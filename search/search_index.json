{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"PHP Kafka Client","text":"<p>This is a Kafka client library for PHP ^7.4 and ^8.0 with a slim librdkafka binding via  FFI.</p> <p>It supports the same interfaces as the PHP RdKafka extension ^5.0 and ^6.0.</p>"},{"location":"#supported-features","title":"Supported Features","text":"<ul> <li>Consumer (low and high level)</li> <li>Producer (with support for transactional producing)</li> <li>Admin Client</li> <li>Mock Cluster to simplify integration tests (even with error situations)</li> <li>Support for error handling and logging via callbacks</li> </ul>"},{"location":"#runtime-requirements","title":"Runtime Requirements","text":"<ul> <li>PHP ^7.4 or ^8.0 with extensions FFI enabled</li> <li>librdkafka ^1.0.0 or ^2.0.0</li> <li>Conflicts: RdKafka extension</li> <li>Suggested:<ul> <li>zend opcache extension for preloading</li> <li>pcntl extension for faster shutdown in request/response context</li> </ul> </li> </ul> <p>Note: From PHP 8.3 onwards, you must disable the stack overflow check by setting <code>zend.max_allowed_stack_size=-1</code> in your php.ini. This is necessary because FFI callbacks are executed off the main thread, and the overflow checks do not handle this scenario properly.</p> <p>Note: Support for macOS and Windows is experimental.</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>composer require idealo/php-rdkafka-ffi\n</code></pre> <p>Note: Expect breaking changes along all 0.* pre-releases. This changes may depend on upcoming major releases of the RdKafka extension or improved interfaces for the experimental features like transactional producer, mock cluster and admin client.</p>"},{"location":"#documentation","title":"Documentation","text":"<p>https://idealo.github.io/php-rdkafka-ffi/</p>"},{"location":"#changelog","title":"Changelog","text":"<p>See Changelog for details.</p>"},{"location":"#contributing","title":"Contributing","text":"<p>We welcome all kinds of contributions. See the Contribution guide for more details.</p>"},{"location":"#license","title":"License","text":"<p>See License for details.</p>"},{"location":"benchmarks/","title":"Benchmarks","text":"<p>These benchmarks were run with version 0.4.0.</p> <p>Note</p> <p>Please note that these benchmarks depend on asynchronous responses/requests to a Kafka broker.</p>"},{"location":"benchmarks/#suites","title":"Suites","text":"<p>All suites use librdkafka v1.8.2.</p> Tag PHP PHP Config phpbench Config php74_ffi 7.4.25 opcache ffi.json php74_ffi_preload 7.4.25 opcachepreload ffi_preload.json php74_ext 7.4.25RdKafka Extension v4.1.2 opcache ext.json php80_ffi 8.0.12 opcache ffi.json php80_ffi_preload 8.0.12 opcachepreload ffi_preload.json php80_ffi_preload_jit 8.0.12 opcachepreloadjit ffi_preload_jit.json php80_ext 8.0.12RdKafka Extension v5.0.0 opcache ext.json"},{"location":"benchmarks/#runtime-average-ffi-extension","title":"Runtime Average FFI &lt;&gt; Extension","text":""},{"location":"benchmarks/#raw-reports-env-data","title":"Raw reports &amp; env data","text":"<p>See https://github.com/idealo/php-rdkafka-ffi/tree/main/benchmarks/reports</p>"},{"location":"benchmarks/#setup","title":"Setup","text":"<ul> <li>Hetzner CCX21 Cloud Server (dedicated 4 vCPU, 16 GB Ram, NVMe SSD)</li> <li>Ubuntu 20.04</li> <li>docker ce 20.10.9</li> <li>docker-compose with images for php 7.4 / 8.0 and librdkafka 1.8.2 installed<ul> <li>see https://github.com/idealo/php-rdkafka-ffi/blob/main/docker-compose.yml</li> <li>see https://github.com/idealo/php-rdkafka-ffi/tree/main/resources/docker</li> </ul> </li> </ul>"},{"location":"benchmarks/#run-benchmarks","title":"Run benchmarks","text":"<p>See running benchmarks in try out.</p> <p>There are ansible playbooks in resources to setup and run benchmarks.</p>"},{"location":"api/","title":"Overview","text":""},{"location":"api/#traits","title":"Traits","text":"<ul> <li>\\RdKafka\\FFI\\Methods \ud83e\udd0d</li> </ul>"},{"location":"api/#classes","title":"Classes","text":"<ul> <li>\\RdKafka \ud83d\udc9b</li> <li>\\RdKafka\\Admin\\AlterConfigsOptions \ud83d\udc9a</li> <li>\\RdKafka\\Admin\\Client \ud83d\udc9b</li> <li>\\RdKafka\\Admin\\ConfigEntry \ud83d\udc9a</li> <li>\\RdKafka\\Admin\\ConfigResource \ud83d\udc9a</li> <li>\\RdKafka\\Admin\\ConfigResourceResult \ud83d\udc9a</li> <li>\\RdKafka\\Admin\\CreatePartitionsOptions \ud83d\udc9a</li> <li>\\RdKafka\\Admin\\CreateTopicsOptions \ud83d\udc9a</li> <li>\\RdKafka\\Admin\\DeleteConsumerGroupOffsets \u2764\ufe0f</li> <li>\\RdKafka\\Admin\\DeleteConsumerGroupOffsetsOptions \u2764\ufe0f</li> <li>\\RdKafka\\Admin\\DeleteGroup \u2764\ufe0f</li> <li>\\RdKafka\\Admin\\DeleteGroupsOptions \u2764\ufe0f</li> <li>\\RdKafka\\Admin\\DeleteRecords \ud83e\udde1</li> <li>\\RdKafka\\Admin\\DeleteRecordsOptions \ud83d\udc9a</li> <li>\\RdKafka\\Admin\\DeleteTopic \ud83e\udde1</li> <li>\\RdKafka\\Admin\\DeleteTopicsOptions \ud83d\udc9a</li> <li>\\RdKafka\\Admin\\DescribeConfigsOptions \ud83d\udc9a</li> <li>\\RdKafka\\Admin\\GroupResult \u2764\ufe0f</li> <li>\\RdKafka\\Admin\\NewPartitions \ud83d\udc9a</li> <li>\\RdKafka\\Admin\\NewTopic \ud83d\udc9b</li> <li>\\RdKafka\\Admin\\Options \ud83d\udc9b</li> <li>\\RdKafka\\Admin\\TopicResult \ud83d\udc9a</li> <li>\\RdKafka\\Conf \ud83d\udc9a</li> <li>\\RdKafka\\Consumer \ud83d\udc9a</li> <li>\\RdKafka\\ConsumerTopic \ud83d\udc9b</li> <li>\\RdKafka\\Event \ud83d\udc9b</li> <li>\\RdKafka\\Exception \ud83d\udc9a</li> <li>\\RdKafka\\FFI\\CallbackProxy \ud83d\udc9a</li> <li>\\RdKafka\\FFI\\ConsumeCallbackProxy \ud83d\udc9a</li> <li>\\RdKafka\\FFI\\DrMsgCallbackProxy \ud83d\udc9a</li> <li>\\RdKafka\\FFI\\ErrorCallbackProxy \ud83d\udc9a</li> <li>\\RdKafka\\FFI\\Library \ud83d\udc9b</li> <li>\\RdKafka\\FFI\\LogCallbackProxy \ud83d\udc9a</li> <li>\\RdKafka\\FFI\\NativePartitionerCallbackProxy \ud83d\udc9a</li> <li>\\RdKafka\\FFI\\OffsetCommitCallbackProxy \ud83d\udc9a</li> <li>\\RdKafka\\FFI\\OpaqueMap \ud83d\udc9a</li> <li>\\RdKafka\\FFI\\PartitionerCallbackProxy \ud83d\udc9a</li> <li>\\RdKafka\\FFI\\RebalanceCallbackProxy \ud83d\udc9a</li> <li>\\RdKafka\\FFI\\StatsCallbackProxy \ud83d\udc9a</li> <li>\\RdKafka\\KafkaConsumer \ud83d\udc9b</li> <li>\\RdKafka\\KafkaConsumerTopic \ud83d\udc9b</li> <li>\\RdKafka\\KafkaErrorException \ud83d\udc9a</li> <li>\\RdKafka\\Message \ud83d\udc9b</li> <li>\\RdKafka\\Metadata \ud83d\udc9a</li> <li>\\RdKafka\\Metadata\\Broker \ud83d\udc9a</li> <li>\\RdKafka\\Metadata\\Collection \ud83d\udc9a</li> <li>\\RdKafka\\Metadata\\Partition \ud83d\udc9b</li> <li>\\RdKafka\\Metadata\\Topic \ud83d\udc9a</li> <li>\\RdKafka\\Producer \ud83d\udc9b</li> <li>\\RdKafka\\ProducerTopic \ud83d\udc9b</li> <li>\\RdKafka\\Queue \ud83d\udc9b</li> <li>\\RdKafka\\Test\\ApiKey \u2764\ufe0f</li> <li>\\RdKafka\\Test\\MockCluster \ud83e\udde1</li> <li>\\RdKafka\\Topic \ud83d\udc9b</li> <li>\\RdKafka\\TopicConf \ud83d\udc9b</li> <li>\\RdKafka\\TopicPartition \ud83d\udc9a</li> <li>\\RdKafka\\TopicPartitionList \ud83d\udc9a</li> </ul>"},{"location":"api/#functions","title":"Functions","text":"<ul> <li>\\rd_kafka_err2name()</li> <li>\\rd_kafka_err2str()</li> <li>\\rd_kafka_errno()</li> <li>\\rd_kafka_errno2err()</li> <li>\\rd_kafka_offset_tail()</li> <li>\\rd_kafka_thread_cnt()</li> <li>\\rd_kafka_version()</li> </ul>"},{"location":"api/#constants","title":"Constants","text":"<ul> <li>\\RD_KAFKA_ACL_OPERATION_ALL</li> <li>\\RD_KAFKA_ACL_OPERATION_ALTER</li> <li>\\RD_KAFKA_ACL_OPERATION_ALTER_CONFIGS</li> <li>\\RD_KAFKA_ACL_OPERATION_ANY</li> <li>\\RD_KAFKA_ACL_OPERATION_CLUSTER_ACTION</li> <li>\\RD_KAFKA_ACL_OPERATION_CREATE</li> <li>\\RD_KAFKA_ACL_OPERATION_DELETE</li> <li>\\RD_KAFKA_ACL_OPERATION_DESCRIBE</li> <li>\\RD_KAFKA_ACL_OPERATION_DESCRIBE_CONFIGS</li> <li>\\RD_KAFKA_ACL_OPERATION_IDEMPOTENT_WRITE</li> <li>\\RD_KAFKA_ACL_OPERATION_READ</li> <li>\\RD_KAFKA_ACL_OPERATION_UNKNOWN</li> <li>\\RD_KAFKA_ACL_OPERATION_WRITE</li> <li>\\RD_KAFKA_ACL_OPERATION__CNT</li> <li>\\RD_KAFKA_ACL_PERMISSION_TYPE_ALLOW</li> <li>\\RD_KAFKA_ACL_PERMISSION_TYPE_ANY</li> <li>\\RD_KAFKA_ACL_PERMISSION_TYPE_DENY</li> <li>\\RD_KAFKA_ACL_PERMISSION_TYPE_UNKNOWN</li> <li>\\RD_KAFKA_ACL_PERMISSION_TYPE__CNT</li> <li>\\RD_KAFKA_ADMIN_OP_ALTERCONFIGS</li> <li>\\RD_KAFKA_ADMIN_OP_ALTERCONSUMERGROUPOFFSETS</li> <li>\\RD_KAFKA_ADMIN_OP_ALTERUSERSCRAMCREDENTIALS</li> <li>\\RD_KAFKA_ADMIN_OP_ANY</li> <li>\\RD_KAFKA_ADMIN_OP_CREATEACLS</li> <li>\\RD_KAFKA_ADMIN_OP_CREATEPARTITIONS</li> <li>\\RD_KAFKA_ADMIN_OP_CREATETOPICS</li> <li>\\RD_KAFKA_ADMIN_OP_DELETEACLS</li> <li>\\RD_KAFKA_ADMIN_OP_DELETECONSUMERGROUPOFFSETS</li> <li>\\RD_KAFKA_ADMIN_OP_DELETEGROUPS</li> <li>\\RD_KAFKA_ADMIN_OP_DELETERECORDS</li> <li>\\RD_KAFKA_ADMIN_OP_DELETETOPICS</li> <li>\\RD_KAFKA_ADMIN_OP_DESCRIBEACLS</li> <li>\\RD_KAFKA_ADMIN_OP_DESCRIBECLUSTER</li> <li>\\RD_KAFKA_ADMIN_OP_DESCRIBECONFIGS</li> <li>\\RD_KAFKA_ADMIN_OP_DESCRIBECONSUMERGROUPS</li> <li>\\RD_KAFKA_ADMIN_OP_DESCRIBETOPICS</li> <li>\\RD_KAFKA_ADMIN_OP_DESCRIBEUSERSCRAMCREDENTIALS</li> <li>\\RD_KAFKA_ADMIN_OP_ELECTLEADERS</li> <li>\\RD_KAFKA_ADMIN_OP_INCREMENTALALTERCONFIGS</li> <li>\\RD_KAFKA_ADMIN_OP_LISTCONSUMERGROUPOFFSETS</li> <li>\\RD_KAFKA_ADMIN_OP_LISTCONSUMERGROUPS</li> <li>\\RD_KAFKA_ADMIN_OP_LISTOFFSETS</li> <li>\\RD_KAFKA_ADMIN_OP__CNT</li> <li>\\RD_KAFKA_ADMIN_OP__CNT</li> <li>\\RD_KAFKA_ADMIN_OP__CNT</li> <li>\\RD_KAFKA_ADMIN_OP__CNT</li> <li>\\RD_KAFKA_ADMIN_OP__CNT</li> <li>\\RD_KAFKA_ADMIN_OP__CNT</li> <li>\\RD_KAFKA_ADMIN_OP__CNT</li> <li>\\RD_KAFKA_ADMIN_OP__CNT</li> <li>\\RD_KAFKA_ADMIN_OP__CNT</li> <li>\\RD_KAFKA_ADMIN_OP__CNT</li> <li>\\RD_KAFKA_ADMIN_OP__CNT</li> <li>\\RD_KAFKA_ADMIN_OP__CNT</li> <li>\\RD_KAFKA_ADMIN_OP__CNT</li> <li>\\RD_KAFKA_ADMIN_OP__CNT</li> <li>\\RD_KAFKA_ADMIN_OP__CNT</li> <li>\\RD_KAFKA_ADMIN_OP__CNT</li> <li>\\RD_KAFKA_ADMIN_OP__CNT</li> <li>\\RD_KAFKA_ADMIN_OP__CNT</li> <li>\\RD_KAFKA_ADMIN_OP__CNT</li> <li>\\RD_KAFKA_ADMIN_OP__CNT</li> <li>\\RD_KAFKA_ADMIN_OP__CNT</li> <li>\\RD_KAFKA_ADMIN_OP__CNT</li> <li>\\RD_KAFKA_ADMIN_OP__CNT</li> <li>\\RD_KAFKA_ADMIN_OP__CNT</li> <li>\\RD_KAFKA_ADMIN_OP__CNT</li> <li>\\RD_KAFKA_ADMIN_OP__CNT</li> <li>\\RD_KAFKA_ADMIN_OP__CNT</li> <li>\\RD_KAFKA_ADMIN_OP__CNT</li> <li>\\RD_KAFKA_ADMIN_OP__CNT</li> <li>\\RD_KAFKA_ADMIN_OP__CNT</li> <li>\\RD_KAFKA_ADMIN_OP__CNT</li> <li>\\RD_KAFKA_ADMIN_OP__CNT</li> <li>\\RD_KAFKA_ADMIN_OP__CNT</li> <li>\\RD_KAFKA_ADMIN_OP__CNT</li> <li>\\RD_KAFKA_ADMIN_OP__CNT</li> <li>\\RD_KAFKA_ADMIN_OP__CNT</li> <li>\\RD_KAFKA_ALTER_CONFIG_OP_TYPE_APPEND</li> <li>\\RD_KAFKA_ALTER_CONFIG_OP_TYPE_DELETE</li> <li>\\RD_KAFKA_ALTER_CONFIG_OP_TYPE_SET</li> <li>\\RD_KAFKA_ALTER_CONFIG_OP_TYPE_SUBTRACT</li> <li>\\RD_KAFKA_ALTER_CONFIG_OP_TYPE__CNT</li> <li>\\RD_KAFKA_CDEF</li> <li>\\RD_KAFKA_CDEF</li> <li>\\RD_KAFKA_CDEF</li> <li>\\RD_KAFKA_CDEF</li> <li>\\RD_KAFKA_CDEF</li> <li>\\RD_KAFKA_CDEF</li> <li>\\RD_KAFKA_CDEF</li> <li>\\RD_KAFKA_CDEF</li> <li>\\RD_KAFKA_CDEF</li> <li>\\RD_KAFKA_CDEF</li> <li>\\RD_KAFKA_CDEF</li> <li>\\RD_KAFKA_CDEF</li> <li>\\RD_KAFKA_CDEF</li> <li>\\RD_KAFKA_CDEF</li> <li>\\RD_KAFKA_CDEF</li> <li>\\RD_KAFKA_CDEF</li> <li>\\RD_KAFKA_CDEF</li> <li>\\RD_KAFKA_CDEF</li> <li>\\RD_KAFKA_CDEF</li> <li>\\RD_KAFKA_CDEF</li> <li>\\RD_KAFKA_CDEF</li> <li>\\RD_KAFKA_CDEF</li> <li>\\RD_KAFKA_CDEF</li> <li>\\RD_KAFKA_CDEF</li> <li>\\RD_KAFKA_CDEF</li> <li>\\RD_KAFKA_CDEF</li> <li>\\RD_KAFKA_CDEF</li> <li>\\RD_KAFKA_CDEF</li> <li>\\RD_KAFKA_CDEF</li> <li>\\RD_KAFKA_CDEF</li> <li>\\RD_KAFKA_CDEF</li> <li>\\RD_KAFKA_CDEF</li> <li>\\RD_KAFKA_CDEF</li> <li>\\RD_KAFKA_CDEF</li> <li>\\RD_KAFKA_CDEF</li> <li>\\RD_KAFKA_CDEF</li> <li>\\RD_KAFKA_CERT_CA</li> <li>\\RD_KAFKA_CERT_ENC_DER</li> <li>\\RD_KAFKA_CERT_ENC_PEM</li> <li>\\RD_KAFKA_CERT_ENC_PKCS12</li> <li>\\RD_KAFKA_CERT_ENC__CNT</li> <li>\\RD_KAFKA_CERT_PRIVATE_KEY</li> <li>\\RD_KAFKA_CERT_PUBLIC_KEY</li> <li>\\RD_KAFKA_CERT__CNT</li> <li>\\RD_KAFKA_CONFIG_SOURCE_DEFAULT_CONFIG</li> <li>\\RD_KAFKA_CONFIG_SOURCE_DYNAMIC_BROKER_CONFIG</li> <li>\\RD_KAFKA_CONFIG_SOURCE_DYNAMIC_DEFAULT_BROKER_CONFIG</li> <li>\\RD_KAFKA_CONFIG_SOURCE_DYNAMIC_TOPIC_CONFIG</li> <li>\\RD_KAFKA_CONFIG_SOURCE_STATIC_BROKER_CONFIG</li> <li>\\RD_KAFKA_CONFIG_SOURCE_UNKNOWN_CONFIG</li> <li>\\RD_KAFKA_CONFIG_SOURCE__CNT</li> <li>\\RD_KAFKA_CONF_INVALID</li> <li>\\RD_KAFKA_CONF_OK</li> <li>\\RD_KAFKA_CONF_UNKNOWN</li> <li>\\RD_KAFKA_CONSUMER</li> <li>\\RD_KAFKA_CONSUMER_GROUP_STATE_COMPLETING_REBALANCE</li> <li>\\RD_KAFKA_CONSUMER_GROUP_STATE_DEAD</li> <li>\\RD_KAFKA_CONSUMER_GROUP_STATE_EMPTY</li> <li>\\RD_KAFKA_CONSUMER_GROUP_STATE_PREPARING_REBALANCE</li> <li>\\RD_KAFKA_CONSUMER_GROUP_STATE_STABLE</li> <li>\\RD_KAFKA_CONSUMER_GROUP_STATE_UNKNOWN</li> <li>\\RD_KAFKA_CONSUMER_GROUP_STATE__CNT</li> <li>\\RD_KAFKA_CONSUMER_GROUP_TYPE_CLASSIC</li> <li>\\RD_KAFKA_CONSUMER_GROUP_TYPE_CONSUMER</li> <li>\\RD_KAFKA_CONSUMER_GROUP_TYPE_UNKNOWN</li> <li>\\RD_KAFKA_CONSUMER_GROUP_TYPE__CNT</li> <li>\\RD_KAFKA_DESTROY_F_NO_CONSUMER_CLOSE</li> <li>\\RD_KAFKA_ELECTION_TYPE_PREFERRED</li> <li>\\RD_KAFKA_ELECTION_TYPE_UNCLEAN</li> <li>\\RD_KAFKA_EVENT_ALTERCONFIGS_RESULT</li> <li>\\RD_KAFKA_EVENT_ALTERCONSUMERGROUPOFFSETS_RESULT</li> <li>\\RD_KAFKA_EVENT_ALTERUSERSCRAMCREDENTIALS_RESULT</li> <li>\\RD_KAFKA_EVENT_BACKGROUND</li> <li>\\RD_KAFKA_EVENT_CREATEACLS_RESULT</li> <li>\\RD_KAFKA_EVENT_CREATEPARTITIONS_RESULT</li> <li>\\RD_KAFKA_EVENT_CREATETOPICS_RESULT</li> <li>\\RD_KAFKA_EVENT_DELETEACLS_RESULT</li> <li>\\RD_KAFKA_EVENT_DELETECONSUMERGROUPOFFSETS_RESULT</li> <li>\\RD_KAFKA_EVENT_DELETEGROUPS_RESULT</li> <li>\\RD_KAFKA_EVENT_DELETERECORDS_RESULT</li> <li>\\RD_KAFKA_EVENT_DELETETOPICS_RESULT</li> <li>\\RD_KAFKA_EVENT_DESCRIBEACLS_RESULT</li> <li>\\RD_KAFKA_EVENT_DESCRIBECLUSTER_RESULT</li> <li>\\RD_KAFKA_EVENT_DESCRIBECONFIGS_RESULT</li> <li>\\RD_KAFKA_EVENT_DESCRIBECONSUMERGROUPS_RESULT</li> <li>\\RD_KAFKA_EVENT_DESCRIBETOPICS_RESULT</li> <li>\\RD_KAFKA_EVENT_DESCRIBEUSERSCRAMCREDENTIALS_RESULT</li> <li>\\RD_KAFKA_EVENT_DR</li> <li>\\RD_KAFKA_EVENT_ELECTLEADERS_RESULT</li> <li>\\RD_KAFKA_EVENT_ERROR</li> <li>\\RD_KAFKA_EVENT_FETCH</li> <li>\\RD_KAFKA_EVENT_INCREMENTALALTERCONFIGS_RESULT</li> <li>\\RD_KAFKA_EVENT_LISTCONSUMERGROUPOFFSETS_RESULT</li> <li>\\RD_KAFKA_EVENT_LISTCONSUMERGROUPS_RESULT</li> <li>\\RD_KAFKA_EVENT_LISTOFFSETS_RESULT</li> <li>\\RD_KAFKA_EVENT_LOG</li> <li>\\RD_KAFKA_EVENT_NONE</li> <li>\\RD_KAFKA_EVENT_OAUTHBEARER_TOKEN_REFRESH</li> <li>\\RD_KAFKA_EVENT_OFFSET_COMMIT</li> <li>\\RD_KAFKA_EVENT_REBALANCE</li> <li>\\RD_KAFKA_EVENT_STATS</li> <li>\\RD_KAFKA_ISOLATION_LEVEL_READ_COMMITTED</li> <li>\\RD_KAFKA_ISOLATION_LEVEL_READ_UNCOMMITTED</li> <li>\\RD_KAFKA_LOG_PRINT</li> <li>\\RD_KAFKA_LOG_SYSLOG</li> <li>\\RD_KAFKA_LOG_SYSLOG_PRINT</li> <li>\\RD_KAFKA_MSG_F_BLOCK</li> <li>\\RD_KAFKA_MSG_F_COPY</li> <li>\\RD_KAFKA_MSG_F_FREE</li> <li>\\RD_KAFKA_MSG_F_PARTITION</li> <li>\\RD_KAFKA_MSG_PARTITIONER_CONSISTENT</li> <li>\\RD_KAFKA_MSG_PARTITIONER_CONSISTENT_RANDOM</li> <li>\\RD_KAFKA_MSG_PARTITIONER_FNV1A</li> <li>\\RD_KAFKA_MSG_PARTITIONER_FNV1A_RANDOM</li> <li>\\RD_KAFKA_MSG_PARTITIONER_MURMUR2</li> <li>\\RD_KAFKA_MSG_PARTITIONER_MURMUR2_RANDOM</li> <li>\\RD_KAFKA_MSG_PARTITIONER_RANDOM</li> <li>\\RD_KAFKA_MSG_STATUS_NOT_PERSISTED</li> <li>\\RD_KAFKA_MSG_STATUS_PERSISTED</li> <li>\\RD_KAFKA_MSG_STATUS_POSSIBLY_PERSISTED</li> <li>\\RD_KAFKA_OFFSET_BEGINNING</li> <li>\\RD_KAFKA_OFFSET_END</li> <li>\\RD_KAFKA_OFFSET_INVALID</li> <li>\\RD_KAFKA_OFFSET_SPEC_EARLIEST</li> <li>\\RD_KAFKA_OFFSET_SPEC_LATEST</li> <li>\\RD_KAFKA_OFFSET_SPEC_MAX_TIMESTAMP</li> <li>\\RD_KAFKA_OFFSET_STORED</li> <li>\\RD_KAFKA_OFFSET_TAIL_BASE</li> <li>\\RD_KAFKA_PARTITION_UA</li> <li>\\RD_KAFKA_PRODUCER</li> <li>\\RD_KAFKA_PURGE_F_INFLIGHT</li> <li>\\RD_KAFKA_PURGE_F_NON_BLOCKING</li> <li>\\RD_KAFKA_PURGE_F_QUEUE</li> <li>\\RD_KAFKA_RESOURCE_ANY</li> <li>\\RD_KAFKA_RESOURCE_BROKER</li> <li>\\RD_KAFKA_RESOURCE_GROUP</li> <li>\\RD_KAFKA_RESOURCE_PATTERN_ANY</li> <li>\\RD_KAFKA_RESOURCE_PATTERN_LITERAL</li> <li>\\RD_KAFKA_RESOURCE_PATTERN_MATCH</li> <li>\\RD_KAFKA_RESOURCE_PATTERN_PREFIXED</li> <li>\\RD_KAFKA_RESOURCE_PATTERN_TYPE__CNT</li> <li>\\RD_KAFKA_RESOURCE_PATTERN_UNKNOWN</li> <li>\\RD_KAFKA_RESOURCE_TOPIC</li> <li>\\RD_KAFKA_RESOURCE_TRANSACTIONAL_ID</li> <li>\\RD_KAFKA_RESOURCE_UNKNOWN</li> <li>\\RD_KAFKA_RESOURCE__CNT</li> <li>\\RD_KAFKA_RESOURCE__CNT</li> <li>\\RD_KAFKA_RESOURCE__CNT</li> <li>\\RD_KAFKA_RESOURCE__CNT</li> <li>\\RD_KAFKA_RESOURCE__CNT</li> <li>\\RD_KAFKA_RESOURCE__CNT</li> <li>\\RD_KAFKA_RESOURCE__CNT</li> <li>\\RD_KAFKA_RESOURCE__CNT</li> <li>\\RD_KAFKA_RESOURCE__CNT</li> <li>\\RD_KAFKA_RESOURCE__CNT</li> <li>\\RD_KAFKA_RESOURCE__CNT</li> <li>\\RD_KAFKA_RESOURCE__CNT</li> <li>\\RD_KAFKA_RESOURCE__CNT</li> <li>\\RD_KAFKA_RESOURCE__CNT</li> <li>\\RD_KAFKA_RESOURCE__CNT</li> <li>\\RD_KAFKA_RESOURCE__CNT</li> <li>\\RD_KAFKA_RESOURCE__CNT</li> <li>\\RD_KAFKA_RESOURCE__CNT</li> <li>\\RD_KAFKA_RESOURCE__CNT</li> <li>\\RD_KAFKA_RESOURCE__CNT</li> <li>\\RD_KAFKA_RESOURCE__CNT</li> <li>\\RD_KAFKA_RESOURCE__CNT</li> <li>\\RD_KAFKA_RESOURCE__CNT</li> <li>\\RD_KAFKA_RESOURCE__CNT</li> <li>\\RD_KAFKA_RESOURCE__CNT</li> <li>\\RD_KAFKA_RESOURCE__CNT</li> <li>\\RD_KAFKA_RESOURCE__CNT</li> <li>\\RD_KAFKA_RESOURCE__CNT</li> <li>\\RD_KAFKA_RESOURCE__CNT</li> <li>\\RD_KAFKA_RESOURCE__CNT</li> <li>\\RD_KAFKA_RESOURCE__CNT</li> <li>\\RD_KAFKA_RESOURCE__CNT</li> <li>\\RD_KAFKA_RESOURCE__CNT</li> <li>\\RD_KAFKA_RESOURCE__CNT</li> <li>\\RD_KAFKA_RESOURCE__CNT</li> <li>\\RD_KAFKA_RESOURCE__CNT</li> <li>\\RD_KAFKA_RESP_ERR_BROKER_NOT_AVAILABLE</li> <li>\\RD_KAFKA_RESP_ERR_CLUSTER_AUTHORIZATION_FAILED</li> <li>\\RD_KAFKA_RESP_ERR_CONCURRENT_TRANSACTIONS</li> <li>\\RD_KAFKA_RESP_ERR_COORDINATOR_LOAD_IN_PROGRESS</li> <li>\\RD_KAFKA_RESP_ERR_COORDINATOR_NOT_AVAILABLE</li> <li>\\RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTHORIZATION_FAILED</li> <li>\\RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTH_DISABLED</li> <li>\\RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_EXPIRED</li> <li>\\RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_NOT_FOUND</li> <li>\\RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_OWNER_MISMATCH</li> <li>\\RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_REQUEST_NOT_ALLOWED</li> <li>\\RD_KAFKA_RESP_ERR_DUPLICATE_RESOURCE</li> <li>\\RD_KAFKA_RESP_ERR_DUPLICATE_SEQUENCE_NUMBER</li> <li>\\RD_KAFKA_RESP_ERR_ELECTION_NOT_NEEDED</li> <li>\\RD_KAFKA_RESP_ERR_ELIGIBLE_LEADERS_NOT_AVAILABLE</li> <li>\\RD_KAFKA_RESP_ERR_END_ALL</li> <li>\\RD_KAFKA_RESP_ERR_END_ALL</li> <li>\\RD_KAFKA_RESP_ERR_END_ALL</li> <li>\\RD_KAFKA_RESP_ERR_END_ALL</li> <li>\\RD_KAFKA_RESP_ERR_END_ALL</li> <li>\\RD_KAFKA_RESP_ERR_END_ALL</li> <li>\\RD_KAFKA_RESP_ERR_END_ALL</li> <li>\\RD_KAFKA_RESP_ERR_END_ALL</li> <li>\\RD_KAFKA_RESP_ERR_END_ALL</li> <li>\\RD_KAFKA_RESP_ERR_END_ALL</li> <li>\\RD_KAFKA_RESP_ERR_END_ALL</li> <li>\\RD_KAFKA_RESP_ERR_END_ALL</li> <li>\\RD_KAFKA_RESP_ERR_END_ALL</li> <li>\\RD_KAFKA_RESP_ERR_END_ALL</li> <li>\\RD_KAFKA_RESP_ERR_END_ALL</li> <li>\\RD_KAFKA_RESP_ERR_END_ALL</li> <li>\\RD_KAFKA_RESP_ERR_END_ALL</li> <li>\\RD_KAFKA_RESP_ERR_END_ALL</li> <li>\\RD_KAFKA_RESP_ERR_END_ALL</li> <li>\\RD_KAFKA_RESP_ERR_END_ALL</li> <li>\\RD_KAFKA_RESP_ERR_END_ALL</li> <li>\\RD_KAFKA_RESP_ERR_END_ALL</li> <li>\\RD_KAFKA_RESP_ERR_END_ALL</li> <li>\\RD_KAFKA_RESP_ERR_END_ALL</li> <li>\\RD_KAFKA_RESP_ERR_END_ALL</li> <li>\\RD_KAFKA_RESP_ERR_END_ALL</li> <li>\\RD_KAFKA_RESP_ERR_END_ALL</li> <li>\\RD_KAFKA_RESP_ERR_END_ALL</li> <li>\\RD_KAFKA_RESP_ERR_END_ALL</li> <li>\\RD_KAFKA_RESP_ERR_END_ALL</li> <li>\\RD_KAFKA_RESP_ERR_END_ALL</li> <li>\\RD_KAFKA_RESP_ERR_END_ALL</li> <li>\\RD_KAFKA_RESP_ERR_END_ALL</li> <li>\\RD_KAFKA_RESP_ERR_END_ALL</li> <li>\\RD_KAFKA_RESP_ERR_END_ALL</li> <li>\\RD_KAFKA_RESP_ERR_END_ALL</li> <li>\\RD_KAFKA_RESP_ERR_FEATURE_UPDATE_FAILED</li> <li>\\RD_KAFKA_RESP_ERR_FENCED_INSTANCE_ID</li> <li>\\RD_KAFKA_RESP_ERR_FENCED_LEADER_EPOCH</li> <li>\\RD_KAFKA_RESP_ERR_FENCED_MEMBER_EPOCH</li> <li>\\RD_KAFKA_RESP_ERR_FETCH_SESSION_ID_NOT_FOUND</li> <li>\\RD_KAFKA_RESP_ERR_GROUP_AUTHORIZATION_FAILED</li> <li>\\RD_KAFKA_RESP_ERR_GROUP_COORDINATOR_NOT_AVAILABLE</li> <li>\\RD_KAFKA_RESP_ERR_GROUP_ID_NOT_FOUND</li> <li>\\RD_KAFKA_RESP_ERR_GROUP_LOAD_IN_PROGRESS</li> <li>\\RD_KAFKA_RESP_ERR_GROUP_MAX_SIZE_REACHED</li> <li>\\RD_KAFKA_RESP_ERR_GROUP_SUBSCRIBED_TO_TOPIC</li> <li>\\RD_KAFKA_RESP_ERR_ILLEGAL_GENERATION</li> <li>\\RD_KAFKA_RESP_ERR_ILLEGAL_SASL_STATE</li> <li>\\RD_KAFKA_RESP_ERR_INCONSISTENT_GROUP_PROTOCOL</li> <li>\\RD_KAFKA_RESP_ERR_INCONSISTENT_VOTER_SET</li> <li>\\RD_KAFKA_RESP_ERR_INVALID_COMMIT_OFFSET_SIZE</li> <li>\\RD_KAFKA_RESP_ERR_INVALID_CONFIG</li> <li>\\RD_KAFKA_RESP_ERR_INVALID_FETCH_SESSION_EPOCH</li> <li>\\RD_KAFKA_RESP_ERR_INVALID_GROUP_ID</li> <li>\\RD_KAFKA_RESP_ERR_INVALID_MSG</li> <li>\\RD_KAFKA_RESP_ERR_INVALID_MSG_SIZE</li> <li>\\RD_KAFKA_RESP_ERR_INVALID_PARTITIONS</li> <li>\\RD_KAFKA_RESP_ERR_INVALID_PRINCIPAL_TYPE</li> <li>\\RD_KAFKA_RESP_ERR_INVALID_PRODUCER_EPOCH</li> <li>\\RD_KAFKA_RESP_ERR_INVALID_PRODUCER_ID_MAPPING</li> <li>\\RD_KAFKA_RESP_ERR_INVALID_RECORD</li> <li>\\RD_KAFKA_RESP_ERR_INVALID_REPLICATION_FACTOR</li> <li>\\RD_KAFKA_RESP_ERR_INVALID_REPLICA_ASSIGNMENT</li> <li>\\RD_KAFKA_RESP_ERR_INVALID_REQUEST</li> <li>\\RD_KAFKA_RESP_ERR_INVALID_REQUIRED_ACKS</li> <li>\\RD_KAFKA_RESP_ERR_INVALID_SESSION_TIMEOUT</li> <li>\\RD_KAFKA_RESP_ERR_INVALID_TIMESTAMP</li> <li>\\RD_KAFKA_RESP_ERR_INVALID_TRANSACTION_TIMEOUT</li> <li>\\RD_KAFKA_RESP_ERR_INVALID_TXN_STATE</li> <li>\\RD_KAFKA_RESP_ERR_INVALID_UPDATE_VERSION</li> <li>\\RD_KAFKA_RESP_ERR_KAFKA_STORAGE_ERROR</li> <li>\\RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE</li> <li>\\RD_KAFKA_RESP_ERR_LISTENER_NOT_FOUND</li> <li>\\RD_KAFKA_RESP_ERR_LOG_DIR_NOT_FOUND</li> <li>\\RD_KAFKA_RESP_ERR_MEMBER_ID_REQUIRED</li> <li>\\RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE</li> <li>\\RD_KAFKA_RESP_ERR_NETWORK_EXCEPTION</li> <li>\\RD_KAFKA_RESP_ERR_NON_EMPTY_GROUP</li> <li>\\RD_KAFKA_RESP_ERR_NOT_CONTROLLER</li> <li>\\RD_KAFKA_RESP_ERR_NOT_COORDINATOR</li> <li>\\RD_KAFKA_RESP_ERR_NOT_COORDINATOR_FOR_GROUP</li> <li>\\RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS</li> <li>\\RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS_AFTER_APPEND</li> <li>\\RD_KAFKA_RESP_ERR_NOT_LEADER_FOR_PARTITION</li> <li>\\RD_KAFKA_RESP_ERR_NO_ERROR</li> <li>\\RD_KAFKA_RESP_ERR_NO_REASSIGNMENT_IN_PROGRESS</li> <li>\\RD_KAFKA_RESP_ERR_OFFSET_METADATA_TOO_LARGE</li> <li>\\RD_KAFKA_RESP_ERR_OFFSET_NOT_AVAILABLE</li> <li>\\RD_KAFKA_RESP_ERR_OFFSET_OUT_OF_RANGE</li> <li>\\RD_KAFKA_RESP_ERR_OPERATION_NOT_ATTEMPTED</li> <li>\\RD_KAFKA_RESP_ERR_OUT_OF_ORDER_SEQUENCE_NUMBER</li> <li>\\RD_KAFKA_RESP_ERR_POLICY_VIOLATION</li> <li>\\RD_KAFKA_RESP_ERR_PREFERRED_LEADER_NOT_AVAILABLE</li> <li>\\RD_KAFKA_RESP_ERR_PRINCIPAL_DESERIALIZATION_FAILURE</li> <li>\\RD_KAFKA_RESP_ERR_PRODUCER_FENCED</li> <li>\\RD_KAFKA_RESP_ERR_REASSIGNMENT_IN_PROGRESS</li> <li>\\RD_KAFKA_RESP_ERR_REBALANCE_IN_PROGRESS</li> <li>\\RD_KAFKA_RESP_ERR_RECORD_LIST_TOO_LARGE</li> <li>\\RD_KAFKA_RESP_ERR_REPLICA_NOT_AVAILABLE</li> <li>\\RD_KAFKA_RESP_ERR_REQUEST_TIMED_OUT</li> <li>\\RD_KAFKA_RESP_ERR_RESOURCE_NOT_FOUND</li> <li>\\RD_KAFKA_RESP_ERR_SASL_AUTHENTICATION_FAILED</li> <li>\\RD_KAFKA_RESP_ERR_SECURITY_DISABLED</li> <li>\\RD_KAFKA_RESP_ERR_STALE_BROKER_EPOCH</li> <li>\\RD_KAFKA_RESP_ERR_STALE_CTRL_EPOCH</li> <li>\\RD_KAFKA_RESP_ERR_STALE_MEMBER_EPOCH</li> <li>\\RD_KAFKA_RESP_ERR_TELEMETRY_TOO_LARGE</li> <li>\\RD_KAFKA_RESP_ERR_THROTTLING_QUOTA_EXCEEDED</li> <li>\\RD_KAFKA_RESP_ERR_TOPIC_ALREADY_EXISTS</li> <li>\\RD_KAFKA_RESP_ERR_TOPIC_AUTHORIZATION_FAILED</li> <li>\\RD_KAFKA_RESP_ERR_TOPIC_DELETION_DISABLED</li> <li>\\RD_KAFKA_RESP_ERR_TOPIC_EXCEPTION</li> <li>\\RD_KAFKA_RESP_ERR_TRANSACTIONAL_ID_AUTHORIZATION_FAILED</li> <li>\\RD_KAFKA_RESP_ERR_TRANSACTION_COORDINATOR_FENCED</li> <li>\\RD_KAFKA_RESP_ERR_UNACCEPTABLE_CREDENTIAL</li> <li>\\RD_KAFKA_RESP_ERR_UNKNOWN</li> <li>\\RD_KAFKA_RESP_ERR_UNKNOWN_LEADER_EPOCH</li> <li>\\RD_KAFKA_RESP_ERR_UNKNOWN_MEMBER_ID</li> <li>\\RD_KAFKA_RESP_ERR_UNKNOWN_PRODUCER_ID</li> <li>\\RD_KAFKA_RESP_ERR_UNKNOWN_SUBSCRIPTION_ID</li> <li>\\RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_ID</li> <li>\\RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART</li> <li>\\RD_KAFKA_RESP_ERR_UNRELEASED_INSTANCE_ID</li> <li>\\RD_KAFKA_RESP_ERR_UNSTABLE_OFFSET_COMMIT</li> <li>\\RD_KAFKA_RESP_ERR_UNSUPPORTED_ASSIGNOR</li> <li>\\RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE</li> <li>\\RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE</li> <li>\\RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE</li> <li>\\RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE</li> <li>\\RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE</li> <li>\\RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE</li> <li>\\RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE</li> <li>\\RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE</li> <li>\\RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE</li> <li>\\RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE</li> <li>\\RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE</li> <li>\\RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE</li> <li>\\RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE</li> <li>\\RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE</li> <li>\\RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE</li> <li>\\RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE</li> <li>\\RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE</li> <li>\\RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE</li> <li>\\RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE</li> <li>\\RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE</li> <li>\\RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE</li> <li>\\RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE</li> <li>\\RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE</li> <li>\\RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE</li> <li>\\RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE</li> <li>\\RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE</li> <li>\\RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE</li> <li>\\RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE</li> <li>\\RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE</li> <li>\\RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE</li> <li>\\RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE</li> <li>\\RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE</li> <li>\\RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE</li> <li>\\RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE</li> <li>\\RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE</li> <li>\\RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE</li> <li>\\RD_KAFKA_RESP_ERR_UNSUPPORTED_FOR_MESSAGE_FORMAT</li> <li>\\RD_KAFKA_RESP_ERR_UNSUPPORTED_SASL_MECHANISM</li> <li>\\RD_KAFKA_RESP_ERR_UNSUPPORTED_VERSION</li> <li>\\RD_KAFKA_RESP_ERR__ALL_BROKERS_DOWN</li> <li>\\RD_KAFKA_RESP_ERR__APPLICATION</li> <li>\\RD_KAFKA_RESP_ERR__ASSIGNMENT_LOST</li> <li>\\RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS</li> <li>\\RD_KAFKA_RESP_ERR__AUTHENTICATION</li> <li>\\RD_KAFKA_RESP_ERR__AUTO_OFFSET_RESET</li> <li>\\RD_KAFKA_RESP_ERR__BAD_COMPRESSION</li> <li>\\RD_KAFKA_RESP_ERR__BAD_MSG</li> <li>\\RD_KAFKA_RESP_ERR__BEGIN</li> <li>\\RD_KAFKA_RESP_ERR__CONFLICT</li> <li>\\RD_KAFKA_RESP_ERR__CRIT_SYS_RESOURCE</li> <li>\\RD_KAFKA_RESP_ERR__DESTROY</li> <li>\\RD_KAFKA_RESP_ERR__END</li> <li>\\RD_KAFKA_RESP_ERR__EXISTING_SUBSCRIPTION</li> <li>\\RD_KAFKA_RESP_ERR__FAIL</li> <li>\\RD_KAFKA_RESP_ERR__FATAL</li> <li>\\RD_KAFKA_RESP_ERR__FENCED</li> <li>\\RD_KAFKA_RESP_ERR__FS</li> <li>\\RD_KAFKA_RESP_ERR__GAPLESS_GUARANTEE</li> <li>\\RD_KAFKA_RESP_ERR__INCONSISTENT</li> <li>\\RD_KAFKA_RESP_ERR__INTR</li> <li>\\RD_KAFKA_RESP_ERR__INVALID_ARG</li> <li>\\RD_KAFKA_RESP_ERR__INVALID_DIFFERENT_RECORD</li> <li>\\RD_KAFKA_RESP_ERR__INVALID_TYPE</li> <li>\\RD_KAFKA_RESP_ERR__IN_PROGRESS</li> <li>\\RD_KAFKA_RESP_ERR__ISR_INSUFF</li> <li>\\RD_KAFKA_RESP_ERR__KEY_DESERIALIZATION</li> <li>\\RD_KAFKA_RESP_ERR__KEY_SERIALIZATION</li> <li>\\RD_KAFKA_RESP_ERR__LOG_TRUNCATION</li> <li>\\RD_KAFKA_RESP_ERR__MAX_POLL_EXCEEDED</li> <li>\\RD_KAFKA_RESP_ERR__MSG_TIMED_OUT</li> <li>\\RD_KAFKA_RESP_ERR__NODE_UPDATE</li> <li>\\RD_KAFKA_RESP_ERR__NOENT</li> <li>\\RD_KAFKA_RESP_ERR__NOOP</li> <li>\\RD_KAFKA_RESP_ERR__NOT_CONFIGURED</li> <li>\\RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED</li> <li>\\RD_KAFKA_RESP_ERR__NO_OFFSET</li> <li>\\RD_KAFKA_RESP_ERR__OUTDATED</li> <li>\\RD_KAFKA_RESP_ERR__PARTIAL</li> <li>\\RD_KAFKA_RESP_ERR__PARTITION_EOF</li> <li>\\RD_KAFKA_RESP_ERR__PREV_IN_PROGRESS</li> <li>\\RD_KAFKA_RESP_ERR__PURGE_INFLIGHT</li> <li>\\RD_KAFKA_RESP_ERR__PURGE_QUEUE</li> <li>\\RD_KAFKA_RESP_ERR__QUEUE_FULL</li> <li>\\RD_KAFKA_RESP_ERR__READ_ONLY</li> <li>\\RD_KAFKA_RESP_ERR__RESOLVE</li> <li>\\RD_KAFKA_RESP_ERR__RETRY</li> <li>\\RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS</li> <li>\\RD_KAFKA_RESP_ERR__SSL</li> <li>\\RD_KAFKA_RESP_ERR__STATE</li> <li>\\RD_KAFKA_RESP_ERR__TIMED_OUT</li> <li>\\RD_KAFKA_RESP_ERR__TIMED_OUT_QUEUE</li> <li>\\RD_KAFKA_RESP_ERR__TRANSPORT</li> <li>\\RD_KAFKA_RESP_ERR__UNDERFLOW</li> <li>\\RD_KAFKA_RESP_ERR__UNKNOWN_BROKER</li> <li>\\RD_KAFKA_RESP_ERR__UNKNOWN_GROUP</li> <li>\\RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION</li> <li>\\RD_KAFKA_RESP_ERR__UNKNOWN_PROTOCOL</li> <li>\\RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC</li> <li>\\RD_KAFKA_RESP_ERR__UNSUPPORTED_FEATURE</li> <li>\\RD_KAFKA_RESP_ERR__VALUE_DESERIALIZATION</li> <li>\\RD_KAFKA_RESP_ERR__VALUE_SERIALIZATION</li> <li>\\RD_KAFKA_RESP_ERR__WAIT_CACHE</li> <li>\\RD_KAFKA_RESP_ERR__WAIT_COORD</li> <li>\\RD_KAFKA_SCRAM_MECHANISM_SHA_256</li> <li>\\RD_KAFKA_SCRAM_MECHANISM_SHA_512</li> <li>\\RD_KAFKA_SCRAM_MECHANISM_UNKNOWN</li> <li>\\RD_KAFKA_SCRAM_MECHANISM__CNT</li> <li>\\RD_KAFKA_SUPPORTED_METHODS</li> <li>\\RD_KAFKA_THREAD_BACKGROUND</li> <li>\\RD_KAFKA_THREAD_BROKER</li> <li>\\RD_KAFKA_THREAD_MAIN</li> <li>\\RD_KAFKA_TIMESTAMP_CREATE_TIME</li> <li>\\RD_KAFKA_TIMESTAMP_LOG_APPEND_TIME</li> <li>\\RD_KAFKA_TIMESTAMP_NOT_AVAILABLE</li> <li>\\RD_KAFKA_VERSION</li> <li>\\RD_KAFKA_VERSION</li> <li>\\RD_KAFKA_VERSION</li> <li>\\RD_KAFKA_VERSION</li> <li>\\RD_KAFKA_VERSION</li> <li>\\RD_KAFKA_VERSION</li> <li>\\RD_KAFKA_VERSION</li> <li>\\RD_KAFKA_VERSION</li> <li>\\RD_KAFKA_VERSION</li> <li>\\RD_KAFKA_VERSION</li> <li>\\RD_KAFKA_VERSION</li> <li>\\RD_KAFKA_VERSION</li> <li>\\RD_KAFKA_VERSION</li> <li>\\RD_KAFKA_VERSION</li> <li>\\RD_KAFKA_VERSION</li> <li>\\RD_KAFKA_VERSION</li> <li>\\RD_KAFKA_VERSION</li> <li>\\RD_KAFKA_VERSION</li> <li>\\RD_KAFKA_VERSION</li> <li>\\RD_KAFKA_VERSION</li> <li>\\RD_KAFKA_VERSION</li> <li>\\RD_KAFKA_VERSION</li> <li>\\RD_KAFKA_VERSION</li> <li>\\RD_KAFKA_VERSION</li> <li>\\RD_KAFKA_VERSION</li> <li>\\RD_KAFKA_VERSION</li> <li>\\RD_KAFKA_VERSION</li> <li>\\RD_KAFKA_VERSION</li> <li>\\RD_KAFKA_VERSION</li> <li>\\RD_KAFKA_VERSION</li> <li>\\RD_KAFKA_VERSION</li> <li>\\RD_KAFKA_VERSION</li> <li>\\RD_KAFKA_VERSION</li> <li>\\RD_KAFKA_VERSION</li> <li>\\RD_KAFKA_VERSION</li> <li>\\RD_KAFKA_VERSION</li> <li>\\RD_KAFKA_VTYPE_END</li> <li>\\RD_KAFKA_VTYPE_HEADER</li> <li>\\RD_KAFKA_VTYPE_HEADERS</li> <li>\\RD_KAFKA_VTYPE_KEY</li> <li>\\RD_KAFKA_VTYPE_MSGFLAGS</li> <li>\\RD_KAFKA_VTYPE_OPAQUE</li> <li>\\RD_KAFKA_VTYPE_PARTITION</li> <li>\\RD_KAFKA_VTYPE_RKT</li> <li>\\RD_KAFKA_VTYPE_TIMESTAMP</li> <li>\\RD_KAFKA_VTYPE_TOPIC</li> <li>\\RD_KAFKA_VTYPE_VALUE</li> </ul>"},{"location":"api/#test-coverage","title":"Test Coverage \ud83d\udc9b","text":"<ul> <li>\ud83d\udc9b  Lines: 84.58% (1267 / 1498)</li> <li>\u2764\ufe0f  Classes: 44.64% (25 / 56)</li> <li>\ud83e\udde1  Methods: 65.66% (195 / 297)</li> </ul>"},{"location":"api/RdKafka/","title":"Class RdKafka","text":"<p>abstract Class \\RdKafka</p>"},{"location":"api/RdKafka/#methods","title":"Methods","text":""},{"location":"api/RdKafka/#__construct","title":"__construct()","text":"<pre><code>public __construct ( \n    int $type, \n    ?\\RdKafka\\Conf $conf = null\n ): \n</code></pre> Parameters type <code>int</code> conf <code>?\\RdKafka\\Conf</code>"},{"location":"api/RdKafka/#__destruct","title":"__destruct()","text":"<pre><code>public __destruct (  ): \n</code></pre>"},{"location":"api/RdKafka/#getcdata","title":"getCData()","text":"<pre><code>public getCData (  ): \\FFI\\CData\n</code></pre> Returns <code>\\FFI\\CData</code>"},{"location":"api/RdKafka/#getmetadata","title":"getMetadata()","text":"<pre><code>public getMetadata ( \n    bool $all_topics, \n    ?\\RdKafka\\Topic $only_topic, \n    int $timeout_ms\n ): \\RdKafka\\Metadata\n</code></pre> Parameters all_topics <code>bool</code> only_topic <code>?\\RdKafka\\Topic</code> timeout_ms <code>int</code> Returns <code>\\RdKafka\\Metadata</code>"},{"location":"api/RdKafka/#getopaque","title":"getOpaque()","text":"<pre><code>public getOpaque (  ): mixed|null\n</code></pre> Returns <code>mixed|null</code>"},{"location":"api/RdKafka/#pausepartitions","title":"pausePartitions()","text":"<pre><code>public pausePartitions ( \n    \\TopicPartition[] $topicPartitions\n ): \\TopicPartition[]\n</code></pre> Parameters topicPartitions <code>\\TopicPartition[]</code> Returns <code>\\TopicPartition[]</code>"},{"location":"api/RdKafka/#querywatermarkoffsets","title":"queryWatermarkOffsets()","text":"<pre><code>public queryWatermarkOffsets ( \n    string $topic, \n    int $partition, \n    int &amp;$low, \n    int &amp;$high, \n    int $timeout_ms\n ): void\n</code></pre> Parameters topic <code>string</code> partition <code>int</code> low <code>int</code> high <code>int</code> timeout_ms <code>int</code>"},{"location":"api/RdKafka/#resolvefromcdata","title":"resolveFromCData()","text":"<pre><code>public static resolveFromCData ( \n    ?\\FFI\\CData $kafka = null\n ): ?self\n</code></pre> Parameters kafka <code>?\\FFI\\CData</code> Returns <code>?self</code>"},{"location":"api/RdKafka/#resumepartitions","title":"resumePartitions()","text":"<pre><code>public resumePartitions ( \n    \\TopicPartition[] $topicPartitions\n ): \\TopicPartition[]\n</code></pre> Parameters topicPartitions <code>\\TopicPartition[]</code> Returns <code>\\TopicPartition[]</code>"},{"location":"api/RdKafka/#setloglevel","title":"setLogLevel()","text":"<pre><code>public setLogLevel ( \n    int $level\n ): void\n</code></pre> Parameters level <code>int</code> <p>Deprecated</p> <p>Set via Conf parameter log_level instead</p>"},{"location":"api/RdKafka/#setlogger","title":"setLogger()","text":"<pre><code>public setLogger ( \n    int $logger\n ): void\n</code></pre> Parameters logger <code>int</code> <p>Deprecated</p> <p>Use Conf::setLogCb instead</p>"},{"location":"api/RdKafka/#test-coverage","title":"Test Coverage \ud83d\udc9b","text":"<ul> <li>\ud83d\udc9b  Lines: 85.33% (64 / 75)</li> <li>\u2764\ufe0f  Methods: 40% (6 / 15)</li> </ul>"},{"location":"api/RdKafka/#extended-by","title":"Extended by","text":"<ul> <li>\\RdKafka\\Consumer</li> <li>\\RdKafka\\KafkaConsumer</li> <li>\\RdKafka\\Producer</li> </ul>"},{"location":"api/constants/","title":"Constants","text":""},{"location":"api/constants/#rd_kafka_log_print","title":"RD_KAFKA_LOG_PRINT","text":"<pre><code>public RD_KAFKA_LOG_PRINT = 100\n</code></pre>"},{"location":"api/constants/#rd_kafka_log_syslog","title":"RD_KAFKA_LOG_SYSLOG","text":"<pre><code>public RD_KAFKA_LOG_SYSLOG = 101\n</code></pre>"},{"location":"api/constants/#rd_kafka_log_syslog_print","title":"RD_KAFKA_LOG_SYSLOG_PRINT","text":"<pre><code>public RD_KAFKA_LOG_SYSLOG_PRINT = 102\n</code></pre>"},{"location":"api/constants/#rd_kafka_msg_partitioner_random","title":"RD_KAFKA_MSG_PARTITIONER_RANDOM","text":"<pre><code>public RD_KAFKA_MSG_PARTITIONER_RANDOM = 2\n</code></pre>"},{"location":"api/constants/#rd_kafka_msg_partitioner_consistent","title":"RD_KAFKA_MSG_PARTITIONER_CONSISTENT","text":"<pre><code>public RD_KAFKA_MSG_PARTITIONER_CONSISTENT = 3\n</code></pre>"},{"location":"api/constants/#rd_kafka_msg_partitioner_consistent_random","title":"RD_KAFKA_MSG_PARTITIONER_CONSISTENT_RANDOM","text":"<pre><code>public RD_KAFKA_MSG_PARTITIONER_CONSISTENT_RANDOM = 4\n</code></pre>"},{"location":"api/constants/#rd_kafka_msg_partitioner_murmur2","title":"RD_KAFKA_MSG_PARTITIONER_MURMUR2","text":"<pre><code>public RD_KAFKA_MSG_PARTITIONER_MURMUR2 = 5\n</code></pre>"},{"location":"api/constants/#rd_kafka_msg_partitioner_murmur2_random","title":"RD_KAFKA_MSG_PARTITIONER_MURMUR2_RANDOM","text":"<pre><code>public RD_KAFKA_MSG_PARTITIONER_MURMUR2_RANDOM = 6\n</code></pre>"},{"location":"api/constants/#rd_kafka_msg_partitioner_fnv1a","title":"RD_KAFKA_MSG_PARTITIONER_FNV1A","text":"<pre><code>public RD_KAFKA_MSG_PARTITIONER_FNV1A = 7\n</code></pre>"},{"location":"api/constants/#rd_kafka_msg_partitioner_fnv1a_random","title":"RD_KAFKA_MSG_PARTITIONER_FNV1A_RANDOM","text":"<pre><code>public RD_KAFKA_MSG_PARTITIONER_FNV1A_RANDOM = 8\n</code></pre>"},{"location":"api/constants/#rd_kafka_destroy_f_no_consumer_close","title":"RD_KAFKA_DESTROY_F_NO_CONSUMER_CLOSE","text":"<pre><code>public RD_KAFKA_DESTROY_F_NO_CONSUMER_CLOSE = 8\n</code></pre> <p>Flags for rd_kafka_destroy_flags() </p> <p>Don't call consumer_close() to leave group and commit final offsets.</p> <p>This also disables consumer callbacks to be called from rd_kafka_destroy*(), such as rebalance_cb.</p> <p>The consumer group handler is still closed internally, but from an application perspective none of the functionality from consumer_close() is performed. </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#af2a79b2f2bef22e06ed9fade159f42d4 </li> </ul>"},{"location":"api/constants/#rd_kafka_partition_ua","title":"RD_KAFKA_PARTITION_UA","text":"<pre><code>public RD_KAFKA_PARTITION_UA = -1\n</code></pre> <p>Unassigned partition. </p> <p>The unassigned partition is used by the producer API for messages that should be partitioned using the configured or default partitioner. </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a3002d1858385de283ea004893e352863 </li> </ul>"},{"location":"api/constants/#rd_kafka_offset_beginning","title":"RD_KAFKA_OFFSET_BEGINNING","text":"<pre><code>public RD_KAFKA_OFFSET_BEGINNING = -2\n</code></pre> <p>Start consuming from beginning of \\ kafka partition queue: oldest msg </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a32dc6dd93c16e3aac9b89804c4817fba </li> </ul>"},{"location":"api/constants/#rd_kafka_offset_end","title":"RD_KAFKA_OFFSET_END","text":"<pre><code>public RD_KAFKA_OFFSET_END = -1\n</code></pre> <p>Start consuming from end of kafka \\ partition queue: next msg </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aa7aaaf16e5bd7c0a8a8cb014275c3e06 </li> </ul>"},{"location":"api/constants/#rd_kafka_offset_stored","title":"RD_KAFKA_OFFSET_STORED","text":"<pre><code>public RD_KAFKA_OFFSET_STORED = -1000\n</code></pre> <p>Start consuming from offset retrieved \\ from offset store </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a727dc7080140da43adbd5d0b170d49be </li> </ul>"},{"location":"api/constants/#rd_kafka_offset_invalid","title":"RD_KAFKA_OFFSET_INVALID","text":"<pre><code>public RD_KAFKA_OFFSET_INVALID = -1001\n</code></pre> <p>Invalid offset </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ac2e48c4fef9e959ab43cad60ade84af1 </li> </ul>"},{"location":"api/constants/#rd_kafka_offset_tail_base","title":"RD_KAFKA_OFFSET_TAIL_BASE","text":"<p><pre><code>public RD_KAFKA_OFFSET_TAIL_BASE = -2000\n</code></pre> define</p>"},{"location":"api/constants/#rd_kafka_msg_f_free","title":"RD_KAFKA_MSG_F_FREE","text":"<pre><code>public RD_KAFKA_MSG_F_FREE = 1\n</code></pre> <p>Producer message flags. </p> <p>Delegate freeing of payload to rdkafka. \\ </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a21be13f8a4cb1d5aff01419f333e5ea7 </li> </ul>"},{"location":"api/constants/#rd_kafka_msg_f_copy","title":"RD_KAFKA_MSG_F_COPY","text":"<pre><code>public RD_KAFKA_MSG_F_COPY = 2\n</code></pre> <p>rdkafka will make a copy of the payload. \\ </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ad7468ab0ece73cc9cb6253a3dcfe702d </li> </ul>"},{"location":"api/constants/#rd_kafka_msg_f_block","title":"RD_KAFKA_MSG_F_BLOCK","text":"<pre><code>public RD_KAFKA_MSG_F_BLOCK = 4\n</code></pre> <p>Block produce*() on message queue full. \\ WARNING: If a delivery report callback \\ is used, the application MUST \\ call rd_kafka_poll() (or equiv.) \\ to make sure delivered messages \\ are drained from the internal \\ delivery report queue. \\ Failure to do so will result \\ in indefinitely blocking on \\ the produce() call when the \\ message queue is full. </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aca3cdf1c55668f4aa1c2391ddd39c9c2 </li> </ul>"},{"location":"api/constants/#rd_kafka_msg_f_partition","title":"RD_KAFKA_MSG_F_PARTITION","text":"<pre><code>public RD_KAFKA_MSG_F_PARTITION = 8\n</code></pre> <p>produce_batch() will honor \\ per-message partition. </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a991bd9378d2fc5b2102ce3a29805b345 </li> </ul>"},{"location":"api/constants/#rd_kafka_purge_f_queue","title":"RD_KAFKA_PURGE_F_QUEUE","text":"<pre><code>public RD_KAFKA_PURGE_F_QUEUE = 1\n</code></pre> <p>Flags for rd_kafka_purge() </p> <p>Purge messages in internal queues. </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ad5bcdab21e406a23d50cdb1c68e95a34 </li> </ul>"},{"location":"api/constants/#rd_kafka_purge_f_inflight","title":"RD_KAFKA_PURGE_F_INFLIGHT","text":"<pre><code>public RD_KAFKA_PURGE_F_INFLIGHT = 2\n</code></pre> <p>Purge messages in-flight to or from the broker. Purging these messages will void any future acknowledgements from the broker, making it impossible for the application to know if these messages were successfully delivered or not. Retrying these messages may lead to duplicates. </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#af232512144175a21b5bda2a1fcbe1f00 </li> </ul>"},{"location":"api/constants/#rd_kafka_purge_f_non_blocking","title":"RD_KAFKA_PURGE_F_NON_BLOCKING","text":"<pre><code>public RD_KAFKA_PURGE_F_NON_BLOCKING = 4\n</code></pre> <p>Don't wait for background thread queue purging to finish. </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aef197fd7fd6dfa02d70563e359b8281f </li> </ul>"},{"location":"api/constants/#rd_kafka_event_none","title":"RD_KAFKA_EVENT_NONE","text":"<pre><code>public RD_KAFKA_EVENT_NONE = 0\n</code></pre> <p>Unset value </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aa2707dd1a6225e7649fd5d825284da4d </li> </ul>"},{"location":"api/constants/#rd_kafka_event_dr","title":"RD_KAFKA_EVENT_DR","text":"<pre><code>public RD_KAFKA_EVENT_DR = 1\n</code></pre> <p>Producer Delivery report batch </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#abfe880d05ff52138b26dbe8b8e0d2132 </li> </ul>"},{"location":"api/constants/#rd_kafka_event_fetch","title":"RD_KAFKA_EVENT_FETCH","text":"<pre><code>public RD_KAFKA_EVENT_FETCH = 2\n</code></pre> <p>Fetched message (consumer) </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#acfddfd9f3d49591dcd9e7f323dbcd865 </li> </ul>"},{"location":"api/constants/#rd_kafka_event_log","title":"RD_KAFKA_EVENT_LOG","text":"<pre><code>public RD_KAFKA_EVENT_LOG = 4\n</code></pre> <p>Log message </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a6265a9eeee57e83eb9f3bbd33d92700f </li> </ul>"},{"location":"api/constants/#rd_kafka_event_error","title":"RD_KAFKA_EVENT_ERROR","text":"<pre><code>public RD_KAFKA_EVENT_ERROR = 8\n</code></pre> <p>Error </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a080a7ad60de643f47424031ee95da103 </li> </ul>"},{"location":"api/constants/#rd_kafka_event_rebalance","title":"RD_KAFKA_EVENT_REBALANCE","text":"<pre><code>public RD_KAFKA_EVENT_REBALANCE = 16\n</code></pre> <p>Group rebalance (consumer) </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a271e6a5984932015585dd5248535aa2b </li> </ul>"},{"location":"api/constants/#rd_kafka_event_offset_commit","title":"RD_KAFKA_EVENT_OFFSET_COMMIT","text":"<pre><code>public RD_KAFKA_EVENT_OFFSET_COMMIT = 32\n</code></pre> <p>Offset commit result </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a73a29f22b22433a93253a5f77c866437 </li> </ul>"},{"location":"api/constants/#rd_kafka_event_stats","title":"RD_KAFKA_EVENT_STATS","text":"<pre><code>public RD_KAFKA_EVENT_STATS = 64\n</code></pre> <p>Stats </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a67070a77150f54039273097c57da5965 </li> </ul>"},{"location":"api/constants/#rd_kafka_event_createtopics_result","title":"RD_KAFKA_EVENT_CREATETOPICS_RESULT","text":"<pre><code>public RD_KAFKA_EVENT_CREATETOPICS_RESULT = 100\n</code></pre> <p>CreateTopics_result_t </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ae0622aab30c391aed6c8b57d1aa5d0a8 </li> </ul>"},{"location":"api/constants/#rd_kafka_event_deletetopics_result","title":"RD_KAFKA_EVENT_DELETETOPICS_RESULT","text":"<pre><code>public RD_KAFKA_EVENT_DELETETOPICS_RESULT = 101\n</code></pre> <p>DeleteTopics_result_t </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#af69b2889c6e9cc2ebb03c607efade311 </li> </ul>"},{"location":"api/constants/#rd_kafka_event_createpartitions_result","title":"RD_KAFKA_EVENT_CREATEPARTITIONS_RESULT","text":"<pre><code>public RD_KAFKA_EVENT_CREATEPARTITIONS_RESULT = 102\n</code></pre> <p>CreatePartitions_result_t </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a82de17d7d0eb7ac80761a35695b1f971 </li> </ul>"},{"location":"api/constants/#rd_kafka_event_alterconfigs_result","title":"RD_KAFKA_EVENT_ALTERCONFIGS_RESULT","text":"<pre><code>public RD_KAFKA_EVENT_ALTERCONFIGS_RESULT = 103\n</code></pre> <p>AlterConfigs_result_t </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a25ded37b0459f4207e033ead15d30909 </li> </ul>"},{"location":"api/constants/#rd_kafka_event_describeconfigs_result","title":"RD_KAFKA_EVENT_DESCRIBECONFIGS_RESULT","text":"<pre><code>public RD_KAFKA_EVENT_DESCRIBECONFIGS_RESULT = 104\n</code></pre> <p>DescribeConfigs_result_t </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a5918e726a9b2828c3051e48d6a747259 </li> </ul>"},{"location":"api/constants/#rd_kafka_producer","title":"RD_KAFKA_PRODUCER","text":"<pre><code>public RD_KAFKA_PRODUCER = 0\n</code></pre> <p>Producer client </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ac6f9c3cb01cbaf3013689c4f2731b831 </li> </ul>"},{"location":"api/constants/#rd_kafka_consumer","title":"RD_KAFKA_CONSUMER","text":"<pre><code>public RD_KAFKA_CONSUMER = 1\n</code></pre> <p>Consumer client </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ac6f9c3cb01cbaf3013689c4f2731b831 </li> </ul>"},{"location":"api/constants/#rd_kafka_timestamp_not_available","title":"RD_KAFKA_TIMESTAMP_NOT_AVAILABLE","text":"<pre><code>public RD_KAFKA_TIMESTAMP_NOT_AVAILABLE = 0\n</code></pre> <p>Timestamp not available </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#af7cb459a230a61489234823da2beb3f3 </li> </ul>"},{"location":"api/constants/#rd_kafka_timestamp_create_time","title":"RD_KAFKA_TIMESTAMP_CREATE_TIME","text":"<pre><code>public RD_KAFKA_TIMESTAMP_CREATE_TIME = 1\n</code></pre> <p>Message creation time </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#af7cb459a230a61489234823da2beb3f3 </li> </ul>"},{"location":"api/constants/#rd_kafka_timestamp_log_append_time","title":"RD_KAFKA_TIMESTAMP_LOG_APPEND_TIME","text":"<pre><code>public RD_KAFKA_TIMESTAMP_LOG_APPEND_TIME = 2\n</code></pre> <p>Log append time </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#af7cb459a230a61489234823da2beb3f3 </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err__begin","title":"RD_KAFKA_RESP_ERR__BEGIN","text":"<pre><code>public RD_KAFKA_RESP_ERR__BEGIN = -200\n</code></pre> <p>Begin internal error codes </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err__bad_msg","title":"RD_KAFKA_RESP_ERR__BAD_MSG","text":"<pre><code>public RD_KAFKA_RESP_ERR__BAD_MSG = -199\n</code></pre> <p>Received message is incorrect </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err__bad_compression","title":"RD_KAFKA_RESP_ERR__BAD_COMPRESSION","text":"<pre><code>public RD_KAFKA_RESP_ERR__BAD_COMPRESSION = -198\n</code></pre> <p>Bad/unknown compression </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err__destroy","title":"RD_KAFKA_RESP_ERR__DESTROY","text":"<pre><code>public RD_KAFKA_RESP_ERR__DESTROY = -197\n</code></pre> <p>Broker is going away </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err__fail","title":"RD_KAFKA_RESP_ERR__FAIL","text":"<pre><code>public RD_KAFKA_RESP_ERR__FAIL = -196\n</code></pre> <p>Generic failure </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err__transport","title":"RD_KAFKA_RESP_ERR__TRANSPORT","text":"<pre><code>public RD_KAFKA_RESP_ERR__TRANSPORT = -195\n</code></pre> <p>Broker transport failure </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err__crit_sys_resource","title":"RD_KAFKA_RESP_ERR__CRIT_SYS_RESOURCE","text":"<pre><code>public RD_KAFKA_RESP_ERR__CRIT_SYS_RESOURCE = -194\n</code></pre> <p>Critical system resource </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err__resolve","title":"RD_KAFKA_RESP_ERR__RESOLVE","text":"<pre><code>public RD_KAFKA_RESP_ERR__RESOLVE = -193\n</code></pre> <p>Failed to resolve broker </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err__msg_timed_out","title":"RD_KAFKA_RESP_ERR__MSG_TIMED_OUT","text":"<pre><code>public RD_KAFKA_RESP_ERR__MSG_TIMED_OUT = -192\n</code></pre> <p>Produced message timed out </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err__partition_eof","title":"RD_KAFKA_RESP_ERR__PARTITION_EOF","text":"<pre><code>public RD_KAFKA_RESP_ERR__PARTITION_EOF = -191\n</code></pre> <p>Reached the end of the topic+partition queue on the broker. Not really an error. This event is disabled by default, see the <code>enable.partition.eof</code> configuration property. </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err__unknown_partition","title":"RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION","text":"<pre><code>public RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION = -190\n</code></pre> <p>Permanent: Partition does not exist in cluster. </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err__fs","title":"RD_KAFKA_RESP_ERR__FS","text":"<pre><code>public RD_KAFKA_RESP_ERR__FS = -189\n</code></pre> <p>File or filesystem error </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err__unknown_topic","title":"RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC","text":"<pre><code>public RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC = -188\n</code></pre> <p>Permanent: Topic does not exist in cluster. </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err__all_brokers_down","title":"RD_KAFKA_RESP_ERR__ALL_BROKERS_DOWN","text":"<pre><code>public RD_KAFKA_RESP_ERR__ALL_BROKERS_DOWN = -187\n</code></pre> <p>All broker connections are down. </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err__invalid_arg","title":"RD_KAFKA_RESP_ERR__INVALID_ARG","text":"<pre><code>public RD_KAFKA_RESP_ERR__INVALID_ARG = -186\n</code></pre> <p>Invalid argument, or invalid configuration </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err__timed_out","title":"RD_KAFKA_RESP_ERR__TIMED_OUT","text":"<pre><code>public RD_KAFKA_RESP_ERR__TIMED_OUT = -185\n</code></pre> <p>Operation timed out </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err__queue_full","title":"RD_KAFKA_RESP_ERR__QUEUE_FULL","text":"<pre><code>public RD_KAFKA_RESP_ERR__QUEUE_FULL = -184\n</code></pre> <p>Queue is full </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err__isr_insuff","title":"RD_KAFKA_RESP_ERR__ISR_INSUFF","text":"<pre><code>public RD_KAFKA_RESP_ERR__ISR_INSUFF = -183\n</code></pre> <p>ISR count &lt; required.acks </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err__node_update","title":"RD_KAFKA_RESP_ERR__NODE_UPDATE","text":"<pre><code>public RD_KAFKA_RESP_ERR__NODE_UPDATE = -182\n</code></pre> <p>Broker node update </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err__ssl","title":"RD_KAFKA_RESP_ERR__SSL","text":"<pre><code>public RD_KAFKA_RESP_ERR__SSL = -181\n</code></pre> <p>SSL error </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err__wait_coord","title":"RD_KAFKA_RESP_ERR__WAIT_COORD","text":"<pre><code>public RD_KAFKA_RESP_ERR__WAIT_COORD = -180\n</code></pre> <p>Waiting for coordinator to become available. </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err__unknown_group","title":"RD_KAFKA_RESP_ERR__UNKNOWN_GROUP","text":"<pre><code>public RD_KAFKA_RESP_ERR__UNKNOWN_GROUP = -179\n</code></pre> <p>Unknown client group </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err__in_progress","title":"RD_KAFKA_RESP_ERR__IN_PROGRESS","text":"<pre><code>public RD_KAFKA_RESP_ERR__IN_PROGRESS = -178\n</code></pre> <p>Operation in progress </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err__prev_in_progress","title":"RD_KAFKA_RESP_ERR__PREV_IN_PROGRESS","text":"<pre><code>public RD_KAFKA_RESP_ERR__PREV_IN_PROGRESS = -177\n</code></pre> <p>Previous operation in progress, wait for it to finish. </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err__existing_subscription","title":"RD_KAFKA_RESP_ERR__EXISTING_SUBSCRIPTION","text":"<pre><code>public RD_KAFKA_RESP_ERR__EXISTING_SUBSCRIPTION = -176\n</code></pre> <p>This operation would interfere with an existing subscription </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err__assign_partitions","title":"RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS","text":"<pre><code>public RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS = -175\n</code></pre> <p>Assigned partitions (rebalance_cb) </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err__revoke_partitions","title":"RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS","text":"<pre><code>public RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS = -174\n</code></pre> <p>Revoked partitions (rebalance_cb) </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err__conflict","title":"RD_KAFKA_RESP_ERR__CONFLICT","text":"<pre><code>public RD_KAFKA_RESP_ERR__CONFLICT = -173\n</code></pre> <p>Conflicting use </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err__state","title":"RD_KAFKA_RESP_ERR__STATE","text":"<pre><code>public RD_KAFKA_RESP_ERR__STATE = -172\n</code></pre> <p>Wrong state </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err__unknown_protocol","title":"RD_KAFKA_RESP_ERR__UNKNOWN_PROTOCOL","text":"<pre><code>public RD_KAFKA_RESP_ERR__UNKNOWN_PROTOCOL = -171\n</code></pre> <p>Unknown protocol </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err__not_implemented","title":"RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED","text":"<pre><code>public RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED = -170\n</code></pre> <p>Not implemented </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err__authentication","title":"RD_KAFKA_RESP_ERR__AUTHENTICATION","text":"<pre><code>public RD_KAFKA_RESP_ERR__AUTHENTICATION = -169\n</code></pre> <p>Authentication failure </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err__no_offset","title":"RD_KAFKA_RESP_ERR__NO_OFFSET","text":"<pre><code>public RD_KAFKA_RESP_ERR__NO_OFFSET = -168\n</code></pre> <p>No stored offset </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err__outdated","title":"RD_KAFKA_RESP_ERR__OUTDATED","text":"<pre><code>public RD_KAFKA_RESP_ERR__OUTDATED = -167\n</code></pre> <p>Outdated </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err__timed_out_queue","title":"RD_KAFKA_RESP_ERR__TIMED_OUT_QUEUE","text":"<pre><code>public RD_KAFKA_RESP_ERR__TIMED_OUT_QUEUE = -166\n</code></pre> <p>Timed out in queue </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err__unsupported_feature","title":"RD_KAFKA_RESP_ERR__UNSUPPORTED_FEATURE","text":"<pre><code>public RD_KAFKA_RESP_ERR__UNSUPPORTED_FEATURE = -165\n</code></pre> <p>Feature not supported by broker </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err__wait_cache","title":"RD_KAFKA_RESP_ERR__WAIT_CACHE","text":"<pre><code>public RD_KAFKA_RESP_ERR__WAIT_CACHE = -164\n</code></pre> <p>Awaiting cache update </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err__intr","title":"RD_KAFKA_RESP_ERR__INTR","text":"<pre><code>public RD_KAFKA_RESP_ERR__INTR = -163\n</code></pre> <p>Operation interrupted (e.g., due to yield)) </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err__key_serialization","title":"RD_KAFKA_RESP_ERR__KEY_SERIALIZATION","text":"<pre><code>public RD_KAFKA_RESP_ERR__KEY_SERIALIZATION = -162\n</code></pre> <p>Key serialization error </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err__value_serialization","title":"RD_KAFKA_RESP_ERR__VALUE_SERIALIZATION","text":"<pre><code>public RD_KAFKA_RESP_ERR__VALUE_SERIALIZATION = -161\n</code></pre> <p>Value serialization error </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err__key_deserialization","title":"RD_KAFKA_RESP_ERR__KEY_DESERIALIZATION","text":"<pre><code>public RD_KAFKA_RESP_ERR__KEY_DESERIALIZATION = -160\n</code></pre> <p>Key deserialization error </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err__value_deserialization","title":"RD_KAFKA_RESP_ERR__VALUE_DESERIALIZATION","text":"<pre><code>public RD_KAFKA_RESP_ERR__VALUE_DESERIALIZATION = -159\n</code></pre> <p>Value deserialization error </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err__partial","title":"RD_KAFKA_RESP_ERR__PARTIAL","text":"<pre><code>public RD_KAFKA_RESP_ERR__PARTIAL = -158\n</code></pre> <p>Partial response </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err__read_only","title":"RD_KAFKA_RESP_ERR__READ_ONLY","text":"<pre><code>public RD_KAFKA_RESP_ERR__READ_ONLY = -157\n</code></pre> <p>Modification attempted on read-only object </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err__noent","title":"RD_KAFKA_RESP_ERR__NOENT","text":"<pre><code>public RD_KAFKA_RESP_ERR__NOENT = -156\n</code></pre> <p>No such entry / item not found </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err__underflow","title":"RD_KAFKA_RESP_ERR__UNDERFLOW","text":"<pre><code>public RD_KAFKA_RESP_ERR__UNDERFLOW = -155\n</code></pre> <p>Read underflow </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err__invalid_type","title":"RD_KAFKA_RESP_ERR__INVALID_TYPE","text":"<pre><code>public RD_KAFKA_RESP_ERR__INVALID_TYPE = -154\n</code></pre> <p>Invalid type </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err__retry","title":"RD_KAFKA_RESP_ERR__RETRY","text":"<pre><code>public RD_KAFKA_RESP_ERR__RETRY = -153\n</code></pre> <p>Retry operation </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err__purge_queue","title":"RD_KAFKA_RESP_ERR__PURGE_QUEUE","text":"<pre><code>public RD_KAFKA_RESP_ERR__PURGE_QUEUE = -152\n</code></pre> <p>Purged in queue </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err__purge_inflight","title":"RD_KAFKA_RESP_ERR__PURGE_INFLIGHT","text":"<pre><code>public RD_KAFKA_RESP_ERR__PURGE_INFLIGHT = -151\n</code></pre> <p>Purged in flight </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err__fatal","title":"RD_KAFKA_RESP_ERR__FATAL","text":"<pre><code>public RD_KAFKA_RESP_ERR__FATAL = -150\n</code></pre> <p>Fatal error: see rd_kafka_fatal_error() </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err__inconsistent","title":"RD_KAFKA_RESP_ERR__INCONSISTENT","text":"<pre><code>public RD_KAFKA_RESP_ERR__INCONSISTENT = -149\n</code></pre> <p>Inconsistent state </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err__gapless_guarantee","title":"RD_KAFKA_RESP_ERR__GAPLESS_GUARANTEE","text":"<pre><code>public RD_KAFKA_RESP_ERR__GAPLESS_GUARANTEE = -148\n</code></pre> <p>Gap-less ordering would not be guaranteed if proceeding </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err__max_poll_exceeded","title":"RD_KAFKA_RESP_ERR__MAX_POLL_EXCEEDED","text":"<pre><code>public RD_KAFKA_RESP_ERR__MAX_POLL_EXCEEDED = -147\n</code></pre> <p>Maximum poll interval exceeded </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err__end","title":"RD_KAFKA_RESP_ERR__END","text":"<pre><code>public RD_KAFKA_RESP_ERR__END = -100\n</code></pre> <p>End internal error codes </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_unknown","title":"RD_KAFKA_RESP_ERR_UNKNOWN","text":"<pre><code>public RD_KAFKA_RESP_ERR_UNKNOWN = -1\n</code></pre> <p>Unknown broker error </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_no_error","title":"RD_KAFKA_RESP_ERR_NO_ERROR","text":"<pre><code>public RD_KAFKA_RESP_ERR_NO_ERROR = 0\n</code></pre> <p>Success </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_offset_out_of_range","title":"RD_KAFKA_RESP_ERR_OFFSET_OUT_OF_RANGE","text":"<pre><code>public RD_KAFKA_RESP_ERR_OFFSET_OUT_OF_RANGE = 1\n</code></pre> <p>Offset out of range </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_invalid_msg","title":"RD_KAFKA_RESP_ERR_INVALID_MSG","text":"<pre><code>public RD_KAFKA_RESP_ERR_INVALID_MSG = 2\n</code></pre> <p>Invalid message </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_unknown_topic_or_part","title":"RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART","text":"<pre><code>public RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART = 3\n</code></pre> <p>Unknown topic or partition </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_invalid_msg_size","title":"RD_KAFKA_RESP_ERR_INVALID_MSG_SIZE","text":"<pre><code>public RD_KAFKA_RESP_ERR_INVALID_MSG_SIZE = 4\n</code></pre> <p>Invalid message size </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_leader_not_available","title":"RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE","text":"<pre><code>public RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE = 5\n</code></pre> <p>Leader not available </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_not_leader_for_partition","title":"RD_KAFKA_RESP_ERR_NOT_LEADER_FOR_PARTITION","text":"<pre><code>public RD_KAFKA_RESP_ERR_NOT_LEADER_FOR_PARTITION = 6\n</code></pre> <p>Not leader for partition </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ad4aa22eb292d320e5155c6cec9de4c43 </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_request_timed_out","title":"RD_KAFKA_RESP_ERR_REQUEST_TIMED_OUT","text":"<pre><code>public RD_KAFKA_RESP_ERR_REQUEST_TIMED_OUT = 7\n</code></pre> <p>Request timed out </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_broker_not_available","title":"RD_KAFKA_RESP_ERR_BROKER_NOT_AVAILABLE","text":"<pre><code>public RD_KAFKA_RESP_ERR_BROKER_NOT_AVAILABLE = 8\n</code></pre> <p>Broker not available </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_replica_not_available","title":"RD_KAFKA_RESP_ERR_REPLICA_NOT_AVAILABLE","text":"<pre><code>public RD_KAFKA_RESP_ERR_REPLICA_NOT_AVAILABLE = 9\n</code></pre> <p>Replica not available </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_msg_size_too_large","title":"RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE","text":"<pre><code>public RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE = 10\n</code></pre> <p>Message size too large </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_stale_ctrl_epoch","title":"RD_KAFKA_RESP_ERR_STALE_CTRL_EPOCH","text":"<pre><code>public RD_KAFKA_RESP_ERR_STALE_CTRL_EPOCH = 11\n</code></pre> <p>StaleControllerEpochCode </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_offset_metadata_too_large","title":"RD_KAFKA_RESP_ERR_OFFSET_METADATA_TOO_LARGE","text":"<pre><code>public RD_KAFKA_RESP_ERR_OFFSET_METADATA_TOO_LARGE = 12\n</code></pre> <p>Offset metadata string too large </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_network_exception","title":"RD_KAFKA_RESP_ERR_NETWORK_EXCEPTION","text":"<pre><code>public RD_KAFKA_RESP_ERR_NETWORK_EXCEPTION = 13\n</code></pre> <p>Broker disconnected before response received </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_group_load_in_progress","title":"RD_KAFKA_RESP_ERR_GROUP_LOAD_IN_PROGRESS","text":"<pre><code>public RD_KAFKA_RESP_ERR_GROUP_LOAD_IN_PROGRESS = 14\n</code></pre> <p>Group coordinator load in progress </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#afa695eee077bfd031e5bb637b899cfd8 </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_group_coordinator_not_available","title":"RD_KAFKA_RESP_ERR_GROUP_COORDINATOR_NOT_AVAILABLE","text":"<pre><code>public RD_KAFKA_RESP_ERR_GROUP_COORDINATOR_NOT_AVAILABLE = 15\n</code></pre> <p>Group coordinator not available </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a23a154df5190e1fc072199737f39bd87 </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_not_coordinator_for_group","title":"RD_KAFKA_RESP_ERR_NOT_COORDINATOR_FOR_GROUP","text":"<pre><code>public RD_KAFKA_RESP_ERR_NOT_COORDINATOR_FOR_GROUP = 16\n</code></pre> <p>Not coordinator for group </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a7755c1901da130a937be67a1c66e2c1f </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_topic_exception","title":"RD_KAFKA_RESP_ERR_TOPIC_EXCEPTION","text":"<pre><code>public RD_KAFKA_RESP_ERR_TOPIC_EXCEPTION = 17\n</code></pre> <p>Invalid topic </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_record_list_too_large","title":"RD_KAFKA_RESP_ERR_RECORD_LIST_TOO_LARGE","text":"<pre><code>public RD_KAFKA_RESP_ERR_RECORD_LIST_TOO_LARGE = 18\n</code></pre> <p>Message batch larger than configured server segment size </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_not_enough_replicas","title":"RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS","text":"<pre><code>public RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS = 19\n</code></pre> <p>Not enough in-sync replicas </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_not_enough_replicas_after_append","title":"RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS_AFTER_APPEND","text":"<pre><code>public RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS_AFTER_APPEND = 20\n</code></pre> <p>Message(s) written to insufficient number of in-sync replicas </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_invalid_required_acks","title":"RD_KAFKA_RESP_ERR_INVALID_REQUIRED_ACKS","text":"<pre><code>public RD_KAFKA_RESP_ERR_INVALID_REQUIRED_ACKS = 21\n</code></pre> <p>Invalid required acks value </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_illegal_generation","title":"RD_KAFKA_RESP_ERR_ILLEGAL_GENERATION","text":"<pre><code>public RD_KAFKA_RESP_ERR_ILLEGAL_GENERATION = 22\n</code></pre> <p>Specified group generation id is not valid </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_inconsistent_group_protocol","title":"RD_KAFKA_RESP_ERR_INCONSISTENT_GROUP_PROTOCOL","text":"<pre><code>public RD_KAFKA_RESP_ERR_INCONSISTENT_GROUP_PROTOCOL = 23\n</code></pre> <p>Inconsistent group protocol </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_invalid_group_id","title":"RD_KAFKA_RESP_ERR_INVALID_GROUP_ID","text":"<pre><code>public RD_KAFKA_RESP_ERR_INVALID_GROUP_ID = 24\n</code></pre> <p>Invalid group.id </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_unknown_member_id","title":"RD_KAFKA_RESP_ERR_UNKNOWN_MEMBER_ID","text":"<pre><code>public RD_KAFKA_RESP_ERR_UNKNOWN_MEMBER_ID = 25\n</code></pre> <p>Unknown member </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_invalid_session_timeout","title":"RD_KAFKA_RESP_ERR_INVALID_SESSION_TIMEOUT","text":"<pre><code>public RD_KAFKA_RESP_ERR_INVALID_SESSION_TIMEOUT = 26\n</code></pre> <p>Invalid session timeout </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_rebalance_in_progress","title":"RD_KAFKA_RESP_ERR_REBALANCE_IN_PROGRESS","text":"<pre><code>public RD_KAFKA_RESP_ERR_REBALANCE_IN_PROGRESS = 27\n</code></pre> <p>Group rebalance in progress </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_invalid_commit_offset_size","title":"RD_KAFKA_RESP_ERR_INVALID_COMMIT_OFFSET_SIZE","text":"<pre><code>public RD_KAFKA_RESP_ERR_INVALID_COMMIT_OFFSET_SIZE = 28\n</code></pre> <p>Commit offset data size is not valid </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_topic_authorization_failed","title":"RD_KAFKA_RESP_ERR_TOPIC_AUTHORIZATION_FAILED","text":"<pre><code>public RD_KAFKA_RESP_ERR_TOPIC_AUTHORIZATION_FAILED = 29\n</code></pre> <p>Topic authorization failed </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_group_authorization_failed","title":"RD_KAFKA_RESP_ERR_GROUP_AUTHORIZATION_FAILED","text":"<pre><code>public RD_KAFKA_RESP_ERR_GROUP_AUTHORIZATION_FAILED = 30\n</code></pre> <p>Group authorization failed </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_cluster_authorization_failed","title":"RD_KAFKA_RESP_ERR_CLUSTER_AUTHORIZATION_FAILED","text":"<pre><code>public RD_KAFKA_RESP_ERR_CLUSTER_AUTHORIZATION_FAILED = 31\n</code></pre> <p>Cluster authorization failed </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_invalid_timestamp","title":"RD_KAFKA_RESP_ERR_INVALID_TIMESTAMP","text":"<pre><code>public RD_KAFKA_RESP_ERR_INVALID_TIMESTAMP = 32\n</code></pre> <p>Invalid timestamp </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_unsupported_sasl_mechanism","title":"RD_KAFKA_RESP_ERR_UNSUPPORTED_SASL_MECHANISM","text":"<pre><code>public RD_KAFKA_RESP_ERR_UNSUPPORTED_SASL_MECHANISM = 33\n</code></pre> <p>Unsupported SASL mechanism </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_illegal_sasl_state","title":"RD_KAFKA_RESP_ERR_ILLEGAL_SASL_STATE","text":"<pre><code>public RD_KAFKA_RESP_ERR_ILLEGAL_SASL_STATE = 34\n</code></pre> <p>Illegal SASL state </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_unsupported_version","title":"RD_KAFKA_RESP_ERR_UNSUPPORTED_VERSION","text":"<pre><code>public RD_KAFKA_RESP_ERR_UNSUPPORTED_VERSION = 35\n</code></pre> <p>Unuspported version </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_topic_already_exists","title":"RD_KAFKA_RESP_ERR_TOPIC_ALREADY_EXISTS","text":"<pre><code>public RD_KAFKA_RESP_ERR_TOPIC_ALREADY_EXISTS = 36\n</code></pre> <p>Topic already exists </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_invalid_partitions","title":"RD_KAFKA_RESP_ERR_INVALID_PARTITIONS","text":"<pre><code>public RD_KAFKA_RESP_ERR_INVALID_PARTITIONS = 37\n</code></pre> <p>Invalid number of partitions </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_invalid_replication_factor","title":"RD_KAFKA_RESP_ERR_INVALID_REPLICATION_FACTOR","text":"<pre><code>public RD_KAFKA_RESP_ERR_INVALID_REPLICATION_FACTOR = 38\n</code></pre> <p>Invalid replication factor </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_invalid_replica_assignment","title":"RD_KAFKA_RESP_ERR_INVALID_REPLICA_ASSIGNMENT","text":"<pre><code>public RD_KAFKA_RESP_ERR_INVALID_REPLICA_ASSIGNMENT = 39\n</code></pre> <p>Invalid replica assignment </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_invalid_config","title":"RD_KAFKA_RESP_ERR_INVALID_CONFIG","text":"<pre><code>public RD_KAFKA_RESP_ERR_INVALID_CONFIG = 40\n</code></pre> <p>Invalid config </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_not_controller","title":"RD_KAFKA_RESP_ERR_NOT_CONTROLLER","text":"<pre><code>public RD_KAFKA_RESP_ERR_NOT_CONTROLLER = 41\n</code></pre> <p>Not controller for cluster </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_invalid_request","title":"RD_KAFKA_RESP_ERR_INVALID_REQUEST","text":"<pre><code>public RD_KAFKA_RESP_ERR_INVALID_REQUEST = 42\n</code></pre> <p>Invalid request </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_unsupported_for_message_format","title":"RD_KAFKA_RESP_ERR_UNSUPPORTED_FOR_MESSAGE_FORMAT","text":"<pre><code>public RD_KAFKA_RESP_ERR_UNSUPPORTED_FOR_MESSAGE_FORMAT = 43\n</code></pre> <p>Message format on broker does not support request </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_policy_violation","title":"RD_KAFKA_RESP_ERR_POLICY_VIOLATION","text":"<pre><code>public RD_KAFKA_RESP_ERR_POLICY_VIOLATION = 44\n</code></pre> <p>Policy violation </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_out_of_order_sequence_number","title":"RD_KAFKA_RESP_ERR_OUT_OF_ORDER_SEQUENCE_NUMBER","text":"<pre><code>public RD_KAFKA_RESP_ERR_OUT_OF_ORDER_SEQUENCE_NUMBER = 45\n</code></pre> <p>Broker received an out of order sequence number </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_duplicate_sequence_number","title":"RD_KAFKA_RESP_ERR_DUPLICATE_SEQUENCE_NUMBER","text":"<pre><code>public RD_KAFKA_RESP_ERR_DUPLICATE_SEQUENCE_NUMBER = 46\n</code></pre> <p>Broker received a duplicate sequence number </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_invalid_producer_epoch","title":"RD_KAFKA_RESP_ERR_INVALID_PRODUCER_EPOCH","text":"<pre><code>public RD_KAFKA_RESP_ERR_INVALID_PRODUCER_EPOCH = 47\n</code></pre> <p>Producer attempted an operation with an old epoch </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_invalid_txn_state","title":"RD_KAFKA_RESP_ERR_INVALID_TXN_STATE","text":"<pre><code>public RD_KAFKA_RESP_ERR_INVALID_TXN_STATE = 48\n</code></pre> <p>Producer attempted a transactional operation in an invalid state </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_invalid_producer_id_mapping","title":"RD_KAFKA_RESP_ERR_INVALID_PRODUCER_ID_MAPPING","text":"<pre><code>public RD_KAFKA_RESP_ERR_INVALID_PRODUCER_ID_MAPPING = 49\n</code></pre> <p>Producer attempted to use a producer id which is not currently assigned to its transactional id </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_invalid_transaction_timeout","title":"RD_KAFKA_RESP_ERR_INVALID_TRANSACTION_TIMEOUT","text":"<pre><code>public RD_KAFKA_RESP_ERR_INVALID_TRANSACTION_TIMEOUT = 50\n</code></pre> <p>Transaction timeout is larger than the maximum value allowed by the broker's max.transaction.timeout.ms </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_concurrent_transactions","title":"RD_KAFKA_RESP_ERR_CONCURRENT_TRANSACTIONS","text":"<pre><code>public RD_KAFKA_RESP_ERR_CONCURRENT_TRANSACTIONS = 51\n</code></pre> <p>Producer attempted to update a transaction while another concurrent operation on the same transaction was ongoing </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_transaction_coordinator_fenced","title":"RD_KAFKA_RESP_ERR_TRANSACTION_COORDINATOR_FENCED","text":"<pre><code>public RD_KAFKA_RESP_ERR_TRANSACTION_COORDINATOR_FENCED = 52\n</code></pre> <p>Indicates that the transaction coordinator sending a WriteTxnMarker is no longer the current coordinator for a given producer </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_transactional_id_authorization_failed","title":"RD_KAFKA_RESP_ERR_TRANSACTIONAL_ID_AUTHORIZATION_FAILED","text":"<pre><code>public RD_KAFKA_RESP_ERR_TRANSACTIONAL_ID_AUTHORIZATION_FAILED = 53\n</code></pre> <p>Transactional Id authorization failed </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_security_disabled","title":"RD_KAFKA_RESP_ERR_SECURITY_DISABLED","text":"<pre><code>public RD_KAFKA_RESP_ERR_SECURITY_DISABLED = 54\n</code></pre> <p>Security features are disabled </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_operation_not_attempted","title":"RD_KAFKA_RESP_ERR_OPERATION_NOT_ATTEMPTED","text":"<pre><code>public RD_KAFKA_RESP_ERR_OPERATION_NOT_ATTEMPTED = 55\n</code></pre> <p>Operation not attempted </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_kafka_storage_error","title":"RD_KAFKA_RESP_ERR_KAFKA_STORAGE_ERROR","text":"<pre><code>public RD_KAFKA_RESP_ERR_KAFKA_STORAGE_ERROR = 56\n</code></pre> <p>Disk error when trying to access log file on the disk </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_log_dir_not_found","title":"RD_KAFKA_RESP_ERR_LOG_DIR_NOT_FOUND","text":"<pre><code>public RD_KAFKA_RESP_ERR_LOG_DIR_NOT_FOUND = 57\n</code></pre> <p>The user-specified log directory is not found in the broker config </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_sasl_authentication_failed","title":"RD_KAFKA_RESP_ERR_SASL_AUTHENTICATION_FAILED","text":"<pre><code>public RD_KAFKA_RESP_ERR_SASL_AUTHENTICATION_FAILED = 58\n</code></pre> <p>SASL Authentication failed </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_unknown_producer_id","title":"RD_KAFKA_RESP_ERR_UNKNOWN_PRODUCER_ID","text":"<pre><code>public RD_KAFKA_RESP_ERR_UNKNOWN_PRODUCER_ID = 59\n</code></pre> <p>Unknown Producer Id </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_reassignment_in_progress","title":"RD_KAFKA_RESP_ERR_REASSIGNMENT_IN_PROGRESS","text":"<pre><code>public RD_KAFKA_RESP_ERR_REASSIGNMENT_IN_PROGRESS = 60\n</code></pre> <p>Partition reassignment is in progress </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_delegation_token_auth_disabled","title":"RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTH_DISABLED","text":"<pre><code>public RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTH_DISABLED = 61\n</code></pre> <p>Delegation Token feature is not enabled </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_delegation_token_not_found","title":"RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_NOT_FOUND","text":"<pre><code>public RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_NOT_FOUND = 62\n</code></pre> <p>Delegation Token is not found on server </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_delegation_token_owner_mismatch","title":"RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_OWNER_MISMATCH","text":"<pre><code>public RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_OWNER_MISMATCH = 63\n</code></pre> <p>Specified Principal is not valid Owner/Renewer </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_delegation_token_request_not_allowed","title":"RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_REQUEST_NOT_ALLOWED","text":"<pre><code>public RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_REQUEST_NOT_ALLOWED = 64\n</code></pre> <p>Delegation Token requests are not allowed on this connection </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_delegation_token_authorization_failed","title":"RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTHORIZATION_FAILED","text":"<pre><code>public RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTHORIZATION_FAILED = 65\n</code></pre> <p>Delegation Token authorization failed </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_delegation_token_expired","title":"RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_EXPIRED","text":"<pre><code>public RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_EXPIRED = 66\n</code></pre> <p>Delegation Token is expired </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_invalid_principal_type","title":"RD_KAFKA_RESP_ERR_INVALID_PRINCIPAL_TYPE","text":"<pre><code>public RD_KAFKA_RESP_ERR_INVALID_PRINCIPAL_TYPE = 67\n</code></pre> <p>Supplied principalType is not supported </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_non_empty_group","title":"RD_KAFKA_RESP_ERR_NON_EMPTY_GROUP","text":"<pre><code>public RD_KAFKA_RESP_ERR_NON_EMPTY_GROUP = 68\n</code></pre> <p>The group is not empty </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_group_id_not_found","title":"RD_KAFKA_RESP_ERR_GROUP_ID_NOT_FOUND","text":"<pre><code>public RD_KAFKA_RESP_ERR_GROUP_ID_NOT_FOUND = 69\n</code></pre> <p>The group id does not exist </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_fetch_session_id_not_found","title":"RD_KAFKA_RESP_ERR_FETCH_SESSION_ID_NOT_FOUND","text":"<pre><code>public RD_KAFKA_RESP_ERR_FETCH_SESSION_ID_NOT_FOUND = 70\n</code></pre> <p>The fetch session ID was not found </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_invalid_fetch_session_epoch","title":"RD_KAFKA_RESP_ERR_INVALID_FETCH_SESSION_EPOCH","text":"<pre><code>public RD_KAFKA_RESP_ERR_INVALID_FETCH_SESSION_EPOCH = 71\n</code></pre> <p>The fetch session epoch is invalid </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_listener_not_found","title":"RD_KAFKA_RESP_ERR_LISTENER_NOT_FOUND","text":"<pre><code>public RD_KAFKA_RESP_ERR_LISTENER_NOT_FOUND = 72\n</code></pre> <p>No matching listener </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_topic_deletion_disabled","title":"RD_KAFKA_RESP_ERR_TOPIC_DELETION_DISABLED","text":"<pre><code>public RD_KAFKA_RESP_ERR_TOPIC_DELETION_DISABLED = 73\n</code></pre> <p>Topic deletion is disabled </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_vtype_end","title":"RD_KAFKA_VTYPE_END","text":"<pre><code>public RD_KAFKA_VTYPE_END = 0\n</code></pre> <p>va-arg sentinel </p> <p>See also</p> <ul> <li> <p> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03c74ceba678b4e7a624310160a02165 </p> </li> <li> <p> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a9aac65afa4c30e6d75550e39f6c1ea6b </p> </li> </ul>"},{"location":"api/constants/#rd_kafka_vtype_topic","title":"RD_KAFKA_VTYPE_TOPIC","text":"<pre><code>public RD_KAFKA_VTYPE_TOPIC = 1\n</code></pre> <p>(const char *) Topic name </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a9aac65afa4c30e6d75550e39f6c1ea6b </li> </ul>"},{"location":"api/constants/#rd_kafka_vtype_rkt","title":"RD_KAFKA_VTYPE_RKT","text":"<pre><code>public RD_KAFKA_VTYPE_RKT = 2\n</code></pre> <p>(rd_kafka_topic_t *) Topic handle </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a9aac65afa4c30e6d75550e39f6c1ea6b </li> </ul>"},{"location":"api/constants/#rd_kafka_vtype_partition","title":"RD_KAFKA_VTYPE_PARTITION","text":"<pre><code>public RD_KAFKA_VTYPE_PARTITION = 3\n</code></pre> <p>(int32_t) Partition </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a9aac65afa4c30e6d75550e39f6c1ea6b </li> </ul>"},{"location":"api/constants/#rd_kafka_vtype_value","title":"RD_KAFKA_VTYPE_VALUE","text":"<pre><code>public RD_KAFKA_VTYPE_VALUE = 4\n</code></pre> <p>(void *, size_t) Message value (payload) </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a9aac65afa4c30e6d75550e39f6c1ea6b </li> </ul>"},{"location":"api/constants/#rd_kafka_vtype_key","title":"RD_KAFKA_VTYPE_KEY","text":"<pre><code>public RD_KAFKA_VTYPE_KEY = 5\n</code></pre> <p>(void *, size_t) Message key </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a9aac65afa4c30e6d75550e39f6c1ea6b </li> </ul>"},{"location":"api/constants/#rd_kafka_vtype_opaque","title":"RD_KAFKA_VTYPE_OPAQUE","text":"<pre><code>public RD_KAFKA_VTYPE_OPAQUE = 6\n</code></pre> <p>(void *) Per-message application opaque value. This is the same as the _private field in rd_kafka_message_t, also known as the msg_opaque. </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a9aac65afa4c30e6d75550e39f6c1ea6b </li> </ul>"},{"location":"api/constants/#rd_kafka_vtype_msgflags","title":"RD_KAFKA_VTYPE_MSGFLAGS","text":"<pre><code>public RD_KAFKA_VTYPE_MSGFLAGS = 7\n</code></pre> <p>(int) RD_KAFKA_MSG_F_.. flags </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a9aac65afa4c30e6d75550e39f6c1ea6b </li> </ul>"},{"location":"api/constants/#rd_kafka_vtype_timestamp","title":"RD_KAFKA_VTYPE_TIMESTAMP","text":"<pre><code>public RD_KAFKA_VTYPE_TIMESTAMP = 8\n</code></pre> <p>(int64_t) Milliseconds since epoch UTC </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a9aac65afa4c30e6d75550e39f6c1ea6b </li> </ul>"},{"location":"api/constants/#rd_kafka_vtype_header","title":"RD_KAFKA_VTYPE_HEADER","text":"<pre><code>public RD_KAFKA_VTYPE_HEADER = 9\n</code></pre> <p>(const char *, const void *, ssize_t) Message Header </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a9aac65afa4c30e6d75550e39f6c1ea6b </li> </ul>"},{"location":"api/constants/#rd_kafka_vtype_headers","title":"RD_KAFKA_VTYPE_HEADERS","text":"<pre><code>public RD_KAFKA_VTYPE_HEADERS = 10\n</code></pre> <p>(rd_kafka_headers_t *) Headers list </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a9aac65afa4c30e6d75550e39f6c1ea6b </li> </ul>"},{"location":"api/constants/#rd_kafka_msg_status_not_persisted","title":"RD_KAFKA_MSG_STATUS_NOT_PERSISTED","text":"<pre><code>public RD_KAFKA_MSG_STATUS_NOT_PERSISTED = 0\n</code></pre> <p>Message was never transmitted to the broker, or failed with an error indicating it was not written to the log. Application retry risks ordering, but not duplication. </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ad46cb2b6064fcfbe2451aca8df802517 </li> </ul>"},{"location":"api/constants/#rd_kafka_msg_status_possibly_persisted","title":"RD_KAFKA_MSG_STATUS_POSSIBLY_PERSISTED","text":"<pre><code>public RD_KAFKA_MSG_STATUS_POSSIBLY_PERSISTED = 1\n</code></pre> <p>Message was transmitted to broker, but no acknowledgement was received. Application retry risks ordering and duplication. </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ad46cb2b6064fcfbe2451aca8df802517 </li> </ul>"},{"location":"api/constants/#rd_kafka_msg_status_persisted","title":"RD_KAFKA_MSG_STATUS_PERSISTED","text":"<pre><code>public RD_KAFKA_MSG_STATUS_PERSISTED = 2\n</code></pre> <p>Message was written to the log and acknowledged by the broker. No reason for application to retry. Note: this value should only be trusted with <code>acks=all</code>. </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ad46cb2b6064fcfbe2451aca8df802517 </li> </ul>"},{"location":"api/constants/#rd_kafka_conf_unknown","title":"RD_KAFKA_CONF_UNKNOWN","text":"<pre><code>public RD_KAFKA_CONF_UNKNOWN = -2\n</code></pre> <p>Unknown configuration name. </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ad8306a08e59e8e2cbc6abdb84f9689f4 </li> </ul>"},{"location":"api/constants/#rd_kafka_conf_invalid","title":"RD_KAFKA_CONF_INVALID","text":"<pre><code>public RD_KAFKA_CONF_INVALID = -1\n</code></pre> <p>Invalid configuration value or property or value not supported in this build. </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ad8306a08e59e8e2cbc6abdb84f9689f4 </li> </ul>"},{"location":"api/constants/#rd_kafka_conf_ok","title":"RD_KAFKA_CONF_OK","text":"<pre><code>public RD_KAFKA_CONF_OK = 0\n</code></pre> <p>Configuration okay </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ad8306a08e59e8e2cbc6abdb84f9689f4 </li> </ul>"},{"location":"api/constants/#rd_kafka_admin_op_any","title":"RD_KAFKA_ADMIN_OP_ANY","text":"<pre><code>public RD_KAFKA_ADMIN_OP_ANY = 0\n</code></pre> <p>Default value </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe </li> </ul>"},{"location":"api/constants/#rd_kafka_admin_op_createtopics","title":"RD_KAFKA_ADMIN_OP_CREATETOPICS","text":"<pre><code>public RD_KAFKA_ADMIN_OP_CREATETOPICS = 1\n</code></pre> <p>CreateTopics </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe </li> </ul>"},{"location":"api/constants/#rd_kafka_admin_op_deletetopics","title":"RD_KAFKA_ADMIN_OP_DELETETOPICS","text":"<pre><code>public RD_KAFKA_ADMIN_OP_DELETETOPICS = 2\n</code></pre> <p>DeleteTopics </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe </li> </ul>"},{"location":"api/constants/#rd_kafka_admin_op_createpartitions","title":"RD_KAFKA_ADMIN_OP_CREATEPARTITIONS","text":"<pre><code>public RD_KAFKA_ADMIN_OP_CREATEPARTITIONS = 3\n</code></pre> <p>CreatePartitions </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe </li> </ul>"},{"location":"api/constants/#rd_kafka_admin_op_alterconfigs","title":"RD_KAFKA_ADMIN_OP_ALTERCONFIGS","text":"<pre><code>public RD_KAFKA_ADMIN_OP_ALTERCONFIGS = 4\n</code></pre> <p>AlterConfigs </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe </li> </ul>"},{"location":"api/constants/#rd_kafka_admin_op_describeconfigs","title":"RD_KAFKA_ADMIN_OP_DESCRIBECONFIGS","text":"<pre><code>public RD_KAFKA_ADMIN_OP_DESCRIBECONFIGS = 5\n</code></pre> <p>DescribeConfigs </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe </li> </ul>"},{"location":"api/constants/#rd_kafka_config_source_unknown_config","title":"RD_KAFKA_CONFIG_SOURCE_UNKNOWN_CONFIG","text":"<pre><code>public RD_KAFKA_CONFIG_SOURCE_UNKNOWN_CONFIG = 0\n</code></pre> <p>Source unknown, e.g., in the ConfigEntry used for alter requests where source is not set </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aab84b4178e74bd4319721ee0c68ae62c </li> </ul>"},{"location":"api/constants/#rd_kafka_config_source_dynamic_topic_config","title":"RD_KAFKA_CONFIG_SOURCE_DYNAMIC_TOPIC_CONFIG","text":"<pre><code>public RD_KAFKA_CONFIG_SOURCE_DYNAMIC_TOPIC_CONFIG = 1\n</code></pre> <p>Dynamic topic config that is configured for a specific topic </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aab84b4178e74bd4319721ee0c68ae62c </li> </ul>"},{"location":"api/constants/#rd_kafka_config_source_dynamic_broker_config","title":"RD_KAFKA_CONFIG_SOURCE_DYNAMIC_BROKER_CONFIG","text":"<pre><code>public RD_KAFKA_CONFIG_SOURCE_DYNAMIC_BROKER_CONFIG = 2\n</code></pre> <p>Dynamic broker config that is configured for a specific broker </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aab84b4178e74bd4319721ee0c68ae62c </li> </ul>"},{"location":"api/constants/#rd_kafka_config_source_dynamic_default_broker_config","title":"RD_KAFKA_CONFIG_SOURCE_DYNAMIC_DEFAULT_BROKER_CONFIG","text":"<pre><code>public RD_KAFKA_CONFIG_SOURCE_DYNAMIC_DEFAULT_BROKER_CONFIG = 3\n</code></pre> <p>Dynamic broker config that is configured as default for all brokers in the cluster </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aab84b4178e74bd4319721ee0c68ae62c </li> </ul>"},{"location":"api/constants/#rd_kafka_config_source_static_broker_config","title":"RD_KAFKA_CONFIG_SOURCE_STATIC_BROKER_CONFIG","text":"<pre><code>public RD_KAFKA_CONFIG_SOURCE_STATIC_BROKER_CONFIG = 4\n</code></pre> <p>Static broker config provided as broker properties at startup (e.g. from server.properties file) </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aab84b4178e74bd4319721ee0c68ae62c </li> </ul>"},{"location":"api/constants/#rd_kafka_config_source_default_config","title":"RD_KAFKA_CONFIG_SOURCE_DEFAULT_CONFIG","text":"<pre><code>public RD_KAFKA_CONFIG_SOURCE_DEFAULT_CONFIG = 5\n</code></pre> <p>Built-in default configuration for configs that have a default value </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aab84b4178e74bd4319721ee0c68ae62c </li> </ul>"},{"location":"api/constants/#rd_kafka_config_source__cnt","title":"RD_KAFKA_CONFIG_SOURCE__CNT","text":"<pre><code>public RD_KAFKA_CONFIG_SOURCE__CNT = 6\n</code></pre> <p>Number of source types defined </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aab84b4178e74bd4319721ee0c68ae62c </li> </ul>"},{"location":"api/constants/#rd_kafka_resource_unknown","title":"RD_KAFKA_RESOURCE_UNKNOWN","text":"<pre><code>public RD_KAFKA_RESOURCE_UNKNOWN = 0\n</code></pre> <p>Unknown </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#acca83a66d7783ff7683ed2691cc907c9 </li> </ul>"},{"location":"api/constants/#rd_kafka_resource_any","title":"RD_KAFKA_RESOURCE_ANY","text":"<pre><code>public RD_KAFKA_RESOURCE_ANY = 1\n</code></pre> <p>Any (used for lookups) </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#acca83a66d7783ff7683ed2691cc907c9 </li> </ul>"},{"location":"api/constants/#rd_kafka_resource_topic","title":"RD_KAFKA_RESOURCE_TOPIC","text":"<pre><code>public RD_KAFKA_RESOURCE_TOPIC = 2\n</code></pre> <p>Topic </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#acca83a66d7783ff7683ed2691cc907c9 </li> </ul>"},{"location":"api/constants/#rd_kafka_resource_group","title":"RD_KAFKA_RESOURCE_GROUP","text":"<pre><code>public RD_KAFKA_RESOURCE_GROUP = 3\n</code></pre> <p>Group </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#acca83a66d7783ff7683ed2691cc907c9 </li> </ul>"},{"location":"api/constants/#rd_kafka_resource_broker","title":"RD_KAFKA_RESOURCE_BROKER","text":"<pre><code>public RD_KAFKA_RESOURCE_BROKER = 4\n</code></pre> <p>Broker </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#acca83a66d7783ff7683ed2691cc907c9 </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_fenced_leader_epoch","title":"RD_KAFKA_RESP_ERR_FENCED_LEADER_EPOCH","text":"<pre><code>public RD_KAFKA_RESP_ERR_FENCED_LEADER_EPOCH = 74\n</code></pre> <p>Leader epoch is older than broker epoch </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_unknown_leader_epoch","title":"RD_KAFKA_RESP_ERR_UNKNOWN_LEADER_EPOCH","text":"<pre><code>public RD_KAFKA_RESP_ERR_UNKNOWN_LEADER_EPOCH = 75\n</code></pre> <p>Leader epoch is newer than broker epoch </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_stale_broker_epoch","title":"RD_KAFKA_RESP_ERR_STALE_BROKER_EPOCH","text":"<pre><code>public RD_KAFKA_RESP_ERR_STALE_BROKER_EPOCH = 77\n</code></pre> <p>Broker epoch has changed </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_offset_not_available","title":"RD_KAFKA_RESP_ERR_OFFSET_NOT_AVAILABLE","text":"<pre><code>public RD_KAFKA_RESP_ERR_OFFSET_NOT_AVAILABLE = 78\n</code></pre> <p>Leader high watermark is not caught up </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_member_id_required","title":"RD_KAFKA_RESP_ERR_MEMBER_ID_REQUIRED","text":"<pre><code>public RD_KAFKA_RESP_ERR_MEMBER_ID_REQUIRED = 79\n</code></pre> <p>Group member needs a valid member ID </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_preferred_leader_not_available","title":"RD_KAFKA_RESP_ERR_PREFERRED_LEADER_NOT_AVAILABLE","text":"<pre><code>public RD_KAFKA_RESP_ERR_PREFERRED_LEADER_NOT_AVAILABLE = 80\n</code></pre> <p>Preferred leader was not available </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_group_max_size_reached","title":"RD_KAFKA_RESP_ERR_GROUP_MAX_SIZE_REACHED","text":"<pre><code>public RD_KAFKA_RESP_ERR_GROUP_MAX_SIZE_REACHED = 81\n</code></pre> <p>Consumer group has reached maximum size </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_event_oauthbearer_token_refresh","title":"RD_KAFKA_EVENT_OAUTHBEARER_TOKEN_REFRESH","text":"<pre><code>public RD_KAFKA_EVENT_OAUTHBEARER_TOKEN_REFRESH = 256\n</code></pre> <p>SASL/OAUTHBEARER token needs to be refreshed </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a63e097de934fac48b93411ac91564db1 </li> </ul>"},{"location":"api/constants/#rd_kafka_cert_public_key","title":"RD_KAFKA_CERT_PUBLIC_KEY","text":"<pre><code>public RD_KAFKA_CERT_PUBLIC_KEY = 0\n</code></pre> <p>Client's public key </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a5f0ba54591c0ffa725cb1a5eafe8b180 </li> </ul>"},{"location":"api/constants/#rd_kafka_cert_private_key","title":"RD_KAFKA_CERT_PRIVATE_KEY","text":"<pre><code>public RD_KAFKA_CERT_PRIVATE_KEY = 1\n</code></pre> <p>Client's private key </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a5f0ba54591c0ffa725cb1a5eafe8b180 </li> </ul>"},{"location":"api/constants/#rd_kafka_cert_ca","title":"RD_KAFKA_CERT_CA","text":"<pre><code>public RD_KAFKA_CERT_CA = 2\n</code></pre> <p>CA certificate </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a5f0ba54591c0ffa725cb1a5eafe8b180 </li> </ul>"},{"location":"api/constants/#rd_kafka_cert__cnt","title":"RD_KAFKA_CERT__CNT","text":"<p><pre><code>public RD_KAFKA_CERT__CNT = 3\n</code></pre> enum rd_kafka_cert_type_t</p>"},{"location":"api/constants/#rd_kafka_cert_enc_pkcs12","title":"RD_KAFKA_CERT_ENC_PKCS12","text":"<pre><code>public RD_KAFKA_CERT_ENC_PKCS12 = 0\n</code></pre> <p>PKCS#12 </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ab7a624d3a484453f4abe5955bb6a45eb </li> </ul>"},{"location":"api/constants/#rd_kafka_cert_enc_der","title":"RD_KAFKA_CERT_ENC_DER","text":"<pre><code>public RD_KAFKA_CERT_ENC_DER = 1\n</code></pre> <p>DER / binary X.509 ASN1 </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ab7a624d3a484453f4abe5955bb6a45eb </li> </ul>"},{"location":"api/constants/#rd_kafka_cert_enc_pem","title":"RD_KAFKA_CERT_ENC_PEM","text":"<pre><code>public RD_KAFKA_CERT_ENC_PEM = 2\n</code></pre> <p>PEM </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ab7a624d3a484453f4abe5955bb6a45eb </li> </ul>"},{"location":"api/constants/#rd_kafka_cert_enc__cnt","title":"RD_KAFKA_CERT_ENC__CNT","text":"<p><pre><code>public RD_KAFKA_CERT_ENC__CNT = 3\n</code></pre> enum rd_kafka_cert_enc_t</p>"},{"location":"api/constants/#rd_kafka_thread_main","title":"RD_KAFKA_THREAD_MAIN","text":"<pre><code>public RD_KAFKA_THREAD_MAIN = 0\n</code></pre> <p>librdkafka's internal main thread </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ab327ca8929b6895de7b300970ad59745 </li> </ul>"},{"location":"api/constants/#rd_kafka_thread_background","title":"RD_KAFKA_THREAD_BACKGROUND","text":"<pre><code>public RD_KAFKA_THREAD_BACKGROUND = 1\n</code></pre> <p>Background thread (if enabled) </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ab327ca8929b6895de7b300970ad59745 </li> </ul>"},{"location":"api/constants/#rd_kafka_thread_broker","title":"RD_KAFKA_THREAD_BROKER","text":"<pre><code>public RD_KAFKA_THREAD_BROKER = 2\n</code></pre> <p>Per-broker thread </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ab327ca8929b6895de7b300970ad59745 </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err__unknown_broker","title":"RD_KAFKA_RESP_ERR__UNKNOWN_BROKER","text":"<pre><code>public RD_KAFKA_RESP_ERR__UNKNOWN_BROKER = -146\n</code></pre> <p>Unknown broker </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_coordinator_load_in_progress","title":"RD_KAFKA_RESP_ERR_COORDINATOR_LOAD_IN_PROGRESS","text":"<pre><code>public RD_KAFKA_RESP_ERR_COORDINATOR_LOAD_IN_PROGRESS = 14\n</code></pre> <p>Coordinator load in progress </p> <p>See also</p> <ul> <li> <p> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#afa695eee077bfd031e5bb637b899cfd8 </p> </li> <li> <p> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </p> </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_coordinator_not_available","title":"RD_KAFKA_RESP_ERR_COORDINATOR_NOT_AVAILABLE","text":"<pre><code>public RD_KAFKA_RESP_ERR_COORDINATOR_NOT_AVAILABLE = 15\n</code></pre> <p>Coordinator not available </p> <p>See also</p> <ul> <li> <p> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a23a154df5190e1fc072199737f39bd87 </p> </li> <li> <p> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </p> </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_not_coordinator","title":"RD_KAFKA_RESP_ERR_NOT_COORDINATOR","text":"<pre><code>public RD_KAFKA_RESP_ERR_NOT_COORDINATOR = 16\n</code></pre> <p>Not coordinator </p> <p>See also</p> <ul> <li> <p> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a7755c1901da130a937be67a1c66e2c1f </p> </li> <li> <p> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </p> </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err__not_configured","title":"RD_KAFKA_RESP_ERR__NOT_CONFIGURED","text":"<pre><code>public RD_KAFKA_RESP_ERR__NOT_CONFIGURED = -145\n</code></pre> <p>Functionality not configured </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err__fenced","title":"RD_KAFKA_RESP_ERR__FENCED","text":"<pre><code>public RD_KAFKA_RESP_ERR__FENCED = -144\n</code></pre> <p>Instance has been fenced </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err__application","title":"RD_KAFKA_RESP_ERR__APPLICATION","text":"<pre><code>public RD_KAFKA_RESP_ERR__APPLICATION = -143\n</code></pre> <p>Application generated error </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_fenced_instance_id","title":"RD_KAFKA_RESP_ERR_FENCED_INSTANCE_ID","text":"<pre><code>public RD_KAFKA_RESP_ERR_FENCED_INSTANCE_ID = 82\n</code></pre> <p>Static consumer fenced by other consumer with same group.instance.id. </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_eligible_leaders_not_available","title":"RD_KAFKA_RESP_ERR_ELIGIBLE_LEADERS_NOT_AVAILABLE","text":"<pre><code>public RD_KAFKA_RESP_ERR_ELIGIBLE_LEADERS_NOT_AVAILABLE = 83\n</code></pre> <p>Eligible partition leaders are not available </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_election_not_needed","title":"RD_KAFKA_RESP_ERR_ELECTION_NOT_NEEDED","text":"<pre><code>public RD_KAFKA_RESP_ERR_ELECTION_NOT_NEEDED = 84\n</code></pre> <p>Leader election not needed for topic partition </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_no_reassignment_in_progress","title":"RD_KAFKA_RESP_ERR_NO_REASSIGNMENT_IN_PROGRESS","text":"<pre><code>public RD_KAFKA_RESP_ERR_NO_REASSIGNMENT_IN_PROGRESS = 85\n</code></pre> <p>No partition reassignment is in progress </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_group_subscribed_to_topic","title":"RD_KAFKA_RESP_ERR_GROUP_SUBSCRIBED_TO_TOPIC","text":"<pre><code>public RD_KAFKA_RESP_ERR_GROUP_SUBSCRIBED_TO_TOPIC = 86\n</code></pre> <p>Deleting offsets of a topic while the consumer group is subscribed to it </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_invalid_record","title":"RD_KAFKA_RESP_ERR_INVALID_RECORD","text":"<pre><code>public RD_KAFKA_RESP_ERR_INVALID_RECORD = 87\n</code></pre> <p>Broker failed to validate record </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_unstable_offset_commit","title":"RD_KAFKA_RESP_ERR_UNSTABLE_OFFSET_COMMIT","text":"<pre><code>public RD_KAFKA_RESP_ERR_UNSTABLE_OFFSET_COMMIT = 88\n</code></pre> <p>There are unstable offsets that need to be cleared </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_event_deleterecords_result","title":"RD_KAFKA_EVENT_DELETERECORDS_RESULT","text":"<pre><code>public RD_KAFKA_EVENT_DELETERECORDS_RESULT = 105\n</code></pre> <p>DeleteRecords_result_t </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ab572fd50785847b03c96af744ceffaf1 </li> </ul>"},{"location":"api/constants/#rd_kafka_event_deletegroups_result","title":"RD_KAFKA_EVENT_DELETEGROUPS_RESULT","text":"<pre><code>public RD_KAFKA_EVENT_DELETEGROUPS_RESULT = 106\n</code></pre> <p>DeleteGroups_result_t </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a6d2f3f1797ba2241c707b077ddc2c1b3 </li> </ul>"},{"location":"api/constants/#rd_kafka_event_deleteconsumergroupoffsets_result","title":"RD_KAFKA_EVENT_DELETECONSUMERGROUPOFFSETS_RESULT","text":"<pre><code>public RD_KAFKA_EVENT_DELETECONSUMERGROUPOFFSETS_RESULT = 107\n</code></pre> <p>DeleteConsumerGroupOffsets_result_t </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a16dee39b23bef225ad3bb902cf391659 </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err__assignment_lost","title":"RD_KAFKA_RESP_ERR__ASSIGNMENT_LOST","text":"<pre><code>public RD_KAFKA_RESP_ERR__ASSIGNMENT_LOST = -142\n</code></pre> <p>Assignment lost </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err__noop","title":"RD_KAFKA_RESP_ERR__NOOP","text":"<pre><code>public RD_KAFKA_RESP_ERR__NOOP = -141\n</code></pre> <p>No operation performed </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_throttling_quota_exceeded","title":"RD_KAFKA_RESP_ERR_THROTTLING_QUOTA_EXCEEDED","text":"<pre><code>public RD_KAFKA_RESP_ERR_THROTTLING_QUOTA_EXCEEDED = 89\n</code></pre> <p>Throttling quota has been exceeded </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_producer_fenced","title":"RD_KAFKA_RESP_ERR_PRODUCER_FENCED","text":"<pre><code>public RD_KAFKA_RESP_ERR_PRODUCER_FENCED = 90\n</code></pre> <p>There is a newer producer with the same transactionalId which fences the current one </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_resource_not_found","title":"RD_KAFKA_RESP_ERR_RESOURCE_NOT_FOUND","text":"<pre><code>public RD_KAFKA_RESP_ERR_RESOURCE_NOT_FOUND = 91\n</code></pre> <p>Request illegally referred to resource that does not exist </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_duplicate_resource","title":"RD_KAFKA_RESP_ERR_DUPLICATE_RESOURCE","text":"<pre><code>public RD_KAFKA_RESP_ERR_DUPLICATE_RESOURCE = 92\n</code></pre> <p>Request illegally referred to the same resource twice </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_unacceptable_credential","title":"RD_KAFKA_RESP_ERR_UNACCEPTABLE_CREDENTIAL","text":"<pre><code>public RD_KAFKA_RESP_ERR_UNACCEPTABLE_CREDENTIAL = 93\n</code></pre> <p>Requested credential would not meet criteria for acceptability </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_inconsistent_voter_set","title":"RD_KAFKA_RESP_ERR_INCONSISTENT_VOTER_SET","text":"<pre><code>public RD_KAFKA_RESP_ERR_INCONSISTENT_VOTER_SET = 94\n</code></pre> <p>Indicates that the either the sender or recipient of a voter-only request is not one of the expected voters </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_invalid_update_version","title":"RD_KAFKA_RESP_ERR_INVALID_UPDATE_VERSION","text":"<pre><code>public RD_KAFKA_RESP_ERR_INVALID_UPDATE_VERSION = 95\n</code></pre> <p>Invalid update version </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_feature_update_failed","title":"RD_KAFKA_RESP_ERR_FEATURE_UPDATE_FAILED","text":"<pre><code>public RD_KAFKA_RESP_ERR_FEATURE_UPDATE_FAILED = 96\n</code></pre> <p>Unable to update finalized features due to server error </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_principal_deserialization_failure","title":"RD_KAFKA_RESP_ERR_PRINCIPAL_DESERIALIZATION_FAILURE","text":"<pre><code>public RD_KAFKA_RESP_ERR_PRINCIPAL_DESERIALIZATION_FAILURE = 97\n</code></pre> <p>Request principal deserialization failed during forwarding </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_admin_op_deleterecords","title":"RD_KAFKA_ADMIN_OP_DELETERECORDS","text":"<pre><code>public RD_KAFKA_ADMIN_OP_DELETERECORDS = 6\n</code></pre> <p>DeleteRecords </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe </li> </ul>"},{"location":"api/constants/#rd_kafka_admin_op_deletegroups","title":"RD_KAFKA_ADMIN_OP_DELETEGROUPS","text":"<pre><code>public RD_KAFKA_ADMIN_OP_DELETEGROUPS = 7\n</code></pre> <p>DeleteGroups </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe </li> </ul>"},{"location":"api/constants/#rd_kafka_admin_op_deleteconsumergroupoffsets","title":"RD_KAFKA_ADMIN_OP_DELETECONSUMERGROUPOFFSETS","text":"<pre><code>public RD_KAFKA_ADMIN_OP_DELETECONSUMERGROUPOFFSETS = 8\n</code></pre> <p>DeleteConsumerGroupOffsets </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err__auto_offset_reset","title":"RD_KAFKA_RESP_ERR__AUTO_OFFSET_RESET","text":"<pre><code>public RD_KAFKA_RESP_ERR__AUTO_OFFSET_RESET = -140\n</code></pre> <p>No offset to automatically reset to </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_event_background","title":"RD_KAFKA_EVENT_BACKGROUND","text":"<pre><code>public RD_KAFKA_EVENT_BACKGROUND = 512\n</code></pre> <p>Enable background thread. </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ad6fc906cff51d7ed8bfc9597c2054190 </li> </ul>"},{"location":"api/constants/#rd_kafka_event_createacls_result","title":"RD_KAFKA_EVENT_CREATEACLS_RESULT","text":"<pre><code>public RD_KAFKA_EVENT_CREATEACLS_RESULT = 1024\n</code></pre> <p>CreateAcls_result_t </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ae09849fc4a1e0a1b4240fbf9e195f2b9 </li> </ul>"},{"location":"api/constants/#rd_kafka_event_describeacls_result","title":"RD_KAFKA_EVENT_DESCRIBEACLS_RESULT","text":"<pre><code>public RD_KAFKA_EVENT_DESCRIBEACLS_RESULT = 2048\n</code></pre> <p>DescribeAcls_result_t </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#af4991ffb7e86a8344a7012d40e2124d8 </li> </ul>"},{"location":"api/constants/#rd_kafka_event_deleteacls_result","title":"RD_KAFKA_EVENT_DELETEACLS_RESULT","text":"<pre><code>public RD_KAFKA_EVENT_DELETEACLS_RESULT = 4096\n</code></pre> <p>DeleteAcls_result_t </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aa44fa18142c943e305b48ae67c836cb4 </li> </ul>"},{"location":"api/constants/#rd_kafka_admin_op_createacls","title":"RD_KAFKA_ADMIN_OP_CREATEACLS","text":"<pre><code>public RD_KAFKA_ADMIN_OP_CREATEACLS = 9\n</code></pre> <p>CreateAcls </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe </li> </ul>"},{"location":"api/constants/#rd_kafka_admin_op_describeacls","title":"RD_KAFKA_ADMIN_OP_DESCRIBEACLS","text":"<pre><code>public RD_KAFKA_ADMIN_OP_DESCRIBEACLS = 10\n</code></pre> <p>DescribeAcls </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe </li> </ul>"},{"location":"api/constants/#rd_kafka_admin_op_deleteacls","title":"RD_KAFKA_ADMIN_OP_DELETEACLS","text":"<pre><code>public RD_KAFKA_ADMIN_OP_DELETEACLS = 11\n</code></pre> <p>DeleteAcls </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe </li> </ul>"},{"location":"api/constants/#rd_kafka_resource_pattern_unknown","title":"RD_KAFKA_RESOURCE_PATTERN_UNKNOWN","text":"<pre><code>public RD_KAFKA_RESOURCE_PATTERN_UNKNOWN = 0\n</code></pre> <p>Unknown </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#acbe0ed4347fe1bd085eef03ca7aadbdb </li> </ul>"},{"location":"api/constants/#rd_kafka_resource_pattern_any","title":"RD_KAFKA_RESOURCE_PATTERN_ANY","text":"<pre><code>public RD_KAFKA_RESOURCE_PATTERN_ANY = 1\n</code></pre> <p>Any (used for lookups) </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#acbe0ed4347fe1bd085eef03ca7aadbdb </li> </ul>"},{"location":"api/constants/#rd_kafka_resource_pattern_match","title":"RD_KAFKA_RESOURCE_PATTERN_MATCH","text":"<pre><code>public RD_KAFKA_RESOURCE_PATTERN_MATCH = 2\n</code></pre> <p>Match: will perform pattern matching </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#acbe0ed4347fe1bd085eef03ca7aadbdb </li> </ul>"},{"location":"api/constants/#rd_kafka_resource_pattern_literal","title":"RD_KAFKA_RESOURCE_PATTERN_LITERAL","text":"<pre><code>public RD_KAFKA_RESOURCE_PATTERN_LITERAL = 3\n</code></pre> <p>Literal: A literal resource name </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#acbe0ed4347fe1bd085eef03ca7aadbdb </li> </ul>"},{"location":"api/constants/#rd_kafka_resource_pattern_prefixed","title":"RD_KAFKA_RESOURCE_PATTERN_PREFIXED","text":"<pre><code>public RD_KAFKA_RESOURCE_PATTERN_PREFIXED = 4\n</code></pre> <p>Prefixed: A prefixed resource name </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#acbe0ed4347fe1bd085eef03ca7aadbdb </li> </ul>"},{"location":"api/constants/#rd_kafka_resource_pattern_type__cnt","title":"RD_KAFKA_RESOURCE_PATTERN_TYPE__CNT","text":"<p><pre><code>public RD_KAFKA_RESOURCE_PATTERN_TYPE__CNT = 5\n</code></pre> enum rd_kafka_ResourcePatternType_t</p>"},{"location":"api/constants/#rd_kafka_acl_operation_unknown","title":"RD_KAFKA_ACL_OPERATION_UNKNOWN","text":"<pre><code>public RD_KAFKA_ACL_OPERATION_UNKNOWN = 0\n</code></pre> <p>Unknown </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a526269d7fc5c9acd1b8b56e84895c2bb </li> </ul>"},{"location":"api/constants/#rd_kafka_acl_operation_any","title":"RD_KAFKA_ACL_OPERATION_ANY","text":"<pre><code>public RD_KAFKA_ACL_OPERATION_ANY = 1\n</code></pre> <p>In a filter, matches any AclOperation </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a526269d7fc5c9acd1b8b56e84895c2bb </li> </ul>"},{"location":"api/constants/#rd_kafka_acl_operation_all","title":"RD_KAFKA_ACL_OPERATION_ALL","text":"<pre><code>public RD_KAFKA_ACL_OPERATION_ALL = 2\n</code></pre> <p>ALL operation </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a526269d7fc5c9acd1b8b56e84895c2bb </li> </ul>"},{"location":"api/constants/#rd_kafka_acl_operation_read","title":"RD_KAFKA_ACL_OPERATION_READ","text":"<pre><code>public RD_KAFKA_ACL_OPERATION_READ = 3\n</code></pre> <p>READ operation </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a526269d7fc5c9acd1b8b56e84895c2bb </li> </ul>"},{"location":"api/constants/#rd_kafka_acl_operation_write","title":"RD_KAFKA_ACL_OPERATION_WRITE","text":"<pre><code>public RD_KAFKA_ACL_OPERATION_WRITE = 4\n</code></pre> <p>WRITE operation </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a526269d7fc5c9acd1b8b56e84895c2bb </li> </ul>"},{"location":"api/constants/#rd_kafka_acl_operation_create","title":"RD_KAFKA_ACL_OPERATION_CREATE","text":"<pre><code>public RD_KAFKA_ACL_OPERATION_CREATE = 5\n</code></pre> <p>CREATE operation </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a526269d7fc5c9acd1b8b56e84895c2bb </li> </ul>"},{"location":"api/constants/#rd_kafka_acl_operation_delete","title":"RD_KAFKA_ACL_OPERATION_DELETE","text":"<pre><code>public RD_KAFKA_ACL_OPERATION_DELETE = 6\n</code></pre> <p>DELETE operation </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a526269d7fc5c9acd1b8b56e84895c2bb </li> </ul>"},{"location":"api/constants/#rd_kafka_acl_operation_alter","title":"RD_KAFKA_ACL_OPERATION_ALTER","text":"<pre><code>public RD_KAFKA_ACL_OPERATION_ALTER = 7\n</code></pre> <p>ALTER operation </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a526269d7fc5c9acd1b8b56e84895c2bb </li> </ul>"},{"location":"api/constants/#rd_kafka_acl_operation_describe","title":"RD_KAFKA_ACL_OPERATION_DESCRIBE","text":"<pre><code>public RD_KAFKA_ACL_OPERATION_DESCRIBE = 8\n</code></pre> <p>DESCRIBE operation </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a526269d7fc5c9acd1b8b56e84895c2bb </li> </ul>"},{"location":"api/constants/#rd_kafka_acl_operation_cluster_action","title":"RD_KAFKA_ACL_OPERATION_CLUSTER_ACTION","text":"<pre><code>public RD_KAFKA_ACL_OPERATION_CLUSTER_ACTION = 9\n</code></pre> <p>CLUSTER_ACTION operation </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a526269d7fc5c9acd1b8b56e84895c2bb </li> </ul>"},{"location":"api/constants/#rd_kafka_acl_operation_describe_configs","title":"RD_KAFKA_ACL_OPERATION_DESCRIBE_CONFIGS","text":"<pre><code>public RD_KAFKA_ACL_OPERATION_DESCRIBE_CONFIGS = 10\n</code></pre> <p>DESCRIBE_CONFIGS operation </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a526269d7fc5c9acd1b8b56e84895c2bb </li> </ul>"},{"location":"api/constants/#rd_kafka_acl_operation_alter_configs","title":"RD_KAFKA_ACL_OPERATION_ALTER_CONFIGS","text":"<pre><code>public RD_KAFKA_ACL_OPERATION_ALTER_CONFIGS = 11\n</code></pre> <p>ALTER_CONFIGS operation </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a526269d7fc5c9acd1b8b56e84895c2bb </li> </ul>"},{"location":"api/constants/#rd_kafka_acl_operation_idempotent_write","title":"RD_KAFKA_ACL_OPERATION_IDEMPOTENT_WRITE","text":"<pre><code>public RD_KAFKA_ACL_OPERATION_IDEMPOTENT_WRITE = 12\n</code></pre> <p>IDEMPOTENT_WRITE operation </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a526269d7fc5c9acd1b8b56e84895c2bb </li> </ul>"},{"location":"api/constants/#rd_kafka_acl_operation__cnt","title":"RD_KAFKA_ACL_OPERATION__CNT","text":"<p><pre><code>public RD_KAFKA_ACL_OPERATION__CNT = 13\n</code></pre> enum rd_kafka_AclOperation_t</p>"},{"location":"api/constants/#rd_kafka_acl_permission_type_unknown","title":"RD_KAFKA_ACL_PERMISSION_TYPE_UNKNOWN","text":"<pre><code>public RD_KAFKA_ACL_PERMISSION_TYPE_UNKNOWN = 0\n</code></pre> <p>Unknown </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ab2da1706fced5ccc7ac5566825ba44b8 </li> </ul>"},{"location":"api/constants/#rd_kafka_acl_permission_type_any","title":"RD_KAFKA_ACL_PERMISSION_TYPE_ANY","text":"<pre><code>public RD_KAFKA_ACL_PERMISSION_TYPE_ANY = 1\n</code></pre> <p>In a filter, matches any AclPermissionType </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ab2da1706fced5ccc7ac5566825ba44b8 </li> </ul>"},{"location":"api/constants/#rd_kafka_acl_permission_type_deny","title":"RD_KAFKA_ACL_PERMISSION_TYPE_DENY","text":"<pre><code>public RD_KAFKA_ACL_PERMISSION_TYPE_DENY = 2\n</code></pre> <p>Disallows access </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ab2da1706fced5ccc7ac5566825ba44b8 </li> </ul>"},{"location":"api/constants/#rd_kafka_acl_permission_type_allow","title":"RD_KAFKA_ACL_PERMISSION_TYPE_ALLOW","text":"<pre><code>public RD_KAFKA_ACL_PERMISSION_TYPE_ALLOW = 3\n</code></pre> <p>Grants access. </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ab2da1706fced5ccc7ac5566825ba44b8 </li> </ul>"},{"location":"api/constants/#rd_kafka_acl_permission_type__cnt","title":"RD_KAFKA_ACL_PERMISSION_TYPE__CNT","text":"<p><pre><code>public RD_KAFKA_ACL_PERMISSION_TYPE__CNT = 4\n</code></pre> enum rd_kafka_AclPermissionType_t</p>"},{"location":"api/constants/#rd_kafka_event_listconsumergroups_result","title":"RD_KAFKA_EVENT_LISTCONSUMERGROUPS_RESULT","text":"<pre><code>public RD_KAFKA_EVENT_LISTCONSUMERGROUPS_RESULT = 8192\n</code></pre> <p>ListConsumerGroupsResult_t </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a7ba2a751aaf1dc30083f91d09b8a5d13 </li> </ul>"},{"location":"api/constants/#rd_kafka_event_describeconsumergroups_result","title":"RD_KAFKA_EVENT_DESCRIBECONSUMERGROUPS_RESULT","text":"<pre><code>public RD_KAFKA_EVENT_DESCRIBECONSUMERGROUPS_RESULT = 16384\n</code></pre> <p>DescribeConsumerGroups_result_t </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a9f1efde95e9895a55407f2edc2a9dc35 </li> </ul>"},{"location":"api/constants/#rd_kafka_event_listconsumergroupoffsets_result","title":"RD_KAFKA_EVENT_LISTCONSUMERGROUPOFFSETS_RESULT","text":"<pre><code>public RD_KAFKA_EVENT_LISTCONSUMERGROUPOFFSETS_RESULT = 32768\n</code></pre> <p>ListConsumerGroupOffsets_result_t </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a04babfacd056e51968c5c3c4b5410f5f </li> </ul>"},{"location":"api/constants/#rd_kafka_event_alterconsumergroupoffsets_result","title":"RD_KAFKA_EVENT_ALTERCONSUMERGROUPOFFSETS_RESULT","text":"<pre><code>public RD_KAFKA_EVENT_ALTERCONSUMERGROUPOFFSETS_RESULT = 65536\n</code></pre> <p>AlterConsumerGroupOffsets_result_t </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#af2b49b7fc3d4368c8cd24e78c31d275c </li> </ul>"},{"location":"api/constants/#rd_kafka_consumer_group_state_unknown","title":"RD_KAFKA_CONSUMER_GROUP_STATE_UNKNOWN","text":"<p><pre><code>public RD_KAFKA_CONSUMER_GROUP_STATE_UNKNOWN = 0\n</code></pre> enum rd_kafka_consumer_group_state_t</p>"},{"location":"api/constants/#rd_kafka_consumer_group_state_preparing_rebalance","title":"RD_KAFKA_CONSUMER_GROUP_STATE_PREPARING_REBALANCE","text":"<p><pre><code>public RD_KAFKA_CONSUMER_GROUP_STATE_PREPARING_REBALANCE = 1\n</code></pre> enum rd_kafka_consumer_group_state_t</p>"},{"location":"api/constants/#rd_kafka_consumer_group_state_completing_rebalance","title":"RD_KAFKA_CONSUMER_GROUP_STATE_COMPLETING_REBALANCE","text":"<p><pre><code>public RD_KAFKA_CONSUMER_GROUP_STATE_COMPLETING_REBALANCE = 2\n</code></pre> enum rd_kafka_consumer_group_state_t</p>"},{"location":"api/constants/#rd_kafka_consumer_group_state_stable","title":"RD_KAFKA_CONSUMER_GROUP_STATE_STABLE","text":"<p><pre><code>public RD_KAFKA_CONSUMER_GROUP_STATE_STABLE = 3\n</code></pre> enum rd_kafka_consumer_group_state_t</p>"},{"location":"api/constants/#rd_kafka_consumer_group_state_dead","title":"RD_KAFKA_CONSUMER_GROUP_STATE_DEAD","text":"<p><pre><code>public RD_KAFKA_CONSUMER_GROUP_STATE_DEAD = 4\n</code></pre> enum rd_kafka_consumer_group_state_t</p>"},{"location":"api/constants/#rd_kafka_consumer_group_state_empty","title":"RD_KAFKA_CONSUMER_GROUP_STATE_EMPTY","text":"<p><pre><code>public RD_KAFKA_CONSUMER_GROUP_STATE_EMPTY = 5\n</code></pre> enum rd_kafka_consumer_group_state_t</p>"},{"location":"api/constants/#rd_kafka_consumer_group_state__cnt","title":"RD_KAFKA_CONSUMER_GROUP_STATE__CNT","text":"<p><pre><code>public RD_KAFKA_CONSUMER_GROUP_STATE__CNT = 6\n</code></pre> enum rd_kafka_consumer_group_state_t</p>"},{"location":"api/constants/#rd_kafka_admin_op_listconsumergroups","title":"RD_KAFKA_ADMIN_OP_LISTCONSUMERGROUPS","text":"<pre><code>public RD_KAFKA_ADMIN_OP_LISTCONSUMERGROUPS = 12\n</code></pre> <p>ListConsumerGroups </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe </li> </ul>"},{"location":"api/constants/#rd_kafka_admin_op_describeconsumergroups","title":"RD_KAFKA_ADMIN_OP_DESCRIBECONSUMERGROUPS","text":"<pre><code>public RD_KAFKA_ADMIN_OP_DESCRIBECONSUMERGROUPS = 13\n</code></pre> <p>DescribeConsumerGroups </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe </li> </ul>"},{"location":"api/constants/#rd_kafka_admin_op_listconsumergroupoffsets","title":"RD_KAFKA_ADMIN_OP_LISTCONSUMERGROUPOFFSETS","text":"<pre><code>public RD_KAFKA_ADMIN_OP_LISTCONSUMERGROUPOFFSETS = 14\n</code></pre> <p>ListConsumerGroupOffsets </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe </li> </ul>"},{"location":"api/constants/#rd_kafka_admin_op_alterconsumergroupoffsets","title":"RD_KAFKA_ADMIN_OP_ALTERCONSUMERGROUPOFFSETS","text":"<pre><code>public RD_KAFKA_ADMIN_OP_ALTERCONSUMERGROUPOFFSETS = 15\n</code></pre> <p>AlterConsumerGroupOffsets </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err__log_truncation","title":"RD_KAFKA_RESP_ERR__LOG_TRUNCATION","text":"<pre><code>public RD_KAFKA_RESP_ERR__LOG_TRUNCATION = -139\n</code></pre> <p>Partition log truncation detected </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_event_incrementalalterconfigs_result","title":"RD_KAFKA_EVENT_INCREMENTALALTERCONFIGS_RESULT","text":"<pre><code>public RD_KAFKA_EVENT_INCREMENTALALTERCONFIGS_RESULT = 131072\n</code></pre> <p>IncrementalAlterConfigs_result_t </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ab9388401d375ee75080814b9a1aff78c </li> </ul>"},{"location":"api/constants/#rd_kafka_event_describeuserscramcredentials_result","title":"RD_KAFKA_EVENT_DESCRIBEUSERSCRAMCREDENTIALS_RESULT","text":"<pre><code>public RD_KAFKA_EVENT_DESCRIBEUSERSCRAMCREDENTIALS_RESULT = 262144\n</code></pre> <p>DescribeUserScramCredentials_result_t </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a05a179e0165a01bfd72fd78163c465c1 </li> </ul>"},{"location":"api/constants/#rd_kafka_event_alteruserscramcredentials_result","title":"RD_KAFKA_EVENT_ALTERUSERSCRAMCREDENTIALS_RESULT","text":"<pre><code>public RD_KAFKA_EVENT_ALTERUSERSCRAMCREDENTIALS_RESULT = 524288\n</code></pre> <p>AlterUserScramCredentials_result_t </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a11f6abfe27ffb6edcd184df41218f5cf </li> </ul>"},{"location":"api/constants/#rd_kafka_admin_op_incrementalalterconfigs","title":"RD_KAFKA_ADMIN_OP_INCREMENTALALTERCONFIGS","text":"<pre><code>public RD_KAFKA_ADMIN_OP_INCREMENTALALTERCONFIGS = 16\n</code></pre> <p>IncrementalAlterConfigs </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe </li> </ul>"},{"location":"api/constants/#rd_kafka_admin_op_describeuserscramcredentials","title":"RD_KAFKA_ADMIN_OP_DESCRIBEUSERSCRAMCREDENTIALS","text":"<pre><code>public RD_KAFKA_ADMIN_OP_DESCRIBEUSERSCRAMCREDENTIALS = 17\n</code></pre> <p>DescribeUserScramCredentials </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe </li> </ul>"},{"location":"api/constants/#rd_kafka_admin_op_alteruserscramcredentials","title":"RD_KAFKA_ADMIN_OP_ALTERUSERSCRAMCREDENTIALS","text":"<pre><code>public RD_KAFKA_ADMIN_OP_ALTERUSERSCRAMCREDENTIALS = 18\n</code></pre> <p>AlterUserScramCredentials </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe </li> </ul>"},{"location":"api/constants/#rd_kafka_alter_config_op_type_set","title":"RD_KAFKA_ALTER_CONFIG_OP_TYPE_SET","text":"<p><pre><code>public RD_KAFKA_ALTER_CONFIG_OP_TYPE_SET = 0\n</code></pre> enum rd_kafka_AlterConfigOpType_t</p>"},{"location":"api/constants/#rd_kafka_alter_config_op_type_delete","title":"RD_KAFKA_ALTER_CONFIG_OP_TYPE_DELETE","text":"<p><pre><code>public RD_KAFKA_ALTER_CONFIG_OP_TYPE_DELETE = 1\n</code></pre> enum rd_kafka_AlterConfigOpType_t</p>"},{"location":"api/constants/#rd_kafka_alter_config_op_type_append","title":"RD_KAFKA_ALTER_CONFIG_OP_TYPE_APPEND","text":"<p><pre><code>public RD_KAFKA_ALTER_CONFIG_OP_TYPE_APPEND = 2\n</code></pre> enum rd_kafka_AlterConfigOpType_t</p>"},{"location":"api/constants/#rd_kafka_alter_config_op_type_subtract","title":"RD_KAFKA_ALTER_CONFIG_OP_TYPE_SUBTRACT","text":"<p><pre><code>public RD_KAFKA_ALTER_CONFIG_OP_TYPE_SUBTRACT = 3\n</code></pre> enum rd_kafka_AlterConfigOpType_t</p>"},{"location":"api/constants/#rd_kafka_alter_config_op_type__cnt","title":"RD_KAFKA_ALTER_CONFIG_OP_TYPE__CNT","text":"<p><pre><code>public RD_KAFKA_ALTER_CONFIG_OP_TYPE__CNT = 4\n</code></pre> enum rd_kafka_AlterConfigOpType_t</p>"},{"location":"api/constants/#rd_kafka_scram_mechanism_unknown","title":"RD_KAFKA_SCRAM_MECHANISM_UNKNOWN","text":"<p><pre><code>public RD_KAFKA_SCRAM_MECHANISM_UNKNOWN = 0\n</code></pre> enum rd_kafka_ScramMechanism_t</p>"},{"location":"api/constants/#rd_kafka_scram_mechanism_sha_256","title":"RD_KAFKA_SCRAM_MECHANISM_SHA_256","text":"<p><pre><code>public RD_KAFKA_SCRAM_MECHANISM_SHA_256 = 1\n</code></pre> enum rd_kafka_ScramMechanism_t</p>"},{"location":"api/constants/#rd_kafka_scram_mechanism_sha_512","title":"RD_KAFKA_SCRAM_MECHANISM_SHA_512","text":"<p><pre><code>public RD_KAFKA_SCRAM_MECHANISM_SHA_512 = 2\n</code></pre> enum rd_kafka_ScramMechanism_t</p>"},{"location":"api/constants/#rd_kafka_scram_mechanism__cnt","title":"RD_KAFKA_SCRAM_MECHANISM__CNT","text":"<p><pre><code>public RD_KAFKA_SCRAM_MECHANISM__CNT = 3\n</code></pre> enum rd_kafka_ScramMechanism_t</p>"},{"location":"api/constants/#rd_kafka_event_describetopics_result","title":"RD_KAFKA_EVENT_DESCRIBETOPICS_RESULT","text":"<pre><code>public RD_KAFKA_EVENT_DESCRIBETOPICS_RESULT = 1048576\n</code></pre> <p>DescribeTopics_result_t </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a54fb65ad2053d2a8058932f414d0af1a </li> </ul>"},{"location":"api/constants/#rd_kafka_event_describecluster_result","title":"RD_KAFKA_EVENT_DESCRIBECLUSTER_RESULT","text":"<pre><code>public RD_KAFKA_EVENT_DESCRIBECLUSTER_RESULT = 2097152\n</code></pre> <p>DescribeCluster_result_t </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a9834684799e542cdcf5ad60d0b3f9fc0 </li> </ul>"},{"location":"api/constants/#rd_kafka_event_listoffsets_result","title":"RD_KAFKA_EVENT_LISTOFFSETS_RESULT","text":"<pre><code>public RD_KAFKA_EVENT_LISTOFFSETS_RESULT = 4194304\n</code></pre> <p>ListOffsets_result_t </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8cb212872006d6ae10574cd8fdeacb7c </li> </ul>"},{"location":"api/constants/#rd_kafka_admin_op_describetopics","title":"RD_KAFKA_ADMIN_OP_DESCRIBETOPICS","text":"<pre><code>public RD_KAFKA_ADMIN_OP_DESCRIBETOPICS = 19\n</code></pre> <p>DescribeTopics </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe </li> </ul>"},{"location":"api/constants/#rd_kafka_admin_op_describecluster","title":"RD_KAFKA_ADMIN_OP_DESCRIBECLUSTER","text":"<pre><code>public RD_KAFKA_ADMIN_OP_DESCRIBECLUSTER = 20\n</code></pre> <p>DescribeCluster </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe </li> </ul>"},{"location":"api/constants/#rd_kafka_admin_op_listoffsets","title":"RD_KAFKA_ADMIN_OP_LISTOFFSETS","text":"<pre><code>public RD_KAFKA_ADMIN_OP_LISTOFFSETS = 21\n</code></pre> <p>ListOffsets </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe </li> </ul>"},{"location":"api/constants/#rd_kafka_isolation_level_read_uncommitted","title":"RD_KAFKA_ISOLATION_LEVEL_READ_UNCOMMITTED","text":"<p><pre><code>public RD_KAFKA_ISOLATION_LEVEL_READ_UNCOMMITTED = 0\n</code></pre> enum rd_kafka_IsolationLevel_t</p>"},{"location":"api/constants/#rd_kafka_isolation_level_read_committed","title":"RD_KAFKA_ISOLATION_LEVEL_READ_COMMITTED","text":"<p><pre><code>public RD_KAFKA_ISOLATION_LEVEL_READ_COMMITTED = 1\n</code></pre> enum rd_kafka_IsolationLevel_t</p>"},{"location":"api/constants/#rd_kafka_offset_spec_max_timestamp","title":"RD_KAFKA_OFFSET_SPEC_MAX_TIMESTAMP","text":"<p><pre><code>public RD_KAFKA_OFFSET_SPEC_MAX_TIMESTAMP = -3\n</code></pre> enum rd_kafka_OffsetSpec_t</p>"},{"location":"api/constants/#rd_kafka_offset_spec_earliest","title":"RD_KAFKA_OFFSET_SPEC_EARLIEST","text":"<p><pre><code>public RD_KAFKA_OFFSET_SPEC_EARLIEST = -2\n</code></pre> enum rd_kafka_OffsetSpec_t</p>"},{"location":"api/constants/#rd_kafka_offset_spec_latest","title":"RD_KAFKA_OFFSET_SPEC_LATEST","text":"<p><pre><code>public RD_KAFKA_OFFSET_SPEC_LATEST = -1\n</code></pre> enum rd_kafka_OffsetSpec_t</p>"},{"location":"api/constants/#rd_kafka_resp_err__invalid_different_record","title":"RD_KAFKA_RESP_ERR__INVALID_DIFFERENT_RECORD","text":"<pre><code>public RD_KAFKA_RESP_ERR__INVALID_DIFFERENT_RECORD = -138\n</code></pre> <p>A different record in the batch was invalid and this message failed persisting. </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_unknown_topic_id","title":"RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_ID","text":"<pre><code>public RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_ID = 100\n</code></pre> <p>Unknown Topic Id </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_fenced_member_epoch","title":"RD_KAFKA_RESP_ERR_FENCED_MEMBER_EPOCH","text":"<pre><code>public RD_KAFKA_RESP_ERR_FENCED_MEMBER_EPOCH = 110\n</code></pre> <p>The member epoch is fenced by the group coordinator </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_unreleased_instance_id","title":"RD_KAFKA_RESP_ERR_UNRELEASED_INSTANCE_ID","text":"<pre><code>public RD_KAFKA_RESP_ERR_UNRELEASED_INSTANCE_ID = 111\n</code></pre> <p>The instance ID is still used by another member in the consumer group </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_unsupported_assignor","title":"RD_KAFKA_RESP_ERR_UNSUPPORTED_ASSIGNOR","text":"<pre><code>public RD_KAFKA_RESP_ERR_UNSUPPORTED_ASSIGNOR = 112\n</code></pre> <p>The assignor or its version range is not supported by the consumer group </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_stale_member_epoch","title":"RD_KAFKA_RESP_ERR_STALE_MEMBER_EPOCH","text":"<pre><code>public RD_KAFKA_RESP_ERR_STALE_MEMBER_EPOCH = 113\n</code></pre> <p>The member epoch is stale </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_unknown_subscription_id","title":"RD_KAFKA_RESP_ERR_UNKNOWN_SUBSCRIPTION_ID","text":"<pre><code>public RD_KAFKA_RESP_ERR_UNKNOWN_SUBSCRIPTION_ID = 117\n</code></pre> <p>Client sent a push telemetry request with an invalid or outdated subscription ID. </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_telemetry_too_large","title":"RD_KAFKA_RESP_ERR_TELEMETRY_TOO_LARGE","text":"<pre><code>public RD_KAFKA_RESP_ERR_TELEMETRY_TOO_LARGE = 118\n</code></pre> <p>Client sent a push telemetry request larger than the maximum size the broker will accept. </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_event_electleaders_result","title":"RD_KAFKA_EVENT_ELECTLEADERS_RESULT","text":"<pre><code>public RD_KAFKA_EVENT_ELECTLEADERS_RESULT = 8388608\n</code></pre> <p>ElectLeaders_result_t </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a7f8345f7468058dcce009b1ed891d36e </li> </ul>"},{"location":"api/constants/#rd_kafka_consumer_group_type_unknown","title":"RD_KAFKA_CONSUMER_GROUP_TYPE_UNKNOWN","text":"<p><pre><code>public RD_KAFKA_CONSUMER_GROUP_TYPE_UNKNOWN = 0\n</code></pre> enum rd_kafka_consumer_group_type_t</p>"},{"location":"api/constants/#rd_kafka_consumer_group_type_consumer","title":"RD_KAFKA_CONSUMER_GROUP_TYPE_CONSUMER","text":"<p><pre><code>public RD_KAFKA_CONSUMER_GROUP_TYPE_CONSUMER = 1\n</code></pre> enum rd_kafka_consumer_group_type_t</p>"},{"location":"api/constants/#rd_kafka_consumer_group_type_classic","title":"RD_KAFKA_CONSUMER_GROUP_TYPE_CLASSIC","text":"<p><pre><code>public RD_KAFKA_CONSUMER_GROUP_TYPE_CLASSIC = 2\n</code></pre> enum rd_kafka_consumer_group_type_t</p>"},{"location":"api/constants/#rd_kafka_consumer_group_type__cnt","title":"RD_KAFKA_CONSUMER_GROUP_TYPE__CNT","text":"<p><pre><code>public RD_KAFKA_CONSUMER_GROUP_TYPE__CNT = 3\n</code></pre> enum rd_kafka_consumer_group_type_t</p>"},{"location":"api/constants/#rd_kafka_admin_op_electleaders","title":"RD_KAFKA_ADMIN_OP_ELECTLEADERS","text":"<pre><code>public RD_KAFKA_ADMIN_OP_ELECTLEADERS = 22\n</code></pre> <p>ElectLeaders </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe </li> </ul>"},{"location":"api/constants/#rd_kafka_resource_transactional_id","title":"RD_KAFKA_RESOURCE_TRANSACTIONAL_ID","text":"<pre><code>public RD_KAFKA_RESOURCE_TRANSACTIONAL_ID = 5\n</code></pre> <p>Transactional ID </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#acca83a66d7783ff7683ed2691cc907c9 </li> </ul>"},{"location":"api/constants/#rd_kafka_election_type_preferred","title":"RD_KAFKA_ELECTION_TYPE_PREFERRED","text":"<pre><code>public RD_KAFKA_ELECTION_TYPE_PREFERRED = 0\n</code></pre> <p>Preferred Replica Election </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aea051bad25a647e140abc310d2f400d4 </li> </ul>"},{"location":"api/constants/#rd_kafka_election_type_unclean","title":"RD_KAFKA_ELECTION_TYPE_UNCLEAN","text":"<pre><code>public RD_KAFKA_ELECTION_TYPE_UNCLEAN = 1\n</code></pre> <p>Unclean Election </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aea051bad25a647e140abc310d2f400d4 </li> </ul>"},{"location":"api/constants/#rd_kafka_supported_methods","title":"RD_KAFKA_SUPPORTED_METHODS","text":"<pre><code>public RD_KAFKA_SUPPORTED_METHODS = ['rd_kafka_version' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_version_str' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_get_debug_contexts' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_get_err_descs' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_err2str' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_err2name' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_last_error' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_errno2err' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_errno' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_fatal_error' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_test_fatal_error' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_topic_partition_destroy' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_topic_partition_list_new' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_topic_partition_list_destroy' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_topic_partition_list_add' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_topic_partition_list_add_range' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_topic_partition_list_del' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_topic_partition_list_del_by_idx' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_topic_partition_list_copy' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_topic_partition_list_set_offset' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_topic_partition_list_find' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_topic_partition_list_sort' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_headers_new' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_headers_destroy' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_headers_copy' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_header_add' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_header_remove' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_header_get_last' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_header_get' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_header_get_all' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_message_destroy' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_message_timestamp' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_message_latency' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_message_headers' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_message_detach_headers' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_message_set_headers' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_header_cnt' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_message_status' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_conf_new' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_conf_destroy' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_conf_dup' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_conf_dup_filter' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_conf_set' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_conf_set_events' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_conf_set_background_event_cb' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_conf_set_dr_cb' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_conf_set_dr_msg_cb' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_conf_set_consume_cb' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_conf_set_rebalance_cb' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_conf_set_offset_commit_cb' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_conf_set_error_cb' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_conf_set_throttle_cb' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_conf_set_log_cb' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_conf_set_stats_cb' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_conf_set_socket_cb' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_conf_set_connect_cb' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_conf_set_closesocket_cb' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_conf_set_opaque' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_opaque' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_conf_set_default_topic_conf' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_conf_get' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_topic_conf_get' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_conf_dump' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_topic_conf_dump' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_conf_dump_free' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_conf_properties_show' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_topic_conf_new' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_topic_conf_dup' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_default_topic_conf_dup' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_topic_conf_destroy' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_topic_conf_set' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_topic_conf_set_opaque' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_topic_conf_set_partitioner_cb' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_topic_conf_set_msg_order_cmp' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_topic_partition_available' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_msg_partitioner_random' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_msg_partitioner_consistent' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_msg_partitioner_consistent_random' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_msg_partitioner_murmur2' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_msg_partitioner_murmur2_random' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_new' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_destroy' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_destroy_flags' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_name' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_type' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_memberid' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_clusterid' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_controllerid' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_topic_new' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_topic_destroy' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_topic_name' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_topic_opaque' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_poll' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_yield' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_pause_partitions' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_resume_partitions' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_query_watermark_offsets' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_get_watermark_offsets' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_offsets_for_times' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_mem_free' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_queue_new' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_queue_destroy' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_queue_get_main' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_queue_get_consumer' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_queue_get_partition' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_queue_get_background' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_queue_forward' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_set_log_queue' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_queue_length' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_queue_io_event_enable' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_queue_cb_event_enable' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_consume_start' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_consume_start_queue' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_consume_stop' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_seek' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_consume' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_consume_batch' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_consume_callback' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_consume_queue' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_consume_batch_queue' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_consume_callback_queue' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_offset_store' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_offsets_store' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_subscribe' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_unsubscribe' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_subscription' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_consumer_poll' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_consumer_close' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_assign' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_assignment' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_commit' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_commit_message' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_commit_queue' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_committed' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_position' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_produce' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_producev' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_produce_batch' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_flush' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_purge' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_metadata' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_metadata_destroy' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_list_groups' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_group_list_destroy' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_brokers_add' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_set_logger' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_set_log_level' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_log_print' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_log_syslog' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_outq_len' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_dump' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_thread_cnt' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_wait_destroyed' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_unittest' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_poll_set_consumer' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_event_type' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_event_name' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_event_destroy' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_event_message_next' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_event_message_array' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_event_message_count' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_event_error' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_event_error_string' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_event_error_is_fatal' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_event_opaque' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_event_log' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_event_stats' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_event_topic_partition_list' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_event_topic_partition' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_event_CreateTopics_result' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_event_DeleteTopics_result' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_event_CreatePartitions_result' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_event_AlterConfigs_result' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_event_DescribeConfigs_result' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_queue_poll' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_queue_poll_callback' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_plugin_f_conf_init_t' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_interceptor_f_on_conf_set_t' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_interceptor_f_on_conf_dup_t' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_interceptor_f_on_conf_destroy_t' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_interceptor_f_on_new_t' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_interceptor_f_on_destroy_t' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_interceptor_f_on_send_t' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_interceptor_f_on_acknowledgement_t' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_interceptor_f_on_consume_t' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_interceptor_f_on_commit_t' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_interceptor_f_on_request_sent_t' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_conf_interceptor_add_on_conf_set' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_conf_interceptor_add_on_conf_dup' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_conf_interceptor_add_on_conf_destroy' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_conf_interceptor_add_on_new' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_interceptor_add_on_destroy' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_interceptor_add_on_send' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_interceptor_add_on_acknowledgement' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_interceptor_add_on_consume' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_interceptor_add_on_commit' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_interceptor_add_on_request_sent' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_topic_result_error' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_topic_result_error_string' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_topic_result_name' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_AdminOptions_new' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_AdminOptions_destroy' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_AdminOptions_set_request_timeout' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_AdminOptions_set_operation_timeout' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_AdminOptions_set_validate_only' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_AdminOptions_set_broker' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_AdminOptions_set_opaque' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_NewTopic_new' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_NewTopic_destroy' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_NewTopic_destroy_array' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_NewTopic_set_replica_assignment' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_NewTopic_set_config' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_CreateTopics' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_CreateTopics_result_topics' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_DeleteTopic_new' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_DeleteTopic_destroy' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_DeleteTopic_destroy_array' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_DeleteTopics' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_DeleteTopics_result_topics' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_NewPartitions_new' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_NewPartitions_destroy' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_NewPartitions_destroy_array' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_NewPartitions_set_replica_assignment' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_CreatePartitions' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_CreatePartitions_result_topics' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_ConfigSource_name' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_ConfigEntry_name' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_ConfigEntry_value' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_ConfigEntry_source' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_ConfigEntry_is_read_only' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_ConfigEntry_is_default' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_ConfigEntry_is_sensitive' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_ConfigEntry_is_synonym' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_ConfigEntry_synonyms' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_ResourceType_name' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_ConfigResource_new' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_ConfigResource_destroy' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_ConfigResource_destroy_array' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_ConfigResource_set_config' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_ConfigResource_configs' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_ConfigResource_type' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_ConfigResource_name' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_ConfigResource_error' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_ConfigResource_error_string' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_AlterConfigs' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_AlterConfigs_result_resources' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_DescribeConfigs' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_DescribeConfigs_result_resources' =&gt; ['min' =&gt; '1.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_conf' =&gt; ['min' =&gt; '1.1.0', 'max' =&gt; '2.8.0'], 'rd_kafka_conf_set_oauthbearer_token_refresh_cb' =&gt; ['min' =&gt; '1.1.0', 'max' =&gt; '2.8.0'], 'rd_kafka_conf_set_ssl_cert_verify_cb' =&gt; ['min' =&gt; '1.1.0', 'max' =&gt; '2.8.0'], 'rd_kafka_conf_set_ssl_cert' =&gt; ['min' =&gt; '1.1.0', 'max' =&gt; '2.8.0'], 'rd_kafka_event_config_string' =&gt; ['min' =&gt; '1.1.0', 'max' =&gt; '2.8.0'], 'rd_kafka_oauthbearer_set_token' =&gt; ['min' =&gt; '1.1.0', 'max' =&gt; '2.8.0'], 'rd_kafka_oauthbearer_set_token_failure' =&gt; ['min' =&gt; '1.1.0', 'max' =&gt; '2.8.0'], 'rd_kafka_interceptor_f_on_thread_start_t' =&gt; ['min' =&gt; '1.2.0', 'max' =&gt; '2.8.0'], 'rd_kafka_interceptor_f_on_thread_exit_t' =&gt; ['min' =&gt; '1.2.0', 'max' =&gt; '2.8.0'], 'rd_kafka_interceptor_add_on_thread_start' =&gt; ['min' =&gt; '1.2.0', 'max' =&gt; '2.8.0'], 'rd_kafka_interceptor_add_on_thread_exit' =&gt; ['min' =&gt; '1.2.0', 'max' =&gt; '2.8.0'], 'rd_kafka_mock_cluster_new' =&gt; ['min' =&gt; '1.3.0', 'max' =&gt; '2.8.0'], 'rd_kafka_mock_cluster_destroy' =&gt; ['min' =&gt; '1.3.0', 'max' =&gt; '2.8.0'], 'rd_kafka_mock_cluster_handle' =&gt; ['min' =&gt; '1.3.0', 'max' =&gt; '2.8.0'], 'rd_kafka_mock_cluster_bootstraps' =&gt; ['min' =&gt; '1.3.0', 'max' =&gt; '2.8.0'], 'rd_kafka_mock_push_request_errors' =&gt; ['min' =&gt; '1.3.0', 'max' =&gt; '2.8.0'], 'rd_kafka_mock_topic_set_error' =&gt; ['min' =&gt; '1.3.0', 'max' =&gt; '2.8.0'], 'rd_kafka_mock_partition_set_leader' =&gt; ['min' =&gt; '1.3.0', 'max' =&gt; '2.8.0'], 'rd_kafka_mock_partition_set_follower' =&gt; ['min' =&gt; '1.3.0', 'max' =&gt; '2.8.0'], 'rd_kafka_mock_partition_set_follower_wmarks' =&gt; ['min' =&gt; '1.3.0', 'max' =&gt; '2.8.0'], 'rd_kafka_mock_broker_set_rack' =&gt; ['min' =&gt; '1.3.0', 'max' =&gt; '2.8.0'], 'rd_kafka_error_code' =&gt; ['min' =&gt; '1.4.0', 'max' =&gt; '2.8.0'], 'rd_kafka_error_name' =&gt; ['min' =&gt; '1.4.0', 'max' =&gt; '2.8.0'], 'rd_kafka_error_string' =&gt; ['min' =&gt; '1.4.0', 'max' =&gt; '2.8.0'], 'rd_kafka_error_is_fatal' =&gt; ['min' =&gt; '1.4.0', 'max' =&gt; '2.8.0'], 'rd_kafka_error_is_retriable' =&gt; ['min' =&gt; '1.4.0', 'max' =&gt; '2.8.0'], 'rd_kafka_error_txn_requires_abort' =&gt; ['min' =&gt; '1.4.0', 'max' =&gt; '2.8.0'], 'rd_kafka_error_destroy' =&gt; ['min' =&gt; '1.4.0', 'max' =&gt; '2.8.0'], 'rd_kafka_error_new' =&gt; ['min' =&gt; '1.4.0', 'max' =&gt; '2.8.0'], 'rd_kafka_msg_partitioner_fnv1a' =&gt; ['min' =&gt; '1.4.0', 'max' =&gt; '2.8.0'], 'rd_kafka_msg_partitioner_fnv1a_random' =&gt; ['min' =&gt; '1.4.0', 'max' =&gt; '2.8.0'], 'rd_kafka_consumer_group_metadata' =&gt; ['min' =&gt; '1.4.0', 'max' =&gt; '2.8.0'], 'rd_kafka_consumer_group_metadata_new' =&gt; ['min' =&gt; '1.4.0', 'max' =&gt; '2.8.0'], 'rd_kafka_consumer_group_metadata_destroy' =&gt; ['min' =&gt; '1.4.0', 'max' =&gt; '2.8.0'], 'rd_kafka_consumer_group_metadata_write' =&gt; ['min' =&gt; '1.4.0', 'max' =&gt; '2.8.0'], 'rd_kafka_consumer_group_metadata_read' =&gt; ['min' =&gt; '1.4.0', 'max' =&gt; '2.8.0'], 'rd_kafka_init_transactions' =&gt; ['min' =&gt; '1.4.0', 'max' =&gt; '2.8.0'], 'rd_kafka_begin_transaction' =&gt; ['min' =&gt; '1.4.0', 'max' =&gt; '2.8.0'], 'rd_kafka_send_offsets_to_transaction' =&gt; ['min' =&gt; '1.4.0', 'max' =&gt; '2.8.0'], 'rd_kafka_commit_transaction' =&gt; ['min' =&gt; '1.4.0', 'max' =&gt; '2.8.0'], 'rd_kafka_abort_transaction' =&gt; ['min' =&gt; '1.4.0', 'max' =&gt; '2.8.0'], 'rd_kafka_handle_mock_cluster' =&gt; ['min' =&gt; '1.4.0', 'max' =&gt; '2.8.0'], 'rd_kafka_mock_topic_create' =&gt; ['min' =&gt; '1.4.0', 'max' =&gt; '2.8.0'], 'rd_kafka_mock_broker_set_down' =&gt; ['min' =&gt; '1.4.0', 'max' =&gt; '2.8.0'], 'rd_kafka_mock_broker_set_up' =&gt; ['min' =&gt; '1.4.0', 'max' =&gt; '2.8.0'], 'rd_kafka_mock_coordinator_set' =&gt; ['min' =&gt; '1.4.0', 'max' =&gt; '2.8.0'], 'rd_kafka_mock_set_apiversion' =&gt; ['min' =&gt; '1.4.0', 'max' =&gt; '2.8.0'], 'rd_kafka_mock_broker_set_rtt' =&gt; ['min' =&gt; '1.4.4', 'max' =&gt; '2.8.0'], 'rd_kafka_message_errstr' =&gt; ['min' =&gt; '1.5.0', 'max' =&gt; '2.8.0'], 'rd_kafka_message_broker_id' =&gt; ['min' =&gt; '1.5.0', 'max' =&gt; '2.8.0'], 'rd_kafka_produceva' =&gt; ['min' =&gt; '1.5.0', 'max' =&gt; '2.8.0'], 'rd_kafka_event_debug_contexts' =&gt; ['min' =&gt; '1.5.0', 'max' =&gt; '2.8.0'], 'rd_kafka_mock_broker_push_request_errors' =&gt; ['min' =&gt; '1.5.0', 'max' =&gt; '1.6.2'], 'rd_kafka_conf_get_default_topic_conf' =&gt; ['min' =&gt; '1.6.0', 'max' =&gt; '2.8.0'], 'rd_kafka_queue_yield' =&gt; ['min' =&gt; '1.6.0', 'max' =&gt; '2.8.0'], 'rd_kafka_seek_partitions' =&gt; ['min' =&gt; '1.6.0', 'max' =&gt; '2.8.0'], 'rd_kafka_incremental_assign' =&gt; ['min' =&gt; '1.6.0', 'max' =&gt; '2.8.0'], 'rd_kafka_incremental_unassign' =&gt; ['min' =&gt; '1.6.0', 'max' =&gt; '2.8.0'], 'rd_kafka_rebalance_protocol' =&gt; ['min' =&gt; '1.6.0', 'max' =&gt; '2.8.0'], 'rd_kafka_assignment_lost' =&gt; ['min' =&gt; '1.6.0', 'max' =&gt; '2.8.0'], 'rd_kafka_consumer_group_metadata_new_with_genid' =&gt; ['min' =&gt; '1.6.0', 'max' =&gt; '2.8.0'], 'rd_kafka_event_DeleteRecords_result' =&gt; ['min' =&gt; '1.6.0', 'max' =&gt; '2.8.0'], 'rd_kafka_event_DeleteGroups_result' =&gt; ['min' =&gt; '1.6.0', 'max' =&gt; '2.8.0'], 'rd_kafka_event_DeleteConsumerGroupOffsets_result' =&gt; ['min' =&gt; '1.6.0', 'max' =&gt; '2.8.0'], 'rd_kafka_group_result_error' =&gt; ['min' =&gt; '1.6.0', 'max' =&gt; '2.8.0'], 'rd_kafka_group_result_name' =&gt; ['min' =&gt; '1.6.0', 'max' =&gt; '2.8.0'], 'rd_kafka_group_result_partitions' =&gt; ['min' =&gt; '1.6.0', 'max' =&gt; '2.8.0'], 'rd_kafka_DeleteRecords_new' =&gt; ['min' =&gt; '1.6.0', 'max' =&gt; '2.8.0'], 'rd_kafka_DeleteRecords_destroy' =&gt; ['min' =&gt; '1.6.0', 'max' =&gt; '2.8.0'], 'rd_kafka_DeleteRecords_destroy_array' =&gt; ['min' =&gt; '1.6.0', 'max' =&gt; '2.8.0'], 'rd_kafka_DeleteRecords' =&gt; ['min' =&gt; '1.6.0', 'max' =&gt; '2.8.0'], 'rd_kafka_DeleteRecords_result_offsets' =&gt; ['min' =&gt; '1.6.0', 'max' =&gt; '2.8.0'], 'rd_kafka_DeleteGroup_new' =&gt; ['min' =&gt; '1.6.0', 'max' =&gt; '2.8.0'], 'rd_kafka_DeleteGroup_destroy' =&gt; ['min' =&gt; '1.6.0', 'max' =&gt; '2.8.0'], 'rd_kafka_DeleteGroup_destroy_array' =&gt; ['min' =&gt; '1.6.0', 'max' =&gt; '2.8.0'], 'rd_kafka_DeleteGroups' =&gt; ['min' =&gt; '1.6.0', 'max' =&gt; '2.8.0'], 'rd_kafka_DeleteGroups_result_groups' =&gt; ['min' =&gt; '1.6.0', 'max' =&gt; '2.8.0'], 'rd_kafka_DeleteConsumerGroupOffsets_new' =&gt; ['min' =&gt; '1.6.0', 'max' =&gt; '2.8.0'], 'rd_kafka_DeleteConsumerGroupOffsets_destroy' =&gt; ['min' =&gt; '1.6.0', 'max' =&gt; '2.8.0'], 'rd_kafka_DeleteConsumerGroupOffsets_destroy_array' =&gt; ['min' =&gt; '1.6.0', 'max' =&gt; '2.8.0'], 'rd_kafka_DeleteConsumerGroupOffsets' =&gt; ['min' =&gt; '1.6.0', 'max' =&gt; '2.8.0'], 'rd_kafka_DeleteConsumerGroupOffsets_result_groups' =&gt; ['min' =&gt; '1.6.0', 'max' =&gt; '2.8.0'], 'rd_kafka_mock_clear_request_errors' =&gt; ['min' =&gt; '1.6.0', 'max' =&gt; '2.8.0'], 'rd_kafka_mock_push_request_errors_array' =&gt; ['min' =&gt; '1.6.0', 'max' =&gt; '2.8.0'], 'rd_kafka_interceptor_f_on_response_received_t' =&gt; ['min' =&gt; '1.6.1', 'max' =&gt; '2.8.0'], 'rd_kafka_interceptor_add_on_response_received' =&gt; ['min' =&gt; '1.6.1', 'max' =&gt; '2.8.0'], 'rd_kafka_conf_set_engine_callback_data' =&gt; ['min' =&gt; '1.7.0', 'max' =&gt; '2.8.0'], 'rd_kafka_mem_calloc' =&gt; ['min' =&gt; '1.7.0', 'max' =&gt; '2.8.0'], 'rd_kafka_mem_malloc' =&gt; ['min' =&gt; '1.7.0', 'max' =&gt; '2.8.0'], 'rd_kafka_mock_broker_push_request_error_rtts' =&gt; ['min' =&gt; '1.7.0', 'max' =&gt; '2.8.0'], 'rd_kafka_conf_enable_sasl_queue' =&gt; ['min' =&gt; '1.9.0', 'max' =&gt; '2.8.0'], 'rd_kafka_queue_get_sasl' =&gt; ['min' =&gt; '1.9.0', 'max' =&gt; '2.8.0'], 'rd_kafka_sasl_background_callbacks_enable' =&gt; ['min' =&gt; '1.9.0', 'max' =&gt; '2.8.0'], 'rd_kafka_consumer_close_queue' =&gt; ['min' =&gt; '1.9.0', 'max' =&gt; '2.8.0'], 'rd_kafka_consumer_closed' =&gt; ['min' =&gt; '1.9.0', 'max' =&gt; '2.8.0'], 'rd_kafka_event_CreateAcls_result' =&gt; ['min' =&gt; '1.9.0', 'max' =&gt; '2.8.0'], 'rd_kafka_event_DescribeAcls_result' =&gt; ['min' =&gt; '1.9.0', 'max' =&gt; '2.8.0'], 'rd_kafka_event_DeleteAcls_result' =&gt; ['min' =&gt; '1.9.0', 'max' =&gt; '2.8.0'], 'rd_kafka_ResourcePatternType_name' =&gt; ['min' =&gt; '1.9.0', 'max' =&gt; '2.8.0'], 'rd_kafka_acl_result_error' =&gt; ['min' =&gt; '1.9.0', 'max' =&gt; '2.8.0'], 'rd_kafka_AclOperation_name' =&gt; ['min' =&gt; '1.9.0', 'max' =&gt; '2.8.0'], 'rd_kafka_AclPermissionType_name' =&gt; ['min' =&gt; '1.9.0', 'max' =&gt; '2.8.0'], 'rd_kafka_AclBinding_new' =&gt; ['min' =&gt; '1.9.0', 'max' =&gt; '2.8.0'], 'rd_kafka_AclBindingFilter_new' =&gt; ['min' =&gt; '1.9.0', 'max' =&gt; '2.8.0'], 'rd_kafka_AclBinding_restype' =&gt; ['min' =&gt; '1.9.0', 'max' =&gt; '2.8.0'], 'rd_kafka_AclBinding_name' =&gt; ['min' =&gt; '1.9.0', 'max' =&gt; '2.8.0'], 'rd_kafka_AclBinding_principal' =&gt; ['min' =&gt; '1.9.0', 'max' =&gt; '2.8.0'], 'rd_kafka_AclBinding_host' =&gt; ['min' =&gt; '1.9.0', 'max' =&gt; '2.8.0'], 'rd_kafka_AclBinding_operation' =&gt; ['min' =&gt; '1.9.0', 'max' =&gt; '2.8.0'], 'rd_kafka_AclBinding_permission_type' =&gt; ['min' =&gt; '1.9.0', 'max' =&gt; '2.8.0'], 'rd_kafka_AclBinding_resource_pattern_type' =&gt; ['min' =&gt; '1.9.0', 'max' =&gt; '2.8.0'], 'rd_kafka_AclBinding_error' =&gt; ['min' =&gt; '1.9.0', 'max' =&gt; '2.8.0'], 'rd_kafka_AclBinding_destroy' =&gt; ['min' =&gt; '1.9.0', 'max' =&gt; '2.8.0'], 'rd_kafka_AclBinding_destroy_array' =&gt; ['min' =&gt; '1.9.0', 'max' =&gt; '2.8.0'], 'rd_kafka_CreateAcls_result_acls' =&gt; ['min' =&gt; '1.9.0', 'max' =&gt; '2.8.0'], 'rd_kafka_CreateAcls' =&gt; ['min' =&gt; '1.9.0', 'max' =&gt; '2.8.0'], 'rd_kafka_DescribeAcls_result_acls' =&gt; ['min' =&gt; '1.9.0', 'max' =&gt; '2.8.0'], 'rd_kafka_DescribeAcls' =&gt; ['min' =&gt; '1.9.0', 'max' =&gt; '2.8.0'], 'rd_kafka_DeleteAcls_result_responses' =&gt; ['min' =&gt; '1.9.0', 'max' =&gt; '2.8.0'], 'rd_kafka_DeleteAcls_result_response_error' =&gt; ['min' =&gt; '1.9.0', 'max' =&gt; '2.8.0'], 'rd_kafka_DeleteAcls_result_response_matching_acls' =&gt; ['min' =&gt; '1.9.0', 'max' =&gt; '2.8.0'], 'rd_kafka_DeleteAcls' =&gt; ['min' =&gt; '1.9.0', 'max' =&gt; '2.8.0'], 'rd_kafka_conf_set_resolve_cb' =&gt; ['min' =&gt; '2.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_sasl_set_credentials' =&gt; ['min' =&gt; '2.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_Node_id' =&gt; ['min' =&gt; '2.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_Node_host' =&gt; ['min' =&gt; '2.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_Node_port' =&gt; ['min' =&gt; '2.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_consumer_group_state_name' =&gt; ['min' =&gt; '2.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_consumer_group_state_code' =&gt; ['min' =&gt; '2.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_event_ListConsumerGroups_result' =&gt; ['min' =&gt; '2.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_event_DescribeConsumerGroups_result' =&gt; ['min' =&gt; '2.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_event_AlterConsumerGroupOffsets_result' =&gt; ['min' =&gt; '2.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_event_ListConsumerGroupOffsets_result' =&gt; ['min' =&gt; '2.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_interceptor_f_on_broker_state_change_t' =&gt; ['min' =&gt; '2.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_interceptor_add_on_broker_state_change' =&gt; ['min' =&gt; '2.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_AdminOptions_set_require_stable_offsets' =&gt; ['min' =&gt; '2.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_AdminOptions_set_match_consumer_group_states' =&gt; ['min' =&gt; '2.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_ListConsumerGroups' =&gt; ['min' =&gt; '2.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_ConsumerGroupListing_group_id' =&gt; ['min' =&gt; '2.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_ConsumerGroupListing_is_simple_consumer_group' =&gt; ['min' =&gt; '2.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_ConsumerGroupListing_state' =&gt; ['min' =&gt; '2.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_ListConsumerGroups_result_valid' =&gt; ['min' =&gt; '2.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_ListConsumerGroups_result_errors' =&gt; ['min' =&gt; '2.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_DescribeConsumerGroups' =&gt; ['min' =&gt; '2.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_DescribeConsumerGroups_result_groups' =&gt; ['min' =&gt; '2.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_ConsumerGroupDescription_group_id' =&gt; ['min' =&gt; '2.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_ConsumerGroupDescription_error' =&gt; ['min' =&gt; '2.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_ConsumerGroupDescription_is_simple_consumer_group' =&gt; ['min' =&gt; '2.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_ConsumerGroupDescription_partition_assignor' =&gt; ['min' =&gt; '2.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_ConsumerGroupDescription_state' =&gt; ['min' =&gt; '2.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_ConsumerGroupDescription_coordinator' =&gt; ['min' =&gt; '2.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_ConsumerGroupDescription_member_count' =&gt; ['min' =&gt; '2.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_ConsumerGroupDescription_member' =&gt; ['min' =&gt; '2.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_MemberDescription_client_id' =&gt; ['min' =&gt; '2.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_MemberDescription_group_instance_id' =&gt; ['min' =&gt; '2.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_MemberDescription_consumer_id' =&gt; ['min' =&gt; '2.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_MemberDescription_host' =&gt; ['min' =&gt; '2.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_MemberDescription_assignment' =&gt; ['min' =&gt; '2.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_MemberAssignment_partitions' =&gt; ['min' =&gt; '2.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_ListConsumerGroupOffsets_new' =&gt; ['min' =&gt; '2.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_ListConsumerGroupOffsets_destroy' =&gt; ['min' =&gt; '2.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_ListConsumerGroupOffsets_destroy_array' =&gt; ['min' =&gt; '2.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_ListConsumerGroupOffsets' =&gt; ['min' =&gt; '2.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_ListConsumerGroupOffsets_result_groups' =&gt; ['min' =&gt; '2.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_AlterConsumerGroupOffsets_new' =&gt; ['min' =&gt; '2.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_AlterConsumerGroupOffsets_destroy' =&gt; ['min' =&gt; '2.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_AlterConsumerGroupOffsets_destroy_array' =&gt; ['min' =&gt; '2.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_AlterConsumerGroupOffsets' =&gt; ['min' =&gt; '2.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_AlterConsumerGroupOffsets_result_groups' =&gt; ['min' =&gt; '2.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_mock_broker_error_stack_cnt' =&gt; ['min' =&gt; '2.0.0', 'max' =&gt; '2.8.0'], 'rd_kafka_topic_partition_set_leader_epoch' =&gt; ['min' =&gt; '2.1.0', 'max' =&gt; '2.8.0'], 'rd_kafka_topic_partition_get_leader_epoch' =&gt; ['min' =&gt; '2.1.0', 'max' =&gt; '2.8.0'], 'rd_kafka_message_leader_epoch' =&gt; ['min' =&gt; '2.1.0', 'max' =&gt; '2.8.0'], 'rd_kafka_offset_store_message' =&gt; ['min' =&gt; '2.1.0', 'max' =&gt; '2.8.0'], 'rd_kafka_event_IncrementalAlterConfigs_result' =&gt; ['min' =&gt; '2.2.0', 'max' =&gt; '2.8.0'], 'rd_kafka_event_DescribeUserScramCredentials_result' =&gt; ['min' =&gt; '2.2.0', 'max' =&gt; '2.8.0'], 'rd_kafka_event_AlterUserScramCredentials_result' =&gt; ['min' =&gt; '2.2.0', 'max' =&gt; '2.8.0'], 'rd_kafka_ConfigResource_add_incremental_config' =&gt; ['min' =&gt; '2.2.0', 'max' =&gt; '2.8.0'], 'rd_kafka_IncrementalAlterConfigs' =&gt; ['min' =&gt; '2.2.0', 'max' =&gt; '2.8.0'], 'rd_kafka_IncrementalAlterConfigs_result_resources' =&gt; ['min' =&gt; '2.2.0', 'max' =&gt; '2.8.0'], 'rd_kafka_ScramCredentialInfo_mechanism' =&gt; ['min' =&gt; '2.2.0', 'max' =&gt; '2.8.0'], 'rd_kafka_ScramCredentialInfo_iterations' =&gt; ['min' =&gt; '2.2.0', 'max' =&gt; '2.8.0'], 'rd_kafka_UserScramCredentialsDescription_user' =&gt; ['min' =&gt; '2.2.0', 'max' =&gt; '2.8.0'], 'rd_kafka_UserScramCredentialsDescription_error' =&gt; ['min' =&gt; '2.2.0', 'max' =&gt; '2.8.0'], 'rd_kafka_UserScramCredentialsDescription_scramcredentialinfo_count' =&gt; ['min' =&gt; '2.2.0', 'max' =&gt; '2.8.0'], 'rd_kafka_UserScramCredentialsDescription_scramcredentialinfo' =&gt; ['min' =&gt; '2.2.0', 'max' =&gt; '2.8.0'], 'rd_kafka_DescribeUserScramCredentials_result_descriptions' =&gt; ['min' =&gt; '2.2.0', 'max' =&gt; '2.8.0'], 'rd_kafka_DescribeUserScramCredentials' =&gt; ['min' =&gt; '2.2.0', 'max' =&gt; '2.8.0'], 'rd_kafka_UserScramCredentialUpsertion_new' =&gt; ['min' =&gt; '2.2.0', 'max' =&gt; '2.8.0'], 'rd_kafka_UserScramCredentialDeletion_new' =&gt; ['min' =&gt; '2.2.0', 'max' =&gt; '2.8.0'], 'rd_kafka_UserScramCredentialAlteration_destroy' =&gt; ['min' =&gt; '2.2.0', 'max' =&gt; '2.8.0'], 'rd_kafka_UserScramCredentialAlteration_destroy_array' =&gt; ['min' =&gt; '2.2.0', 'max' =&gt; '2.8.0'], 'rd_kafka_AlterUserScramCredentials_result_response_user' =&gt; ['min' =&gt; '2.2.0', 'max' =&gt; '2.8.0'], 'rd_kafka_AlterUserScramCredentials_result_response_error' =&gt; ['min' =&gt; '2.2.0', 'max' =&gt; '2.8.0'], 'rd_kafka_AlterUserScramCredentials_result_responses' =&gt; ['min' =&gt; '2.2.0', 'max' =&gt; '2.8.0'], 'rd_kafka_AlterUserScramCredentials' =&gt; ['min' =&gt; '2.2.0', 'max' =&gt; '2.8.0'], 'rd_kafka_Uuid_base64str' =&gt; ['min' =&gt; '2.3.0', 'max' =&gt; '2.8.0'], 'rd_kafka_Uuid_least_significant_bits' =&gt; ['min' =&gt; '2.3.0', 'max' =&gt; '2.8.0'], 'rd_kafka_Uuid_most_significant_bits' =&gt; ['min' =&gt; '2.3.0', 'max' =&gt; '2.8.0'], 'rd_kafka_Uuid_new' =&gt; ['min' =&gt; '2.3.0', 'max' =&gt; '2.8.0'], 'rd_kafka_Uuid_copy' =&gt; ['min' =&gt; '2.3.0', 'max' =&gt; '2.8.0'], 'rd_kafka_Uuid_destroy' =&gt; ['min' =&gt; '2.3.0', 'max' =&gt; '2.8.0'], 'rd_kafka_Node_rack' =&gt; ['min' =&gt; '2.3.0', 'max' =&gt; '2.8.0'], 'rd_kafka_event_DescribeTopics_result' =&gt; ['min' =&gt; '2.3.0', 'max' =&gt; '2.8.0'], 'rd_kafka_event_DescribeCluster_result' =&gt; ['min' =&gt; '2.3.0', 'max' =&gt; '2.8.0'], 'rd_kafka_event_ListOffsets_result' =&gt; ['min' =&gt; '2.3.0', 'max' =&gt; '2.8.0'], 'rd_kafka_AdminOptions_set_include_authorized_operations' =&gt; ['min' =&gt; '2.3.0', 'max' =&gt; '2.8.0'], 'rd_kafka_AdminOptions_set_isolation_level' =&gt; ['min' =&gt; '2.3.0', 'max' =&gt; '2.8.0'], 'rd_kafka_TopicCollection_of_topic_names' =&gt; ['min' =&gt; '2.3.0', 'max' =&gt; '2.8.0'], 'rd_kafka_TopicCollection_destroy' =&gt; ['min' =&gt; '2.3.0', 'max' =&gt; '2.8.0'], 'rd_kafka_DescribeTopics' =&gt; ['min' =&gt; '2.3.0', 'max' =&gt; '2.8.0'], 'rd_kafka_DescribeTopics_result_topics' =&gt; ['min' =&gt; '2.3.0', 'max' =&gt; '2.8.0'], 'rd_kafka_TopicDescription_partitions' =&gt; ['min' =&gt; '2.3.0', 'max' =&gt; '2.8.0'], 'rd_kafka_TopicPartitionInfo_partition' =&gt; ['min' =&gt; '2.3.0', 'max' =&gt; '2.8.0'], 'rd_kafka_TopicPartitionInfo_leader' =&gt; ['min' =&gt; '2.3.0', 'max' =&gt; '2.8.0'], 'rd_kafka_TopicPartitionInfo_isr' =&gt; ['min' =&gt; '2.3.0', 'max' =&gt; '2.8.0'], 'rd_kafka_TopicPartitionInfo_replicas' =&gt; ['min' =&gt; '2.3.0', 'max' =&gt; '2.8.0'], 'rd_kafka_TopicDescription_authorized_operations' =&gt; ['min' =&gt; '2.3.0', 'max' =&gt; '2.8.0'], 'rd_kafka_TopicDescription_name' =&gt; ['min' =&gt; '2.3.0', 'max' =&gt; '2.8.0'], 'rd_kafka_TopicDescription_topic_id' =&gt; ['min' =&gt; '2.3.0', 'max' =&gt; '2.8.0'], 'rd_kafka_TopicDescription_is_internal' =&gt; ['min' =&gt; '2.3.0', 'max' =&gt; '2.8.0'], 'rd_kafka_TopicDescription_error' =&gt; ['min' =&gt; '2.3.0', 'max' =&gt; '2.8.0'], 'rd_kafka_DescribeCluster' =&gt; ['min' =&gt; '2.3.0', 'max' =&gt; '2.8.0'], 'rd_kafka_DescribeCluster_result_nodes' =&gt; ['min' =&gt; '2.3.0', 'max' =&gt; '2.8.0'], 'rd_kafka_DescribeCluster_result_authorized_operations' =&gt; ['min' =&gt; '2.3.0', 'max' =&gt; '2.8.0'], 'rd_kafka_DescribeCluster_result_controller' =&gt; ['min' =&gt; '2.3.0', 'max' =&gt; '2.8.0'], 'rd_kafka_DescribeCluster_result_cluster_id' =&gt; ['min' =&gt; '2.3.0', 'max' =&gt; '2.8.0'], 'rd_kafka_ConsumerGroupDescription_authorized_operations' =&gt; ['min' =&gt; '2.3.0', 'max' =&gt; '2.8.0'], 'rd_kafka_ListOffsetsResultInfo_topic_partition' =&gt; ['min' =&gt; '2.3.0', 'max' =&gt; '2.8.0'], 'rd_kafka_ListOffsetsResultInfo_timestamp' =&gt; ['min' =&gt; '2.3.0', 'max' =&gt; '2.8.0'], 'rd_kafka_ListOffsets_result_infos' =&gt; ['min' =&gt; '2.3.0', 'max' =&gt; '2.8.0'], 'rd_kafka_ListOffsets' =&gt; ['min' =&gt; '2.3.0', 'max' =&gt; '2.8.0'], 'rd_kafka_mock_start_request_tracking' =&gt; ['min' =&gt; '2.3.0', 'max' =&gt; '2.8.0'], 'rd_kafka_mock_stop_request_tracking' =&gt; ['min' =&gt; '2.3.0', 'max' =&gt; '2.8.0'], 'rd_kafka_mock_request_destroy' =&gt; ['min' =&gt; '2.3.0', 'max' =&gt; '2.8.0'], 'rd_kafka_mock_request_id' =&gt; ['min' =&gt; '2.3.0', 'max' =&gt; '2.8.0'], 'rd_kafka_mock_request_api_key' =&gt; ['min' =&gt; '2.3.0', 'max' =&gt; '2.8.0'], 'rd_kafka_mock_request_timestamp' =&gt; ['min' =&gt; '2.3.0', 'max' =&gt; '2.8.0'], 'rd_kafka_mock_get_requests' =&gt; ['min' =&gt; '2.3.0', 'max' =&gt; '2.8.0'], 'rd_kafka_mock_clear_requests' =&gt; ['min' =&gt; '2.3.0', 'max' =&gt; '2.8.0'], 'rd_kafka_message_produce_errstr' =&gt; ['min' =&gt; '2.4.0', 'max' =&gt; '2.8.0'], 'rd_kafka_consumer_group_metadata_member_id' =&gt; ['min' =&gt; '2.4.0', 'max' =&gt; '2.8.0'], 'rd_kafka_mock_partition_push_leader_response' =&gt; ['min' =&gt; '2.4.0', 'max' =&gt; '2.8.0'], 'rd_kafka_mock_request_destroy_array' =&gt; ['min' =&gt; '2.4.0', 'max' =&gt; '2.8.0'], 'rd_kafka_mock_telemetry_set_requested_metrics' =&gt; ['min' =&gt; '2.5.0', 'max' =&gt; '2.8.0'], 'rd_kafka_mock_telemetry_set_push_interval' =&gt; ['min' =&gt; '2.5.0', 'max' =&gt; '2.8.0'], 'rd_kafka_consumer_group_type_name' =&gt; ['min' =&gt; '2.6.0', 'max' =&gt; '2.8.0'], 'rd_kafka_consumer_group_type_code' =&gt; ['min' =&gt; '2.6.0', 'max' =&gt; '2.8.0'], 'rd_kafka_event_ElectLeaders_result' =&gt; ['min' =&gt; '2.6.0', 'max' =&gt; '2.8.0'], 'rd_kafka_topic_partition_result_partition' =&gt; ['min' =&gt; '2.6.0', 'max' =&gt; '2.8.0'], 'rd_kafka_topic_partition_result_error' =&gt; ['min' =&gt; '2.6.0', 'max' =&gt; '2.8.0'], 'rd_kafka_AdminOptions_set_match_consumer_group_types' =&gt; ['min' =&gt; '2.6.0', 'max' =&gt; '2.8.0'], 'rd_kafka_ConsumerGroupListing_type' =&gt; ['min' =&gt; '2.6.0', 'max' =&gt; '2.8.0'], 'rd_kafka_ElectLeaders_new' =&gt; ['min' =&gt; '2.6.0', 'max' =&gt; '2.8.0'], 'rd_kafka_ElectLeaders_destroy' =&gt; ['min' =&gt; '2.6.0', 'max' =&gt; '2.8.0'], 'rd_kafka_ElectLeaders' =&gt; ['min' =&gt; '2.6.0', 'max' =&gt; '2.8.0'], 'rd_kafka_ElectLeaders_result_partitions' =&gt; ['min' =&gt; '2.6.0', 'max' =&gt; '2.8.0'], 'rd_kafka_mock_group_initial_rebalance_delay_ms' =&gt; ['min' =&gt; '2.6.0', 'max' =&gt; '2.8.0'], 'rd_kafka_consumer_group_metadata_group_id' =&gt; ['min' =&gt; '2.8.0', 'max' =&gt; '2.8.0'], 'rd_kafka_consumer_group_metadata_group_instance_id' =&gt; ['min' =&gt; '2.8.0', 'max' =&gt; '2.8.0'], 'rd_kafka_consumer_group_metadata_generation_id' =&gt; ['min' =&gt; '2.8.0', 'max' =&gt; '2.8.0'], 'rd_kafka_mock_cgrp_consumer_target_assignment_new' =&gt; ['min' =&gt; '2.8.0', 'max' =&gt; '2.8.0'], 'rd_kafka_mock_cgrp_consumer_target_assignment_destroy' =&gt; ['min' =&gt; '2.8.0', 'max' =&gt; '2.8.0'], 'rd_kafka_mock_cgrp_consumer_target_assignment' =&gt; ['min' =&gt; '2.8.0', 'max' =&gt; '2.8.0'], 'rd_kafka_mock_set_group_consumer_session_timeout_ms' =&gt; ['min' =&gt; '2.8.0', 'max' =&gt; '2.8.0'], 'rd_kafka_mock_set_group_consumer_heartbeat_interval_ms' =&gt; ['min' =&gt; '2.8.0', 'max' =&gt; '2.8.0']]\n</code></pre>"},{"location":"api/constants/#rd_kafka_version","title":"RD_KAFKA_VERSION","text":"<pre><code>public RD_KAFKA_VERSION = 16777471\n</code></pre> <p>librdkafka version </p> <p>Interpreted as hex <code>MM.mm.rr.xx</code>:</p> <ul> <li>MM = Major</li> <li>mm = minor</li> <li>rr = revision</li> <li>xx = pre-release id (0xff is the final release)</li> </ul> <p>E.g.: <code>0x000801ff</code> = 0.8.1</p> RemarksThis value should only be used during compile time, for runtime checks of version use rd_kafka_version()  <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_unsupported_compression_type","title":"RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE","text":"<pre><code>public RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 74\n</code></pre> <p>Unsupported compression type </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_end_all","title":"RD_KAFKA_RESP_ERR_END_ALL","text":"<p><pre><code>public RD_KAFKA_RESP_ERR_END_ALL = 75\n</code></pre> enum rd_kafka_resp_err_t</p>"},{"location":"api/constants/#rd_kafka_admin_op__cnt","title":"RD_KAFKA_ADMIN_OP__CNT","text":"<pre><code>public RD_KAFKA_ADMIN_OP__CNT = 6\n</code></pre> <p>Number of ops defined </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe </li> </ul>"},{"location":"api/constants/#rd_kafka_resource__cnt","title":"RD_KAFKA_RESOURCE__CNT","text":"<pre><code>public RD_KAFKA_RESOURCE__CNT = 5\n</code></pre> <p>Number of resource types defined </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#acca83a66d7783ff7683ed2691cc907c9 </li> </ul>"},{"location":"api/constants/#rd_kafka_cdef","title":"RD_KAFKA_CDEF","text":"<p><pre><code>public RD_KAFKA_CDEF = 'typedef long int ssize_t;\ntypedef struct _IO_FILE FILE;\ntypedef long int mode_t;\ntypedef signed int int16_t;\ntypedef unsigned int uint16_t;\ntypedef signed int int32_t;\ntypedef signed long int int64_t;\nint rd_kafka_version(void);\nconst char *rd_kafka_version_str(void);\ntypedef enum rd_kafka_type_t {\n  RD_KAFKA_PRODUCER,\n  RD_KAFKA_CONSUMER,\n} rd_kafka_type_t;\ntypedef enum rd_kafka_timestamp_type_t {\n  RD_KAFKA_TIMESTAMP_NOT_AVAILABLE,\n  RD_KAFKA_TIMESTAMP_CREATE_TIME,\n  RD_KAFKA_TIMESTAMP_LOG_APPEND_TIME,\n} rd_kafka_timestamp_type_t;\nconst char *rd_kafka_get_debug_contexts(void);\ntypedef struct rd_kafka_s rd_kafka_t;\ntypedef struct rd_kafka_topic_s rd_kafka_topic_t;\ntypedef struct rd_kafka_conf_s rd_kafka_conf_t;\ntypedef struct rd_kafka_topic_conf_s rd_kafka_topic_conf_t;\ntypedef struct rd_kafka_queue_s rd_kafka_queue_t;\ntypedef struct rd_kafka_op_s rd_kafka_event_t;\ntypedef struct rd_kafka_topic_result_s rd_kafka_topic_result_t;\ntypedef enum {\n  RD_KAFKA_RESP_ERR__BEGIN = (- 200),\n  RD_KAFKA_RESP_ERR__BAD_MSG = (- 199),\n  RD_KAFKA_RESP_ERR__BAD_COMPRESSION = (- 198),\n  RD_KAFKA_RESP_ERR__DESTROY = (- 197),\n  RD_KAFKA_RESP_ERR__FAIL = (- 196),\n  RD_KAFKA_RESP_ERR__TRANSPORT = (- 195),\n  RD_KAFKA_RESP_ERR__CRIT_SYS_RESOURCE = (- 194),\n  RD_KAFKA_RESP_ERR__RESOLVE = (- 193),\n  RD_KAFKA_RESP_ERR__MSG_TIMED_OUT = (- 192),\n  RD_KAFKA_RESP_ERR__PARTITION_EOF = (- 191),\n  RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION = (- 190),\n  RD_KAFKA_RESP_ERR__FS = (- 189),\n  RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC = (- 188),\n  RD_KAFKA_RESP_ERR__ALL_BROKERS_DOWN = (- 187),\n  RD_KAFKA_RESP_ERR__INVALID_ARG = (- 186),\n  RD_KAFKA_RESP_ERR__TIMED_OUT = (- 185),\n  RD_KAFKA_RESP_ERR__QUEUE_FULL = (- 184),\n  RD_KAFKA_RESP_ERR__ISR_INSUFF = (- 183),\n  RD_KAFKA_RESP_ERR__NODE_UPDATE = (- 182),\n  RD_KAFKA_RESP_ERR__SSL = (- 181),\n  RD_KAFKA_RESP_ERR__WAIT_COORD = (- 180),\n  RD_KAFKA_RESP_ERR__UNKNOWN_GROUP = (- 179),\n  RD_KAFKA_RESP_ERR__IN_PROGRESS = (- 178),\n  RD_KAFKA_RESP_ERR__PREV_IN_PROGRESS = (- 177),\n  RD_KAFKA_RESP_ERR__EXISTING_SUBSCRIPTION = (- 176),\n  RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS = (- 175),\n  RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS = (- 174),\n  RD_KAFKA_RESP_ERR__CONFLICT = (- 173),\n  RD_KAFKA_RESP_ERR__STATE = (- 172),\n  RD_KAFKA_RESP_ERR__UNKNOWN_PROTOCOL = (- 171),\n  RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED = (- 170),\n  RD_KAFKA_RESP_ERR__AUTHENTICATION = (- 169),\n  RD_KAFKA_RESP_ERR__NO_OFFSET = (- 168),\n  RD_KAFKA_RESP_ERR__OUTDATED = (- 167),\n  RD_KAFKA_RESP_ERR__TIMED_OUT_QUEUE = (- 166),\n  RD_KAFKA_RESP_ERR__UNSUPPORTED_FEATURE = (- 165),\n  RD_KAFKA_RESP_ERR__WAIT_CACHE = (- 164),\n  RD_KAFKA_RESP_ERR__INTR = (- 163),\n  RD_KAFKA_RESP_ERR__KEY_SERIALIZATION = (- 162),\n  RD_KAFKA_RESP_ERR__VALUE_SERIALIZATION = (- 161),\n  RD_KAFKA_RESP_ERR__KEY_DESERIALIZATION = (- 160),\n  RD_KAFKA_RESP_ERR__VALUE_DESERIALIZATION = (- 159),\n  RD_KAFKA_RESP_ERR__PARTIAL = (- 158),\n  RD_KAFKA_RESP_ERR__READ_ONLY = (- 157),\n  RD_KAFKA_RESP_ERR__NOENT = (- 156),\n  RD_KAFKA_RESP_ERR__UNDERFLOW = (- 155),\n  RD_KAFKA_RESP_ERR__INVALID_TYPE = (- 154),\n  RD_KAFKA_RESP_ERR__RETRY = (- 153),\n  RD_KAFKA_RESP_ERR__PURGE_QUEUE = (- 152),\n  RD_KAFKA_RESP_ERR__PURGE_INFLIGHT = (- 151),\n  RD_KAFKA_RESP_ERR__FATAL = (- 150),\n  RD_KAFKA_RESP_ERR__INCONSISTENT = (- 149),\n  RD_KAFKA_RESP_ERR__GAPLESS_GUARANTEE = (- 148),\n  RD_KAFKA_RESP_ERR__MAX_POLL_EXCEEDED = (- 147),\n  RD_KAFKA_RESP_ERR__END = (- 100),\n  RD_KAFKA_RESP_ERR_UNKNOWN = (- 1),\n  RD_KAFKA_RESP_ERR_NO_ERROR = 0,\n  RD_KAFKA_RESP_ERR_OFFSET_OUT_OF_RANGE = 1,\n  RD_KAFKA_RESP_ERR_INVALID_MSG = 2,\n  RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART = 3,\n  RD_KAFKA_RESP_ERR_INVALID_MSG_SIZE = 4,\n  RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE = 5,\n  RD_KAFKA_RESP_ERR_NOT_LEADER_FOR_PARTITION = 6,\n  RD_KAFKA_RESP_ERR_REQUEST_TIMED_OUT = 7,\n  RD_KAFKA_RESP_ERR_BROKER_NOT_AVAILABLE = 8,\n  RD_KAFKA_RESP_ERR_REPLICA_NOT_AVAILABLE = 9,\n  RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE = 10,\n  RD_KAFKA_RESP_ERR_STALE_CTRL_EPOCH = 11,\n  RD_KAFKA_RESP_ERR_OFFSET_METADATA_TOO_LARGE = 12,\n  RD_KAFKA_RESP_ERR_NETWORK_EXCEPTION = 13,\n  RD_KAFKA_RESP_ERR_GROUP_LOAD_IN_PROGRESS = 14,\n  RD_KAFKA_RESP_ERR_GROUP_COORDINATOR_NOT_AVAILABLE = 15,\n  RD_KAFKA_RESP_ERR_NOT_COORDINATOR_FOR_GROUP = 16,\n  RD_KAFKA_RESP_ERR_TOPIC_EXCEPTION = 17,\n  RD_KAFKA_RESP_ERR_RECORD_LIST_TOO_LARGE = 18,\n  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS = 19,\n  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS_AFTER_APPEND = 20,\n  RD_KAFKA_RESP_ERR_INVALID_REQUIRED_ACKS = 21,\n  RD_KAFKA_RESP_ERR_ILLEGAL_GENERATION = 22,\n  RD_KAFKA_RESP_ERR_INCONSISTENT_GROUP_PROTOCOL = 23,\n  RD_KAFKA_RESP_ERR_INVALID_GROUP_ID = 24,\n  RD_KAFKA_RESP_ERR_UNKNOWN_MEMBER_ID = 25,\n  RD_KAFKA_RESP_ERR_INVALID_SESSION_TIMEOUT = 26,\n  RD_KAFKA_RESP_ERR_REBALANCE_IN_PROGRESS = 27,\n  RD_KAFKA_RESP_ERR_INVALID_COMMIT_OFFSET_SIZE = 28,\n  RD_KAFKA_RESP_ERR_TOPIC_AUTHORIZATION_FAILED = 29,\n  RD_KAFKA_RESP_ERR_GROUP_AUTHORIZATION_FAILED = 30,\n  RD_KAFKA_RESP_ERR_CLUSTER_AUTHORIZATION_FAILED = 31,\n  RD_KAFKA_RESP_ERR_INVALID_TIMESTAMP = 32,\n  RD_KAFKA_RESP_ERR_UNSUPPORTED_SASL_MECHANISM = 33,\n  RD_KAFKA_RESP_ERR_ILLEGAL_SASL_STATE = 34,\n  RD_KAFKA_RESP_ERR_UNSUPPORTED_VERSION = 35,\n  RD_KAFKA_RESP_ERR_TOPIC_ALREADY_EXISTS = 36,\n  RD_KAFKA_RESP_ERR_INVALID_PARTITIONS = 37,\n  RD_KAFKA_RESP_ERR_INVALID_REPLICATION_FACTOR = 38,\n  RD_KAFKA_RESP_ERR_INVALID_REPLICA_ASSIGNMENT = 39,\n  RD_KAFKA_RESP_ERR_INVALID_CONFIG = 40,\n  RD_KAFKA_RESP_ERR_NOT_CONTROLLER = 41,\n  RD_KAFKA_RESP_ERR_INVALID_REQUEST = 42,\n  RD_KAFKA_RESP_ERR_UNSUPPORTED_FOR_MESSAGE_FORMAT = 43,\n  RD_KAFKA_RESP_ERR_POLICY_VIOLATION = 44,\n  RD_KAFKA_RESP_ERR_OUT_OF_ORDER_SEQUENCE_NUMBER = 45,\n  RD_KAFKA_RESP_ERR_DUPLICATE_SEQUENCE_NUMBER = 46,\n  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_EPOCH = 47,\n  RD_KAFKA_RESP_ERR_INVALID_TXN_STATE = 48,\n  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_ID_MAPPING = 49,\n  RD_KAFKA_RESP_ERR_INVALID_TRANSACTION_TIMEOUT = 50,\n  RD_KAFKA_RESP_ERR_CONCURRENT_TRANSACTIONS = 51,\n  RD_KAFKA_RESP_ERR_TRANSACTION_COORDINATOR_FENCED = 52,\n  RD_KAFKA_RESP_ERR_TRANSACTIONAL_ID_AUTHORIZATION_FAILED = 53,\n  RD_KAFKA_RESP_ERR_SECURITY_DISABLED = 54,\n  RD_KAFKA_RESP_ERR_OPERATION_NOT_ATTEMPTED = 55,\n  RD_KAFKA_RESP_ERR_KAFKA_STORAGE_ERROR = 56,\n  RD_KAFKA_RESP_ERR_LOG_DIR_NOT_FOUND = 57,\n  RD_KAFKA_RESP_ERR_SASL_AUTHENTICATION_FAILED = 58,\n  RD_KAFKA_RESP_ERR_UNKNOWN_PRODUCER_ID = 59,\n  RD_KAFKA_RESP_ERR_REASSIGNMENT_IN_PROGRESS = 60,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTH_DISABLED = 61,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_NOT_FOUND = 62,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_OWNER_MISMATCH = 63,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_REQUEST_NOT_ALLOWED = 64,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTHORIZATION_FAILED = 65,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_EXPIRED = 66,\n  RD_KAFKA_RESP_ERR_INVALID_PRINCIPAL_TYPE = 67,\n  RD_KAFKA_RESP_ERR_NON_EMPTY_GROUP = 68,\n  RD_KAFKA_RESP_ERR_GROUP_ID_NOT_FOUND = 69,\n  RD_KAFKA_RESP_ERR_FETCH_SESSION_ID_NOT_FOUND = 70,\n  RD_KAFKA_RESP_ERR_INVALID_FETCH_SESSION_EPOCH = 71,\n  RD_KAFKA_RESP_ERR_LISTENER_NOT_FOUND = 72,\n  RD_KAFKA_RESP_ERR_TOPIC_DELETION_DISABLED = 73,\n  RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 74,\n  RD_KAFKA_RESP_ERR_END_ALL,\n} rd_kafka_resp_err_t;\nstruct rd_kafka_err_desc {\n  rd_kafka_resp_err_t code;\n  char *name;\n  char *desc;\n};\nvoid rd_kafka_get_err_descs(const struct rd_kafka_err_desc **errdescs, size_t *cntp);\nconst char *rd_kafka_err2str(rd_kafka_resp_err_t err);\nconst char *rd_kafka_err2name(rd_kafka_resp_err_t err);\nrd_kafka_resp_err_t rd_kafka_last_error(void);\nrd_kafka_resp_err_t rd_kafka_errno2err(int errnox);\nint rd_kafka_errno(void);\nrd_kafka_resp_err_t rd_kafka_fatal_error(rd_kafka_t *rk, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_test_fatal_error(rd_kafka_t *rk, rd_kafka_resp_err_t err, const char *reason);\ntypedef struct rd_kafka_topic_partition_s {\n  char *topic;\n  int32_t partition;\n  int64_t offset;\n  void *metadata;\n  size_t metadata_size;\n  void *opaque;\n  rd_kafka_resp_err_t err;\n  void *_private;\n} rd_kafka_topic_partition_t;\nvoid rd_kafka_topic_partition_destroy(rd_kafka_topic_partition_t *rktpar);\ntypedef struct rd_kafka_topic_partition_list_s {\n  int cnt;\n  int size;\n  rd_kafka_topic_partition_t *elems;\n} rd_kafka_topic_partition_list_t;\nrd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_new(int size);\nvoid rd_kafka_topic_partition_list_destroy(rd_kafka_topic_partition_list_t *rkparlist);\nrd_kafka_topic_partition_t *rd_kafka_topic_partition_list_add(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);\nvoid rd_kafka_topic_partition_list_add_range(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t start, int32_t stop);\nint rd_kafka_topic_partition_list_del(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);\nint rd_kafka_topic_partition_list_del_by_idx(rd_kafka_topic_partition_list_t *rktparlist, int idx);\nrd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_copy(const rd_kafka_topic_partition_list_t *src);\nrd_kafka_resp_err_t rd_kafka_topic_partition_list_set_offset(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition, int64_t offset);\nrd_kafka_topic_partition_t *rd_kafka_topic_partition_list_find(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);\nvoid rd_kafka_topic_partition_list_sort(rd_kafka_topic_partition_list_t *rktparlist, int (*cmp)(const void *a, const void *b, void *opaque), void *opaque);\ntypedef enum rd_kafka_vtype_t {\n  RD_KAFKA_VTYPE_END,\n  RD_KAFKA_VTYPE_TOPIC,\n  RD_KAFKA_VTYPE_RKT,\n  RD_KAFKA_VTYPE_PARTITION,\n  RD_KAFKA_VTYPE_VALUE,\n  RD_KAFKA_VTYPE_KEY,\n  RD_KAFKA_VTYPE_OPAQUE,\n  RD_KAFKA_VTYPE_MSGFLAGS,\n  RD_KAFKA_VTYPE_TIMESTAMP,\n  RD_KAFKA_VTYPE_HEADER,\n  RD_KAFKA_VTYPE_HEADERS,\n} rd_kafka_vtype_t;\ntypedef struct rd_kafka_headers_s rd_kafka_headers_t;\nrd_kafka_headers_t *rd_kafka_headers_new(size_t initial_count);\nvoid rd_kafka_headers_destroy(rd_kafka_headers_t *hdrs);\nrd_kafka_headers_t *rd_kafka_headers_copy(const rd_kafka_headers_t *src);\nrd_kafka_resp_err_t rd_kafka_header_add(rd_kafka_headers_t *hdrs, const char *name, ssize_t name_size, const void *value, ssize_t value_size);\nrd_kafka_resp_err_t rd_kafka_header_remove(rd_kafka_headers_t *hdrs, const char *name);\nrd_kafka_resp_err_t rd_kafka_header_get_last(const rd_kafka_headers_t *hdrs, const char *name, const void **valuep, size_t *sizep);\nrd_kafka_resp_err_t rd_kafka_header_get(const rd_kafka_headers_t *hdrs, size_t idx, const char *name, const void **valuep, size_t *sizep);\nrd_kafka_resp_err_t rd_kafka_header_get_all(const rd_kafka_headers_t *hdrs, size_t idx, const char **namep, const void **valuep, size_t *sizep);\ntypedef struct rd_kafka_message_s {\n  rd_kafka_resp_err_t err;\n  rd_kafka_topic_t *rkt;\n  int32_t partition;\n  void *payload;\n  size_t len;\n  void *key;\n  size_t key_len;\n  int64_t offset;\n  void *_private;\n} rd_kafka_message_t;\nvoid rd_kafka_message_destroy(rd_kafka_message_t *rkmessage);\nint64_t rd_kafka_message_timestamp(const rd_kafka_message_t *rkmessage, rd_kafka_timestamp_type_t *tstype);\nint64_t rd_kafka_message_latency(const rd_kafka_message_t *rkmessage);\nrd_kafka_resp_err_t rd_kafka_message_headers(const rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);\nrd_kafka_resp_err_t rd_kafka_message_detach_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);\nvoid rd_kafka_message_set_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t *hdrs);\nsize_t rd_kafka_header_cnt(const rd_kafka_headers_t *hdrs);\ntypedef enum {\n  RD_KAFKA_MSG_STATUS_NOT_PERSISTED = 0,\n  RD_KAFKA_MSG_STATUS_POSSIBLY_PERSISTED = 1,\n  RD_KAFKA_MSG_STATUS_PERSISTED = 2,\n} rd_kafka_msg_status_t;\nrd_kafka_msg_status_t rd_kafka_message_status(const rd_kafka_message_t *rkmessage);\ntypedef enum {\n  RD_KAFKA_CONF_UNKNOWN = (- 2),\n  RD_KAFKA_CONF_INVALID = (- 1),\n  RD_KAFKA_CONF_OK = 0,\n} rd_kafka_conf_res_t;\nrd_kafka_conf_t *rd_kafka_conf_new(void);\nvoid rd_kafka_conf_destroy(rd_kafka_conf_t *conf);\nrd_kafka_conf_t *rd_kafka_conf_dup(const rd_kafka_conf_t *conf);\nrd_kafka_conf_t *rd_kafka_conf_dup_filter(const rd_kafka_conf_t *conf, size_t filter_cnt, const char **filter);\nrd_kafka_conf_res_t rd_kafka_conf_set(rd_kafka_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);\nvoid rd_kafka_conf_set_events(rd_kafka_conf_t *conf, int events);\nvoid rd_kafka_conf_set_background_event_cb(rd_kafka_conf_t *conf, void (*event_cb)(rd_kafka_t *rk, rd_kafka_event_t *rkev, void *opaque));\nvoid rd_kafka_conf_set_dr_cb(rd_kafka_conf_t *conf, void (*dr_cb)(rd_kafka_t *rk, void *payload, size_t len, rd_kafka_resp_err_t err, void *opaque, void *msg_opaque));\nvoid rd_kafka_conf_set_dr_msg_cb(rd_kafka_conf_t *conf, void (*dr_msg_cb)(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, void *opaque));\nvoid rd_kafka_conf_set_consume_cb(rd_kafka_conf_t *conf, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *opaque));\nvoid rd_kafka_conf_set_rebalance_cb(rd_kafka_conf_t *conf, void (*rebalance_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *partitions, void *opaque));\nvoid rd_kafka_conf_set_offset_commit_cb(rd_kafka_conf_t *conf, void (*offset_commit_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *opaque));\nvoid rd_kafka_conf_set_error_cb(rd_kafka_conf_t *conf, void (*error_cb)(rd_kafka_t *rk, int err, const char *reason, void *opaque));\nvoid rd_kafka_conf_set_throttle_cb(rd_kafka_conf_t *conf, void (*throttle_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int throttle_time_ms, void *opaque));\nvoid rd_kafka_conf_set_log_cb(rd_kafka_conf_t *conf, void (*log_cb)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));\nvoid rd_kafka_conf_set_stats_cb(rd_kafka_conf_t *conf, int (*stats_cb)(rd_kafka_t *rk, char *json, size_t json_len, void *opaque));\nvoid rd_kafka_conf_set_socket_cb(rd_kafka_conf_t *conf, int (*socket_cb)(int domain, int type, int protocol, void *opaque));\nvoid rd_kafka_conf_set_connect_cb(rd_kafka_conf_t *conf, int (*connect_cb)(int sockfd, const struct sockaddr *addr, int addrlen, const char *id, void *opaque));\nvoid rd_kafka_conf_set_closesocket_cb(rd_kafka_conf_t *conf, int (*closesocket_cb)(int sockfd, void *opaque));\nvoid rd_kafka_conf_set_opaque(rd_kafka_conf_t *conf, void *opaque);\nvoid *rd_kafka_opaque(const rd_kafka_t *rk);\nvoid rd_kafka_conf_set_default_topic_conf(rd_kafka_conf_t *conf, rd_kafka_topic_conf_t *tconf);\nrd_kafka_conf_res_t rd_kafka_conf_get(const rd_kafka_conf_t *conf, const char *name, char *dest, size_t *dest_size);\nrd_kafka_conf_res_t rd_kafka_topic_conf_get(const rd_kafka_topic_conf_t *conf, const char *name, char *dest, size_t *dest_size);\nconst char **rd_kafka_conf_dump(rd_kafka_conf_t *conf, size_t *cntp);\nconst char **rd_kafka_topic_conf_dump(rd_kafka_topic_conf_t *conf, size_t *cntp);\nvoid rd_kafka_conf_dump_free(const char **arr, size_t cnt);\nvoid rd_kafka_conf_properties_show(FILE *fp);\nrd_kafka_topic_conf_t *rd_kafka_topic_conf_new(void);\nrd_kafka_topic_conf_t *rd_kafka_topic_conf_dup(const rd_kafka_topic_conf_t *conf);\nrd_kafka_topic_conf_t *rd_kafka_default_topic_conf_dup(rd_kafka_t *rk);\nvoid rd_kafka_topic_conf_destroy(rd_kafka_topic_conf_t *topic_conf);\nrd_kafka_conf_res_t rd_kafka_topic_conf_set(rd_kafka_topic_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);\nvoid rd_kafka_topic_conf_set_opaque(rd_kafka_topic_conf_t *conf, void *opaque);\nvoid rd_kafka_topic_conf_set_partitioner_cb(rd_kafka_topic_conf_t *topic_conf, int32_t (*partitioner)(const rd_kafka_topic_t *rkt, const void *keydata, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque));\nvoid rd_kafka_topic_conf_set_msg_order_cmp(rd_kafka_topic_conf_t *topic_conf, int (*msg_order_cmp)(const rd_kafka_message_t *a, const rd_kafka_message_t *b));\nint rd_kafka_topic_partition_available(const rd_kafka_topic_t *rkt, int32_t partition);\nint32_t rd_kafka_msg_partitioner_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_consistent(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_consistent_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_murmur2(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_murmur2_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nrd_kafka_t *rd_kafka_new(rd_kafka_type_t type, rd_kafka_conf_t *conf, char *errstr, size_t errstr_size);\nvoid rd_kafka_destroy(rd_kafka_t *rk);\nvoid rd_kafka_destroy_flags(rd_kafka_t *rk, int flags);\nconst char *rd_kafka_name(const rd_kafka_t *rk);\nrd_kafka_type_t rd_kafka_type(const rd_kafka_t *rk);\nchar *rd_kafka_memberid(const rd_kafka_t *rk);\nchar *rd_kafka_clusterid(rd_kafka_t *rk, int timeout_ms);\nint32_t rd_kafka_controllerid(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_topic_t *rd_kafka_topic_new(rd_kafka_t *rk, const char *topic, rd_kafka_topic_conf_t *conf);\nvoid rd_kafka_topic_destroy(rd_kafka_topic_t *rkt);\nconst char *rd_kafka_topic_name(const rd_kafka_topic_t *rkt);\nvoid *rd_kafka_topic_opaque(const rd_kafka_topic_t *rkt);\nint rd_kafka_poll(rd_kafka_t *rk, int timeout_ms);\nvoid rd_kafka_yield(rd_kafka_t *rk);\nrd_kafka_resp_err_t rd_kafka_pause_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_resp_err_t rd_kafka_resume_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_resp_err_t rd_kafka_query_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high, int timeout_ms);\nrd_kafka_resp_err_t rd_kafka_get_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high);\nrd_kafka_resp_err_t rd_kafka_offsets_for_times(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets, int timeout_ms);\nvoid rd_kafka_mem_free(rd_kafka_t *rk, void *ptr);\nrd_kafka_queue_t *rd_kafka_queue_new(rd_kafka_t *rk);\nvoid rd_kafka_queue_destroy(rd_kafka_queue_t *rkqu);\nrd_kafka_queue_t *rd_kafka_queue_get_main(rd_kafka_t *rk);\nrd_kafka_queue_t *rd_kafka_queue_get_consumer(rd_kafka_t *rk);\nrd_kafka_queue_t *rd_kafka_queue_get_partition(rd_kafka_t *rk, const char *topic, int32_t partition);\nrd_kafka_queue_t *rd_kafka_queue_get_background(rd_kafka_t *rk);\nvoid rd_kafka_queue_forward(rd_kafka_queue_t *src, rd_kafka_queue_t *dst);\nrd_kafka_resp_err_t rd_kafka_set_log_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu);\nsize_t rd_kafka_queue_length(rd_kafka_queue_t *rkqu);\nvoid rd_kafka_queue_io_event_enable(rd_kafka_queue_t *rkqu, int fd, const void *payload, size_t size);\nvoid rd_kafka_queue_cb_event_enable(rd_kafka_queue_t *rkqu, void (*event_cb)(rd_kafka_t *rk, void *opaque), void *opaque);\nint rd_kafka_consume_start(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);\nint rd_kafka_consume_start_queue(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, rd_kafka_queue_t *rkqu);\nint rd_kafka_consume_stop(rd_kafka_topic_t *rkt, int32_t partition);\nrd_kafka_resp_err_t rd_kafka_seek(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, int timeout_ms);\nrd_kafka_message_t *rd_kafka_consume(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms);\nssize_t rd_kafka_consume_batch(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);\nint rd_kafka_consume_callback(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *opaque), void *opaque);\nrd_kafka_message_t *rd_kafka_consume_queue(rd_kafka_queue_t *rkqu, int timeout_ms);\nssize_t rd_kafka_consume_batch_queue(rd_kafka_queue_t *rkqu, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);\nint rd_kafka_consume_callback_queue(rd_kafka_queue_t *rkqu, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *opaque), void *opaque);\nrd_kafka_resp_err_t rd_kafka_offset_store(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);\nrd_kafka_resp_err_t rd_kafka_offsets_store(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets);\nrd_kafka_resp_err_t rd_kafka_subscribe(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *topics);\nrd_kafka_resp_err_t rd_kafka_unsubscribe(rd_kafka_t *rk);\nrd_kafka_resp_err_t rd_kafka_subscription(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **topics);\nrd_kafka_message_t *rd_kafka_consumer_poll(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_resp_err_t rd_kafka_consumer_close(rd_kafka_t *rk);\nrd_kafka_resp_err_t rd_kafka_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_resp_err_t rd_kafka_assignment(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **partitions);\nrd_kafka_resp_err_t rd_kafka_commit(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, int async);\nrd_kafka_resp_err_t rd_kafka_commit_message(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, int async);\nrd_kafka_resp_err_t rd_kafka_commit_queue(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_queue_t *rkqu, void (*cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *opaque), void *opaque);\nrd_kafka_resp_err_t rd_kafka_committed(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms);\nrd_kafka_resp_err_t rd_kafka_position(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);\nint rd_kafka_produce(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, void *payload, size_t len, const void *key, size_t keylen, void *msg_opaque);\nrd_kafka_resp_err_t rd_kafka_producev(rd_kafka_t *rk, ...);\nint rd_kafka_produce_batch(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, rd_kafka_message_t *rkmessages, int message_cnt);\nrd_kafka_resp_err_t rd_kafka_flush(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_resp_err_t rd_kafka_purge(rd_kafka_t *rk, int purge_flags);\ntypedef struct rd_kafka_metadata_broker {\n  int32_t id;\n  char *host;\n  int port;\n} rd_kafka_metadata_broker_t;\ntypedef struct rd_kafka_metadata_partition {\n  int32_t id;\n  rd_kafka_resp_err_t err;\n  int32_t leader;\n  int replica_cnt;\n  int32_t *replicas;\n  int isr_cnt;\n  int32_t *isrs;\n} rd_kafka_metadata_partition_t;\ntypedef struct rd_kafka_metadata_topic {\n  char *topic;\n  int partition_cnt;\n  struct rd_kafka_metadata_partition *partitions;\n  rd_kafka_resp_err_t err;\n} rd_kafka_metadata_topic_t;\ntypedef struct rd_kafka_metadata {\n  int broker_cnt;\n  struct rd_kafka_metadata_broker *brokers;\n  int topic_cnt;\n  struct rd_kafka_metadata_topic *topics;\n  int32_t orig_broker_id;\n  char *orig_broker_name;\n} rd_kafka_metadata_t;\nrd_kafka_resp_err_t rd_kafka_metadata(rd_kafka_t *rk, int all_topics, rd_kafka_topic_t *only_rkt, const struct rd_kafka_metadata **metadatap, int timeout_ms);\nvoid rd_kafka_metadata_destroy(const struct rd_kafka_metadata *metadata);\nstruct rd_kafka_group_member_info {\n  char *member_id;\n  char *client_id;\n  char *client_host;\n  void *member_metadata;\n  int member_metadata_size;\n  void *member_assignment;\n  int member_assignment_size;\n};\nstruct rd_kafka_group_info {\n  struct rd_kafka_metadata_broker broker;\n  char *group;\n  rd_kafka_resp_err_t err;\n  char *state;\n  char *protocol_type;\n  char *protocol;\n  struct rd_kafka_group_member_info *members;\n  int member_cnt;\n};\nstruct rd_kafka_group_list {\n  struct rd_kafka_group_info *groups;\n  int group_cnt;\n};\nrd_kafka_resp_err_t rd_kafka_list_groups(rd_kafka_t *rk, const char *group, const struct rd_kafka_group_list **grplistp, int timeout_ms);\nvoid rd_kafka_group_list_destroy(const struct rd_kafka_group_list *grplist);\nint rd_kafka_brokers_add(rd_kafka_t *rk, const char *brokerlist);\nvoid rd_kafka_set_logger(rd_kafka_t *rk, void (*func)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));\nvoid rd_kafka_set_log_level(rd_kafka_t *rk, int level);\nvoid rd_kafka_log_print(const rd_kafka_t *rk, int level, const char *fac, const char *buf);\nvoid rd_kafka_log_syslog(const rd_kafka_t *rk, int level, const char *fac, const char *buf);\nint rd_kafka_outq_len(rd_kafka_t *rk);\nvoid rd_kafka_dump(FILE *fp, rd_kafka_t *rk);\nint rd_kafka_thread_cnt(void);\nint rd_kafka_wait_destroyed(int timeout_ms);\nint rd_kafka_unittest(void);\nrd_kafka_resp_err_t rd_kafka_poll_set_consumer(rd_kafka_t *rk);\ntypedef int rd_kafka_event_type_t;\nrd_kafka_event_type_t rd_kafka_event_type(const rd_kafka_event_t *rkev);\nconst char *rd_kafka_event_name(const rd_kafka_event_t *rkev);\nvoid rd_kafka_event_destroy(rd_kafka_event_t *rkev);\nconst rd_kafka_message_t *rd_kafka_event_message_next(rd_kafka_event_t *rkev);\nsize_t rd_kafka_event_message_array(rd_kafka_event_t *rkev, const rd_kafka_message_t **rkmessages, size_t size);\nsize_t rd_kafka_event_message_count(rd_kafka_event_t *rkev);\nrd_kafka_resp_err_t rd_kafka_event_error(rd_kafka_event_t *rkev);\nconst char *rd_kafka_event_error_string(rd_kafka_event_t *rkev);\nint rd_kafka_event_error_is_fatal(rd_kafka_event_t *rkev);\nvoid *rd_kafka_event_opaque(rd_kafka_event_t *rkev);\nint rd_kafka_event_log(rd_kafka_event_t *rkev, const char **fac, const char **str, int *level);\nconst char *rd_kafka_event_stats(rd_kafka_event_t *rkev);\nrd_kafka_topic_partition_list_t *rd_kafka_event_topic_partition_list(rd_kafka_event_t *rkev);\nrd_kafka_topic_partition_t *rd_kafka_event_topic_partition(rd_kafka_event_t *rkev);\ntypedef rd_kafka_event_t rd_kafka_CreateTopics_result_t;\ntypedef rd_kafka_event_t rd_kafka_DeleteTopics_result_t;\ntypedef rd_kafka_event_t rd_kafka_CreatePartitions_result_t;\ntypedef rd_kafka_event_t rd_kafka_AlterConfigs_result_t;\ntypedef rd_kafka_event_t rd_kafka_DescribeConfigs_result_t;\nconst rd_kafka_CreateTopics_result_t *rd_kafka_event_CreateTopics_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DeleteTopics_result_t *rd_kafka_event_DeleteTopics_result(rd_kafka_event_t *rkev);\nconst rd_kafka_CreatePartitions_result_t *rd_kafka_event_CreatePartitions_result(rd_kafka_event_t *rkev);\nconst rd_kafka_AlterConfigs_result_t *rd_kafka_event_AlterConfigs_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DescribeConfigs_result_t *rd_kafka_event_DescribeConfigs_result(rd_kafka_event_t *rkev);\nrd_kafka_event_t *rd_kafka_queue_poll(rd_kafka_queue_t *rkqu, int timeout_ms);\nint rd_kafka_queue_poll_callback(rd_kafka_queue_t *rkqu, int timeout_ms);\ntypedef rd_kafka_resp_err_t (rd_kafka_plugin_f_conf_init_t)(rd_kafka_conf_t *conf, void **plug_opaquep, char *errstr, size_t errstr_size);\ntypedef rd_kafka_conf_res_t (rd_kafka_interceptor_f_on_conf_set_t)(rd_kafka_conf_t *conf, const char *name, const char *val, char *errstr, size_t errstr_size, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_dup_t)(rd_kafka_conf_t *new_conf, const rd_kafka_conf_t *old_conf, size_t filter_cnt, const char **filter, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_destroy_t)(void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_new_t)(rd_kafka_t *rk, const rd_kafka_conf_t *conf, void *ic_opaque, char *errstr, size_t errstr_size);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_destroy_t)(rd_kafka_t *rk, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_send_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_acknowledgement_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_consume_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_commit_t)(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_resp_err_t err, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_request_sent_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_set(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_set_t *on_conf_set, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_dup(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_dup_t *on_conf_dup, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_destroy(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_destroy_t *on_conf_destroy, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_new(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_new_t *on_new, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_destroy(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_destroy_t *on_destroy, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_send(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_send_t *on_send, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_acknowledgement(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_acknowledgement_t *on_acknowledgement, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_consume(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_consume_t *on_consume, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_commit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_commit_t *on_commit, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_request_sent(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_request_sent_t *on_request_sent, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_topic_result_error(const rd_kafka_topic_result_t *topicres);\nconst char *rd_kafka_topic_result_error_string(const rd_kafka_topic_result_t *topicres);\nconst char *rd_kafka_topic_result_name(const rd_kafka_topic_result_t *topicres);\ntypedef enum rd_kafka_admin_op_t {\n  RD_KAFKA_ADMIN_OP_ANY = 0,\n  RD_KAFKA_ADMIN_OP_CREATETOPICS,\n  RD_KAFKA_ADMIN_OP_DELETETOPICS,\n  RD_KAFKA_ADMIN_OP_CREATEPARTITIONS,\n  RD_KAFKA_ADMIN_OP_ALTERCONFIGS,\n  RD_KAFKA_ADMIN_OP_DESCRIBECONFIGS,\n  RD_KAFKA_ADMIN_OP__CNT,\n} rd_kafka_admin_op_t;\ntypedef struct rd_kafka_AdminOptions_s rd_kafka_AdminOptions_t;\nrd_kafka_AdminOptions_t *rd_kafka_AdminOptions_new(rd_kafka_t *rk, rd_kafka_admin_op_t for_api);\nvoid rd_kafka_AdminOptions_destroy(rd_kafka_AdminOptions_t *options);\nrd_kafka_resp_err_t rd_kafka_AdminOptions_set_request_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_AdminOptions_set_operation_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_AdminOptions_set_validate_only(rd_kafka_AdminOptions_t *options, int true_or_false, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_AdminOptions_set_broker(rd_kafka_AdminOptions_t *options, int32_t broker_id, char *errstr, size_t errstr_size);\nvoid rd_kafka_AdminOptions_set_opaque(rd_kafka_AdminOptions_t *options, void *opaque);\ntypedef struct rd_kafka_NewTopic_s rd_kafka_NewTopic_t;\nrd_kafka_NewTopic_t *rd_kafka_NewTopic_new(const char *topic, int num_partitions, int replication_factor, char *errstr, size_t errstr_size);\nvoid rd_kafka_NewTopic_destroy(rd_kafka_NewTopic_t *new_topic);\nvoid rd_kafka_NewTopic_destroy_array(rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt);\nrd_kafka_resp_err_t rd_kafka_NewTopic_set_replica_assignment(rd_kafka_NewTopic_t *new_topic, int32_t partition, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_NewTopic_set_config(rd_kafka_NewTopic_t *new_topic, const char *name, const char *value);\nvoid rd_kafka_CreateTopics(rd_kafka_t *rk, rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_topic_result_t **rd_kafka_CreateTopics_result_topics(const rd_kafka_CreateTopics_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_DeleteTopic_s rd_kafka_DeleteTopic_t;\nrd_kafka_DeleteTopic_t *rd_kafka_DeleteTopic_new(const char *topic);\nvoid rd_kafka_DeleteTopic_destroy(rd_kafka_DeleteTopic_t *del_topic);\nvoid rd_kafka_DeleteTopic_destroy_array(rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt);\nvoid rd_kafka_DeleteTopics(rd_kafka_t *rk, rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_topic_result_t **rd_kafka_DeleteTopics_result_topics(const rd_kafka_DeleteTopics_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_NewPartitions_s rd_kafka_NewPartitions_t;\nrd_kafka_NewPartitions_t *rd_kafka_NewPartitions_new(const char *topic, size_t new_total_cnt, char *errstr, size_t errstr_size);\nvoid rd_kafka_NewPartitions_destroy(rd_kafka_NewPartitions_t *new_parts);\nvoid rd_kafka_NewPartitions_destroy_array(rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt);\nrd_kafka_resp_err_t rd_kafka_NewPartitions_set_replica_assignment(rd_kafka_NewPartitions_t *new_parts, int32_t new_partition_idx, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);\nvoid rd_kafka_CreatePartitions(rd_kafka_t *rk, rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_topic_result_t **rd_kafka_CreatePartitions_result_topics(const rd_kafka_CreatePartitions_result_t *result, size_t *cntp);\ntypedef enum rd_kafka_ConfigSource_t {\n  RD_KAFKA_CONFIG_SOURCE_UNKNOWN_CONFIG = 0,\n  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_TOPIC_CONFIG = 1,\n  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_BROKER_CONFIG = 2,\n  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_DEFAULT_BROKER_CONFIG = 3,\n  RD_KAFKA_CONFIG_SOURCE_STATIC_BROKER_CONFIG = 4,\n  RD_KAFKA_CONFIG_SOURCE_DEFAULT_CONFIG = 5,\n  RD_KAFKA_CONFIG_SOURCE__CNT,\n} rd_kafka_ConfigSource_t;\nconst char *rd_kafka_ConfigSource_name(rd_kafka_ConfigSource_t confsource);\ntypedef struct rd_kafka_ConfigEntry_s rd_kafka_ConfigEntry_t;\nconst char *rd_kafka_ConfigEntry_name(const rd_kafka_ConfigEntry_t *entry);\nconst char *rd_kafka_ConfigEntry_value(const rd_kafka_ConfigEntry_t *entry);\nrd_kafka_ConfigSource_t rd_kafka_ConfigEntry_source(const rd_kafka_ConfigEntry_t *entry);\nint rd_kafka_ConfigEntry_is_read_only(const rd_kafka_ConfigEntry_t *entry);\nint rd_kafka_ConfigEntry_is_default(const rd_kafka_ConfigEntry_t *entry);\nint rd_kafka_ConfigEntry_is_sensitive(const rd_kafka_ConfigEntry_t *entry);\nint rd_kafka_ConfigEntry_is_synonym(const rd_kafka_ConfigEntry_t *entry);\nconst rd_kafka_ConfigEntry_t **rd_kafka_ConfigEntry_synonyms(const rd_kafka_ConfigEntry_t *entry, size_t *cntp);\ntypedef enum rd_kafka_ResourceType_t {\n  RD_KAFKA_RESOURCE_UNKNOWN = 0,\n  RD_KAFKA_RESOURCE_ANY = 1,\n  RD_KAFKA_RESOURCE_TOPIC = 2,\n  RD_KAFKA_RESOURCE_GROUP = 3,\n  RD_KAFKA_RESOURCE_BROKER = 4,\n  RD_KAFKA_RESOURCE__CNT,\n} rd_kafka_ResourceType_t;\nconst char *rd_kafka_ResourceType_name(rd_kafka_ResourceType_t restype);\ntypedef struct rd_kafka_ConfigResource_s rd_kafka_ConfigResource_t;\nrd_kafka_ConfigResource_t *rd_kafka_ConfigResource_new(rd_kafka_ResourceType_t restype, const char *resname);\nvoid rd_kafka_ConfigResource_destroy(rd_kafka_ConfigResource_t *config);\nvoid rd_kafka_ConfigResource_destroy_array(rd_kafka_ConfigResource_t **config, size_t config_cnt);\nrd_kafka_resp_err_t rd_kafka_ConfigResource_set_config(rd_kafka_ConfigResource_t *config, const char *name, const char *value);\nconst rd_kafka_ConfigEntry_t **rd_kafka_ConfigResource_configs(const rd_kafka_ConfigResource_t *config, size_t *cntp);\nrd_kafka_ResourceType_t rd_kafka_ConfigResource_type(const rd_kafka_ConfigResource_t *config);\nconst char *rd_kafka_ConfigResource_name(const rd_kafka_ConfigResource_t *config);\nrd_kafka_resp_err_t rd_kafka_ConfigResource_error(const rd_kafka_ConfigResource_t *config);\nconst char *rd_kafka_ConfigResource_error_string(const rd_kafka_ConfigResource_t *config);\nvoid rd_kafka_AlterConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_ConfigResource_t **rd_kafka_AlterConfigs_result_resources(const rd_kafka_AlterConfigs_result_t *result, size_t *cntp);\nvoid rd_kafka_DescribeConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_ConfigResource_t **rd_kafka_DescribeConfigs_result_resources(const rd_kafka_DescribeConfigs_result_t *result, size_t *cntp);\n'\n</code></pre> rdkafka.h, rdkafka_mock.h</p>"},{"location":"api/constants/#rd_kafka_version_1","title":"RD_KAFKA_VERSION","text":"<pre><code>public RD_KAFKA_VERSION = 16777727\n</code></pre> <p>librdkafka version </p> <p>Interpreted as hex <code>MM.mm.rr.xx</code>:</p> <ul> <li>MM = Major</li> <li>mm = minor</li> <li>rr = revision</li> <li>xx = pre-release id (0xff is the final release)</li> </ul> <p>E.g.: <code>0x000801ff</code> = 0.8.1</p> RemarksThis value should only be used during compile time, for runtime checks of version use rd_kafka_version()  <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_unsupported_compression_type_1","title":"RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE","text":"<pre><code>public RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76\n</code></pre> <p>Unsupported compression type </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_end_all_1","title":"RD_KAFKA_RESP_ERR_END_ALL","text":"<p><pre><code>public RD_KAFKA_RESP_ERR_END_ALL = 82\n</code></pre> enum rd_kafka_resp_err_t</p>"},{"location":"api/constants/#rd_kafka_admin_op__cnt_1","title":"RD_KAFKA_ADMIN_OP__CNT","text":"<pre><code>public RD_KAFKA_ADMIN_OP__CNT = 6\n</code></pre> <p>Number of ops defined </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe </li> </ul>"},{"location":"api/constants/#rd_kafka_resource__cnt_1","title":"RD_KAFKA_RESOURCE__CNT","text":"<pre><code>public RD_KAFKA_RESOURCE__CNT = 5\n</code></pre> <p>Number of resource types defined </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#acca83a66d7783ff7683ed2691cc907c9 </li> </ul>"},{"location":"api/constants/#rd_kafka_cdef_1","title":"RD_KAFKA_CDEF","text":"<p><pre><code>public RD_KAFKA_CDEF = 'typedef long int ssize_t;\ntypedef struct _IO_FILE FILE;\ntypedef long int mode_t;\ntypedef signed int int16_t;\ntypedef unsigned int uint16_t;\ntypedef signed int int32_t;\ntypedef signed long int int64_t;\nint rd_kafka_version(void);\nconst char *rd_kafka_version_str(void);\ntypedef enum rd_kafka_type_t {\n  RD_KAFKA_PRODUCER,\n  RD_KAFKA_CONSUMER,\n} rd_kafka_type_t;\ntypedef enum rd_kafka_timestamp_type_t {\n  RD_KAFKA_TIMESTAMP_NOT_AVAILABLE,\n  RD_KAFKA_TIMESTAMP_CREATE_TIME,\n  RD_KAFKA_TIMESTAMP_LOG_APPEND_TIME,\n} rd_kafka_timestamp_type_t;\nconst char *rd_kafka_get_debug_contexts(void);\ntypedef struct rd_kafka_s rd_kafka_t;\ntypedef struct rd_kafka_topic_s rd_kafka_topic_t;\ntypedef struct rd_kafka_conf_s rd_kafka_conf_t;\ntypedef struct rd_kafka_topic_conf_s rd_kafka_topic_conf_t;\ntypedef struct rd_kafka_queue_s rd_kafka_queue_t;\ntypedef struct rd_kafka_op_s rd_kafka_event_t;\ntypedef struct rd_kafka_topic_result_s rd_kafka_topic_result_t;\ntypedef enum {\n  RD_KAFKA_RESP_ERR__BEGIN = (- 200),\n  RD_KAFKA_RESP_ERR__BAD_MSG = (- 199),\n  RD_KAFKA_RESP_ERR__BAD_COMPRESSION = (- 198),\n  RD_KAFKA_RESP_ERR__DESTROY = (- 197),\n  RD_KAFKA_RESP_ERR__FAIL = (- 196),\n  RD_KAFKA_RESP_ERR__TRANSPORT = (- 195),\n  RD_KAFKA_RESP_ERR__CRIT_SYS_RESOURCE = (- 194),\n  RD_KAFKA_RESP_ERR__RESOLVE = (- 193),\n  RD_KAFKA_RESP_ERR__MSG_TIMED_OUT = (- 192),\n  RD_KAFKA_RESP_ERR__PARTITION_EOF = (- 191),\n  RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION = (- 190),\n  RD_KAFKA_RESP_ERR__FS = (- 189),\n  RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC = (- 188),\n  RD_KAFKA_RESP_ERR__ALL_BROKERS_DOWN = (- 187),\n  RD_KAFKA_RESP_ERR__INVALID_ARG = (- 186),\n  RD_KAFKA_RESP_ERR__TIMED_OUT = (- 185),\n  RD_KAFKA_RESP_ERR__QUEUE_FULL = (- 184),\n  RD_KAFKA_RESP_ERR__ISR_INSUFF = (- 183),\n  RD_KAFKA_RESP_ERR__NODE_UPDATE = (- 182),\n  RD_KAFKA_RESP_ERR__SSL = (- 181),\n  RD_KAFKA_RESP_ERR__WAIT_COORD = (- 180),\n  RD_KAFKA_RESP_ERR__UNKNOWN_GROUP = (- 179),\n  RD_KAFKA_RESP_ERR__IN_PROGRESS = (- 178),\n  RD_KAFKA_RESP_ERR__PREV_IN_PROGRESS = (- 177),\n  RD_KAFKA_RESP_ERR__EXISTING_SUBSCRIPTION = (- 176),\n  RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS = (- 175),\n  RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS = (- 174),\n  RD_KAFKA_RESP_ERR__CONFLICT = (- 173),\n  RD_KAFKA_RESP_ERR__STATE = (- 172),\n  RD_KAFKA_RESP_ERR__UNKNOWN_PROTOCOL = (- 171),\n  RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED = (- 170),\n  RD_KAFKA_RESP_ERR__AUTHENTICATION = (- 169),\n  RD_KAFKA_RESP_ERR__NO_OFFSET = (- 168),\n  RD_KAFKA_RESP_ERR__OUTDATED = (- 167),\n  RD_KAFKA_RESP_ERR__TIMED_OUT_QUEUE = (- 166),\n  RD_KAFKA_RESP_ERR__UNSUPPORTED_FEATURE = (- 165),\n  RD_KAFKA_RESP_ERR__WAIT_CACHE = (- 164),\n  RD_KAFKA_RESP_ERR__INTR = (- 163),\n  RD_KAFKA_RESP_ERR__KEY_SERIALIZATION = (- 162),\n  RD_KAFKA_RESP_ERR__VALUE_SERIALIZATION = (- 161),\n  RD_KAFKA_RESP_ERR__KEY_DESERIALIZATION = (- 160),\n  RD_KAFKA_RESP_ERR__VALUE_DESERIALIZATION = (- 159),\n  RD_KAFKA_RESP_ERR__PARTIAL = (- 158),\n  RD_KAFKA_RESP_ERR__READ_ONLY = (- 157),\n  RD_KAFKA_RESP_ERR__NOENT = (- 156),\n  RD_KAFKA_RESP_ERR__UNDERFLOW = (- 155),\n  RD_KAFKA_RESP_ERR__INVALID_TYPE = (- 154),\n  RD_KAFKA_RESP_ERR__RETRY = (- 153),\n  RD_KAFKA_RESP_ERR__PURGE_QUEUE = (- 152),\n  RD_KAFKA_RESP_ERR__PURGE_INFLIGHT = (- 151),\n  RD_KAFKA_RESP_ERR__FATAL = (- 150),\n  RD_KAFKA_RESP_ERR__INCONSISTENT = (- 149),\n  RD_KAFKA_RESP_ERR__GAPLESS_GUARANTEE = (- 148),\n  RD_KAFKA_RESP_ERR__MAX_POLL_EXCEEDED = (- 147),\n  RD_KAFKA_RESP_ERR__END = (- 100),\n  RD_KAFKA_RESP_ERR_UNKNOWN = (- 1),\n  RD_KAFKA_RESP_ERR_NO_ERROR = 0,\n  RD_KAFKA_RESP_ERR_OFFSET_OUT_OF_RANGE = 1,\n  RD_KAFKA_RESP_ERR_INVALID_MSG = 2,\n  RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART = 3,\n  RD_KAFKA_RESP_ERR_INVALID_MSG_SIZE = 4,\n  RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE = 5,\n  RD_KAFKA_RESP_ERR_NOT_LEADER_FOR_PARTITION = 6,\n  RD_KAFKA_RESP_ERR_REQUEST_TIMED_OUT = 7,\n  RD_KAFKA_RESP_ERR_BROKER_NOT_AVAILABLE = 8,\n  RD_KAFKA_RESP_ERR_REPLICA_NOT_AVAILABLE = 9,\n  RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE = 10,\n  RD_KAFKA_RESP_ERR_STALE_CTRL_EPOCH = 11,\n  RD_KAFKA_RESP_ERR_OFFSET_METADATA_TOO_LARGE = 12,\n  RD_KAFKA_RESP_ERR_NETWORK_EXCEPTION = 13,\n  RD_KAFKA_RESP_ERR_GROUP_LOAD_IN_PROGRESS = 14,\n  RD_KAFKA_RESP_ERR_GROUP_COORDINATOR_NOT_AVAILABLE = 15,\n  RD_KAFKA_RESP_ERR_NOT_COORDINATOR_FOR_GROUP = 16,\n  RD_KAFKA_RESP_ERR_TOPIC_EXCEPTION = 17,\n  RD_KAFKA_RESP_ERR_RECORD_LIST_TOO_LARGE = 18,\n  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS = 19,\n  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS_AFTER_APPEND = 20,\n  RD_KAFKA_RESP_ERR_INVALID_REQUIRED_ACKS = 21,\n  RD_KAFKA_RESP_ERR_ILLEGAL_GENERATION = 22,\n  RD_KAFKA_RESP_ERR_INCONSISTENT_GROUP_PROTOCOL = 23,\n  RD_KAFKA_RESP_ERR_INVALID_GROUP_ID = 24,\n  RD_KAFKA_RESP_ERR_UNKNOWN_MEMBER_ID = 25,\n  RD_KAFKA_RESP_ERR_INVALID_SESSION_TIMEOUT = 26,\n  RD_KAFKA_RESP_ERR_REBALANCE_IN_PROGRESS = 27,\n  RD_KAFKA_RESP_ERR_INVALID_COMMIT_OFFSET_SIZE = 28,\n  RD_KAFKA_RESP_ERR_TOPIC_AUTHORIZATION_FAILED = 29,\n  RD_KAFKA_RESP_ERR_GROUP_AUTHORIZATION_FAILED = 30,\n  RD_KAFKA_RESP_ERR_CLUSTER_AUTHORIZATION_FAILED = 31,\n  RD_KAFKA_RESP_ERR_INVALID_TIMESTAMP = 32,\n  RD_KAFKA_RESP_ERR_UNSUPPORTED_SASL_MECHANISM = 33,\n  RD_KAFKA_RESP_ERR_ILLEGAL_SASL_STATE = 34,\n  RD_KAFKA_RESP_ERR_UNSUPPORTED_VERSION = 35,\n  RD_KAFKA_RESP_ERR_TOPIC_ALREADY_EXISTS = 36,\n  RD_KAFKA_RESP_ERR_INVALID_PARTITIONS = 37,\n  RD_KAFKA_RESP_ERR_INVALID_REPLICATION_FACTOR = 38,\n  RD_KAFKA_RESP_ERR_INVALID_REPLICA_ASSIGNMENT = 39,\n  RD_KAFKA_RESP_ERR_INVALID_CONFIG = 40,\n  RD_KAFKA_RESP_ERR_NOT_CONTROLLER = 41,\n  RD_KAFKA_RESP_ERR_INVALID_REQUEST = 42,\n  RD_KAFKA_RESP_ERR_UNSUPPORTED_FOR_MESSAGE_FORMAT = 43,\n  RD_KAFKA_RESP_ERR_POLICY_VIOLATION = 44,\n  RD_KAFKA_RESP_ERR_OUT_OF_ORDER_SEQUENCE_NUMBER = 45,\n  RD_KAFKA_RESP_ERR_DUPLICATE_SEQUENCE_NUMBER = 46,\n  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_EPOCH = 47,\n  RD_KAFKA_RESP_ERR_INVALID_TXN_STATE = 48,\n  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_ID_MAPPING = 49,\n  RD_KAFKA_RESP_ERR_INVALID_TRANSACTION_TIMEOUT = 50,\n  RD_KAFKA_RESP_ERR_CONCURRENT_TRANSACTIONS = 51,\n  RD_KAFKA_RESP_ERR_TRANSACTION_COORDINATOR_FENCED = 52,\n  RD_KAFKA_RESP_ERR_TRANSACTIONAL_ID_AUTHORIZATION_FAILED = 53,\n  RD_KAFKA_RESP_ERR_SECURITY_DISABLED = 54,\n  RD_KAFKA_RESP_ERR_OPERATION_NOT_ATTEMPTED = 55,\n  RD_KAFKA_RESP_ERR_KAFKA_STORAGE_ERROR = 56,\n  RD_KAFKA_RESP_ERR_LOG_DIR_NOT_FOUND = 57,\n  RD_KAFKA_RESP_ERR_SASL_AUTHENTICATION_FAILED = 58,\n  RD_KAFKA_RESP_ERR_UNKNOWN_PRODUCER_ID = 59,\n  RD_KAFKA_RESP_ERR_REASSIGNMENT_IN_PROGRESS = 60,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTH_DISABLED = 61,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_NOT_FOUND = 62,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_OWNER_MISMATCH = 63,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_REQUEST_NOT_ALLOWED = 64,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTHORIZATION_FAILED = 65,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_EXPIRED = 66,\n  RD_KAFKA_RESP_ERR_INVALID_PRINCIPAL_TYPE = 67,\n  RD_KAFKA_RESP_ERR_NON_EMPTY_GROUP = 68,\n  RD_KAFKA_RESP_ERR_GROUP_ID_NOT_FOUND = 69,\n  RD_KAFKA_RESP_ERR_FETCH_SESSION_ID_NOT_FOUND = 70,\n  RD_KAFKA_RESP_ERR_INVALID_FETCH_SESSION_EPOCH = 71,\n  RD_KAFKA_RESP_ERR_LISTENER_NOT_FOUND = 72,\n  RD_KAFKA_RESP_ERR_TOPIC_DELETION_DISABLED = 73,\n  RD_KAFKA_RESP_ERR_FENCED_LEADER_EPOCH = 74,\n  RD_KAFKA_RESP_ERR_UNKNOWN_LEADER_EPOCH = 75,\n  RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76,\n  RD_KAFKA_RESP_ERR_STALE_BROKER_EPOCH = 77,\n  RD_KAFKA_RESP_ERR_OFFSET_NOT_AVAILABLE = 78,\n  RD_KAFKA_RESP_ERR_MEMBER_ID_REQUIRED = 79,\n  RD_KAFKA_RESP_ERR_PREFERRED_LEADER_NOT_AVAILABLE = 80,\n  RD_KAFKA_RESP_ERR_GROUP_MAX_SIZE_REACHED = 81,\n  RD_KAFKA_RESP_ERR_END_ALL,\n} rd_kafka_resp_err_t;\nstruct rd_kafka_err_desc {\n  rd_kafka_resp_err_t code;\n  char *name;\n  char *desc;\n};\nvoid rd_kafka_get_err_descs(const struct rd_kafka_err_desc **errdescs, size_t *cntp);\nconst char *rd_kafka_err2str(rd_kafka_resp_err_t err);\nconst char *rd_kafka_err2name(rd_kafka_resp_err_t err);\nrd_kafka_resp_err_t rd_kafka_last_error(void);\nrd_kafka_resp_err_t rd_kafka_errno2err(int errnox);\nint rd_kafka_errno(void);\nrd_kafka_resp_err_t rd_kafka_fatal_error(rd_kafka_t *rk, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_test_fatal_error(rd_kafka_t *rk, rd_kafka_resp_err_t err, const char *reason);\ntypedef struct rd_kafka_topic_partition_s {\n  char *topic;\n  int32_t partition;\n  int64_t offset;\n  void *metadata;\n  size_t metadata_size;\n  void *opaque;\n  rd_kafka_resp_err_t err;\n  void *_private;\n} rd_kafka_topic_partition_t;\nvoid rd_kafka_topic_partition_destroy(rd_kafka_topic_partition_t *rktpar);\ntypedef struct rd_kafka_topic_partition_list_s {\n  int cnt;\n  int size;\n  rd_kafka_topic_partition_t *elems;\n} rd_kafka_topic_partition_list_t;\nrd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_new(int size);\nvoid rd_kafka_topic_partition_list_destroy(rd_kafka_topic_partition_list_t *rkparlist);\nrd_kafka_topic_partition_t *rd_kafka_topic_partition_list_add(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);\nvoid rd_kafka_topic_partition_list_add_range(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t start, int32_t stop);\nint rd_kafka_topic_partition_list_del(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);\nint rd_kafka_topic_partition_list_del_by_idx(rd_kafka_topic_partition_list_t *rktparlist, int idx);\nrd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_copy(const rd_kafka_topic_partition_list_t *src);\nrd_kafka_resp_err_t rd_kafka_topic_partition_list_set_offset(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition, int64_t offset);\nrd_kafka_topic_partition_t *rd_kafka_topic_partition_list_find(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);\nvoid rd_kafka_topic_partition_list_sort(rd_kafka_topic_partition_list_t *rktparlist, int (*cmp)(const void *a, const void *b, void *opaque), void *opaque);\ntypedef enum rd_kafka_vtype_t {\n  RD_KAFKA_VTYPE_END,\n  RD_KAFKA_VTYPE_TOPIC,\n  RD_KAFKA_VTYPE_RKT,\n  RD_KAFKA_VTYPE_PARTITION,\n  RD_KAFKA_VTYPE_VALUE,\n  RD_KAFKA_VTYPE_KEY,\n  RD_KAFKA_VTYPE_OPAQUE,\n  RD_KAFKA_VTYPE_MSGFLAGS,\n  RD_KAFKA_VTYPE_TIMESTAMP,\n  RD_KAFKA_VTYPE_HEADER,\n  RD_KAFKA_VTYPE_HEADERS,\n} rd_kafka_vtype_t;\ntypedef struct rd_kafka_headers_s rd_kafka_headers_t;\nrd_kafka_headers_t *rd_kafka_headers_new(size_t initial_count);\nvoid rd_kafka_headers_destroy(rd_kafka_headers_t *hdrs);\nrd_kafka_headers_t *rd_kafka_headers_copy(const rd_kafka_headers_t *src);\nrd_kafka_resp_err_t rd_kafka_header_add(rd_kafka_headers_t *hdrs, const char *name, ssize_t name_size, const void *value, ssize_t value_size);\nrd_kafka_resp_err_t rd_kafka_header_remove(rd_kafka_headers_t *hdrs, const char *name);\nrd_kafka_resp_err_t rd_kafka_header_get_last(const rd_kafka_headers_t *hdrs, const char *name, const void **valuep, size_t *sizep);\nrd_kafka_resp_err_t rd_kafka_header_get(const rd_kafka_headers_t *hdrs, size_t idx, const char *name, const void **valuep, size_t *sizep);\nrd_kafka_resp_err_t rd_kafka_header_get_all(const rd_kafka_headers_t *hdrs, size_t idx, const char **namep, const void **valuep, size_t *sizep);\ntypedef struct rd_kafka_message_s {\n  rd_kafka_resp_err_t err;\n  rd_kafka_topic_t *rkt;\n  int32_t partition;\n  void *payload;\n  size_t len;\n  void *key;\n  size_t key_len;\n  int64_t offset;\n  void *_private;\n} rd_kafka_message_t;\nvoid rd_kafka_message_destroy(rd_kafka_message_t *rkmessage);\nint64_t rd_kafka_message_timestamp(const rd_kafka_message_t *rkmessage, rd_kafka_timestamp_type_t *tstype);\nint64_t rd_kafka_message_latency(const rd_kafka_message_t *rkmessage);\nrd_kafka_resp_err_t rd_kafka_message_headers(const rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);\nrd_kafka_resp_err_t rd_kafka_message_detach_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);\nvoid rd_kafka_message_set_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t *hdrs);\nsize_t rd_kafka_header_cnt(const rd_kafka_headers_t *hdrs);\ntypedef enum {\n  RD_KAFKA_MSG_STATUS_NOT_PERSISTED = 0,\n  RD_KAFKA_MSG_STATUS_POSSIBLY_PERSISTED = 1,\n  RD_KAFKA_MSG_STATUS_PERSISTED = 2,\n} rd_kafka_msg_status_t;\nrd_kafka_msg_status_t rd_kafka_message_status(const rd_kafka_message_t *rkmessage);\ntypedef enum {\n  RD_KAFKA_CONF_UNKNOWN = (- 2),\n  RD_KAFKA_CONF_INVALID = (- 1),\n  RD_KAFKA_CONF_OK = 0,\n} rd_kafka_conf_res_t;\nrd_kafka_conf_t *rd_kafka_conf_new(void);\nvoid rd_kafka_conf_destroy(rd_kafka_conf_t *conf);\nrd_kafka_conf_t *rd_kafka_conf_dup(const rd_kafka_conf_t *conf);\nrd_kafka_conf_t *rd_kafka_conf_dup_filter(const rd_kafka_conf_t *conf, size_t filter_cnt, const char **filter);\nrd_kafka_conf_res_t rd_kafka_conf_set(rd_kafka_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);\nvoid rd_kafka_conf_set_events(rd_kafka_conf_t *conf, int events);\nvoid rd_kafka_conf_set_background_event_cb(rd_kafka_conf_t *conf, void (*event_cb)(rd_kafka_t *rk, rd_kafka_event_t *rkev, void *opaque));\nvoid rd_kafka_conf_set_dr_cb(rd_kafka_conf_t *conf, void (*dr_cb)(rd_kafka_t *rk, void *payload, size_t len, rd_kafka_resp_err_t err, void *opaque, void *msg_opaque));\nvoid rd_kafka_conf_set_dr_msg_cb(rd_kafka_conf_t *conf, void (*dr_msg_cb)(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, void *opaque));\nvoid rd_kafka_conf_set_consume_cb(rd_kafka_conf_t *conf, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *opaque));\nvoid rd_kafka_conf_set_rebalance_cb(rd_kafka_conf_t *conf, void (*rebalance_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *partitions, void *opaque));\nvoid rd_kafka_conf_set_offset_commit_cb(rd_kafka_conf_t *conf, void (*offset_commit_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *opaque));\nvoid rd_kafka_conf_set_error_cb(rd_kafka_conf_t *conf, void (*error_cb)(rd_kafka_t *rk, int err, const char *reason, void *opaque));\nvoid rd_kafka_conf_set_throttle_cb(rd_kafka_conf_t *conf, void (*throttle_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int throttle_time_ms, void *opaque));\nvoid rd_kafka_conf_set_log_cb(rd_kafka_conf_t *conf, void (*log_cb)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));\nvoid rd_kafka_conf_set_stats_cb(rd_kafka_conf_t *conf, int (*stats_cb)(rd_kafka_t *rk, char *json, size_t json_len, void *opaque));\nvoid rd_kafka_conf_set_socket_cb(rd_kafka_conf_t *conf, int (*socket_cb)(int domain, int type, int protocol, void *opaque));\nvoid rd_kafka_conf_set_connect_cb(rd_kafka_conf_t *conf, int (*connect_cb)(int sockfd, const struct sockaddr *addr, int addrlen, const char *id, void *opaque));\nvoid rd_kafka_conf_set_closesocket_cb(rd_kafka_conf_t *conf, int (*closesocket_cb)(int sockfd, void *opaque));\nvoid rd_kafka_conf_set_opaque(rd_kafka_conf_t *conf, void *opaque);\nvoid *rd_kafka_opaque(const rd_kafka_t *rk);\nvoid rd_kafka_conf_set_default_topic_conf(rd_kafka_conf_t *conf, rd_kafka_topic_conf_t *tconf);\nrd_kafka_conf_res_t rd_kafka_conf_get(const rd_kafka_conf_t *conf, const char *name, char *dest, size_t *dest_size);\nrd_kafka_conf_res_t rd_kafka_topic_conf_get(const rd_kafka_topic_conf_t *conf, const char *name, char *dest, size_t *dest_size);\nconst char **rd_kafka_conf_dump(rd_kafka_conf_t *conf, size_t *cntp);\nconst char **rd_kafka_topic_conf_dump(rd_kafka_topic_conf_t *conf, size_t *cntp);\nvoid rd_kafka_conf_dump_free(const char **arr, size_t cnt);\nvoid rd_kafka_conf_properties_show(FILE *fp);\nrd_kafka_topic_conf_t *rd_kafka_topic_conf_new(void);\nrd_kafka_topic_conf_t *rd_kafka_topic_conf_dup(const rd_kafka_topic_conf_t *conf);\nrd_kafka_topic_conf_t *rd_kafka_default_topic_conf_dup(rd_kafka_t *rk);\nvoid rd_kafka_topic_conf_destroy(rd_kafka_topic_conf_t *topic_conf);\nrd_kafka_conf_res_t rd_kafka_topic_conf_set(rd_kafka_topic_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);\nvoid rd_kafka_topic_conf_set_opaque(rd_kafka_topic_conf_t *conf, void *opaque);\nvoid rd_kafka_topic_conf_set_partitioner_cb(rd_kafka_topic_conf_t *topic_conf, int32_t (*partitioner)(const rd_kafka_topic_t *rkt, const void *keydata, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque));\nvoid rd_kafka_topic_conf_set_msg_order_cmp(rd_kafka_topic_conf_t *topic_conf, int (*msg_order_cmp)(const rd_kafka_message_t *a, const rd_kafka_message_t *b));\nint rd_kafka_topic_partition_available(const rd_kafka_topic_t *rkt, int32_t partition);\nint32_t rd_kafka_msg_partitioner_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_consistent(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_consistent_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_murmur2(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_murmur2_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nrd_kafka_t *rd_kafka_new(rd_kafka_type_t type, rd_kafka_conf_t *conf, char *errstr, size_t errstr_size);\nvoid rd_kafka_destroy(rd_kafka_t *rk);\nvoid rd_kafka_destroy_flags(rd_kafka_t *rk, int flags);\nconst char *rd_kafka_name(const rd_kafka_t *rk);\nrd_kafka_type_t rd_kafka_type(const rd_kafka_t *rk);\nchar *rd_kafka_memberid(const rd_kafka_t *rk);\nchar *rd_kafka_clusterid(rd_kafka_t *rk, int timeout_ms);\nint32_t rd_kafka_controllerid(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_topic_t *rd_kafka_topic_new(rd_kafka_t *rk, const char *topic, rd_kafka_topic_conf_t *conf);\nvoid rd_kafka_topic_destroy(rd_kafka_topic_t *rkt);\nconst char *rd_kafka_topic_name(const rd_kafka_topic_t *rkt);\nvoid *rd_kafka_topic_opaque(const rd_kafka_topic_t *rkt);\nint rd_kafka_poll(rd_kafka_t *rk, int timeout_ms);\nvoid rd_kafka_yield(rd_kafka_t *rk);\nrd_kafka_resp_err_t rd_kafka_pause_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_resp_err_t rd_kafka_resume_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_resp_err_t rd_kafka_query_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high, int timeout_ms);\nrd_kafka_resp_err_t rd_kafka_get_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high);\nrd_kafka_resp_err_t rd_kafka_offsets_for_times(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets, int timeout_ms);\nvoid rd_kafka_mem_free(rd_kafka_t *rk, void *ptr);\nrd_kafka_queue_t *rd_kafka_queue_new(rd_kafka_t *rk);\nvoid rd_kafka_queue_destroy(rd_kafka_queue_t *rkqu);\nrd_kafka_queue_t *rd_kafka_queue_get_main(rd_kafka_t *rk);\nrd_kafka_queue_t *rd_kafka_queue_get_consumer(rd_kafka_t *rk);\nrd_kafka_queue_t *rd_kafka_queue_get_partition(rd_kafka_t *rk, const char *topic, int32_t partition);\nrd_kafka_queue_t *rd_kafka_queue_get_background(rd_kafka_t *rk);\nvoid rd_kafka_queue_forward(rd_kafka_queue_t *src, rd_kafka_queue_t *dst);\nrd_kafka_resp_err_t rd_kafka_set_log_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu);\nsize_t rd_kafka_queue_length(rd_kafka_queue_t *rkqu);\nvoid rd_kafka_queue_io_event_enable(rd_kafka_queue_t *rkqu, int fd, const void *payload, size_t size);\nvoid rd_kafka_queue_cb_event_enable(rd_kafka_queue_t *rkqu, void (*event_cb)(rd_kafka_t *rk, void *opaque), void *opaque);\nint rd_kafka_consume_start(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);\nint rd_kafka_consume_start_queue(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, rd_kafka_queue_t *rkqu);\nint rd_kafka_consume_stop(rd_kafka_topic_t *rkt, int32_t partition);\nrd_kafka_resp_err_t rd_kafka_seek(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, int timeout_ms);\nrd_kafka_message_t *rd_kafka_consume(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms);\nssize_t rd_kafka_consume_batch(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);\nint rd_kafka_consume_callback(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *opaque), void *opaque);\nrd_kafka_message_t *rd_kafka_consume_queue(rd_kafka_queue_t *rkqu, int timeout_ms);\nssize_t rd_kafka_consume_batch_queue(rd_kafka_queue_t *rkqu, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);\nint rd_kafka_consume_callback_queue(rd_kafka_queue_t *rkqu, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *opaque), void *opaque);\nrd_kafka_resp_err_t rd_kafka_offset_store(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);\nrd_kafka_resp_err_t rd_kafka_offsets_store(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets);\nrd_kafka_resp_err_t rd_kafka_subscribe(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *topics);\nrd_kafka_resp_err_t rd_kafka_unsubscribe(rd_kafka_t *rk);\nrd_kafka_resp_err_t rd_kafka_subscription(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **topics);\nrd_kafka_message_t *rd_kafka_consumer_poll(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_resp_err_t rd_kafka_consumer_close(rd_kafka_t *rk);\nrd_kafka_resp_err_t rd_kafka_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_resp_err_t rd_kafka_assignment(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **partitions);\nrd_kafka_resp_err_t rd_kafka_commit(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, int async);\nrd_kafka_resp_err_t rd_kafka_commit_message(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, int async);\nrd_kafka_resp_err_t rd_kafka_commit_queue(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_queue_t *rkqu, void (*cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *opaque), void *opaque);\nrd_kafka_resp_err_t rd_kafka_committed(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms);\nrd_kafka_resp_err_t rd_kafka_position(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);\nint rd_kafka_produce(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, void *payload, size_t len, const void *key, size_t keylen, void *msg_opaque);\nrd_kafka_resp_err_t rd_kafka_producev(rd_kafka_t *rk, ...);\nint rd_kafka_produce_batch(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, rd_kafka_message_t *rkmessages, int message_cnt);\nrd_kafka_resp_err_t rd_kafka_flush(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_resp_err_t rd_kafka_purge(rd_kafka_t *rk, int purge_flags);\ntypedef struct rd_kafka_metadata_broker {\n  int32_t id;\n  char *host;\n  int port;\n} rd_kafka_metadata_broker_t;\ntypedef struct rd_kafka_metadata_partition {\n  int32_t id;\n  rd_kafka_resp_err_t err;\n  int32_t leader;\n  int replica_cnt;\n  int32_t *replicas;\n  int isr_cnt;\n  int32_t *isrs;\n} rd_kafka_metadata_partition_t;\ntypedef struct rd_kafka_metadata_topic {\n  char *topic;\n  int partition_cnt;\n  struct rd_kafka_metadata_partition *partitions;\n  rd_kafka_resp_err_t err;\n} rd_kafka_metadata_topic_t;\ntypedef struct rd_kafka_metadata {\n  int broker_cnt;\n  struct rd_kafka_metadata_broker *brokers;\n  int topic_cnt;\n  struct rd_kafka_metadata_topic *topics;\n  int32_t orig_broker_id;\n  char *orig_broker_name;\n} rd_kafka_metadata_t;\nrd_kafka_resp_err_t rd_kafka_metadata(rd_kafka_t *rk, int all_topics, rd_kafka_topic_t *only_rkt, const struct rd_kafka_metadata **metadatap, int timeout_ms);\nvoid rd_kafka_metadata_destroy(const struct rd_kafka_metadata *metadata);\nstruct rd_kafka_group_member_info {\n  char *member_id;\n  char *client_id;\n  char *client_host;\n  void *member_metadata;\n  int member_metadata_size;\n  void *member_assignment;\n  int member_assignment_size;\n};\nstruct rd_kafka_group_info {\n  struct rd_kafka_metadata_broker broker;\n  char *group;\n  rd_kafka_resp_err_t err;\n  char *state;\n  char *protocol_type;\n  char *protocol;\n  struct rd_kafka_group_member_info *members;\n  int member_cnt;\n};\nstruct rd_kafka_group_list {\n  struct rd_kafka_group_info *groups;\n  int group_cnt;\n};\nrd_kafka_resp_err_t rd_kafka_list_groups(rd_kafka_t *rk, const char *group, const struct rd_kafka_group_list **grplistp, int timeout_ms);\nvoid rd_kafka_group_list_destroy(const struct rd_kafka_group_list *grplist);\nint rd_kafka_brokers_add(rd_kafka_t *rk, const char *brokerlist);\nvoid rd_kafka_set_logger(rd_kafka_t *rk, void (*func)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));\nvoid rd_kafka_set_log_level(rd_kafka_t *rk, int level);\nvoid rd_kafka_log_print(const rd_kafka_t *rk, int level, const char *fac, const char *buf);\nvoid rd_kafka_log_syslog(const rd_kafka_t *rk, int level, const char *fac, const char *buf);\nint rd_kafka_outq_len(rd_kafka_t *rk);\nvoid rd_kafka_dump(FILE *fp, rd_kafka_t *rk);\nint rd_kafka_thread_cnt(void);\nint rd_kafka_wait_destroyed(int timeout_ms);\nint rd_kafka_unittest(void);\nrd_kafka_resp_err_t rd_kafka_poll_set_consumer(rd_kafka_t *rk);\ntypedef int rd_kafka_event_type_t;\nrd_kafka_event_type_t rd_kafka_event_type(const rd_kafka_event_t *rkev);\nconst char *rd_kafka_event_name(const rd_kafka_event_t *rkev);\nvoid rd_kafka_event_destroy(rd_kafka_event_t *rkev);\nconst rd_kafka_message_t *rd_kafka_event_message_next(rd_kafka_event_t *rkev);\nsize_t rd_kafka_event_message_array(rd_kafka_event_t *rkev, const rd_kafka_message_t **rkmessages, size_t size);\nsize_t rd_kafka_event_message_count(rd_kafka_event_t *rkev);\nrd_kafka_resp_err_t rd_kafka_event_error(rd_kafka_event_t *rkev);\nconst char *rd_kafka_event_error_string(rd_kafka_event_t *rkev);\nint rd_kafka_event_error_is_fatal(rd_kafka_event_t *rkev);\nvoid *rd_kafka_event_opaque(rd_kafka_event_t *rkev);\nint rd_kafka_event_log(rd_kafka_event_t *rkev, const char **fac, const char **str, int *level);\nconst char *rd_kafka_event_stats(rd_kafka_event_t *rkev);\nrd_kafka_topic_partition_list_t *rd_kafka_event_topic_partition_list(rd_kafka_event_t *rkev);\nrd_kafka_topic_partition_t *rd_kafka_event_topic_partition(rd_kafka_event_t *rkev);\ntypedef rd_kafka_event_t rd_kafka_CreateTopics_result_t;\ntypedef rd_kafka_event_t rd_kafka_DeleteTopics_result_t;\ntypedef rd_kafka_event_t rd_kafka_CreatePartitions_result_t;\ntypedef rd_kafka_event_t rd_kafka_AlterConfigs_result_t;\ntypedef rd_kafka_event_t rd_kafka_DescribeConfigs_result_t;\nconst rd_kafka_CreateTopics_result_t *rd_kafka_event_CreateTopics_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DeleteTopics_result_t *rd_kafka_event_DeleteTopics_result(rd_kafka_event_t *rkev);\nconst rd_kafka_CreatePartitions_result_t *rd_kafka_event_CreatePartitions_result(rd_kafka_event_t *rkev);\nconst rd_kafka_AlterConfigs_result_t *rd_kafka_event_AlterConfigs_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DescribeConfigs_result_t *rd_kafka_event_DescribeConfigs_result(rd_kafka_event_t *rkev);\nrd_kafka_event_t *rd_kafka_queue_poll(rd_kafka_queue_t *rkqu, int timeout_ms);\nint rd_kafka_queue_poll_callback(rd_kafka_queue_t *rkqu, int timeout_ms);\ntypedef rd_kafka_resp_err_t (rd_kafka_plugin_f_conf_init_t)(rd_kafka_conf_t *conf, void **plug_opaquep, char *errstr, size_t errstr_size);\ntypedef rd_kafka_conf_res_t (rd_kafka_interceptor_f_on_conf_set_t)(rd_kafka_conf_t *conf, const char *name, const char *val, char *errstr, size_t errstr_size, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_dup_t)(rd_kafka_conf_t *new_conf, const rd_kafka_conf_t *old_conf, size_t filter_cnt, const char **filter, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_destroy_t)(void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_new_t)(rd_kafka_t *rk, const rd_kafka_conf_t *conf, void *ic_opaque, char *errstr, size_t errstr_size);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_destroy_t)(rd_kafka_t *rk, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_send_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_acknowledgement_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_consume_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_commit_t)(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_resp_err_t err, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_request_sent_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_set(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_set_t *on_conf_set, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_dup(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_dup_t *on_conf_dup, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_destroy(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_destroy_t *on_conf_destroy, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_new(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_new_t *on_new, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_destroy(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_destroy_t *on_destroy, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_send(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_send_t *on_send, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_acknowledgement(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_acknowledgement_t *on_acknowledgement, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_consume(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_consume_t *on_consume, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_commit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_commit_t *on_commit, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_request_sent(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_request_sent_t *on_request_sent, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_topic_result_error(const rd_kafka_topic_result_t *topicres);\nconst char *rd_kafka_topic_result_error_string(const rd_kafka_topic_result_t *topicres);\nconst char *rd_kafka_topic_result_name(const rd_kafka_topic_result_t *topicres);\ntypedef enum rd_kafka_admin_op_t {\n  RD_KAFKA_ADMIN_OP_ANY = 0,\n  RD_KAFKA_ADMIN_OP_CREATETOPICS,\n  RD_KAFKA_ADMIN_OP_DELETETOPICS,\n  RD_KAFKA_ADMIN_OP_CREATEPARTITIONS,\n  RD_KAFKA_ADMIN_OP_ALTERCONFIGS,\n  RD_KAFKA_ADMIN_OP_DESCRIBECONFIGS,\n  RD_KAFKA_ADMIN_OP__CNT,\n} rd_kafka_admin_op_t;\ntypedef struct rd_kafka_AdminOptions_s rd_kafka_AdminOptions_t;\nrd_kafka_AdminOptions_t *rd_kafka_AdminOptions_new(rd_kafka_t *rk, rd_kafka_admin_op_t for_api);\nvoid rd_kafka_AdminOptions_destroy(rd_kafka_AdminOptions_t *options);\nrd_kafka_resp_err_t rd_kafka_AdminOptions_set_request_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_AdminOptions_set_operation_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_AdminOptions_set_validate_only(rd_kafka_AdminOptions_t *options, int true_or_false, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_AdminOptions_set_broker(rd_kafka_AdminOptions_t *options, int32_t broker_id, char *errstr, size_t errstr_size);\nvoid rd_kafka_AdminOptions_set_opaque(rd_kafka_AdminOptions_t *options, void *opaque);\ntypedef struct rd_kafka_NewTopic_s rd_kafka_NewTopic_t;\nrd_kafka_NewTopic_t *rd_kafka_NewTopic_new(const char *topic, int num_partitions, int replication_factor, char *errstr, size_t errstr_size);\nvoid rd_kafka_NewTopic_destroy(rd_kafka_NewTopic_t *new_topic);\nvoid rd_kafka_NewTopic_destroy_array(rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt);\nrd_kafka_resp_err_t rd_kafka_NewTopic_set_replica_assignment(rd_kafka_NewTopic_t *new_topic, int32_t partition, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_NewTopic_set_config(rd_kafka_NewTopic_t *new_topic, const char *name, const char *value);\nvoid rd_kafka_CreateTopics(rd_kafka_t *rk, rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_topic_result_t **rd_kafka_CreateTopics_result_topics(const rd_kafka_CreateTopics_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_DeleteTopic_s rd_kafka_DeleteTopic_t;\nrd_kafka_DeleteTopic_t *rd_kafka_DeleteTopic_new(const char *topic);\nvoid rd_kafka_DeleteTopic_destroy(rd_kafka_DeleteTopic_t *del_topic);\nvoid rd_kafka_DeleteTopic_destroy_array(rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt);\nvoid rd_kafka_DeleteTopics(rd_kafka_t *rk, rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_topic_result_t **rd_kafka_DeleteTopics_result_topics(const rd_kafka_DeleteTopics_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_NewPartitions_s rd_kafka_NewPartitions_t;\nrd_kafka_NewPartitions_t *rd_kafka_NewPartitions_new(const char *topic, size_t new_total_cnt, char *errstr, size_t errstr_size);\nvoid rd_kafka_NewPartitions_destroy(rd_kafka_NewPartitions_t *new_parts);\nvoid rd_kafka_NewPartitions_destroy_array(rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt);\nrd_kafka_resp_err_t rd_kafka_NewPartitions_set_replica_assignment(rd_kafka_NewPartitions_t *new_parts, int32_t new_partition_idx, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);\nvoid rd_kafka_CreatePartitions(rd_kafka_t *rk, rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_topic_result_t **rd_kafka_CreatePartitions_result_topics(const rd_kafka_CreatePartitions_result_t *result, size_t *cntp);\ntypedef enum rd_kafka_ConfigSource_t {\n  RD_KAFKA_CONFIG_SOURCE_UNKNOWN_CONFIG = 0,\n  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_TOPIC_CONFIG = 1,\n  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_BROKER_CONFIG = 2,\n  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_DEFAULT_BROKER_CONFIG = 3,\n  RD_KAFKA_CONFIG_SOURCE_STATIC_BROKER_CONFIG = 4,\n  RD_KAFKA_CONFIG_SOURCE_DEFAULT_CONFIG = 5,\n  RD_KAFKA_CONFIG_SOURCE__CNT,\n} rd_kafka_ConfigSource_t;\nconst char *rd_kafka_ConfigSource_name(rd_kafka_ConfigSource_t confsource);\ntypedef struct rd_kafka_ConfigEntry_s rd_kafka_ConfigEntry_t;\nconst char *rd_kafka_ConfigEntry_name(const rd_kafka_ConfigEntry_t *entry);\nconst char *rd_kafka_ConfigEntry_value(const rd_kafka_ConfigEntry_t *entry);\nrd_kafka_ConfigSource_t rd_kafka_ConfigEntry_source(const rd_kafka_ConfigEntry_t *entry);\nint rd_kafka_ConfigEntry_is_read_only(const rd_kafka_ConfigEntry_t *entry);\nint rd_kafka_ConfigEntry_is_default(const rd_kafka_ConfigEntry_t *entry);\nint rd_kafka_ConfigEntry_is_sensitive(const rd_kafka_ConfigEntry_t *entry);\nint rd_kafka_ConfigEntry_is_synonym(const rd_kafka_ConfigEntry_t *entry);\nconst rd_kafka_ConfigEntry_t **rd_kafka_ConfigEntry_synonyms(const rd_kafka_ConfigEntry_t *entry, size_t *cntp);\ntypedef enum rd_kafka_ResourceType_t {\n  RD_KAFKA_RESOURCE_UNKNOWN = 0,\n  RD_KAFKA_RESOURCE_ANY = 1,\n  RD_KAFKA_RESOURCE_TOPIC = 2,\n  RD_KAFKA_RESOURCE_GROUP = 3,\n  RD_KAFKA_RESOURCE_BROKER = 4,\n  RD_KAFKA_RESOURCE__CNT,\n} rd_kafka_ResourceType_t;\nconst char *rd_kafka_ResourceType_name(rd_kafka_ResourceType_t restype);\ntypedef struct rd_kafka_ConfigResource_s rd_kafka_ConfigResource_t;\nrd_kafka_ConfigResource_t *rd_kafka_ConfigResource_new(rd_kafka_ResourceType_t restype, const char *resname);\nvoid rd_kafka_ConfigResource_destroy(rd_kafka_ConfigResource_t *config);\nvoid rd_kafka_ConfigResource_destroy_array(rd_kafka_ConfigResource_t **config, size_t config_cnt);\nrd_kafka_resp_err_t rd_kafka_ConfigResource_set_config(rd_kafka_ConfigResource_t *config, const char *name, const char *value);\nconst rd_kafka_ConfigEntry_t **rd_kafka_ConfigResource_configs(const rd_kafka_ConfigResource_t *config, size_t *cntp);\nrd_kafka_ResourceType_t rd_kafka_ConfigResource_type(const rd_kafka_ConfigResource_t *config);\nconst char *rd_kafka_ConfigResource_name(const rd_kafka_ConfigResource_t *config);\nrd_kafka_resp_err_t rd_kafka_ConfigResource_error(const rd_kafka_ConfigResource_t *config);\nconst char *rd_kafka_ConfigResource_error_string(const rd_kafka_ConfigResource_t *config);\nvoid rd_kafka_AlterConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_ConfigResource_t **rd_kafka_AlterConfigs_result_resources(const rd_kafka_AlterConfigs_result_t *result, size_t *cntp);\nvoid rd_kafka_DescribeConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_ConfigResource_t **rd_kafka_DescribeConfigs_result_resources(const rd_kafka_DescribeConfigs_result_t *result, size_t *cntp);\n'\n</code></pre> rdkafka.h, rdkafka_mock.h</p>"},{"location":"api/constants/#rd_kafka_version_2","title":"RD_KAFKA_VERSION","text":"<pre><code>public RD_KAFKA_VERSION = 16843007\n</code></pre> <p>librdkafka version </p> <p>Interpreted as hex <code>MM.mm.rr.xx</code>:</p> <ul> <li>MM = Major</li> <li>mm = minor</li> <li>rr = revision</li> <li>xx = pre-release id (0xff is the final release)</li> </ul> <p>E.g.: <code>0x000801ff</code> = 0.8.1</p> RemarksThis value should only be used during compile time, for runtime checks of version use rd_kafka_version()  <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_unsupported_compression_type_2","title":"RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE","text":"<pre><code>public RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76\n</code></pre> <p>Unsupported compression type </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_end_all_2","title":"RD_KAFKA_RESP_ERR_END_ALL","text":"<p><pre><code>public RD_KAFKA_RESP_ERR_END_ALL = 82\n</code></pre> enum rd_kafka_resp_err_t</p>"},{"location":"api/constants/#rd_kafka_admin_op__cnt_2","title":"RD_KAFKA_ADMIN_OP__CNT","text":"<pre><code>public RD_KAFKA_ADMIN_OP__CNT = 6\n</code></pre> <p>Number of ops defined </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe </li> </ul>"},{"location":"api/constants/#rd_kafka_resource__cnt_2","title":"RD_KAFKA_RESOURCE__CNT","text":"<pre><code>public RD_KAFKA_RESOURCE__CNT = 5\n</code></pre> <p>Number of resource types defined </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#acca83a66d7783ff7683ed2691cc907c9 </li> </ul>"},{"location":"api/constants/#rd_kafka_cdef_2","title":"RD_KAFKA_CDEF","text":"<p><pre><code>public RD_KAFKA_CDEF = 'typedef long int ssize_t;\ntypedef struct _IO_FILE FILE;\ntypedef long int mode_t;\ntypedef signed int int16_t;\ntypedef unsigned int uint16_t;\ntypedef signed int int32_t;\ntypedef signed long int int64_t;\nint rd_kafka_version(void);\nconst char *rd_kafka_version_str(void);\ntypedef enum rd_kafka_type_t {\n  RD_KAFKA_PRODUCER,\n  RD_KAFKA_CONSUMER,\n} rd_kafka_type_t;\ntypedef enum rd_kafka_timestamp_type_t {\n  RD_KAFKA_TIMESTAMP_NOT_AVAILABLE,\n  RD_KAFKA_TIMESTAMP_CREATE_TIME,\n  RD_KAFKA_TIMESTAMP_LOG_APPEND_TIME,\n} rd_kafka_timestamp_type_t;\nconst char *rd_kafka_get_debug_contexts(void);\ntypedef struct rd_kafka_s rd_kafka_t;\ntypedef struct rd_kafka_topic_s rd_kafka_topic_t;\ntypedef struct rd_kafka_conf_s rd_kafka_conf_t;\ntypedef struct rd_kafka_topic_conf_s rd_kafka_topic_conf_t;\ntypedef struct rd_kafka_queue_s rd_kafka_queue_t;\ntypedef struct rd_kafka_op_s rd_kafka_event_t;\ntypedef struct rd_kafka_topic_result_s rd_kafka_topic_result_t;\ntypedef enum {\n  RD_KAFKA_RESP_ERR__BEGIN = (- 200),\n  RD_KAFKA_RESP_ERR__BAD_MSG = (- 199),\n  RD_KAFKA_RESP_ERR__BAD_COMPRESSION = (- 198),\n  RD_KAFKA_RESP_ERR__DESTROY = (- 197),\n  RD_KAFKA_RESP_ERR__FAIL = (- 196),\n  RD_KAFKA_RESP_ERR__TRANSPORT = (- 195),\n  RD_KAFKA_RESP_ERR__CRIT_SYS_RESOURCE = (- 194),\n  RD_KAFKA_RESP_ERR__RESOLVE = (- 193),\n  RD_KAFKA_RESP_ERR__MSG_TIMED_OUT = (- 192),\n  RD_KAFKA_RESP_ERR__PARTITION_EOF = (- 191),\n  RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION = (- 190),\n  RD_KAFKA_RESP_ERR__FS = (- 189),\n  RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC = (- 188),\n  RD_KAFKA_RESP_ERR__ALL_BROKERS_DOWN = (- 187),\n  RD_KAFKA_RESP_ERR__INVALID_ARG = (- 186),\n  RD_KAFKA_RESP_ERR__TIMED_OUT = (- 185),\n  RD_KAFKA_RESP_ERR__QUEUE_FULL = (- 184),\n  RD_KAFKA_RESP_ERR__ISR_INSUFF = (- 183),\n  RD_KAFKA_RESP_ERR__NODE_UPDATE = (- 182),\n  RD_KAFKA_RESP_ERR__SSL = (- 181),\n  RD_KAFKA_RESP_ERR__WAIT_COORD = (- 180),\n  RD_KAFKA_RESP_ERR__UNKNOWN_GROUP = (- 179),\n  RD_KAFKA_RESP_ERR__IN_PROGRESS = (- 178),\n  RD_KAFKA_RESP_ERR__PREV_IN_PROGRESS = (- 177),\n  RD_KAFKA_RESP_ERR__EXISTING_SUBSCRIPTION = (- 176),\n  RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS = (- 175),\n  RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS = (- 174),\n  RD_KAFKA_RESP_ERR__CONFLICT = (- 173),\n  RD_KAFKA_RESP_ERR__STATE = (- 172),\n  RD_KAFKA_RESP_ERR__UNKNOWN_PROTOCOL = (- 171),\n  RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED = (- 170),\n  RD_KAFKA_RESP_ERR__AUTHENTICATION = (- 169),\n  RD_KAFKA_RESP_ERR__NO_OFFSET = (- 168),\n  RD_KAFKA_RESP_ERR__OUTDATED = (- 167),\n  RD_KAFKA_RESP_ERR__TIMED_OUT_QUEUE = (- 166),\n  RD_KAFKA_RESP_ERR__UNSUPPORTED_FEATURE = (- 165),\n  RD_KAFKA_RESP_ERR__WAIT_CACHE = (- 164),\n  RD_KAFKA_RESP_ERR__INTR = (- 163),\n  RD_KAFKA_RESP_ERR__KEY_SERIALIZATION = (- 162),\n  RD_KAFKA_RESP_ERR__VALUE_SERIALIZATION = (- 161),\n  RD_KAFKA_RESP_ERR__KEY_DESERIALIZATION = (- 160),\n  RD_KAFKA_RESP_ERR__VALUE_DESERIALIZATION = (- 159),\n  RD_KAFKA_RESP_ERR__PARTIAL = (- 158),\n  RD_KAFKA_RESP_ERR__READ_ONLY = (- 157),\n  RD_KAFKA_RESP_ERR__NOENT = (- 156),\n  RD_KAFKA_RESP_ERR__UNDERFLOW = (- 155),\n  RD_KAFKA_RESP_ERR__INVALID_TYPE = (- 154),\n  RD_KAFKA_RESP_ERR__RETRY = (- 153),\n  RD_KAFKA_RESP_ERR__PURGE_QUEUE = (- 152),\n  RD_KAFKA_RESP_ERR__PURGE_INFLIGHT = (- 151),\n  RD_KAFKA_RESP_ERR__FATAL = (- 150),\n  RD_KAFKA_RESP_ERR__INCONSISTENT = (- 149),\n  RD_KAFKA_RESP_ERR__GAPLESS_GUARANTEE = (- 148),\n  RD_KAFKA_RESP_ERR__MAX_POLL_EXCEEDED = (- 147),\n  RD_KAFKA_RESP_ERR__END = (- 100),\n  RD_KAFKA_RESP_ERR_UNKNOWN = (- 1),\n  RD_KAFKA_RESP_ERR_NO_ERROR = 0,\n  RD_KAFKA_RESP_ERR_OFFSET_OUT_OF_RANGE = 1,\n  RD_KAFKA_RESP_ERR_INVALID_MSG = 2,\n  RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART = 3,\n  RD_KAFKA_RESP_ERR_INVALID_MSG_SIZE = 4,\n  RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE = 5,\n  RD_KAFKA_RESP_ERR_NOT_LEADER_FOR_PARTITION = 6,\n  RD_KAFKA_RESP_ERR_REQUEST_TIMED_OUT = 7,\n  RD_KAFKA_RESP_ERR_BROKER_NOT_AVAILABLE = 8,\n  RD_KAFKA_RESP_ERR_REPLICA_NOT_AVAILABLE = 9,\n  RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE = 10,\n  RD_KAFKA_RESP_ERR_STALE_CTRL_EPOCH = 11,\n  RD_KAFKA_RESP_ERR_OFFSET_METADATA_TOO_LARGE = 12,\n  RD_KAFKA_RESP_ERR_NETWORK_EXCEPTION = 13,\n  RD_KAFKA_RESP_ERR_GROUP_LOAD_IN_PROGRESS = 14,\n  RD_KAFKA_RESP_ERR_GROUP_COORDINATOR_NOT_AVAILABLE = 15,\n  RD_KAFKA_RESP_ERR_NOT_COORDINATOR_FOR_GROUP = 16,\n  RD_KAFKA_RESP_ERR_TOPIC_EXCEPTION = 17,\n  RD_KAFKA_RESP_ERR_RECORD_LIST_TOO_LARGE = 18,\n  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS = 19,\n  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS_AFTER_APPEND = 20,\n  RD_KAFKA_RESP_ERR_INVALID_REQUIRED_ACKS = 21,\n  RD_KAFKA_RESP_ERR_ILLEGAL_GENERATION = 22,\n  RD_KAFKA_RESP_ERR_INCONSISTENT_GROUP_PROTOCOL = 23,\n  RD_KAFKA_RESP_ERR_INVALID_GROUP_ID = 24,\n  RD_KAFKA_RESP_ERR_UNKNOWN_MEMBER_ID = 25,\n  RD_KAFKA_RESP_ERR_INVALID_SESSION_TIMEOUT = 26,\n  RD_KAFKA_RESP_ERR_REBALANCE_IN_PROGRESS = 27,\n  RD_KAFKA_RESP_ERR_INVALID_COMMIT_OFFSET_SIZE = 28,\n  RD_KAFKA_RESP_ERR_TOPIC_AUTHORIZATION_FAILED = 29,\n  RD_KAFKA_RESP_ERR_GROUP_AUTHORIZATION_FAILED = 30,\n  RD_KAFKA_RESP_ERR_CLUSTER_AUTHORIZATION_FAILED = 31,\n  RD_KAFKA_RESP_ERR_INVALID_TIMESTAMP = 32,\n  RD_KAFKA_RESP_ERR_UNSUPPORTED_SASL_MECHANISM = 33,\n  RD_KAFKA_RESP_ERR_ILLEGAL_SASL_STATE = 34,\n  RD_KAFKA_RESP_ERR_UNSUPPORTED_VERSION = 35,\n  RD_KAFKA_RESP_ERR_TOPIC_ALREADY_EXISTS = 36,\n  RD_KAFKA_RESP_ERR_INVALID_PARTITIONS = 37,\n  RD_KAFKA_RESP_ERR_INVALID_REPLICATION_FACTOR = 38,\n  RD_KAFKA_RESP_ERR_INVALID_REPLICA_ASSIGNMENT = 39,\n  RD_KAFKA_RESP_ERR_INVALID_CONFIG = 40,\n  RD_KAFKA_RESP_ERR_NOT_CONTROLLER = 41,\n  RD_KAFKA_RESP_ERR_INVALID_REQUEST = 42,\n  RD_KAFKA_RESP_ERR_UNSUPPORTED_FOR_MESSAGE_FORMAT = 43,\n  RD_KAFKA_RESP_ERR_POLICY_VIOLATION = 44,\n  RD_KAFKA_RESP_ERR_OUT_OF_ORDER_SEQUENCE_NUMBER = 45,\n  RD_KAFKA_RESP_ERR_DUPLICATE_SEQUENCE_NUMBER = 46,\n  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_EPOCH = 47,\n  RD_KAFKA_RESP_ERR_INVALID_TXN_STATE = 48,\n  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_ID_MAPPING = 49,\n  RD_KAFKA_RESP_ERR_INVALID_TRANSACTION_TIMEOUT = 50,\n  RD_KAFKA_RESP_ERR_CONCURRENT_TRANSACTIONS = 51,\n  RD_KAFKA_RESP_ERR_TRANSACTION_COORDINATOR_FENCED = 52,\n  RD_KAFKA_RESP_ERR_TRANSACTIONAL_ID_AUTHORIZATION_FAILED = 53,\n  RD_KAFKA_RESP_ERR_SECURITY_DISABLED = 54,\n  RD_KAFKA_RESP_ERR_OPERATION_NOT_ATTEMPTED = 55,\n  RD_KAFKA_RESP_ERR_KAFKA_STORAGE_ERROR = 56,\n  RD_KAFKA_RESP_ERR_LOG_DIR_NOT_FOUND = 57,\n  RD_KAFKA_RESP_ERR_SASL_AUTHENTICATION_FAILED = 58,\n  RD_KAFKA_RESP_ERR_UNKNOWN_PRODUCER_ID = 59,\n  RD_KAFKA_RESP_ERR_REASSIGNMENT_IN_PROGRESS = 60,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTH_DISABLED = 61,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_NOT_FOUND = 62,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_OWNER_MISMATCH = 63,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_REQUEST_NOT_ALLOWED = 64,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTHORIZATION_FAILED = 65,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_EXPIRED = 66,\n  RD_KAFKA_RESP_ERR_INVALID_PRINCIPAL_TYPE = 67,\n  RD_KAFKA_RESP_ERR_NON_EMPTY_GROUP = 68,\n  RD_KAFKA_RESP_ERR_GROUP_ID_NOT_FOUND = 69,\n  RD_KAFKA_RESP_ERR_FETCH_SESSION_ID_NOT_FOUND = 70,\n  RD_KAFKA_RESP_ERR_INVALID_FETCH_SESSION_EPOCH = 71,\n  RD_KAFKA_RESP_ERR_LISTENER_NOT_FOUND = 72,\n  RD_KAFKA_RESP_ERR_TOPIC_DELETION_DISABLED = 73,\n  RD_KAFKA_RESP_ERR_FENCED_LEADER_EPOCH = 74,\n  RD_KAFKA_RESP_ERR_UNKNOWN_LEADER_EPOCH = 75,\n  RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76,\n  RD_KAFKA_RESP_ERR_STALE_BROKER_EPOCH = 77,\n  RD_KAFKA_RESP_ERR_OFFSET_NOT_AVAILABLE = 78,\n  RD_KAFKA_RESP_ERR_MEMBER_ID_REQUIRED = 79,\n  RD_KAFKA_RESP_ERR_PREFERRED_LEADER_NOT_AVAILABLE = 80,\n  RD_KAFKA_RESP_ERR_GROUP_MAX_SIZE_REACHED = 81,\n  RD_KAFKA_RESP_ERR_END_ALL,\n} rd_kafka_resp_err_t;\nstruct rd_kafka_err_desc {\n  rd_kafka_resp_err_t code;\n  char *name;\n  char *desc;\n};\nvoid rd_kafka_get_err_descs(const struct rd_kafka_err_desc **errdescs, size_t *cntp);\nconst char *rd_kafka_err2str(rd_kafka_resp_err_t err);\nconst char *rd_kafka_err2name(rd_kafka_resp_err_t err);\nrd_kafka_resp_err_t rd_kafka_last_error(void);\nrd_kafka_resp_err_t rd_kafka_errno2err(int errnox);\nint rd_kafka_errno(void);\nrd_kafka_resp_err_t rd_kafka_fatal_error(rd_kafka_t *rk, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_test_fatal_error(rd_kafka_t *rk, rd_kafka_resp_err_t err, const char *reason);\ntypedef struct rd_kafka_topic_partition_s {\n  char *topic;\n  int32_t partition;\n  int64_t offset;\n  void *metadata;\n  size_t metadata_size;\n  void *opaque;\n  rd_kafka_resp_err_t err;\n  void *_private;\n} rd_kafka_topic_partition_t;\nvoid rd_kafka_topic_partition_destroy(rd_kafka_topic_partition_t *rktpar);\ntypedef struct rd_kafka_topic_partition_list_s {\n  int cnt;\n  int size;\n  rd_kafka_topic_partition_t *elems;\n} rd_kafka_topic_partition_list_t;\nrd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_new(int size);\nvoid rd_kafka_topic_partition_list_destroy(rd_kafka_topic_partition_list_t *rkparlist);\nrd_kafka_topic_partition_t *rd_kafka_topic_partition_list_add(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);\nvoid rd_kafka_topic_partition_list_add_range(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t start, int32_t stop);\nint rd_kafka_topic_partition_list_del(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);\nint rd_kafka_topic_partition_list_del_by_idx(rd_kafka_topic_partition_list_t *rktparlist, int idx);\nrd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_copy(const rd_kafka_topic_partition_list_t *src);\nrd_kafka_resp_err_t rd_kafka_topic_partition_list_set_offset(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition, int64_t offset);\nrd_kafka_topic_partition_t *rd_kafka_topic_partition_list_find(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);\nvoid rd_kafka_topic_partition_list_sort(rd_kafka_topic_partition_list_t *rktparlist, int (*cmp)(const void *a, const void *b, void *opaque), void *opaque);\ntypedef enum rd_kafka_vtype_t {\n  RD_KAFKA_VTYPE_END,\n  RD_KAFKA_VTYPE_TOPIC,\n  RD_KAFKA_VTYPE_RKT,\n  RD_KAFKA_VTYPE_PARTITION,\n  RD_KAFKA_VTYPE_VALUE,\n  RD_KAFKA_VTYPE_KEY,\n  RD_KAFKA_VTYPE_OPAQUE,\n  RD_KAFKA_VTYPE_MSGFLAGS,\n  RD_KAFKA_VTYPE_TIMESTAMP,\n  RD_KAFKA_VTYPE_HEADER,\n  RD_KAFKA_VTYPE_HEADERS,\n} rd_kafka_vtype_t;\ntypedef struct rd_kafka_headers_s rd_kafka_headers_t;\nrd_kafka_headers_t *rd_kafka_headers_new(size_t initial_count);\nvoid rd_kafka_headers_destroy(rd_kafka_headers_t *hdrs);\nrd_kafka_headers_t *rd_kafka_headers_copy(const rd_kafka_headers_t *src);\nrd_kafka_resp_err_t rd_kafka_header_add(rd_kafka_headers_t *hdrs, const char *name, ssize_t name_size, const void *value, ssize_t value_size);\nrd_kafka_resp_err_t rd_kafka_header_remove(rd_kafka_headers_t *hdrs, const char *name);\nrd_kafka_resp_err_t rd_kafka_header_get_last(const rd_kafka_headers_t *hdrs, const char *name, const void **valuep, size_t *sizep);\nrd_kafka_resp_err_t rd_kafka_header_get(const rd_kafka_headers_t *hdrs, size_t idx, const char *name, const void **valuep, size_t *sizep);\nrd_kafka_resp_err_t rd_kafka_header_get_all(const rd_kafka_headers_t *hdrs, size_t idx, const char **namep, const void **valuep, size_t *sizep);\ntypedef struct rd_kafka_message_s {\n  rd_kafka_resp_err_t err;\n  rd_kafka_topic_t *rkt;\n  int32_t partition;\n  void *payload;\n  size_t len;\n  void *key;\n  size_t key_len;\n  int64_t offset;\n  void *_private;\n} rd_kafka_message_t;\nvoid rd_kafka_message_destroy(rd_kafka_message_t *rkmessage);\nint64_t rd_kafka_message_timestamp(const rd_kafka_message_t *rkmessage, rd_kafka_timestamp_type_t *tstype);\nint64_t rd_kafka_message_latency(const rd_kafka_message_t *rkmessage);\nrd_kafka_resp_err_t rd_kafka_message_headers(const rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);\nrd_kafka_resp_err_t rd_kafka_message_detach_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);\nvoid rd_kafka_message_set_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t *hdrs);\nsize_t rd_kafka_header_cnt(const rd_kafka_headers_t *hdrs);\ntypedef enum {\n  RD_KAFKA_MSG_STATUS_NOT_PERSISTED = 0,\n  RD_KAFKA_MSG_STATUS_POSSIBLY_PERSISTED = 1,\n  RD_KAFKA_MSG_STATUS_PERSISTED = 2,\n} rd_kafka_msg_status_t;\nrd_kafka_msg_status_t rd_kafka_message_status(const rd_kafka_message_t *rkmessage);\ntypedef enum {\n  RD_KAFKA_CONF_UNKNOWN = (- 2),\n  RD_KAFKA_CONF_INVALID = (- 1),\n  RD_KAFKA_CONF_OK = 0,\n} rd_kafka_conf_res_t;\nrd_kafka_conf_t *rd_kafka_conf_new(void);\nvoid rd_kafka_conf_destroy(rd_kafka_conf_t *conf);\nrd_kafka_conf_t *rd_kafka_conf_dup(const rd_kafka_conf_t *conf);\nrd_kafka_conf_t *rd_kafka_conf_dup_filter(const rd_kafka_conf_t *conf, size_t filter_cnt, const char **filter);\nconst rd_kafka_conf_t *rd_kafka_conf(rd_kafka_t *rk);\nrd_kafka_conf_res_t rd_kafka_conf_set(rd_kafka_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);\nvoid rd_kafka_conf_set_events(rd_kafka_conf_t *conf, int events);\nvoid rd_kafka_conf_set_background_event_cb(rd_kafka_conf_t *conf, void (*event_cb)(rd_kafka_t *rk, rd_kafka_event_t *rkev, void *opaque));\nvoid rd_kafka_conf_set_dr_cb(rd_kafka_conf_t *conf, void (*dr_cb)(rd_kafka_t *rk, void *payload, size_t len, rd_kafka_resp_err_t err, void *opaque, void *msg_opaque));\nvoid rd_kafka_conf_set_dr_msg_cb(rd_kafka_conf_t *conf, void (*dr_msg_cb)(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, void *opaque));\nvoid rd_kafka_conf_set_consume_cb(rd_kafka_conf_t *conf, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *opaque));\nvoid rd_kafka_conf_set_rebalance_cb(rd_kafka_conf_t *conf, void (*rebalance_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *partitions, void *opaque));\nvoid rd_kafka_conf_set_offset_commit_cb(rd_kafka_conf_t *conf, void (*offset_commit_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *opaque));\nvoid rd_kafka_conf_set_error_cb(rd_kafka_conf_t *conf, void (*error_cb)(rd_kafka_t *rk, int err, const char *reason, void *opaque));\nvoid rd_kafka_conf_set_throttle_cb(rd_kafka_conf_t *conf, void (*throttle_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int throttle_time_ms, void *opaque));\nvoid rd_kafka_conf_set_log_cb(rd_kafka_conf_t *conf, void (*log_cb)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));\nvoid rd_kafka_conf_set_stats_cb(rd_kafka_conf_t *conf, int (*stats_cb)(rd_kafka_t *rk, char *json, size_t json_len, void *opaque));\nvoid rd_kafka_conf_set_oauthbearer_token_refresh_cb(rd_kafka_conf_t *conf, void (*oauthbearer_token_refresh_cb)(rd_kafka_t *rk, const char *oauthbearer_config, void *opaque));\nvoid rd_kafka_conf_set_socket_cb(rd_kafka_conf_t *conf, int (*socket_cb)(int domain, int type, int protocol, void *opaque));\nvoid rd_kafka_conf_set_connect_cb(rd_kafka_conf_t *conf, int (*connect_cb)(int sockfd, const struct sockaddr *addr, int addrlen, const char *id, void *opaque));\nvoid rd_kafka_conf_set_closesocket_cb(rd_kafka_conf_t *conf, int (*closesocket_cb)(int sockfd, void *opaque));\nrd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert_verify_cb(rd_kafka_conf_t *conf, int (*ssl_cert_verify_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int *x509_error, int depth, const char *buf, size_t size, char *errstr, size_t errstr_size, void *opaque));\ntypedef enum rd_kafka_cert_type_t {\n  RD_KAFKA_CERT_PUBLIC_KEY,\n  RD_KAFKA_CERT_PRIVATE_KEY,\n  RD_KAFKA_CERT_CA,\n  RD_KAFKA_CERT__CNT,\n} rd_kafka_cert_type_t;\ntypedef enum rd_kafka_cert_enc_t {\n  RD_KAFKA_CERT_ENC_PKCS12,\n  RD_KAFKA_CERT_ENC_DER,\n  RD_KAFKA_CERT_ENC_PEM,\n  RD_KAFKA_CERT_ENC__CNT,\n} rd_kafka_cert_enc_t;\nrd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert(rd_kafka_conf_t *conf, rd_kafka_cert_type_t cert_type, rd_kafka_cert_enc_t cert_enc, const void *buffer, size_t size, char *errstr, size_t errstr_size);\nvoid rd_kafka_conf_set_opaque(rd_kafka_conf_t *conf, void *opaque);\nvoid *rd_kafka_opaque(const rd_kafka_t *rk);\nvoid rd_kafka_conf_set_default_topic_conf(rd_kafka_conf_t *conf, rd_kafka_topic_conf_t *tconf);\nrd_kafka_conf_res_t rd_kafka_conf_get(const rd_kafka_conf_t *conf, const char *name, char *dest, size_t *dest_size);\nrd_kafka_conf_res_t rd_kafka_topic_conf_get(const rd_kafka_topic_conf_t *conf, const char *name, char *dest, size_t *dest_size);\nconst char **rd_kafka_conf_dump(rd_kafka_conf_t *conf, size_t *cntp);\nconst char **rd_kafka_topic_conf_dump(rd_kafka_topic_conf_t *conf, size_t *cntp);\nvoid rd_kafka_conf_dump_free(const char **arr, size_t cnt);\nvoid rd_kafka_conf_properties_show(FILE *fp);\nrd_kafka_topic_conf_t *rd_kafka_topic_conf_new(void);\nrd_kafka_topic_conf_t *rd_kafka_topic_conf_dup(const rd_kafka_topic_conf_t *conf);\nrd_kafka_topic_conf_t *rd_kafka_default_topic_conf_dup(rd_kafka_t *rk);\nvoid rd_kafka_topic_conf_destroy(rd_kafka_topic_conf_t *topic_conf);\nrd_kafka_conf_res_t rd_kafka_topic_conf_set(rd_kafka_topic_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);\nvoid rd_kafka_topic_conf_set_opaque(rd_kafka_topic_conf_t *conf, void *opaque);\nvoid rd_kafka_topic_conf_set_partitioner_cb(rd_kafka_topic_conf_t *topic_conf, int32_t (*partitioner)(const rd_kafka_topic_t *rkt, const void *keydata, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque));\nvoid rd_kafka_topic_conf_set_msg_order_cmp(rd_kafka_topic_conf_t *topic_conf, int (*msg_order_cmp)(const rd_kafka_message_t *a, const rd_kafka_message_t *b));\nint rd_kafka_topic_partition_available(const rd_kafka_topic_t *rkt, int32_t partition);\nint32_t rd_kafka_msg_partitioner_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_consistent(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_consistent_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_murmur2(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_murmur2_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nrd_kafka_t *rd_kafka_new(rd_kafka_type_t type, rd_kafka_conf_t *conf, char *errstr, size_t errstr_size);\nvoid rd_kafka_destroy(rd_kafka_t *rk);\nvoid rd_kafka_destroy_flags(rd_kafka_t *rk, int flags);\nconst char *rd_kafka_name(const rd_kafka_t *rk);\nrd_kafka_type_t rd_kafka_type(const rd_kafka_t *rk);\nchar *rd_kafka_memberid(const rd_kafka_t *rk);\nchar *rd_kafka_clusterid(rd_kafka_t *rk, int timeout_ms);\nint32_t rd_kafka_controllerid(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_topic_t *rd_kafka_topic_new(rd_kafka_t *rk, const char *topic, rd_kafka_topic_conf_t *conf);\nvoid rd_kafka_topic_destroy(rd_kafka_topic_t *rkt);\nconst char *rd_kafka_topic_name(const rd_kafka_topic_t *rkt);\nvoid *rd_kafka_topic_opaque(const rd_kafka_topic_t *rkt);\nint rd_kafka_poll(rd_kafka_t *rk, int timeout_ms);\nvoid rd_kafka_yield(rd_kafka_t *rk);\nrd_kafka_resp_err_t rd_kafka_pause_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_resp_err_t rd_kafka_resume_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_resp_err_t rd_kafka_query_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high, int timeout_ms);\nrd_kafka_resp_err_t rd_kafka_get_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high);\nrd_kafka_resp_err_t rd_kafka_offsets_for_times(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets, int timeout_ms);\nvoid rd_kafka_mem_free(rd_kafka_t *rk, void *ptr);\nrd_kafka_queue_t *rd_kafka_queue_new(rd_kafka_t *rk);\nvoid rd_kafka_queue_destroy(rd_kafka_queue_t *rkqu);\nrd_kafka_queue_t *rd_kafka_queue_get_main(rd_kafka_t *rk);\nrd_kafka_queue_t *rd_kafka_queue_get_consumer(rd_kafka_t *rk);\nrd_kafka_queue_t *rd_kafka_queue_get_partition(rd_kafka_t *rk, const char *topic, int32_t partition);\nrd_kafka_queue_t *rd_kafka_queue_get_background(rd_kafka_t *rk);\nvoid rd_kafka_queue_forward(rd_kafka_queue_t *src, rd_kafka_queue_t *dst);\nrd_kafka_resp_err_t rd_kafka_set_log_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu);\nsize_t rd_kafka_queue_length(rd_kafka_queue_t *rkqu);\nvoid rd_kafka_queue_io_event_enable(rd_kafka_queue_t *rkqu, int fd, const void *payload, size_t size);\nvoid rd_kafka_queue_cb_event_enable(rd_kafka_queue_t *rkqu, void (*event_cb)(rd_kafka_t *rk, void *opaque), void *opaque);\nint rd_kafka_consume_start(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);\nint rd_kafka_consume_start_queue(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, rd_kafka_queue_t *rkqu);\nint rd_kafka_consume_stop(rd_kafka_topic_t *rkt, int32_t partition);\nrd_kafka_resp_err_t rd_kafka_seek(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, int timeout_ms);\nrd_kafka_message_t *rd_kafka_consume(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms);\nssize_t rd_kafka_consume_batch(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);\nint rd_kafka_consume_callback(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *opaque), void *opaque);\nrd_kafka_message_t *rd_kafka_consume_queue(rd_kafka_queue_t *rkqu, int timeout_ms);\nssize_t rd_kafka_consume_batch_queue(rd_kafka_queue_t *rkqu, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);\nint rd_kafka_consume_callback_queue(rd_kafka_queue_t *rkqu, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *opaque), void *opaque);\nrd_kafka_resp_err_t rd_kafka_offset_store(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);\nrd_kafka_resp_err_t rd_kafka_offsets_store(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets);\nrd_kafka_resp_err_t rd_kafka_subscribe(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *topics);\nrd_kafka_resp_err_t rd_kafka_unsubscribe(rd_kafka_t *rk);\nrd_kafka_resp_err_t rd_kafka_subscription(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **topics);\nrd_kafka_message_t *rd_kafka_consumer_poll(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_resp_err_t rd_kafka_consumer_close(rd_kafka_t *rk);\nrd_kafka_resp_err_t rd_kafka_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_resp_err_t rd_kafka_assignment(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **partitions);\nrd_kafka_resp_err_t rd_kafka_commit(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, int async);\nrd_kafka_resp_err_t rd_kafka_commit_message(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, int async);\nrd_kafka_resp_err_t rd_kafka_commit_queue(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_queue_t *rkqu, void (*cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *opaque), void *opaque);\nrd_kafka_resp_err_t rd_kafka_committed(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms);\nrd_kafka_resp_err_t rd_kafka_position(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);\nint rd_kafka_produce(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, void *payload, size_t len, const void *key, size_t keylen, void *msg_opaque);\nrd_kafka_resp_err_t rd_kafka_producev(rd_kafka_t *rk, ...);\nint rd_kafka_produce_batch(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, rd_kafka_message_t *rkmessages, int message_cnt);\nrd_kafka_resp_err_t rd_kafka_flush(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_resp_err_t rd_kafka_purge(rd_kafka_t *rk, int purge_flags);\ntypedef struct rd_kafka_metadata_broker {\n  int32_t id;\n  char *host;\n  int port;\n} rd_kafka_metadata_broker_t;\ntypedef struct rd_kafka_metadata_partition {\n  int32_t id;\n  rd_kafka_resp_err_t err;\n  int32_t leader;\n  int replica_cnt;\n  int32_t *replicas;\n  int isr_cnt;\n  int32_t *isrs;\n} rd_kafka_metadata_partition_t;\ntypedef struct rd_kafka_metadata_topic {\n  char *topic;\n  int partition_cnt;\n  struct rd_kafka_metadata_partition *partitions;\n  rd_kafka_resp_err_t err;\n} rd_kafka_metadata_topic_t;\ntypedef struct rd_kafka_metadata {\n  int broker_cnt;\n  struct rd_kafka_metadata_broker *brokers;\n  int topic_cnt;\n  struct rd_kafka_metadata_topic *topics;\n  int32_t orig_broker_id;\n  char *orig_broker_name;\n} rd_kafka_metadata_t;\nrd_kafka_resp_err_t rd_kafka_metadata(rd_kafka_t *rk, int all_topics, rd_kafka_topic_t *only_rkt, const struct rd_kafka_metadata **metadatap, int timeout_ms);\nvoid rd_kafka_metadata_destroy(const struct rd_kafka_metadata *metadata);\nstruct rd_kafka_group_member_info {\n  char *member_id;\n  char *client_id;\n  char *client_host;\n  void *member_metadata;\n  int member_metadata_size;\n  void *member_assignment;\n  int member_assignment_size;\n};\nstruct rd_kafka_group_info {\n  struct rd_kafka_metadata_broker broker;\n  char *group;\n  rd_kafka_resp_err_t err;\n  char *state;\n  char *protocol_type;\n  char *protocol;\n  struct rd_kafka_group_member_info *members;\n  int member_cnt;\n};\nstruct rd_kafka_group_list {\n  struct rd_kafka_group_info *groups;\n  int group_cnt;\n};\nrd_kafka_resp_err_t rd_kafka_list_groups(rd_kafka_t *rk, const char *group, const struct rd_kafka_group_list **grplistp, int timeout_ms);\nvoid rd_kafka_group_list_destroy(const struct rd_kafka_group_list *grplist);\nint rd_kafka_brokers_add(rd_kafka_t *rk, const char *brokerlist);\nvoid rd_kafka_set_logger(rd_kafka_t *rk, void (*func)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));\nvoid rd_kafka_set_log_level(rd_kafka_t *rk, int level);\nvoid rd_kafka_log_print(const rd_kafka_t *rk, int level, const char *fac, const char *buf);\nvoid rd_kafka_log_syslog(const rd_kafka_t *rk, int level, const char *fac, const char *buf);\nint rd_kafka_outq_len(rd_kafka_t *rk);\nvoid rd_kafka_dump(FILE *fp, rd_kafka_t *rk);\nint rd_kafka_thread_cnt(void);\nint rd_kafka_wait_destroyed(int timeout_ms);\nint rd_kafka_unittest(void);\nrd_kafka_resp_err_t rd_kafka_poll_set_consumer(rd_kafka_t *rk);\ntypedef int rd_kafka_event_type_t;\nrd_kafka_event_type_t rd_kafka_event_type(const rd_kafka_event_t *rkev);\nconst char *rd_kafka_event_name(const rd_kafka_event_t *rkev);\nvoid rd_kafka_event_destroy(rd_kafka_event_t *rkev);\nconst rd_kafka_message_t *rd_kafka_event_message_next(rd_kafka_event_t *rkev);\nsize_t rd_kafka_event_message_array(rd_kafka_event_t *rkev, const rd_kafka_message_t **rkmessages, size_t size);\nsize_t rd_kafka_event_message_count(rd_kafka_event_t *rkev);\nconst char *rd_kafka_event_config_string(rd_kafka_event_t *rkev);\nrd_kafka_resp_err_t rd_kafka_event_error(rd_kafka_event_t *rkev);\nconst char *rd_kafka_event_error_string(rd_kafka_event_t *rkev);\nint rd_kafka_event_error_is_fatal(rd_kafka_event_t *rkev);\nvoid *rd_kafka_event_opaque(rd_kafka_event_t *rkev);\nint rd_kafka_event_log(rd_kafka_event_t *rkev, const char **fac, const char **str, int *level);\nconst char *rd_kafka_event_stats(rd_kafka_event_t *rkev);\nrd_kafka_topic_partition_list_t *rd_kafka_event_topic_partition_list(rd_kafka_event_t *rkev);\nrd_kafka_topic_partition_t *rd_kafka_event_topic_partition(rd_kafka_event_t *rkev);\ntypedef rd_kafka_event_t rd_kafka_CreateTopics_result_t;\ntypedef rd_kafka_event_t rd_kafka_DeleteTopics_result_t;\ntypedef rd_kafka_event_t rd_kafka_CreatePartitions_result_t;\ntypedef rd_kafka_event_t rd_kafka_AlterConfigs_result_t;\ntypedef rd_kafka_event_t rd_kafka_DescribeConfigs_result_t;\nconst rd_kafka_CreateTopics_result_t *rd_kafka_event_CreateTopics_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DeleteTopics_result_t *rd_kafka_event_DeleteTopics_result(rd_kafka_event_t *rkev);\nconst rd_kafka_CreatePartitions_result_t *rd_kafka_event_CreatePartitions_result(rd_kafka_event_t *rkev);\nconst rd_kafka_AlterConfigs_result_t *rd_kafka_event_AlterConfigs_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DescribeConfigs_result_t *rd_kafka_event_DescribeConfigs_result(rd_kafka_event_t *rkev);\nrd_kafka_event_t *rd_kafka_queue_poll(rd_kafka_queue_t *rkqu, int timeout_ms);\nint rd_kafka_queue_poll_callback(rd_kafka_queue_t *rkqu, int timeout_ms);\ntypedef rd_kafka_resp_err_t (rd_kafka_plugin_f_conf_init_t)(rd_kafka_conf_t *conf, void **plug_opaquep, char *errstr, size_t errstr_size);\ntypedef rd_kafka_conf_res_t (rd_kafka_interceptor_f_on_conf_set_t)(rd_kafka_conf_t *conf, const char *name, const char *val, char *errstr, size_t errstr_size, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_dup_t)(rd_kafka_conf_t *new_conf, const rd_kafka_conf_t *old_conf, size_t filter_cnt, const char **filter, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_destroy_t)(void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_new_t)(rd_kafka_t *rk, const rd_kafka_conf_t *conf, void *ic_opaque, char *errstr, size_t errstr_size);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_destroy_t)(rd_kafka_t *rk, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_send_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_acknowledgement_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_consume_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_commit_t)(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_resp_err_t err, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_request_sent_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_set(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_set_t *on_conf_set, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_dup(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_dup_t *on_conf_dup, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_destroy(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_destroy_t *on_conf_destroy, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_new(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_new_t *on_new, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_destroy(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_destroy_t *on_destroy, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_send(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_send_t *on_send, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_acknowledgement(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_acknowledgement_t *on_acknowledgement, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_consume(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_consume_t *on_consume, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_commit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_commit_t *on_commit, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_request_sent(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_request_sent_t *on_request_sent, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_topic_result_error(const rd_kafka_topic_result_t *topicres);\nconst char *rd_kafka_topic_result_error_string(const rd_kafka_topic_result_t *topicres);\nconst char *rd_kafka_topic_result_name(const rd_kafka_topic_result_t *topicres);\ntypedef enum rd_kafka_admin_op_t {\n  RD_KAFKA_ADMIN_OP_ANY = 0,\n  RD_KAFKA_ADMIN_OP_CREATETOPICS,\n  RD_KAFKA_ADMIN_OP_DELETETOPICS,\n  RD_KAFKA_ADMIN_OP_CREATEPARTITIONS,\n  RD_KAFKA_ADMIN_OP_ALTERCONFIGS,\n  RD_KAFKA_ADMIN_OP_DESCRIBECONFIGS,\n  RD_KAFKA_ADMIN_OP__CNT,\n} rd_kafka_admin_op_t;\ntypedef struct rd_kafka_AdminOptions_s rd_kafka_AdminOptions_t;\nrd_kafka_AdminOptions_t *rd_kafka_AdminOptions_new(rd_kafka_t *rk, rd_kafka_admin_op_t for_api);\nvoid rd_kafka_AdminOptions_destroy(rd_kafka_AdminOptions_t *options);\nrd_kafka_resp_err_t rd_kafka_AdminOptions_set_request_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_AdminOptions_set_operation_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_AdminOptions_set_validate_only(rd_kafka_AdminOptions_t *options, int true_or_false, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_AdminOptions_set_broker(rd_kafka_AdminOptions_t *options, int32_t broker_id, char *errstr, size_t errstr_size);\nvoid rd_kafka_AdminOptions_set_opaque(rd_kafka_AdminOptions_t *options, void *opaque);\ntypedef struct rd_kafka_NewTopic_s rd_kafka_NewTopic_t;\nrd_kafka_NewTopic_t *rd_kafka_NewTopic_new(const char *topic, int num_partitions, int replication_factor, char *errstr, size_t errstr_size);\nvoid rd_kafka_NewTopic_destroy(rd_kafka_NewTopic_t *new_topic);\nvoid rd_kafka_NewTopic_destroy_array(rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt);\nrd_kafka_resp_err_t rd_kafka_NewTopic_set_replica_assignment(rd_kafka_NewTopic_t *new_topic, int32_t partition, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_NewTopic_set_config(rd_kafka_NewTopic_t *new_topic, const char *name, const char *value);\nvoid rd_kafka_CreateTopics(rd_kafka_t *rk, rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_topic_result_t **rd_kafka_CreateTopics_result_topics(const rd_kafka_CreateTopics_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_DeleteTopic_s rd_kafka_DeleteTopic_t;\nrd_kafka_DeleteTopic_t *rd_kafka_DeleteTopic_new(const char *topic);\nvoid rd_kafka_DeleteTopic_destroy(rd_kafka_DeleteTopic_t *del_topic);\nvoid rd_kafka_DeleteTopic_destroy_array(rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt);\nvoid rd_kafka_DeleteTopics(rd_kafka_t *rk, rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_topic_result_t **rd_kafka_DeleteTopics_result_topics(const rd_kafka_DeleteTopics_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_NewPartitions_s rd_kafka_NewPartitions_t;\nrd_kafka_NewPartitions_t *rd_kafka_NewPartitions_new(const char *topic, size_t new_total_cnt, char *errstr, size_t errstr_size);\nvoid rd_kafka_NewPartitions_destroy(rd_kafka_NewPartitions_t *new_parts);\nvoid rd_kafka_NewPartitions_destroy_array(rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt);\nrd_kafka_resp_err_t rd_kafka_NewPartitions_set_replica_assignment(rd_kafka_NewPartitions_t *new_parts, int32_t new_partition_idx, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);\nvoid rd_kafka_CreatePartitions(rd_kafka_t *rk, rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_topic_result_t **rd_kafka_CreatePartitions_result_topics(const rd_kafka_CreatePartitions_result_t *result, size_t *cntp);\ntypedef enum rd_kafka_ConfigSource_t {\n  RD_KAFKA_CONFIG_SOURCE_UNKNOWN_CONFIG = 0,\n  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_TOPIC_CONFIG = 1,\n  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_BROKER_CONFIG = 2,\n  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_DEFAULT_BROKER_CONFIG = 3,\n  RD_KAFKA_CONFIG_SOURCE_STATIC_BROKER_CONFIG = 4,\n  RD_KAFKA_CONFIG_SOURCE_DEFAULT_CONFIG = 5,\n  RD_KAFKA_CONFIG_SOURCE__CNT,\n} rd_kafka_ConfigSource_t;\nconst char *rd_kafka_ConfigSource_name(rd_kafka_ConfigSource_t confsource);\ntypedef struct rd_kafka_ConfigEntry_s rd_kafka_ConfigEntry_t;\nconst char *rd_kafka_ConfigEntry_name(const rd_kafka_ConfigEntry_t *entry);\nconst char *rd_kafka_ConfigEntry_value(const rd_kafka_ConfigEntry_t *entry);\nrd_kafka_ConfigSource_t rd_kafka_ConfigEntry_source(const rd_kafka_ConfigEntry_t *entry);\nint rd_kafka_ConfigEntry_is_read_only(const rd_kafka_ConfigEntry_t *entry);\nint rd_kafka_ConfigEntry_is_default(const rd_kafka_ConfigEntry_t *entry);\nint rd_kafka_ConfigEntry_is_sensitive(const rd_kafka_ConfigEntry_t *entry);\nint rd_kafka_ConfigEntry_is_synonym(const rd_kafka_ConfigEntry_t *entry);\nconst rd_kafka_ConfigEntry_t **rd_kafka_ConfigEntry_synonyms(const rd_kafka_ConfigEntry_t *entry, size_t *cntp);\ntypedef enum rd_kafka_ResourceType_t {\n  RD_KAFKA_RESOURCE_UNKNOWN = 0,\n  RD_KAFKA_RESOURCE_ANY = 1,\n  RD_KAFKA_RESOURCE_TOPIC = 2,\n  RD_KAFKA_RESOURCE_GROUP = 3,\n  RD_KAFKA_RESOURCE_BROKER = 4,\n  RD_KAFKA_RESOURCE__CNT,\n} rd_kafka_ResourceType_t;\nconst char *rd_kafka_ResourceType_name(rd_kafka_ResourceType_t restype);\ntypedef struct rd_kafka_ConfigResource_s rd_kafka_ConfigResource_t;\nrd_kafka_ConfigResource_t *rd_kafka_ConfigResource_new(rd_kafka_ResourceType_t restype, const char *resname);\nvoid rd_kafka_ConfigResource_destroy(rd_kafka_ConfigResource_t *config);\nvoid rd_kafka_ConfigResource_destroy_array(rd_kafka_ConfigResource_t **config, size_t config_cnt);\nrd_kafka_resp_err_t rd_kafka_ConfigResource_set_config(rd_kafka_ConfigResource_t *config, const char *name, const char *value);\nconst rd_kafka_ConfigEntry_t **rd_kafka_ConfigResource_configs(const rd_kafka_ConfigResource_t *config, size_t *cntp);\nrd_kafka_ResourceType_t rd_kafka_ConfigResource_type(const rd_kafka_ConfigResource_t *config);\nconst char *rd_kafka_ConfigResource_name(const rd_kafka_ConfigResource_t *config);\nrd_kafka_resp_err_t rd_kafka_ConfigResource_error(const rd_kafka_ConfigResource_t *config);\nconst char *rd_kafka_ConfigResource_error_string(const rd_kafka_ConfigResource_t *config);\nvoid rd_kafka_AlterConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_ConfigResource_t **rd_kafka_AlterConfigs_result_resources(const rd_kafka_AlterConfigs_result_t *result, size_t *cntp);\nvoid rd_kafka_DescribeConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_ConfigResource_t **rd_kafka_DescribeConfigs_result_resources(const rd_kafka_DescribeConfigs_result_t *result, size_t *cntp);\nrd_kafka_resp_err_t rd_kafka_oauthbearer_set_token(rd_kafka_t *rk, const char *token_value, int64_t md_lifetime_ms, const char *md_principal_name, const char **extensions, size_t extension_size, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_oauthbearer_set_token_failure(rd_kafka_t *rk, const char *errstr);\n'\n</code></pre> rdkafka.h, rdkafka_mock.h</p>"},{"location":"api/constants/#rd_kafka_version_3","title":"RD_KAFKA_VERSION","text":"<pre><code>public RD_KAFKA_VERSION = 16908543\n</code></pre> <p>librdkafka version </p> <p>Interpreted as hex <code>MM.mm.rr.xx</code>:</p> <ul> <li>MM = Major</li> <li>mm = minor</li> <li>rr = revision</li> <li>xx = pre-release id (0xff is the final release)</li> </ul> <p>E.g.: <code>0x000801ff</code> = 0.8.1</p> RemarksThis value should only be used during compile time, for runtime checks of version use rd_kafka_version()  <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_unsupported_compression_type_3","title":"RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE","text":"<pre><code>public RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76\n</code></pre> <p>Unsupported compression type </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_end_all_3","title":"RD_KAFKA_RESP_ERR_END_ALL","text":"<p><pre><code>public RD_KAFKA_RESP_ERR_END_ALL = 82\n</code></pre> enum rd_kafka_resp_err_t</p>"},{"location":"api/constants/#rd_kafka_admin_op__cnt_3","title":"RD_KAFKA_ADMIN_OP__CNT","text":"<pre><code>public RD_KAFKA_ADMIN_OP__CNT = 6\n</code></pre> <p>Number of ops defined </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe </li> </ul>"},{"location":"api/constants/#rd_kafka_resource__cnt_3","title":"RD_KAFKA_RESOURCE__CNT","text":"<pre><code>public RD_KAFKA_RESOURCE__CNT = 5\n</code></pre> <p>Number of resource types defined </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#acca83a66d7783ff7683ed2691cc907c9 </li> </ul>"},{"location":"api/constants/#rd_kafka_cdef_3","title":"RD_KAFKA_CDEF","text":"<p><pre><code>public RD_KAFKA_CDEF = 'typedef long int ssize_t;\ntypedef struct _IO_FILE FILE;\ntypedef long int mode_t;\ntypedef signed int int16_t;\ntypedef unsigned int uint16_t;\ntypedef signed int int32_t;\ntypedef signed long int int64_t;\nint rd_kafka_version(void);\nconst char *rd_kafka_version_str(void);\ntypedef enum rd_kafka_type_t {\n  RD_KAFKA_PRODUCER,\n  RD_KAFKA_CONSUMER,\n} rd_kafka_type_t;\ntypedef enum rd_kafka_timestamp_type_t {\n  RD_KAFKA_TIMESTAMP_NOT_AVAILABLE,\n  RD_KAFKA_TIMESTAMP_CREATE_TIME,\n  RD_KAFKA_TIMESTAMP_LOG_APPEND_TIME,\n} rd_kafka_timestamp_type_t;\nconst char *rd_kafka_get_debug_contexts(void);\ntypedef struct rd_kafka_s rd_kafka_t;\ntypedef struct rd_kafka_topic_s rd_kafka_topic_t;\ntypedef struct rd_kafka_conf_s rd_kafka_conf_t;\ntypedef struct rd_kafka_topic_conf_s rd_kafka_topic_conf_t;\ntypedef struct rd_kafka_queue_s rd_kafka_queue_t;\ntypedef struct rd_kafka_op_s rd_kafka_event_t;\ntypedef struct rd_kafka_topic_result_s rd_kafka_topic_result_t;\ntypedef enum {\n  RD_KAFKA_RESP_ERR__BEGIN = (- 200),\n  RD_KAFKA_RESP_ERR__BAD_MSG = (- 199),\n  RD_KAFKA_RESP_ERR__BAD_COMPRESSION = (- 198),\n  RD_KAFKA_RESP_ERR__DESTROY = (- 197),\n  RD_KAFKA_RESP_ERR__FAIL = (- 196),\n  RD_KAFKA_RESP_ERR__TRANSPORT = (- 195),\n  RD_KAFKA_RESP_ERR__CRIT_SYS_RESOURCE = (- 194),\n  RD_KAFKA_RESP_ERR__RESOLVE = (- 193),\n  RD_KAFKA_RESP_ERR__MSG_TIMED_OUT = (- 192),\n  RD_KAFKA_RESP_ERR__PARTITION_EOF = (- 191),\n  RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION = (- 190),\n  RD_KAFKA_RESP_ERR__FS = (- 189),\n  RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC = (- 188),\n  RD_KAFKA_RESP_ERR__ALL_BROKERS_DOWN = (- 187),\n  RD_KAFKA_RESP_ERR__INVALID_ARG = (- 186),\n  RD_KAFKA_RESP_ERR__TIMED_OUT = (- 185),\n  RD_KAFKA_RESP_ERR__QUEUE_FULL = (- 184),\n  RD_KAFKA_RESP_ERR__ISR_INSUFF = (- 183),\n  RD_KAFKA_RESP_ERR__NODE_UPDATE = (- 182),\n  RD_KAFKA_RESP_ERR__SSL = (- 181),\n  RD_KAFKA_RESP_ERR__WAIT_COORD = (- 180),\n  RD_KAFKA_RESP_ERR__UNKNOWN_GROUP = (- 179),\n  RD_KAFKA_RESP_ERR__IN_PROGRESS = (- 178),\n  RD_KAFKA_RESP_ERR__PREV_IN_PROGRESS = (- 177),\n  RD_KAFKA_RESP_ERR__EXISTING_SUBSCRIPTION = (- 176),\n  RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS = (- 175),\n  RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS = (- 174),\n  RD_KAFKA_RESP_ERR__CONFLICT = (- 173),\n  RD_KAFKA_RESP_ERR__STATE = (- 172),\n  RD_KAFKA_RESP_ERR__UNKNOWN_PROTOCOL = (- 171),\n  RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED = (- 170),\n  RD_KAFKA_RESP_ERR__AUTHENTICATION = (- 169),\n  RD_KAFKA_RESP_ERR__NO_OFFSET = (- 168),\n  RD_KAFKA_RESP_ERR__OUTDATED = (- 167),\n  RD_KAFKA_RESP_ERR__TIMED_OUT_QUEUE = (- 166),\n  RD_KAFKA_RESP_ERR__UNSUPPORTED_FEATURE = (- 165),\n  RD_KAFKA_RESP_ERR__WAIT_CACHE = (- 164),\n  RD_KAFKA_RESP_ERR__INTR = (- 163),\n  RD_KAFKA_RESP_ERR__KEY_SERIALIZATION = (- 162),\n  RD_KAFKA_RESP_ERR__VALUE_SERIALIZATION = (- 161),\n  RD_KAFKA_RESP_ERR__KEY_DESERIALIZATION = (- 160),\n  RD_KAFKA_RESP_ERR__VALUE_DESERIALIZATION = (- 159),\n  RD_KAFKA_RESP_ERR__PARTIAL = (- 158),\n  RD_KAFKA_RESP_ERR__READ_ONLY = (- 157),\n  RD_KAFKA_RESP_ERR__NOENT = (- 156),\n  RD_KAFKA_RESP_ERR__UNDERFLOW = (- 155),\n  RD_KAFKA_RESP_ERR__INVALID_TYPE = (- 154),\n  RD_KAFKA_RESP_ERR__RETRY = (- 153),\n  RD_KAFKA_RESP_ERR__PURGE_QUEUE = (- 152),\n  RD_KAFKA_RESP_ERR__PURGE_INFLIGHT = (- 151),\n  RD_KAFKA_RESP_ERR__FATAL = (- 150),\n  RD_KAFKA_RESP_ERR__INCONSISTENT = (- 149),\n  RD_KAFKA_RESP_ERR__GAPLESS_GUARANTEE = (- 148),\n  RD_KAFKA_RESP_ERR__MAX_POLL_EXCEEDED = (- 147),\n  RD_KAFKA_RESP_ERR__END = (- 100),\n  RD_KAFKA_RESP_ERR_UNKNOWN = (- 1),\n  RD_KAFKA_RESP_ERR_NO_ERROR = 0,\n  RD_KAFKA_RESP_ERR_OFFSET_OUT_OF_RANGE = 1,\n  RD_KAFKA_RESP_ERR_INVALID_MSG = 2,\n  RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART = 3,\n  RD_KAFKA_RESP_ERR_INVALID_MSG_SIZE = 4,\n  RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE = 5,\n  RD_KAFKA_RESP_ERR_NOT_LEADER_FOR_PARTITION = 6,\n  RD_KAFKA_RESP_ERR_REQUEST_TIMED_OUT = 7,\n  RD_KAFKA_RESP_ERR_BROKER_NOT_AVAILABLE = 8,\n  RD_KAFKA_RESP_ERR_REPLICA_NOT_AVAILABLE = 9,\n  RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE = 10,\n  RD_KAFKA_RESP_ERR_STALE_CTRL_EPOCH = 11,\n  RD_KAFKA_RESP_ERR_OFFSET_METADATA_TOO_LARGE = 12,\n  RD_KAFKA_RESP_ERR_NETWORK_EXCEPTION = 13,\n  RD_KAFKA_RESP_ERR_GROUP_LOAD_IN_PROGRESS = 14,\n  RD_KAFKA_RESP_ERR_GROUP_COORDINATOR_NOT_AVAILABLE = 15,\n  RD_KAFKA_RESP_ERR_NOT_COORDINATOR_FOR_GROUP = 16,\n  RD_KAFKA_RESP_ERR_TOPIC_EXCEPTION = 17,\n  RD_KAFKA_RESP_ERR_RECORD_LIST_TOO_LARGE = 18,\n  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS = 19,\n  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS_AFTER_APPEND = 20,\n  RD_KAFKA_RESP_ERR_INVALID_REQUIRED_ACKS = 21,\n  RD_KAFKA_RESP_ERR_ILLEGAL_GENERATION = 22,\n  RD_KAFKA_RESP_ERR_INCONSISTENT_GROUP_PROTOCOL = 23,\n  RD_KAFKA_RESP_ERR_INVALID_GROUP_ID = 24,\n  RD_KAFKA_RESP_ERR_UNKNOWN_MEMBER_ID = 25,\n  RD_KAFKA_RESP_ERR_INVALID_SESSION_TIMEOUT = 26,\n  RD_KAFKA_RESP_ERR_REBALANCE_IN_PROGRESS = 27,\n  RD_KAFKA_RESP_ERR_INVALID_COMMIT_OFFSET_SIZE = 28,\n  RD_KAFKA_RESP_ERR_TOPIC_AUTHORIZATION_FAILED = 29,\n  RD_KAFKA_RESP_ERR_GROUP_AUTHORIZATION_FAILED = 30,\n  RD_KAFKA_RESP_ERR_CLUSTER_AUTHORIZATION_FAILED = 31,\n  RD_KAFKA_RESP_ERR_INVALID_TIMESTAMP = 32,\n  RD_KAFKA_RESP_ERR_UNSUPPORTED_SASL_MECHANISM = 33,\n  RD_KAFKA_RESP_ERR_ILLEGAL_SASL_STATE = 34,\n  RD_KAFKA_RESP_ERR_UNSUPPORTED_VERSION = 35,\n  RD_KAFKA_RESP_ERR_TOPIC_ALREADY_EXISTS = 36,\n  RD_KAFKA_RESP_ERR_INVALID_PARTITIONS = 37,\n  RD_KAFKA_RESP_ERR_INVALID_REPLICATION_FACTOR = 38,\n  RD_KAFKA_RESP_ERR_INVALID_REPLICA_ASSIGNMENT = 39,\n  RD_KAFKA_RESP_ERR_INVALID_CONFIG = 40,\n  RD_KAFKA_RESP_ERR_NOT_CONTROLLER = 41,\n  RD_KAFKA_RESP_ERR_INVALID_REQUEST = 42,\n  RD_KAFKA_RESP_ERR_UNSUPPORTED_FOR_MESSAGE_FORMAT = 43,\n  RD_KAFKA_RESP_ERR_POLICY_VIOLATION = 44,\n  RD_KAFKA_RESP_ERR_OUT_OF_ORDER_SEQUENCE_NUMBER = 45,\n  RD_KAFKA_RESP_ERR_DUPLICATE_SEQUENCE_NUMBER = 46,\n  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_EPOCH = 47,\n  RD_KAFKA_RESP_ERR_INVALID_TXN_STATE = 48,\n  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_ID_MAPPING = 49,\n  RD_KAFKA_RESP_ERR_INVALID_TRANSACTION_TIMEOUT = 50,\n  RD_KAFKA_RESP_ERR_CONCURRENT_TRANSACTIONS = 51,\n  RD_KAFKA_RESP_ERR_TRANSACTION_COORDINATOR_FENCED = 52,\n  RD_KAFKA_RESP_ERR_TRANSACTIONAL_ID_AUTHORIZATION_FAILED = 53,\n  RD_KAFKA_RESP_ERR_SECURITY_DISABLED = 54,\n  RD_KAFKA_RESP_ERR_OPERATION_NOT_ATTEMPTED = 55,\n  RD_KAFKA_RESP_ERR_KAFKA_STORAGE_ERROR = 56,\n  RD_KAFKA_RESP_ERR_LOG_DIR_NOT_FOUND = 57,\n  RD_KAFKA_RESP_ERR_SASL_AUTHENTICATION_FAILED = 58,\n  RD_KAFKA_RESP_ERR_UNKNOWN_PRODUCER_ID = 59,\n  RD_KAFKA_RESP_ERR_REASSIGNMENT_IN_PROGRESS = 60,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTH_DISABLED = 61,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_NOT_FOUND = 62,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_OWNER_MISMATCH = 63,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_REQUEST_NOT_ALLOWED = 64,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTHORIZATION_FAILED = 65,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_EXPIRED = 66,\n  RD_KAFKA_RESP_ERR_INVALID_PRINCIPAL_TYPE = 67,\n  RD_KAFKA_RESP_ERR_NON_EMPTY_GROUP = 68,\n  RD_KAFKA_RESP_ERR_GROUP_ID_NOT_FOUND = 69,\n  RD_KAFKA_RESP_ERR_FETCH_SESSION_ID_NOT_FOUND = 70,\n  RD_KAFKA_RESP_ERR_INVALID_FETCH_SESSION_EPOCH = 71,\n  RD_KAFKA_RESP_ERR_LISTENER_NOT_FOUND = 72,\n  RD_KAFKA_RESP_ERR_TOPIC_DELETION_DISABLED = 73,\n  RD_KAFKA_RESP_ERR_FENCED_LEADER_EPOCH = 74,\n  RD_KAFKA_RESP_ERR_UNKNOWN_LEADER_EPOCH = 75,\n  RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76,\n  RD_KAFKA_RESP_ERR_STALE_BROKER_EPOCH = 77,\n  RD_KAFKA_RESP_ERR_OFFSET_NOT_AVAILABLE = 78,\n  RD_KAFKA_RESP_ERR_MEMBER_ID_REQUIRED = 79,\n  RD_KAFKA_RESP_ERR_PREFERRED_LEADER_NOT_AVAILABLE = 80,\n  RD_KAFKA_RESP_ERR_GROUP_MAX_SIZE_REACHED = 81,\n  RD_KAFKA_RESP_ERR_END_ALL,\n} rd_kafka_resp_err_t;\nstruct rd_kafka_err_desc {\n  rd_kafka_resp_err_t code;\n  char *name;\n  char *desc;\n};\nvoid rd_kafka_get_err_descs(const struct rd_kafka_err_desc **errdescs, size_t *cntp);\nconst char *rd_kafka_err2str(rd_kafka_resp_err_t err);\nconst char *rd_kafka_err2name(rd_kafka_resp_err_t err);\nrd_kafka_resp_err_t rd_kafka_last_error(void);\nrd_kafka_resp_err_t rd_kafka_errno2err(int errnox);\nint rd_kafka_errno(void);\nrd_kafka_resp_err_t rd_kafka_fatal_error(rd_kafka_t *rk, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_test_fatal_error(rd_kafka_t *rk, rd_kafka_resp_err_t err, const char *reason);\ntypedef struct rd_kafka_topic_partition_s {\n  char *topic;\n  int32_t partition;\n  int64_t offset;\n  void *metadata;\n  size_t metadata_size;\n  void *opaque;\n  rd_kafka_resp_err_t err;\n  void *_private;\n} rd_kafka_topic_partition_t;\nvoid rd_kafka_topic_partition_destroy(rd_kafka_topic_partition_t *rktpar);\ntypedef struct rd_kafka_topic_partition_list_s {\n  int cnt;\n  int size;\n  rd_kafka_topic_partition_t *elems;\n} rd_kafka_topic_partition_list_t;\nrd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_new(int size);\nvoid rd_kafka_topic_partition_list_destroy(rd_kafka_topic_partition_list_t *rkparlist);\nrd_kafka_topic_partition_t *rd_kafka_topic_partition_list_add(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);\nvoid rd_kafka_topic_partition_list_add_range(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t start, int32_t stop);\nint rd_kafka_topic_partition_list_del(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);\nint rd_kafka_topic_partition_list_del_by_idx(rd_kafka_topic_partition_list_t *rktparlist, int idx);\nrd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_copy(const rd_kafka_topic_partition_list_t *src);\nrd_kafka_resp_err_t rd_kafka_topic_partition_list_set_offset(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition, int64_t offset);\nrd_kafka_topic_partition_t *rd_kafka_topic_partition_list_find(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);\nvoid rd_kafka_topic_partition_list_sort(rd_kafka_topic_partition_list_t *rktparlist, int (*cmp)(const void *a, const void *b, void *cmp_opaque), void *cmp_opaque);\ntypedef enum rd_kafka_vtype_t {\n  RD_KAFKA_VTYPE_END,\n  RD_KAFKA_VTYPE_TOPIC,\n  RD_KAFKA_VTYPE_RKT,\n  RD_KAFKA_VTYPE_PARTITION,\n  RD_KAFKA_VTYPE_VALUE,\n  RD_KAFKA_VTYPE_KEY,\n  RD_KAFKA_VTYPE_OPAQUE,\n  RD_KAFKA_VTYPE_MSGFLAGS,\n  RD_KAFKA_VTYPE_TIMESTAMP,\n  RD_KAFKA_VTYPE_HEADER,\n  RD_KAFKA_VTYPE_HEADERS,\n} rd_kafka_vtype_t;\ntypedef struct rd_kafka_headers_s rd_kafka_headers_t;\nrd_kafka_headers_t *rd_kafka_headers_new(size_t initial_count);\nvoid rd_kafka_headers_destroy(rd_kafka_headers_t *hdrs);\nrd_kafka_headers_t *rd_kafka_headers_copy(const rd_kafka_headers_t *src);\nrd_kafka_resp_err_t rd_kafka_header_add(rd_kafka_headers_t *hdrs, const char *name, ssize_t name_size, const void *value, ssize_t value_size);\nrd_kafka_resp_err_t rd_kafka_header_remove(rd_kafka_headers_t *hdrs, const char *name);\nrd_kafka_resp_err_t rd_kafka_header_get_last(const rd_kafka_headers_t *hdrs, const char *name, const void **valuep, size_t *sizep);\nrd_kafka_resp_err_t rd_kafka_header_get(const rd_kafka_headers_t *hdrs, size_t idx, const char *name, const void **valuep, size_t *sizep);\nrd_kafka_resp_err_t rd_kafka_header_get_all(const rd_kafka_headers_t *hdrs, size_t idx, const char **namep, const void **valuep, size_t *sizep);\ntypedef struct rd_kafka_message_s {\n  rd_kafka_resp_err_t err;\n  rd_kafka_topic_t *rkt;\n  int32_t partition;\n  void *payload;\n  size_t len;\n  void *key;\n  size_t key_len;\n  int64_t offset;\n  void *_private;\n} rd_kafka_message_t;\nvoid rd_kafka_message_destroy(rd_kafka_message_t *rkmessage);\nint64_t rd_kafka_message_timestamp(const rd_kafka_message_t *rkmessage, rd_kafka_timestamp_type_t *tstype);\nint64_t rd_kafka_message_latency(const rd_kafka_message_t *rkmessage);\nrd_kafka_resp_err_t rd_kafka_message_headers(const rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);\nrd_kafka_resp_err_t rd_kafka_message_detach_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);\nvoid rd_kafka_message_set_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t *hdrs);\nsize_t rd_kafka_header_cnt(const rd_kafka_headers_t *hdrs);\ntypedef enum {\n  RD_KAFKA_MSG_STATUS_NOT_PERSISTED = 0,\n  RD_KAFKA_MSG_STATUS_POSSIBLY_PERSISTED = 1,\n  RD_KAFKA_MSG_STATUS_PERSISTED = 2,\n} rd_kafka_msg_status_t;\nrd_kafka_msg_status_t rd_kafka_message_status(const rd_kafka_message_t *rkmessage);\ntypedef enum {\n  RD_KAFKA_CONF_UNKNOWN = (- 2),\n  RD_KAFKA_CONF_INVALID = (- 1),\n  RD_KAFKA_CONF_OK = 0,\n} rd_kafka_conf_res_t;\nrd_kafka_conf_t *rd_kafka_conf_new(void);\nvoid rd_kafka_conf_destroy(rd_kafka_conf_t *conf);\nrd_kafka_conf_t *rd_kafka_conf_dup(const rd_kafka_conf_t *conf);\nrd_kafka_conf_t *rd_kafka_conf_dup_filter(const rd_kafka_conf_t *conf, size_t filter_cnt, const char **filter);\nconst rd_kafka_conf_t *rd_kafka_conf(rd_kafka_t *rk);\nrd_kafka_conf_res_t rd_kafka_conf_set(rd_kafka_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);\nvoid rd_kafka_conf_set_events(rd_kafka_conf_t *conf, int events);\nvoid rd_kafka_conf_set_background_event_cb(rd_kafka_conf_t *conf, void (*event_cb)(rd_kafka_t *rk, rd_kafka_event_t *rkev, void *opaque));\nvoid rd_kafka_conf_set_dr_cb(rd_kafka_conf_t *conf, void (*dr_cb)(rd_kafka_t *rk, void *payload, size_t len, rd_kafka_resp_err_t err, void *opaque, void *msg_opaque));\nvoid rd_kafka_conf_set_dr_msg_cb(rd_kafka_conf_t *conf, void (*dr_msg_cb)(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, void *opaque));\nvoid rd_kafka_conf_set_consume_cb(rd_kafka_conf_t *conf, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *opaque));\nvoid rd_kafka_conf_set_rebalance_cb(rd_kafka_conf_t *conf, void (*rebalance_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *partitions, void *opaque));\nvoid rd_kafka_conf_set_offset_commit_cb(rd_kafka_conf_t *conf, void (*offset_commit_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *opaque));\nvoid rd_kafka_conf_set_error_cb(rd_kafka_conf_t *conf, void (*error_cb)(rd_kafka_t *rk, int err, const char *reason, void *opaque));\nvoid rd_kafka_conf_set_throttle_cb(rd_kafka_conf_t *conf, void (*throttle_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int throttle_time_ms, void *opaque));\nvoid rd_kafka_conf_set_log_cb(rd_kafka_conf_t *conf, void (*log_cb)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));\nvoid rd_kafka_conf_set_stats_cb(rd_kafka_conf_t *conf, int (*stats_cb)(rd_kafka_t *rk, char *json, size_t json_len, void *opaque));\nvoid rd_kafka_conf_set_oauthbearer_token_refresh_cb(rd_kafka_conf_t *conf, void (*oauthbearer_token_refresh_cb)(rd_kafka_t *rk, const char *oauthbearer_config, void *opaque));\nvoid rd_kafka_conf_set_socket_cb(rd_kafka_conf_t *conf, int (*socket_cb)(int domain, int type, int protocol, void *opaque));\nvoid rd_kafka_conf_set_connect_cb(rd_kafka_conf_t *conf, int (*connect_cb)(int sockfd, const struct sockaddr *addr, int addrlen, const char *id, void *opaque));\nvoid rd_kafka_conf_set_closesocket_cb(rd_kafka_conf_t *conf, int (*closesocket_cb)(int sockfd, void *opaque));\nrd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert_verify_cb(rd_kafka_conf_t *conf, int (*ssl_cert_verify_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int *x509_error, int depth, const char *buf, size_t size, char *errstr, size_t errstr_size, void *opaque));\ntypedef enum rd_kafka_cert_type_t {\n  RD_KAFKA_CERT_PUBLIC_KEY,\n  RD_KAFKA_CERT_PRIVATE_KEY,\n  RD_KAFKA_CERT_CA,\n  RD_KAFKA_CERT__CNT,\n} rd_kafka_cert_type_t;\ntypedef enum rd_kafka_cert_enc_t {\n  RD_KAFKA_CERT_ENC_PKCS12,\n  RD_KAFKA_CERT_ENC_DER,\n  RD_KAFKA_CERT_ENC_PEM,\n  RD_KAFKA_CERT_ENC__CNT,\n} rd_kafka_cert_enc_t;\nrd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert(rd_kafka_conf_t *conf, rd_kafka_cert_type_t cert_type, rd_kafka_cert_enc_t cert_enc, const void *buffer, size_t size, char *errstr, size_t errstr_size);\nvoid rd_kafka_conf_set_opaque(rd_kafka_conf_t *conf, void *opaque);\nvoid *rd_kafka_opaque(const rd_kafka_t *rk);\nvoid rd_kafka_conf_set_default_topic_conf(rd_kafka_conf_t *conf, rd_kafka_topic_conf_t *tconf);\nrd_kafka_conf_res_t rd_kafka_conf_get(const rd_kafka_conf_t *conf, const char *name, char *dest, size_t *dest_size);\nrd_kafka_conf_res_t rd_kafka_topic_conf_get(const rd_kafka_topic_conf_t *conf, const char *name, char *dest, size_t *dest_size);\nconst char **rd_kafka_conf_dump(rd_kafka_conf_t *conf, size_t *cntp);\nconst char **rd_kafka_topic_conf_dump(rd_kafka_topic_conf_t *conf, size_t *cntp);\nvoid rd_kafka_conf_dump_free(const char **arr, size_t cnt);\nvoid rd_kafka_conf_properties_show(FILE *fp);\nrd_kafka_topic_conf_t *rd_kafka_topic_conf_new(void);\nrd_kafka_topic_conf_t *rd_kafka_topic_conf_dup(const rd_kafka_topic_conf_t *conf);\nrd_kafka_topic_conf_t *rd_kafka_default_topic_conf_dup(rd_kafka_t *rk);\nvoid rd_kafka_topic_conf_destroy(rd_kafka_topic_conf_t *topic_conf);\nrd_kafka_conf_res_t rd_kafka_topic_conf_set(rd_kafka_topic_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);\nvoid rd_kafka_topic_conf_set_opaque(rd_kafka_topic_conf_t *conf, void *rkt_opaque);\nvoid rd_kafka_topic_conf_set_partitioner_cb(rd_kafka_topic_conf_t *topic_conf, int32_t (*partitioner)(const rd_kafka_topic_t *rkt, const void *keydata, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque));\nvoid rd_kafka_topic_conf_set_msg_order_cmp(rd_kafka_topic_conf_t *topic_conf, int (*msg_order_cmp)(const rd_kafka_message_t *a, const rd_kafka_message_t *b));\nint rd_kafka_topic_partition_available(const rd_kafka_topic_t *rkt, int32_t partition);\nint32_t rd_kafka_msg_partitioner_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_consistent(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_consistent_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_murmur2(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_murmur2_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nrd_kafka_t *rd_kafka_new(rd_kafka_type_t type, rd_kafka_conf_t *conf, char *errstr, size_t errstr_size);\nvoid rd_kafka_destroy(rd_kafka_t *rk);\nvoid rd_kafka_destroy_flags(rd_kafka_t *rk, int flags);\nconst char *rd_kafka_name(const rd_kafka_t *rk);\nrd_kafka_type_t rd_kafka_type(const rd_kafka_t *rk);\nchar *rd_kafka_memberid(const rd_kafka_t *rk);\nchar *rd_kafka_clusterid(rd_kafka_t *rk, int timeout_ms);\nint32_t rd_kafka_controllerid(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_topic_t *rd_kafka_topic_new(rd_kafka_t *rk, const char *topic, rd_kafka_topic_conf_t *conf);\nvoid rd_kafka_topic_destroy(rd_kafka_topic_t *rkt);\nconst char *rd_kafka_topic_name(const rd_kafka_topic_t *rkt);\nvoid *rd_kafka_topic_opaque(const rd_kafka_topic_t *rkt);\nint rd_kafka_poll(rd_kafka_t *rk, int timeout_ms);\nvoid rd_kafka_yield(rd_kafka_t *rk);\nrd_kafka_resp_err_t rd_kafka_pause_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_resp_err_t rd_kafka_resume_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_resp_err_t rd_kafka_query_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high, int timeout_ms);\nrd_kafka_resp_err_t rd_kafka_get_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high);\nrd_kafka_resp_err_t rd_kafka_offsets_for_times(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets, int timeout_ms);\nvoid rd_kafka_mem_free(rd_kafka_t *rk, void *ptr);\nrd_kafka_queue_t *rd_kafka_queue_new(rd_kafka_t *rk);\nvoid rd_kafka_queue_destroy(rd_kafka_queue_t *rkqu);\nrd_kafka_queue_t *rd_kafka_queue_get_main(rd_kafka_t *rk);\nrd_kafka_queue_t *rd_kafka_queue_get_consumer(rd_kafka_t *rk);\nrd_kafka_queue_t *rd_kafka_queue_get_partition(rd_kafka_t *rk, const char *topic, int32_t partition);\nrd_kafka_queue_t *rd_kafka_queue_get_background(rd_kafka_t *rk);\nvoid rd_kafka_queue_forward(rd_kafka_queue_t *src, rd_kafka_queue_t *dst);\nrd_kafka_resp_err_t rd_kafka_set_log_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu);\nsize_t rd_kafka_queue_length(rd_kafka_queue_t *rkqu);\nvoid rd_kafka_queue_io_event_enable(rd_kafka_queue_t *rkqu, int fd, const void *payload, size_t size);\nvoid rd_kafka_queue_cb_event_enable(rd_kafka_queue_t *rkqu, void (*event_cb)(rd_kafka_t *rk, void *qev_opaque), void *qev_opaque);\nint rd_kafka_consume_start(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);\nint rd_kafka_consume_start_queue(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, rd_kafka_queue_t *rkqu);\nint rd_kafka_consume_stop(rd_kafka_topic_t *rkt, int32_t partition);\nrd_kafka_resp_err_t rd_kafka_seek(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, int timeout_ms);\nrd_kafka_message_t *rd_kafka_consume(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms);\nssize_t rd_kafka_consume_batch(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);\nint rd_kafka_consume_callback(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);\nrd_kafka_message_t *rd_kafka_consume_queue(rd_kafka_queue_t *rkqu, int timeout_ms);\nssize_t rd_kafka_consume_batch_queue(rd_kafka_queue_t *rkqu, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);\nint rd_kafka_consume_callback_queue(rd_kafka_queue_t *rkqu, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);\nrd_kafka_resp_err_t rd_kafka_offset_store(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);\nrd_kafka_resp_err_t rd_kafka_offsets_store(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets);\nrd_kafka_resp_err_t rd_kafka_subscribe(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *topics);\nrd_kafka_resp_err_t rd_kafka_unsubscribe(rd_kafka_t *rk);\nrd_kafka_resp_err_t rd_kafka_subscription(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **topics);\nrd_kafka_message_t *rd_kafka_consumer_poll(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_resp_err_t rd_kafka_consumer_close(rd_kafka_t *rk);\nrd_kafka_resp_err_t rd_kafka_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_resp_err_t rd_kafka_assignment(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **partitions);\nrd_kafka_resp_err_t rd_kafka_commit(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, int async);\nrd_kafka_resp_err_t rd_kafka_commit_message(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, int async);\nrd_kafka_resp_err_t rd_kafka_commit_queue(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_queue_t *rkqu, void (*cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *commit_opaque), void *commit_opaque);\nrd_kafka_resp_err_t rd_kafka_committed(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms);\nrd_kafka_resp_err_t rd_kafka_position(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);\nint rd_kafka_produce(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, void *payload, size_t len, const void *key, size_t keylen, void *msg_opaque);\nrd_kafka_resp_err_t rd_kafka_producev(rd_kafka_t *rk, ...);\nint rd_kafka_produce_batch(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, rd_kafka_message_t *rkmessages, int message_cnt);\nrd_kafka_resp_err_t rd_kafka_flush(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_resp_err_t rd_kafka_purge(rd_kafka_t *rk, int purge_flags);\ntypedef struct rd_kafka_metadata_broker {\n  int32_t id;\n  char *host;\n  int port;\n} rd_kafka_metadata_broker_t;\ntypedef struct rd_kafka_metadata_partition {\n  int32_t id;\n  rd_kafka_resp_err_t err;\n  int32_t leader;\n  int replica_cnt;\n  int32_t *replicas;\n  int isr_cnt;\n  int32_t *isrs;\n} rd_kafka_metadata_partition_t;\ntypedef struct rd_kafka_metadata_topic {\n  char *topic;\n  int partition_cnt;\n  struct rd_kafka_metadata_partition *partitions;\n  rd_kafka_resp_err_t err;\n} rd_kafka_metadata_topic_t;\ntypedef struct rd_kafka_metadata {\n  int broker_cnt;\n  struct rd_kafka_metadata_broker *brokers;\n  int topic_cnt;\n  struct rd_kafka_metadata_topic *topics;\n  int32_t orig_broker_id;\n  char *orig_broker_name;\n} rd_kafka_metadata_t;\nrd_kafka_resp_err_t rd_kafka_metadata(rd_kafka_t *rk, int all_topics, rd_kafka_topic_t *only_rkt, const struct rd_kafka_metadata **metadatap, int timeout_ms);\nvoid rd_kafka_metadata_destroy(const struct rd_kafka_metadata *metadata);\nstruct rd_kafka_group_member_info {\n  char *member_id;\n  char *client_id;\n  char *client_host;\n  void *member_metadata;\n  int member_metadata_size;\n  void *member_assignment;\n  int member_assignment_size;\n};\nstruct rd_kafka_group_info {\n  struct rd_kafka_metadata_broker broker;\n  char *group;\n  rd_kafka_resp_err_t err;\n  char *state;\n  char *protocol_type;\n  char *protocol;\n  struct rd_kafka_group_member_info *members;\n  int member_cnt;\n};\nstruct rd_kafka_group_list {\n  struct rd_kafka_group_info *groups;\n  int group_cnt;\n};\nrd_kafka_resp_err_t rd_kafka_list_groups(rd_kafka_t *rk, const char *group, const struct rd_kafka_group_list **grplistp, int timeout_ms);\nvoid rd_kafka_group_list_destroy(const struct rd_kafka_group_list *grplist);\nint rd_kafka_brokers_add(rd_kafka_t *rk, const char *brokerlist);\nvoid rd_kafka_set_logger(rd_kafka_t *rk, void (*func)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));\nvoid rd_kafka_set_log_level(rd_kafka_t *rk, int level);\nvoid rd_kafka_log_print(const rd_kafka_t *rk, int level, const char *fac, const char *buf);\nvoid rd_kafka_log_syslog(const rd_kafka_t *rk, int level, const char *fac, const char *buf);\nint rd_kafka_outq_len(rd_kafka_t *rk);\nvoid rd_kafka_dump(FILE *fp, rd_kafka_t *rk);\nint rd_kafka_thread_cnt(void);\ntypedef enum rd_kafka_thread_type_t {\n  RD_KAFKA_THREAD_MAIN,\n  RD_KAFKA_THREAD_BACKGROUND,\n  RD_KAFKA_THREAD_BROKER,\n} rd_kafka_thread_type_t;\nint rd_kafka_wait_destroyed(int timeout_ms);\nint rd_kafka_unittest(void);\nrd_kafka_resp_err_t rd_kafka_poll_set_consumer(rd_kafka_t *rk);\ntypedef int rd_kafka_event_type_t;\nrd_kafka_event_type_t rd_kafka_event_type(const rd_kafka_event_t *rkev);\nconst char *rd_kafka_event_name(const rd_kafka_event_t *rkev);\nvoid rd_kafka_event_destroy(rd_kafka_event_t *rkev);\nconst rd_kafka_message_t *rd_kafka_event_message_next(rd_kafka_event_t *rkev);\nsize_t rd_kafka_event_message_array(rd_kafka_event_t *rkev, const rd_kafka_message_t **rkmessages, size_t size);\nsize_t rd_kafka_event_message_count(rd_kafka_event_t *rkev);\nconst char *rd_kafka_event_config_string(rd_kafka_event_t *rkev);\nrd_kafka_resp_err_t rd_kafka_event_error(rd_kafka_event_t *rkev);\nconst char *rd_kafka_event_error_string(rd_kafka_event_t *rkev);\nint rd_kafka_event_error_is_fatal(rd_kafka_event_t *rkev);\nvoid *rd_kafka_event_opaque(rd_kafka_event_t *rkev);\nint rd_kafka_event_log(rd_kafka_event_t *rkev, const char **fac, const char **str, int *level);\nconst char *rd_kafka_event_stats(rd_kafka_event_t *rkev);\nrd_kafka_topic_partition_list_t *rd_kafka_event_topic_partition_list(rd_kafka_event_t *rkev);\nrd_kafka_topic_partition_t *rd_kafka_event_topic_partition(rd_kafka_event_t *rkev);\ntypedef rd_kafka_event_t rd_kafka_CreateTopics_result_t;\ntypedef rd_kafka_event_t rd_kafka_DeleteTopics_result_t;\ntypedef rd_kafka_event_t rd_kafka_CreatePartitions_result_t;\ntypedef rd_kafka_event_t rd_kafka_AlterConfigs_result_t;\ntypedef rd_kafka_event_t rd_kafka_DescribeConfigs_result_t;\nconst rd_kafka_CreateTopics_result_t *rd_kafka_event_CreateTopics_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DeleteTopics_result_t *rd_kafka_event_DeleteTopics_result(rd_kafka_event_t *rkev);\nconst rd_kafka_CreatePartitions_result_t *rd_kafka_event_CreatePartitions_result(rd_kafka_event_t *rkev);\nconst rd_kafka_AlterConfigs_result_t *rd_kafka_event_AlterConfigs_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DescribeConfigs_result_t *rd_kafka_event_DescribeConfigs_result(rd_kafka_event_t *rkev);\nrd_kafka_event_t *rd_kafka_queue_poll(rd_kafka_queue_t *rkqu, int timeout_ms);\nint rd_kafka_queue_poll_callback(rd_kafka_queue_t *rkqu, int timeout_ms);\ntypedef rd_kafka_resp_err_t (rd_kafka_plugin_f_conf_init_t)(rd_kafka_conf_t *conf, void **plug_opaquep, char *errstr, size_t errstr_size);\ntypedef rd_kafka_conf_res_t (rd_kafka_interceptor_f_on_conf_set_t)(rd_kafka_conf_t *conf, const char *name, const char *val, char *errstr, size_t errstr_size, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_dup_t)(rd_kafka_conf_t *new_conf, const rd_kafka_conf_t *old_conf, size_t filter_cnt, const char **filter, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_destroy_t)(void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_new_t)(rd_kafka_t *rk, const rd_kafka_conf_t *conf, void *ic_opaque, char *errstr, size_t errstr_size);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_destroy_t)(rd_kafka_t *rk, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_send_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_acknowledgement_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_consume_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_commit_t)(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_resp_err_t err, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_request_sent_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_start_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_exit_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_set(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_set_t *on_conf_set, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_dup(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_dup_t *on_conf_dup, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_destroy(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_destroy_t *on_conf_destroy, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_new(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_new_t *on_new, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_destroy(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_destroy_t *on_destroy, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_send(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_send_t *on_send, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_acknowledgement(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_acknowledgement_t *on_acknowledgement, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_consume(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_consume_t *on_consume, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_commit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_commit_t *on_commit, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_request_sent(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_request_sent_t *on_request_sent, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_start(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_start_t *on_thread_start, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_exit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_exit_t *on_thread_exit, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_topic_result_error(const rd_kafka_topic_result_t *topicres);\nconst char *rd_kafka_topic_result_error_string(const rd_kafka_topic_result_t *topicres);\nconst char *rd_kafka_topic_result_name(const rd_kafka_topic_result_t *topicres);\ntypedef enum rd_kafka_admin_op_t {\n  RD_KAFKA_ADMIN_OP_ANY = 0,\n  RD_KAFKA_ADMIN_OP_CREATETOPICS,\n  RD_KAFKA_ADMIN_OP_DELETETOPICS,\n  RD_KAFKA_ADMIN_OP_CREATEPARTITIONS,\n  RD_KAFKA_ADMIN_OP_ALTERCONFIGS,\n  RD_KAFKA_ADMIN_OP_DESCRIBECONFIGS,\n  RD_KAFKA_ADMIN_OP__CNT,\n} rd_kafka_admin_op_t;\ntypedef struct rd_kafka_AdminOptions_s rd_kafka_AdminOptions_t;\nrd_kafka_AdminOptions_t *rd_kafka_AdminOptions_new(rd_kafka_t *rk, rd_kafka_admin_op_t for_api);\nvoid rd_kafka_AdminOptions_destroy(rd_kafka_AdminOptions_t *options);\nrd_kafka_resp_err_t rd_kafka_AdminOptions_set_request_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_AdminOptions_set_operation_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_AdminOptions_set_validate_only(rd_kafka_AdminOptions_t *options, int true_or_false, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_AdminOptions_set_broker(rd_kafka_AdminOptions_t *options, int32_t broker_id, char *errstr, size_t errstr_size);\nvoid rd_kafka_AdminOptions_set_opaque(rd_kafka_AdminOptions_t *options, void *ev_opaque);\ntypedef struct rd_kafka_NewTopic_s rd_kafka_NewTopic_t;\nrd_kafka_NewTopic_t *rd_kafka_NewTopic_new(const char *topic, int num_partitions, int replication_factor, char *errstr, size_t errstr_size);\nvoid rd_kafka_NewTopic_destroy(rd_kafka_NewTopic_t *new_topic);\nvoid rd_kafka_NewTopic_destroy_array(rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt);\nrd_kafka_resp_err_t rd_kafka_NewTopic_set_replica_assignment(rd_kafka_NewTopic_t *new_topic, int32_t partition, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_NewTopic_set_config(rd_kafka_NewTopic_t *new_topic, const char *name, const char *value);\nvoid rd_kafka_CreateTopics(rd_kafka_t *rk, rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_topic_result_t **rd_kafka_CreateTopics_result_topics(const rd_kafka_CreateTopics_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_DeleteTopic_s rd_kafka_DeleteTopic_t;\nrd_kafka_DeleteTopic_t *rd_kafka_DeleteTopic_new(const char *topic);\nvoid rd_kafka_DeleteTopic_destroy(rd_kafka_DeleteTopic_t *del_topic);\nvoid rd_kafka_DeleteTopic_destroy_array(rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt);\nvoid rd_kafka_DeleteTopics(rd_kafka_t *rk, rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_topic_result_t **rd_kafka_DeleteTopics_result_topics(const rd_kafka_DeleteTopics_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_NewPartitions_s rd_kafka_NewPartitions_t;\nrd_kafka_NewPartitions_t *rd_kafka_NewPartitions_new(const char *topic, size_t new_total_cnt, char *errstr, size_t errstr_size);\nvoid rd_kafka_NewPartitions_destroy(rd_kafka_NewPartitions_t *new_parts);\nvoid rd_kafka_NewPartitions_destroy_array(rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt);\nrd_kafka_resp_err_t rd_kafka_NewPartitions_set_replica_assignment(rd_kafka_NewPartitions_t *new_parts, int32_t new_partition_idx, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);\nvoid rd_kafka_CreatePartitions(rd_kafka_t *rk, rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_topic_result_t **rd_kafka_CreatePartitions_result_topics(const rd_kafka_CreatePartitions_result_t *result, size_t *cntp);\ntypedef enum rd_kafka_ConfigSource_t {\n  RD_KAFKA_CONFIG_SOURCE_UNKNOWN_CONFIG = 0,\n  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_TOPIC_CONFIG = 1,\n  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_BROKER_CONFIG = 2,\n  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_DEFAULT_BROKER_CONFIG = 3,\n  RD_KAFKA_CONFIG_SOURCE_STATIC_BROKER_CONFIG = 4,\n  RD_KAFKA_CONFIG_SOURCE_DEFAULT_CONFIG = 5,\n  RD_KAFKA_CONFIG_SOURCE__CNT,\n} rd_kafka_ConfigSource_t;\nconst char *rd_kafka_ConfigSource_name(rd_kafka_ConfigSource_t confsource);\ntypedef struct rd_kafka_ConfigEntry_s rd_kafka_ConfigEntry_t;\nconst char *rd_kafka_ConfigEntry_name(const rd_kafka_ConfigEntry_t *entry);\nconst char *rd_kafka_ConfigEntry_value(const rd_kafka_ConfigEntry_t *entry);\nrd_kafka_ConfigSource_t rd_kafka_ConfigEntry_source(const rd_kafka_ConfigEntry_t *entry);\nint rd_kafka_ConfigEntry_is_read_only(const rd_kafka_ConfigEntry_t *entry);\nint rd_kafka_ConfigEntry_is_default(const rd_kafka_ConfigEntry_t *entry);\nint rd_kafka_ConfigEntry_is_sensitive(const rd_kafka_ConfigEntry_t *entry);\nint rd_kafka_ConfigEntry_is_synonym(const rd_kafka_ConfigEntry_t *entry);\nconst rd_kafka_ConfigEntry_t **rd_kafka_ConfigEntry_synonyms(const rd_kafka_ConfigEntry_t *entry, size_t *cntp);\ntypedef enum rd_kafka_ResourceType_t {\n  RD_KAFKA_RESOURCE_UNKNOWN = 0,\n  RD_KAFKA_RESOURCE_ANY = 1,\n  RD_KAFKA_RESOURCE_TOPIC = 2,\n  RD_KAFKA_RESOURCE_GROUP = 3,\n  RD_KAFKA_RESOURCE_BROKER = 4,\n  RD_KAFKA_RESOURCE__CNT,\n} rd_kafka_ResourceType_t;\nconst char *rd_kafka_ResourceType_name(rd_kafka_ResourceType_t restype);\ntypedef struct rd_kafka_ConfigResource_s rd_kafka_ConfigResource_t;\nrd_kafka_ConfigResource_t *rd_kafka_ConfigResource_new(rd_kafka_ResourceType_t restype, const char *resname);\nvoid rd_kafka_ConfigResource_destroy(rd_kafka_ConfigResource_t *config);\nvoid rd_kafka_ConfigResource_destroy_array(rd_kafka_ConfigResource_t **config, size_t config_cnt);\nrd_kafka_resp_err_t rd_kafka_ConfigResource_set_config(rd_kafka_ConfigResource_t *config, const char *name, const char *value);\nconst rd_kafka_ConfigEntry_t **rd_kafka_ConfigResource_configs(const rd_kafka_ConfigResource_t *config, size_t *cntp);\nrd_kafka_ResourceType_t rd_kafka_ConfigResource_type(const rd_kafka_ConfigResource_t *config);\nconst char *rd_kafka_ConfigResource_name(const rd_kafka_ConfigResource_t *config);\nrd_kafka_resp_err_t rd_kafka_ConfigResource_error(const rd_kafka_ConfigResource_t *config);\nconst char *rd_kafka_ConfigResource_error_string(const rd_kafka_ConfigResource_t *config);\nvoid rd_kafka_AlterConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_ConfigResource_t **rd_kafka_AlterConfigs_result_resources(const rd_kafka_AlterConfigs_result_t *result, size_t *cntp);\nvoid rd_kafka_DescribeConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_ConfigResource_t **rd_kafka_DescribeConfigs_result_resources(const rd_kafka_DescribeConfigs_result_t *result, size_t *cntp);\nrd_kafka_resp_err_t rd_kafka_oauthbearer_set_token(rd_kafka_t *rk, const char *token_value, int64_t md_lifetime_ms, const char *md_principal_name, const char **extensions, size_t extension_size, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_oauthbearer_set_token_failure(rd_kafka_t *rk, const char *errstr);\n'\n</code></pre> rdkafka.h, rdkafka_mock.h</p>"},{"location":"api/constants/#rd_kafka_version_4","title":"RD_KAFKA_VERSION","text":"<pre><code>public RD_KAFKA_VERSION = 16908799\n</code></pre> <p>librdkafka version </p> <p>Interpreted as hex <code>MM.mm.rr.xx</code>:</p> <ul> <li>MM = Major</li> <li>mm = minor</li> <li>rr = revision</li> <li>xx = pre-release id (0xff is the final release)</li> </ul> <p>E.g.: <code>0x000801ff</code> = 0.8.1</p> RemarksThis value should only be used during compile time, for runtime checks of version use rd_kafka_version()  <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_unsupported_compression_type_4","title":"RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE","text":"<pre><code>public RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76\n</code></pre> <p>Unsupported compression type </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_end_all_4","title":"RD_KAFKA_RESP_ERR_END_ALL","text":"<p><pre><code>public RD_KAFKA_RESP_ERR_END_ALL = 82\n</code></pre> enum rd_kafka_resp_err_t</p>"},{"location":"api/constants/#rd_kafka_admin_op__cnt_4","title":"RD_KAFKA_ADMIN_OP__CNT","text":"<pre><code>public RD_KAFKA_ADMIN_OP__CNT = 6\n</code></pre> <p>Number of ops defined </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe </li> </ul>"},{"location":"api/constants/#rd_kafka_resource__cnt_4","title":"RD_KAFKA_RESOURCE__CNT","text":"<pre><code>public RD_KAFKA_RESOURCE__CNT = 5\n</code></pre> <p>Number of resource types defined </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#acca83a66d7783ff7683ed2691cc907c9 </li> </ul>"},{"location":"api/constants/#rd_kafka_cdef_4","title":"RD_KAFKA_CDEF","text":"<p><pre><code>public RD_KAFKA_CDEF = 'typedef long int ssize_t;\ntypedef struct _IO_FILE FILE;\ntypedef long int mode_t;\ntypedef signed int int16_t;\ntypedef unsigned int uint16_t;\ntypedef signed int int32_t;\ntypedef signed long int int64_t;\nint rd_kafka_version(void);\nconst char *rd_kafka_version_str(void);\ntypedef enum rd_kafka_type_t {\n  RD_KAFKA_PRODUCER,\n  RD_KAFKA_CONSUMER,\n} rd_kafka_type_t;\ntypedef enum rd_kafka_timestamp_type_t {\n  RD_KAFKA_TIMESTAMP_NOT_AVAILABLE,\n  RD_KAFKA_TIMESTAMP_CREATE_TIME,\n  RD_KAFKA_TIMESTAMP_LOG_APPEND_TIME,\n} rd_kafka_timestamp_type_t;\nconst char *rd_kafka_get_debug_contexts(void);\ntypedef struct rd_kafka_s rd_kafka_t;\ntypedef struct rd_kafka_topic_s rd_kafka_topic_t;\ntypedef struct rd_kafka_conf_s rd_kafka_conf_t;\ntypedef struct rd_kafka_topic_conf_s rd_kafka_topic_conf_t;\ntypedef struct rd_kafka_queue_s rd_kafka_queue_t;\ntypedef struct rd_kafka_op_s rd_kafka_event_t;\ntypedef struct rd_kafka_topic_result_s rd_kafka_topic_result_t;\ntypedef enum {\n  RD_KAFKA_RESP_ERR__BEGIN = (- 200),\n  RD_KAFKA_RESP_ERR__BAD_MSG = (- 199),\n  RD_KAFKA_RESP_ERR__BAD_COMPRESSION = (- 198),\n  RD_KAFKA_RESP_ERR__DESTROY = (- 197),\n  RD_KAFKA_RESP_ERR__FAIL = (- 196),\n  RD_KAFKA_RESP_ERR__TRANSPORT = (- 195),\n  RD_KAFKA_RESP_ERR__CRIT_SYS_RESOURCE = (- 194),\n  RD_KAFKA_RESP_ERR__RESOLVE = (- 193),\n  RD_KAFKA_RESP_ERR__MSG_TIMED_OUT = (- 192),\n  RD_KAFKA_RESP_ERR__PARTITION_EOF = (- 191),\n  RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION = (- 190),\n  RD_KAFKA_RESP_ERR__FS = (- 189),\n  RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC = (- 188),\n  RD_KAFKA_RESP_ERR__ALL_BROKERS_DOWN = (- 187),\n  RD_KAFKA_RESP_ERR__INVALID_ARG = (- 186),\n  RD_KAFKA_RESP_ERR__TIMED_OUT = (- 185),\n  RD_KAFKA_RESP_ERR__QUEUE_FULL = (- 184),\n  RD_KAFKA_RESP_ERR__ISR_INSUFF = (- 183),\n  RD_KAFKA_RESP_ERR__NODE_UPDATE = (- 182),\n  RD_KAFKA_RESP_ERR__SSL = (- 181),\n  RD_KAFKA_RESP_ERR__WAIT_COORD = (- 180),\n  RD_KAFKA_RESP_ERR__UNKNOWN_GROUP = (- 179),\n  RD_KAFKA_RESP_ERR__IN_PROGRESS = (- 178),\n  RD_KAFKA_RESP_ERR__PREV_IN_PROGRESS = (- 177),\n  RD_KAFKA_RESP_ERR__EXISTING_SUBSCRIPTION = (- 176),\n  RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS = (- 175),\n  RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS = (- 174),\n  RD_KAFKA_RESP_ERR__CONFLICT = (- 173),\n  RD_KAFKA_RESP_ERR__STATE = (- 172),\n  RD_KAFKA_RESP_ERR__UNKNOWN_PROTOCOL = (- 171),\n  RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED = (- 170),\n  RD_KAFKA_RESP_ERR__AUTHENTICATION = (- 169),\n  RD_KAFKA_RESP_ERR__NO_OFFSET = (- 168),\n  RD_KAFKA_RESP_ERR__OUTDATED = (- 167),\n  RD_KAFKA_RESP_ERR__TIMED_OUT_QUEUE = (- 166),\n  RD_KAFKA_RESP_ERR__UNSUPPORTED_FEATURE = (- 165),\n  RD_KAFKA_RESP_ERR__WAIT_CACHE = (- 164),\n  RD_KAFKA_RESP_ERR__INTR = (- 163),\n  RD_KAFKA_RESP_ERR__KEY_SERIALIZATION = (- 162),\n  RD_KAFKA_RESP_ERR__VALUE_SERIALIZATION = (- 161),\n  RD_KAFKA_RESP_ERR__KEY_DESERIALIZATION = (- 160),\n  RD_KAFKA_RESP_ERR__VALUE_DESERIALIZATION = (- 159),\n  RD_KAFKA_RESP_ERR__PARTIAL = (- 158),\n  RD_KAFKA_RESP_ERR__READ_ONLY = (- 157),\n  RD_KAFKA_RESP_ERR__NOENT = (- 156),\n  RD_KAFKA_RESP_ERR__UNDERFLOW = (- 155),\n  RD_KAFKA_RESP_ERR__INVALID_TYPE = (- 154),\n  RD_KAFKA_RESP_ERR__RETRY = (- 153),\n  RD_KAFKA_RESP_ERR__PURGE_QUEUE = (- 152),\n  RD_KAFKA_RESP_ERR__PURGE_INFLIGHT = (- 151),\n  RD_KAFKA_RESP_ERR__FATAL = (- 150),\n  RD_KAFKA_RESP_ERR__INCONSISTENT = (- 149),\n  RD_KAFKA_RESP_ERR__GAPLESS_GUARANTEE = (- 148),\n  RD_KAFKA_RESP_ERR__MAX_POLL_EXCEEDED = (- 147),\n  RD_KAFKA_RESP_ERR__END = (- 100),\n  RD_KAFKA_RESP_ERR_UNKNOWN = (- 1),\n  RD_KAFKA_RESP_ERR_NO_ERROR = 0,\n  RD_KAFKA_RESP_ERR_OFFSET_OUT_OF_RANGE = 1,\n  RD_KAFKA_RESP_ERR_INVALID_MSG = 2,\n  RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART = 3,\n  RD_KAFKA_RESP_ERR_INVALID_MSG_SIZE = 4,\n  RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE = 5,\n  RD_KAFKA_RESP_ERR_NOT_LEADER_FOR_PARTITION = 6,\n  RD_KAFKA_RESP_ERR_REQUEST_TIMED_OUT = 7,\n  RD_KAFKA_RESP_ERR_BROKER_NOT_AVAILABLE = 8,\n  RD_KAFKA_RESP_ERR_REPLICA_NOT_AVAILABLE = 9,\n  RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE = 10,\n  RD_KAFKA_RESP_ERR_STALE_CTRL_EPOCH = 11,\n  RD_KAFKA_RESP_ERR_OFFSET_METADATA_TOO_LARGE = 12,\n  RD_KAFKA_RESP_ERR_NETWORK_EXCEPTION = 13,\n  RD_KAFKA_RESP_ERR_GROUP_LOAD_IN_PROGRESS = 14,\n  RD_KAFKA_RESP_ERR_GROUP_COORDINATOR_NOT_AVAILABLE = 15,\n  RD_KAFKA_RESP_ERR_NOT_COORDINATOR_FOR_GROUP = 16,\n  RD_KAFKA_RESP_ERR_TOPIC_EXCEPTION = 17,\n  RD_KAFKA_RESP_ERR_RECORD_LIST_TOO_LARGE = 18,\n  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS = 19,\n  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS_AFTER_APPEND = 20,\n  RD_KAFKA_RESP_ERR_INVALID_REQUIRED_ACKS = 21,\n  RD_KAFKA_RESP_ERR_ILLEGAL_GENERATION = 22,\n  RD_KAFKA_RESP_ERR_INCONSISTENT_GROUP_PROTOCOL = 23,\n  RD_KAFKA_RESP_ERR_INVALID_GROUP_ID = 24,\n  RD_KAFKA_RESP_ERR_UNKNOWN_MEMBER_ID = 25,\n  RD_KAFKA_RESP_ERR_INVALID_SESSION_TIMEOUT = 26,\n  RD_KAFKA_RESP_ERR_REBALANCE_IN_PROGRESS = 27,\n  RD_KAFKA_RESP_ERR_INVALID_COMMIT_OFFSET_SIZE = 28,\n  RD_KAFKA_RESP_ERR_TOPIC_AUTHORIZATION_FAILED = 29,\n  RD_KAFKA_RESP_ERR_GROUP_AUTHORIZATION_FAILED = 30,\n  RD_KAFKA_RESP_ERR_CLUSTER_AUTHORIZATION_FAILED = 31,\n  RD_KAFKA_RESP_ERR_INVALID_TIMESTAMP = 32,\n  RD_KAFKA_RESP_ERR_UNSUPPORTED_SASL_MECHANISM = 33,\n  RD_KAFKA_RESP_ERR_ILLEGAL_SASL_STATE = 34,\n  RD_KAFKA_RESP_ERR_UNSUPPORTED_VERSION = 35,\n  RD_KAFKA_RESP_ERR_TOPIC_ALREADY_EXISTS = 36,\n  RD_KAFKA_RESP_ERR_INVALID_PARTITIONS = 37,\n  RD_KAFKA_RESP_ERR_INVALID_REPLICATION_FACTOR = 38,\n  RD_KAFKA_RESP_ERR_INVALID_REPLICA_ASSIGNMENT = 39,\n  RD_KAFKA_RESP_ERR_INVALID_CONFIG = 40,\n  RD_KAFKA_RESP_ERR_NOT_CONTROLLER = 41,\n  RD_KAFKA_RESP_ERR_INVALID_REQUEST = 42,\n  RD_KAFKA_RESP_ERR_UNSUPPORTED_FOR_MESSAGE_FORMAT = 43,\n  RD_KAFKA_RESP_ERR_POLICY_VIOLATION = 44,\n  RD_KAFKA_RESP_ERR_OUT_OF_ORDER_SEQUENCE_NUMBER = 45,\n  RD_KAFKA_RESP_ERR_DUPLICATE_SEQUENCE_NUMBER = 46,\n  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_EPOCH = 47,\n  RD_KAFKA_RESP_ERR_INVALID_TXN_STATE = 48,\n  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_ID_MAPPING = 49,\n  RD_KAFKA_RESP_ERR_INVALID_TRANSACTION_TIMEOUT = 50,\n  RD_KAFKA_RESP_ERR_CONCURRENT_TRANSACTIONS = 51,\n  RD_KAFKA_RESP_ERR_TRANSACTION_COORDINATOR_FENCED = 52,\n  RD_KAFKA_RESP_ERR_TRANSACTIONAL_ID_AUTHORIZATION_FAILED = 53,\n  RD_KAFKA_RESP_ERR_SECURITY_DISABLED = 54,\n  RD_KAFKA_RESP_ERR_OPERATION_NOT_ATTEMPTED = 55,\n  RD_KAFKA_RESP_ERR_KAFKA_STORAGE_ERROR = 56,\n  RD_KAFKA_RESP_ERR_LOG_DIR_NOT_FOUND = 57,\n  RD_KAFKA_RESP_ERR_SASL_AUTHENTICATION_FAILED = 58,\n  RD_KAFKA_RESP_ERR_UNKNOWN_PRODUCER_ID = 59,\n  RD_KAFKA_RESP_ERR_REASSIGNMENT_IN_PROGRESS = 60,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTH_DISABLED = 61,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_NOT_FOUND = 62,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_OWNER_MISMATCH = 63,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_REQUEST_NOT_ALLOWED = 64,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTHORIZATION_FAILED = 65,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_EXPIRED = 66,\n  RD_KAFKA_RESP_ERR_INVALID_PRINCIPAL_TYPE = 67,\n  RD_KAFKA_RESP_ERR_NON_EMPTY_GROUP = 68,\n  RD_KAFKA_RESP_ERR_GROUP_ID_NOT_FOUND = 69,\n  RD_KAFKA_RESP_ERR_FETCH_SESSION_ID_NOT_FOUND = 70,\n  RD_KAFKA_RESP_ERR_INVALID_FETCH_SESSION_EPOCH = 71,\n  RD_KAFKA_RESP_ERR_LISTENER_NOT_FOUND = 72,\n  RD_KAFKA_RESP_ERR_TOPIC_DELETION_DISABLED = 73,\n  RD_KAFKA_RESP_ERR_FENCED_LEADER_EPOCH = 74,\n  RD_KAFKA_RESP_ERR_UNKNOWN_LEADER_EPOCH = 75,\n  RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76,\n  RD_KAFKA_RESP_ERR_STALE_BROKER_EPOCH = 77,\n  RD_KAFKA_RESP_ERR_OFFSET_NOT_AVAILABLE = 78,\n  RD_KAFKA_RESP_ERR_MEMBER_ID_REQUIRED = 79,\n  RD_KAFKA_RESP_ERR_PREFERRED_LEADER_NOT_AVAILABLE = 80,\n  RD_KAFKA_RESP_ERR_GROUP_MAX_SIZE_REACHED = 81,\n  RD_KAFKA_RESP_ERR_END_ALL,\n} rd_kafka_resp_err_t;\nstruct rd_kafka_err_desc {\n  rd_kafka_resp_err_t code;\n  char *name;\n  char *desc;\n};\nvoid rd_kafka_get_err_descs(const struct rd_kafka_err_desc **errdescs, size_t *cntp);\nconst char *rd_kafka_err2str(rd_kafka_resp_err_t err);\nconst char *rd_kafka_err2name(rd_kafka_resp_err_t err);\nrd_kafka_resp_err_t rd_kafka_last_error(void);\nrd_kafka_resp_err_t rd_kafka_errno2err(int errnox);\nint rd_kafka_errno(void);\nrd_kafka_resp_err_t rd_kafka_fatal_error(rd_kafka_t *rk, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_test_fatal_error(rd_kafka_t *rk, rd_kafka_resp_err_t err, const char *reason);\ntypedef struct rd_kafka_topic_partition_s {\n  char *topic;\n  int32_t partition;\n  int64_t offset;\n  void *metadata;\n  size_t metadata_size;\n  void *opaque;\n  rd_kafka_resp_err_t err;\n  void *_private;\n} rd_kafka_topic_partition_t;\nvoid rd_kafka_topic_partition_destroy(rd_kafka_topic_partition_t *rktpar);\ntypedef struct rd_kafka_topic_partition_list_s {\n  int cnt;\n  int size;\n  rd_kafka_topic_partition_t *elems;\n} rd_kafka_topic_partition_list_t;\nrd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_new(int size);\nvoid rd_kafka_topic_partition_list_destroy(rd_kafka_topic_partition_list_t *rkparlist);\nrd_kafka_topic_partition_t *rd_kafka_topic_partition_list_add(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);\nvoid rd_kafka_topic_partition_list_add_range(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t start, int32_t stop);\nint rd_kafka_topic_partition_list_del(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);\nint rd_kafka_topic_partition_list_del_by_idx(rd_kafka_topic_partition_list_t *rktparlist, int idx);\nrd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_copy(const rd_kafka_topic_partition_list_t *src);\nrd_kafka_resp_err_t rd_kafka_topic_partition_list_set_offset(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition, int64_t offset);\nrd_kafka_topic_partition_t *rd_kafka_topic_partition_list_find(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);\nvoid rd_kafka_topic_partition_list_sort(rd_kafka_topic_partition_list_t *rktparlist, int (*cmp)(const void *a, const void *b, void *cmp_opaque), void *cmp_opaque);\ntypedef enum rd_kafka_vtype_t {\n  RD_KAFKA_VTYPE_END,\n  RD_KAFKA_VTYPE_TOPIC,\n  RD_KAFKA_VTYPE_RKT,\n  RD_KAFKA_VTYPE_PARTITION,\n  RD_KAFKA_VTYPE_VALUE,\n  RD_KAFKA_VTYPE_KEY,\n  RD_KAFKA_VTYPE_OPAQUE,\n  RD_KAFKA_VTYPE_MSGFLAGS,\n  RD_KAFKA_VTYPE_TIMESTAMP,\n  RD_KAFKA_VTYPE_HEADER,\n  RD_KAFKA_VTYPE_HEADERS,\n} rd_kafka_vtype_t;\ntypedef struct rd_kafka_headers_s rd_kafka_headers_t;\nrd_kafka_headers_t *rd_kafka_headers_new(size_t initial_count);\nvoid rd_kafka_headers_destroy(rd_kafka_headers_t *hdrs);\nrd_kafka_headers_t *rd_kafka_headers_copy(const rd_kafka_headers_t *src);\nrd_kafka_resp_err_t rd_kafka_header_add(rd_kafka_headers_t *hdrs, const char *name, ssize_t name_size, const void *value, ssize_t value_size);\nrd_kafka_resp_err_t rd_kafka_header_remove(rd_kafka_headers_t *hdrs, const char *name);\nrd_kafka_resp_err_t rd_kafka_header_get_last(const rd_kafka_headers_t *hdrs, const char *name, const void **valuep, size_t *sizep);\nrd_kafka_resp_err_t rd_kafka_header_get(const rd_kafka_headers_t *hdrs, size_t idx, const char *name, const void **valuep, size_t *sizep);\nrd_kafka_resp_err_t rd_kafka_header_get_all(const rd_kafka_headers_t *hdrs, size_t idx, const char **namep, const void **valuep, size_t *sizep);\ntypedef struct rd_kafka_message_s {\n  rd_kafka_resp_err_t err;\n  rd_kafka_topic_t *rkt;\n  int32_t partition;\n  void *payload;\n  size_t len;\n  void *key;\n  size_t key_len;\n  int64_t offset;\n  void *_private;\n} rd_kafka_message_t;\nvoid rd_kafka_message_destroy(rd_kafka_message_t *rkmessage);\nint64_t rd_kafka_message_timestamp(const rd_kafka_message_t *rkmessage, rd_kafka_timestamp_type_t *tstype);\nint64_t rd_kafka_message_latency(const rd_kafka_message_t *rkmessage);\nrd_kafka_resp_err_t rd_kafka_message_headers(const rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);\nrd_kafka_resp_err_t rd_kafka_message_detach_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);\nvoid rd_kafka_message_set_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t *hdrs);\nsize_t rd_kafka_header_cnt(const rd_kafka_headers_t *hdrs);\ntypedef enum {\n  RD_KAFKA_MSG_STATUS_NOT_PERSISTED = 0,\n  RD_KAFKA_MSG_STATUS_POSSIBLY_PERSISTED = 1,\n  RD_KAFKA_MSG_STATUS_PERSISTED = 2,\n} rd_kafka_msg_status_t;\nrd_kafka_msg_status_t rd_kafka_message_status(const rd_kafka_message_t *rkmessage);\ntypedef enum {\n  RD_KAFKA_CONF_UNKNOWN = (- 2),\n  RD_KAFKA_CONF_INVALID = (- 1),\n  RD_KAFKA_CONF_OK = 0,\n} rd_kafka_conf_res_t;\nrd_kafka_conf_t *rd_kafka_conf_new(void);\nvoid rd_kafka_conf_destroy(rd_kafka_conf_t *conf);\nrd_kafka_conf_t *rd_kafka_conf_dup(const rd_kafka_conf_t *conf);\nrd_kafka_conf_t *rd_kafka_conf_dup_filter(const rd_kafka_conf_t *conf, size_t filter_cnt, const char **filter);\nconst rd_kafka_conf_t *rd_kafka_conf(rd_kafka_t *rk);\nrd_kafka_conf_res_t rd_kafka_conf_set(rd_kafka_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);\nvoid rd_kafka_conf_set_events(rd_kafka_conf_t *conf, int events);\nvoid rd_kafka_conf_set_background_event_cb(rd_kafka_conf_t *conf, void (*event_cb)(rd_kafka_t *rk, rd_kafka_event_t *rkev, void *opaque));\nvoid rd_kafka_conf_set_dr_cb(rd_kafka_conf_t *conf, void (*dr_cb)(rd_kafka_t *rk, void *payload, size_t len, rd_kafka_resp_err_t err, void *opaque, void *msg_opaque));\nvoid rd_kafka_conf_set_dr_msg_cb(rd_kafka_conf_t *conf, void (*dr_msg_cb)(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, void *opaque));\nvoid rd_kafka_conf_set_consume_cb(rd_kafka_conf_t *conf, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *opaque));\nvoid rd_kafka_conf_set_rebalance_cb(rd_kafka_conf_t *conf, void (*rebalance_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *partitions, void *opaque));\nvoid rd_kafka_conf_set_offset_commit_cb(rd_kafka_conf_t *conf, void (*offset_commit_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *opaque));\nvoid rd_kafka_conf_set_error_cb(rd_kafka_conf_t *conf, void (*error_cb)(rd_kafka_t *rk, int err, const char *reason, void *opaque));\nvoid rd_kafka_conf_set_throttle_cb(rd_kafka_conf_t *conf, void (*throttle_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int throttle_time_ms, void *opaque));\nvoid rd_kafka_conf_set_log_cb(rd_kafka_conf_t *conf, void (*log_cb)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));\nvoid rd_kafka_conf_set_stats_cb(rd_kafka_conf_t *conf, int (*stats_cb)(rd_kafka_t *rk, char *json, size_t json_len, void *opaque));\nvoid rd_kafka_conf_set_oauthbearer_token_refresh_cb(rd_kafka_conf_t *conf, void (*oauthbearer_token_refresh_cb)(rd_kafka_t *rk, const char *oauthbearer_config, void *opaque));\nvoid rd_kafka_conf_set_socket_cb(rd_kafka_conf_t *conf, int (*socket_cb)(int domain, int type, int protocol, void *opaque));\nvoid rd_kafka_conf_set_connect_cb(rd_kafka_conf_t *conf, int (*connect_cb)(int sockfd, const struct sockaddr *addr, int addrlen, const char *id, void *opaque));\nvoid rd_kafka_conf_set_closesocket_cb(rd_kafka_conf_t *conf, int (*closesocket_cb)(int sockfd, void *opaque));\nrd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert_verify_cb(rd_kafka_conf_t *conf, int (*ssl_cert_verify_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int *x509_error, int depth, const char *buf, size_t size, char *errstr, size_t errstr_size, void *opaque));\ntypedef enum rd_kafka_cert_type_t {\n  RD_KAFKA_CERT_PUBLIC_KEY,\n  RD_KAFKA_CERT_PRIVATE_KEY,\n  RD_KAFKA_CERT_CA,\n  RD_KAFKA_CERT__CNT,\n} rd_kafka_cert_type_t;\ntypedef enum rd_kafka_cert_enc_t {\n  RD_KAFKA_CERT_ENC_PKCS12,\n  RD_KAFKA_CERT_ENC_DER,\n  RD_KAFKA_CERT_ENC_PEM,\n  RD_KAFKA_CERT_ENC__CNT,\n} rd_kafka_cert_enc_t;\nrd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert(rd_kafka_conf_t *conf, rd_kafka_cert_type_t cert_type, rd_kafka_cert_enc_t cert_enc, const void *buffer, size_t size, char *errstr, size_t errstr_size);\nvoid rd_kafka_conf_set_opaque(rd_kafka_conf_t *conf, void *opaque);\nvoid *rd_kafka_opaque(const rd_kafka_t *rk);\nvoid rd_kafka_conf_set_default_topic_conf(rd_kafka_conf_t *conf, rd_kafka_topic_conf_t *tconf);\nrd_kafka_conf_res_t rd_kafka_conf_get(const rd_kafka_conf_t *conf, const char *name, char *dest, size_t *dest_size);\nrd_kafka_conf_res_t rd_kafka_topic_conf_get(const rd_kafka_topic_conf_t *conf, const char *name, char *dest, size_t *dest_size);\nconst char **rd_kafka_conf_dump(rd_kafka_conf_t *conf, size_t *cntp);\nconst char **rd_kafka_topic_conf_dump(rd_kafka_topic_conf_t *conf, size_t *cntp);\nvoid rd_kafka_conf_dump_free(const char **arr, size_t cnt);\nvoid rd_kafka_conf_properties_show(FILE *fp);\nrd_kafka_topic_conf_t *rd_kafka_topic_conf_new(void);\nrd_kafka_topic_conf_t *rd_kafka_topic_conf_dup(const rd_kafka_topic_conf_t *conf);\nrd_kafka_topic_conf_t *rd_kafka_default_topic_conf_dup(rd_kafka_t *rk);\nvoid rd_kafka_topic_conf_destroy(rd_kafka_topic_conf_t *topic_conf);\nrd_kafka_conf_res_t rd_kafka_topic_conf_set(rd_kafka_topic_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);\nvoid rd_kafka_topic_conf_set_opaque(rd_kafka_topic_conf_t *conf, void *rkt_opaque);\nvoid rd_kafka_topic_conf_set_partitioner_cb(rd_kafka_topic_conf_t *topic_conf, int32_t (*partitioner)(const rd_kafka_topic_t *rkt, const void *keydata, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque));\nvoid rd_kafka_topic_conf_set_msg_order_cmp(rd_kafka_topic_conf_t *topic_conf, int (*msg_order_cmp)(const rd_kafka_message_t *a, const rd_kafka_message_t *b));\nint rd_kafka_topic_partition_available(const rd_kafka_topic_t *rkt, int32_t partition);\nint32_t rd_kafka_msg_partitioner_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_consistent(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_consistent_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_murmur2(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_murmur2_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nrd_kafka_t *rd_kafka_new(rd_kafka_type_t type, rd_kafka_conf_t *conf, char *errstr, size_t errstr_size);\nvoid rd_kafka_destroy(rd_kafka_t *rk);\nvoid rd_kafka_destroy_flags(rd_kafka_t *rk, int flags);\nconst char *rd_kafka_name(const rd_kafka_t *rk);\nrd_kafka_type_t rd_kafka_type(const rd_kafka_t *rk);\nchar *rd_kafka_memberid(const rd_kafka_t *rk);\nchar *rd_kafka_clusterid(rd_kafka_t *rk, int timeout_ms);\nint32_t rd_kafka_controllerid(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_topic_t *rd_kafka_topic_new(rd_kafka_t *rk, const char *topic, rd_kafka_topic_conf_t *conf);\nvoid rd_kafka_topic_destroy(rd_kafka_topic_t *rkt);\nconst char *rd_kafka_topic_name(const rd_kafka_topic_t *rkt);\nvoid *rd_kafka_topic_opaque(const rd_kafka_topic_t *rkt);\nint rd_kafka_poll(rd_kafka_t *rk, int timeout_ms);\nvoid rd_kafka_yield(rd_kafka_t *rk);\nrd_kafka_resp_err_t rd_kafka_pause_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_resp_err_t rd_kafka_resume_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_resp_err_t rd_kafka_query_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high, int timeout_ms);\nrd_kafka_resp_err_t rd_kafka_get_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high);\nrd_kafka_resp_err_t rd_kafka_offsets_for_times(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets, int timeout_ms);\nvoid rd_kafka_mem_free(rd_kafka_t *rk, void *ptr);\nrd_kafka_queue_t *rd_kafka_queue_new(rd_kafka_t *rk);\nvoid rd_kafka_queue_destroy(rd_kafka_queue_t *rkqu);\nrd_kafka_queue_t *rd_kafka_queue_get_main(rd_kafka_t *rk);\nrd_kafka_queue_t *rd_kafka_queue_get_consumer(rd_kafka_t *rk);\nrd_kafka_queue_t *rd_kafka_queue_get_partition(rd_kafka_t *rk, const char *topic, int32_t partition);\nrd_kafka_queue_t *rd_kafka_queue_get_background(rd_kafka_t *rk);\nvoid rd_kafka_queue_forward(rd_kafka_queue_t *src, rd_kafka_queue_t *dst);\nrd_kafka_resp_err_t rd_kafka_set_log_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu);\nsize_t rd_kafka_queue_length(rd_kafka_queue_t *rkqu);\nvoid rd_kafka_queue_io_event_enable(rd_kafka_queue_t *rkqu, int fd, const void *payload, size_t size);\nvoid rd_kafka_queue_cb_event_enable(rd_kafka_queue_t *rkqu, void (*event_cb)(rd_kafka_t *rk, void *qev_opaque), void *qev_opaque);\nint rd_kafka_consume_start(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);\nint rd_kafka_consume_start_queue(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, rd_kafka_queue_t *rkqu);\nint rd_kafka_consume_stop(rd_kafka_topic_t *rkt, int32_t partition);\nrd_kafka_resp_err_t rd_kafka_seek(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, int timeout_ms);\nrd_kafka_message_t *rd_kafka_consume(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms);\nssize_t rd_kafka_consume_batch(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);\nint rd_kafka_consume_callback(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);\nrd_kafka_message_t *rd_kafka_consume_queue(rd_kafka_queue_t *rkqu, int timeout_ms);\nssize_t rd_kafka_consume_batch_queue(rd_kafka_queue_t *rkqu, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);\nint rd_kafka_consume_callback_queue(rd_kafka_queue_t *rkqu, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);\nrd_kafka_resp_err_t rd_kafka_offset_store(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);\nrd_kafka_resp_err_t rd_kafka_offsets_store(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets);\nrd_kafka_resp_err_t rd_kafka_subscribe(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *topics);\nrd_kafka_resp_err_t rd_kafka_unsubscribe(rd_kafka_t *rk);\nrd_kafka_resp_err_t rd_kafka_subscription(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **topics);\nrd_kafka_message_t *rd_kafka_consumer_poll(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_resp_err_t rd_kafka_consumer_close(rd_kafka_t *rk);\nrd_kafka_resp_err_t rd_kafka_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_resp_err_t rd_kafka_assignment(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **partitions);\nrd_kafka_resp_err_t rd_kafka_commit(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, int async);\nrd_kafka_resp_err_t rd_kafka_commit_message(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, int async);\nrd_kafka_resp_err_t rd_kafka_commit_queue(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_queue_t *rkqu, void (*cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *commit_opaque), void *commit_opaque);\nrd_kafka_resp_err_t rd_kafka_committed(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms);\nrd_kafka_resp_err_t rd_kafka_position(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);\nint rd_kafka_produce(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, void *payload, size_t len, const void *key, size_t keylen, void *msg_opaque);\nrd_kafka_resp_err_t rd_kafka_producev(rd_kafka_t *rk, ...);\nint rd_kafka_produce_batch(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, rd_kafka_message_t *rkmessages, int message_cnt);\nrd_kafka_resp_err_t rd_kafka_flush(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_resp_err_t rd_kafka_purge(rd_kafka_t *rk, int purge_flags);\ntypedef struct rd_kafka_metadata_broker {\n  int32_t id;\n  char *host;\n  int port;\n} rd_kafka_metadata_broker_t;\ntypedef struct rd_kafka_metadata_partition {\n  int32_t id;\n  rd_kafka_resp_err_t err;\n  int32_t leader;\n  int replica_cnt;\n  int32_t *replicas;\n  int isr_cnt;\n  int32_t *isrs;\n} rd_kafka_metadata_partition_t;\ntypedef struct rd_kafka_metadata_topic {\n  char *topic;\n  int partition_cnt;\n  struct rd_kafka_metadata_partition *partitions;\n  rd_kafka_resp_err_t err;\n} rd_kafka_metadata_topic_t;\ntypedef struct rd_kafka_metadata {\n  int broker_cnt;\n  struct rd_kafka_metadata_broker *brokers;\n  int topic_cnt;\n  struct rd_kafka_metadata_topic *topics;\n  int32_t orig_broker_id;\n  char *orig_broker_name;\n} rd_kafka_metadata_t;\nrd_kafka_resp_err_t rd_kafka_metadata(rd_kafka_t *rk, int all_topics, rd_kafka_topic_t *only_rkt, const struct rd_kafka_metadata **metadatap, int timeout_ms);\nvoid rd_kafka_metadata_destroy(const struct rd_kafka_metadata *metadata);\nstruct rd_kafka_group_member_info {\n  char *member_id;\n  char *client_id;\n  char *client_host;\n  void *member_metadata;\n  int member_metadata_size;\n  void *member_assignment;\n  int member_assignment_size;\n};\nstruct rd_kafka_group_info {\n  struct rd_kafka_metadata_broker broker;\n  char *group;\n  rd_kafka_resp_err_t err;\n  char *state;\n  char *protocol_type;\n  char *protocol;\n  struct rd_kafka_group_member_info *members;\n  int member_cnt;\n};\nstruct rd_kafka_group_list {\n  struct rd_kafka_group_info *groups;\n  int group_cnt;\n};\nrd_kafka_resp_err_t rd_kafka_list_groups(rd_kafka_t *rk, const char *group, const struct rd_kafka_group_list **grplistp, int timeout_ms);\nvoid rd_kafka_group_list_destroy(const struct rd_kafka_group_list *grplist);\nint rd_kafka_brokers_add(rd_kafka_t *rk, const char *brokerlist);\nvoid rd_kafka_set_logger(rd_kafka_t *rk, void (*func)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));\nvoid rd_kafka_set_log_level(rd_kafka_t *rk, int level);\nvoid rd_kafka_log_print(const rd_kafka_t *rk, int level, const char *fac, const char *buf);\nvoid rd_kafka_log_syslog(const rd_kafka_t *rk, int level, const char *fac, const char *buf);\nint rd_kafka_outq_len(rd_kafka_t *rk);\nvoid rd_kafka_dump(FILE *fp, rd_kafka_t *rk);\nint rd_kafka_thread_cnt(void);\ntypedef enum rd_kafka_thread_type_t {\n  RD_KAFKA_THREAD_MAIN,\n  RD_KAFKA_THREAD_BACKGROUND,\n  RD_KAFKA_THREAD_BROKER,\n} rd_kafka_thread_type_t;\nint rd_kafka_wait_destroyed(int timeout_ms);\nint rd_kafka_unittest(void);\nrd_kafka_resp_err_t rd_kafka_poll_set_consumer(rd_kafka_t *rk);\ntypedef int rd_kafka_event_type_t;\nrd_kafka_event_type_t rd_kafka_event_type(const rd_kafka_event_t *rkev);\nconst char *rd_kafka_event_name(const rd_kafka_event_t *rkev);\nvoid rd_kafka_event_destroy(rd_kafka_event_t *rkev);\nconst rd_kafka_message_t *rd_kafka_event_message_next(rd_kafka_event_t *rkev);\nsize_t rd_kafka_event_message_array(rd_kafka_event_t *rkev, const rd_kafka_message_t **rkmessages, size_t size);\nsize_t rd_kafka_event_message_count(rd_kafka_event_t *rkev);\nconst char *rd_kafka_event_config_string(rd_kafka_event_t *rkev);\nrd_kafka_resp_err_t rd_kafka_event_error(rd_kafka_event_t *rkev);\nconst char *rd_kafka_event_error_string(rd_kafka_event_t *rkev);\nint rd_kafka_event_error_is_fatal(rd_kafka_event_t *rkev);\nvoid *rd_kafka_event_opaque(rd_kafka_event_t *rkev);\nint rd_kafka_event_log(rd_kafka_event_t *rkev, const char **fac, const char **str, int *level);\nconst char *rd_kafka_event_stats(rd_kafka_event_t *rkev);\nrd_kafka_topic_partition_list_t *rd_kafka_event_topic_partition_list(rd_kafka_event_t *rkev);\nrd_kafka_topic_partition_t *rd_kafka_event_topic_partition(rd_kafka_event_t *rkev);\ntypedef rd_kafka_event_t rd_kafka_CreateTopics_result_t;\ntypedef rd_kafka_event_t rd_kafka_DeleteTopics_result_t;\ntypedef rd_kafka_event_t rd_kafka_CreatePartitions_result_t;\ntypedef rd_kafka_event_t rd_kafka_AlterConfigs_result_t;\ntypedef rd_kafka_event_t rd_kafka_DescribeConfigs_result_t;\nconst rd_kafka_CreateTopics_result_t *rd_kafka_event_CreateTopics_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DeleteTopics_result_t *rd_kafka_event_DeleteTopics_result(rd_kafka_event_t *rkev);\nconst rd_kafka_CreatePartitions_result_t *rd_kafka_event_CreatePartitions_result(rd_kafka_event_t *rkev);\nconst rd_kafka_AlterConfigs_result_t *rd_kafka_event_AlterConfigs_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DescribeConfigs_result_t *rd_kafka_event_DescribeConfigs_result(rd_kafka_event_t *rkev);\nrd_kafka_event_t *rd_kafka_queue_poll(rd_kafka_queue_t *rkqu, int timeout_ms);\nint rd_kafka_queue_poll_callback(rd_kafka_queue_t *rkqu, int timeout_ms);\ntypedef rd_kafka_resp_err_t (rd_kafka_plugin_f_conf_init_t)(rd_kafka_conf_t *conf, void **plug_opaquep, char *errstr, size_t errstr_size);\ntypedef rd_kafka_conf_res_t (rd_kafka_interceptor_f_on_conf_set_t)(rd_kafka_conf_t *conf, const char *name, const char *val, char *errstr, size_t errstr_size, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_dup_t)(rd_kafka_conf_t *new_conf, const rd_kafka_conf_t *old_conf, size_t filter_cnt, const char **filter, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_destroy_t)(void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_new_t)(rd_kafka_t *rk, const rd_kafka_conf_t *conf, void *ic_opaque, char *errstr, size_t errstr_size);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_destroy_t)(rd_kafka_t *rk, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_send_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_acknowledgement_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_consume_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_commit_t)(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_resp_err_t err, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_request_sent_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_start_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_exit_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_set(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_set_t *on_conf_set, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_dup(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_dup_t *on_conf_dup, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_destroy(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_destroy_t *on_conf_destroy, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_new(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_new_t *on_new, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_destroy(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_destroy_t *on_destroy, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_send(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_send_t *on_send, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_acknowledgement(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_acknowledgement_t *on_acknowledgement, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_consume(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_consume_t *on_consume, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_commit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_commit_t *on_commit, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_request_sent(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_request_sent_t *on_request_sent, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_start(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_start_t *on_thread_start, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_exit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_exit_t *on_thread_exit, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_topic_result_error(const rd_kafka_topic_result_t *topicres);\nconst char *rd_kafka_topic_result_error_string(const rd_kafka_topic_result_t *topicres);\nconst char *rd_kafka_topic_result_name(const rd_kafka_topic_result_t *topicres);\ntypedef enum rd_kafka_admin_op_t {\n  RD_KAFKA_ADMIN_OP_ANY = 0,\n  RD_KAFKA_ADMIN_OP_CREATETOPICS,\n  RD_KAFKA_ADMIN_OP_DELETETOPICS,\n  RD_KAFKA_ADMIN_OP_CREATEPARTITIONS,\n  RD_KAFKA_ADMIN_OP_ALTERCONFIGS,\n  RD_KAFKA_ADMIN_OP_DESCRIBECONFIGS,\n  RD_KAFKA_ADMIN_OP__CNT,\n} rd_kafka_admin_op_t;\ntypedef struct rd_kafka_AdminOptions_s rd_kafka_AdminOptions_t;\nrd_kafka_AdminOptions_t *rd_kafka_AdminOptions_new(rd_kafka_t *rk, rd_kafka_admin_op_t for_api);\nvoid rd_kafka_AdminOptions_destroy(rd_kafka_AdminOptions_t *options);\nrd_kafka_resp_err_t rd_kafka_AdminOptions_set_request_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_AdminOptions_set_operation_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_AdminOptions_set_validate_only(rd_kafka_AdminOptions_t *options, int true_or_false, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_AdminOptions_set_broker(rd_kafka_AdminOptions_t *options, int32_t broker_id, char *errstr, size_t errstr_size);\nvoid rd_kafka_AdminOptions_set_opaque(rd_kafka_AdminOptions_t *options, void *ev_opaque);\ntypedef struct rd_kafka_NewTopic_s rd_kafka_NewTopic_t;\nrd_kafka_NewTopic_t *rd_kafka_NewTopic_new(const char *topic, int num_partitions, int replication_factor, char *errstr, size_t errstr_size);\nvoid rd_kafka_NewTopic_destroy(rd_kafka_NewTopic_t *new_topic);\nvoid rd_kafka_NewTopic_destroy_array(rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt);\nrd_kafka_resp_err_t rd_kafka_NewTopic_set_replica_assignment(rd_kafka_NewTopic_t *new_topic, int32_t partition, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_NewTopic_set_config(rd_kafka_NewTopic_t *new_topic, const char *name, const char *value);\nvoid rd_kafka_CreateTopics(rd_kafka_t *rk, rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_topic_result_t **rd_kafka_CreateTopics_result_topics(const rd_kafka_CreateTopics_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_DeleteTopic_s rd_kafka_DeleteTopic_t;\nrd_kafka_DeleteTopic_t *rd_kafka_DeleteTopic_new(const char *topic);\nvoid rd_kafka_DeleteTopic_destroy(rd_kafka_DeleteTopic_t *del_topic);\nvoid rd_kafka_DeleteTopic_destroy_array(rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt);\nvoid rd_kafka_DeleteTopics(rd_kafka_t *rk, rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_topic_result_t **rd_kafka_DeleteTopics_result_topics(const rd_kafka_DeleteTopics_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_NewPartitions_s rd_kafka_NewPartitions_t;\nrd_kafka_NewPartitions_t *rd_kafka_NewPartitions_new(const char *topic, size_t new_total_cnt, char *errstr, size_t errstr_size);\nvoid rd_kafka_NewPartitions_destroy(rd_kafka_NewPartitions_t *new_parts);\nvoid rd_kafka_NewPartitions_destroy_array(rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt);\nrd_kafka_resp_err_t rd_kafka_NewPartitions_set_replica_assignment(rd_kafka_NewPartitions_t *new_parts, int32_t new_partition_idx, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);\nvoid rd_kafka_CreatePartitions(rd_kafka_t *rk, rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_topic_result_t **rd_kafka_CreatePartitions_result_topics(const rd_kafka_CreatePartitions_result_t *result, size_t *cntp);\ntypedef enum rd_kafka_ConfigSource_t {\n  RD_KAFKA_CONFIG_SOURCE_UNKNOWN_CONFIG = 0,\n  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_TOPIC_CONFIG = 1,\n  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_BROKER_CONFIG = 2,\n  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_DEFAULT_BROKER_CONFIG = 3,\n  RD_KAFKA_CONFIG_SOURCE_STATIC_BROKER_CONFIG = 4,\n  RD_KAFKA_CONFIG_SOURCE_DEFAULT_CONFIG = 5,\n  RD_KAFKA_CONFIG_SOURCE__CNT,\n} rd_kafka_ConfigSource_t;\nconst char *rd_kafka_ConfigSource_name(rd_kafka_ConfigSource_t confsource);\ntypedef struct rd_kafka_ConfigEntry_s rd_kafka_ConfigEntry_t;\nconst char *rd_kafka_ConfigEntry_name(const rd_kafka_ConfigEntry_t *entry);\nconst char *rd_kafka_ConfigEntry_value(const rd_kafka_ConfigEntry_t *entry);\nrd_kafka_ConfigSource_t rd_kafka_ConfigEntry_source(const rd_kafka_ConfigEntry_t *entry);\nint rd_kafka_ConfigEntry_is_read_only(const rd_kafka_ConfigEntry_t *entry);\nint rd_kafka_ConfigEntry_is_default(const rd_kafka_ConfigEntry_t *entry);\nint rd_kafka_ConfigEntry_is_sensitive(const rd_kafka_ConfigEntry_t *entry);\nint rd_kafka_ConfigEntry_is_synonym(const rd_kafka_ConfigEntry_t *entry);\nconst rd_kafka_ConfigEntry_t **rd_kafka_ConfigEntry_synonyms(const rd_kafka_ConfigEntry_t *entry, size_t *cntp);\ntypedef enum rd_kafka_ResourceType_t {\n  RD_KAFKA_RESOURCE_UNKNOWN = 0,\n  RD_KAFKA_RESOURCE_ANY = 1,\n  RD_KAFKA_RESOURCE_TOPIC = 2,\n  RD_KAFKA_RESOURCE_GROUP = 3,\n  RD_KAFKA_RESOURCE_BROKER = 4,\n  RD_KAFKA_RESOURCE__CNT,\n} rd_kafka_ResourceType_t;\nconst char *rd_kafka_ResourceType_name(rd_kafka_ResourceType_t restype);\ntypedef struct rd_kafka_ConfigResource_s rd_kafka_ConfigResource_t;\nrd_kafka_ConfigResource_t *rd_kafka_ConfigResource_new(rd_kafka_ResourceType_t restype, const char *resname);\nvoid rd_kafka_ConfigResource_destroy(rd_kafka_ConfigResource_t *config);\nvoid rd_kafka_ConfigResource_destroy_array(rd_kafka_ConfigResource_t **config, size_t config_cnt);\nrd_kafka_resp_err_t rd_kafka_ConfigResource_set_config(rd_kafka_ConfigResource_t *config, const char *name, const char *value);\nconst rd_kafka_ConfigEntry_t **rd_kafka_ConfigResource_configs(const rd_kafka_ConfigResource_t *config, size_t *cntp);\nrd_kafka_ResourceType_t rd_kafka_ConfigResource_type(const rd_kafka_ConfigResource_t *config);\nconst char *rd_kafka_ConfigResource_name(const rd_kafka_ConfigResource_t *config);\nrd_kafka_resp_err_t rd_kafka_ConfigResource_error(const rd_kafka_ConfigResource_t *config);\nconst char *rd_kafka_ConfigResource_error_string(const rd_kafka_ConfigResource_t *config);\nvoid rd_kafka_AlterConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_ConfigResource_t **rd_kafka_AlterConfigs_result_resources(const rd_kafka_AlterConfigs_result_t *result, size_t *cntp);\nvoid rd_kafka_DescribeConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_ConfigResource_t **rd_kafka_DescribeConfigs_result_resources(const rd_kafka_DescribeConfigs_result_t *result, size_t *cntp);\nrd_kafka_resp_err_t rd_kafka_oauthbearer_set_token(rd_kafka_t *rk, const char *token_value, int64_t md_lifetime_ms, const char *md_principal_name, const char **extensions, size_t extension_size, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_oauthbearer_set_token_failure(rd_kafka_t *rk, const char *errstr);\n'\n</code></pre> rdkafka.h, rdkafka_mock.h</p>"},{"location":"api/constants/#rd_kafka_version_5","title":"RD_KAFKA_VERSION","text":"<pre><code>public RD_KAFKA_VERSION = 16909055\n</code></pre> <p>librdkafka version </p> <p>Interpreted as hex <code>MM.mm.rr.xx</code>:</p> <ul> <li>MM = Major</li> <li>mm = minor</li> <li>rr = revision</li> <li>xx = pre-release id (0xff is the final release)</li> </ul> <p>E.g.: <code>0x000801ff</code> = 0.8.1</p> RemarksThis value should only be used during compile time, for runtime checks of version use rd_kafka_version()  <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_unsupported_compression_type_5","title":"RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE","text":"<pre><code>public RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76\n</code></pre> <p>Unsupported compression type </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_end_all_5","title":"RD_KAFKA_RESP_ERR_END_ALL","text":"<p><pre><code>public RD_KAFKA_RESP_ERR_END_ALL = 82\n</code></pre> enum rd_kafka_resp_err_t</p>"},{"location":"api/constants/#rd_kafka_admin_op__cnt_5","title":"RD_KAFKA_ADMIN_OP__CNT","text":"<pre><code>public RD_KAFKA_ADMIN_OP__CNT = 6\n</code></pre> <p>Number of ops defined </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe </li> </ul>"},{"location":"api/constants/#rd_kafka_resource__cnt_5","title":"RD_KAFKA_RESOURCE__CNT","text":"<pre><code>public RD_KAFKA_RESOURCE__CNT = 5\n</code></pre> <p>Number of resource types defined </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#acca83a66d7783ff7683ed2691cc907c9 </li> </ul>"},{"location":"api/constants/#rd_kafka_cdef_5","title":"RD_KAFKA_CDEF","text":"<p><pre><code>public RD_KAFKA_CDEF = 'typedef long int ssize_t;\ntypedef struct _IO_FILE FILE;\ntypedef long int mode_t;\ntypedef signed int int16_t;\ntypedef unsigned int uint16_t;\ntypedef signed int int32_t;\ntypedef signed long int int64_t;\nint rd_kafka_version(void);\nconst char *rd_kafka_version_str(void);\ntypedef enum rd_kafka_type_t {\n  RD_KAFKA_PRODUCER,\n  RD_KAFKA_CONSUMER,\n} rd_kafka_type_t;\ntypedef enum rd_kafka_timestamp_type_t {\n  RD_KAFKA_TIMESTAMP_NOT_AVAILABLE,\n  RD_KAFKA_TIMESTAMP_CREATE_TIME,\n  RD_KAFKA_TIMESTAMP_LOG_APPEND_TIME,\n} rd_kafka_timestamp_type_t;\nconst char *rd_kafka_get_debug_contexts(void);\ntypedef struct rd_kafka_s rd_kafka_t;\ntypedef struct rd_kafka_topic_s rd_kafka_topic_t;\ntypedef struct rd_kafka_conf_s rd_kafka_conf_t;\ntypedef struct rd_kafka_topic_conf_s rd_kafka_topic_conf_t;\ntypedef struct rd_kafka_queue_s rd_kafka_queue_t;\ntypedef struct rd_kafka_op_s rd_kafka_event_t;\ntypedef struct rd_kafka_topic_result_s rd_kafka_topic_result_t;\ntypedef enum {\n  RD_KAFKA_RESP_ERR__BEGIN = (- 200),\n  RD_KAFKA_RESP_ERR__BAD_MSG = (- 199),\n  RD_KAFKA_RESP_ERR__BAD_COMPRESSION = (- 198),\n  RD_KAFKA_RESP_ERR__DESTROY = (- 197),\n  RD_KAFKA_RESP_ERR__FAIL = (- 196),\n  RD_KAFKA_RESP_ERR__TRANSPORT = (- 195),\n  RD_KAFKA_RESP_ERR__CRIT_SYS_RESOURCE = (- 194),\n  RD_KAFKA_RESP_ERR__RESOLVE = (- 193),\n  RD_KAFKA_RESP_ERR__MSG_TIMED_OUT = (- 192),\n  RD_KAFKA_RESP_ERR__PARTITION_EOF = (- 191),\n  RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION = (- 190),\n  RD_KAFKA_RESP_ERR__FS = (- 189),\n  RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC = (- 188),\n  RD_KAFKA_RESP_ERR__ALL_BROKERS_DOWN = (- 187),\n  RD_KAFKA_RESP_ERR__INVALID_ARG = (- 186),\n  RD_KAFKA_RESP_ERR__TIMED_OUT = (- 185),\n  RD_KAFKA_RESP_ERR__QUEUE_FULL = (- 184),\n  RD_KAFKA_RESP_ERR__ISR_INSUFF = (- 183),\n  RD_KAFKA_RESP_ERR__NODE_UPDATE = (- 182),\n  RD_KAFKA_RESP_ERR__SSL = (- 181),\n  RD_KAFKA_RESP_ERR__WAIT_COORD = (- 180),\n  RD_KAFKA_RESP_ERR__UNKNOWN_GROUP = (- 179),\n  RD_KAFKA_RESP_ERR__IN_PROGRESS = (- 178),\n  RD_KAFKA_RESP_ERR__PREV_IN_PROGRESS = (- 177),\n  RD_KAFKA_RESP_ERR__EXISTING_SUBSCRIPTION = (- 176),\n  RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS = (- 175),\n  RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS = (- 174),\n  RD_KAFKA_RESP_ERR__CONFLICT = (- 173),\n  RD_KAFKA_RESP_ERR__STATE = (- 172),\n  RD_KAFKA_RESP_ERR__UNKNOWN_PROTOCOL = (- 171),\n  RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED = (- 170),\n  RD_KAFKA_RESP_ERR__AUTHENTICATION = (- 169),\n  RD_KAFKA_RESP_ERR__NO_OFFSET = (- 168),\n  RD_KAFKA_RESP_ERR__OUTDATED = (- 167),\n  RD_KAFKA_RESP_ERR__TIMED_OUT_QUEUE = (- 166),\n  RD_KAFKA_RESP_ERR__UNSUPPORTED_FEATURE = (- 165),\n  RD_KAFKA_RESP_ERR__WAIT_CACHE = (- 164),\n  RD_KAFKA_RESP_ERR__INTR = (- 163),\n  RD_KAFKA_RESP_ERR__KEY_SERIALIZATION = (- 162),\n  RD_KAFKA_RESP_ERR__VALUE_SERIALIZATION = (- 161),\n  RD_KAFKA_RESP_ERR__KEY_DESERIALIZATION = (- 160),\n  RD_KAFKA_RESP_ERR__VALUE_DESERIALIZATION = (- 159),\n  RD_KAFKA_RESP_ERR__PARTIAL = (- 158),\n  RD_KAFKA_RESP_ERR__READ_ONLY = (- 157),\n  RD_KAFKA_RESP_ERR__NOENT = (- 156),\n  RD_KAFKA_RESP_ERR__UNDERFLOW = (- 155),\n  RD_KAFKA_RESP_ERR__INVALID_TYPE = (- 154),\n  RD_KAFKA_RESP_ERR__RETRY = (- 153),\n  RD_KAFKA_RESP_ERR__PURGE_QUEUE = (- 152),\n  RD_KAFKA_RESP_ERR__PURGE_INFLIGHT = (- 151),\n  RD_KAFKA_RESP_ERR__FATAL = (- 150),\n  RD_KAFKA_RESP_ERR__INCONSISTENT = (- 149),\n  RD_KAFKA_RESP_ERR__GAPLESS_GUARANTEE = (- 148),\n  RD_KAFKA_RESP_ERR__MAX_POLL_EXCEEDED = (- 147),\n  RD_KAFKA_RESP_ERR__END = (- 100),\n  RD_KAFKA_RESP_ERR_UNKNOWN = (- 1),\n  RD_KAFKA_RESP_ERR_NO_ERROR = 0,\n  RD_KAFKA_RESP_ERR_OFFSET_OUT_OF_RANGE = 1,\n  RD_KAFKA_RESP_ERR_INVALID_MSG = 2,\n  RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART = 3,\n  RD_KAFKA_RESP_ERR_INVALID_MSG_SIZE = 4,\n  RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE = 5,\n  RD_KAFKA_RESP_ERR_NOT_LEADER_FOR_PARTITION = 6,\n  RD_KAFKA_RESP_ERR_REQUEST_TIMED_OUT = 7,\n  RD_KAFKA_RESP_ERR_BROKER_NOT_AVAILABLE = 8,\n  RD_KAFKA_RESP_ERR_REPLICA_NOT_AVAILABLE = 9,\n  RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE = 10,\n  RD_KAFKA_RESP_ERR_STALE_CTRL_EPOCH = 11,\n  RD_KAFKA_RESP_ERR_OFFSET_METADATA_TOO_LARGE = 12,\n  RD_KAFKA_RESP_ERR_NETWORK_EXCEPTION = 13,\n  RD_KAFKA_RESP_ERR_GROUP_LOAD_IN_PROGRESS = 14,\n  RD_KAFKA_RESP_ERR_GROUP_COORDINATOR_NOT_AVAILABLE = 15,\n  RD_KAFKA_RESP_ERR_NOT_COORDINATOR_FOR_GROUP = 16,\n  RD_KAFKA_RESP_ERR_TOPIC_EXCEPTION = 17,\n  RD_KAFKA_RESP_ERR_RECORD_LIST_TOO_LARGE = 18,\n  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS = 19,\n  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS_AFTER_APPEND = 20,\n  RD_KAFKA_RESP_ERR_INVALID_REQUIRED_ACKS = 21,\n  RD_KAFKA_RESP_ERR_ILLEGAL_GENERATION = 22,\n  RD_KAFKA_RESP_ERR_INCONSISTENT_GROUP_PROTOCOL = 23,\n  RD_KAFKA_RESP_ERR_INVALID_GROUP_ID = 24,\n  RD_KAFKA_RESP_ERR_UNKNOWN_MEMBER_ID = 25,\n  RD_KAFKA_RESP_ERR_INVALID_SESSION_TIMEOUT = 26,\n  RD_KAFKA_RESP_ERR_REBALANCE_IN_PROGRESS = 27,\n  RD_KAFKA_RESP_ERR_INVALID_COMMIT_OFFSET_SIZE = 28,\n  RD_KAFKA_RESP_ERR_TOPIC_AUTHORIZATION_FAILED = 29,\n  RD_KAFKA_RESP_ERR_GROUP_AUTHORIZATION_FAILED = 30,\n  RD_KAFKA_RESP_ERR_CLUSTER_AUTHORIZATION_FAILED = 31,\n  RD_KAFKA_RESP_ERR_INVALID_TIMESTAMP = 32,\n  RD_KAFKA_RESP_ERR_UNSUPPORTED_SASL_MECHANISM = 33,\n  RD_KAFKA_RESP_ERR_ILLEGAL_SASL_STATE = 34,\n  RD_KAFKA_RESP_ERR_UNSUPPORTED_VERSION = 35,\n  RD_KAFKA_RESP_ERR_TOPIC_ALREADY_EXISTS = 36,\n  RD_KAFKA_RESP_ERR_INVALID_PARTITIONS = 37,\n  RD_KAFKA_RESP_ERR_INVALID_REPLICATION_FACTOR = 38,\n  RD_KAFKA_RESP_ERR_INVALID_REPLICA_ASSIGNMENT = 39,\n  RD_KAFKA_RESP_ERR_INVALID_CONFIG = 40,\n  RD_KAFKA_RESP_ERR_NOT_CONTROLLER = 41,\n  RD_KAFKA_RESP_ERR_INVALID_REQUEST = 42,\n  RD_KAFKA_RESP_ERR_UNSUPPORTED_FOR_MESSAGE_FORMAT = 43,\n  RD_KAFKA_RESP_ERR_POLICY_VIOLATION = 44,\n  RD_KAFKA_RESP_ERR_OUT_OF_ORDER_SEQUENCE_NUMBER = 45,\n  RD_KAFKA_RESP_ERR_DUPLICATE_SEQUENCE_NUMBER = 46,\n  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_EPOCH = 47,\n  RD_KAFKA_RESP_ERR_INVALID_TXN_STATE = 48,\n  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_ID_MAPPING = 49,\n  RD_KAFKA_RESP_ERR_INVALID_TRANSACTION_TIMEOUT = 50,\n  RD_KAFKA_RESP_ERR_CONCURRENT_TRANSACTIONS = 51,\n  RD_KAFKA_RESP_ERR_TRANSACTION_COORDINATOR_FENCED = 52,\n  RD_KAFKA_RESP_ERR_TRANSACTIONAL_ID_AUTHORIZATION_FAILED = 53,\n  RD_KAFKA_RESP_ERR_SECURITY_DISABLED = 54,\n  RD_KAFKA_RESP_ERR_OPERATION_NOT_ATTEMPTED = 55,\n  RD_KAFKA_RESP_ERR_KAFKA_STORAGE_ERROR = 56,\n  RD_KAFKA_RESP_ERR_LOG_DIR_NOT_FOUND = 57,\n  RD_KAFKA_RESP_ERR_SASL_AUTHENTICATION_FAILED = 58,\n  RD_KAFKA_RESP_ERR_UNKNOWN_PRODUCER_ID = 59,\n  RD_KAFKA_RESP_ERR_REASSIGNMENT_IN_PROGRESS = 60,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTH_DISABLED = 61,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_NOT_FOUND = 62,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_OWNER_MISMATCH = 63,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_REQUEST_NOT_ALLOWED = 64,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTHORIZATION_FAILED = 65,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_EXPIRED = 66,\n  RD_KAFKA_RESP_ERR_INVALID_PRINCIPAL_TYPE = 67,\n  RD_KAFKA_RESP_ERR_NON_EMPTY_GROUP = 68,\n  RD_KAFKA_RESP_ERR_GROUP_ID_NOT_FOUND = 69,\n  RD_KAFKA_RESP_ERR_FETCH_SESSION_ID_NOT_FOUND = 70,\n  RD_KAFKA_RESP_ERR_INVALID_FETCH_SESSION_EPOCH = 71,\n  RD_KAFKA_RESP_ERR_LISTENER_NOT_FOUND = 72,\n  RD_KAFKA_RESP_ERR_TOPIC_DELETION_DISABLED = 73,\n  RD_KAFKA_RESP_ERR_FENCED_LEADER_EPOCH = 74,\n  RD_KAFKA_RESP_ERR_UNKNOWN_LEADER_EPOCH = 75,\n  RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76,\n  RD_KAFKA_RESP_ERR_STALE_BROKER_EPOCH = 77,\n  RD_KAFKA_RESP_ERR_OFFSET_NOT_AVAILABLE = 78,\n  RD_KAFKA_RESP_ERR_MEMBER_ID_REQUIRED = 79,\n  RD_KAFKA_RESP_ERR_PREFERRED_LEADER_NOT_AVAILABLE = 80,\n  RD_KAFKA_RESP_ERR_GROUP_MAX_SIZE_REACHED = 81,\n  RD_KAFKA_RESP_ERR_END_ALL,\n} rd_kafka_resp_err_t;\nstruct rd_kafka_err_desc {\n  rd_kafka_resp_err_t code;\n  char *name;\n  char *desc;\n};\nvoid rd_kafka_get_err_descs(const struct rd_kafka_err_desc **errdescs, size_t *cntp);\nconst char *rd_kafka_err2str(rd_kafka_resp_err_t err);\nconst char *rd_kafka_err2name(rd_kafka_resp_err_t err);\nrd_kafka_resp_err_t rd_kafka_last_error(void);\nrd_kafka_resp_err_t rd_kafka_errno2err(int errnox);\nint rd_kafka_errno(void);\nrd_kafka_resp_err_t rd_kafka_fatal_error(rd_kafka_t *rk, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_test_fatal_error(rd_kafka_t *rk, rd_kafka_resp_err_t err, const char *reason);\ntypedef struct rd_kafka_topic_partition_s {\n  char *topic;\n  int32_t partition;\n  int64_t offset;\n  void *metadata;\n  size_t metadata_size;\n  void *opaque;\n  rd_kafka_resp_err_t err;\n  void *_private;\n} rd_kafka_topic_partition_t;\nvoid rd_kafka_topic_partition_destroy(rd_kafka_topic_partition_t *rktpar);\ntypedef struct rd_kafka_topic_partition_list_s {\n  int cnt;\n  int size;\n  rd_kafka_topic_partition_t *elems;\n} rd_kafka_topic_partition_list_t;\nrd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_new(int size);\nvoid rd_kafka_topic_partition_list_destroy(rd_kafka_topic_partition_list_t *rkparlist);\nrd_kafka_topic_partition_t *rd_kafka_topic_partition_list_add(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);\nvoid rd_kafka_topic_partition_list_add_range(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t start, int32_t stop);\nint rd_kafka_topic_partition_list_del(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);\nint rd_kafka_topic_partition_list_del_by_idx(rd_kafka_topic_partition_list_t *rktparlist, int idx);\nrd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_copy(const rd_kafka_topic_partition_list_t *src);\nrd_kafka_resp_err_t rd_kafka_topic_partition_list_set_offset(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition, int64_t offset);\nrd_kafka_topic_partition_t *rd_kafka_topic_partition_list_find(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);\nvoid rd_kafka_topic_partition_list_sort(rd_kafka_topic_partition_list_t *rktparlist, int (*cmp)(const void *a, const void *b, void *cmp_opaque), void *cmp_opaque);\ntypedef enum rd_kafka_vtype_t {\n  RD_KAFKA_VTYPE_END,\n  RD_KAFKA_VTYPE_TOPIC,\n  RD_KAFKA_VTYPE_RKT,\n  RD_KAFKA_VTYPE_PARTITION,\n  RD_KAFKA_VTYPE_VALUE,\n  RD_KAFKA_VTYPE_KEY,\n  RD_KAFKA_VTYPE_OPAQUE,\n  RD_KAFKA_VTYPE_MSGFLAGS,\n  RD_KAFKA_VTYPE_TIMESTAMP,\n  RD_KAFKA_VTYPE_HEADER,\n  RD_KAFKA_VTYPE_HEADERS,\n} rd_kafka_vtype_t;\ntypedef struct rd_kafka_headers_s rd_kafka_headers_t;\nrd_kafka_headers_t *rd_kafka_headers_new(size_t initial_count);\nvoid rd_kafka_headers_destroy(rd_kafka_headers_t *hdrs);\nrd_kafka_headers_t *rd_kafka_headers_copy(const rd_kafka_headers_t *src);\nrd_kafka_resp_err_t rd_kafka_header_add(rd_kafka_headers_t *hdrs, const char *name, ssize_t name_size, const void *value, ssize_t value_size);\nrd_kafka_resp_err_t rd_kafka_header_remove(rd_kafka_headers_t *hdrs, const char *name);\nrd_kafka_resp_err_t rd_kafka_header_get_last(const rd_kafka_headers_t *hdrs, const char *name, const void **valuep, size_t *sizep);\nrd_kafka_resp_err_t rd_kafka_header_get(const rd_kafka_headers_t *hdrs, size_t idx, const char *name, const void **valuep, size_t *sizep);\nrd_kafka_resp_err_t rd_kafka_header_get_all(const rd_kafka_headers_t *hdrs, size_t idx, const char **namep, const void **valuep, size_t *sizep);\ntypedef struct rd_kafka_message_s {\n  rd_kafka_resp_err_t err;\n  rd_kafka_topic_t *rkt;\n  int32_t partition;\n  void *payload;\n  size_t len;\n  void *key;\n  size_t key_len;\n  int64_t offset;\n  void *_private;\n} rd_kafka_message_t;\nvoid rd_kafka_message_destroy(rd_kafka_message_t *rkmessage);\nint64_t rd_kafka_message_timestamp(const rd_kafka_message_t *rkmessage, rd_kafka_timestamp_type_t *tstype);\nint64_t rd_kafka_message_latency(const rd_kafka_message_t *rkmessage);\nrd_kafka_resp_err_t rd_kafka_message_headers(const rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);\nrd_kafka_resp_err_t rd_kafka_message_detach_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);\nvoid rd_kafka_message_set_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t *hdrs);\nsize_t rd_kafka_header_cnt(const rd_kafka_headers_t *hdrs);\ntypedef enum {\n  RD_KAFKA_MSG_STATUS_NOT_PERSISTED = 0,\n  RD_KAFKA_MSG_STATUS_POSSIBLY_PERSISTED = 1,\n  RD_KAFKA_MSG_STATUS_PERSISTED = 2,\n} rd_kafka_msg_status_t;\nrd_kafka_msg_status_t rd_kafka_message_status(const rd_kafka_message_t *rkmessage);\ntypedef enum {\n  RD_KAFKA_CONF_UNKNOWN = (- 2),\n  RD_KAFKA_CONF_INVALID = (- 1),\n  RD_KAFKA_CONF_OK = 0,\n} rd_kafka_conf_res_t;\nrd_kafka_conf_t *rd_kafka_conf_new(void);\nvoid rd_kafka_conf_destroy(rd_kafka_conf_t *conf);\nrd_kafka_conf_t *rd_kafka_conf_dup(const rd_kafka_conf_t *conf);\nrd_kafka_conf_t *rd_kafka_conf_dup_filter(const rd_kafka_conf_t *conf, size_t filter_cnt, const char **filter);\nconst rd_kafka_conf_t *rd_kafka_conf(rd_kafka_t *rk);\nrd_kafka_conf_res_t rd_kafka_conf_set(rd_kafka_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);\nvoid rd_kafka_conf_set_events(rd_kafka_conf_t *conf, int events);\nvoid rd_kafka_conf_set_background_event_cb(rd_kafka_conf_t *conf, void (*event_cb)(rd_kafka_t *rk, rd_kafka_event_t *rkev, void *opaque));\nvoid rd_kafka_conf_set_dr_cb(rd_kafka_conf_t *conf, void (*dr_cb)(rd_kafka_t *rk, void *payload, size_t len, rd_kafka_resp_err_t err, void *opaque, void *msg_opaque));\nvoid rd_kafka_conf_set_dr_msg_cb(rd_kafka_conf_t *conf, void (*dr_msg_cb)(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, void *opaque));\nvoid rd_kafka_conf_set_consume_cb(rd_kafka_conf_t *conf, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *opaque));\nvoid rd_kafka_conf_set_rebalance_cb(rd_kafka_conf_t *conf, void (*rebalance_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *partitions, void *opaque));\nvoid rd_kafka_conf_set_offset_commit_cb(rd_kafka_conf_t *conf, void (*offset_commit_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *opaque));\nvoid rd_kafka_conf_set_error_cb(rd_kafka_conf_t *conf, void (*error_cb)(rd_kafka_t *rk, int err, const char *reason, void *opaque));\nvoid rd_kafka_conf_set_throttle_cb(rd_kafka_conf_t *conf, void (*throttle_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int throttle_time_ms, void *opaque));\nvoid rd_kafka_conf_set_log_cb(rd_kafka_conf_t *conf, void (*log_cb)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));\nvoid rd_kafka_conf_set_stats_cb(rd_kafka_conf_t *conf, int (*stats_cb)(rd_kafka_t *rk, char *json, size_t json_len, void *opaque));\nvoid rd_kafka_conf_set_oauthbearer_token_refresh_cb(rd_kafka_conf_t *conf, void (*oauthbearer_token_refresh_cb)(rd_kafka_t *rk, const char *oauthbearer_config, void *opaque));\nvoid rd_kafka_conf_set_socket_cb(rd_kafka_conf_t *conf, int (*socket_cb)(int domain, int type, int protocol, void *opaque));\nvoid rd_kafka_conf_set_connect_cb(rd_kafka_conf_t *conf, int (*connect_cb)(int sockfd, const struct sockaddr *addr, int addrlen, const char *id, void *opaque));\nvoid rd_kafka_conf_set_closesocket_cb(rd_kafka_conf_t *conf, int (*closesocket_cb)(int sockfd, void *opaque));\nrd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert_verify_cb(rd_kafka_conf_t *conf, int (*ssl_cert_verify_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int *x509_error, int depth, const char *buf, size_t size, char *errstr, size_t errstr_size, void *opaque));\ntypedef enum rd_kafka_cert_type_t {\n  RD_KAFKA_CERT_PUBLIC_KEY,\n  RD_KAFKA_CERT_PRIVATE_KEY,\n  RD_KAFKA_CERT_CA,\n  RD_KAFKA_CERT__CNT,\n} rd_kafka_cert_type_t;\ntypedef enum rd_kafka_cert_enc_t {\n  RD_KAFKA_CERT_ENC_PKCS12,\n  RD_KAFKA_CERT_ENC_DER,\n  RD_KAFKA_CERT_ENC_PEM,\n  RD_KAFKA_CERT_ENC__CNT,\n} rd_kafka_cert_enc_t;\nrd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert(rd_kafka_conf_t *conf, rd_kafka_cert_type_t cert_type, rd_kafka_cert_enc_t cert_enc, const void *buffer, size_t size, char *errstr, size_t errstr_size);\nvoid rd_kafka_conf_set_opaque(rd_kafka_conf_t *conf, void *opaque);\nvoid *rd_kafka_opaque(const rd_kafka_t *rk);\nvoid rd_kafka_conf_set_default_topic_conf(rd_kafka_conf_t *conf, rd_kafka_topic_conf_t *tconf);\nrd_kafka_conf_res_t rd_kafka_conf_get(const rd_kafka_conf_t *conf, const char *name, char *dest, size_t *dest_size);\nrd_kafka_conf_res_t rd_kafka_topic_conf_get(const rd_kafka_topic_conf_t *conf, const char *name, char *dest, size_t *dest_size);\nconst char **rd_kafka_conf_dump(rd_kafka_conf_t *conf, size_t *cntp);\nconst char **rd_kafka_topic_conf_dump(rd_kafka_topic_conf_t *conf, size_t *cntp);\nvoid rd_kafka_conf_dump_free(const char **arr, size_t cnt);\nvoid rd_kafka_conf_properties_show(FILE *fp);\nrd_kafka_topic_conf_t *rd_kafka_topic_conf_new(void);\nrd_kafka_topic_conf_t *rd_kafka_topic_conf_dup(const rd_kafka_topic_conf_t *conf);\nrd_kafka_topic_conf_t *rd_kafka_default_topic_conf_dup(rd_kafka_t *rk);\nvoid rd_kafka_topic_conf_destroy(rd_kafka_topic_conf_t *topic_conf);\nrd_kafka_conf_res_t rd_kafka_topic_conf_set(rd_kafka_topic_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);\nvoid rd_kafka_topic_conf_set_opaque(rd_kafka_topic_conf_t *conf, void *rkt_opaque);\nvoid rd_kafka_topic_conf_set_partitioner_cb(rd_kafka_topic_conf_t *topic_conf, int32_t (*partitioner)(const rd_kafka_topic_t *rkt, const void *keydata, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque));\nvoid rd_kafka_topic_conf_set_msg_order_cmp(rd_kafka_topic_conf_t *topic_conf, int (*msg_order_cmp)(const rd_kafka_message_t *a, const rd_kafka_message_t *b));\nint rd_kafka_topic_partition_available(const rd_kafka_topic_t *rkt, int32_t partition);\nint32_t rd_kafka_msg_partitioner_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_consistent(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_consistent_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_murmur2(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_murmur2_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nrd_kafka_t *rd_kafka_new(rd_kafka_type_t type, rd_kafka_conf_t *conf, char *errstr, size_t errstr_size);\nvoid rd_kafka_destroy(rd_kafka_t *rk);\nvoid rd_kafka_destroy_flags(rd_kafka_t *rk, int flags);\nconst char *rd_kafka_name(const rd_kafka_t *rk);\nrd_kafka_type_t rd_kafka_type(const rd_kafka_t *rk);\nchar *rd_kafka_memberid(const rd_kafka_t *rk);\nchar *rd_kafka_clusterid(rd_kafka_t *rk, int timeout_ms);\nint32_t rd_kafka_controllerid(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_topic_t *rd_kafka_topic_new(rd_kafka_t *rk, const char *topic, rd_kafka_topic_conf_t *conf);\nvoid rd_kafka_topic_destroy(rd_kafka_topic_t *rkt);\nconst char *rd_kafka_topic_name(const rd_kafka_topic_t *rkt);\nvoid *rd_kafka_topic_opaque(const rd_kafka_topic_t *rkt);\nint rd_kafka_poll(rd_kafka_t *rk, int timeout_ms);\nvoid rd_kafka_yield(rd_kafka_t *rk);\nrd_kafka_resp_err_t rd_kafka_pause_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_resp_err_t rd_kafka_resume_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_resp_err_t rd_kafka_query_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high, int timeout_ms);\nrd_kafka_resp_err_t rd_kafka_get_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high);\nrd_kafka_resp_err_t rd_kafka_offsets_for_times(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets, int timeout_ms);\nvoid rd_kafka_mem_free(rd_kafka_t *rk, void *ptr);\nrd_kafka_queue_t *rd_kafka_queue_new(rd_kafka_t *rk);\nvoid rd_kafka_queue_destroy(rd_kafka_queue_t *rkqu);\nrd_kafka_queue_t *rd_kafka_queue_get_main(rd_kafka_t *rk);\nrd_kafka_queue_t *rd_kafka_queue_get_consumer(rd_kafka_t *rk);\nrd_kafka_queue_t *rd_kafka_queue_get_partition(rd_kafka_t *rk, const char *topic, int32_t partition);\nrd_kafka_queue_t *rd_kafka_queue_get_background(rd_kafka_t *rk);\nvoid rd_kafka_queue_forward(rd_kafka_queue_t *src, rd_kafka_queue_t *dst);\nrd_kafka_resp_err_t rd_kafka_set_log_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu);\nsize_t rd_kafka_queue_length(rd_kafka_queue_t *rkqu);\nvoid rd_kafka_queue_io_event_enable(rd_kafka_queue_t *rkqu, int fd, const void *payload, size_t size);\nvoid rd_kafka_queue_cb_event_enable(rd_kafka_queue_t *rkqu, void (*event_cb)(rd_kafka_t *rk, void *qev_opaque), void *qev_opaque);\nint rd_kafka_consume_start(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);\nint rd_kafka_consume_start_queue(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, rd_kafka_queue_t *rkqu);\nint rd_kafka_consume_stop(rd_kafka_topic_t *rkt, int32_t partition);\nrd_kafka_resp_err_t rd_kafka_seek(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, int timeout_ms);\nrd_kafka_message_t *rd_kafka_consume(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms);\nssize_t rd_kafka_consume_batch(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);\nint rd_kafka_consume_callback(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);\nrd_kafka_message_t *rd_kafka_consume_queue(rd_kafka_queue_t *rkqu, int timeout_ms);\nssize_t rd_kafka_consume_batch_queue(rd_kafka_queue_t *rkqu, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);\nint rd_kafka_consume_callback_queue(rd_kafka_queue_t *rkqu, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);\nrd_kafka_resp_err_t rd_kafka_offset_store(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);\nrd_kafka_resp_err_t rd_kafka_offsets_store(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets);\nrd_kafka_resp_err_t rd_kafka_subscribe(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *topics);\nrd_kafka_resp_err_t rd_kafka_unsubscribe(rd_kafka_t *rk);\nrd_kafka_resp_err_t rd_kafka_subscription(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **topics);\nrd_kafka_message_t *rd_kafka_consumer_poll(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_resp_err_t rd_kafka_consumer_close(rd_kafka_t *rk);\nrd_kafka_resp_err_t rd_kafka_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_resp_err_t rd_kafka_assignment(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **partitions);\nrd_kafka_resp_err_t rd_kafka_commit(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, int async);\nrd_kafka_resp_err_t rd_kafka_commit_message(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, int async);\nrd_kafka_resp_err_t rd_kafka_commit_queue(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_queue_t *rkqu, void (*cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *commit_opaque), void *commit_opaque);\nrd_kafka_resp_err_t rd_kafka_committed(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms);\nrd_kafka_resp_err_t rd_kafka_position(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);\nint rd_kafka_produce(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, void *payload, size_t len, const void *key, size_t keylen, void *msg_opaque);\nrd_kafka_resp_err_t rd_kafka_producev(rd_kafka_t *rk, ...);\nint rd_kafka_produce_batch(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, rd_kafka_message_t *rkmessages, int message_cnt);\nrd_kafka_resp_err_t rd_kafka_flush(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_resp_err_t rd_kafka_purge(rd_kafka_t *rk, int purge_flags);\ntypedef struct rd_kafka_metadata_broker {\n  int32_t id;\n  char *host;\n  int port;\n} rd_kafka_metadata_broker_t;\ntypedef struct rd_kafka_metadata_partition {\n  int32_t id;\n  rd_kafka_resp_err_t err;\n  int32_t leader;\n  int replica_cnt;\n  int32_t *replicas;\n  int isr_cnt;\n  int32_t *isrs;\n} rd_kafka_metadata_partition_t;\ntypedef struct rd_kafka_metadata_topic {\n  char *topic;\n  int partition_cnt;\n  struct rd_kafka_metadata_partition *partitions;\n  rd_kafka_resp_err_t err;\n} rd_kafka_metadata_topic_t;\ntypedef struct rd_kafka_metadata {\n  int broker_cnt;\n  struct rd_kafka_metadata_broker *brokers;\n  int topic_cnt;\n  struct rd_kafka_metadata_topic *topics;\n  int32_t orig_broker_id;\n  char *orig_broker_name;\n} rd_kafka_metadata_t;\nrd_kafka_resp_err_t rd_kafka_metadata(rd_kafka_t *rk, int all_topics, rd_kafka_topic_t *only_rkt, const struct rd_kafka_metadata **metadatap, int timeout_ms);\nvoid rd_kafka_metadata_destroy(const struct rd_kafka_metadata *metadata);\nstruct rd_kafka_group_member_info {\n  char *member_id;\n  char *client_id;\n  char *client_host;\n  void *member_metadata;\n  int member_metadata_size;\n  void *member_assignment;\n  int member_assignment_size;\n};\nstruct rd_kafka_group_info {\n  struct rd_kafka_metadata_broker broker;\n  char *group;\n  rd_kafka_resp_err_t err;\n  char *state;\n  char *protocol_type;\n  char *protocol;\n  struct rd_kafka_group_member_info *members;\n  int member_cnt;\n};\nstruct rd_kafka_group_list {\n  struct rd_kafka_group_info *groups;\n  int group_cnt;\n};\nrd_kafka_resp_err_t rd_kafka_list_groups(rd_kafka_t *rk, const char *group, const struct rd_kafka_group_list **grplistp, int timeout_ms);\nvoid rd_kafka_group_list_destroy(const struct rd_kafka_group_list *grplist);\nint rd_kafka_brokers_add(rd_kafka_t *rk, const char *brokerlist);\nvoid rd_kafka_set_logger(rd_kafka_t *rk, void (*func)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));\nvoid rd_kafka_set_log_level(rd_kafka_t *rk, int level);\nvoid rd_kafka_log_print(const rd_kafka_t *rk, int level, const char *fac, const char *buf);\nvoid rd_kafka_log_syslog(const rd_kafka_t *rk, int level, const char *fac, const char *buf);\nint rd_kafka_outq_len(rd_kafka_t *rk);\nvoid rd_kafka_dump(FILE *fp, rd_kafka_t *rk);\nint rd_kafka_thread_cnt(void);\ntypedef enum rd_kafka_thread_type_t {\n  RD_KAFKA_THREAD_MAIN,\n  RD_KAFKA_THREAD_BACKGROUND,\n  RD_KAFKA_THREAD_BROKER,\n} rd_kafka_thread_type_t;\nint rd_kafka_wait_destroyed(int timeout_ms);\nint rd_kafka_unittest(void);\nrd_kafka_resp_err_t rd_kafka_poll_set_consumer(rd_kafka_t *rk);\ntypedef int rd_kafka_event_type_t;\nrd_kafka_event_type_t rd_kafka_event_type(const rd_kafka_event_t *rkev);\nconst char *rd_kafka_event_name(const rd_kafka_event_t *rkev);\nvoid rd_kafka_event_destroy(rd_kafka_event_t *rkev);\nconst rd_kafka_message_t *rd_kafka_event_message_next(rd_kafka_event_t *rkev);\nsize_t rd_kafka_event_message_array(rd_kafka_event_t *rkev, const rd_kafka_message_t **rkmessages, size_t size);\nsize_t rd_kafka_event_message_count(rd_kafka_event_t *rkev);\nconst char *rd_kafka_event_config_string(rd_kafka_event_t *rkev);\nrd_kafka_resp_err_t rd_kafka_event_error(rd_kafka_event_t *rkev);\nconst char *rd_kafka_event_error_string(rd_kafka_event_t *rkev);\nint rd_kafka_event_error_is_fatal(rd_kafka_event_t *rkev);\nvoid *rd_kafka_event_opaque(rd_kafka_event_t *rkev);\nint rd_kafka_event_log(rd_kafka_event_t *rkev, const char **fac, const char **str, int *level);\nconst char *rd_kafka_event_stats(rd_kafka_event_t *rkev);\nrd_kafka_topic_partition_list_t *rd_kafka_event_topic_partition_list(rd_kafka_event_t *rkev);\nrd_kafka_topic_partition_t *rd_kafka_event_topic_partition(rd_kafka_event_t *rkev);\ntypedef rd_kafka_event_t rd_kafka_CreateTopics_result_t;\ntypedef rd_kafka_event_t rd_kafka_DeleteTopics_result_t;\ntypedef rd_kafka_event_t rd_kafka_CreatePartitions_result_t;\ntypedef rd_kafka_event_t rd_kafka_AlterConfigs_result_t;\ntypedef rd_kafka_event_t rd_kafka_DescribeConfigs_result_t;\nconst rd_kafka_CreateTopics_result_t *rd_kafka_event_CreateTopics_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DeleteTopics_result_t *rd_kafka_event_DeleteTopics_result(rd_kafka_event_t *rkev);\nconst rd_kafka_CreatePartitions_result_t *rd_kafka_event_CreatePartitions_result(rd_kafka_event_t *rkev);\nconst rd_kafka_AlterConfigs_result_t *rd_kafka_event_AlterConfigs_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DescribeConfigs_result_t *rd_kafka_event_DescribeConfigs_result(rd_kafka_event_t *rkev);\nrd_kafka_event_t *rd_kafka_queue_poll(rd_kafka_queue_t *rkqu, int timeout_ms);\nint rd_kafka_queue_poll_callback(rd_kafka_queue_t *rkqu, int timeout_ms);\ntypedef rd_kafka_resp_err_t (rd_kafka_plugin_f_conf_init_t)(rd_kafka_conf_t *conf, void **plug_opaquep, char *errstr, size_t errstr_size);\ntypedef rd_kafka_conf_res_t (rd_kafka_interceptor_f_on_conf_set_t)(rd_kafka_conf_t *conf, const char *name, const char *val, char *errstr, size_t errstr_size, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_dup_t)(rd_kafka_conf_t *new_conf, const rd_kafka_conf_t *old_conf, size_t filter_cnt, const char **filter, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_destroy_t)(void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_new_t)(rd_kafka_t *rk, const rd_kafka_conf_t *conf, void *ic_opaque, char *errstr, size_t errstr_size);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_destroy_t)(rd_kafka_t *rk, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_send_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_acknowledgement_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_consume_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_commit_t)(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_resp_err_t err, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_request_sent_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_start_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_exit_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_set(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_set_t *on_conf_set, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_dup(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_dup_t *on_conf_dup, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_destroy(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_destroy_t *on_conf_destroy, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_new(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_new_t *on_new, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_destroy(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_destroy_t *on_destroy, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_send(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_send_t *on_send, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_acknowledgement(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_acknowledgement_t *on_acknowledgement, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_consume(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_consume_t *on_consume, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_commit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_commit_t *on_commit, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_request_sent(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_request_sent_t *on_request_sent, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_start(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_start_t *on_thread_start, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_exit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_exit_t *on_thread_exit, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_topic_result_error(const rd_kafka_topic_result_t *topicres);\nconst char *rd_kafka_topic_result_error_string(const rd_kafka_topic_result_t *topicres);\nconst char *rd_kafka_topic_result_name(const rd_kafka_topic_result_t *topicres);\ntypedef enum rd_kafka_admin_op_t {\n  RD_KAFKA_ADMIN_OP_ANY = 0,\n  RD_KAFKA_ADMIN_OP_CREATETOPICS,\n  RD_KAFKA_ADMIN_OP_DELETETOPICS,\n  RD_KAFKA_ADMIN_OP_CREATEPARTITIONS,\n  RD_KAFKA_ADMIN_OP_ALTERCONFIGS,\n  RD_KAFKA_ADMIN_OP_DESCRIBECONFIGS,\n  RD_KAFKA_ADMIN_OP__CNT,\n} rd_kafka_admin_op_t;\ntypedef struct rd_kafka_AdminOptions_s rd_kafka_AdminOptions_t;\nrd_kafka_AdminOptions_t *rd_kafka_AdminOptions_new(rd_kafka_t *rk, rd_kafka_admin_op_t for_api);\nvoid rd_kafka_AdminOptions_destroy(rd_kafka_AdminOptions_t *options);\nrd_kafka_resp_err_t rd_kafka_AdminOptions_set_request_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_AdminOptions_set_operation_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_AdminOptions_set_validate_only(rd_kafka_AdminOptions_t *options, int true_or_false, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_AdminOptions_set_broker(rd_kafka_AdminOptions_t *options, int32_t broker_id, char *errstr, size_t errstr_size);\nvoid rd_kafka_AdminOptions_set_opaque(rd_kafka_AdminOptions_t *options, void *ev_opaque);\ntypedef struct rd_kafka_NewTopic_s rd_kafka_NewTopic_t;\nrd_kafka_NewTopic_t *rd_kafka_NewTopic_new(const char *topic, int num_partitions, int replication_factor, char *errstr, size_t errstr_size);\nvoid rd_kafka_NewTopic_destroy(rd_kafka_NewTopic_t *new_topic);\nvoid rd_kafka_NewTopic_destroy_array(rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt);\nrd_kafka_resp_err_t rd_kafka_NewTopic_set_replica_assignment(rd_kafka_NewTopic_t *new_topic, int32_t partition, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_NewTopic_set_config(rd_kafka_NewTopic_t *new_topic, const char *name, const char *value);\nvoid rd_kafka_CreateTopics(rd_kafka_t *rk, rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_topic_result_t **rd_kafka_CreateTopics_result_topics(const rd_kafka_CreateTopics_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_DeleteTopic_s rd_kafka_DeleteTopic_t;\nrd_kafka_DeleteTopic_t *rd_kafka_DeleteTopic_new(const char *topic);\nvoid rd_kafka_DeleteTopic_destroy(rd_kafka_DeleteTopic_t *del_topic);\nvoid rd_kafka_DeleteTopic_destroy_array(rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt);\nvoid rd_kafka_DeleteTopics(rd_kafka_t *rk, rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_topic_result_t **rd_kafka_DeleteTopics_result_topics(const rd_kafka_DeleteTopics_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_NewPartitions_s rd_kafka_NewPartitions_t;\nrd_kafka_NewPartitions_t *rd_kafka_NewPartitions_new(const char *topic, size_t new_total_cnt, char *errstr, size_t errstr_size);\nvoid rd_kafka_NewPartitions_destroy(rd_kafka_NewPartitions_t *new_parts);\nvoid rd_kafka_NewPartitions_destroy_array(rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt);\nrd_kafka_resp_err_t rd_kafka_NewPartitions_set_replica_assignment(rd_kafka_NewPartitions_t *new_parts, int32_t new_partition_idx, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);\nvoid rd_kafka_CreatePartitions(rd_kafka_t *rk, rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_topic_result_t **rd_kafka_CreatePartitions_result_topics(const rd_kafka_CreatePartitions_result_t *result, size_t *cntp);\ntypedef enum rd_kafka_ConfigSource_t {\n  RD_KAFKA_CONFIG_SOURCE_UNKNOWN_CONFIG = 0,\n  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_TOPIC_CONFIG = 1,\n  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_BROKER_CONFIG = 2,\n  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_DEFAULT_BROKER_CONFIG = 3,\n  RD_KAFKA_CONFIG_SOURCE_STATIC_BROKER_CONFIG = 4,\n  RD_KAFKA_CONFIG_SOURCE_DEFAULT_CONFIG = 5,\n  RD_KAFKA_CONFIG_SOURCE__CNT,\n} rd_kafka_ConfigSource_t;\nconst char *rd_kafka_ConfigSource_name(rd_kafka_ConfigSource_t confsource);\ntypedef struct rd_kafka_ConfigEntry_s rd_kafka_ConfigEntry_t;\nconst char *rd_kafka_ConfigEntry_name(const rd_kafka_ConfigEntry_t *entry);\nconst char *rd_kafka_ConfigEntry_value(const rd_kafka_ConfigEntry_t *entry);\nrd_kafka_ConfigSource_t rd_kafka_ConfigEntry_source(const rd_kafka_ConfigEntry_t *entry);\nint rd_kafka_ConfigEntry_is_read_only(const rd_kafka_ConfigEntry_t *entry);\nint rd_kafka_ConfigEntry_is_default(const rd_kafka_ConfigEntry_t *entry);\nint rd_kafka_ConfigEntry_is_sensitive(const rd_kafka_ConfigEntry_t *entry);\nint rd_kafka_ConfigEntry_is_synonym(const rd_kafka_ConfigEntry_t *entry);\nconst rd_kafka_ConfigEntry_t **rd_kafka_ConfigEntry_synonyms(const rd_kafka_ConfigEntry_t *entry, size_t *cntp);\ntypedef enum rd_kafka_ResourceType_t {\n  RD_KAFKA_RESOURCE_UNKNOWN = 0,\n  RD_KAFKA_RESOURCE_ANY = 1,\n  RD_KAFKA_RESOURCE_TOPIC = 2,\n  RD_KAFKA_RESOURCE_GROUP = 3,\n  RD_KAFKA_RESOURCE_BROKER = 4,\n  RD_KAFKA_RESOURCE__CNT,\n} rd_kafka_ResourceType_t;\nconst char *rd_kafka_ResourceType_name(rd_kafka_ResourceType_t restype);\ntypedef struct rd_kafka_ConfigResource_s rd_kafka_ConfigResource_t;\nrd_kafka_ConfigResource_t *rd_kafka_ConfigResource_new(rd_kafka_ResourceType_t restype, const char *resname);\nvoid rd_kafka_ConfigResource_destroy(rd_kafka_ConfigResource_t *config);\nvoid rd_kafka_ConfigResource_destroy_array(rd_kafka_ConfigResource_t **config, size_t config_cnt);\nrd_kafka_resp_err_t rd_kafka_ConfigResource_set_config(rd_kafka_ConfigResource_t *config, const char *name, const char *value);\nconst rd_kafka_ConfigEntry_t **rd_kafka_ConfigResource_configs(const rd_kafka_ConfigResource_t *config, size_t *cntp);\nrd_kafka_ResourceType_t rd_kafka_ConfigResource_type(const rd_kafka_ConfigResource_t *config);\nconst char *rd_kafka_ConfigResource_name(const rd_kafka_ConfigResource_t *config);\nrd_kafka_resp_err_t rd_kafka_ConfigResource_error(const rd_kafka_ConfigResource_t *config);\nconst char *rd_kafka_ConfigResource_error_string(const rd_kafka_ConfigResource_t *config);\nvoid rd_kafka_AlterConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_ConfigResource_t **rd_kafka_AlterConfigs_result_resources(const rd_kafka_AlterConfigs_result_t *result, size_t *cntp);\nvoid rd_kafka_DescribeConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_ConfigResource_t **rd_kafka_DescribeConfigs_result_resources(const rd_kafka_DescribeConfigs_result_t *result, size_t *cntp);\nrd_kafka_resp_err_t rd_kafka_oauthbearer_set_token(rd_kafka_t *rk, const char *token_value, int64_t md_lifetime_ms, const char *md_principal_name, const char **extensions, size_t extension_size, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_oauthbearer_set_token_failure(rd_kafka_t *rk, const char *errstr);\n'\n</code></pre> rdkafka.h, rdkafka_mock.h</p>"},{"location":"api/constants/#rd_kafka_version_6","title":"RD_KAFKA_VERSION","text":"<pre><code>public RD_KAFKA_VERSION = 16974079\n</code></pre> <p>librdkafka version </p> <p>Interpreted as hex <code>MM.mm.rr.xx</code>:</p> <ul> <li>MM = Major</li> <li>mm = minor</li> <li>rr = revision</li> <li>xx = pre-release id (0xff is the final release)</li> </ul> <p>E.g.: <code>0x000801ff</code> = 0.8.1</p> RemarksThis value should only be used during compile time, for runtime checks of version use rd_kafka_version()  <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_unsupported_compression_type_6","title":"RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE","text":"<pre><code>public RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76\n</code></pre> <p>Unsupported compression type </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_end_all_6","title":"RD_KAFKA_RESP_ERR_END_ALL","text":"<p><pre><code>public RD_KAFKA_RESP_ERR_END_ALL = 82\n</code></pre> enum rd_kafka_resp_err_t</p>"},{"location":"api/constants/#rd_kafka_admin_op__cnt_6","title":"RD_KAFKA_ADMIN_OP__CNT","text":"<pre><code>public RD_KAFKA_ADMIN_OP__CNT = 6\n</code></pre> <p>Number of ops defined </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe </li> </ul>"},{"location":"api/constants/#rd_kafka_resource__cnt_6","title":"RD_KAFKA_RESOURCE__CNT","text":"<pre><code>public RD_KAFKA_RESOURCE__CNT = 5\n</code></pre> <p>Number of resource types defined </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#acca83a66d7783ff7683ed2691cc907c9 </li> </ul>"},{"location":"api/constants/#rd_kafka_cdef_6","title":"RD_KAFKA_CDEF","text":"<p><pre><code>public RD_KAFKA_CDEF = 'typedef long int ssize_t;\ntypedef struct _IO_FILE FILE;\ntypedef long int mode_t;\ntypedef signed int int16_t;\ntypedef unsigned int uint16_t;\ntypedef signed int int32_t;\ntypedef signed long int int64_t;\nint rd_kafka_version(void);\nconst char *rd_kafka_version_str(void);\ntypedef enum rd_kafka_type_t {\n  RD_KAFKA_PRODUCER,\n  RD_KAFKA_CONSUMER,\n} rd_kafka_type_t;\ntypedef enum rd_kafka_timestamp_type_t {\n  RD_KAFKA_TIMESTAMP_NOT_AVAILABLE,\n  RD_KAFKA_TIMESTAMP_CREATE_TIME,\n  RD_KAFKA_TIMESTAMP_LOG_APPEND_TIME,\n} rd_kafka_timestamp_type_t;\nconst char *rd_kafka_get_debug_contexts(void);\ntypedef struct rd_kafka_s rd_kafka_t;\ntypedef struct rd_kafka_topic_s rd_kafka_topic_t;\ntypedef struct rd_kafka_conf_s rd_kafka_conf_t;\ntypedef struct rd_kafka_topic_conf_s rd_kafka_topic_conf_t;\ntypedef struct rd_kafka_queue_s rd_kafka_queue_t;\ntypedef struct rd_kafka_op_s rd_kafka_event_t;\ntypedef struct rd_kafka_topic_result_s rd_kafka_topic_result_t;\ntypedef enum {\n  RD_KAFKA_RESP_ERR__BEGIN = (- 200),\n  RD_KAFKA_RESP_ERR__BAD_MSG = (- 199),\n  RD_KAFKA_RESP_ERR__BAD_COMPRESSION = (- 198),\n  RD_KAFKA_RESP_ERR__DESTROY = (- 197),\n  RD_KAFKA_RESP_ERR__FAIL = (- 196),\n  RD_KAFKA_RESP_ERR__TRANSPORT = (- 195),\n  RD_KAFKA_RESP_ERR__CRIT_SYS_RESOURCE = (- 194),\n  RD_KAFKA_RESP_ERR__RESOLVE = (- 193),\n  RD_KAFKA_RESP_ERR__MSG_TIMED_OUT = (- 192),\n  RD_KAFKA_RESP_ERR__PARTITION_EOF = (- 191),\n  RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION = (- 190),\n  RD_KAFKA_RESP_ERR__FS = (- 189),\n  RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC = (- 188),\n  RD_KAFKA_RESP_ERR__ALL_BROKERS_DOWN = (- 187),\n  RD_KAFKA_RESP_ERR__INVALID_ARG = (- 186),\n  RD_KAFKA_RESP_ERR__TIMED_OUT = (- 185),\n  RD_KAFKA_RESP_ERR__QUEUE_FULL = (- 184),\n  RD_KAFKA_RESP_ERR__ISR_INSUFF = (- 183),\n  RD_KAFKA_RESP_ERR__NODE_UPDATE = (- 182),\n  RD_KAFKA_RESP_ERR__SSL = (- 181),\n  RD_KAFKA_RESP_ERR__WAIT_COORD = (- 180),\n  RD_KAFKA_RESP_ERR__UNKNOWN_GROUP = (- 179),\n  RD_KAFKA_RESP_ERR__IN_PROGRESS = (- 178),\n  RD_KAFKA_RESP_ERR__PREV_IN_PROGRESS = (- 177),\n  RD_KAFKA_RESP_ERR__EXISTING_SUBSCRIPTION = (- 176),\n  RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS = (- 175),\n  RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS = (- 174),\n  RD_KAFKA_RESP_ERR__CONFLICT = (- 173),\n  RD_KAFKA_RESP_ERR__STATE = (- 172),\n  RD_KAFKA_RESP_ERR__UNKNOWN_PROTOCOL = (- 171),\n  RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED = (- 170),\n  RD_KAFKA_RESP_ERR__AUTHENTICATION = (- 169),\n  RD_KAFKA_RESP_ERR__NO_OFFSET = (- 168),\n  RD_KAFKA_RESP_ERR__OUTDATED = (- 167),\n  RD_KAFKA_RESP_ERR__TIMED_OUT_QUEUE = (- 166),\n  RD_KAFKA_RESP_ERR__UNSUPPORTED_FEATURE = (- 165),\n  RD_KAFKA_RESP_ERR__WAIT_CACHE = (- 164),\n  RD_KAFKA_RESP_ERR__INTR = (- 163),\n  RD_KAFKA_RESP_ERR__KEY_SERIALIZATION = (- 162),\n  RD_KAFKA_RESP_ERR__VALUE_SERIALIZATION = (- 161),\n  RD_KAFKA_RESP_ERR__KEY_DESERIALIZATION = (- 160),\n  RD_KAFKA_RESP_ERR__VALUE_DESERIALIZATION = (- 159),\n  RD_KAFKA_RESP_ERR__PARTIAL = (- 158),\n  RD_KAFKA_RESP_ERR__READ_ONLY = (- 157),\n  RD_KAFKA_RESP_ERR__NOENT = (- 156),\n  RD_KAFKA_RESP_ERR__UNDERFLOW = (- 155),\n  RD_KAFKA_RESP_ERR__INVALID_TYPE = (- 154),\n  RD_KAFKA_RESP_ERR__RETRY = (- 153),\n  RD_KAFKA_RESP_ERR__PURGE_QUEUE = (- 152),\n  RD_KAFKA_RESP_ERR__PURGE_INFLIGHT = (- 151),\n  RD_KAFKA_RESP_ERR__FATAL = (- 150),\n  RD_KAFKA_RESP_ERR__INCONSISTENT = (- 149),\n  RD_KAFKA_RESP_ERR__GAPLESS_GUARANTEE = (- 148),\n  RD_KAFKA_RESP_ERR__MAX_POLL_EXCEEDED = (- 147),\n  RD_KAFKA_RESP_ERR__UNKNOWN_BROKER = (- 146),\n  RD_KAFKA_RESP_ERR__END = (- 100),\n  RD_KAFKA_RESP_ERR_UNKNOWN = (- 1),\n  RD_KAFKA_RESP_ERR_NO_ERROR = 0,\n  RD_KAFKA_RESP_ERR_OFFSET_OUT_OF_RANGE = 1,\n  RD_KAFKA_RESP_ERR_INVALID_MSG = 2,\n  RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART = 3,\n  RD_KAFKA_RESP_ERR_INVALID_MSG_SIZE = 4,\n  RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE = 5,\n  RD_KAFKA_RESP_ERR_NOT_LEADER_FOR_PARTITION = 6,\n  RD_KAFKA_RESP_ERR_REQUEST_TIMED_OUT = 7,\n  RD_KAFKA_RESP_ERR_BROKER_NOT_AVAILABLE = 8,\n  RD_KAFKA_RESP_ERR_REPLICA_NOT_AVAILABLE = 9,\n  RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE = 10,\n  RD_KAFKA_RESP_ERR_STALE_CTRL_EPOCH = 11,\n  RD_KAFKA_RESP_ERR_OFFSET_METADATA_TOO_LARGE = 12,\n  RD_KAFKA_RESP_ERR_NETWORK_EXCEPTION = 13,\n  RD_KAFKA_RESP_ERR_COORDINATOR_LOAD_IN_PROGRESS = 14,\n  RD_KAFKA_RESP_ERR_COORDINATOR_NOT_AVAILABLE = 15,\n  RD_KAFKA_RESP_ERR_NOT_COORDINATOR = 16,\n  RD_KAFKA_RESP_ERR_TOPIC_EXCEPTION = 17,\n  RD_KAFKA_RESP_ERR_RECORD_LIST_TOO_LARGE = 18,\n  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS = 19,\n  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS_AFTER_APPEND = 20,\n  RD_KAFKA_RESP_ERR_INVALID_REQUIRED_ACKS = 21,\n  RD_KAFKA_RESP_ERR_ILLEGAL_GENERATION = 22,\n  RD_KAFKA_RESP_ERR_INCONSISTENT_GROUP_PROTOCOL = 23,\n  RD_KAFKA_RESP_ERR_INVALID_GROUP_ID = 24,\n  RD_KAFKA_RESP_ERR_UNKNOWN_MEMBER_ID = 25,\n  RD_KAFKA_RESP_ERR_INVALID_SESSION_TIMEOUT = 26,\n  RD_KAFKA_RESP_ERR_REBALANCE_IN_PROGRESS = 27,\n  RD_KAFKA_RESP_ERR_INVALID_COMMIT_OFFSET_SIZE = 28,\n  RD_KAFKA_RESP_ERR_TOPIC_AUTHORIZATION_FAILED = 29,\n  RD_KAFKA_RESP_ERR_GROUP_AUTHORIZATION_FAILED = 30,\n  RD_KAFKA_RESP_ERR_CLUSTER_AUTHORIZATION_FAILED = 31,\n  RD_KAFKA_RESP_ERR_INVALID_TIMESTAMP = 32,\n  RD_KAFKA_RESP_ERR_UNSUPPORTED_SASL_MECHANISM = 33,\n  RD_KAFKA_RESP_ERR_ILLEGAL_SASL_STATE = 34,\n  RD_KAFKA_RESP_ERR_UNSUPPORTED_VERSION = 35,\n  RD_KAFKA_RESP_ERR_TOPIC_ALREADY_EXISTS = 36,\n  RD_KAFKA_RESP_ERR_INVALID_PARTITIONS = 37,\n  RD_KAFKA_RESP_ERR_INVALID_REPLICATION_FACTOR = 38,\n  RD_KAFKA_RESP_ERR_INVALID_REPLICA_ASSIGNMENT = 39,\n  RD_KAFKA_RESP_ERR_INVALID_CONFIG = 40,\n  RD_KAFKA_RESP_ERR_NOT_CONTROLLER = 41,\n  RD_KAFKA_RESP_ERR_INVALID_REQUEST = 42,\n  RD_KAFKA_RESP_ERR_UNSUPPORTED_FOR_MESSAGE_FORMAT = 43,\n  RD_KAFKA_RESP_ERR_POLICY_VIOLATION = 44,\n  RD_KAFKA_RESP_ERR_OUT_OF_ORDER_SEQUENCE_NUMBER = 45,\n  RD_KAFKA_RESP_ERR_DUPLICATE_SEQUENCE_NUMBER = 46,\n  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_EPOCH = 47,\n  RD_KAFKA_RESP_ERR_INVALID_TXN_STATE = 48,\n  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_ID_MAPPING = 49,\n  RD_KAFKA_RESP_ERR_INVALID_TRANSACTION_TIMEOUT = 50,\n  RD_KAFKA_RESP_ERR_CONCURRENT_TRANSACTIONS = 51,\n  RD_KAFKA_RESP_ERR_TRANSACTION_COORDINATOR_FENCED = 52,\n  RD_KAFKA_RESP_ERR_TRANSACTIONAL_ID_AUTHORIZATION_FAILED = 53,\n  RD_KAFKA_RESP_ERR_SECURITY_DISABLED = 54,\n  RD_KAFKA_RESP_ERR_OPERATION_NOT_ATTEMPTED = 55,\n  RD_KAFKA_RESP_ERR_KAFKA_STORAGE_ERROR = 56,\n  RD_KAFKA_RESP_ERR_LOG_DIR_NOT_FOUND = 57,\n  RD_KAFKA_RESP_ERR_SASL_AUTHENTICATION_FAILED = 58,\n  RD_KAFKA_RESP_ERR_UNKNOWN_PRODUCER_ID = 59,\n  RD_KAFKA_RESP_ERR_REASSIGNMENT_IN_PROGRESS = 60,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTH_DISABLED = 61,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_NOT_FOUND = 62,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_OWNER_MISMATCH = 63,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_REQUEST_NOT_ALLOWED = 64,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTHORIZATION_FAILED = 65,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_EXPIRED = 66,\n  RD_KAFKA_RESP_ERR_INVALID_PRINCIPAL_TYPE = 67,\n  RD_KAFKA_RESP_ERR_NON_EMPTY_GROUP = 68,\n  RD_KAFKA_RESP_ERR_GROUP_ID_NOT_FOUND = 69,\n  RD_KAFKA_RESP_ERR_FETCH_SESSION_ID_NOT_FOUND = 70,\n  RD_KAFKA_RESP_ERR_INVALID_FETCH_SESSION_EPOCH = 71,\n  RD_KAFKA_RESP_ERR_LISTENER_NOT_FOUND = 72,\n  RD_KAFKA_RESP_ERR_TOPIC_DELETION_DISABLED = 73,\n  RD_KAFKA_RESP_ERR_FENCED_LEADER_EPOCH = 74,\n  RD_KAFKA_RESP_ERR_UNKNOWN_LEADER_EPOCH = 75,\n  RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76,\n  RD_KAFKA_RESP_ERR_STALE_BROKER_EPOCH = 77,\n  RD_KAFKA_RESP_ERR_OFFSET_NOT_AVAILABLE = 78,\n  RD_KAFKA_RESP_ERR_MEMBER_ID_REQUIRED = 79,\n  RD_KAFKA_RESP_ERR_PREFERRED_LEADER_NOT_AVAILABLE = 80,\n  RD_KAFKA_RESP_ERR_GROUP_MAX_SIZE_REACHED = 81,\n  RD_KAFKA_RESP_ERR_END_ALL,\n} rd_kafka_resp_err_t;\nstruct rd_kafka_err_desc {\n  rd_kafka_resp_err_t code;\n  char *name;\n  char *desc;\n};\nvoid rd_kafka_get_err_descs(const struct rd_kafka_err_desc **errdescs, size_t *cntp);\nconst char *rd_kafka_err2str(rd_kafka_resp_err_t err);\nconst char *rd_kafka_err2name(rd_kafka_resp_err_t err);\nrd_kafka_resp_err_t rd_kafka_last_error(void);\nrd_kafka_resp_err_t rd_kafka_errno2err(int errnox);\nint rd_kafka_errno(void);\nrd_kafka_resp_err_t rd_kafka_fatal_error(rd_kafka_t *rk, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_test_fatal_error(rd_kafka_t *rk, rd_kafka_resp_err_t err, const char *reason);\ntypedef struct rd_kafka_topic_partition_s {\n  char *topic;\n  int32_t partition;\n  int64_t offset;\n  void *metadata;\n  size_t metadata_size;\n  void *opaque;\n  rd_kafka_resp_err_t err;\n  void *_private;\n} rd_kafka_topic_partition_t;\nvoid rd_kafka_topic_partition_destroy(rd_kafka_topic_partition_t *rktpar);\ntypedef struct rd_kafka_topic_partition_list_s {\n  int cnt;\n  int size;\n  rd_kafka_topic_partition_t *elems;\n} rd_kafka_topic_partition_list_t;\nrd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_new(int size);\nvoid rd_kafka_topic_partition_list_destroy(rd_kafka_topic_partition_list_t *rkparlist);\nrd_kafka_topic_partition_t *rd_kafka_topic_partition_list_add(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);\nvoid rd_kafka_topic_partition_list_add_range(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t start, int32_t stop);\nint rd_kafka_topic_partition_list_del(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);\nint rd_kafka_topic_partition_list_del_by_idx(rd_kafka_topic_partition_list_t *rktparlist, int idx);\nrd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_copy(const rd_kafka_topic_partition_list_t *src);\nrd_kafka_resp_err_t rd_kafka_topic_partition_list_set_offset(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition, int64_t offset);\nrd_kafka_topic_partition_t *rd_kafka_topic_partition_list_find(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);\nvoid rd_kafka_topic_partition_list_sort(rd_kafka_topic_partition_list_t *rktparlist, int (*cmp)(const void *a, const void *b, void *cmp_opaque), void *cmp_opaque);\ntypedef enum rd_kafka_vtype_t {\n  RD_KAFKA_VTYPE_END,\n  RD_KAFKA_VTYPE_TOPIC,\n  RD_KAFKA_VTYPE_RKT,\n  RD_KAFKA_VTYPE_PARTITION,\n  RD_KAFKA_VTYPE_VALUE,\n  RD_KAFKA_VTYPE_KEY,\n  RD_KAFKA_VTYPE_OPAQUE,\n  RD_KAFKA_VTYPE_MSGFLAGS,\n  RD_KAFKA_VTYPE_TIMESTAMP,\n  RD_KAFKA_VTYPE_HEADER,\n  RD_KAFKA_VTYPE_HEADERS,\n} rd_kafka_vtype_t;\ntypedef struct rd_kafka_headers_s rd_kafka_headers_t;\nrd_kafka_headers_t *rd_kafka_headers_new(size_t initial_count);\nvoid rd_kafka_headers_destroy(rd_kafka_headers_t *hdrs);\nrd_kafka_headers_t *rd_kafka_headers_copy(const rd_kafka_headers_t *src);\nrd_kafka_resp_err_t rd_kafka_header_add(rd_kafka_headers_t *hdrs, const char *name, ssize_t name_size, const void *value, ssize_t value_size);\nrd_kafka_resp_err_t rd_kafka_header_remove(rd_kafka_headers_t *hdrs, const char *name);\nrd_kafka_resp_err_t rd_kafka_header_get_last(const rd_kafka_headers_t *hdrs, const char *name, const void **valuep, size_t *sizep);\nrd_kafka_resp_err_t rd_kafka_header_get(const rd_kafka_headers_t *hdrs, size_t idx, const char *name, const void **valuep, size_t *sizep);\nrd_kafka_resp_err_t rd_kafka_header_get_all(const rd_kafka_headers_t *hdrs, size_t idx, const char **namep, const void **valuep, size_t *sizep);\ntypedef struct rd_kafka_message_s {\n  rd_kafka_resp_err_t err;\n  rd_kafka_topic_t *rkt;\n  int32_t partition;\n  void *payload;\n  size_t len;\n  void *key;\n  size_t key_len;\n  int64_t offset;\n  void *_private;\n} rd_kafka_message_t;\nvoid rd_kafka_message_destroy(rd_kafka_message_t *rkmessage);\nint64_t rd_kafka_message_timestamp(const rd_kafka_message_t *rkmessage, rd_kafka_timestamp_type_t *tstype);\nint64_t rd_kafka_message_latency(const rd_kafka_message_t *rkmessage);\nrd_kafka_resp_err_t rd_kafka_message_headers(const rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);\nrd_kafka_resp_err_t rd_kafka_message_detach_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);\nvoid rd_kafka_message_set_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t *hdrs);\nsize_t rd_kafka_header_cnt(const rd_kafka_headers_t *hdrs);\ntypedef enum {\n  RD_KAFKA_MSG_STATUS_NOT_PERSISTED = 0,\n  RD_KAFKA_MSG_STATUS_POSSIBLY_PERSISTED = 1,\n  RD_KAFKA_MSG_STATUS_PERSISTED = 2,\n} rd_kafka_msg_status_t;\nrd_kafka_msg_status_t rd_kafka_message_status(const rd_kafka_message_t *rkmessage);\ntypedef enum {\n  RD_KAFKA_CONF_UNKNOWN = (- 2),\n  RD_KAFKA_CONF_INVALID = (- 1),\n  RD_KAFKA_CONF_OK = 0,\n} rd_kafka_conf_res_t;\nrd_kafka_conf_t *rd_kafka_conf_new(void);\nvoid rd_kafka_conf_destroy(rd_kafka_conf_t *conf);\nrd_kafka_conf_t *rd_kafka_conf_dup(const rd_kafka_conf_t *conf);\nrd_kafka_conf_t *rd_kafka_conf_dup_filter(const rd_kafka_conf_t *conf, size_t filter_cnt, const char **filter);\nconst rd_kafka_conf_t *rd_kafka_conf(rd_kafka_t *rk);\nrd_kafka_conf_res_t rd_kafka_conf_set(rd_kafka_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);\nvoid rd_kafka_conf_set_events(rd_kafka_conf_t *conf, int events);\nvoid rd_kafka_conf_set_background_event_cb(rd_kafka_conf_t *conf, void (*event_cb)(rd_kafka_t *rk, rd_kafka_event_t *rkev, void *opaque));\nvoid rd_kafka_conf_set_dr_cb(rd_kafka_conf_t *conf, void (*dr_cb)(rd_kafka_t *rk, void *payload, size_t len, rd_kafka_resp_err_t err, void *opaque, void *msg_opaque));\nvoid rd_kafka_conf_set_dr_msg_cb(rd_kafka_conf_t *conf, void (*dr_msg_cb)(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, void *opaque));\nvoid rd_kafka_conf_set_consume_cb(rd_kafka_conf_t *conf, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *opaque));\nvoid rd_kafka_conf_set_rebalance_cb(rd_kafka_conf_t *conf, void (*rebalance_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *partitions, void *opaque));\nvoid rd_kafka_conf_set_offset_commit_cb(rd_kafka_conf_t *conf, void (*offset_commit_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *opaque));\nvoid rd_kafka_conf_set_error_cb(rd_kafka_conf_t *conf, void (*error_cb)(rd_kafka_t *rk, int err, const char *reason, void *opaque));\nvoid rd_kafka_conf_set_throttle_cb(rd_kafka_conf_t *conf, void (*throttle_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int throttle_time_ms, void *opaque));\nvoid rd_kafka_conf_set_log_cb(rd_kafka_conf_t *conf, void (*log_cb)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));\nvoid rd_kafka_conf_set_stats_cb(rd_kafka_conf_t *conf, int (*stats_cb)(rd_kafka_t *rk, char *json, size_t json_len, void *opaque));\nvoid rd_kafka_conf_set_oauthbearer_token_refresh_cb(rd_kafka_conf_t *conf, void (*oauthbearer_token_refresh_cb)(rd_kafka_t *rk, const char *oauthbearer_config, void *opaque));\nvoid rd_kafka_conf_set_socket_cb(rd_kafka_conf_t *conf, int (*socket_cb)(int domain, int type, int protocol, void *opaque));\nvoid rd_kafka_conf_set_connect_cb(rd_kafka_conf_t *conf, int (*connect_cb)(int sockfd, const struct sockaddr *addr, int addrlen, const char *id, void *opaque));\nvoid rd_kafka_conf_set_closesocket_cb(rd_kafka_conf_t *conf, int (*closesocket_cb)(int sockfd, void *opaque));\nrd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert_verify_cb(rd_kafka_conf_t *conf, int (*ssl_cert_verify_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int *x509_error, int depth, const char *buf, size_t size, char *errstr, size_t errstr_size, void *opaque));\ntypedef enum rd_kafka_cert_type_t {\n  RD_KAFKA_CERT_PUBLIC_KEY,\n  RD_KAFKA_CERT_PRIVATE_KEY,\n  RD_KAFKA_CERT_CA,\n  RD_KAFKA_CERT__CNT,\n} rd_kafka_cert_type_t;\ntypedef enum rd_kafka_cert_enc_t {\n  RD_KAFKA_CERT_ENC_PKCS12,\n  RD_KAFKA_CERT_ENC_DER,\n  RD_KAFKA_CERT_ENC_PEM,\n  RD_KAFKA_CERT_ENC__CNT,\n} rd_kafka_cert_enc_t;\nrd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert(rd_kafka_conf_t *conf, rd_kafka_cert_type_t cert_type, rd_kafka_cert_enc_t cert_enc, const void *buffer, size_t size, char *errstr, size_t errstr_size);\nvoid rd_kafka_conf_set_opaque(rd_kafka_conf_t *conf, void *opaque);\nvoid *rd_kafka_opaque(const rd_kafka_t *rk);\nvoid rd_kafka_conf_set_default_topic_conf(rd_kafka_conf_t *conf, rd_kafka_topic_conf_t *tconf);\nrd_kafka_conf_res_t rd_kafka_conf_get(const rd_kafka_conf_t *conf, const char *name, char *dest, size_t *dest_size);\nrd_kafka_conf_res_t rd_kafka_topic_conf_get(const rd_kafka_topic_conf_t *conf, const char *name, char *dest, size_t *dest_size);\nconst char **rd_kafka_conf_dump(rd_kafka_conf_t *conf, size_t *cntp);\nconst char **rd_kafka_topic_conf_dump(rd_kafka_topic_conf_t *conf, size_t *cntp);\nvoid rd_kafka_conf_dump_free(const char **arr, size_t cnt);\nvoid rd_kafka_conf_properties_show(FILE *fp);\nrd_kafka_topic_conf_t *rd_kafka_topic_conf_new(void);\nrd_kafka_topic_conf_t *rd_kafka_topic_conf_dup(const rd_kafka_topic_conf_t *conf);\nrd_kafka_topic_conf_t *rd_kafka_default_topic_conf_dup(rd_kafka_t *rk);\nvoid rd_kafka_topic_conf_destroy(rd_kafka_topic_conf_t *topic_conf);\nrd_kafka_conf_res_t rd_kafka_topic_conf_set(rd_kafka_topic_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);\nvoid rd_kafka_topic_conf_set_opaque(rd_kafka_topic_conf_t *conf, void *rkt_opaque);\nvoid rd_kafka_topic_conf_set_partitioner_cb(rd_kafka_topic_conf_t *topic_conf, int32_t (*partitioner)(const rd_kafka_topic_t *rkt, const void *keydata, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque));\nvoid rd_kafka_topic_conf_set_msg_order_cmp(rd_kafka_topic_conf_t *topic_conf, int (*msg_order_cmp)(const rd_kafka_message_t *a, const rd_kafka_message_t *b));\nint rd_kafka_topic_partition_available(const rd_kafka_topic_t *rkt, int32_t partition);\nint32_t rd_kafka_msg_partitioner_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_consistent(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_consistent_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_murmur2(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_murmur2_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nrd_kafka_t *rd_kafka_new(rd_kafka_type_t type, rd_kafka_conf_t *conf, char *errstr, size_t errstr_size);\nvoid rd_kafka_destroy(rd_kafka_t *rk);\nvoid rd_kafka_destroy_flags(rd_kafka_t *rk, int flags);\nconst char *rd_kafka_name(const rd_kafka_t *rk);\nrd_kafka_type_t rd_kafka_type(const rd_kafka_t *rk);\nchar *rd_kafka_memberid(const rd_kafka_t *rk);\nchar *rd_kafka_clusterid(rd_kafka_t *rk, int timeout_ms);\nint32_t rd_kafka_controllerid(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_topic_t *rd_kafka_topic_new(rd_kafka_t *rk, const char *topic, rd_kafka_topic_conf_t *conf);\nvoid rd_kafka_topic_destroy(rd_kafka_topic_t *rkt);\nconst char *rd_kafka_topic_name(const rd_kafka_topic_t *rkt);\nvoid *rd_kafka_topic_opaque(const rd_kafka_topic_t *rkt);\nint rd_kafka_poll(rd_kafka_t *rk, int timeout_ms);\nvoid rd_kafka_yield(rd_kafka_t *rk);\nrd_kafka_resp_err_t rd_kafka_pause_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_resp_err_t rd_kafka_resume_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_resp_err_t rd_kafka_query_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high, int timeout_ms);\nrd_kafka_resp_err_t rd_kafka_get_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high);\nrd_kafka_resp_err_t rd_kafka_offsets_for_times(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets, int timeout_ms);\nvoid rd_kafka_mem_free(rd_kafka_t *rk, void *ptr);\nrd_kafka_queue_t *rd_kafka_queue_new(rd_kafka_t *rk);\nvoid rd_kafka_queue_destroy(rd_kafka_queue_t *rkqu);\nrd_kafka_queue_t *rd_kafka_queue_get_main(rd_kafka_t *rk);\nrd_kafka_queue_t *rd_kafka_queue_get_consumer(rd_kafka_t *rk);\nrd_kafka_queue_t *rd_kafka_queue_get_partition(rd_kafka_t *rk, const char *topic, int32_t partition);\nrd_kafka_queue_t *rd_kafka_queue_get_background(rd_kafka_t *rk);\nvoid rd_kafka_queue_forward(rd_kafka_queue_t *src, rd_kafka_queue_t *dst);\nrd_kafka_resp_err_t rd_kafka_set_log_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu);\nsize_t rd_kafka_queue_length(rd_kafka_queue_t *rkqu);\nvoid rd_kafka_queue_io_event_enable(rd_kafka_queue_t *rkqu, int fd, const void *payload, size_t size);\nvoid rd_kafka_queue_cb_event_enable(rd_kafka_queue_t *rkqu, void (*event_cb)(rd_kafka_t *rk, void *qev_opaque), void *qev_opaque);\nint rd_kafka_consume_start(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);\nint rd_kafka_consume_start_queue(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, rd_kafka_queue_t *rkqu);\nint rd_kafka_consume_stop(rd_kafka_topic_t *rkt, int32_t partition);\nrd_kafka_resp_err_t rd_kafka_seek(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, int timeout_ms);\nrd_kafka_message_t *rd_kafka_consume(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms);\nssize_t rd_kafka_consume_batch(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);\nint rd_kafka_consume_callback(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);\nrd_kafka_message_t *rd_kafka_consume_queue(rd_kafka_queue_t *rkqu, int timeout_ms);\nssize_t rd_kafka_consume_batch_queue(rd_kafka_queue_t *rkqu, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);\nint rd_kafka_consume_callback_queue(rd_kafka_queue_t *rkqu, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);\nrd_kafka_resp_err_t rd_kafka_offset_store(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);\nrd_kafka_resp_err_t rd_kafka_offsets_store(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets);\nrd_kafka_resp_err_t rd_kafka_subscribe(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *topics);\nrd_kafka_resp_err_t rd_kafka_unsubscribe(rd_kafka_t *rk);\nrd_kafka_resp_err_t rd_kafka_subscription(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **topics);\nrd_kafka_message_t *rd_kafka_consumer_poll(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_resp_err_t rd_kafka_consumer_close(rd_kafka_t *rk);\nrd_kafka_resp_err_t rd_kafka_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_resp_err_t rd_kafka_assignment(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **partitions);\nrd_kafka_resp_err_t rd_kafka_commit(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, int async);\nrd_kafka_resp_err_t rd_kafka_commit_message(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, int async);\nrd_kafka_resp_err_t rd_kafka_commit_queue(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_queue_t *rkqu, void (*cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *commit_opaque), void *commit_opaque);\nrd_kafka_resp_err_t rd_kafka_committed(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms);\nrd_kafka_resp_err_t rd_kafka_position(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);\nint rd_kafka_produce(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, void *payload, size_t len, const void *key, size_t keylen, void *msg_opaque);\nrd_kafka_resp_err_t rd_kafka_producev(rd_kafka_t *rk, ...);\nint rd_kafka_produce_batch(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, rd_kafka_message_t *rkmessages, int message_cnt);\nrd_kafka_resp_err_t rd_kafka_flush(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_resp_err_t rd_kafka_purge(rd_kafka_t *rk, int purge_flags);\ntypedef struct rd_kafka_metadata_broker {\n  int32_t id;\n  char *host;\n  int port;\n} rd_kafka_metadata_broker_t;\ntypedef struct rd_kafka_metadata_partition {\n  int32_t id;\n  rd_kafka_resp_err_t err;\n  int32_t leader;\n  int replica_cnt;\n  int32_t *replicas;\n  int isr_cnt;\n  int32_t *isrs;\n} rd_kafka_metadata_partition_t;\ntypedef struct rd_kafka_metadata_topic {\n  char *topic;\n  int partition_cnt;\n  struct rd_kafka_metadata_partition *partitions;\n  rd_kafka_resp_err_t err;\n} rd_kafka_metadata_topic_t;\ntypedef struct rd_kafka_metadata {\n  int broker_cnt;\n  struct rd_kafka_metadata_broker *brokers;\n  int topic_cnt;\n  struct rd_kafka_metadata_topic *topics;\n  int32_t orig_broker_id;\n  char *orig_broker_name;\n} rd_kafka_metadata_t;\nrd_kafka_resp_err_t rd_kafka_metadata(rd_kafka_t *rk, int all_topics, rd_kafka_topic_t *only_rkt, const struct rd_kafka_metadata **metadatap, int timeout_ms);\nvoid rd_kafka_metadata_destroy(const struct rd_kafka_metadata *metadata);\nstruct rd_kafka_group_member_info {\n  char *member_id;\n  char *client_id;\n  char *client_host;\n  void *member_metadata;\n  int member_metadata_size;\n  void *member_assignment;\n  int member_assignment_size;\n};\nstruct rd_kafka_group_info {\n  struct rd_kafka_metadata_broker broker;\n  char *group;\n  rd_kafka_resp_err_t err;\n  char *state;\n  char *protocol_type;\n  char *protocol;\n  struct rd_kafka_group_member_info *members;\n  int member_cnt;\n};\nstruct rd_kafka_group_list {\n  struct rd_kafka_group_info *groups;\n  int group_cnt;\n};\nrd_kafka_resp_err_t rd_kafka_list_groups(rd_kafka_t *rk, const char *group, const struct rd_kafka_group_list **grplistp, int timeout_ms);\nvoid rd_kafka_group_list_destroy(const struct rd_kafka_group_list *grplist);\nint rd_kafka_brokers_add(rd_kafka_t *rk, const char *brokerlist);\nvoid rd_kafka_set_logger(rd_kafka_t *rk, void (*func)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));\nvoid rd_kafka_set_log_level(rd_kafka_t *rk, int level);\nvoid rd_kafka_log_print(const rd_kafka_t *rk, int level, const char *fac, const char *buf);\nvoid rd_kafka_log_syslog(const rd_kafka_t *rk, int level, const char *fac, const char *buf);\nint rd_kafka_outq_len(rd_kafka_t *rk);\nvoid rd_kafka_dump(FILE *fp, rd_kafka_t *rk);\nint rd_kafka_thread_cnt(void);\ntypedef enum rd_kafka_thread_type_t {\n  RD_KAFKA_THREAD_MAIN,\n  RD_KAFKA_THREAD_BACKGROUND,\n  RD_KAFKA_THREAD_BROKER,\n} rd_kafka_thread_type_t;\nint rd_kafka_wait_destroyed(int timeout_ms);\nint rd_kafka_unittest(void);\nrd_kafka_resp_err_t rd_kafka_poll_set_consumer(rd_kafka_t *rk);\ntypedef int rd_kafka_event_type_t;\nrd_kafka_event_type_t rd_kafka_event_type(const rd_kafka_event_t *rkev);\nconst char *rd_kafka_event_name(const rd_kafka_event_t *rkev);\nvoid rd_kafka_event_destroy(rd_kafka_event_t *rkev);\nconst rd_kafka_message_t *rd_kafka_event_message_next(rd_kafka_event_t *rkev);\nsize_t rd_kafka_event_message_array(rd_kafka_event_t *rkev, const rd_kafka_message_t **rkmessages, size_t size);\nsize_t rd_kafka_event_message_count(rd_kafka_event_t *rkev);\nconst char *rd_kafka_event_config_string(rd_kafka_event_t *rkev);\nrd_kafka_resp_err_t rd_kafka_event_error(rd_kafka_event_t *rkev);\nconst char *rd_kafka_event_error_string(rd_kafka_event_t *rkev);\nint rd_kafka_event_error_is_fatal(rd_kafka_event_t *rkev);\nvoid *rd_kafka_event_opaque(rd_kafka_event_t *rkev);\nint rd_kafka_event_log(rd_kafka_event_t *rkev, const char **fac, const char **str, int *level);\nconst char *rd_kafka_event_stats(rd_kafka_event_t *rkev);\nrd_kafka_topic_partition_list_t *rd_kafka_event_topic_partition_list(rd_kafka_event_t *rkev);\nrd_kafka_topic_partition_t *rd_kafka_event_topic_partition(rd_kafka_event_t *rkev);\ntypedef rd_kafka_event_t rd_kafka_CreateTopics_result_t;\ntypedef rd_kafka_event_t rd_kafka_DeleteTopics_result_t;\ntypedef rd_kafka_event_t rd_kafka_CreatePartitions_result_t;\ntypedef rd_kafka_event_t rd_kafka_AlterConfigs_result_t;\ntypedef rd_kafka_event_t rd_kafka_DescribeConfigs_result_t;\nconst rd_kafka_CreateTopics_result_t *rd_kafka_event_CreateTopics_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DeleteTopics_result_t *rd_kafka_event_DeleteTopics_result(rd_kafka_event_t *rkev);\nconst rd_kafka_CreatePartitions_result_t *rd_kafka_event_CreatePartitions_result(rd_kafka_event_t *rkev);\nconst rd_kafka_AlterConfigs_result_t *rd_kafka_event_AlterConfigs_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DescribeConfigs_result_t *rd_kafka_event_DescribeConfigs_result(rd_kafka_event_t *rkev);\nrd_kafka_event_t *rd_kafka_queue_poll(rd_kafka_queue_t *rkqu, int timeout_ms);\nint rd_kafka_queue_poll_callback(rd_kafka_queue_t *rkqu, int timeout_ms);\ntypedef rd_kafka_resp_err_t (rd_kafka_plugin_f_conf_init_t)(rd_kafka_conf_t *conf, void **plug_opaquep, char *errstr, size_t errstr_size);\ntypedef rd_kafka_conf_res_t (rd_kafka_interceptor_f_on_conf_set_t)(rd_kafka_conf_t *conf, const char *name, const char *val, char *errstr, size_t errstr_size, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_dup_t)(rd_kafka_conf_t *new_conf, const rd_kafka_conf_t *old_conf, size_t filter_cnt, const char **filter, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_destroy_t)(void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_new_t)(rd_kafka_t *rk, const rd_kafka_conf_t *conf, void *ic_opaque, char *errstr, size_t errstr_size);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_destroy_t)(rd_kafka_t *rk, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_send_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_acknowledgement_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_consume_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_commit_t)(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_resp_err_t err, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_request_sent_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_start_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_exit_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_set(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_set_t *on_conf_set, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_dup(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_dup_t *on_conf_dup, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_destroy(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_destroy_t *on_conf_destroy, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_new(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_new_t *on_new, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_destroy(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_destroy_t *on_destroy, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_send(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_send_t *on_send, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_acknowledgement(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_acknowledgement_t *on_acknowledgement, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_consume(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_consume_t *on_consume, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_commit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_commit_t *on_commit, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_request_sent(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_request_sent_t *on_request_sent, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_start(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_start_t *on_thread_start, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_exit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_exit_t *on_thread_exit, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_topic_result_error(const rd_kafka_topic_result_t *topicres);\nconst char *rd_kafka_topic_result_error_string(const rd_kafka_topic_result_t *topicres);\nconst char *rd_kafka_topic_result_name(const rd_kafka_topic_result_t *topicres);\ntypedef enum rd_kafka_admin_op_t {\n  RD_KAFKA_ADMIN_OP_ANY = 0,\n  RD_KAFKA_ADMIN_OP_CREATETOPICS,\n  RD_KAFKA_ADMIN_OP_DELETETOPICS,\n  RD_KAFKA_ADMIN_OP_CREATEPARTITIONS,\n  RD_KAFKA_ADMIN_OP_ALTERCONFIGS,\n  RD_KAFKA_ADMIN_OP_DESCRIBECONFIGS,\n  RD_KAFKA_ADMIN_OP__CNT,\n} rd_kafka_admin_op_t;\ntypedef struct rd_kafka_AdminOptions_s rd_kafka_AdminOptions_t;\nrd_kafka_AdminOptions_t *rd_kafka_AdminOptions_new(rd_kafka_t *rk, rd_kafka_admin_op_t for_api);\nvoid rd_kafka_AdminOptions_destroy(rd_kafka_AdminOptions_t *options);\nrd_kafka_resp_err_t rd_kafka_AdminOptions_set_request_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_AdminOptions_set_operation_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_AdminOptions_set_validate_only(rd_kafka_AdminOptions_t *options, int true_or_false, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_AdminOptions_set_broker(rd_kafka_AdminOptions_t *options, int32_t broker_id, char *errstr, size_t errstr_size);\nvoid rd_kafka_AdminOptions_set_opaque(rd_kafka_AdminOptions_t *options, void *ev_opaque);\ntypedef struct rd_kafka_NewTopic_s rd_kafka_NewTopic_t;\nrd_kafka_NewTopic_t *rd_kafka_NewTopic_new(const char *topic, int num_partitions, int replication_factor, char *errstr, size_t errstr_size);\nvoid rd_kafka_NewTopic_destroy(rd_kafka_NewTopic_t *new_topic);\nvoid rd_kafka_NewTopic_destroy_array(rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt);\nrd_kafka_resp_err_t rd_kafka_NewTopic_set_replica_assignment(rd_kafka_NewTopic_t *new_topic, int32_t partition, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_NewTopic_set_config(rd_kafka_NewTopic_t *new_topic, const char *name, const char *value);\nvoid rd_kafka_CreateTopics(rd_kafka_t *rk, rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_topic_result_t **rd_kafka_CreateTopics_result_topics(const rd_kafka_CreateTopics_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_DeleteTopic_s rd_kafka_DeleteTopic_t;\nrd_kafka_DeleteTopic_t *rd_kafka_DeleteTopic_new(const char *topic);\nvoid rd_kafka_DeleteTopic_destroy(rd_kafka_DeleteTopic_t *del_topic);\nvoid rd_kafka_DeleteTopic_destroy_array(rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt);\nvoid rd_kafka_DeleteTopics(rd_kafka_t *rk, rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_topic_result_t **rd_kafka_DeleteTopics_result_topics(const rd_kafka_DeleteTopics_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_NewPartitions_s rd_kafka_NewPartitions_t;\nrd_kafka_NewPartitions_t *rd_kafka_NewPartitions_new(const char *topic, size_t new_total_cnt, char *errstr, size_t errstr_size);\nvoid rd_kafka_NewPartitions_destroy(rd_kafka_NewPartitions_t *new_parts);\nvoid rd_kafka_NewPartitions_destroy_array(rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt);\nrd_kafka_resp_err_t rd_kafka_NewPartitions_set_replica_assignment(rd_kafka_NewPartitions_t *new_parts, int32_t new_partition_idx, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);\nvoid rd_kafka_CreatePartitions(rd_kafka_t *rk, rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_topic_result_t **rd_kafka_CreatePartitions_result_topics(const rd_kafka_CreatePartitions_result_t *result, size_t *cntp);\ntypedef enum rd_kafka_ConfigSource_t {\n  RD_KAFKA_CONFIG_SOURCE_UNKNOWN_CONFIG = 0,\n  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_TOPIC_CONFIG = 1,\n  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_BROKER_CONFIG = 2,\n  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_DEFAULT_BROKER_CONFIG = 3,\n  RD_KAFKA_CONFIG_SOURCE_STATIC_BROKER_CONFIG = 4,\n  RD_KAFKA_CONFIG_SOURCE_DEFAULT_CONFIG = 5,\n  RD_KAFKA_CONFIG_SOURCE__CNT,\n} rd_kafka_ConfigSource_t;\nconst char *rd_kafka_ConfigSource_name(rd_kafka_ConfigSource_t confsource);\ntypedef struct rd_kafka_ConfigEntry_s rd_kafka_ConfigEntry_t;\nconst char *rd_kafka_ConfigEntry_name(const rd_kafka_ConfigEntry_t *entry);\nconst char *rd_kafka_ConfigEntry_value(const rd_kafka_ConfigEntry_t *entry);\nrd_kafka_ConfigSource_t rd_kafka_ConfigEntry_source(const rd_kafka_ConfigEntry_t *entry);\nint rd_kafka_ConfigEntry_is_read_only(const rd_kafka_ConfigEntry_t *entry);\nint rd_kafka_ConfigEntry_is_default(const rd_kafka_ConfigEntry_t *entry);\nint rd_kafka_ConfigEntry_is_sensitive(const rd_kafka_ConfigEntry_t *entry);\nint rd_kafka_ConfigEntry_is_synonym(const rd_kafka_ConfigEntry_t *entry);\nconst rd_kafka_ConfigEntry_t **rd_kafka_ConfigEntry_synonyms(const rd_kafka_ConfigEntry_t *entry, size_t *cntp);\ntypedef enum rd_kafka_ResourceType_t {\n  RD_KAFKA_RESOURCE_UNKNOWN = 0,\n  RD_KAFKA_RESOURCE_ANY = 1,\n  RD_KAFKA_RESOURCE_TOPIC = 2,\n  RD_KAFKA_RESOURCE_GROUP = 3,\n  RD_KAFKA_RESOURCE_BROKER = 4,\n  RD_KAFKA_RESOURCE__CNT,\n} rd_kafka_ResourceType_t;\nconst char *rd_kafka_ResourceType_name(rd_kafka_ResourceType_t restype);\ntypedef struct rd_kafka_ConfigResource_s rd_kafka_ConfigResource_t;\nrd_kafka_ConfigResource_t *rd_kafka_ConfigResource_new(rd_kafka_ResourceType_t restype, const char *resname);\nvoid rd_kafka_ConfigResource_destroy(rd_kafka_ConfigResource_t *config);\nvoid rd_kafka_ConfigResource_destroy_array(rd_kafka_ConfigResource_t **config, size_t config_cnt);\nrd_kafka_resp_err_t rd_kafka_ConfigResource_set_config(rd_kafka_ConfigResource_t *config, const char *name, const char *value);\nconst rd_kafka_ConfigEntry_t **rd_kafka_ConfigResource_configs(const rd_kafka_ConfigResource_t *config, size_t *cntp);\nrd_kafka_ResourceType_t rd_kafka_ConfigResource_type(const rd_kafka_ConfigResource_t *config);\nconst char *rd_kafka_ConfigResource_name(const rd_kafka_ConfigResource_t *config);\nrd_kafka_resp_err_t rd_kafka_ConfigResource_error(const rd_kafka_ConfigResource_t *config);\nconst char *rd_kafka_ConfigResource_error_string(const rd_kafka_ConfigResource_t *config);\nvoid rd_kafka_AlterConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_ConfigResource_t **rd_kafka_AlterConfigs_result_resources(const rd_kafka_AlterConfigs_result_t *result, size_t *cntp);\nvoid rd_kafka_DescribeConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_ConfigResource_t **rd_kafka_DescribeConfigs_result_resources(const rd_kafka_DescribeConfigs_result_t *result, size_t *cntp);\nrd_kafka_resp_err_t rd_kafka_oauthbearer_set_token(rd_kafka_t *rk, const char *token_value, int64_t md_lifetime_ms, const char *md_principal_name, const char **extensions, size_t extension_size, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_oauthbearer_set_token_failure(rd_kafka_t *rk, const char *errstr);\ntypedef struct rd_kafka_mock_cluster_s rd_kafka_mock_cluster_t;\nrd_kafka_mock_cluster_t *rd_kafka_mock_cluster_new(rd_kafka_t *rk, int broker_cnt);\nvoid rd_kafka_mock_cluster_destroy(rd_kafka_mock_cluster_t *mcluster);\nrd_kafka_t *rd_kafka_mock_cluster_handle(const rd_kafka_mock_cluster_t *mcluster);\nconst char *rd_kafka_mock_cluster_bootstraps(const rd_kafka_mock_cluster_t *mcluster);\nvoid rd_kafka_mock_push_request_errors(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, size_t cnt, ...);\nvoid rd_kafka_mock_topic_set_error(rd_kafka_mock_cluster_t *mcluster, const char *topic, rd_kafka_resp_err_t err);\nrd_kafka_resp_err_t rd_kafka_mock_partition_set_leader(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id);\nrd_kafka_resp_err_t rd_kafka_mock_partition_set_follower(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id);\nrd_kafka_resp_err_t rd_kafka_mock_partition_set_follower_wmarks(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int64_t lo, int64_t hi);\nrd_kafka_resp_err_t rd_kafka_mock_broker_set_rack(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, const char *rack);\n'\n</code></pre> rdkafka.h, rdkafka_mock.h</p>"},{"location":"api/constants/#rd_kafka_version_7","title":"RD_KAFKA_VERSION","text":"<pre><code>public RD_KAFKA_VERSION = 17039615\n</code></pre> <p>librdkafka version </p> <p>Interpreted as hex <code>MM.mm.rr.xx</code>:</p> <ul> <li>MM = Major</li> <li>mm = minor</li> <li>rr = revision</li> <li>xx = pre-release id (0xff is the final release)</li> </ul> <p>E.g.: <code>0x000801ff</code> = 0.8.1</p> RemarksThis value should only be used during compile time, for runtime checks of version use rd_kafka_version()  <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_unsupported_compression_type_7","title":"RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE","text":"<pre><code>public RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76\n</code></pre> <p>Unsupported compression type </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_end_all_7","title":"RD_KAFKA_RESP_ERR_END_ALL","text":"<p><pre><code>public RD_KAFKA_RESP_ERR_END_ALL = 83\n</code></pre> enum rd_kafka_resp_err_t</p>"},{"location":"api/constants/#rd_kafka_admin_op__cnt_7","title":"RD_KAFKA_ADMIN_OP__CNT","text":"<pre><code>public RD_KAFKA_ADMIN_OP__CNT = 6\n</code></pre> <p>Number of ops defined </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe </li> </ul>"},{"location":"api/constants/#rd_kafka_resource__cnt_7","title":"RD_KAFKA_RESOURCE__CNT","text":"<pre><code>public RD_KAFKA_RESOURCE__CNT = 5\n</code></pre> <p>Number of resource types defined </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#acca83a66d7783ff7683ed2691cc907c9 </li> </ul>"},{"location":"api/constants/#rd_kafka_cdef_7","title":"RD_KAFKA_CDEF","text":"<p><pre><code>public RD_KAFKA_CDEF = 'typedef long int ssize_t;\ntypedef struct _IO_FILE FILE;\ntypedef long int mode_t;\ntypedef signed int int16_t;\ntypedef unsigned int uint16_t;\ntypedef signed int int32_t;\ntypedef signed long int int64_t;\nint rd_kafka_version(void);\nconst char *rd_kafka_version_str(void);\ntypedef enum rd_kafka_type_t {\n  RD_KAFKA_PRODUCER,\n  RD_KAFKA_CONSUMER,\n} rd_kafka_type_t;\ntypedef enum rd_kafka_timestamp_type_t {\n  RD_KAFKA_TIMESTAMP_NOT_AVAILABLE,\n  RD_KAFKA_TIMESTAMP_CREATE_TIME,\n  RD_KAFKA_TIMESTAMP_LOG_APPEND_TIME,\n} rd_kafka_timestamp_type_t;\nconst char *rd_kafka_get_debug_contexts(void);\ntypedef struct rd_kafka_s rd_kafka_t;\ntypedef struct rd_kafka_topic_s rd_kafka_topic_t;\ntypedef struct rd_kafka_conf_s rd_kafka_conf_t;\ntypedef struct rd_kafka_topic_conf_s rd_kafka_topic_conf_t;\ntypedef struct rd_kafka_queue_s rd_kafka_queue_t;\ntypedef struct rd_kafka_op_s rd_kafka_event_t;\ntypedef struct rd_kafka_topic_result_s rd_kafka_topic_result_t;\ntypedef struct rd_kafka_consumer_group_metadata_s rd_kafka_consumer_group_metadata_t;\ntypedef struct rd_kafka_error_s {\n  unsigned int code;\n  char *errstr;\n  unsigned char fatal;\n  unsigned char retriable;\n  unsigned char txn_requires_abort;\n} rd_kafka_error_t;\ntypedef enum {\n  RD_KAFKA_RESP_ERR__BEGIN = (- 200),\n  RD_KAFKA_RESP_ERR__BAD_MSG = (- 199),\n  RD_KAFKA_RESP_ERR__BAD_COMPRESSION = (- 198),\n  RD_KAFKA_RESP_ERR__DESTROY = (- 197),\n  RD_KAFKA_RESP_ERR__FAIL = (- 196),\n  RD_KAFKA_RESP_ERR__TRANSPORT = (- 195),\n  RD_KAFKA_RESP_ERR__CRIT_SYS_RESOURCE = (- 194),\n  RD_KAFKA_RESP_ERR__RESOLVE = (- 193),\n  RD_KAFKA_RESP_ERR__MSG_TIMED_OUT = (- 192),\n  RD_KAFKA_RESP_ERR__PARTITION_EOF = (- 191),\n  RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION = (- 190),\n  RD_KAFKA_RESP_ERR__FS = (- 189),\n  RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC = (- 188),\n  RD_KAFKA_RESP_ERR__ALL_BROKERS_DOWN = (- 187),\n  RD_KAFKA_RESP_ERR__INVALID_ARG = (- 186),\n  RD_KAFKA_RESP_ERR__TIMED_OUT = (- 185),\n  RD_KAFKA_RESP_ERR__QUEUE_FULL = (- 184),\n  RD_KAFKA_RESP_ERR__ISR_INSUFF = (- 183),\n  RD_KAFKA_RESP_ERR__NODE_UPDATE = (- 182),\n  RD_KAFKA_RESP_ERR__SSL = (- 181),\n  RD_KAFKA_RESP_ERR__WAIT_COORD = (- 180),\n  RD_KAFKA_RESP_ERR__UNKNOWN_GROUP = (- 179),\n  RD_KAFKA_RESP_ERR__IN_PROGRESS = (- 178),\n  RD_KAFKA_RESP_ERR__PREV_IN_PROGRESS = (- 177),\n  RD_KAFKA_RESP_ERR__EXISTING_SUBSCRIPTION = (- 176),\n  RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS = (- 175),\n  RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS = (- 174),\n  RD_KAFKA_RESP_ERR__CONFLICT = (- 173),\n  RD_KAFKA_RESP_ERR__STATE = (- 172),\n  RD_KAFKA_RESP_ERR__UNKNOWN_PROTOCOL = (- 171),\n  RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED = (- 170),\n  RD_KAFKA_RESP_ERR__AUTHENTICATION = (- 169),\n  RD_KAFKA_RESP_ERR__NO_OFFSET = (- 168),\n  RD_KAFKA_RESP_ERR__OUTDATED = (- 167),\n  RD_KAFKA_RESP_ERR__TIMED_OUT_QUEUE = (- 166),\n  RD_KAFKA_RESP_ERR__UNSUPPORTED_FEATURE = (- 165),\n  RD_KAFKA_RESP_ERR__WAIT_CACHE = (- 164),\n  RD_KAFKA_RESP_ERR__INTR = (- 163),\n  RD_KAFKA_RESP_ERR__KEY_SERIALIZATION = (- 162),\n  RD_KAFKA_RESP_ERR__VALUE_SERIALIZATION = (- 161),\n  RD_KAFKA_RESP_ERR__KEY_DESERIALIZATION = (- 160),\n  RD_KAFKA_RESP_ERR__VALUE_DESERIALIZATION = (- 159),\n  RD_KAFKA_RESP_ERR__PARTIAL = (- 158),\n  RD_KAFKA_RESP_ERR__READ_ONLY = (- 157),\n  RD_KAFKA_RESP_ERR__NOENT = (- 156),\n  RD_KAFKA_RESP_ERR__UNDERFLOW = (- 155),\n  RD_KAFKA_RESP_ERR__INVALID_TYPE = (- 154),\n  RD_KAFKA_RESP_ERR__RETRY = (- 153),\n  RD_KAFKA_RESP_ERR__PURGE_QUEUE = (- 152),\n  RD_KAFKA_RESP_ERR__PURGE_INFLIGHT = (- 151),\n  RD_KAFKA_RESP_ERR__FATAL = (- 150),\n  RD_KAFKA_RESP_ERR__INCONSISTENT = (- 149),\n  RD_KAFKA_RESP_ERR__GAPLESS_GUARANTEE = (- 148),\n  RD_KAFKA_RESP_ERR__MAX_POLL_EXCEEDED = (- 147),\n  RD_KAFKA_RESP_ERR__UNKNOWN_BROKER = (- 146),\n  RD_KAFKA_RESP_ERR__NOT_CONFIGURED = (- 145),\n  RD_KAFKA_RESP_ERR__FENCED = (- 144),\n  RD_KAFKA_RESP_ERR__APPLICATION = (- 143),\n  RD_KAFKA_RESP_ERR__END = (- 100),\n  RD_KAFKA_RESP_ERR_UNKNOWN = (- 1),\n  RD_KAFKA_RESP_ERR_NO_ERROR = 0,\n  RD_KAFKA_RESP_ERR_OFFSET_OUT_OF_RANGE = 1,\n  RD_KAFKA_RESP_ERR_INVALID_MSG = 2,\n  RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART = 3,\n  RD_KAFKA_RESP_ERR_INVALID_MSG_SIZE = 4,\n  RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE = 5,\n  RD_KAFKA_RESP_ERR_NOT_LEADER_FOR_PARTITION = 6,\n  RD_KAFKA_RESP_ERR_REQUEST_TIMED_OUT = 7,\n  RD_KAFKA_RESP_ERR_BROKER_NOT_AVAILABLE = 8,\n  RD_KAFKA_RESP_ERR_REPLICA_NOT_AVAILABLE = 9,\n  RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE = 10,\n  RD_KAFKA_RESP_ERR_STALE_CTRL_EPOCH = 11,\n  RD_KAFKA_RESP_ERR_OFFSET_METADATA_TOO_LARGE = 12,\n  RD_KAFKA_RESP_ERR_NETWORK_EXCEPTION = 13,\n  RD_KAFKA_RESP_ERR_COORDINATOR_LOAD_IN_PROGRESS = 14,\n  RD_KAFKA_RESP_ERR_COORDINATOR_NOT_AVAILABLE = 15,\n  RD_KAFKA_RESP_ERR_NOT_COORDINATOR = 16,\n  RD_KAFKA_RESP_ERR_TOPIC_EXCEPTION = 17,\n  RD_KAFKA_RESP_ERR_RECORD_LIST_TOO_LARGE = 18,\n  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS = 19,\n  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS_AFTER_APPEND = 20,\n  RD_KAFKA_RESP_ERR_INVALID_REQUIRED_ACKS = 21,\n  RD_KAFKA_RESP_ERR_ILLEGAL_GENERATION = 22,\n  RD_KAFKA_RESP_ERR_INCONSISTENT_GROUP_PROTOCOL = 23,\n  RD_KAFKA_RESP_ERR_INVALID_GROUP_ID = 24,\n  RD_KAFKA_RESP_ERR_UNKNOWN_MEMBER_ID = 25,\n  RD_KAFKA_RESP_ERR_INVALID_SESSION_TIMEOUT = 26,\n  RD_KAFKA_RESP_ERR_REBALANCE_IN_PROGRESS = 27,\n  RD_KAFKA_RESP_ERR_INVALID_COMMIT_OFFSET_SIZE = 28,\n  RD_KAFKA_RESP_ERR_TOPIC_AUTHORIZATION_FAILED = 29,\n  RD_KAFKA_RESP_ERR_GROUP_AUTHORIZATION_FAILED = 30,\n  RD_KAFKA_RESP_ERR_CLUSTER_AUTHORIZATION_FAILED = 31,\n  RD_KAFKA_RESP_ERR_INVALID_TIMESTAMP = 32,\n  RD_KAFKA_RESP_ERR_UNSUPPORTED_SASL_MECHANISM = 33,\n  RD_KAFKA_RESP_ERR_ILLEGAL_SASL_STATE = 34,\n  RD_KAFKA_RESP_ERR_UNSUPPORTED_VERSION = 35,\n  RD_KAFKA_RESP_ERR_TOPIC_ALREADY_EXISTS = 36,\n  RD_KAFKA_RESP_ERR_INVALID_PARTITIONS = 37,\n  RD_KAFKA_RESP_ERR_INVALID_REPLICATION_FACTOR = 38,\n  RD_KAFKA_RESP_ERR_INVALID_REPLICA_ASSIGNMENT = 39,\n  RD_KAFKA_RESP_ERR_INVALID_CONFIG = 40,\n  RD_KAFKA_RESP_ERR_NOT_CONTROLLER = 41,\n  RD_KAFKA_RESP_ERR_INVALID_REQUEST = 42,\n  RD_KAFKA_RESP_ERR_UNSUPPORTED_FOR_MESSAGE_FORMAT = 43,\n  RD_KAFKA_RESP_ERR_POLICY_VIOLATION = 44,\n  RD_KAFKA_RESP_ERR_OUT_OF_ORDER_SEQUENCE_NUMBER = 45,\n  RD_KAFKA_RESP_ERR_DUPLICATE_SEQUENCE_NUMBER = 46,\n  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_EPOCH = 47,\n  RD_KAFKA_RESP_ERR_INVALID_TXN_STATE = 48,\n  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_ID_MAPPING = 49,\n  RD_KAFKA_RESP_ERR_INVALID_TRANSACTION_TIMEOUT = 50,\n  RD_KAFKA_RESP_ERR_CONCURRENT_TRANSACTIONS = 51,\n  RD_KAFKA_RESP_ERR_TRANSACTION_COORDINATOR_FENCED = 52,\n  RD_KAFKA_RESP_ERR_TRANSACTIONAL_ID_AUTHORIZATION_FAILED = 53,\n  RD_KAFKA_RESP_ERR_SECURITY_DISABLED = 54,\n  RD_KAFKA_RESP_ERR_OPERATION_NOT_ATTEMPTED = 55,\n  RD_KAFKA_RESP_ERR_KAFKA_STORAGE_ERROR = 56,\n  RD_KAFKA_RESP_ERR_LOG_DIR_NOT_FOUND = 57,\n  RD_KAFKA_RESP_ERR_SASL_AUTHENTICATION_FAILED = 58,\n  RD_KAFKA_RESP_ERR_UNKNOWN_PRODUCER_ID = 59,\n  RD_KAFKA_RESP_ERR_REASSIGNMENT_IN_PROGRESS = 60,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTH_DISABLED = 61,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_NOT_FOUND = 62,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_OWNER_MISMATCH = 63,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_REQUEST_NOT_ALLOWED = 64,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTHORIZATION_FAILED = 65,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_EXPIRED = 66,\n  RD_KAFKA_RESP_ERR_INVALID_PRINCIPAL_TYPE = 67,\n  RD_KAFKA_RESP_ERR_NON_EMPTY_GROUP = 68,\n  RD_KAFKA_RESP_ERR_GROUP_ID_NOT_FOUND = 69,\n  RD_KAFKA_RESP_ERR_FETCH_SESSION_ID_NOT_FOUND = 70,\n  RD_KAFKA_RESP_ERR_INVALID_FETCH_SESSION_EPOCH = 71,\n  RD_KAFKA_RESP_ERR_LISTENER_NOT_FOUND = 72,\n  RD_KAFKA_RESP_ERR_TOPIC_DELETION_DISABLED = 73,\n  RD_KAFKA_RESP_ERR_FENCED_LEADER_EPOCH = 74,\n  RD_KAFKA_RESP_ERR_UNKNOWN_LEADER_EPOCH = 75,\n  RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76,\n  RD_KAFKA_RESP_ERR_STALE_BROKER_EPOCH = 77,\n  RD_KAFKA_RESP_ERR_OFFSET_NOT_AVAILABLE = 78,\n  RD_KAFKA_RESP_ERR_MEMBER_ID_REQUIRED = 79,\n  RD_KAFKA_RESP_ERR_PREFERRED_LEADER_NOT_AVAILABLE = 80,\n  RD_KAFKA_RESP_ERR_GROUP_MAX_SIZE_REACHED = 81,\n  RD_KAFKA_RESP_ERR_FENCED_INSTANCE_ID = 82,\n  RD_KAFKA_RESP_ERR_END_ALL,\n} rd_kafka_resp_err_t;\nstruct rd_kafka_err_desc {\n  rd_kafka_resp_err_t code;\n  char *name;\n  char *desc;\n};\nvoid rd_kafka_get_err_descs(const struct rd_kafka_err_desc **errdescs, size_t *cntp);\nconst char *rd_kafka_err2str(rd_kafka_resp_err_t err);\nconst char *rd_kafka_err2name(rd_kafka_resp_err_t err);\nrd_kafka_resp_err_t rd_kafka_last_error(void);\nrd_kafka_resp_err_t rd_kafka_errno2err(int errnox);\nint rd_kafka_errno(void);\nrd_kafka_resp_err_t rd_kafka_fatal_error(rd_kafka_t *rk, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_test_fatal_error(rd_kafka_t *rk, rd_kafka_resp_err_t err, const char *reason);\nrd_kafka_resp_err_t rd_kafka_error_code(const rd_kafka_error_t *error);\nconst char *rd_kafka_error_name(const rd_kafka_error_t *error);\nconst char *rd_kafka_error_string(const rd_kafka_error_t *error);\nint rd_kafka_error_is_fatal(const rd_kafka_error_t *error);\nint rd_kafka_error_is_retriable(const rd_kafka_error_t *error);\nint rd_kafka_error_txn_requires_abort(const rd_kafka_error_t *error);\nvoid rd_kafka_error_destroy(rd_kafka_error_t *error);\nrd_kafka_error_t *rd_kafka_error_new(rd_kafka_resp_err_t code, const char *fmt, ...);\ntypedef struct rd_kafka_topic_partition_s {\n  char *topic;\n  int32_t partition;\n  int64_t offset;\n  void *metadata;\n  size_t metadata_size;\n  void *opaque;\n  rd_kafka_resp_err_t err;\n  void *_private;\n} rd_kafka_topic_partition_t;\nvoid rd_kafka_topic_partition_destroy(rd_kafka_topic_partition_t *rktpar);\ntypedef struct rd_kafka_topic_partition_list_s {\n  int cnt;\n  int size;\n  rd_kafka_topic_partition_t *elems;\n} rd_kafka_topic_partition_list_t;\nrd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_new(int size);\nvoid rd_kafka_topic_partition_list_destroy(rd_kafka_topic_partition_list_t *rkparlist);\nrd_kafka_topic_partition_t *rd_kafka_topic_partition_list_add(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);\nvoid rd_kafka_topic_partition_list_add_range(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t start, int32_t stop);\nint rd_kafka_topic_partition_list_del(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);\nint rd_kafka_topic_partition_list_del_by_idx(rd_kafka_topic_partition_list_t *rktparlist, int idx);\nrd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_copy(const rd_kafka_topic_partition_list_t *src);\nrd_kafka_resp_err_t rd_kafka_topic_partition_list_set_offset(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition, int64_t offset);\nrd_kafka_topic_partition_t *rd_kafka_topic_partition_list_find(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);\nvoid rd_kafka_topic_partition_list_sort(rd_kafka_topic_partition_list_t *rktparlist, int (*cmp)(const void *a, const void *b, void *cmp_opaque), void *cmp_opaque);\ntypedef enum rd_kafka_vtype_t {\n  RD_KAFKA_VTYPE_END,\n  RD_KAFKA_VTYPE_TOPIC,\n  RD_KAFKA_VTYPE_RKT,\n  RD_KAFKA_VTYPE_PARTITION,\n  RD_KAFKA_VTYPE_VALUE,\n  RD_KAFKA_VTYPE_KEY,\n  RD_KAFKA_VTYPE_OPAQUE,\n  RD_KAFKA_VTYPE_MSGFLAGS,\n  RD_KAFKA_VTYPE_TIMESTAMP,\n  RD_KAFKA_VTYPE_HEADER,\n  RD_KAFKA_VTYPE_HEADERS,\n} rd_kafka_vtype_t;\ntypedef struct rd_kafka_headers_s rd_kafka_headers_t;\nrd_kafka_headers_t *rd_kafka_headers_new(size_t initial_count);\nvoid rd_kafka_headers_destroy(rd_kafka_headers_t *hdrs);\nrd_kafka_headers_t *rd_kafka_headers_copy(const rd_kafka_headers_t *src);\nrd_kafka_resp_err_t rd_kafka_header_add(rd_kafka_headers_t *hdrs, const char *name, ssize_t name_size, const void *value, ssize_t value_size);\nrd_kafka_resp_err_t rd_kafka_header_remove(rd_kafka_headers_t *hdrs, const char *name);\nrd_kafka_resp_err_t rd_kafka_header_get_last(const rd_kafka_headers_t *hdrs, const char *name, const void **valuep, size_t *sizep);\nrd_kafka_resp_err_t rd_kafka_header_get(const rd_kafka_headers_t *hdrs, size_t idx, const char *name, const void **valuep, size_t *sizep);\nrd_kafka_resp_err_t rd_kafka_header_get_all(const rd_kafka_headers_t *hdrs, size_t idx, const char **namep, const void **valuep, size_t *sizep);\ntypedef struct rd_kafka_message_s {\n  rd_kafka_resp_err_t err;\n  rd_kafka_topic_t *rkt;\n  int32_t partition;\n  void *payload;\n  size_t len;\n  void *key;\n  size_t key_len;\n  int64_t offset;\n  void *_private;\n} rd_kafka_message_t;\nvoid rd_kafka_message_destroy(rd_kafka_message_t *rkmessage);\nint64_t rd_kafka_message_timestamp(const rd_kafka_message_t *rkmessage, rd_kafka_timestamp_type_t *tstype);\nint64_t rd_kafka_message_latency(const rd_kafka_message_t *rkmessage);\nrd_kafka_resp_err_t rd_kafka_message_headers(const rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);\nrd_kafka_resp_err_t rd_kafka_message_detach_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);\nvoid rd_kafka_message_set_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t *hdrs);\nsize_t rd_kafka_header_cnt(const rd_kafka_headers_t *hdrs);\ntypedef enum {\n  RD_KAFKA_MSG_STATUS_NOT_PERSISTED = 0,\n  RD_KAFKA_MSG_STATUS_POSSIBLY_PERSISTED = 1,\n  RD_KAFKA_MSG_STATUS_PERSISTED = 2,\n} rd_kafka_msg_status_t;\nrd_kafka_msg_status_t rd_kafka_message_status(const rd_kafka_message_t *rkmessage);\ntypedef enum {\n  RD_KAFKA_CONF_UNKNOWN = (- 2),\n  RD_KAFKA_CONF_INVALID = (- 1),\n  RD_KAFKA_CONF_OK = 0,\n} rd_kafka_conf_res_t;\nrd_kafka_conf_t *rd_kafka_conf_new(void);\nvoid rd_kafka_conf_destroy(rd_kafka_conf_t *conf);\nrd_kafka_conf_t *rd_kafka_conf_dup(const rd_kafka_conf_t *conf);\nrd_kafka_conf_t *rd_kafka_conf_dup_filter(const rd_kafka_conf_t *conf, size_t filter_cnt, const char **filter);\nconst rd_kafka_conf_t *rd_kafka_conf(rd_kafka_t *rk);\nrd_kafka_conf_res_t rd_kafka_conf_set(rd_kafka_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);\nvoid rd_kafka_conf_set_events(rd_kafka_conf_t *conf, int events);\nvoid rd_kafka_conf_set_background_event_cb(rd_kafka_conf_t *conf, void (*event_cb)(rd_kafka_t *rk, rd_kafka_event_t *rkev, void *opaque));\nvoid rd_kafka_conf_set_dr_cb(rd_kafka_conf_t *conf, void (*dr_cb)(rd_kafka_t *rk, void *payload, size_t len, rd_kafka_resp_err_t err, void *opaque, void *msg_opaque));\nvoid rd_kafka_conf_set_dr_msg_cb(rd_kafka_conf_t *conf, void (*dr_msg_cb)(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, void *opaque));\nvoid rd_kafka_conf_set_consume_cb(rd_kafka_conf_t *conf, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *opaque));\nvoid rd_kafka_conf_set_rebalance_cb(rd_kafka_conf_t *conf, void (*rebalance_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *partitions, void *opaque));\nvoid rd_kafka_conf_set_offset_commit_cb(rd_kafka_conf_t *conf, void (*offset_commit_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *opaque));\nvoid rd_kafka_conf_set_error_cb(rd_kafka_conf_t *conf, void (*error_cb)(rd_kafka_t *rk, int err, const char *reason, void *opaque));\nvoid rd_kafka_conf_set_throttle_cb(rd_kafka_conf_t *conf, void (*throttle_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int throttle_time_ms, void *opaque));\nvoid rd_kafka_conf_set_log_cb(rd_kafka_conf_t *conf, void (*log_cb)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));\nvoid rd_kafka_conf_set_stats_cb(rd_kafka_conf_t *conf, int (*stats_cb)(rd_kafka_t *rk, char *json, size_t json_len, void *opaque));\nvoid rd_kafka_conf_set_oauthbearer_token_refresh_cb(rd_kafka_conf_t *conf, void (*oauthbearer_token_refresh_cb)(rd_kafka_t *rk, const char *oauthbearer_config, void *opaque));\nvoid rd_kafka_conf_set_socket_cb(rd_kafka_conf_t *conf, int (*socket_cb)(int domain, int type, int protocol, void *opaque));\nvoid rd_kafka_conf_set_connect_cb(rd_kafka_conf_t *conf, int (*connect_cb)(int sockfd, const struct sockaddr *addr, int addrlen, const char *id, void *opaque));\nvoid rd_kafka_conf_set_closesocket_cb(rd_kafka_conf_t *conf, int (*closesocket_cb)(int sockfd, void *opaque));\nrd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert_verify_cb(rd_kafka_conf_t *conf, int (*ssl_cert_verify_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int *x509_error, int depth, const char *buf, size_t size, char *errstr, size_t errstr_size, void *opaque));\ntypedef enum rd_kafka_cert_type_t {\n  RD_KAFKA_CERT_PUBLIC_KEY,\n  RD_KAFKA_CERT_PRIVATE_KEY,\n  RD_KAFKA_CERT_CA,\n  RD_KAFKA_CERT__CNT,\n} rd_kafka_cert_type_t;\ntypedef enum rd_kafka_cert_enc_t {\n  RD_KAFKA_CERT_ENC_PKCS12,\n  RD_KAFKA_CERT_ENC_DER,\n  RD_KAFKA_CERT_ENC_PEM,\n  RD_KAFKA_CERT_ENC__CNT,\n} rd_kafka_cert_enc_t;\nrd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert(rd_kafka_conf_t *conf, rd_kafka_cert_type_t cert_type, rd_kafka_cert_enc_t cert_enc, const void *buffer, size_t size, char *errstr, size_t errstr_size);\nvoid rd_kafka_conf_set_opaque(rd_kafka_conf_t *conf, void *opaque);\nvoid *rd_kafka_opaque(const rd_kafka_t *rk);\nvoid rd_kafka_conf_set_default_topic_conf(rd_kafka_conf_t *conf, rd_kafka_topic_conf_t *tconf);\nrd_kafka_conf_res_t rd_kafka_conf_get(const rd_kafka_conf_t *conf, const char *name, char *dest, size_t *dest_size);\nrd_kafka_conf_res_t rd_kafka_topic_conf_get(const rd_kafka_topic_conf_t *conf, const char *name, char *dest, size_t *dest_size);\nconst char **rd_kafka_conf_dump(rd_kafka_conf_t *conf, size_t *cntp);\nconst char **rd_kafka_topic_conf_dump(rd_kafka_topic_conf_t *conf, size_t *cntp);\nvoid rd_kafka_conf_dump_free(const char **arr, size_t cnt);\nvoid rd_kafka_conf_properties_show(FILE *fp);\nrd_kafka_topic_conf_t *rd_kafka_topic_conf_new(void);\nrd_kafka_topic_conf_t *rd_kafka_topic_conf_dup(const rd_kafka_topic_conf_t *conf);\nrd_kafka_topic_conf_t *rd_kafka_default_topic_conf_dup(rd_kafka_t *rk);\nvoid rd_kafka_topic_conf_destroy(rd_kafka_topic_conf_t *topic_conf);\nrd_kafka_conf_res_t rd_kafka_topic_conf_set(rd_kafka_topic_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);\nvoid rd_kafka_topic_conf_set_opaque(rd_kafka_topic_conf_t *conf, void *rkt_opaque);\nvoid rd_kafka_topic_conf_set_partitioner_cb(rd_kafka_topic_conf_t *topic_conf, int32_t (*partitioner)(const rd_kafka_topic_t *rkt, const void *keydata, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque));\nvoid rd_kafka_topic_conf_set_msg_order_cmp(rd_kafka_topic_conf_t *topic_conf, int (*msg_order_cmp)(const rd_kafka_message_t *a, const rd_kafka_message_t *b));\nint rd_kafka_topic_partition_available(const rd_kafka_topic_t *rkt, int32_t partition);\nint32_t rd_kafka_msg_partitioner_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_consistent(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_consistent_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_murmur2(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_murmur2_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_fnv1a(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_fnv1a_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nrd_kafka_t *rd_kafka_new(rd_kafka_type_t type, rd_kafka_conf_t *conf, char *errstr, size_t errstr_size);\nvoid rd_kafka_destroy(rd_kafka_t *rk);\nvoid rd_kafka_destroy_flags(rd_kafka_t *rk, int flags);\nconst char *rd_kafka_name(const rd_kafka_t *rk);\nrd_kafka_type_t rd_kafka_type(const rd_kafka_t *rk);\nchar *rd_kafka_memberid(const rd_kafka_t *rk);\nchar *rd_kafka_clusterid(rd_kafka_t *rk, int timeout_ms);\nint32_t rd_kafka_controllerid(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_topic_t *rd_kafka_topic_new(rd_kafka_t *rk, const char *topic, rd_kafka_topic_conf_t *conf);\nvoid rd_kafka_topic_destroy(rd_kafka_topic_t *rkt);\nconst char *rd_kafka_topic_name(const rd_kafka_topic_t *rkt);\nvoid *rd_kafka_topic_opaque(const rd_kafka_topic_t *rkt);\nint rd_kafka_poll(rd_kafka_t *rk, int timeout_ms);\nvoid rd_kafka_yield(rd_kafka_t *rk);\nrd_kafka_resp_err_t rd_kafka_pause_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_resp_err_t rd_kafka_resume_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_resp_err_t rd_kafka_query_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high, int timeout_ms);\nrd_kafka_resp_err_t rd_kafka_get_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high);\nrd_kafka_resp_err_t rd_kafka_offsets_for_times(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets, int timeout_ms);\nvoid rd_kafka_mem_free(rd_kafka_t *rk, void *ptr);\nrd_kafka_queue_t *rd_kafka_queue_new(rd_kafka_t *rk);\nvoid rd_kafka_queue_destroy(rd_kafka_queue_t *rkqu);\nrd_kafka_queue_t *rd_kafka_queue_get_main(rd_kafka_t *rk);\nrd_kafka_queue_t *rd_kafka_queue_get_consumer(rd_kafka_t *rk);\nrd_kafka_queue_t *rd_kafka_queue_get_partition(rd_kafka_t *rk, const char *topic, int32_t partition);\nrd_kafka_queue_t *rd_kafka_queue_get_background(rd_kafka_t *rk);\nvoid rd_kafka_queue_forward(rd_kafka_queue_t *src, rd_kafka_queue_t *dst);\nrd_kafka_resp_err_t rd_kafka_set_log_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu);\nsize_t rd_kafka_queue_length(rd_kafka_queue_t *rkqu);\nvoid rd_kafka_queue_io_event_enable(rd_kafka_queue_t *rkqu, int fd, const void *payload, size_t size);\nvoid rd_kafka_queue_cb_event_enable(rd_kafka_queue_t *rkqu, void (*event_cb)(rd_kafka_t *rk, void *qev_opaque), void *qev_opaque);\nint rd_kafka_consume_start(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);\nint rd_kafka_consume_start_queue(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, rd_kafka_queue_t *rkqu);\nint rd_kafka_consume_stop(rd_kafka_topic_t *rkt, int32_t partition);\nrd_kafka_resp_err_t rd_kafka_seek(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, int timeout_ms);\nrd_kafka_message_t *rd_kafka_consume(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms);\nssize_t rd_kafka_consume_batch(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);\nint rd_kafka_consume_callback(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);\nrd_kafka_message_t *rd_kafka_consume_queue(rd_kafka_queue_t *rkqu, int timeout_ms);\nssize_t rd_kafka_consume_batch_queue(rd_kafka_queue_t *rkqu, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);\nint rd_kafka_consume_callback_queue(rd_kafka_queue_t *rkqu, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);\nrd_kafka_resp_err_t rd_kafka_offset_store(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);\nrd_kafka_resp_err_t rd_kafka_offsets_store(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets);\nrd_kafka_resp_err_t rd_kafka_subscribe(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *topics);\nrd_kafka_resp_err_t rd_kafka_unsubscribe(rd_kafka_t *rk);\nrd_kafka_resp_err_t rd_kafka_subscription(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **topics);\nrd_kafka_message_t *rd_kafka_consumer_poll(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_resp_err_t rd_kafka_consumer_close(rd_kafka_t *rk);\nrd_kafka_resp_err_t rd_kafka_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_resp_err_t rd_kafka_assignment(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **partitions);\nrd_kafka_resp_err_t rd_kafka_commit(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, int async);\nrd_kafka_resp_err_t rd_kafka_commit_message(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, int async);\nrd_kafka_resp_err_t rd_kafka_commit_queue(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_queue_t *rkqu, void (*cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *commit_opaque), void *commit_opaque);\nrd_kafka_resp_err_t rd_kafka_committed(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms);\nrd_kafka_resp_err_t rd_kafka_position(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata(rd_kafka_t *rk);\nrd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata_new(const char *group_id);\nvoid rd_kafka_consumer_group_metadata_destroy(rd_kafka_consumer_group_metadata_t *);\nrd_kafka_error_t *rd_kafka_consumer_group_metadata_write(const rd_kafka_consumer_group_metadata_t *cgmd, void **bufferp, size_t *sizep);\nrd_kafka_error_t *rd_kafka_consumer_group_metadata_read(rd_kafka_consumer_group_metadata_t **cgmdp, const void *buffer, size_t size);\nint rd_kafka_produce(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, void *payload, size_t len, const void *key, size_t keylen, void *msg_opaque);\nrd_kafka_resp_err_t rd_kafka_producev(rd_kafka_t *rk, ...);\nint rd_kafka_produce_batch(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, rd_kafka_message_t *rkmessages, int message_cnt);\nrd_kafka_resp_err_t rd_kafka_flush(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_resp_err_t rd_kafka_purge(rd_kafka_t *rk, int purge_flags);\ntypedef struct rd_kafka_metadata_broker {\n  int32_t id;\n  char *host;\n  int port;\n} rd_kafka_metadata_broker_t;\ntypedef struct rd_kafka_metadata_partition {\n  int32_t id;\n  rd_kafka_resp_err_t err;\n  int32_t leader;\n  int replica_cnt;\n  int32_t *replicas;\n  int isr_cnt;\n  int32_t *isrs;\n} rd_kafka_metadata_partition_t;\ntypedef struct rd_kafka_metadata_topic {\n  char *topic;\n  int partition_cnt;\n  struct rd_kafka_metadata_partition *partitions;\n  rd_kafka_resp_err_t err;\n} rd_kafka_metadata_topic_t;\ntypedef struct rd_kafka_metadata {\n  int broker_cnt;\n  struct rd_kafka_metadata_broker *brokers;\n  int topic_cnt;\n  struct rd_kafka_metadata_topic *topics;\n  int32_t orig_broker_id;\n  char *orig_broker_name;\n} rd_kafka_metadata_t;\nrd_kafka_resp_err_t rd_kafka_metadata(rd_kafka_t *rk, int all_topics, rd_kafka_topic_t *only_rkt, const struct rd_kafka_metadata **metadatap, int timeout_ms);\nvoid rd_kafka_metadata_destroy(const struct rd_kafka_metadata *metadata);\nstruct rd_kafka_group_member_info {\n  char *member_id;\n  char *client_id;\n  char *client_host;\n  void *member_metadata;\n  int member_metadata_size;\n  void *member_assignment;\n  int member_assignment_size;\n};\nstruct rd_kafka_group_info {\n  struct rd_kafka_metadata_broker broker;\n  char *group;\n  rd_kafka_resp_err_t err;\n  char *state;\n  char *protocol_type;\n  char *protocol;\n  struct rd_kafka_group_member_info *members;\n  int member_cnt;\n};\nstruct rd_kafka_group_list {\n  struct rd_kafka_group_info *groups;\n  int group_cnt;\n};\nrd_kafka_resp_err_t rd_kafka_list_groups(rd_kafka_t *rk, const char *group, const struct rd_kafka_group_list **grplistp, int timeout_ms);\nvoid rd_kafka_group_list_destroy(const struct rd_kafka_group_list *grplist);\nint rd_kafka_brokers_add(rd_kafka_t *rk, const char *brokerlist);\nvoid rd_kafka_set_logger(rd_kafka_t *rk, void (*func)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));\nvoid rd_kafka_set_log_level(rd_kafka_t *rk, int level);\nvoid rd_kafka_log_print(const rd_kafka_t *rk, int level, const char *fac, const char *buf);\nvoid rd_kafka_log_syslog(const rd_kafka_t *rk, int level, const char *fac, const char *buf);\nint rd_kafka_outq_len(rd_kafka_t *rk);\nvoid rd_kafka_dump(FILE *fp, rd_kafka_t *rk);\nint rd_kafka_thread_cnt(void);\ntypedef enum rd_kafka_thread_type_t {\n  RD_KAFKA_THREAD_MAIN,\n  RD_KAFKA_THREAD_BACKGROUND,\n  RD_KAFKA_THREAD_BROKER,\n} rd_kafka_thread_type_t;\nint rd_kafka_wait_destroyed(int timeout_ms);\nint rd_kafka_unittest(void);\nrd_kafka_resp_err_t rd_kafka_poll_set_consumer(rd_kafka_t *rk);\ntypedef int rd_kafka_event_type_t;\nrd_kafka_event_type_t rd_kafka_event_type(const rd_kafka_event_t *rkev);\nconst char *rd_kafka_event_name(const rd_kafka_event_t *rkev);\nvoid rd_kafka_event_destroy(rd_kafka_event_t *rkev);\nconst rd_kafka_message_t *rd_kafka_event_message_next(rd_kafka_event_t *rkev);\nsize_t rd_kafka_event_message_array(rd_kafka_event_t *rkev, const rd_kafka_message_t **rkmessages, size_t size);\nsize_t rd_kafka_event_message_count(rd_kafka_event_t *rkev);\nconst char *rd_kafka_event_config_string(rd_kafka_event_t *rkev);\nrd_kafka_resp_err_t rd_kafka_event_error(rd_kafka_event_t *rkev);\nconst char *rd_kafka_event_error_string(rd_kafka_event_t *rkev);\nint rd_kafka_event_error_is_fatal(rd_kafka_event_t *rkev);\nvoid *rd_kafka_event_opaque(rd_kafka_event_t *rkev);\nint rd_kafka_event_log(rd_kafka_event_t *rkev, const char **fac, const char **str, int *level);\nconst char *rd_kafka_event_stats(rd_kafka_event_t *rkev);\nrd_kafka_topic_partition_list_t *rd_kafka_event_topic_partition_list(rd_kafka_event_t *rkev);\nrd_kafka_topic_partition_t *rd_kafka_event_topic_partition(rd_kafka_event_t *rkev);\ntypedef rd_kafka_event_t rd_kafka_CreateTopics_result_t;\ntypedef rd_kafka_event_t rd_kafka_DeleteTopics_result_t;\ntypedef rd_kafka_event_t rd_kafka_CreatePartitions_result_t;\ntypedef rd_kafka_event_t rd_kafka_AlterConfigs_result_t;\ntypedef rd_kafka_event_t rd_kafka_DescribeConfigs_result_t;\nconst rd_kafka_CreateTopics_result_t *rd_kafka_event_CreateTopics_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DeleteTopics_result_t *rd_kafka_event_DeleteTopics_result(rd_kafka_event_t *rkev);\nconst rd_kafka_CreatePartitions_result_t *rd_kafka_event_CreatePartitions_result(rd_kafka_event_t *rkev);\nconst rd_kafka_AlterConfigs_result_t *rd_kafka_event_AlterConfigs_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DescribeConfigs_result_t *rd_kafka_event_DescribeConfigs_result(rd_kafka_event_t *rkev);\nrd_kafka_event_t *rd_kafka_queue_poll(rd_kafka_queue_t *rkqu, int timeout_ms);\nint rd_kafka_queue_poll_callback(rd_kafka_queue_t *rkqu, int timeout_ms);\ntypedef rd_kafka_resp_err_t (rd_kafka_plugin_f_conf_init_t)(rd_kafka_conf_t *conf, void **plug_opaquep, char *errstr, size_t errstr_size);\ntypedef rd_kafka_conf_res_t (rd_kafka_interceptor_f_on_conf_set_t)(rd_kafka_conf_t *conf, const char *name, const char *val, char *errstr, size_t errstr_size, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_dup_t)(rd_kafka_conf_t *new_conf, const rd_kafka_conf_t *old_conf, size_t filter_cnt, const char **filter, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_destroy_t)(void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_new_t)(rd_kafka_t *rk, const rd_kafka_conf_t *conf, void *ic_opaque, char *errstr, size_t errstr_size);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_destroy_t)(rd_kafka_t *rk, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_send_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_acknowledgement_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_consume_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_commit_t)(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_resp_err_t err, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_request_sent_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_start_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_exit_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_set(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_set_t *on_conf_set, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_dup(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_dup_t *on_conf_dup, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_destroy(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_destroy_t *on_conf_destroy, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_new(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_new_t *on_new, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_destroy(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_destroy_t *on_destroy, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_send(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_send_t *on_send, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_acknowledgement(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_acknowledgement_t *on_acknowledgement, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_consume(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_consume_t *on_consume, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_commit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_commit_t *on_commit, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_request_sent(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_request_sent_t *on_request_sent, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_start(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_start_t *on_thread_start, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_exit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_exit_t *on_thread_exit, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_topic_result_error(const rd_kafka_topic_result_t *topicres);\nconst char *rd_kafka_topic_result_error_string(const rd_kafka_topic_result_t *topicres);\nconst char *rd_kafka_topic_result_name(const rd_kafka_topic_result_t *topicres);\ntypedef enum rd_kafka_admin_op_t {\n  RD_KAFKA_ADMIN_OP_ANY = 0,\n  RD_KAFKA_ADMIN_OP_CREATETOPICS,\n  RD_KAFKA_ADMIN_OP_DELETETOPICS,\n  RD_KAFKA_ADMIN_OP_CREATEPARTITIONS,\n  RD_KAFKA_ADMIN_OP_ALTERCONFIGS,\n  RD_KAFKA_ADMIN_OP_DESCRIBECONFIGS,\n  RD_KAFKA_ADMIN_OP__CNT,\n} rd_kafka_admin_op_t;\ntypedef struct rd_kafka_AdminOptions_s rd_kafka_AdminOptions_t;\nrd_kafka_AdminOptions_t *rd_kafka_AdminOptions_new(rd_kafka_t *rk, rd_kafka_admin_op_t for_api);\nvoid rd_kafka_AdminOptions_destroy(rd_kafka_AdminOptions_t *options);\nrd_kafka_resp_err_t rd_kafka_AdminOptions_set_request_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_AdminOptions_set_operation_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_AdminOptions_set_validate_only(rd_kafka_AdminOptions_t *options, int true_or_false, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_AdminOptions_set_broker(rd_kafka_AdminOptions_t *options, int32_t broker_id, char *errstr, size_t errstr_size);\nvoid rd_kafka_AdminOptions_set_opaque(rd_kafka_AdminOptions_t *options, void *ev_opaque);\ntypedef struct rd_kafka_NewTopic_s rd_kafka_NewTopic_t;\nrd_kafka_NewTopic_t *rd_kafka_NewTopic_new(const char *topic, int num_partitions, int replication_factor, char *errstr, size_t errstr_size);\nvoid rd_kafka_NewTopic_destroy(rd_kafka_NewTopic_t *new_topic);\nvoid rd_kafka_NewTopic_destroy_array(rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt);\nrd_kafka_resp_err_t rd_kafka_NewTopic_set_replica_assignment(rd_kafka_NewTopic_t *new_topic, int32_t partition, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_NewTopic_set_config(rd_kafka_NewTopic_t *new_topic, const char *name, const char *value);\nvoid rd_kafka_CreateTopics(rd_kafka_t *rk, rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_topic_result_t **rd_kafka_CreateTopics_result_topics(const rd_kafka_CreateTopics_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_DeleteTopic_s rd_kafka_DeleteTopic_t;\nrd_kafka_DeleteTopic_t *rd_kafka_DeleteTopic_new(const char *topic);\nvoid rd_kafka_DeleteTopic_destroy(rd_kafka_DeleteTopic_t *del_topic);\nvoid rd_kafka_DeleteTopic_destroy_array(rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt);\nvoid rd_kafka_DeleteTopics(rd_kafka_t *rk, rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_topic_result_t **rd_kafka_DeleteTopics_result_topics(const rd_kafka_DeleteTopics_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_NewPartitions_s rd_kafka_NewPartitions_t;\nrd_kafka_NewPartitions_t *rd_kafka_NewPartitions_new(const char *topic, size_t new_total_cnt, char *errstr, size_t errstr_size);\nvoid rd_kafka_NewPartitions_destroy(rd_kafka_NewPartitions_t *new_parts);\nvoid rd_kafka_NewPartitions_destroy_array(rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt);\nrd_kafka_resp_err_t rd_kafka_NewPartitions_set_replica_assignment(rd_kafka_NewPartitions_t *new_parts, int32_t new_partition_idx, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);\nvoid rd_kafka_CreatePartitions(rd_kafka_t *rk, rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_topic_result_t **rd_kafka_CreatePartitions_result_topics(const rd_kafka_CreatePartitions_result_t *result, size_t *cntp);\ntypedef enum rd_kafka_ConfigSource_t {\n  RD_KAFKA_CONFIG_SOURCE_UNKNOWN_CONFIG = 0,\n  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_TOPIC_CONFIG = 1,\n  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_BROKER_CONFIG = 2,\n  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_DEFAULT_BROKER_CONFIG = 3,\n  RD_KAFKA_CONFIG_SOURCE_STATIC_BROKER_CONFIG = 4,\n  RD_KAFKA_CONFIG_SOURCE_DEFAULT_CONFIG = 5,\n  RD_KAFKA_CONFIG_SOURCE__CNT,\n} rd_kafka_ConfigSource_t;\nconst char *rd_kafka_ConfigSource_name(rd_kafka_ConfigSource_t confsource);\ntypedef struct rd_kafka_ConfigEntry_s rd_kafka_ConfigEntry_t;\nconst char *rd_kafka_ConfigEntry_name(const rd_kafka_ConfigEntry_t *entry);\nconst char *rd_kafka_ConfigEntry_value(const rd_kafka_ConfigEntry_t *entry);\nrd_kafka_ConfigSource_t rd_kafka_ConfigEntry_source(const rd_kafka_ConfigEntry_t *entry);\nint rd_kafka_ConfigEntry_is_read_only(const rd_kafka_ConfigEntry_t *entry);\nint rd_kafka_ConfigEntry_is_default(const rd_kafka_ConfigEntry_t *entry);\nint rd_kafka_ConfigEntry_is_sensitive(const rd_kafka_ConfigEntry_t *entry);\nint rd_kafka_ConfigEntry_is_synonym(const rd_kafka_ConfigEntry_t *entry);\nconst rd_kafka_ConfigEntry_t **rd_kafka_ConfigEntry_synonyms(const rd_kafka_ConfigEntry_t *entry, size_t *cntp);\ntypedef enum rd_kafka_ResourceType_t {\n  RD_KAFKA_RESOURCE_UNKNOWN = 0,\n  RD_KAFKA_RESOURCE_ANY = 1,\n  RD_KAFKA_RESOURCE_TOPIC = 2,\n  RD_KAFKA_RESOURCE_GROUP = 3,\n  RD_KAFKA_RESOURCE_BROKER = 4,\n  RD_KAFKA_RESOURCE__CNT,\n} rd_kafka_ResourceType_t;\nconst char *rd_kafka_ResourceType_name(rd_kafka_ResourceType_t restype);\ntypedef struct rd_kafka_ConfigResource_s rd_kafka_ConfigResource_t;\nrd_kafka_ConfigResource_t *rd_kafka_ConfigResource_new(rd_kafka_ResourceType_t restype, const char *resname);\nvoid rd_kafka_ConfigResource_destroy(rd_kafka_ConfigResource_t *config);\nvoid rd_kafka_ConfigResource_destroy_array(rd_kafka_ConfigResource_t **config, size_t config_cnt);\nrd_kafka_resp_err_t rd_kafka_ConfigResource_set_config(rd_kafka_ConfigResource_t *config, const char *name, const char *value);\nconst rd_kafka_ConfigEntry_t **rd_kafka_ConfigResource_configs(const rd_kafka_ConfigResource_t *config, size_t *cntp);\nrd_kafka_ResourceType_t rd_kafka_ConfigResource_type(const rd_kafka_ConfigResource_t *config);\nconst char *rd_kafka_ConfigResource_name(const rd_kafka_ConfigResource_t *config);\nrd_kafka_resp_err_t rd_kafka_ConfigResource_error(const rd_kafka_ConfigResource_t *config);\nconst char *rd_kafka_ConfigResource_error_string(const rd_kafka_ConfigResource_t *config);\nvoid rd_kafka_AlterConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_ConfigResource_t **rd_kafka_AlterConfigs_result_resources(const rd_kafka_AlterConfigs_result_t *result, size_t *cntp);\nvoid rd_kafka_DescribeConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_ConfigResource_t **rd_kafka_DescribeConfigs_result_resources(const rd_kafka_DescribeConfigs_result_t *result, size_t *cntp);\nrd_kafka_resp_err_t rd_kafka_oauthbearer_set_token(rd_kafka_t *rk, const char *token_value, int64_t md_lifetime_ms, const char *md_principal_name, const char **extensions, size_t extension_size, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_oauthbearer_set_token_failure(rd_kafka_t *rk, const char *errstr);\nrd_kafka_error_t *rd_kafka_init_transactions(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_error_t *rd_kafka_begin_transaction(rd_kafka_t *rk);\nrd_kafka_error_t *rd_kafka_send_offsets_to_transaction(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, const rd_kafka_consumer_group_metadata_t *cgmetadata, int timeout_ms);\nrd_kafka_error_t *rd_kafka_commit_transaction(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_error_t *rd_kafka_abort_transaction(rd_kafka_t *rk, int timeout_ms);\ntypedef struct rd_kafka_mock_cluster_s rd_kafka_mock_cluster_t;\nrd_kafka_mock_cluster_t *rd_kafka_mock_cluster_new(rd_kafka_t *rk, int broker_cnt);\nvoid rd_kafka_mock_cluster_destroy(rd_kafka_mock_cluster_t *mcluster);\nrd_kafka_t *rd_kafka_mock_cluster_handle(const rd_kafka_mock_cluster_t *mcluster);\nrd_kafka_mock_cluster_t *rd_kafka_handle_mock_cluster(const rd_kafka_t *rk);\nconst char *rd_kafka_mock_cluster_bootstraps(const rd_kafka_mock_cluster_t *mcluster);\nvoid rd_kafka_mock_push_request_errors(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, size_t cnt, ...);\nvoid rd_kafka_mock_topic_set_error(rd_kafka_mock_cluster_t *mcluster, const char *topic, rd_kafka_resp_err_t err);\nrd_kafka_resp_err_t rd_kafka_mock_topic_create(rd_kafka_mock_cluster_t *mcluster, const char *topic, int partition_cnt, int replication_factor);\nrd_kafka_resp_err_t rd_kafka_mock_partition_set_leader(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id);\nrd_kafka_resp_err_t rd_kafka_mock_partition_set_follower(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id);\nrd_kafka_resp_err_t rd_kafka_mock_partition_set_follower_wmarks(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int64_t lo, int64_t hi);\nrd_kafka_resp_err_t rd_kafka_mock_broker_set_down(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id);\nrd_kafka_resp_err_t rd_kafka_mock_broker_set_up(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id);\nrd_kafka_resp_err_t rd_kafka_mock_broker_set_rack(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, const char *rack);\nrd_kafka_resp_err_t rd_kafka_mock_coordinator_set(rd_kafka_mock_cluster_t *mcluster, const char *key_type, const char *key, int32_t broker_id);\nrd_kafka_resp_err_t rd_kafka_mock_set_apiversion(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, int16_t MinVersion, int16_t MaxVersion);\n'\n</code></pre> rdkafka.h, rdkafka_mock.h</p>"},{"location":"api/constants/#rd_kafka_version_8","title":"RD_KAFKA_VERSION","text":"<pre><code>public RD_KAFKA_VERSION = 17040127\n</code></pre> <p>librdkafka version </p> <p>Interpreted as hex <code>MM.mm.rr.xx</code>:</p> <ul> <li>MM = Major</li> <li>mm = minor</li> <li>rr = revision</li> <li>xx = pre-release id (0xff is the final release)</li> </ul> <p>E.g.: <code>0x000801ff</code> = 0.8.1</p> RemarksThis value should only be used during compile time, for runtime checks of version use rd_kafka_version()  <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_unsupported_compression_type_8","title":"RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE","text":"<pre><code>public RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76\n</code></pre> <p>Unsupported compression type </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_end_all_8","title":"RD_KAFKA_RESP_ERR_END_ALL","text":"<p><pre><code>public RD_KAFKA_RESP_ERR_END_ALL = 83\n</code></pre> enum rd_kafka_resp_err_t</p>"},{"location":"api/constants/#rd_kafka_admin_op__cnt_8","title":"RD_KAFKA_ADMIN_OP__CNT","text":"<pre><code>public RD_KAFKA_ADMIN_OP__CNT = 6\n</code></pre> <p>Number of ops defined </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe </li> </ul>"},{"location":"api/constants/#rd_kafka_resource__cnt_8","title":"RD_KAFKA_RESOURCE__CNT","text":"<pre><code>public RD_KAFKA_RESOURCE__CNT = 5\n</code></pre> <p>Number of resource types defined </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#acca83a66d7783ff7683ed2691cc907c9 </li> </ul>"},{"location":"api/constants/#rd_kafka_cdef_8","title":"RD_KAFKA_CDEF","text":"<p><pre><code>public RD_KAFKA_CDEF = 'typedef long int ssize_t;\ntypedef struct _IO_FILE FILE;\ntypedef long int mode_t;\ntypedef signed int int16_t;\ntypedef unsigned int uint16_t;\ntypedef signed int int32_t;\ntypedef signed long int int64_t;\nint rd_kafka_version(void);\nconst char *rd_kafka_version_str(void);\ntypedef enum rd_kafka_type_t {\n  RD_KAFKA_PRODUCER,\n  RD_KAFKA_CONSUMER,\n} rd_kafka_type_t;\ntypedef enum rd_kafka_timestamp_type_t {\n  RD_KAFKA_TIMESTAMP_NOT_AVAILABLE,\n  RD_KAFKA_TIMESTAMP_CREATE_TIME,\n  RD_KAFKA_TIMESTAMP_LOG_APPEND_TIME,\n} rd_kafka_timestamp_type_t;\nconst char *rd_kafka_get_debug_contexts(void);\ntypedef struct rd_kafka_s rd_kafka_t;\ntypedef struct rd_kafka_topic_s rd_kafka_topic_t;\ntypedef struct rd_kafka_conf_s rd_kafka_conf_t;\ntypedef struct rd_kafka_topic_conf_s rd_kafka_topic_conf_t;\ntypedef struct rd_kafka_queue_s rd_kafka_queue_t;\ntypedef struct rd_kafka_op_s rd_kafka_event_t;\ntypedef struct rd_kafka_topic_result_s rd_kafka_topic_result_t;\ntypedef struct rd_kafka_consumer_group_metadata_s rd_kafka_consumer_group_metadata_t;\ntypedef struct rd_kafka_error_s {\n  unsigned int code;\n  char *errstr;\n  unsigned char fatal;\n  unsigned char retriable;\n  unsigned char txn_requires_abort;\n} rd_kafka_error_t;\ntypedef enum {\n  RD_KAFKA_RESP_ERR__BEGIN = (- 200),\n  RD_KAFKA_RESP_ERR__BAD_MSG = (- 199),\n  RD_KAFKA_RESP_ERR__BAD_COMPRESSION = (- 198),\n  RD_KAFKA_RESP_ERR__DESTROY = (- 197),\n  RD_KAFKA_RESP_ERR__FAIL = (- 196),\n  RD_KAFKA_RESP_ERR__TRANSPORT = (- 195),\n  RD_KAFKA_RESP_ERR__CRIT_SYS_RESOURCE = (- 194),\n  RD_KAFKA_RESP_ERR__RESOLVE = (- 193),\n  RD_KAFKA_RESP_ERR__MSG_TIMED_OUT = (- 192),\n  RD_KAFKA_RESP_ERR__PARTITION_EOF = (- 191),\n  RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION = (- 190),\n  RD_KAFKA_RESP_ERR__FS = (- 189),\n  RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC = (- 188),\n  RD_KAFKA_RESP_ERR__ALL_BROKERS_DOWN = (- 187),\n  RD_KAFKA_RESP_ERR__INVALID_ARG = (- 186),\n  RD_KAFKA_RESP_ERR__TIMED_OUT = (- 185),\n  RD_KAFKA_RESP_ERR__QUEUE_FULL = (- 184),\n  RD_KAFKA_RESP_ERR__ISR_INSUFF = (- 183),\n  RD_KAFKA_RESP_ERR__NODE_UPDATE = (- 182),\n  RD_KAFKA_RESP_ERR__SSL = (- 181),\n  RD_KAFKA_RESP_ERR__WAIT_COORD = (- 180),\n  RD_KAFKA_RESP_ERR__UNKNOWN_GROUP = (- 179),\n  RD_KAFKA_RESP_ERR__IN_PROGRESS = (- 178),\n  RD_KAFKA_RESP_ERR__PREV_IN_PROGRESS = (- 177),\n  RD_KAFKA_RESP_ERR__EXISTING_SUBSCRIPTION = (- 176),\n  RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS = (- 175),\n  RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS = (- 174),\n  RD_KAFKA_RESP_ERR__CONFLICT = (- 173),\n  RD_KAFKA_RESP_ERR__STATE = (- 172),\n  RD_KAFKA_RESP_ERR__UNKNOWN_PROTOCOL = (- 171),\n  RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED = (- 170),\n  RD_KAFKA_RESP_ERR__AUTHENTICATION = (- 169),\n  RD_KAFKA_RESP_ERR__NO_OFFSET = (- 168),\n  RD_KAFKA_RESP_ERR__OUTDATED = (- 167),\n  RD_KAFKA_RESP_ERR__TIMED_OUT_QUEUE = (- 166),\n  RD_KAFKA_RESP_ERR__UNSUPPORTED_FEATURE = (- 165),\n  RD_KAFKA_RESP_ERR__WAIT_CACHE = (- 164),\n  RD_KAFKA_RESP_ERR__INTR = (- 163),\n  RD_KAFKA_RESP_ERR__KEY_SERIALIZATION = (- 162),\n  RD_KAFKA_RESP_ERR__VALUE_SERIALIZATION = (- 161),\n  RD_KAFKA_RESP_ERR__KEY_DESERIALIZATION = (- 160),\n  RD_KAFKA_RESP_ERR__VALUE_DESERIALIZATION = (- 159),\n  RD_KAFKA_RESP_ERR__PARTIAL = (- 158),\n  RD_KAFKA_RESP_ERR__READ_ONLY = (- 157),\n  RD_KAFKA_RESP_ERR__NOENT = (- 156),\n  RD_KAFKA_RESP_ERR__UNDERFLOW = (- 155),\n  RD_KAFKA_RESP_ERR__INVALID_TYPE = (- 154),\n  RD_KAFKA_RESP_ERR__RETRY = (- 153),\n  RD_KAFKA_RESP_ERR__PURGE_QUEUE = (- 152),\n  RD_KAFKA_RESP_ERR__PURGE_INFLIGHT = (- 151),\n  RD_KAFKA_RESP_ERR__FATAL = (- 150),\n  RD_KAFKA_RESP_ERR__INCONSISTENT = (- 149),\n  RD_KAFKA_RESP_ERR__GAPLESS_GUARANTEE = (- 148),\n  RD_KAFKA_RESP_ERR__MAX_POLL_EXCEEDED = (- 147),\n  RD_KAFKA_RESP_ERR__UNKNOWN_BROKER = (- 146),\n  RD_KAFKA_RESP_ERR__NOT_CONFIGURED = (- 145),\n  RD_KAFKA_RESP_ERR__FENCED = (- 144),\n  RD_KAFKA_RESP_ERR__APPLICATION = (- 143),\n  RD_KAFKA_RESP_ERR__END = (- 100),\n  RD_KAFKA_RESP_ERR_UNKNOWN = (- 1),\n  RD_KAFKA_RESP_ERR_NO_ERROR = 0,\n  RD_KAFKA_RESP_ERR_OFFSET_OUT_OF_RANGE = 1,\n  RD_KAFKA_RESP_ERR_INVALID_MSG = 2,\n  RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART = 3,\n  RD_KAFKA_RESP_ERR_INVALID_MSG_SIZE = 4,\n  RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE = 5,\n  RD_KAFKA_RESP_ERR_NOT_LEADER_FOR_PARTITION = 6,\n  RD_KAFKA_RESP_ERR_REQUEST_TIMED_OUT = 7,\n  RD_KAFKA_RESP_ERR_BROKER_NOT_AVAILABLE = 8,\n  RD_KAFKA_RESP_ERR_REPLICA_NOT_AVAILABLE = 9,\n  RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE = 10,\n  RD_KAFKA_RESP_ERR_STALE_CTRL_EPOCH = 11,\n  RD_KAFKA_RESP_ERR_OFFSET_METADATA_TOO_LARGE = 12,\n  RD_KAFKA_RESP_ERR_NETWORK_EXCEPTION = 13,\n  RD_KAFKA_RESP_ERR_COORDINATOR_LOAD_IN_PROGRESS = 14,\n  RD_KAFKA_RESP_ERR_COORDINATOR_NOT_AVAILABLE = 15,\n  RD_KAFKA_RESP_ERR_NOT_COORDINATOR = 16,\n  RD_KAFKA_RESP_ERR_TOPIC_EXCEPTION = 17,\n  RD_KAFKA_RESP_ERR_RECORD_LIST_TOO_LARGE = 18,\n  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS = 19,\n  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS_AFTER_APPEND = 20,\n  RD_KAFKA_RESP_ERR_INVALID_REQUIRED_ACKS = 21,\n  RD_KAFKA_RESP_ERR_ILLEGAL_GENERATION = 22,\n  RD_KAFKA_RESP_ERR_INCONSISTENT_GROUP_PROTOCOL = 23,\n  RD_KAFKA_RESP_ERR_INVALID_GROUP_ID = 24,\n  RD_KAFKA_RESP_ERR_UNKNOWN_MEMBER_ID = 25,\n  RD_KAFKA_RESP_ERR_INVALID_SESSION_TIMEOUT = 26,\n  RD_KAFKA_RESP_ERR_REBALANCE_IN_PROGRESS = 27,\n  RD_KAFKA_RESP_ERR_INVALID_COMMIT_OFFSET_SIZE = 28,\n  RD_KAFKA_RESP_ERR_TOPIC_AUTHORIZATION_FAILED = 29,\n  RD_KAFKA_RESP_ERR_GROUP_AUTHORIZATION_FAILED = 30,\n  RD_KAFKA_RESP_ERR_CLUSTER_AUTHORIZATION_FAILED = 31,\n  RD_KAFKA_RESP_ERR_INVALID_TIMESTAMP = 32,\n  RD_KAFKA_RESP_ERR_UNSUPPORTED_SASL_MECHANISM = 33,\n  RD_KAFKA_RESP_ERR_ILLEGAL_SASL_STATE = 34,\n  RD_KAFKA_RESP_ERR_UNSUPPORTED_VERSION = 35,\n  RD_KAFKA_RESP_ERR_TOPIC_ALREADY_EXISTS = 36,\n  RD_KAFKA_RESP_ERR_INVALID_PARTITIONS = 37,\n  RD_KAFKA_RESP_ERR_INVALID_REPLICATION_FACTOR = 38,\n  RD_KAFKA_RESP_ERR_INVALID_REPLICA_ASSIGNMENT = 39,\n  RD_KAFKA_RESP_ERR_INVALID_CONFIG = 40,\n  RD_KAFKA_RESP_ERR_NOT_CONTROLLER = 41,\n  RD_KAFKA_RESP_ERR_INVALID_REQUEST = 42,\n  RD_KAFKA_RESP_ERR_UNSUPPORTED_FOR_MESSAGE_FORMAT = 43,\n  RD_KAFKA_RESP_ERR_POLICY_VIOLATION = 44,\n  RD_KAFKA_RESP_ERR_OUT_OF_ORDER_SEQUENCE_NUMBER = 45,\n  RD_KAFKA_RESP_ERR_DUPLICATE_SEQUENCE_NUMBER = 46,\n  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_EPOCH = 47,\n  RD_KAFKA_RESP_ERR_INVALID_TXN_STATE = 48,\n  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_ID_MAPPING = 49,\n  RD_KAFKA_RESP_ERR_INVALID_TRANSACTION_TIMEOUT = 50,\n  RD_KAFKA_RESP_ERR_CONCURRENT_TRANSACTIONS = 51,\n  RD_KAFKA_RESP_ERR_TRANSACTION_COORDINATOR_FENCED = 52,\n  RD_KAFKA_RESP_ERR_TRANSACTIONAL_ID_AUTHORIZATION_FAILED = 53,\n  RD_KAFKA_RESP_ERR_SECURITY_DISABLED = 54,\n  RD_KAFKA_RESP_ERR_OPERATION_NOT_ATTEMPTED = 55,\n  RD_KAFKA_RESP_ERR_KAFKA_STORAGE_ERROR = 56,\n  RD_KAFKA_RESP_ERR_LOG_DIR_NOT_FOUND = 57,\n  RD_KAFKA_RESP_ERR_SASL_AUTHENTICATION_FAILED = 58,\n  RD_KAFKA_RESP_ERR_UNKNOWN_PRODUCER_ID = 59,\n  RD_KAFKA_RESP_ERR_REASSIGNMENT_IN_PROGRESS = 60,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTH_DISABLED = 61,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_NOT_FOUND = 62,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_OWNER_MISMATCH = 63,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_REQUEST_NOT_ALLOWED = 64,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTHORIZATION_FAILED = 65,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_EXPIRED = 66,\n  RD_KAFKA_RESP_ERR_INVALID_PRINCIPAL_TYPE = 67,\n  RD_KAFKA_RESP_ERR_NON_EMPTY_GROUP = 68,\n  RD_KAFKA_RESP_ERR_GROUP_ID_NOT_FOUND = 69,\n  RD_KAFKA_RESP_ERR_FETCH_SESSION_ID_NOT_FOUND = 70,\n  RD_KAFKA_RESP_ERR_INVALID_FETCH_SESSION_EPOCH = 71,\n  RD_KAFKA_RESP_ERR_LISTENER_NOT_FOUND = 72,\n  RD_KAFKA_RESP_ERR_TOPIC_DELETION_DISABLED = 73,\n  RD_KAFKA_RESP_ERR_FENCED_LEADER_EPOCH = 74,\n  RD_KAFKA_RESP_ERR_UNKNOWN_LEADER_EPOCH = 75,\n  RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76,\n  RD_KAFKA_RESP_ERR_STALE_BROKER_EPOCH = 77,\n  RD_KAFKA_RESP_ERR_OFFSET_NOT_AVAILABLE = 78,\n  RD_KAFKA_RESP_ERR_MEMBER_ID_REQUIRED = 79,\n  RD_KAFKA_RESP_ERR_PREFERRED_LEADER_NOT_AVAILABLE = 80,\n  RD_KAFKA_RESP_ERR_GROUP_MAX_SIZE_REACHED = 81,\n  RD_KAFKA_RESP_ERR_FENCED_INSTANCE_ID = 82,\n  RD_KAFKA_RESP_ERR_END_ALL,\n} rd_kafka_resp_err_t;\nstruct rd_kafka_err_desc {\n  rd_kafka_resp_err_t code;\n  char *name;\n  char *desc;\n};\nvoid rd_kafka_get_err_descs(const struct rd_kafka_err_desc **errdescs, size_t *cntp);\nconst char *rd_kafka_err2str(rd_kafka_resp_err_t err);\nconst char *rd_kafka_err2name(rd_kafka_resp_err_t err);\nrd_kafka_resp_err_t rd_kafka_last_error(void);\nrd_kafka_resp_err_t rd_kafka_errno2err(int errnox);\nint rd_kafka_errno(void);\nrd_kafka_resp_err_t rd_kafka_fatal_error(rd_kafka_t *rk, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_test_fatal_error(rd_kafka_t *rk, rd_kafka_resp_err_t err, const char *reason);\nrd_kafka_resp_err_t rd_kafka_error_code(const rd_kafka_error_t *error);\nconst char *rd_kafka_error_name(const rd_kafka_error_t *error);\nconst char *rd_kafka_error_string(const rd_kafka_error_t *error);\nint rd_kafka_error_is_fatal(const rd_kafka_error_t *error);\nint rd_kafka_error_is_retriable(const rd_kafka_error_t *error);\nint rd_kafka_error_txn_requires_abort(const rd_kafka_error_t *error);\nvoid rd_kafka_error_destroy(rd_kafka_error_t *error);\nrd_kafka_error_t *rd_kafka_error_new(rd_kafka_resp_err_t code, const char *fmt, ...);\ntypedef struct rd_kafka_topic_partition_s {\n  char *topic;\n  int32_t partition;\n  int64_t offset;\n  void *metadata;\n  size_t metadata_size;\n  void *opaque;\n  rd_kafka_resp_err_t err;\n  void *_private;\n} rd_kafka_topic_partition_t;\nvoid rd_kafka_topic_partition_destroy(rd_kafka_topic_partition_t *rktpar);\ntypedef struct rd_kafka_topic_partition_list_s {\n  int cnt;\n  int size;\n  rd_kafka_topic_partition_t *elems;\n} rd_kafka_topic_partition_list_t;\nrd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_new(int size);\nvoid rd_kafka_topic_partition_list_destroy(rd_kafka_topic_partition_list_t *rkparlist);\nrd_kafka_topic_partition_t *rd_kafka_topic_partition_list_add(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);\nvoid rd_kafka_topic_partition_list_add_range(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t start, int32_t stop);\nint rd_kafka_topic_partition_list_del(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);\nint rd_kafka_topic_partition_list_del_by_idx(rd_kafka_topic_partition_list_t *rktparlist, int idx);\nrd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_copy(const rd_kafka_topic_partition_list_t *src);\nrd_kafka_resp_err_t rd_kafka_topic_partition_list_set_offset(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition, int64_t offset);\nrd_kafka_topic_partition_t *rd_kafka_topic_partition_list_find(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);\nvoid rd_kafka_topic_partition_list_sort(rd_kafka_topic_partition_list_t *rktparlist, int (*cmp)(const void *a, const void *b, void *cmp_opaque), void *cmp_opaque);\ntypedef enum rd_kafka_vtype_t {\n  RD_KAFKA_VTYPE_END,\n  RD_KAFKA_VTYPE_TOPIC,\n  RD_KAFKA_VTYPE_RKT,\n  RD_KAFKA_VTYPE_PARTITION,\n  RD_KAFKA_VTYPE_VALUE,\n  RD_KAFKA_VTYPE_KEY,\n  RD_KAFKA_VTYPE_OPAQUE,\n  RD_KAFKA_VTYPE_MSGFLAGS,\n  RD_KAFKA_VTYPE_TIMESTAMP,\n  RD_KAFKA_VTYPE_HEADER,\n  RD_KAFKA_VTYPE_HEADERS,\n} rd_kafka_vtype_t;\ntypedef struct rd_kafka_headers_s rd_kafka_headers_t;\nrd_kafka_headers_t *rd_kafka_headers_new(size_t initial_count);\nvoid rd_kafka_headers_destroy(rd_kafka_headers_t *hdrs);\nrd_kafka_headers_t *rd_kafka_headers_copy(const rd_kafka_headers_t *src);\nrd_kafka_resp_err_t rd_kafka_header_add(rd_kafka_headers_t *hdrs, const char *name, ssize_t name_size, const void *value, ssize_t value_size);\nrd_kafka_resp_err_t rd_kafka_header_remove(rd_kafka_headers_t *hdrs, const char *name);\nrd_kafka_resp_err_t rd_kafka_header_get_last(const rd_kafka_headers_t *hdrs, const char *name, const void **valuep, size_t *sizep);\nrd_kafka_resp_err_t rd_kafka_header_get(const rd_kafka_headers_t *hdrs, size_t idx, const char *name, const void **valuep, size_t *sizep);\nrd_kafka_resp_err_t rd_kafka_header_get_all(const rd_kafka_headers_t *hdrs, size_t idx, const char **namep, const void **valuep, size_t *sizep);\ntypedef struct rd_kafka_message_s {\n  rd_kafka_resp_err_t err;\n  rd_kafka_topic_t *rkt;\n  int32_t partition;\n  void *payload;\n  size_t len;\n  void *key;\n  size_t key_len;\n  int64_t offset;\n  void *_private;\n} rd_kafka_message_t;\nvoid rd_kafka_message_destroy(rd_kafka_message_t *rkmessage);\nint64_t rd_kafka_message_timestamp(const rd_kafka_message_t *rkmessage, rd_kafka_timestamp_type_t *tstype);\nint64_t rd_kafka_message_latency(const rd_kafka_message_t *rkmessage);\nrd_kafka_resp_err_t rd_kafka_message_headers(const rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);\nrd_kafka_resp_err_t rd_kafka_message_detach_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);\nvoid rd_kafka_message_set_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t *hdrs);\nsize_t rd_kafka_header_cnt(const rd_kafka_headers_t *hdrs);\ntypedef enum {\n  RD_KAFKA_MSG_STATUS_NOT_PERSISTED = 0,\n  RD_KAFKA_MSG_STATUS_POSSIBLY_PERSISTED = 1,\n  RD_KAFKA_MSG_STATUS_PERSISTED = 2,\n} rd_kafka_msg_status_t;\nrd_kafka_msg_status_t rd_kafka_message_status(const rd_kafka_message_t *rkmessage);\ntypedef enum {\n  RD_KAFKA_CONF_UNKNOWN = (- 2),\n  RD_KAFKA_CONF_INVALID = (- 1),\n  RD_KAFKA_CONF_OK = 0,\n} rd_kafka_conf_res_t;\nrd_kafka_conf_t *rd_kafka_conf_new(void);\nvoid rd_kafka_conf_destroy(rd_kafka_conf_t *conf);\nrd_kafka_conf_t *rd_kafka_conf_dup(const rd_kafka_conf_t *conf);\nrd_kafka_conf_t *rd_kafka_conf_dup_filter(const rd_kafka_conf_t *conf, size_t filter_cnt, const char **filter);\nconst rd_kafka_conf_t *rd_kafka_conf(rd_kafka_t *rk);\nrd_kafka_conf_res_t rd_kafka_conf_set(rd_kafka_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);\nvoid rd_kafka_conf_set_events(rd_kafka_conf_t *conf, int events);\nvoid rd_kafka_conf_set_background_event_cb(rd_kafka_conf_t *conf, void (*event_cb)(rd_kafka_t *rk, rd_kafka_event_t *rkev, void *opaque));\nvoid rd_kafka_conf_set_dr_cb(rd_kafka_conf_t *conf, void (*dr_cb)(rd_kafka_t *rk, void *payload, size_t len, rd_kafka_resp_err_t err, void *opaque, void *msg_opaque));\nvoid rd_kafka_conf_set_dr_msg_cb(rd_kafka_conf_t *conf, void (*dr_msg_cb)(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, void *opaque));\nvoid rd_kafka_conf_set_consume_cb(rd_kafka_conf_t *conf, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *opaque));\nvoid rd_kafka_conf_set_rebalance_cb(rd_kafka_conf_t *conf, void (*rebalance_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *partitions, void *opaque));\nvoid rd_kafka_conf_set_offset_commit_cb(rd_kafka_conf_t *conf, void (*offset_commit_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *opaque));\nvoid rd_kafka_conf_set_error_cb(rd_kafka_conf_t *conf, void (*error_cb)(rd_kafka_t *rk, int err, const char *reason, void *opaque));\nvoid rd_kafka_conf_set_throttle_cb(rd_kafka_conf_t *conf, void (*throttle_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int throttle_time_ms, void *opaque));\nvoid rd_kafka_conf_set_log_cb(rd_kafka_conf_t *conf, void (*log_cb)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));\nvoid rd_kafka_conf_set_stats_cb(rd_kafka_conf_t *conf, int (*stats_cb)(rd_kafka_t *rk, char *json, size_t json_len, void *opaque));\nvoid rd_kafka_conf_set_oauthbearer_token_refresh_cb(rd_kafka_conf_t *conf, void (*oauthbearer_token_refresh_cb)(rd_kafka_t *rk, const char *oauthbearer_config, void *opaque));\nvoid rd_kafka_conf_set_socket_cb(rd_kafka_conf_t *conf, int (*socket_cb)(int domain, int type, int protocol, void *opaque));\nvoid rd_kafka_conf_set_connect_cb(rd_kafka_conf_t *conf, int (*connect_cb)(int sockfd, const struct sockaddr *addr, int addrlen, const char *id, void *opaque));\nvoid rd_kafka_conf_set_closesocket_cb(rd_kafka_conf_t *conf, int (*closesocket_cb)(int sockfd, void *opaque));\nrd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert_verify_cb(rd_kafka_conf_t *conf, int (*ssl_cert_verify_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int *x509_error, int depth, const char *buf, size_t size, char *errstr, size_t errstr_size, void *opaque));\ntypedef enum rd_kafka_cert_type_t {\n  RD_KAFKA_CERT_PUBLIC_KEY,\n  RD_KAFKA_CERT_PRIVATE_KEY,\n  RD_KAFKA_CERT_CA,\n  RD_KAFKA_CERT__CNT,\n} rd_kafka_cert_type_t;\ntypedef enum rd_kafka_cert_enc_t {\n  RD_KAFKA_CERT_ENC_PKCS12,\n  RD_KAFKA_CERT_ENC_DER,\n  RD_KAFKA_CERT_ENC_PEM,\n  RD_KAFKA_CERT_ENC__CNT,\n} rd_kafka_cert_enc_t;\nrd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert(rd_kafka_conf_t *conf, rd_kafka_cert_type_t cert_type, rd_kafka_cert_enc_t cert_enc, const void *buffer, size_t size, char *errstr, size_t errstr_size);\nvoid rd_kafka_conf_set_opaque(rd_kafka_conf_t *conf, void *opaque);\nvoid *rd_kafka_opaque(const rd_kafka_t *rk);\nvoid rd_kafka_conf_set_default_topic_conf(rd_kafka_conf_t *conf, rd_kafka_topic_conf_t *tconf);\nrd_kafka_conf_res_t rd_kafka_conf_get(const rd_kafka_conf_t *conf, const char *name, char *dest, size_t *dest_size);\nrd_kafka_conf_res_t rd_kafka_topic_conf_get(const rd_kafka_topic_conf_t *conf, const char *name, char *dest, size_t *dest_size);\nconst char **rd_kafka_conf_dump(rd_kafka_conf_t *conf, size_t *cntp);\nconst char **rd_kafka_topic_conf_dump(rd_kafka_topic_conf_t *conf, size_t *cntp);\nvoid rd_kafka_conf_dump_free(const char **arr, size_t cnt);\nvoid rd_kafka_conf_properties_show(FILE *fp);\nrd_kafka_topic_conf_t *rd_kafka_topic_conf_new(void);\nrd_kafka_topic_conf_t *rd_kafka_topic_conf_dup(const rd_kafka_topic_conf_t *conf);\nrd_kafka_topic_conf_t *rd_kafka_default_topic_conf_dup(rd_kafka_t *rk);\nvoid rd_kafka_topic_conf_destroy(rd_kafka_topic_conf_t *topic_conf);\nrd_kafka_conf_res_t rd_kafka_topic_conf_set(rd_kafka_topic_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);\nvoid rd_kafka_topic_conf_set_opaque(rd_kafka_topic_conf_t *conf, void *rkt_opaque);\nvoid rd_kafka_topic_conf_set_partitioner_cb(rd_kafka_topic_conf_t *topic_conf, int32_t (*partitioner)(const rd_kafka_topic_t *rkt, const void *keydata, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque));\nvoid rd_kafka_topic_conf_set_msg_order_cmp(rd_kafka_topic_conf_t *topic_conf, int (*msg_order_cmp)(const rd_kafka_message_t *a, const rd_kafka_message_t *b));\nint rd_kafka_topic_partition_available(const rd_kafka_topic_t *rkt, int32_t partition);\nint32_t rd_kafka_msg_partitioner_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_consistent(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_consistent_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_murmur2(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_murmur2_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_fnv1a(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_fnv1a_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nrd_kafka_t *rd_kafka_new(rd_kafka_type_t type, rd_kafka_conf_t *conf, char *errstr, size_t errstr_size);\nvoid rd_kafka_destroy(rd_kafka_t *rk);\nvoid rd_kafka_destroy_flags(rd_kafka_t *rk, int flags);\nconst char *rd_kafka_name(const rd_kafka_t *rk);\nrd_kafka_type_t rd_kafka_type(const rd_kafka_t *rk);\nchar *rd_kafka_memberid(const rd_kafka_t *rk);\nchar *rd_kafka_clusterid(rd_kafka_t *rk, int timeout_ms);\nint32_t rd_kafka_controllerid(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_topic_t *rd_kafka_topic_new(rd_kafka_t *rk, const char *topic, rd_kafka_topic_conf_t *conf);\nvoid rd_kafka_topic_destroy(rd_kafka_topic_t *rkt);\nconst char *rd_kafka_topic_name(const rd_kafka_topic_t *rkt);\nvoid *rd_kafka_topic_opaque(const rd_kafka_topic_t *rkt);\nint rd_kafka_poll(rd_kafka_t *rk, int timeout_ms);\nvoid rd_kafka_yield(rd_kafka_t *rk);\nrd_kafka_resp_err_t rd_kafka_pause_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_resp_err_t rd_kafka_resume_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_resp_err_t rd_kafka_query_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high, int timeout_ms);\nrd_kafka_resp_err_t rd_kafka_get_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high);\nrd_kafka_resp_err_t rd_kafka_offsets_for_times(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets, int timeout_ms);\nvoid rd_kafka_mem_free(rd_kafka_t *rk, void *ptr);\nrd_kafka_queue_t *rd_kafka_queue_new(rd_kafka_t *rk);\nvoid rd_kafka_queue_destroy(rd_kafka_queue_t *rkqu);\nrd_kafka_queue_t *rd_kafka_queue_get_main(rd_kafka_t *rk);\nrd_kafka_queue_t *rd_kafka_queue_get_consumer(rd_kafka_t *rk);\nrd_kafka_queue_t *rd_kafka_queue_get_partition(rd_kafka_t *rk, const char *topic, int32_t partition);\nrd_kafka_queue_t *rd_kafka_queue_get_background(rd_kafka_t *rk);\nvoid rd_kafka_queue_forward(rd_kafka_queue_t *src, rd_kafka_queue_t *dst);\nrd_kafka_resp_err_t rd_kafka_set_log_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu);\nsize_t rd_kafka_queue_length(rd_kafka_queue_t *rkqu);\nvoid rd_kafka_queue_io_event_enable(rd_kafka_queue_t *rkqu, int fd, const void *payload, size_t size);\nvoid rd_kafka_queue_cb_event_enable(rd_kafka_queue_t *rkqu, void (*event_cb)(rd_kafka_t *rk, void *qev_opaque), void *qev_opaque);\nint rd_kafka_consume_start(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);\nint rd_kafka_consume_start_queue(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, rd_kafka_queue_t *rkqu);\nint rd_kafka_consume_stop(rd_kafka_topic_t *rkt, int32_t partition);\nrd_kafka_resp_err_t rd_kafka_seek(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, int timeout_ms);\nrd_kafka_message_t *rd_kafka_consume(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms);\nssize_t rd_kafka_consume_batch(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);\nint rd_kafka_consume_callback(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);\nrd_kafka_message_t *rd_kafka_consume_queue(rd_kafka_queue_t *rkqu, int timeout_ms);\nssize_t rd_kafka_consume_batch_queue(rd_kafka_queue_t *rkqu, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);\nint rd_kafka_consume_callback_queue(rd_kafka_queue_t *rkqu, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);\nrd_kafka_resp_err_t rd_kafka_offset_store(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);\nrd_kafka_resp_err_t rd_kafka_offsets_store(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets);\nrd_kafka_resp_err_t rd_kafka_subscribe(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *topics);\nrd_kafka_resp_err_t rd_kafka_unsubscribe(rd_kafka_t *rk);\nrd_kafka_resp_err_t rd_kafka_subscription(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **topics);\nrd_kafka_message_t *rd_kafka_consumer_poll(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_resp_err_t rd_kafka_consumer_close(rd_kafka_t *rk);\nrd_kafka_resp_err_t rd_kafka_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_resp_err_t rd_kafka_assignment(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **partitions);\nrd_kafka_resp_err_t rd_kafka_commit(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, int async);\nrd_kafka_resp_err_t rd_kafka_commit_message(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, int async);\nrd_kafka_resp_err_t rd_kafka_commit_queue(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_queue_t *rkqu, void (*cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *commit_opaque), void *commit_opaque);\nrd_kafka_resp_err_t rd_kafka_committed(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms);\nrd_kafka_resp_err_t rd_kafka_position(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata(rd_kafka_t *rk);\nrd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata_new(const char *group_id);\nvoid rd_kafka_consumer_group_metadata_destroy(rd_kafka_consumer_group_metadata_t *);\nrd_kafka_error_t *rd_kafka_consumer_group_metadata_write(const rd_kafka_consumer_group_metadata_t *cgmd, void **bufferp, size_t *sizep);\nrd_kafka_error_t *rd_kafka_consumer_group_metadata_read(rd_kafka_consumer_group_metadata_t **cgmdp, const void *buffer, size_t size);\nint rd_kafka_produce(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, void *payload, size_t len, const void *key, size_t keylen, void *msg_opaque);\nrd_kafka_resp_err_t rd_kafka_producev(rd_kafka_t *rk, ...);\nint rd_kafka_produce_batch(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, rd_kafka_message_t *rkmessages, int message_cnt);\nrd_kafka_resp_err_t rd_kafka_flush(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_resp_err_t rd_kafka_purge(rd_kafka_t *rk, int purge_flags);\ntypedef struct rd_kafka_metadata_broker {\n  int32_t id;\n  char *host;\n  int port;\n} rd_kafka_metadata_broker_t;\ntypedef struct rd_kafka_metadata_partition {\n  int32_t id;\n  rd_kafka_resp_err_t err;\n  int32_t leader;\n  int replica_cnt;\n  int32_t *replicas;\n  int isr_cnt;\n  int32_t *isrs;\n} rd_kafka_metadata_partition_t;\ntypedef struct rd_kafka_metadata_topic {\n  char *topic;\n  int partition_cnt;\n  struct rd_kafka_metadata_partition *partitions;\n  rd_kafka_resp_err_t err;\n} rd_kafka_metadata_topic_t;\ntypedef struct rd_kafka_metadata {\n  int broker_cnt;\n  struct rd_kafka_metadata_broker *brokers;\n  int topic_cnt;\n  struct rd_kafka_metadata_topic *topics;\n  int32_t orig_broker_id;\n  char *orig_broker_name;\n} rd_kafka_metadata_t;\nrd_kafka_resp_err_t rd_kafka_metadata(rd_kafka_t *rk, int all_topics, rd_kafka_topic_t *only_rkt, const struct rd_kafka_metadata **metadatap, int timeout_ms);\nvoid rd_kafka_metadata_destroy(const struct rd_kafka_metadata *metadata);\nstruct rd_kafka_group_member_info {\n  char *member_id;\n  char *client_id;\n  char *client_host;\n  void *member_metadata;\n  int member_metadata_size;\n  void *member_assignment;\n  int member_assignment_size;\n};\nstruct rd_kafka_group_info {\n  struct rd_kafka_metadata_broker broker;\n  char *group;\n  rd_kafka_resp_err_t err;\n  char *state;\n  char *protocol_type;\n  char *protocol;\n  struct rd_kafka_group_member_info *members;\n  int member_cnt;\n};\nstruct rd_kafka_group_list {\n  struct rd_kafka_group_info *groups;\n  int group_cnt;\n};\nrd_kafka_resp_err_t rd_kafka_list_groups(rd_kafka_t *rk, const char *group, const struct rd_kafka_group_list **grplistp, int timeout_ms);\nvoid rd_kafka_group_list_destroy(const struct rd_kafka_group_list *grplist);\nint rd_kafka_brokers_add(rd_kafka_t *rk, const char *brokerlist);\nvoid rd_kafka_set_logger(rd_kafka_t *rk, void (*func)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));\nvoid rd_kafka_set_log_level(rd_kafka_t *rk, int level);\nvoid rd_kafka_log_print(const rd_kafka_t *rk, int level, const char *fac, const char *buf);\nvoid rd_kafka_log_syslog(const rd_kafka_t *rk, int level, const char *fac, const char *buf);\nint rd_kafka_outq_len(rd_kafka_t *rk);\nvoid rd_kafka_dump(FILE *fp, rd_kafka_t *rk);\nint rd_kafka_thread_cnt(void);\ntypedef enum rd_kafka_thread_type_t {\n  RD_KAFKA_THREAD_MAIN,\n  RD_KAFKA_THREAD_BACKGROUND,\n  RD_KAFKA_THREAD_BROKER,\n} rd_kafka_thread_type_t;\nint rd_kafka_wait_destroyed(int timeout_ms);\nint rd_kafka_unittest(void);\nrd_kafka_resp_err_t rd_kafka_poll_set_consumer(rd_kafka_t *rk);\ntypedef int rd_kafka_event_type_t;\nrd_kafka_event_type_t rd_kafka_event_type(const rd_kafka_event_t *rkev);\nconst char *rd_kafka_event_name(const rd_kafka_event_t *rkev);\nvoid rd_kafka_event_destroy(rd_kafka_event_t *rkev);\nconst rd_kafka_message_t *rd_kafka_event_message_next(rd_kafka_event_t *rkev);\nsize_t rd_kafka_event_message_array(rd_kafka_event_t *rkev, const rd_kafka_message_t **rkmessages, size_t size);\nsize_t rd_kafka_event_message_count(rd_kafka_event_t *rkev);\nconst char *rd_kafka_event_config_string(rd_kafka_event_t *rkev);\nrd_kafka_resp_err_t rd_kafka_event_error(rd_kafka_event_t *rkev);\nconst char *rd_kafka_event_error_string(rd_kafka_event_t *rkev);\nint rd_kafka_event_error_is_fatal(rd_kafka_event_t *rkev);\nvoid *rd_kafka_event_opaque(rd_kafka_event_t *rkev);\nint rd_kafka_event_log(rd_kafka_event_t *rkev, const char **fac, const char **str, int *level);\nconst char *rd_kafka_event_stats(rd_kafka_event_t *rkev);\nrd_kafka_topic_partition_list_t *rd_kafka_event_topic_partition_list(rd_kafka_event_t *rkev);\nrd_kafka_topic_partition_t *rd_kafka_event_topic_partition(rd_kafka_event_t *rkev);\ntypedef rd_kafka_event_t rd_kafka_CreateTopics_result_t;\ntypedef rd_kafka_event_t rd_kafka_DeleteTopics_result_t;\ntypedef rd_kafka_event_t rd_kafka_CreatePartitions_result_t;\ntypedef rd_kafka_event_t rd_kafka_AlterConfigs_result_t;\ntypedef rd_kafka_event_t rd_kafka_DescribeConfigs_result_t;\nconst rd_kafka_CreateTopics_result_t *rd_kafka_event_CreateTopics_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DeleteTopics_result_t *rd_kafka_event_DeleteTopics_result(rd_kafka_event_t *rkev);\nconst rd_kafka_CreatePartitions_result_t *rd_kafka_event_CreatePartitions_result(rd_kafka_event_t *rkev);\nconst rd_kafka_AlterConfigs_result_t *rd_kafka_event_AlterConfigs_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DescribeConfigs_result_t *rd_kafka_event_DescribeConfigs_result(rd_kafka_event_t *rkev);\nrd_kafka_event_t *rd_kafka_queue_poll(rd_kafka_queue_t *rkqu, int timeout_ms);\nint rd_kafka_queue_poll_callback(rd_kafka_queue_t *rkqu, int timeout_ms);\ntypedef rd_kafka_resp_err_t (rd_kafka_plugin_f_conf_init_t)(rd_kafka_conf_t *conf, void **plug_opaquep, char *errstr, size_t errstr_size);\ntypedef rd_kafka_conf_res_t (rd_kafka_interceptor_f_on_conf_set_t)(rd_kafka_conf_t *conf, const char *name, const char *val, char *errstr, size_t errstr_size, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_dup_t)(rd_kafka_conf_t *new_conf, const rd_kafka_conf_t *old_conf, size_t filter_cnt, const char **filter, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_destroy_t)(void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_new_t)(rd_kafka_t *rk, const rd_kafka_conf_t *conf, void *ic_opaque, char *errstr, size_t errstr_size);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_destroy_t)(rd_kafka_t *rk, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_send_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_acknowledgement_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_consume_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_commit_t)(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_resp_err_t err, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_request_sent_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_start_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_exit_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_set(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_set_t *on_conf_set, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_dup(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_dup_t *on_conf_dup, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_destroy(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_destroy_t *on_conf_destroy, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_new(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_new_t *on_new, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_destroy(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_destroy_t *on_destroy, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_send(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_send_t *on_send, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_acknowledgement(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_acknowledgement_t *on_acknowledgement, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_consume(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_consume_t *on_consume, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_commit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_commit_t *on_commit, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_request_sent(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_request_sent_t *on_request_sent, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_start(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_start_t *on_thread_start, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_exit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_exit_t *on_thread_exit, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_topic_result_error(const rd_kafka_topic_result_t *topicres);\nconst char *rd_kafka_topic_result_error_string(const rd_kafka_topic_result_t *topicres);\nconst char *rd_kafka_topic_result_name(const rd_kafka_topic_result_t *topicres);\ntypedef enum rd_kafka_admin_op_t {\n  RD_KAFKA_ADMIN_OP_ANY = 0,\n  RD_KAFKA_ADMIN_OP_CREATETOPICS,\n  RD_KAFKA_ADMIN_OP_DELETETOPICS,\n  RD_KAFKA_ADMIN_OP_CREATEPARTITIONS,\n  RD_KAFKA_ADMIN_OP_ALTERCONFIGS,\n  RD_KAFKA_ADMIN_OP_DESCRIBECONFIGS,\n  RD_KAFKA_ADMIN_OP__CNT,\n} rd_kafka_admin_op_t;\ntypedef struct rd_kafka_AdminOptions_s rd_kafka_AdminOptions_t;\nrd_kafka_AdminOptions_t *rd_kafka_AdminOptions_new(rd_kafka_t *rk, rd_kafka_admin_op_t for_api);\nvoid rd_kafka_AdminOptions_destroy(rd_kafka_AdminOptions_t *options);\nrd_kafka_resp_err_t rd_kafka_AdminOptions_set_request_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_AdminOptions_set_operation_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_AdminOptions_set_validate_only(rd_kafka_AdminOptions_t *options, int true_or_false, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_AdminOptions_set_broker(rd_kafka_AdminOptions_t *options, int32_t broker_id, char *errstr, size_t errstr_size);\nvoid rd_kafka_AdminOptions_set_opaque(rd_kafka_AdminOptions_t *options, void *ev_opaque);\ntypedef struct rd_kafka_NewTopic_s rd_kafka_NewTopic_t;\nrd_kafka_NewTopic_t *rd_kafka_NewTopic_new(const char *topic, int num_partitions, int replication_factor, char *errstr, size_t errstr_size);\nvoid rd_kafka_NewTopic_destroy(rd_kafka_NewTopic_t *new_topic);\nvoid rd_kafka_NewTopic_destroy_array(rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt);\nrd_kafka_resp_err_t rd_kafka_NewTopic_set_replica_assignment(rd_kafka_NewTopic_t *new_topic, int32_t partition, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_NewTopic_set_config(rd_kafka_NewTopic_t *new_topic, const char *name, const char *value);\nvoid rd_kafka_CreateTopics(rd_kafka_t *rk, rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_topic_result_t **rd_kafka_CreateTopics_result_topics(const rd_kafka_CreateTopics_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_DeleteTopic_s rd_kafka_DeleteTopic_t;\nrd_kafka_DeleteTopic_t *rd_kafka_DeleteTopic_new(const char *topic);\nvoid rd_kafka_DeleteTopic_destroy(rd_kafka_DeleteTopic_t *del_topic);\nvoid rd_kafka_DeleteTopic_destroy_array(rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt);\nvoid rd_kafka_DeleteTopics(rd_kafka_t *rk, rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_topic_result_t **rd_kafka_DeleteTopics_result_topics(const rd_kafka_DeleteTopics_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_NewPartitions_s rd_kafka_NewPartitions_t;\nrd_kafka_NewPartitions_t *rd_kafka_NewPartitions_new(const char *topic, size_t new_total_cnt, char *errstr, size_t errstr_size);\nvoid rd_kafka_NewPartitions_destroy(rd_kafka_NewPartitions_t *new_parts);\nvoid rd_kafka_NewPartitions_destroy_array(rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt);\nrd_kafka_resp_err_t rd_kafka_NewPartitions_set_replica_assignment(rd_kafka_NewPartitions_t *new_parts, int32_t new_partition_idx, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);\nvoid rd_kafka_CreatePartitions(rd_kafka_t *rk, rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_topic_result_t **rd_kafka_CreatePartitions_result_topics(const rd_kafka_CreatePartitions_result_t *result, size_t *cntp);\ntypedef enum rd_kafka_ConfigSource_t {\n  RD_KAFKA_CONFIG_SOURCE_UNKNOWN_CONFIG = 0,\n  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_TOPIC_CONFIG = 1,\n  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_BROKER_CONFIG = 2,\n  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_DEFAULT_BROKER_CONFIG = 3,\n  RD_KAFKA_CONFIG_SOURCE_STATIC_BROKER_CONFIG = 4,\n  RD_KAFKA_CONFIG_SOURCE_DEFAULT_CONFIG = 5,\n  RD_KAFKA_CONFIG_SOURCE__CNT,\n} rd_kafka_ConfigSource_t;\nconst char *rd_kafka_ConfigSource_name(rd_kafka_ConfigSource_t confsource);\ntypedef struct rd_kafka_ConfigEntry_s rd_kafka_ConfigEntry_t;\nconst char *rd_kafka_ConfigEntry_name(const rd_kafka_ConfigEntry_t *entry);\nconst char *rd_kafka_ConfigEntry_value(const rd_kafka_ConfigEntry_t *entry);\nrd_kafka_ConfigSource_t rd_kafka_ConfigEntry_source(const rd_kafka_ConfigEntry_t *entry);\nint rd_kafka_ConfigEntry_is_read_only(const rd_kafka_ConfigEntry_t *entry);\nint rd_kafka_ConfigEntry_is_default(const rd_kafka_ConfigEntry_t *entry);\nint rd_kafka_ConfigEntry_is_sensitive(const rd_kafka_ConfigEntry_t *entry);\nint rd_kafka_ConfigEntry_is_synonym(const rd_kafka_ConfigEntry_t *entry);\nconst rd_kafka_ConfigEntry_t **rd_kafka_ConfigEntry_synonyms(const rd_kafka_ConfigEntry_t *entry, size_t *cntp);\ntypedef enum rd_kafka_ResourceType_t {\n  RD_KAFKA_RESOURCE_UNKNOWN = 0,\n  RD_KAFKA_RESOURCE_ANY = 1,\n  RD_KAFKA_RESOURCE_TOPIC = 2,\n  RD_KAFKA_RESOURCE_GROUP = 3,\n  RD_KAFKA_RESOURCE_BROKER = 4,\n  RD_KAFKA_RESOURCE__CNT,\n} rd_kafka_ResourceType_t;\nconst char *rd_kafka_ResourceType_name(rd_kafka_ResourceType_t restype);\ntypedef struct rd_kafka_ConfigResource_s rd_kafka_ConfigResource_t;\nrd_kafka_ConfigResource_t *rd_kafka_ConfigResource_new(rd_kafka_ResourceType_t restype, const char *resname);\nvoid rd_kafka_ConfigResource_destroy(rd_kafka_ConfigResource_t *config);\nvoid rd_kafka_ConfigResource_destroy_array(rd_kafka_ConfigResource_t **config, size_t config_cnt);\nrd_kafka_resp_err_t rd_kafka_ConfigResource_set_config(rd_kafka_ConfigResource_t *config, const char *name, const char *value);\nconst rd_kafka_ConfigEntry_t **rd_kafka_ConfigResource_configs(const rd_kafka_ConfigResource_t *config, size_t *cntp);\nrd_kafka_ResourceType_t rd_kafka_ConfigResource_type(const rd_kafka_ConfigResource_t *config);\nconst char *rd_kafka_ConfigResource_name(const rd_kafka_ConfigResource_t *config);\nrd_kafka_resp_err_t rd_kafka_ConfigResource_error(const rd_kafka_ConfigResource_t *config);\nconst char *rd_kafka_ConfigResource_error_string(const rd_kafka_ConfigResource_t *config);\nvoid rd_kafka_AlterConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_ConfigResource_t **rd_kafka_AlterConfigs_result_resources(const rd_kafka_AlterConfigs_result_t *result, size_t *cntp);\nvoid rd_kafka_DescribeConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_ConfigResource_t **rd_kafka_DescribeConfigs_result_resources(const rd_kafka_DescribeConfigs_result_t *result, size_t *cntp);\nrd_kafka_resp_err_t rd_kafka_oauthbearer_set_token(rd_kafka_t *rk, const char *token_value, int64_t md_lifetime_ms, const char *md_principal_name, const char **extensions, size_t extension_size, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_oauthbearer_set_token_failure(rd_kafka_t *rk, const char *errstr);\nrd_kafka_error_t *rd_kafka_init_transactions(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_error_t *rd_kafka_begin_transaction(rd_kafka_t *rk);\nrd_kafka_error_t *rd_kafka_send_offsets_to_transaction(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, const rd_kafka_consumer_group_metadata_t *cgmetadata, int timeout_ms);\nrd_kafka_error_t *rd_kafka_commit_transaction(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_error_t *rd_kafka_abort_transaction(rd_kafka_t *rk, int timeout_ms);\ntypedef struct rd_kafka_mock_cluster_s rd_kafka_mock_cluster_t;\nrd_kafka_mock_cluster_t *rd_kafka_mock_cluster_new(rd_kafka_t *rk, int broker_cnt);\nvoid rd_kafka_mock_cluster_destroy(rd_kafka_mock_cluster_t *mcluster);\nrd_kafka_t *rd_kafka_mock_cluster_handle(const rd_kafka_mock_cluster_t *mcluster);\nrd_kafka_mock_cluster_t *rd_kafka_handle_mock_cluster(const rd_kafka_t *rk);\nconst char *rd_kafka_mock_cluster_bootstraps(const rd_kafka_mock_cluster_t *mcluster);\nvoid rd_kafka_mock_push_request_errors(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, size_t cnt, ...);\nvoid rd_kafka_mock_topic_set_error(rd_kafka_mock_cluster_t *mcluster, const char *topic, rd_kafka_resp_err_t err);\nrd_kafka_resp_err_t rd_kafka_mock_topic_create(rd_kafka_mock_cluster_t *mcluster, const char *topic, int partition_cnt, int replication_factor);\nrd_kafka_resp_err_t rd_kafka_mock_partition_set_leader(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id);\nrd_kafka_resp_err_t rd_kafka_mock_partition_set_follower(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id);\nrd_kafka_resp_err_t rd_kafka_mock_partition_set_follower_wmarks(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int64_t lo, int64_t hi);\nrd_kafka_resp_err_t rd_kafka_mock_broker_set_down(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id);\nrd_kafka_resp_err_t rd_kafka_mock_broker_set_up(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id);\nrd_kafka_resp_err_t rd_kafka_mock_broker_set_rack(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, const char *rack);\nrd_kafka_resp_err_t rd_kafka_mock_coordinator_set(rd_kafka_mock_cluster_t *mcluster, const char *key_type, const char *key, int32_t broker_id);\nrd_kafka_resp_err_t rd_kafka_mock_set_apiversion(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, int16_t MinVersion, int16_t MaxVersion);\n'\n</code></pre> rdkafka.h, rdkafka_mock.h</p>"},{"location":"api/constants/#rd_kafka_version_9","title":"RD_KAFKA_VERSION","text":"<pre><code>public RD_KAFKA_VERSION = 17040639\n</code></pre> <p>librdkafka version </p> <p>Interpreted as hex <code>MM.mm.rr.xx</code>:</p> <ul> <li>MM = Major</li> <li>mm = minor</li> <li>rr = revision</li> <li>xx = pre-release id (0xff is the final release)</li> </ul> <p>E.g.: <code>0x000801ff</code> = 0.8.1</p> RemarksThis value should only be used during compile time, for runtime checks of version use rd_kafka_version()  <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_unsupported_compression_type_9","title":"RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE","text":"<pre><code>public RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76\n</code></pre> <p>Unsupported compression type </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_end_all_9","title":"RD_KAFKA_RESP_ERR_END_ALL","text":"<p><pre><code>public RD_KAFKA_RESP_ERR_END_ALL = 83\n</code></pre> enum rd_kafka_resp_err_t</p>"},{"location":"api/constants/#rd_kafka_admin_op__cnt_9","title":"RD_KAFKA_ADMIN_OP__CNT","text":"<pre><code>public RD_KAFKA_ADMIN_OP__CNT = 6\n</code></pre> <p>Number of ops defined </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe </li> </ul>"},{"location":"api/constants/#rd_kafka_resource__cnt_9","title":"RD_KAFKA_RESOURCE__CNT","text":"<pre><code>public RD_KAFKA_RESOURCE__CNT = 5\n</code></pre> <p>Number of resource types defined </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#acca83a66d7783ff7683ed2691cc907c9 </li> </ul>"},{"location":"api/constants/#rd_kafka_cdef_9","title":"RD_KAFKA_CDEF","text":"<p><pre><code>public RD_KAFKA_CDEF = 'typedef long int ssize_t;\ntypedef struct _IO_FILE FILE;\ntypedef long int mode_t;\ntypedef signed int int16_t;\ntypedef unsigned int uint16_t;\ntypedef signed int int32_t;\ntypedef signed long int int64_t;\nint rd_kafka_version(void);\nconst char *rd_kafka_version_str(void);\ntypedef enum rd_kafka_type_t {\n  RD_KAFKA_PRODUCER,\n  RD_KAFKA_CONSUMER,\n} rd_kafka_type_t;\ntypedef enum rd_kafka_timestamp_type_t {\n  RD_KAFKA_TIMESTAMP_NOT_AVAILABLE,\n  RD_KAFKA_TIMESTAMP_CREATE_TIME,\n  RD_KAFKA_TIMESTAMP_LOG_APPEND_TIME,\n} rd_kafka_timestamp_type_t;\nconst char *rd_kafka_get_debug_contexts(void);\ntypedef struct rd_kafka_s rd_kafka_t;\ntypedef struct rd_kafka_topic_s rd_kafka_topic_t;\ntypedef struct rd_kafka_conf_s rd_kafka_conf_t;\ntypedef struct rd_kafka_topic_conf_s rd_kafka_topic_conf_t;\ntypedef struct rd_kafka_queue_s rd_kafka_queue_t;\ntypedef struct rd_kafka_op_s rd_kafka_event_t;\ntypedef struct rd_kafka_topic_result_s rd_kafka_topic_result_t;\ntypedef struct rd_kafka_consumer_group_metadata_s rd_kafka_consumer_group_metadata_t;\ntypedef struct rd_kafka_error_s {\n  unsigned int code;\n  char *errstr;\n  unsigned char fatal;\n  unsigned char retriable;\n  unsigned char txn_requires_abort;\n} rd_kafka_error_t;\ntypedef enum {\n  RD_KAFKA_RESP_ERR__BEGIN = (- 200),\n  RD_KAFKA_RESP_ERR__BAD_MSG = (- 199),\n  RD_KAFKA_RESP_ERR__BAD_COMPRESSION = (- 198),\n  RD_KAFKA_RESP_ERR__DESTROY = (- 197),\n  RD_KAFKA_RESP_ERR__FAIL = (- 196),\n  RD_KAFKA_RESP_ERR__TRANSPORT = (- 195),\n  RD_KAFKA_RESP_ERR__CRIT_SYS_RESOURCE = (- 194),\n  RD_KAFKA_RESP_ERR__RESOLVE = (- 193),\n  RD_KAFKA_RESP_ERR__MSG_TIMED_OUT = (- 192),\n  RD_KAFKA_RESP_ERR__PARTITION_EOF = (- 191),\n  RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION = (- 190),\n  RD_KAFKA_RESP_ERR__FS = (- 189),\n  RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC = (- 188),\n  RD_KAFKA_RESP_ERR__ALL_BROKERS_DOWN = (- 187),\n  RD_KAFKA_RESP_ERR__INVALID_ARG = (- 186),\n  RD_KAFKA_RESP_ERR__TIMED_OUT = (- 185),\n  RD_KAFKA_RESP_ERR__QUEUE_FULL = (- 184),\n  RD_KAFKA_RESP_ERR__ISR_INSUFF = (- 183),\n  RD_KAFKA_RESP_ERR__NODE_UPDATE = (- 182),\n  RD_KAFKA_RESP_ERR__SSL = (- 181),\n  RD_KAFKA_RESP_ERR__WAIT_COORD = (- 180),\n  RD_KAFKA_RESP_ERR__UNKNOWN_GROUP = (- 179),\n  RD_KAFKA_RESP_ERR__IN_PROGRESS = (- 178),\n  RD_KAFKA_RESP_ERR__PREV_IN_PROGRESS = (- 177),\n  RD_KAFKA_RESP_ERR__EXISTING_SUBSCRIPTION = (- 176),\n  RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS = (- 175),\n  RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS = (- 174),\n  RD_KAFKA_RESP_ERR__CONFLICT = (- 173),\n  RD_KAFKA_RESP_ERR__STATE = (- 172),\n  RD_KAFKA_RESP_ERR__UNKNOWN_PROTOCOL = (- 171),\n  RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED = (- 170),\n  RD_KAFKA_RESP_ERR__AUTHENTICATION = (- 169),\n  RD_KAFKA_RESP_ERR__NO_OFFSET = (- 168),\n  RD_KAFKA_RESP_ERR__OUTDATED = (- 167),\n  RD_KAFKA_RESP_ERR__TIMED_OUT_QUEUE = (- 166),\n  RD_KAFKA_RESP_ERR__UNSUPPORTED_FEATURE = (- 165),\n  RD_KAFKA_RESP_ERR__WAIT_CACHE = (- 164),\n  RD_KAFKA_RESP_ERR__INTR = (- 163),\n  RD_KAFKA_RESP_ERR__KEY_SERIALIZATION = (- 162),\n  RD_KAFKA_RESP_ERR__VALUE_SERIALIZATION = (- 161),\n  RD_KAFKA_RESP_ERR__KEY_DESERIALIZATION = (- 160),\n  RD_KAFKA_RESP_ERR__VALUE_DESERIALIZATION = (- 159),\n  RD_KAFKA_RESP_ERR__PARTIAL = (- 158),\n  RD_KAFKA_RESP_ERR__READ_ONLY = (- 157),\n  RD_KAFKA_RESP_ERR__NOENT = (- 156),\n  RD_KAFKA_RESP_ERR__UNDERFLOW = (- 155),\n  RD_KAFKA_RESP_ERR__INVALID_TYPE = (- 154),\n  RD_KAFKA_RESP_ERR__RETRY = (- 153),\n  RD_KAFKA_RESP_ERR__PURGE_QUEUE = (- 152),\n  RD_KAFKA_RESP_ERR__PURGE_INFLIGHT = (- 151),\n  RD_KAFKA_RESP_ERR__FATAL = (- 150),\n  RD_KAFKA_RESP_ERR__INCONSISTENT = (- 149),\n  RD_KAFKA_RESP_ERR__GAPLESS_GUARANTEE = (- 148),\n  RD_KAFKA_RESP_ERR__MAX_POLL_EXCEEDED = (- 147),\n  RD_KAFKA_RESP_ERR__UNKNOWN_BROKER = (- 146),\n  RD_KAFKA_RESP_ERR__NOT_CONFIGURED = (- 145),\n  RD_KAFKA_RESP_ERR__FENCED = (- 144),\n  RD_KAFKA_RESP_ERR__APPLICATION = (- 143),\n  RD_KAFKA_RESP_ERR__END = (- 100),\n  RD_KAFKA_RESP_ERR_UNKNOWN = (- 1),\n  RD_KAFKA_RESP_ERR_NO_ERROR = 0,\n  RD_KAFKA_RESP_ERR_OFFSET_OUT_OF_RANGE = 1,\n  RD_KAFKA_RESP_ERR_INVALID_MSG = 2,\n  RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART = 3,\n  RD_KAFKA_RESP_ERR_INVALID_MSG_SIZE = 4,\n  RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE = 5,\n  RD_KAFKA_RESP_ERR_NOT_LEADER_FOR_PARTITION = 6,\n  RD_KAFKA_RESP_ERR_REQUEST_TIMED_OUT = 7,\n  RD_KAFKA_RESP_ERR_BROKER_NOT_AVAILABLE = 8,\n  RD_KAFKA_RESP_ERR_REPLICA_NOT_AVAILABLE = 9,\n  RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE = 10,\n  RD_KAFKA_RESP_ERR_STALE_CTRL_EPOCH = 11,\n  RD_KAFKA_RESP_ERR_OFFSET_METADATA_TOO_LARGE = 12,\n  RD_KAFKA_RESP_ERR_NETWORK_EXCEPTION = 13,\n  RD_KAFKA_RESP_ERR_COORDINATOR_LOAD_IN_PROGRESS = 14,\n  RD_KAFKA_RESP_ERR_COORDINATOR_NOT_AVAILABLE = 15,\n  RD_KAFKA_RESP_ERR_NOT_COORDINATOR = 16,\n  RD_KAFKA_RESP_ERR_TOPIC_EXCEPTION = 17,\n  RD_KAFKA_RESP_ERR_RECORD_LIST_TOO_LARGE = 18,\n  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS = 19,\n  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS_AFTER_APPEND = 20,\n  RD_KAFKA_RESP_ERR_INVALID_REQUIRED_ACKS = 21,\n  RD_KAFKA_RESP_ERR_ILLEGAL_GENERATION = 22,\n  RD_KAFKA_RESP_ERR_INCONSISTENT_GROUP_PROTOCOL = 23,\n  RD_KAFKA_RESP_ERR_INVALID_GROUP_ID = 24,\n  RD_KAFKA_RESP_ERR_UNKNOWN_MEMBER_ID = 25,\n  RD_KAFKA_RESP_ERR_INVALID_SESSION_TIMEOUT = 26,\n  RD_KAFKA_RESP_ERR_REBALANCE_IN_PROGRESS = 27,\n  RD_KAFKA_RESP_ERR_INVALID_COMMIT_OFFSET_SIZE = 28,\n  RD_KAFKA_RESP_ERR_TOPIC_AUTHORIZATION_FAILED = 29,\n  RD_KAFKA_RESP_ERR_GROUP_AUTHORIZATION_FAILED = 30,\n  RD_KAFKA_RESP_ERR_CLUSTER_AUTHORIZATION_FAILED = 31,\n  RD_KAFKA_RESP_ERR_INVALID_TIMESTAMP = 32,\n  RD_KAFKA_RESP_ERR_UNSUPPORTED_SASL_MECHANISM = 33,\n  RD_KAFKA_RESP_ERR_ILLEGAL_SASL_STATE = 34,\n  RD_KAFKA_RESP_ERR_UNSUPPORTED_VERSION = 35,\n  RD_KAFKA_RESP_ERR_TOPIC_ALREADY_EXISTS = 36,\n  RD_KAFKA_RESP_ERR_INVALID_PARTITIONS = 37,\n  RD_KAFKA_RESP_ERR_INVALID_REPLICATION_FACTOR = 38,\n  RD_KAFKA_RESP_ERR_INVALID_REPLICA_ASSIGNMENT = 39,\n  RD_KAFKA_RESP_ERR_INVALID_CONFIG = 40,\n  RD_KAFKA_RESP_ERR_NOT_CONTROLLER = 41,\n  RD_KAFKA_RESP_ERR_INVALID_REQUEST = 42,\n  RD_KAFKA_RESP_ERR_UNSUPPORTED_FOR_MESSAGE_FORMAT = 43,\n  RD_KAFKA_RESP_ERR_POLICY_VIOLATION = 44,\n  RD_KAFKA_RESP_ERR_OUT_OF_ORDER_SEQUENCE_NUMBER = 45,\n  RD_KAFKA_RESP_ERR_DUPLICATE_SEQUENCE_NUMBER = 46,\n  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_EPOCH = 47,\n  RD_KAFKA_RESP_ERR_INVALID_TXN_STATE = 48,\n  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_ID_MAPPING = 49,\n  RD_KAFKA_RESP_ERR_INVALID_TRANSACTION_TIMEOUT = 50,\n  RD_KAFKA_RESP_ERR_CONCURRENT_TRANSACTIONS = 51,\n  RD_KAFKA_RESP_ERR_TRANSACTION_COORDINATOR_FENCED = 52,\n  RD_KAFKA_RESP_ERR_TRANSACTIONAL_ID_AUTHORIZATION_FAILED = 53,\n  RD_KAFKA_RESP_ERR_SECURITY_DISABLED = 54,\n  RD_KAFKA_RESP_ERR_OPERATION_NOT_ATTEMPTED = 55,\n  RD_KAFKA_RESP_ERR_KAFKA_STORAGE_ERROR = 56,\n  RD_KAFKA_RESP_ERR_LOG_DIR_NOT_FOUND = 57,\n  RD_KAFKA_RESP_ERR_SASL_AUTHENTICATION_FAILED = 58,\n  RD_KAFKA_RESP_ERR_UNKNOWN_PRODUCER_ID = 59,\n  RD_KAFKA_RESP_ERR_REASSIGNMENT_IN_PROGRESS = 60,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTH_DISABLED = 61,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_NOT_FOUND = 62,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_OWNER_MISMATCH = 63,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_REQUEST_NOT_ALLOWED = 64,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTHORIZATION_FAILED = 65,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_EXPIRED = 66,\n  RD_KAFKA_RESP_ERR_INVALID_PRINCIPAL_TYPE = 67,\n  RD_KAFKA_RESP_ERR_NON_EMPTY_GROUP = 68,\n  RD_KAFKA_RESP_ERR_GROUP_ID_NOT_FOUND = 69,\n  RD_KAFKA_RESP_ERR_FETCH_SESSION_ID_NOT_FOUND = 70,\n  RD_KAFKA_RESP_ERR_INVALID_FETCH_SESSION_EPOCH = 71,\n  RD_KAFKA_RESP_ERR_LISTENER_NOT_FOUND = 72,\n  RD_KAFKA_RESP_ERR_TOPIC_DELETION_DISABLED = 73,\n  RD_KAFKA_RESP_ERR_FENCED_LEADER_EPOCH = 74,\n  RD_KAFKA_RESP_ERR_UNKNOWN_LEADER_EPOCH = 75,\n  RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76,\n  RD_KAFKA_RESP_ERR_STALE_BROKER_EPOCH = 77,\n  RD_KAFKA_RESP_ERR_OFFSET_NOT_AVAILABLE = 78,\n  RD_KAFKA_RESP_ERR_MEMBER_ID_REQUIRED = 79,\n  RD_KAFKA_RESP_ERR_PREFERRED_LEADER_NOT_AVAILABLE = 80,\n  RD_KAFKA_RESP_ERR_GROUP_MAX_SIZE_REACHED = 81,\n  RD_KAFKA_RESP_ERR_FENCED_INSTANCE_ID = 82,\n  RD_KAFKA_RESP_ERR_END_ALL,\n} rd_kafka_resp_err_t;\nstruct rd_kafka_err_desc {\n  rd_kafka_resp_err_t code;\n  char *name;\n  char *desc;\n};\nvoid rd_kafka_get_err_descs(const struct rd_kafka_err_desc **errdescs, size_t *cntp);\nconst char *rd_kafka_err2str(rd_kafka_resp_err_t err);\nconst char *rd_kafka_err2name(rd_kafka_resp_err_t err);\nrd_kafka_resp_err_t rd_kafka_last_error(void);\nrd_kafka_resp_err_t rd_kafka_errno2err(int errnox);\nint rd_kafka_errno(void);\nrd_kafka_resp_err_t rd_kafka_fatal_error(rd_kafka_t *rk, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_test_fatal_error(rd_kafka_t *rk, rd_kafka_resp_err_t err, const char *reason);\nrd_kafka_resp_err_t rd_kafka_error_code(const rd_kafka_error_t *error);\nconst char *rd_kafka_error_name(const rd_kafka_error_t *error);\nconst char *rd_kafka_error_string(const rd_kafka_error_t *error);\nint rd_kafka_error_is_fatal(const rd_kafka_error_t *error);\nint rd_kafka_error_is_retriable(const rd_kafka_error_t *error);\nint rd_kafka_error_txn_requires_abort(const rd_kafka_error_t *error);\nvoid rd_kafka_error_destroy(rd_kafka_error_t *error);\nrd_kafka_error_t *rd_kafka_error_new(rd_kafka_resp_err_t code, const char *fmt, ...);\ntypedef struct rd_kafka_topic_partition_s {\n  char *topic;\n  int32_t partition;\n  int64_t offset;\n  void *metadata;\n  size_t metadata_size;\n  void *opaque;\n  rd_kafka_resp_err_t err;\n  void *_private;\n} rd_kafka_topic_partition_t;\nvoid rd_kafka_topic_partition_destroy(rd_kafka_topic_partition_t *rktpar);\ntypedef struct rd_kafka_topic_partition_list_s {\n  int cnt;\n  int size;\n  rd_kafka_topic_partition_t *elems;\n} rd_kafka_topic_partition_list_t;\nrd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_new(int size);\nvoid rd_kafka_topic_partition_list_destroy(rd_kafka_topic_partition_list_t *rkparlist);\nrd_kafka_topic_partition_t *rd_kafka_topic_partition_list_add(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);\nvoid rd_kafka_topic_partition_list_add_range(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t start, int32_t stop);\nint rd_kafka_topic_partition_list_del(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);\nint rd_kafka_topic_partition_list_del_by_idx(rd_kafka_topic_partition_list_t *rktparlist, int idx);\nrd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_copy(const rd_kafka_topic_partition_list_t *src);\nrd_kafka_resp_err_t rd_kafka_topic_partition_list_set_offset(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition, int64_t offset);\nrd_kafka_topic_partition_t *rd_kafka_topic_partition_list_find(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);\nvoid rd_kafka_topic_partition_list_sort(rd_kafka_topic_partition_list_t *rktparlist, int (*cmp)(const void *a, const void *b, void *cmp_opaque), void *cmp_opaque);\ntypedef enum rd_kafka_vtype_t {\n  RD_KAFKA_VTYPE_END,\n  RD_KAFKA_VTYPE_TOPIC,\n  RD_KAFKA_VTYPE_RKT,\n  RD_KAFKA_VTYPE_PARTITION,\n  RD_KAFKA_VTYPE_VALUE,\n  RD_KAFKA_VTYPE_KEY,\n  RD_KAFKA_VTYPE_OPAQUE,\n  RD_KAFKA_VTYPE_MSGFLAGS,\n  RD_KAFKA_VTYPE_TIMESTAMP,\n  RD_KAFKA_VTYPE_HEADER,\n  RD_KAFKA_VTYPE_HEADERS,\n} rd_kafka_vtype_t;\ntypedef struct rd_kafka_headers_s rd_kafka_headers_t;\nrd_kafka_headers_t *rd_kafka_headers_new(size_t initial_count);\nvoid rd_kafka_headers_destroy(rd_kafka_headers_t *hdrs);\nrd_kafka_headers_t *rd_kafka_headers_copy(const rd_kafka_headers_t *src);\nrd_kafka_resp_err_t rd_kafka_header_add(rd_kafka_headers_t *hdrs, const char *name, ssize_t name_size, const void *value, ssize_t value_size);\nrd_kafka_resp_err_t rd_kafka_header_remove(rd_kafka_headers_t *hdrs, const char *name);\nrd_kafka_resp_err_t rd_kafka_header_get_last(const rd_kafka_headers_t *hdrs, const char *name, const void **valuep, size_t *sizep);\nrd_kafka_resp_err_t rd_kafka_header_get(const rd_kafka_headers_t *hdrs, size_t idx, const char *name, const void **valuep, size_t *sizep);\nrd_kafka_resp_err_t rd_kafka_header_get_all(const rd_kafka_headers_t *hdrs, size_t idx, const char **namep, const void **valuep, size_t *sizep);\ntypedef struct rd_kafka_message_s {\n  rd_kafka_resp_err_t err;\n  rd_kafka_topic_t *rkt;\n  int32_t partition;\n  void *payload;\n  size_t len;\n  void *key;\n  size_t key_len;\n  int64_t offset;\n  void *_private;\n} rd_kafka_message_t;\nvoid rd_kafka_message_destroy(rd_kafka_message_t *rkmessage);\nint64_t rd_kafka_message_timestamp(const rd_kafka_message_t *rkmessage, rd_kafka_timestamp_type_t *tstype);\nint64_t rd_kafka_message_latency(const rd_kafka_message_t *rkmessage);\nrd_kafka_resp_err_t rd_kafka_message_headers(const rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);\nrd_kafka_resp_err_t rd_kafka_message_detach_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);\nvoid rd_kafka_message_set_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t *hdrs);\nsize_t rd_kafka_header_cnt(const rd_kafka_headers_t *hdrs);\ntypedef enum {\n  RD_KAFKA_MSG_STATUS_NOT_PERSISTED = 0,\n  RD_KAFKA_MSG_STATUS_POSSIBLY_PERSISTED = 1,\n  RD_KAFKA_MSG_STATUS_PERSISTED = 2,\n} rd_kafka_msg_status_t;\nrd_kafka_msg_status_t rd_kafka_message_status(const rd_kafka_message_t *rkmessage);\ntypedef enum {\n  RD_KAFKA_CONF_UNKNOWN = (- 2),\n  RD_KAFKA_CONF_INVALID = (- 1),\n  RD_KAFKA_CONF_OK = 0,\n} rd_kafka_conf_res_t;\nrd_kafka_conf_t *rd_kafka_conf_new(void);\nvoid rd_kafka_conf_destroy(rd_kafka_conf_t *conf);\nrd_kafka_conf_t *rd_kafka_conf_dup(const rd_kafka_conf_t *conf);\nrd_kafka_conf_t *rd_kafka_conf_dup_filter(const rd_kafka_conf_t *conf, size_t filter_cnt, const char **filter);\nconst rd_kafka_conf_t *rd_kafka_conf(rd_kafka_t *rk);\nrd_kafka_conf_res_t rd_kafka_conf_set(rd_kafka_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);\nvoid rd_kafka_conf_set_events(rd_kafka_conf_t *conf, int events);\nvoid rd_kafka_conf_set_background_event_cb(rd_kafka_conf_t *conf, void (*event_cb)(rd_kafka_t *rk, rd_kafka_event_t *rkev, void *opaque));\nvoid rd_kafka_conf_set_dr_cb(rd_kafka_conf_t *conf, void (*dr_cb)(rd_kafka_t *rk, void *payload, size_t len, rd_kafka_resp_err_t err, void *opaque, void *msg_opaque));\nvoid rd_kafka_conf_set_dr_msg_cb(rd_kafka_conf_t *conf, void (*dr_msg_cb)(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, void *opaque));\nvoid rd_kafka_conf_set_consume_cb(rd_kafka_conf_t *conf, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *opaque));\nvoid rd_kafka_conf_set_rebalance_cb(rd_kafka_conf_t *conf, void (*rebalance_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *partitions, void *opaque));\nvoid rd_kafka_conf_set_offset_commit_cb(rd_kafka_conf_t *conf, void (*offset_commit_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *opaque));\nvoid rd_kafka_conf_set_error_cb(rd_kafka_conf_t *conf, void (*error_cb)(rd_kafka_t *rk, int err, const char *reason, void *opaque));\nvoid rd_kafka_conf_set_throttle_cb(rd_kafka_conf_t *conf, void (*throttle_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int throttle_time_ms, void *opaque));\nvoid rd_kafka_conf_set_log_cb(rd_kafka_conf_t *conf, void (*log_cb)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));\nvoid rd_kafka_conf_set_stats_cb(rd_kafka_conf_t *conf, int (*stats_cb)(rd_kafka_t *rk, char *json, size_t json_len, void *opaque));\nvoid rd_kafka_conf_set_oauthbearer_token_refresh_cb(rd_kafka_conf_t *conf, void (*oauthbearer_token_refresh_cb)(rd_kafka_t *rk, const char *oauthbearer_config, void *opaque));\nvoid rd_kafka_conf_set_socket_cb(rd_kafka_conf_t *conf, int (*socket_cb)(int domain, int type, int protocol, void *opaque));\nvoid rd_kafka_conf_set_connect_cb(rd_kafka_conf_t *conf, int (*connect_cb)(int sockfd, const struct sockaddr *addr, int addrlen, const char *id, void *opaque));\nvoid rd_kafka_conf_set_closesocket_cb(rd_kafka_conf_t *conf, int (*closesocket_cb)(int sockfd, void *opaque));\nrd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert_verify_cb(rd_kafka_conf_t *conf, int (*ssl_cert_verify_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int *x509_error, int depth, const char *buf, size_t size, char *errstr, size_t errstr_size, void *opaque));\ntypedef enum rd_kafka_cert_type_t {\n  RD_KAFKA_CERT_PUBLIC_KEY,\n  RD_KAFKA_CERT_PRIVATE_KEY,\n  RD_KAFKA_CERT_CA,\n  RD_KAFKA_CERT__CNT,\n} rd_kafka_cert_type_t;\ntypedef enum rd_kafka_cert_enc_t {\n  RD_KAFKA_CERT_ENC_PKCS12,\n  RD_KAFKA_CERT_ENC_DER,\n  RD_KAFKA_CERT_ENC_PEM,\n  RD_KAFKA_CERT_ENC__CNT,\n} rd_kafka_cert_enc_t;\nrd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert(rd_kafka_conf_t *conf, rd_kafka_cert_type_t cert_type, rd_kafka_cert_enc_t cert_enc, const void *buffer, size_t size, char *errstr, size_t errstr_size);\nvoid rd_kafka_conf_set_opaque(rd_kafka_conf_t *conf, void *opaque);\nvoid *rd_kafka_opaque(const rd_kafka_t *rk);\nvoid rd_kafka_conf_set_default_topic_conf(rd_kafka_conf_t *conf, rd_kafka_topic_conf_t *tconf);\nrd_kafka_conf_res_t rd_kafka_conf_get(const rd_kafka_conf_t *conf, const char *name, char *dest, size_t *dest_size);\nrd_kafka_conf_res_t rd_kafka_topic_conf_get(const rd_kafka_topic_conf_t *conf, const char *name, char *dest, size_t *dest_size);\nconst char **rd_kafka_conf_dump(rd_kafka_conf_t *conf, size_t *cntp);\nconst char **rd_kafka_topic_conf_dump(rd_kafka_topic_conf_t *conf, size_t *cntp);\nvoid rd_kafka_conf_dump_free(const char **arr, size_t cnt);\nvoid rd_kafka_conf_properties_show(FILE *fp);\nrd_kafka_topic_conf_t *rd_kafka_topic_conf_new(void);\nrd_kafka_topic_conf_t *rd_kafka_topic_conf_dup(const rd_kafka_topic_conf_t *conf);\nrd_kafka_topic_conf_t *rd_kafka_default_topic_conf_dup(rd_kafka_t *rk);\nvoid rd_kafka_topic_conf_destroy(rd_kafka_topic_conf_t *topic_conf);\nrd_kafka_conf_res_t rd_kafka_topic_conf_set(rd_kafka_topic_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);\nvoid rd_kafka_topic_conf_set_opaque(rd_kafka_topic_conf_t *conf, void *rkt_opaque);\nvoid rd_kafka_topic_conf_set_partitioner_cb(rd_kafka_topic_conf_t *topic_conf, int32_t (*partitioner)(const rd_kafka_topic_t *rkt, const void *keydata, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque));\nvoid rd_kafka_topic_conf_set_msg_order_cmp(rd_kafka_topic_conf_t *topic_conf, int (*msg_order_cmp)(const rd_kafka_message_t *a, const rd_kafka_message_t *b));\nint rd_kafka_topic_partition_available(const rd_kafka_topic_t *rkt, int32_t partition);\nint32_t rd_kafka_msg_partitioner_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_consistent(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_consistent_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_murmur2(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_murmur2_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_fnv1a(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_fnv1a_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nrd_kafka_t *rd_kafka_new(rd_kafka_type_t type, rd_kafka_conf_t *conf, char *errstr, size_t errstr_size);\nvoid rd_kafka_destroy(rd_kafka_t *rk);\nvoid rd_kafka_destroy_flags(rd_kafka_t *rk, int flags);\nconst char *rd_kafka_name(const rd_kafka_t *rk);\nrd_kafka_type_t rd_kafka_type(const rd_kafka_t *rk);\nchar *rd_kafka_memberid(const rd_kafka_t *rk);\nchar *rd_kafka_clusterid(rd_kafka_t *rk, int timeout_ms);\nint32_t rd_kafka_controllerid(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_topic_t *rd_kafka_topic_new(rd_kafka_t *rk, const char *topic, rd_kafka_topic_conf_t *conf);\nvoid rd_kafka_topic_destroy(rd_kafka_topic_t *rkt);\nconst char *rd_kafka_topic_name(const rd_kafka_topic_t *rkt);\nvoid *rd_kafka_topic_opaque(const rd_kafka_topic_t *rkt);\nint rd_kafka_poll(rd_kafka_t *rk, int timeout_ms);\nvoid rd_kafka_yield(rd_kafka_t *rk);\nrd_kafka_resp_err_t rd_kafka_pause_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_resp_err_t rd_kafka_resume_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_resp_err_t rd_kafka_query_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high, int timeout_ms);\nrd_kafka_resp_err_t rd_kafka_get_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high);\nrd_kafka_resp_err_t rd_kafka_offsets_for_times(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets, int timeout_ms);\nvoid rd_kafka_mem_free(rd_kafka_t *rk, void *ptr);\nrd_kafka_queue_t *rd_kafka_queue_new(rd_kafka_t *rk);\nvoid rd_kafka_queue_destroy(rd_kafka_queue_t *rkqu);\nrd_kafka_queue_t *rd_kafka_queue_get_main(rd_kafka_t *rk);\nrd_kafka_queue_t *rd_kafka_queue_get_consumer(rd_kafka_t *rk);\nrd_kafka_queue_t *rd_kafka_queue_get_partition(rd_kafka_t *rk, const char *topic, int32_t partition);\nrd_kafka_queue_t *rd_kafka_queue_get_background(rd_kafka_t *rk);\nvoid rd_kafka_queue_forward(rd_kafka_queue_t *src, rd_kafka_queue_t *dst);\nrd_kafka_resp_err_t rd_kafka_set_log_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu);\nsize_t rd_kafka_queue_length(rd_kafka_queue_t *rkqu);\nvoid rd_kafka_queue_io_event_enable(rd_kafka_queue_t *rkqu, int fd, const void *payload, size_t size);\nvoid rd_kafka_queue_cb_event_enable(rd_kafka_queue_t *rkqu, void (*event_cb)(rd_kafka_t *rk, void *qev_opaque), void *qev_opaque);\nint rd_kafka_consume_start(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);\nint rd_kafka_consume_start_queue(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, rd_kafka_queue_t *rkqu);\nint rd_kafka_consume_stop(rd_kafka_topic_t *rkt, int32_t partition);\nrd_kafka_resp_err_t rd_kafka_seek(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, int timeout_ms);\nrd_kafka_message_t *rd_kafka_consume(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms);\nssize_t rd_kafka_consume_batch(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);\nint rd_kafka_consume_callback(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);\nrd_kafka_message_t *rd_kafka_consume_queue(rd_kafka_queue_t *rkqu, int timeout_ms);\nssize_t rd_kafka_consume_batch_queue(rd_kafka_queue_t *rkqu, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);\nint rd_kafka_consume_callback_queue(rd_kafka_queue_t *rkqu, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);\nrd_kafka_resp_err_t rd_kafka_offset_store(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);\nrd_kafka_resp_err_t rd_kafka_offsets_store(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets);\nrd_kafka_resp_err_t rd_kafka_subscribe(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *topics);\nrd_kafka_resp_err_t rd_kafka_unsubscribe(rd_kafka_t *rk);\nrd_kafka_resp_err_t rd_kafka_subscription(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **topics);\nrd_kafka_message_t *rd_kafka_consumer_poll(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_resp_err_t rd_kafka_consumer_close(rd_kafka_t *rk);\nrd_kafka_resp_err_t rd_kafka_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_resp_err_t rd_kafka_assignment(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **partitions);\nrd_kafka_resp_err_t rd_kafka_commit(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, int async);\nrd_kafka_resp_err_t rd_kafka_commit_message(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, int async);\nrd_kafka_resp_err_t rd_kafka_commit_queue(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_queue_t *rkqu, void (*cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *commit_opaque), void *commit_opaque);\nrd_kafka_resp_err_t rd_kafka_committed(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms);\nrd_kafka_resp_err_t rd_kafka_position(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata(rd_kafka_t *rk);\nrd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata_new(const char *group_id);\nvoid rd_kafka_consumer_group_metadata_destroy(rd_kafka_consumer_group_metadata_t *);\nrd_kafka_error_t *rd_kafka_consumer_group_metadata_write(const rd_kafka_consumer_group_metadata_t *cgmd, void **bufferp, size_t *sizep);\nrd_kafka_error_t *rd_kafka_consumer_group_metadata_read(rd_kafka_consumer_group_metadata_t **cgmdp, const void *buffer, size_t size);\nint rd_kafka_produce(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, void *payload, size_t len, const void *key, size_t keylen, void *msg_opaque);\nrd_kafka_resp_err_t rd_kafka_producev(rd_kafka_t *rk, ...);\nint rd_kafka_produce_batch(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, rd_kafka_message_t *rkmessages, int message_cnt);\nrd_kafka_resp_err_t rd_kafka_flush(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_resp_err_t rd_kafka_purge(rd_kafka_t *rk, int purge_flags);\ntypedef struct rd_kafka_metadata_broker {\n  int32_t id;\n  char *host;\n  int port;\n} rd_kafka_metadata_broker_t;\ntypedef struct rd_kafka_metadata_partition {\n  int32_t id;\n  rd_kafka_resp_err_t err;\n  int32_t leader;\n  int replica_cnt;\n  int32_t *replicas;\n  int isr_cnt;\n  int32_t *isrs;\n} rd_kafka_metadata_partition_t;\ntypedef struct rd_kafka_metadata_topic {\n  char *topic;\n  int partition_cnt;\n  struct rd_kafka_metadata_partition *partitions;\n  rd_kafka_resp_err_t err;\n} rd_kafka_metadata_topic_t;\ntypedef struct rd_kafka_metadata {\n  int broker_cnt;\n  struct rd_kafka_metadata_broker *brokers;\n  int topic_cnt;\n  struct rd_kafka_metadata_topic *topics;\n  int32_t orig_broker_id;\n  char *orig_broker_name;\n} rd_kafka_metadata_t;\nrd_kafka_resp_err_t rd_kafka_metadata(rd_kafka_t *rk, int all_topics, rd_kafka_topic_t *only_rkt, const struct rd_kafka_metadata **metadatap, int timeout_ms);\nvoid rd_kafka_metadata_destroy(const struct rd_kafka_metadata *metadata);\nstruct rd_kafka_group_member_info {\n  char *member_id;\n  char *client_id;\n  char *client_host;\n  void *member_metadata;\n  int member_metadata_size;\n  void *member_assignment;\n  int member_assignment_size;\n};\nstruct rd_kafka_group_info {\n  struct rd_kafka_metadata_broker broker;\n  char *group;\n  rd_kafka_resp_err_t err;\n  char *state;\n  char *protocol_type;\n  char *protocol;\n  struct rd_kafka_group_member_info *members;\n  int member_cnt;\n};\nstruct rd_kafka_group_list {\n  struct rd_kafka_group_info *groups;\n  int group_cnt;\n};\nrd_kafka_resp_err_t rd_kafka_list_groups(rd_kafka_t *rk, const char *group, const struct rd_kafka_group_list **grplistp, int timeout_ms);\nvoid rd_kafka_group_list_destroy(const struct rd_kafka_group_list *grplist);\nint rd_kafka_brokers_add(rd_kafka_t *rk, const char *brokerlist);\nvoid rd_kafka_set_logger(rd_kafka_t *rk, void (*func)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));\nvoid rd_kafka_set_log_level(rd_kafka_t *rk, int level);\nvoid rd_kafka_log_print(const rd_kafka_t *rk, int level, const char *fac, const char *buf);\nvoid rd_kafka_log_syslog(const rd_kafka_t *rk, int level, const char *fac, const char *buf);\nint rd_kafka_outq_len(rd_kafka_t *rk);\nvoid rd_kafka_dump(FILE *fp, rd_kafka_t *rk);\nint rd_kafka_thread_cnt(void);\ntypedef enum rd_kafka_thread_type_t {\n  RD_KAFKA_THREAD_MAIN,\n  RD_KAFKA_THREAD_BACKGROUND,\n  RD_KAFKA_THREAD_BROKER,\n} rd_kafka_thread_type_t;\nint rd_kafka_wait_destroyed(int timeout_ms);\nint rd_kafka_unittest(void);\nrd_kafka_resp_err_t rd_kafka_poll_set_consumer(rd_kafka_t *rk);\ntypedef int rd_kafka_event_type_t;\nrd_kafka_event_type_t rd_kafka_event_type(const rd_kafka_event_t *rkev);\nconst char *rd_kafka_event_name(const rd_kafka_event_t *rkev);\nvoid rd_kafka_event_destroy(rd_kafka_event_t *rkev);\nconst rd_kafka_message_t *rd_kafka_event_message_next(rd_kafka_event_t *rkev);\nsize_t rd_kafka_event_message_array(rd_kafka_event_t *rkev, const rd_kafka_message_t **rkmessages, size_t size);\nsize_t rd_kafka_event_message_count(rd_kafka_event_t *rkev);\nconst char *rd_kafka_event_config_string(rd_kafka_event_t *rkev);\nrd_kafka_resp_err_t rd_kafka_event_error(rd_kafka_event_t *rkev);\nconst char *rd_kafka_event_error_string(rd_kafka_event_t *rkev);\nint rd_kafka_event_error_is_fatal(rd_kafka_event_t *rkev);\nvoid *rd_kafka_event_opaque(rd_kafka_event_t *rkev);\nint rd_kafka_event_log(rd_kafka_event_t *rkev, const char **fac, const char **str, int *level);\nconst char *rd_kafka_event_stats(rd_kafka_event_t *rkev);\nrd_kafka_topic_partition_list_t *rd_kafka_event_topic_partition_list(rd_kafka_event_t *rkev);\nrd_kafka_topic_partition_t *rd_kafka_event_topic_partition(rd_kafka_event_t *rkev);\ntypedef rd_kafka_event_t rd_kafka_CreateTopics_result_t;\ntypedef rd_kafka_event_t rd_kafka_DeleteTopics_result_t;\ntypedef rd_kafka_event_t rd_kafka_CreatePartitions_result_t;\ntypedef rd_kafka_event_t rd_kafka_AlterConfigs_result_t;\ntypedef rd_kafka_event_t rd_kafka_DescribeConfigs_result_t;\nconst rd_kafka_CreateTopics_result_t *rd_kafka_event_CreateTopics_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DeleteTopics_result_t *rd_kafka_event_DeleteTopics_result(rd_kafka_event_t *rkev);\nconst rd_kafka_CreatePartitions_result_t *rd_kafka_event_CreatePartitions_result(rd_kafka_event_t *rkev);\nconst rd_kafka_AlterConfigs_result_t *rd_kafka_event_AlterConfigs_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DescribeConfigs_result_t *rd_kafka_event_DescribeConfigs_result(rd_kafka_event_t *rkev);\nrd_kafka_event_t *rd_kafka_queue_poll(rd_kafka_queue_t *rkqu, int timeout_ms);\nint rd_kafka_queue_poll_callback(rd_kafka_queue_t *rkqu, int timeout_ms);\ntypedef rd_kafka_resp_err_t (rd_kafka_plugin_f_conf_init_t)(rd_kafka_conf_t *conf, void **plug_opaquep, char *errstr, size_t errstr_size);\ntypedef rd_kafka_conf_res_t (rd_kafka_interceptor_f_on_conf_set_t)(rd_kafka_conf_t *conf, const char *name, const char *val, char *errstr, size_t errstr_size, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_dup_t)(rd_kafka_conf_t *new_conf, const rd_kafka_conf_t *old_conf, size_t filter_cnt, const char **filter, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_destroy_t)(void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_new_t)(rd_kafka_t *rk, const rd_kafka_conf_t *conf, void *ic_opaque, char *errstr, size_t errstr_size);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_destroy_t)(rd_kafka_t *rk, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_send_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_acknowledgement_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_consume_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_commit_t)(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_resp_err_t err, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_request_sent_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_start_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_exit_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_set(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_set_t *on_conf_set, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_dup(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_dup_t *on_conf_dup, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_destroy(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_destroy_t *on_conf_destroy, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_new(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_new_t *on_new, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_destroy(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_destroy_t *on_destroy, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_send(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_send_t *on_send, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_acknowledgement(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_acknowledgement_t *on_acknowledgement, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_consume(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_consume_t *on_consume, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_commit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_commit_t *on_commit, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_request_sent(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_request_sent_t *on_request_sent, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_start(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_start_t *on_thread_start, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_exit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_exit_t *on_thread_exit, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_topic_result_error(const rd_kafka_topic_result_t *topicres);\nconst char *rd_kafka_topic_result_error_string(const rd_kafka_topic_result_t *topicres);\nconst char *rd_kafka_topic_result_name(const rd_kafka_topic_result_t *topicres);\ntypedef enum rd_kafka_admin_op_t {\n  RD_KAFKA_ADMIN_OP_ANY = 0,\n  RD_KAFKA_ADMIN_OP_CREATETOPICS,\n  RD_KAFKA_ADMIN_OP_DELETETOPICS,\n  RD_KAFKA_ADMIN_OP_CREATEPARTITIONS,\n  RD_KAFKA_ADMIN_OP_ALTERCONFIGS,\n  RD_KAFKA_ADMIN_OP_DESCRIBECONFIGS,\n  RD_KAFKA_ADMIN_OP__CNT,\n} rd_kafka_admin_op_t;\ntypedef struct rd_kafka_AdminOptions_s rd_kafka_AdminOptions_t;\nrd_kafka_AdminOptions_t *rd_kafka_AdminOptions_new(rd_kafka_t *rk, rd_kafka_admin_op_t for_api);\nvoid rd_kafka_AdminOptions_destroy(rd_kafka_AdminOptions_t *options);\nrd_kafka_resp_err_t rd_kafka_AdminOptions_set_request_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_AdminOptions_set_operation_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_AdminOptions_set_validate_only(rd_kafka_AdminOptions_t *options, int true_or_false, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_AdminOptions_set_broker(rd_kafka_AdminOptions_t *options, int32_t broker_id, char *errstr, size_t errstr_size);\nvoid rd_kafka_AdminOptions_set_opaque(rd_kafka_AdminOptions_t *options, void *ev_opaque);\ntypedef struct rd_kafka_NewTopic_s rd_kafka_NewTopic_t;\nrd_kafka_NewTopic_t *rd_kafka_NewTopic_new(const char *topic, int num_partitions, int replication_factor, char *errstr, size_t errstr_size);\nvoid rd_kafka_NewTopic_destroy(rd_kafka_NewTopic_t *new_topic);\nvoid rd_kafka_NewTopic_destroy_array(rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt);\nrd_kafka_resp_err_t rd_kafka_NewTopic_set_replica_assignment(rd_kafka_NewTopic_t *new_topic, int32_t partition, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_NewTopic_set_config(rd_kafka_NewTopic_t *new_topic, const char *name, const char *value);\nvoid rd_kafka_CreateTopics(rd_kafka_t *rk, rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_topic_result_t **rd_kafka_CreateTopics_result_topics(const rd_kafka_CreateTopics_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_DeleteTopic_s rd_kafka_DeleteTopic_t;\nrd_kafka_DeleteTopic_t *rd_kafka_DeleteTopic_new(const char *topic);\nvoid rd_kafka_DeleteTopic_destroy(rd_kafka_DeleteTopic_t *del_topic);\nvoid rd_kafka_DeleteTopic_destroy_array(rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt);\nvoid rd_kafka_DeleteTopics(rd_kafka_t *rk, rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_topic_result_t **rd_kafka_DeleteTopics_result_topics(const rd_kafka_DeleteTopics_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_NewPartitions_s rd_kafka_NewPartitions_t;\nrd_kafka_NewPartitions_t *rd_kafka_NewPartitions_new(const char *topic, size_t new_total_cnt, char *errstr, size_t errstr_size);\nvoid rd_kafka_NewPartitions_destroy(rd_kafka_NewPartitions_t *new_parts);\nvoid rd_kafka_NewPartitions_destroy_array(rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt);\nrd_kafka_resp_err_t rd_kafka_NewPartitions_set_replica_assignment(rd_kafka_NewPartitions_t *new_parts, int32_t new_partition_idx, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);\nvoid rd_kafka_CreatePartitions(rd_kafka_t *rk, rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_topic_result_t **rd_kafka_CreatePartitions_result_topics(const rd_kafka_CreatePartitions_result_t *result, size_t *cntp);\ntypedef enum rd_kafka_ConfigSource_t {\n  RD_KAFKA_CONFIG_SOURCE_UNKNOWN_CONFIG = 0,\n  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_TOPIC_CONFIG = 1,\n  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_BROKER_CONFIG = 2,\n  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_DEFAULT_BROKER_CONFIG = 3,\n  RD_KAFKA_CONFIG_SOURCE_STATIC_BROKER_CONFIG = 4,\n  RD_KAFKA_CONFIG_SOURCE_DEFAULT_CONFIG = 5,\n  RD_KAFKA_CONFIG_SOURCE__CNT,\n} rd_kafka_ConfigSource_t;\nconst char *rd_kafka_ConfigSource_name(rd_kafka_ConfigSource_t confsource);\ntypedef struct rd_kafka_ConfigEntry_s rd_kafka_ConfigEntry_t;\nconst char *rd_kafka_ConfigEntry_name(const rd_kafka_ConfigEntry_t *entry);\nconst char *rd_kafka_ConfigEntry_value(const rd_kafka_ConfigEntry_t *entry);\nrd_kafka_ConfigSource_t rd_kafka_ConfigEntry_source(const rd_kafka_ConfigEntry_t *entry);\nint rd_kafka_ConfigEntry_is_read_only(const rd_kafka_ConfigEntry_t *entry);\nint rd_kafka_ConfigEntry_is_default(const rd_kafka_ConfigEntry_t *entry);\nint rd_kafka_ConfigEntry_is_sensitive(const rd_kafka_ConfigEntry_t *entry);\nint rd_kafka_ConfigEntry_is_synonym(const rd_kafka_ConfigEntry_t *entry);\nconst rd_kafka_ConfigEntry_t **rd_kafka_ConfigEntry_synonyms(const rd_kafka_ConfigEntry_t *entry, size_t *cntp);\ntypedef enum rd_kafka_ResourceType_t {\n  RD_KAFKA_RESOURCE_UNKNOWN = 0,\n  RD_KAFKA_RESOURCE_ANY = 1,\n  RD_KAFKA_RESOURCE_TOPIC = 2,\n  RD_KAFKA_RESOURCE_GROUP = 3,\n  RD_KAFKA_RESOURCE_BROKER = 4,\n  RD_KAFKA_RESOURCE__CNT,\n} rd_kafka_ResourceType_t;\nconst char *rd_kafka_ResourceType_name(rd_kafka_ResourceType_t restype);\ntypedef struct rd_kafka_ConfigResource_s rd_kafka_ConfigResource_t;\nrd_kafka_ConfigResource_t *rd_kafka_ConfigResource_new(rd_kafka_ResourceType_t restype, const char *resname);\nvoid rd_kafka_ConfigResource_destroy(rd_kafka_ConfigResource_t *config);\nvoid rd_kafka_ConfigResource_destroy_array(rd_kafka_ConfigResource_t **config, size_t config_cnt);\nrd_kafka_resp_err_t rd_kafka_ConfigResource_set_config(rd_kafka_ConfigResource_t *config, const char *name, const char *value);\nconst rd_kafka_ConfigEntry_t **rd_kafka_ConfigResource_configs(const rd_kafka_ConfigResource_t *config, size_t *cntp);\nrd_kafka_ResourceType_t rd_kafka_ConfigResource_type(const rd_kafka_ConfigResource_t *config);\nconst char *rd_kafka_ConfigResource_name(const rd_kafka_ConfigResource_t *config);\nrd_kafka_resp_err_t rd_kafka_ConfigResource_error(const rd_kafka_ConfigResource_t *config);\nconst char *rd_kafka_ConfigResource_error_string(const rd_kafka_ConfigResource_t *config);\nvoid rd_kafka_AlterConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_ConfigResource_t **rd_kafka_AlterConfigs_result_resources(const rd_kafka_AlterConfigs_result_t *result, size_t *cntp);\nvoid rd_kafka_DescribeConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_ConfigResource_t **rd_kafka_DescribeConfigs_result_resources(const rd_kafka_DescribeConfigs_result_t *result, size_t *cntp);\nrd_kafka_resp_err_t rd_kafka_oauthbearer_set_token(rd_kafka_t *rk, const char *token_value, int64_t md_lifetime_ms, const char *md_principal_name, const char **extensions, size_t extension_size, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_oauthbearer_set_token_failure(rd_kafka_t *rk, const char *errstr);\nrd_kafka_error_t *rd_kafka_init_transactions(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_error_t *rd_kafka_begin_transaction(rd_kafka_t *rk);\nrd_kafka_error_t *rd_kafka_send_offsets_to_transaction(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, const rd_kafka_consumer_group_metadata_t *cgmetadata, int timeout_ms);\nrd_kafka_error_t *rd_kafka_commit_transaction(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_error_t *rd_kafka_abort_transaction(rd_kafka_t *rk, int timeout_ms);\ntypedef struct rd_kafka_mock_cluster_s rd_kafka_mock_cluster_t;\nrd_kafka_mock_cluster_t *rd_kafka_mock_cluster_new(rd_kafka_t *rk, int broker_cnt);\nvoid rd_kafka_mock_cluster_destroy(rd_kafka_mock_cluster_t *mcluster);\nrd_kafka_t *rd_kafka_mock_cluster_handle(const rd_kafka_mock_cluster_t *mcluster);\nrd_kafka_mock_cluster_t *rd_kafka_handle_mock_cluster(const rd_kafka_t *rk);\nconst char *rd_kafka_mock_cluster_bootstraps(const rd_kafka_mock_cluster_t *mcluster);\nvoid rd_kafka_mock_push_request_errors(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, size_t cnt, ...);\nvoid rd_kafka_mock_topic_set_error(rd_kafka_mock_cluster_t *mcluster, const char *topic, rd_kafka_resp_err_t err);\nrd_kafka_resp_err_t rd_kafka_mock_topic_create(rd_kafka_mock_cluster_t *mcluster, const char *topic, int partition_cnt, int replication_factor);\nrd_kafka_resp_err_t rd_kafka_mock_partition_set_leader(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id);\nrd_kafka_resp_err_t rd_kafka_mock_partition_set_follower(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id);\nrd_kafka_resp_err_t rd_kafka_mock_partition_set_follower_wmarks(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int64_t lo, int64_t hi);\nrd_kafka_resp_err_t rd_kafka_mock_broker_set_down(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id);\nrd_kafka_resp_err_t rd_kafka_mock_broker_set_up(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id);\nrd_kafka_resp_err_t rd_kafka_mock_broker_set_rtt(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int rtt_ms);\nrd_kafka_resp_err_t rd_kafka_mock_broker_set_rack(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, const char *rack);\nrd_kafka_resp_err_t rd_kafka_mock_coordinator_set(rd_kafka_mock_cluster_t *mcluster, const char *key_type, const char *key, int32_t broker_id);\nrd_kafka_resp_err_t rd_kafka_mock_set_apiversion(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, int16_t MinVersion, int16_t MaxVersion);\n'\n</code></pre> rdkafka.h, rdkafka_mock.h</p>"},{"location":"api/constants/#rd_kafka_version_10","title":"RD_KAFKA_VERSION","text":"<pre><code>public RD_KAFKA_VERSION = 17105151\n</code></pre> <p>librdkafka version </p> <p>Interpreted as hex <code>MM.mm.rr.xx</code>:</p> <ul> <li>MM = Major</li> <li>mm = minor</li> <li>rr = revision</li> <li>xx = pre-release id (0xff is the final release)</li> </ul> <p>E.g.: <code>0x000801ff</code> = 0.8.1</p> RemarksThis value should only be used during compile time, for runtime checks of version use rd_kafka_version()  <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_unsupported_compression_type_10","title":"RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE","text":"<pre><code>public RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76\n</code></pre> <p>Unsupported compression type </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_end_all_10","title":"RD_KAFKA_RESP_ERR_END_ALL","text":"<p><pre><code>public RD_KAFKA_RESP_ERR_END_ALL = 83\n</code></pre> enum rd_kafka_resp_err_t</p>"},{"location":"api/constants/#rd_kafka_admin_op__cnt_10","title":"RD_KAFKA_ADMIN_OP__CNT","text":"<pre><code>public RD_KAFKA_ADMIN_OP__CNT = 6\n</code></pre> <p>Number of ops defined </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe </li> </ul>"},{"location":"api/constants/#rd_kafka_resource__cnt_10","title":"RD_KAFKA_RESOURCE__CNT","text":"<pre><code>public RD_KAFKA_RESOURCE__CNT = 5\n</code></pre> <p>Number of resource types defined </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#acca83a66d7783ff7683ed2691cc907c9 </li> </ul>"},{"location":"api/constants/#rd_kafka_cdef_10","title":"RD_KAFKA_CDEF","text":"<p><pre><code>public RD_KAFKA_CDEF = 'typedef long int ssize_t;\ntypedef struct _IO_FILE FILE;\ntypedef long int mode_t;\ntypedef signed int int16_t;\ntypedef unsigned int uint16_t;\ntypedef signed int int32_t;\ntypedef signed long int int64_t;\nint rd_kafka_version(void);\nconst char *rd_kafka_version_str(void);\ntypedef enum rd_kafka_type_t {\n  RD_KAFKA_PRODUCER,\n  RD_KAFKA_CONSUMER,\n} rd_kafka_type_t;\ntypedef enum rd_kafka_timestamp_type_t {\n  RD_KAFKA_TIMESTAMP_NOT_AVAILABLE,\n  RD_KAFKA_TIMESTAMP_CREATE_TIME,\n  RD_KAFKA_TIMESTAMP_LOG_APPEND_TIME,\n} rd_kafka_timestamp_type_t;\nconst char *rd_kafka_get_debug_contexts(void);\ntypedef struct rd_kafka_s rd_kafka_t;\ntypedef struct rd_kafka_topic_s rd_kafka_topic_t;\ntypedef struct rd_kafka_conf_s rd_kafka_conf_t;\ntypedef struct rd_kafka_topic_conf_s rd_kafka_topic_conf_t;\ntypedef struct rd_kafka_queue_s rd_kafka_queue_t;\ntypedef struct rd_kafka_op_s rd_kafka_event_t;\ntypedef struct rd_kafka_topic_result_s rd_kafka_topic_result_t;\ntypedef struct rd_kafka_consumer_group_metadata_s rd_kafka_consumer_group_metadata_t;\ntypedef struct rd_kafka_error_s {\n  unsigned int code;\n  char *errstr;\n  unsigned char fatal;\n  unsigned char retriable;\n  unsigned char txn_requires_abort;\n} rd_kafka_error_t;\ntypedef struct rd_kafka_headers_s rd_kafka_headers_t;\ntypedef enum {\n  RD_KAFKA_RESP_ERR__BEGIN = (- 200),\n  RD_KAFKA_RESP_ERR__BAD_MSG = (- 199),\n  RD_KAFKA_RESP_ERR__BAD_COMPRESSION = (- 198),\n  RD_KAFKA_RESP_ERR__DESTROY = (- 197),\n  RD_KAFKA_RESP_ERR__FAIL = (- 196),\n  RD_KAFKA_RESP_ERR__TRANSPORT = (- 195),\n  RD_KAFKA_RESP_ERR__CRIT_SYS_RESOURCE = (- 194),\n  RD_KAFKA_RESP_ERR__RESOLVE = (- 193),\n  RD_KAFKA_RESP_ERR__MSG_TIMED_OUT = (- 192),\n  RD_KAFKA_RESP_ERR__PARTITION_EOF = (- 191),\n  RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION = (- 190),\n  RD_KAFKA_RESP_ERR__FS = (- 189),\n  RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC = (- 188),\n  RD_KAFKA_RESP_ERR__ALL_BROKERS_DOWN = (- 187),\n  RD_KAFKA_RESP_ERR__INVALID_ARG = (- 186),\n  RD_KAFKA_RESP_ERR__TIMED_OUT = (- 185),\n  RD_KAFKA_RESP_ERR__QUEUE_FULL = (- 184),\n  RD_KAFKA_RESP_ERR__ISR_INSUFF = (- 183),\n  RD_KAFKA_RESP_ERR__NODE_UPDATE = (- 182),\n  RD_KAFKA_RESP_ERR__SSL = (- 181),\n  RD_KAFKA_RESP_ERR__WAIT_COORD = (- 180),\n  RD_KAFKA_RESP_ERR__UNKNOWN_GROUP = (- 179),\n  RD_KAFKA_RESP_ERR__IN_PROGRESS = (- 178),\n  RD_KAFKA_RESP_ERR__PREV_IN_PROGRESS = (- 177),\n  RD_KAFKA_RESP_ERR__EXISTING_SUBSCRIPTION = (- 176),\n  RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS = (- 175),\n  RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS = (- 174),\n  RD_KAFKA_RESP_ERR__CONFLICT = (- 173),\n  RD_KAFKA_RESP_ERR__STATE = (- 172),\n  RD_KAFKA_RESP_ERR__UNKNOWN_PROTOCOL = (- 171),\n  RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED = (- 170),\n  RD_KAFKA_RESP_ERR__AUTHENTICATION = (- 169),\n  RD_KAFKA_RESP_ERR__NO_OFFSET = (- 168),\n  RD_KAFKA_RESP_ERR__OUTDATED = (- 167),\n  RD_KAFKA_RESP_ERR__TIMED_OUT_QUEUE = (- 166),\n  RD_KAFKA_RESP_ERR__UNSUPPORTED_FEATURE = (- 165),\n  RD_KAFKA_RESP_ERR__WAIT_CACHE = (- 164),\n  RD_KAFKA_RESP_ERR__INTR = (- 163),\n  RD_KAFKA_RESP_ERR__KEY_SERIALIZATION = (- 162),\n  RD_KAFKA_RESP_ERR__VALUE_SERIALIZATION = (- 161),\n  RD_KAFKA_RESP_ERR__KEY_DESERIALIZATION = (- 160),\n  RD_KAFKA_RESP_ERR__VALUE_DESERIALIZATION = (- 159),\n  RD_KAFKA_RESP_ERR__PARTIAL = (- 158),\n  RD_KAFKA_RESP_ERR__READ_ONLY = (- 157),\n  RD_KAFKA_RESP_ERR__NOENT = (- 156),\n  RD_KAFKA_RESP_ERR__UNDERFLOW = (- 155),\n  RD_KAFKA_RESP_ERR__INVALID_TYPE = (- 154),\n  RD_KAFKA_RESP_ERR__RETRY = (- 153),\n  RD_KAFKA_RESP_ERR__PURGE_QUEUE = (- 152),\n  RD_KAFKA_RESP_ERR__PURGE_INFLIGHT = (- 151),\n  RD_KAFKA_RESP_ERR__FATAL = (- 150),\n  RD_KAFKA_RESP_ERR__INCONSISTENT = (- 149),\n  RD_KAFKA_RESP_ERR__GAPLESS_GUARANTEE = (- 148),\n  RD_KAFKA_RESP_ERR__MAX_POLL_EXCEEDED = (- 147),\n  RD_KAFKA_RESP_ERR__UNKNOWN_BROKER = (- 146),\n  RD_KAFKA_RESP_ERR__NOT_CONFIGURED = (- 145),\n  RD_KAFKA_RESP_ERR__FENCED = (- 144),\n  RD_KAFKA_RESP_ERR__APPLICATION = (- 143),\n  RD_KAFKA_RESP_ERR__END = (- 100),\n  RD_KAFKA_RESP_ERR_UNKNOWN = (- 1),\n  RD_KAFKA_RESP_ERR_NO_ERROR = 0,\n  RD_KAFKA_RESP_ERR_OFFSET_OUT_OF_RANGE = 1,\n  RD_KAFKA_RESP_ERR_INVALID_MSG = 2,\n  RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART = 3,\n  RD_KAFKA_RESP_ERR_INVALID_MSG_SIZE = 4,\n  RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE = 5,\n  RD_KAFKA_RESP_ERR_NOT_LEADER_FOR_PARTITION = 6,\n  RD_KAFKA_RESP_ERR_REQUEST_TIMED_OUT = 7,\n  RD_KAFKA_RESP_ERR_BROKER_NOT_AVAILABLE = 8,\n  RD_KAFKA_RESP_ERR_REPLICA_NOT_AVAILABLE = 9,\n  RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE = 10,\n  RD_KAFKA_RESP_ERR_STALE_CTRL_EPOCH = 11,\n  RD_KAFKA_RESP_ERR_OFFSET_METADATA_TOO_LARGE = 12,\n  RD_KAFKA_RESP_ERR_NETWORK_EXCEPTION = 13,\n  RD_KAFKA_RESP_ERR_COORDINATOR_LOAD_IN_PROGRESS = 14,\n  RD_KAFKA_RESP_ERR_COORDINATOR_NOT_AVAILABLE = 15,\n  RD_KAFKA_RESP_ERR_NOT_COORDINATOR = 16,\n  RD_KAFKA_RESP_ERR_TOPIC_EXCEPTION = 17,\n  RD_KAFKA_RESP_ERR_RECORD_LIST_TOO_LARGE = 18,\n  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS = 19,\n  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS_AFTER_APPEND = 20,\n  RD_KAFKA_RESP_ERR_INVALID_REQUIRED_ACKS = 21,\n  RD_KAFKA_RESP_ERR_ILLEGAL_GENERATION = 22,\n  RD_KAFKA_RESP_ERR_INCONSISTENT_GROUP_PROTOCOL = 23,\n  RD_KAFKA_RESP_ERR_INVALID_GROUP_ID = 24,\n  RD_KAFKA_RESP_ERR_UNKNOWN_MEMBER_ID = 25,\n  RD_KAFKA_RESP_ERR_INVALID_SESSION_TIMEOUT = 26,\n  RD_KAFKA_RESP_ERR_REBALANCE_IN_PROGRESS = 27,\n  RD_KAFKA_RESP_ERR_INVALID_COMMIT_OFFSET_SIZE = 28,\n  RD_KAFKA_RESP_ERR_TOPIC_AUTHORIZATION_FAILED = 29,\n  RD_KAFKA_RESP_ERR_GROUP_AUTHORIZATION_FAILED = 30,\n  RD_KAFKA_RESP_ERR_CLUSTER_AUTHORIZATION_FAILED = 31,\n  RD_KAFKA_RESP_ERR_INVALID_TIMESTAMP = 32,\n  RD_KAFKA_RESP_ERR_UNSUPPORTED_SASL_MECHANISM = 33,\n  RD_KAFKA_RESP_ERR_ILLEGAL_SASL_STATE = 34,\n  RD_KAFKA_RESP_ERR_UNSUPPORTED_VERSION = 35,\n  RD_KAFKA_RESP_ERR_TOPIC_ALREADY_EXISTS = 36,\n  RD_KAFKA_RESP_ERR_INVALID_PARTITIONS = 37,\n  RD_KAFKA_RESP_ERR_INVALID_REPLICATION_FACTOR = 38,\n  RD_KAFKA_RESP_ERR_INVALID_REPLICA_ASSIGNMENT = 39,\n  RD_KAFKA_RESP_ERR_INVALID_CONFIG = 40,\n  RD_KAFKA_RESP_ERR_NOT_CONTROLLER = 41,\n  RD_KAFKA_RESP_ERR_INVALID_REQUEST = 42,\n  RD_KAFKA_RESP_ERR_UNSUPPORTED_FOR_MESSAGE_FORMAT = 43,\n  RD_KAFKA_RESP_ERR_POLICY_VIOLATION = 44,\n  RD_KAFKA_RESP_ERR_OUT_OF_ORDER_SEQUENCE_NUMBER = 45,\n  RD_KAFKA_RESP_ERR_DUPLICATE_SEQUENCE_NUMBER = 46,\n  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_EPOCH = 47,\n  RD_KAFKA_RESP_ERR_INVALID_TXN_STATE = 48,\n  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_ID_MAPPING = 49,\n  RD_KAFKA_RESP_ERR_INVALID_TRANSACTION_TIMEOUT = 50,\n  RD_KAFKA_RESP_ERR_CONCURRENT_TRANSACTIONS = 51,\n  RD_KAFKA_RESP_ERR_TRANSACTION_COORDINATOR_FENCED = 52,\n  RD_KAFKA_RESP_ERR_TRANSACTIONAL_ID_AUTHORIZATION_FAILED = 53,\n  RD_KAFKA_RESP_ERR_SECURITY_DISABLED = 54,\n  RD_KAFKA_RESP_ERR_OPERATION_NOT_ATTEMPTED = 55,\n  RD_KAFKA_RESP_ERR_KAFKA_STORAGE_ERROR = 56,\n  RD_KAFKA_RESP_ERR_LOG_DIR_NOT_FOUND = 57,\n  RD_KAFKA_RESP_ERR_SASL_AUTHENTICATION_FAILED = 58,\n  RD_KAFKA_RESP_ERR_UNKNOWN_PRODUCER_ID = 59,\n  RD_KAFKA_RESP_ERR_REASSIGNMENT_IN_PROGRESS = 60,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTH_DISABLED = 61,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_NOT_FOUND = 62,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_OWNER_MISMATCH = 63,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_REQUEST_NOT_ALLOWED = 64,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTHORIZATION_FAILED = 65,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_EXPIRED = 66,\n  RD_KAFKA_RESP_ERR_INVALID_PRINCIPAL_TYPE = 67,\n  RD_KAFKA_RESP_ERR_NON_EMPTY_GROUP = 68,\n  RD_KAFKA_RESP_ERR_GROUP_ID_NOT_FOUND = 69,\n  RD_KAFKA_RESP_ERR_FETCH_SESSION_ID_NOT_FOUND = 70,\n  RD_KAFKA_RESP_ERR_INVALID_FETCH_SESSION_EPOCH = 71,\n  RD_KAFKA_RESP_ERR_LISTENER_NOT_FOUND = 72,\n  RD_KAFKA_RESP_ERR_TOPIC_DELETION_DISABLED = 73,\n  RD_KAFKA_RESP_ERR_FENCED_LEADER_EPOCH = 74,\n  RD_KAFKA_RESP_ERR_UNKNOWN_LEADER_EPOCH = 75,\n  RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76,\n  RD_KAFKA_RESP_ERR_STALE_BROKER_EPOCH = 77,\n  RD_KAFKA_RESP_ERR_OFFSET_NOT_AVAILABLE = 78,\n  RD_KAFKA_RESP_ERR_MEMBER_ID_REQUIRED = 79,\n  RD_KAFKA_RESP_ERR_PREFERRED_LEADER_NOT_AVAILABLE = 80,\n  RD_KAFKA_RESP_ERR_GROUP_MAX_SIZE_REACHED = 81,\n  RD_KAFKA_RESP_ERR_FENCED_INSTANCE_ID = 82,\n  RD_KAFKA_RESP_ERR_END_ALL,\n} rd_kafka_resp_err_t;\nstruct rd_kafka_err_desc {\n  rd_kafka_resp_err_t code;\n  char *name;\n  char *desc;\n};\nvoid rd_kafka_get_err_descs(const struct rd_kafka_err_desc **errdescs, size_t *cntp);\nconst char *rd_kafka_err2str(rd_kafka_resp_err_t err);\nconst char *rd_kafka_err2name(rd_kafka_resp_err_t err);\nrd_kafka_resp_err_t rd_kafka_last_error(void);\nrd_kafka_resp_err_t rd_kafka_errno2err(int errnox);\nint rd_kafka_errno(void);\nrd_kafka_resp_err_t rd_kafka_fatal_error(rd_kafka_t *rk, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_test_fatal_error(rd_kafka_t *rk, rd_kafka_resp_err_t err, const char *reason);\nrd_kafka_resp_err_t rd_kafka_error_code(const rd_kafka_error_t *error);\nconst char *rd_kafka_error_name(const rd_kafka_error_t *error);\nconst char *rd_kafka_error_string(const rd_kafka_error_t *error);\nint rd_kafka_error_is_fatal(const rd_kafka_error_t *error);\nint rd_kafka_error_is_retriable(const rd_kafka_error_t *error);\nint rd_kafka_error_txn_requires_abort(const rd_kafka_error_t *error);\nvoid rd_kafka_error_destroy(rd_kafka_error_t *error);\nrd_kafka_error_t *rd_kafka_error_new(rd_kafka_resp_err_t code, const char *fmt, ...);\ntypedef struct rd_kafka_topic_partition_s {\n  char *topic;\n  int32_t partition;\n  int64_t offset;\n  void *metadata;\n  size_t metadata_size;\n  void *opaque;\n  rd_kafka_resp_err_t err;\n  void *_private;\n} rd_kafka_topic_partition_t;\nvoid rd_kafka_topic_partition_destroy(rd_kafka_topic_partition_t *rktpar);\ntypedef struct rd_kafka_topic_partition_list_s {\n  int cnt;\n  int size;\n  rd_kafka_topic_partition_t *elems;\n} rd_kafka_topic_partition_list_t;\nrd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_new(int size);\nvoid rd_kafka_topic_partition_list_destroy(rd_kafka_topic_partition_list_t *rkparlist);\nrd_kafka_topic_partition_t *rd_kafka_topic_partition_list_add(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);\nvoid rd_kafka_topic_partition_list_add_range(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t start, int32_t stop);\nint rd_kafka_topic_partition_list_del(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);\nint rd_kafka_topic_partition_list_del_by_idx(rd_kafka_topic_partition_list_t *rktparlist, int idx);\nrd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_copy(const rd_kafka_topic_partition_list_t *src);\nrd_kafka_resp_err_t rd_kafka_topic_partition_list_set_offset(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition, int64_t offset);\nrd_kafka_topic_partition_t *rd_kafka_topic_partition_list_find(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);\nvoid rd_kafka_topic_partition_list_sort(rd_kafka_topic_partition_list_t *rktparlist, int (*cmp)(const void *a, const void *b, void *cmp_opaque), void *cmp_opaque);\ntypedef enum rd_kafka_vtype_t {\n  RD_KAFKA_VTYPE_END,\n  RD_KAFKA_VTYPE_TOPIC,\n  RD_KAFKA_VTYPE_RKT,\n  RD_KAFKA_VTYPE_PARTITION,\n  RD_KAFKA_VTYPE_VALUE,\n  RD_KAFKA_VTYPE_KEY,\n  RD_KAFKA_VTYPE_OPAQUE,\n  RD_KAFKA_VTYPE_MSGFLAGS,\n  RD_KAFKA_VTYPE_TIMESTAMP,\n  RD_KAFKA_VTYPE_HEADER,\n  RD_KAFKA_VTYPE_HEADERS,\n} rd_kafka_vtype_t;\ntypedef struct rd_kafka_vu_s {\n  rd_kafka_vtype_t vtype;\n  union {\n    char *cstr;\n    rd_kafka_topic_t *rkt;\n    int i;\n    int32_t i32;\n    int64_t i64;\n    struct {\n      void *ptr;\n      size_t size;\n    } mem;\n    struct {\n      char *name;\n      void *val;\n      ssize_t size;\n    } header;\n    rd_kafka_headers_t *headers;\n    void *ptr;\n    char _pad[64];\n  } u;\n} rd_kafka_vu_t;\nrd_kafka_headers_t *rd_kafka_headers_new(size_t initial_count);\nvoid rd_kafka_headers_destroy(rd_kafka_headers_t *hdrs);\nrd_kafka_headers_t *rd_kafka_headers_copy(const rd_kafka_headers_t *src);\nrd_kafka_resp_err_t rd_kafka_header_add(rd_kafka_headers_t *hdrs, const char *name, ssize_t name_size, const void *value, ssize_t value_size);\nrd_kafka_resp_err_t rd_kafka_header_remove(rd_kafka_headers_t *hdrs, const char *name);\nrd_kafka_resp_err_t rd_kafka_header_get_last(const rd_kafka_headers_t *hdrs, const char *name, const void **valuep, size_t *sizep);\nrd_kafka_resp_err_t rd_kafka_header_get(const rd_kafka_headers_t *hdrs, size_t idx, const char *name, const void **valuep, size_t *sizep);\nrd_kafka_resp_err_t rd_kafka_header_get_all(const rd_kafka_headers_t *hdrs, size_t idx, const char **namep, const void **valuep, size_t *sizep);\ntypedef struct rd_kafka_message_s {\n  rd_kafka_resp_err_t err;\n  rd_kafka_topic_t *rkt;\n  int32_t partition;\n  void *payload;\n  size_t len;\n  void *key;\n  size_t key_len;\n  int64_t offset;\n  void *_private;\n} rd_kafka_message_t;\nvoid rd_kafka_message_destroy(rd_kafka_message_t *rkmessage);\nconst char *rd_kafka_message_errstr(const rd_kafka_message_t *rkmessage);\nint64_t rd_kafka_message_timestamp(const rd_kafka_message_t *rkmessage, rd_kafka_timestamp_type_t *tstype);\nint64_t rd_kafka_message_latency(const rd_kafka_message_t *rkmessage);\nint32_t rd_kafka_message_broker_id(const rd_kafka_message_t *rkmessage);\nrd_kafka_resp_err_t rd_kafka_message_headers(const rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);\nrd_kafka_resp_err_t rd_kafka_message_detach_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);\nvoid rd_kafka_message_set_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t *hdrs);\nsize_t rd_kafka_header_cnt(const rd_kafka_headers_t *hdrs);\ntypedef enum {\n  RD_KAFKA_MSG_STATUS_NOT_PERSISTED = 0,\n  RD_KAFKA_MSG_STATUS_POSSIBLY_PERSISTED = 1,\n  RD_KAFKA_MSG_STATUS_PERSISTED = 2,\n} rd_kafka_msg_status_t;\nrd_kafka_msg_status_t rd_kafka_message_status(const rd_kafka_message_t *rkmessage);\ntypedef enum {\n  RD_KAFKA_CONF_UNKNOWN = (- 2),\n  RD_KAFKA_CONF_INVALID = (- 1),\n  RD_KAFKA_CONF_OK = 0,\n} rd_kafka_conf_res_t;\nrd_kafka_conf_t *rd_kafka_conf_new(void);\nvoid rd_kafka_conf_destroy(rd_kafka_conf_t *conf);\nrd_kafka_conf_t *rd_kafka_conf_dup(const rd_kafka_conf_t *conf);\nrd_kafka_conf_t *rd_kafka_conf_dup_filter(const rd_kafka_conf_t *conf, size_t filter_cnt, const char **filter);\nconst rd_kafka_conf_t *rd_kafka_conf(rd_kafka_t *rk);\nrd_kafka_conf_res_t rd_kafka_conf_set(rd_kafka_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);\nvoid rd_kafka_conf_set_events(rd_kafka_conf_t *conf, int events);\nvoid rd_kafka_conf_set_background_event_cb(rd_kafka_conf_t *conf, void (*event_cb)(rd_kafka_t *rk, rd_kafka_event_t *rkev, void *opaque));\nvoid rd_kafka_conf_set_dr_cb(rd_kafka_conf_t *conf, void (*dr_cb)(rd_kafka_t *rk, void *payload, size_t len, rd_kafka_resp_err_t err, void *opaque, void *msg_opaque));\nvoid rd_kafka_conf_set_dr_msg_cb(rd_kafka_conf_t *conf, void (*dr_msg_cb)(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, void *opaque));\nvoid rd_kafka_conf_set_consume_cb(rd_kafka_conf_t *conf, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *opaque));\nvoid rd_kafka_conf_set_rebalance_cb(rd_kafka_conf_t *conf, void (*rebalance_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *partitions, void *opaque));\nvoid rd_kafka_conf_set_offset_commit_cb(rd_kafka_conf_t *conf, void (*offset_commit_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *opaque));\nvoid rd_kafka_conf_set_error_cb(rd_kafka_conf_t *conf, void (*error_cb)(rd_kafka_t *rk, int err, const char *reason, void *opaque));\nvoid rd_kafka_conf_set_throttle_cb(rd_kafka_conf_t *conf, void (*throttle_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int throttle_time_ms, void *opaque));\nvoid rd_kafka_conf_set_log_cb(rd_kafka_conf_t *conf, void (*log_cb)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));\nvoid rd_kafka_conf_set_stats_cb(rd_kafka_conf_t *conf, int (*stats_cb)(rd_kafka_t *rk, char *json, size_t json_len, void *opaque));\nvoid rd_kafka_conf_set_oauthbearer_token_refresh_cb(rd_kafka_conf_t *conf, void (*oauthbearer_token_refresh_cb)(rd_kafka_t *rk, const char *oauthbearer_config, void *opaque));\nvoid rd_kafka_conf_set_socket_cb(rd_kafka_conf_t *conf, int (*socket_cb)(int domain, int type, int protocol, void *opaque));\nvoid rd_kafka_conf_set_connect_cb(rd_kafka_conf_t *conf, int (*connect_cb)(int sockfd, const struct sockaddr *addr, int addrlen, const char *id, void *opaque));\nvoid rd_kafka_conf_set_closesocket_cb(rd_kafka_conf_t *conf, int (*closesocket_cb)(int sockfd, void *opaque));\nrd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert_verify_cb(rd_kafka_conf_t *conf, int (*ssl_cert_verify_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int *x509_error, int depth, const char *buf, size_t size, char *errstr, size_t errstr_size, void *opaque));\ntypedef enum rd_kafka_cert_type_t {\n  RD_KAFKA_CERT_PUBLIC_KEY,\n  RD_KAFKA_CERT_PRIVATE_KEY,\n  RD_KAFKA_CERT_CA,\n  RD_KAFKA_CERT__CNT,\n} rd_kafka_cert_type_t;\ntypedef enum rd_kafka_cert_enc_t {\n  RD_KAFKA_CERT_ENC_PKCS12,\n  RD_KAFKA_CERT_ENC_DER,\n  RD_KAFKA_CERT_ENC_PEM,\n  RD_KAFKA_CERT_ENC__CNT,\n} rd_kafka_cert_enc_t;\nrd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert(rd_kafka_conf_t *conf, rd_kafka_cert_type_t cert_type, rd_kafka_cert_enc_t cert_enc, const void *buffer, size_t size, char *errstr, size_t errstr_size);\nvoid rd_kafka_conf_set_opaque(rd_kafka_conf_t *conf, void *opaque);\nvoid *rd_kafka_opaque(const rd_kafka_t *rk);\nvoid rd_kafka_conf_set_default_topic_conf(rd_kafka_conf_t *conf, rd_kafka_topic_conf_t *tconf);\nrd_kafka_conf_res_t rd_kafka_conf_get(const rd_kafka_conf_t *conf, const char *name, char *dest, size_t *dest_size);\nrd_kafka_conf_res_t rd_kafka_topic_conf_get(const rd_kafka_topic_conf_t *conf, const char *name, char *dest, size_t *dest_size);\nconst char **rd_kafka_conf_dump(rd_kafka_conf_t *conf, size_t *cntp);\nconst char **rd_kafka_topic_conf_dump(rd_kafka_topic_conf_t *conf, size_t *cntp);\nvoid rd_kafka_conf_dump_free(const char **arr, size_t cnt);\nvoid rd_kafka_conf_properties_show(FILE *fp);\nrd_kafka_topic_conf_t *rd_kafka_topic_conf_new(void);\nrd_kafka_topic_conf_t *rd_kafka_topic_conf_dup(const rd_kafka_topic_conf_t *conf);\nrd_kafka_topic_conf_t *rd_kafka_default_topic_conf_dup(rd_kafka_t *rk);\nvoid rd_kafka_topic_conf_destroy(rd_kafka_topic_conf_t *topic_conf);\nrd_kafka_conf_res_t rd_kafka_topic_conf_set(rd_kafka_topic_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);\nvoid rd_kafka_topic_conf_set_opaque(rd_kafka_topic_conf_t *conf, void *rkt_opaque);\nvoid rd_kafka_topic_conf_set_partitioner_cb(rd_kafka_topic_conf_t *topic_conf, int32_t (*partitioner)(const rd_kafka_topic_t *rkt, const void *keydata, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque));\nvoid rd_kafka_topic_conf_set_msg_order_cmp(rd_kafka_topic_conf_t *topic_conf, int (*msg_order_cmp)(const rd_kafka_message_t *a, const rd_kafka_message_t *b));\nint rd_kafka_topic_partition_available(const rd_kafka_topic_t *rkt, int32_t partition);\nint32_t rd_kafka_msg_partitioner_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_consistent(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_consistent_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_murmur2(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_murmur2_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_fnv1a(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_fnv1a_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nrd_kafka_t *rd_kafka_new(rd_kafka_type_t type, rd_kafka_conf_t *conf, char *errstr, size_t errstr_size);\nvoid rd_kafka_destroy(rd_kafka_t *rk);\nvoid rd_kafka_destroy_flags(rd_kafka_t *rk, int flags);\nconst char *rd_kafka_name(const rd_kafka_t *rk);\nrd_kafka_type_t rd_kafka_type(const rd_kafka_t *rk);\nchar *rd_kafka_memberid(const rd_kafka_t *rk);\nchar *rd_kafka_clusterid(rd_kafka_t *rk, int timeout_ms);\nint32_t rd_kafka_controllerid(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_topic_t *rd_kafka_topic_new(rd_kafka_t *rk, const char *topic, rd_kafka_topic_conf_t *conf);\nvoid rd_kafka_topic_destroy(rd_kafka_topic_t *rkt);\nconst char *rd_kafka_topic_name(const rd_kafka_topic_t *rkt);\nvoid *rd_kafka_topic_opaque(const rd_kafka_topic_t *rkt);\nint rd_kafka_poll(rd_kafka_t *rk, int timeout_ms);\nvoid rd_kafka_yield(rd_kafka_t *rk);\nrd_kafka_resp_err_t rd_kafka_pause_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_resp_err_t rd_kafka_resume_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_resp_err_t rd_kafka_query_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high, int timeout_ms);\nrd_kafka_resp_err_t rd_kafka_get_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high);\nrd_kafka_resp_err_t rd_kafka_offsets_for_times(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets, int timeout_ms);\nvoid rd_kafka_mem_free(rd_kafka_t *rk, void *ptr);\nrd_kafka_queue_t *rd_kafka_queue_new(rd_kafka_t *rk);\nvoid rd_kafka_queue_destroy(rd_kafka_queue_t *rkqu);\nrd_kafka_queue_t *rd_kafka_queue_get_main(rd_kafka_t *rk);\nrd_kafka_queue_t *rd_kafka_queue_get_consumer(rd_kafka_t *rk);\nrd_kafka_queue_t *rd_kafka_queue_get_partition(rd_kafka_t *rk, const char *topic, int32_t partition);\nrd_kafka_queue_t *rd_kafka_queue_get_background(rd_kafka_t *rk);\nvoid rd_kafka_queue_forward(rd_kafka_queue_t *src, rd_kafka_queue_t *dst);\nrd_kafka_resp_err_t rd_kafka_set_log_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu);\nsize_t rd_kafka_queue_length(rd_kafka_queue_t *rkqu);\nvoid rd_kafka_queue_io_event_enable(rd_kafka_queue_t *rkqu, int fd, const void *payload, size_t size);\nvoid rd_kafka_queue_cb_event_enable(rd_kafka_queue_t *rkqu, void (*event_cb)(rd_kafka_t *rk, void *qev_opaque), void *qev_opaque);\nint rd_kafka_consume_start(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);\nint rd_kafka_consume_start_queue(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, rd_kafka_queue_t *rkqu);\nint rd_kafka_consume_stop(rd_kafka_topic_t *rkt, int32_t partition);\nrd_kafka_resp_err_t rd_kafka_seek(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, int timeout_ms);\nrd_kafka_message_t *rd_kafka_consume(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms);\nssize_t rd_kafka_consume_batch(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);\nint rd_kafka_consume_callback(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);\nrd_kafka_message_t *rd_kafka_consume_queue(rd_kafka_queue_t *rkqu, int timeout_ms);\nssize_t rd_kafka_consume_batch_queue(rd_kafka_queue_t *rkqu, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);\nint rd_kafka_consume_callback_queue(rd_kafka_queue_t *rkqu, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);\nrd_kafka_resp_err_t rd_kafka_offset_store(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);\nrd_kafka_resp_err_t rd_kafka_offsets_store(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets);\nrd_kafka_resp_err_t rd_kafka_subscribe(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *topics);\nrd_kafka_resp_err_t rd_kafka_unsubscribe(rd_kafka_t *rk);\nrd_kafka_resp_err_t rd_kafka_subscription(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **topics);\nrd_kafka_message_t *rd_kafka_consumer_poll(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_resp_err_t rd_kafka_consumer_close(rd_kafka_t *rk);\nrd_kafka_resp_err_t rd_kafka_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_resp_err_t rd_kafka_assignment(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **partitions);\nrd_kafka_resp_err_t rd_kafka_commit(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, int async);\nrd_kafka_resp_err_t rd_kafka_commit_message(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, int async);\nrd_kafka_resp_err_t rd_kafka_commit_queue(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_queue_t *rkqu, void (*cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *commit_opaque), void *commit_opaque);\nrd_kafka_resp_err_t rd_kafka_committed(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms);\nrd_kafka_resp_err_t rd_kafka_position(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata(rd_kafka_t *rk);\nrd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata_new(const char *group_id);\nvoid rd_kafka_consumer_group_metadata_destroy(rd_kafka_consumer_group_metadata_t *);\nrd_kafka_error_t *rd_kafka_consumer_group_metadata_write(const rd_kafka_consumer_group_metadata_t *cgmd, void **bufferp, size_t *sizep);\nrd_kafka_error_t *rd_kafka_consumer_group_metadata_read(rd_kafka_consumer_group_metadata_t **cgmdp, const void *buffer, size_t size);\nint rd_kafka_produce(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, void *payload, size_t len, const void *key, size_t keylen, void *msg_opaque);\nrd_kafka_resp_err_t rd_kafka_producev(rd_kafka_t *rk, ...);\nrd_kafka_error_t *rd_kafka_produceva(rd_kafka_t *rk, const rd_kafka_vu_t *vus, size_t cnt);\nint rd_kafka_produce_batch(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, rd_kafka_message_t *rkmessages, int message_cnt);\nrd_kafka_resp_err_t rd_kafka_flush(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_resp_err_t rd_kafka_purge(rd_kafka_t *rk, int purge_flags);\ntypedef struct rd_kafka_metadata_broker {\n  int32_t id;\n  char *host;\n  int port;\n} rd_kafka_metadata_broker_t;\ntypedef struct rd_kafka_metadata_partition {\n  int32_t id;\n  rd_kafka_resp_err_t err;\n  int32_t leader;\n  int replica_cnt;\n  int32_t *replicas;\n  int isr_cnt;\n  int32_t *isrs;\n} rd_kafka_metadata_partition_t;\ntypedef struct rd_kafka_metadata_topic {\n  char *topic;\n  int partition_cnt;\n  struct rd_kafka_metadata_partition *partitions;\n  rd_kafka_resp_err_t err;\n} rd_kafka_metadata_topic_t;\ntypedef struct rd_kafka_metadata {\n  int broker_cnt;\n  struct rd_kafka_metadata_broker *brokers;\n  int topic_cnt;\n  struct rd_kafka_metadata_topic *topics;\n  int32_t orig_broker_id;\n  char *orig_broker_name;\n} rd_kafka_metadata_t;\nrd_kafka_resp_err_t rd_kafka_metadata(rd_kafka_t *rk, int all_topics, rd_kafka_topic_t *only_rkt, const struct rd_kafka_metadata **metadatap, int timeout_ms);\nvoid rd_kafka_metadata_destroy(const struct rd_kafka_metadata *metadata);\nstruct rd_kafka_group_member_info {\n  char *member_id;\n  char *client_id;\n  char *client_host;\n  void *member_metadata;\n  int member_metadata_size;\n  void *member_assignment;\n  int member_assignment_size;\n};\nstruct rd_kafka_group_info {\n  struct rd_kafka_metadata_broker broker;\n  char *group;\n  rd_kafka_resp_err_t err;\n  char *state;\n  char *protocol_type;\n  char *protocol;\n  struct rd_kafka_group_member_info *members;\n  int member_cnt;\n};\nstruct rd_kafka_group_list {\n  struct rd_kafka_group_info *groups;\n  int group_cnt;\n};\nrd_kafka_resp_err_t rd_kafka_list_groups(rd_kafka_t *rk, const char *group, const struct rd_kafka_group_list **grplistp, int timeout_ms);\nvoid rd_kafka_group_list_destroy(const struct rd_kafka_group_list *grplist);\nint rd_kafka_brokers_add(rd_kafka_t *rk, const char *brokerlist);\nvoid rd_kafka_set_logger(rd_kafka_t *rk, void (*func)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));\nvoid rd_kafka_set_log_level(rd_kafka_t *rk, int level);\nvoid rd_kafka_log_print(const rd_kafka_t *rk, int level, const char *fac, const char *buf);\nvoid rd_kafka_log_syslog(const rd_kafka_t *rk, int level, const char *fac, const char *buf);\nint rd_kafka_outq_len(rd_kafka_t *rk);\nvoid rd_kafka_dump(FILE *fp, rd_kafka_t *rk);\nint rd_kafka_thread_cnt(void);\ntypedef enum rd_kafka_thread_type_t {\n  RD_KAFKA_THREAD_MAIN,\n  RD_KAFKA_THREAD_BACKGROUND,\n  RD_KAFKA_THREAD_BROKER,\n} rd_kafka_thread_type_t;\nint rd_kafka_wait_destroyed(int timeout_ms);\nint rd_kafka_unittest(void);\nrd_kafka_resp_err_t rd_kafka_poll_set_consumer(rd_kafka_t *rk);\ntypedef int rd_kafka_event_type_t;\nrd_kafka_event_type_t rd_kafka_event_type(const rd_kafka_event_t *rkev);\nconst char *rd_kafka_event_name(const rd_kafka_event_t *rkev);\nvoid rd_kafka_event_destroy(rd_kafka_event_t *rkev);\nconst rd_kafka_message_t *rd_kafka_event_message_next(rd_kafka_event_t *rkev);\nsize_t rd_kafka_event_message_array(rd_kafka_event_t *rkev, const rd_kafka_message_t **rkmessages, size_t size);\nsize_t rd_kafka_event_message_count(rd_kafka_event_t *rkev);\nconst char *rd_kafka_event_config_string(rd_kafka_event_t *rkev);\nrd_kafka_resp_err_t rd_kafka_event_error(rd_kafka_event_t *rkev);\nconst char *rd_kafka_event_error_string(rd_kafka_event_t *rkev);\nint rd_kafka_event_error_is_fatal(rd_kafka_event_t *rkev);\nvoid *rd_kafka_event_opaque(rd_kafka_event_t *rkev);\nint rd_kafka_event_log(rd_kafka_event_t *rkev, const char **fac, const char **str, int *level);\nint rd_kafka_event_debug_contexts(rd_kafka_event_t *rkev, char *dst, size_t dstsize);\nconst char *rd_kafka_event_stats(rd_kafka_event_t *rkev);\nrd_kafka_topic_partition_list_t *rd_kafka_event_topic_partition_list(rd_kafka_event_t *rkev);\nrd_kafka_topic_partition_t *rd_kafka_event_topic_partition(rd_kafka_event_t *rkev);\ntypedef rd_kafka_event_t rd_kafka_CreateTopics_result_t;\ntypedef rd_kafka_event_t rd_kafka_DeleteTopics_result_t;\ntypedef rd_kafka_event_t rd_kafka_CreatePartitions_result_t;\ntypedef rd_kafka_event_t rd_kafka_AlterConfigs_result_t;\ntypedef rd_kafka_event_t rd_kafka_DescribeConfigs_result_t;\nconst rd_kafka_CreateTopics_result_t *rd_kafka_event_CreateTopics_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DeleteTopics_result_t *rd_kafka_event_DeleteTopics_result(rd_kafka_event_t *rkev);\nconst rd_kafka_CreatePartitions_result_t *rd_kafka_event_CreatePartitions_result(rd_kafka_event_t *rkev);\nconst rd_kafka_AlterConfigs_result_t *rd_kafka_event_AlterConfigs_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DescribeConfigs_result_t *rd_kafka_event_DescribeConfigs_result(rd_kafka_event_t *rkev);\nrd_kafka_event_t *rd_kafka_queue_poll(rd_kafka_queue_t *rkqu, int timeout_ms);\nint rd_kafka_queue_poll_callback(rd_kafka_queue_t *rkqu, int timeout_ms);\ntypedef rd_kafka_resp_err_t (rd_kafka_plugin_f_conf_init_t)(rd_kafka_conf_t *conf, void **plug_opaquep, char *errstr, size_t errstr_size);\ntypedef rd_kafka_conf_res_t (rd_kafka_interceptor_f_on_conf_set_t)(rd_kafka_conf_t *conf, const char *name, const char *val, char *errstr, size_t errstr_size, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_dup_t)(rd_kafka_conf_t *new_conf, const rd_kafka_conf_t *old_conf, size_t filter_cnt, const char **filter, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_destroy_t)(void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_new_t)(rd_kafka_t *rk, const rd_kafka_conf_t *conf, void *ic_opaque, char *errstr, size_t errstr_size);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_destroy_t)(rd_kafka_t *rk, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_send_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_acknowledgement_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_consume_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_commit_t)(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_resp_err_t err, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_request_sent_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_start_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_exit_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_set(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_set_t *on_conf_set, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_dup(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_dup_t *on_conf_dup, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_destroy(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_destroy_t *on_conf_destroy, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_new(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_new_t *on_new, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_destroy(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_destroy_t *on_destroy, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_send(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_send_t *on_send, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_acknowledgement(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_acknowledgement_t *on_acknowledgement, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_consume(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_consume_t *on_consume, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_commit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_commit_t *on_commit, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_request_sent(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_request_sent_t *on_request_sent, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_start(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_start_t *on_thread_start, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_exit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_exit_t *on_thread_exit, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_topic_result_error(const rd_kafka_topic_result_t *topicres);\nconst char *rd_kafka_topic_result_error_string(const rd_kafka_topic_result_t *topicres);\nconst char *rd_kafka_topic_result_name(const rd_kafka_topic_result_t *topicres);\ntypedef enum rd_kafka_admin_op_t {\n  RD_KAFKA_ADMIN_OP_ANY = 0,\n  RD_KAFKA_ADMIN_OP_CREATETOPICS,\n  RD_KAFKA_ADMIN_OP_DELETETOPICS,\n  RD_KAFKA_ADMIN_OP_CREATEPARTITIONS,\n  RD_KAFKA_ADMIN_OP_ALTERCONFIGS,\n  RD_KAFKA_ADMIN_OP_DESCRIBECONFIGS,\n  RD_KAFKA_ADMIN_OP__CNT,\n} rd_kafka_admin_op_t;\ntypedef struct rd_kafka_AdminOptions_s rd_kafka_AdminOptions_t;\nrd_kafka_AdminOptions_t *rd_kafka_AdminOptions_new(rd_kafka_t *rk, rd_kafka_admin_op_t for_api);\nvoid rd_kafka_AdminOptions_destroy(rd_kafka_AdminOptions_t *options);\nrd_kafka_resp_err_t rd_kafka_AdminOptions_set_request_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_AdminOptions_set_operation_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_AdminOptions_set_validate_only(rd_kafka_AdminOptions_t *options, int true_or_false, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_AdminOptions_set_broker(rd_kafka_AdminOptions_t *options, int32_t broker_id, char *errstr, size_t errstr_size);\nvoid rd_kafka_AdminOptions_set_opaque(rd_kafka_AdminOptions_t *options, void *ev_opaque);\ntypedef struct rd_kafka_NewTopic_s rd_kafka_NewTopic_t;\nrd_kafka_NewTopic_t *rd_kafka_NewTopic_new(const char *topic, int num_partitions, int replication_factor, char *errstr, size_t errstr_size);\nvoid rd_kafka_NewTopic_destroy(rd_kafka_NewTopic_t *new_topic);\nvoid rd_kafka_NewTopic_destroy_array(rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt);\nrd_kafka_resp_err_t rd_kafka_NewTopic_set_replica_assignment(rd_kafka_NewTopic_t *new_topic, int32_t partition, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_NewTopic_set_config(rd_kafka_NewTopic_t *new_topic, const char *name, const char *value);\nvoid rd_kafka_CreateTopics(rd_kafka_t *rk, rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_topic_result_t **rd_kafka_CreateTopics_result_topics(const rd_kafka_CreateTopics_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_DeleteTopic_s rd_kafka_DeleteTopic_t;\nrd_kafka_DeleteTopic_t *rd_kafka_DeleteTopic_new(const char *topic);\nvoid rd_kafka_DeleteTopic_destroy(rd_kafka_DeleteTopic_t *del_topic);\nvoid rd_kafka_DeleteTopic_destroy_array(rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt);\nvoid rd_kafka_DeleteTopics(rd_kafka_t *rk, rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_topic_result_t **rd_kafka_DeleteTopics_result_topics(const rd_kafka_DeleteTopics_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_NewPartitions_s rd_kafka_NewPartitions_t;\nrd_kafka_NewPartitions_t *rd_kafka_NewPartitions_new(const char *topic, size_t new_total_cnt, char *errstr, size_t errstr_size);\nvoid rd_kafka_NewPartitions_destroy(rd_kafka_NewPartitions_t *new_parts);\nvoid rd_kafka_NewPartitions_destroy_array(rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt);\nrd_kafka_resp_err_t rd_kafka_NewPartitions_set_replica_assignment(rd_kafka_NewPartitions_t *new_parts, int32_t new_partition_idx, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);\nvoid rd_kafka_CreatePartitions(rd_kafka_t *rk, rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_topic_result_t **rd_kafka_CreatePartitions_result_topics(const rd_kafka_CreatePartitions_result_t *result, size_t *cntp);\ntypedef enum rd_kafka_ConfigSource_t {\n  RD_KAFKA_CONFIG_SOURCE_UNKNOWN_CONFIG = 0,\n  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_TOPIC_CONFIG = 1,\n  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_BROKER_CONFIG = 2,\n  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_DEFAULT_BROKER_CONFIG = 3,\n  RD_KAFKA_CONFIG_SOURCE_STATIC_BROKER_CONFIG = 4,\n  RD_KAFKA_CONFIG_SOURCE_DEFAULT_CONFIG = 5,\n  RD_KAFKA_CONFIG_SOURCE__CNT,\n} rd_kafka_ConfigSource_t;\nconst char *rd_kafka_ConfigSource_name(rd_kafka_ConfigSource_t confsource);\ntypedef struct rd_kafka_ConfigEntry_s rd_kafka_ConfigEntry_t;\nconst char *rd_kafka_ConfigEntry_name(const rd_kafka_ConfigEntry_t *entry);\nconst char *rd_kafka_ConfigEntry_value(const rd_kafka_ConfigEntry_t *entry);\nrd_kafka_ConfigSource_t rd_kafka_ConfigEntry_source(const rd_kafka_ConfigEntry_t *entry);\nint rd_kafka_ConfigEntry_is_read_only(const rd_kafka_ConfigEntry_t *entry);\nint rd_kafka_ConfigEntry_is_default(const rd_kafka_ConfigEntry_t *entry);\nint rd_kafka_ConfigEntry_is_sensitive(const rd_kafka_ConfigEntry_t *entry);\nint rd_kafka_ConfigEntry_is_synonym(const rd_kafka_ConfigEntry_t *entry);\nconst rd_kafka_ConfigEntry_t **rd_kafka_ConfigEntry_synonyms(const rd_kafka_ConfigEntry_t *entry, size_t *cntp);\ntypedef enum rd_kafka_ResourceType_t {\n  RD_KAFKA_RESOURCE_UNKNOWN = 0,\n  RD_KAFKA_RESOURCE_ANY = 1,\n  RD_KAFKA_RESOURCE_TOPIC = 2,\n  RD_KAFKA_RESOURCE_GROUP = 3,\n  RD_KAFKA_RESOURCE_BROKER = 4,\n  RD_KAFKA_RESOURCE__CNT,\n} rd_kafka_ResourceType_t;\nconst char *rd_kafka_ResourceType_name(rd_kafka_ResourceType_t restype);\ntypedef struct rd_kafka_ConfigResource_s rd_kafka_ConfigResource_t;\nrd_kafka_ConfigResource_t *rd_kafka_ConfigResource_new(rd_kafka_ResourceType_t restype, const char *resname);\nvoid rd_kafka_ConfigResource_destroy(rd_kafka_ConfigResource_t *config);\nvoid rd_kafka_ConfigResource_destroy_array(rd_kafka_ConfigResource_t **config, size_t config_cnt);\nrd_kafka_resp_err_t rd_kafka_ConfigResource_set_config(rd_kafka_ConfigResource_t *config, const char *name, const char *value);\nconst rd_kafka_ConfigEntry_t **rd_kafka_ConfigResource_configs(const rd_kafka_ConfigResource_t *config, size_t *cntp);\nrd_kafka_ResourceType_t rd_kafka_ConfigResource_type(const rd_kafka_ConfigResource_t *config);\nconst char *rd_kafka_ConfigResource_name(const rd_kafka_ConfigResource_t *config);\nrd_kafka_resp_err_t rd_kafka_ConfigResource_error(const rd_kafka_ConfigResource_t *config);\nconst char *rd_kafka_ConfigResource_error_string(const rd_kafka_ConfigResource_t *config);\nvoid rd_kafka_AlterConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_ConfigResource_t **rd_kafka_AlterConfigs_result_resources(const rd_kafka_AlterConfigs_result_t *result, size_t *cntp);\nvoid rd_kafka_DescribeConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_ConfigResource_t **rd_kafka_DescribeConfigs_result_resources(const rd_kafka_DescribeConfigs_result_t *result, size_t *cntp);\nrd_kafka_resp_err_t rd_kafka_oauthbearer_set_token(rd_kafka_t *rk, const char *token_value, int64_t md_lifetime_ms, const char *md_principal_name, const char **extensions, size_t extension_size, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_oauthbearer_set_token_failure(rd_kafka_t *rk, const char *errstr);\nrd_kafka_error_t *rd_kafka_init_transactions(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_error_t *rd_kafka_begin_transaction(rd_kafka_t *rk);\nrd_kafka_error_t *rd_kafka_send_offsets_to_transaction(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, const rd_kafka_consumer_group_metadata_t *cgmetadata, int timeout_ms);\nrd_kafka_error_t *rd_kafka_commit_transaction(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_error_t *rd_kafka_abort_transaction(rd_kafka_t *rk, int timeout_ms);\ntypedef struct rd_kafka_mock_cluster_s rd_kafka_mock_cluster_t;\nrd_kafka_mock_cluster_t *rd_kafka_mock_cluster_new(rd_kafka_t *rk, int broker_cnt);\nvoid rd_kafka_mock_cluster_destroy(rd_kafka_mock_cluster_t *mcluster);\nrd_kafka_t *rd_kafka_mock_cluster_handle(const rd_kafka_mock_cluster_t *mcluster);\nrd_kafka_mock_cluster_t *rd_kafka_handle_mock_cluster(const rd_kafka_t *rk);\nconst char *rd_kafka_mock_cluster_bootstraps(const rd_kafka_mock_cluster_t *mcluster);\nvoid rd_kafka_mock_push_request_errors(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, size_t cnt, ...);\nrd_kafka_resp_err_t rd_kafka_mock_broker_push_request_errors(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int16_t ApiKey, size_t cnt, ...);\nvoid rd_kafka_mock_topic_set_error(rd_kafka_mock_cluster_t *mcluster, const char *topic, rd_kafka_resp_err_t err);\nrd_kafka_resp_err_t rd_kafka_mock_topic_create(rd_kafka_mock_cluster_t *mcluster, const char *topic, int partition_cnt, int replication_factor);\nrd_kafka_resp_err_t rd_kafka_mock_partition_set_leader(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id);\nrd_kafka_resp_err_t rd_kafka_mock_partition_set_follower(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id);\nrd_kafka_resp_err_t rd_kafka_mock_partition_set_follower_wmarks(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int64_t lo, int64_t hi);\nrd_kafka_resp_err_t rd_kafka_mock_broker_set_down(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id);\nrd_kafka_resp_err_t rd_kafka_mock_broker_set_up(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id);\nrd_kafka_resp_err_t rd_kafka_mock_broker_set_rtt(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int rtt_ms);\nrd_kafka_resp_err_t rd_kafka_mock_broker_set_rack(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, const char *rack);\nrd_kafka_resp_err_t rd_kafka_mock_coordinator_set(rd_kafka_mock_cluster_t *mcluster, const char *key_type, const char *key, int32_t broker_id);\nrd_kafka_resp_err_t rd_kafka_mock_set_apiversion(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, int16_t MinVersion, int16_t MaxVersion);\n'\n</code></pre> rdkafka.h, rdkafka_mock.h</p>"},{"location":"api/constants/#rd_kafka_version_11","title":"RD_KAFKA_VERSION","text":"<pre><code>public RD_KAFKA_VERSION = 17105663\n</code></pre> <p>librdkafka version </p> <p>Interpreted as hex <code>MM.mm.rr.xx</code>:</p> <ul> <li>MM = Major</li> <li>mm = minor</li> <li>rr = revision</li> <li>xx = pre-release id (0xff is the final release)</li> </ul> <p>E.g.: <code>0x000801ff</code> = 0.8.1</p> RemarksThis value should only be used during compile time, for runtime checks of version use rd_kafka_version()  <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_unsupported_compression_type_11","title":"RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE","text":"<pre><code>public RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76\n</code></pre> <p>Unsupported compression type </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_end_all_11","title":"RD_KAFKA_RESP_ERR_END_ALL","text":"<p><pre><code>public RD_KAFKA_RESP_ERR_END_ALL = 89\n</code></pre> enum rd_kafka_resp_err_t</p>"},{"location":"api/constants/#rd_kafka_admin_op__cnt_11","title":"RD_KAFKA_ADMIN_OP__CNT","text":"<pre><code>public RD_KAFKA_ADMIN_OP__CNT = 6\n</code></pre> <p>Number of ops defined </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe </li> </ul>"},{"location":"api/constants/#rd_kafka_resource__cnt_11","title":"RD_KAFKA_RESOURCE__CNT","text":"<pre><code>public RD_KAFKA_RESOURCE__CNT = 5\n</code></pre> <p>Number of resource types defined </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#acca83a66d7783ff7683ed2691cc907c9 </li> </ul>"},{"location":"api/constants/#rd_kafka_cdef_11","title":"RD_KAFKA_CDEF","text":"<p><pre><code>public RD_KAFKA_CDEF = 'typedef long int ssize_t;\ntypedef struct _IO_FILE FILE;\ntypedef long int mode_t;\ntypedef signed int int16_t;\ntypedef unsigned int uint16_t;\ntypedef signed int int32_t;\ntypedef signed long int int64_t;\nint rd_kafka_version(void);\nconst char *rd_kafka_version_str(void);\ntypedef enum rd_kafka_type_t {\n  RD_KAFKA_PRODUCER,\n  RD_KAFKA_CONSUMER,\n} rd_kafka_type_t;\ntypedef enum rd_kafka_timestamp_type_t {\n  RD_KAFKA_TIMESTAMP_NOT_AVAILABLE,\n  RD_KAFKA_TIMESTAMP_CREATE_TIME,\n  RD_KAFKA_TIMESTAMP_LOG_APPEND_TIME,\n} rd_kafka_timestamp_type_t;\nconst char *rd_kafka_get_debug_contexts(void);\ntypedef struct rd_kafka_s rd_kafka_t;\ntypedef struct rd_kafka_topic_s rd_kafka_topic_t;\ntypedef struct rd_kafka_conf_s rd_kafka_conf_t;\ntypedef struct rd_kafka_topic_conf_s rd_kafka_topic_conf_t;\ntypedef struct rd_kafka_queue_s rd_kafka_queue_t;\ntypedef struct rd_kafka_op_s rd_kafka_event_t;\ntypedef struct rd_kafka_topic_result_s rd_kafka_topic_result_t;\ntypedef struct rd_kafka_consumer_group_metadata_s rd_kafka_consumer_group_metadata_t;\ntypedef struct rd_kafka_error_s {\n  unsigned int code;\n  char *errstr;\n  unsigned char fatal;\n  unsigned char retriable;\n  unsigned char txn_requires_abort;\n} rd_kafka_error_t;\ntypedef struct rd_kafka_headers_s rd_kafka_headers_t;\ntypedef enum {\n  RD_KAFKA_RESP_ERR__BEGIN = (- 200),\n  RD_KAFKA_RESP_ERR__BAD_MSG = (- 199),\n  RD_KAFKA_RESP_ERR__BAD_COMPRESSION = (- 198),\n  RD_KAFKA_RESP_ERR__DESTROY = (- 197),\n  RD_KAFKA_RESP_ERR__FAIL = (- 196),\n  RD_KAFKA_RESP_ERR__TRANSPORT = (- 195),\n  RD_KAFKA_RESP_ERR__CRIT_SYS_RESOURCE = (- 194),\n  RD_KAFKA_RESP_ERR__RESOLVE = (- 193),\n  RD_KAFKA_RESP_ERR__MSG_TIMED_OUT = (- 192),\n  RD_KAFKA_RESP_ERR__PARTITION_EOF = (- 191),\n  RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION = (- 190),\n  RD_KAFKA_RESP_ERR__FS = (- 189),\n  RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC = (- 188),\n  RD_KAFKA_RESP_ERR__ALL_BROKERS_DOWN = (- 187),\n  RD_KAFKA_RESP_ERR__INVALID_ARG = (- 186),\n  RD_KAFKA_RESP_ERR__TIMED_OUT = (- 185),\n  RD_KAFKA_RESP_ERR__QUEUE_FULL = (- 184),\n  RD_KAFKA_RESP_ERR__ISR_INSUFF = (- 183),\n  RD_KAFKA_RESP_ERR__NODE_UPDATE = (- 182),\n  RD_KAFKA_RESP_ERR__SSL = (- 181),\n  RD_KAFKA_RESP_ERR__WAIT_COORD = (- 180),\n  RD_KAFKA_RESP_ERR__UNKNOWN_GROUP = (- 179),\n  RD_KAFKA_RESP_ERR__IN_PROGRESS = (- 178),\n  RD_KAFKA_RESP_ERR__PREV_IN_PROGRESS = (- 177),\n  RD_KAFKA_RESP_ERR__EXISTING_SUBSCRIPTION = (- 176),\n  RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS = (- 175),\n  RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS = (- 174),\n  RD_KAFKA_RESP_ERR__CONFLICT = (- 173),\n  RD_KAFKA_RESP_ERR__STATE = (- 172),\n  RD_KAFKA_RESP_ERR__UNKNOWN_PROTOCOL = (- 171),\n  RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED = (- 170),\n  RD_KAFKA_RESP_ERR__AUTHENTICATION = (- 169),\n  RD_KAFKA_RESP_ERR__NO_OFFSET = (- 168),\n  RD_KAFKA_RESP_ERR__OUTDATED = (- 167),\n  RD_KAFKA_RESP_ERR__TIMED_OUT_QUEUE = (- 166),\n  RD_KAFKA_RESP_ERR__UNSUPPORTED_FEATURE = (- 165),\n  RD_KAFKA_RESP_ERR__WAIT_CACHE = (- 164),\n  RD_KAFKA_RESP_ERR__INTR = (- 163),\n  RD_KAFKA_RESP_ERR__KEY_SERIALIZATION = (- 162),\n  RD_KAFKA_RESP_ERR__VALUE_SERIALIZATION = (- 161),\n  RD_KAFKA_RESP_ERR__KEY_DESERIALIZATION = (- 160),\n  RD_KAFKA_RESP_ERR__VALUE_DESERIALIZATION = (- 159),\n  RD_KAFKA_RESP_ERR__PARTIAL = (- 158),\n  RD_KAFKA_RESP_ERR__READ_ONLY = (- 157),\n  RD_KAFKA_RESP_ERR__NOENT = (- 156),\n  RD_KAFKA_RESP_ERR__UNDERFLOW = (- 155),\n  RD_KAFKA_RESP_ERR__INVALID_TYPE = (- 154),\n  RD_KAFKA_RESP_ERR__RETRY = (- 153),\n  RD_KAFKA_RESP_ERR__PURGE_QUEUE = (- 152),\n  RD_KAFKA_RESP_ERR__PURGE_INFLIGHT = (- 151),\n  RD_KAFKA_RESP_ERR__FATAL = (- 150),\n  RD_KAFKA_RESP_ERR__INCONSISTENT = (- 149),\n  RD_KAFKA_RESP_ERR__GAPLESS_GUARANTEE = (- 148),\n  RD_KAFKA_RESP_ERR__MAX_POLL_EXCEEDED = (- 147),\n  RD_KAFKA_RESP_ERR__UNKNOWN_BROKER = (- 146),\n  RD_KAFKA_RESP_ERR__NOT_CONFIGURED = (- 145),\n  RD_KAFKA_RESP_ERR__FENCED = (- 144),\n  RD_KAFKA_RESP_ERR__APPLICATION = (- 143),\n  RD_KAFKA_RESP_ERR__END = (- 100),\n  RD_KAFKA_RESP_ERR_UNKNOWN = (- 1),\n  RD_KAFKA_RESP_ERR_NO_ERROR = 0,\n  RD_KAFKA_RESP_ERR_OFFSET_OUT_OF_RANGE = 1,\n  RD_KAFKA_RESP_ERR_INVALID_MSG = 2,\n  RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART = 3,\n  RD_KAFKA_RESP_ERR_INVALID_MSG_SIZE = 4,\n  RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE = 5,\n  RD_KAFKA_RESP_ERR_NOT_LEADER_FOR_PARTITION = 6,\n  RD_KAFKA_RESP_ERR_REQUEST_TIMED_OUT = 7,\n  RD_KAFKA_RESP_ERR_BROKER_NOT_AVAILABLE = 8,\n  RD_KAFKA_RESP_ERR_REPLICA_NOT_AVAILABLE = 9,\n  RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE = 10,\n  RD_KAFKA_RESP_ERR_STALE_CTRL_EPOCH = 11,\n  RD_KAFKA_RESP_ERR_OFFSET_METADATA_TOO_LARGE = 12,\n  RD_KAFKA_RESP_ERR_NETWORK_EXCEPTION = 13,\n  RD_KAFKA_RESP_ERR_COORDINATOR_LOAD_IN_PROGRESS = 14,\n  RD_KAFKA_RESP_ERR_COORDINATOR_NOT_AVAILABLE = 15,\n  RD_KAFKA_RESP_ERR_NOT_COORDINATOR = 16,\n  RD_KAFKA_RESP_ERR_TOPIC_EXCEPTION = 17,\n  RD_KAFKA_RESP_ERR_RECORD_LIST_TOO_LARGE = 18,\n  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS = 19,\n  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS_AFTER_APPEND = 20,\n  RD_KAFKA_RESP_ERR_INVALID_REQUIRED_ACKS = 21,\n  RD_KAFKA_RESP_ERR_ILLEGAL_GENERATION = 22,\n  RD_KAFKA_RESP_ERR_INCONSISTENT_GROUP_PROTOCOL = 23,\n  RD_KAFKA_RESP_ERR_INVALID_GROUP_ID = 24,\n  RD_KAFKA_RESP_ERR_UNKNOWN_MEMBER_ID = 25,\n  RD_KAFKA_RESP_ERR_INVALID_SESSION_TIMEOUT = 26,\n  RD_KAFKA_RESP_ERR_REBALANCE_IN_PROGRESS = 27,\n  RD_KAFKA_RESP_ERR_INVALID_COMMIT_OFFSET_SIZE = 28,\n  RD_KAFKA_RESP_ERR_TOPIC_AUTHORIZATION_FAILED = 29,\n  RD_KAFKA_RESP_ERR_GROUP_AUTHORIZATION_FAILED = 30,\n  RD_KAFKA_RESP_ERR_CLUSTER_AUTHORIZATION_FAILED = 31,\n  RD_KAFKA_RESP_ERR_INVALID_TIMESTAMP = 32,\n  RD_KAFKA_RESP_ERR_UNSUPPORTED_SASL_MECHANISM = 33,\n  RD_KAFKA_RESP_ERR_ILLEGAL_SASL_STATE = 34,\n  RD_KAFKA_RESP_ERR_UNSUPPORTED_VERSION = 35,\n  RD_KAFKA_RESP_ERR_TOPIC_ALREADY_EXISTS = 36,\n  RD_KAFKA_RESP_ERR_INVALID_PARTITIONS = 37,\n  RD_KAFKA_RESP_ERR_INVALID_REPLICATION_FACTOR = 38,\n  RD_KAFKA_RESP_ERR_INVALID_REPLICA_ASSIGNMENT = 39,\n  RD_KAFKA_RESP_ERR_INVALID_CONFIG = 40,\n  RD_KAFKA_RESP_ERR_NOT_CONTROLLER = 41,\n  RD_KAFKA_RESP_ERR_INVALID_REQUEST = 42,\n  RD_KAFKA_RESP_ERR_UNSUPPORTED_FOR_MESSAGE_FORMAT = 43,\n  RD_KAFKA_RESP_ERR_POLICY_VIOLATION = 44,\n  RD_KAFKA_RESP_ERR_OUT_OF_ORDER_SEQUENCE_NUMBER = 45,\n  RD_KAFKA_RESP_ERR_DUPLICATE_SEQUENCE_NUMBER = 46,\n  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_EPOCH = 47,\n  RD_KAFKA_RESP_ERR_INVALID_TXN_STATE = 48,\n  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_ID_MAPPING = 49,\n  RD_KAFKA_RESP_ERR_INVALID_TRANSACTION_TIMEOUT = 50,\n  RD_KAFKA_RESP_ERR_CONCURRENT_TRANSACTIONS = 51,\n  RD_KAFKA_RESP_ERR_TRANSACTION_COORDINATOR_FENCED = 52,\n  RD_KAFKA_RESP_ERR_TRANSACTIONAL_ID_AUTHORIZATION_FAILED = 53,\n  RD_KAFKA_RESP_ERR_SECURITY_DISABLED = 54,\n  RD_KAFKA_RESP_ERR_OPERATION_NOT_ATTEMPTED = 55,\n  RD_KAFKA_RESP_ERR_KAFKA_STORAGE_ERROR = 56,\n  RD_KAFKA_RESP_ERR_LOG_DIR_NOT_FOUND = 57,\n  RD_KAFKA_RESP_ERR_SASL_AUTHENTICATION_FAILED = 58,\n  RD_KAFKA_RESP_ERR_UNKNOWN_PRODUCER_ID = 59,\n  RD_KAFKA_RESP_ERR_REASSIGNMENT_IN_PROGRESS = 60,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTH_DISABLED = 61,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_NOT_FOUND = 62,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_OWNER_MISMATCH = 63,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_REQUEST_NOT_ALLOWED = 64,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTHORIZATION_FAILED = 65,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_EXPIRED = 66,\n  RD_KAFKA_RESP_ERR_INVALID_PRINCIPAL_TYPE = 67,\n  RD_KAFKA_RESP_ERR_NON_EMPTY_GROUP = 68,\n  RD_KAFKA_RESP_ERR_GROUP_ID_NOT_FOUND = 69,\n  RD_KAFKA_RESP_ERR_FETCH_SESSION_ID_NOT_FOUND = 70,\n  RD_KAFKA_RESP_ERR_INVALID_FETCH_SESSION_EPOCH = 71,\n  RD_KAFKA_RESP_ERR_LISTENER_NOT_FOUND = 72,\n  RD_KAFKA_RESP_ERR_TOPIC_DELETION_DISABLED = 73,\n  RD_KAFKA_RESP_ERR_FENCED_LEADER_EPOCH = 74,\n  RD_KAFKA_RESP_ERR_UNKNOWN_LEADER_EPOCH = 75,\n  RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76,\n  RD_KAFKA_RESP_ERR_STALE_BROKER_EPOCH = 77,\n  RD_KAFKA_RESP_ERR_OFFSET_NOT_AVAILABLE = 78,\n  RD_KAFKA_RESP_ERR_MEMBER_ID_REQUIRED = 79,\n  RD_KAFKA_RESP_ERR_PREFERRED_LEADER_NOT_AVAILABLE = 80,\n  RD_KAFKA_RESP_ERR_GROUP_MAX_SIZE_REACHED = 81,\n  RD_KAFKA_RESP_ERR_FENCED_INSTANCE_ID = 82,\n  RD_KAFKA_RESP_ERR_ELIGIBLE_LEADERS_NOT_AVAILABLE = 83,\n  RD_KAFKA_RESP_ERR_ELECTION_NOT_NEEDED = 84,\n  RD_KAFKA_RESP_ERR_NO_REASSIGNMENT_IN_PROGRESS = 85,\n  RD_KAFKA_RESP_ERR_GROUP_SUBSCRIBED_TO_TOPIC = 86,\n  RD_KAFKA_RESP_ERR_INVALID_RECORD = 87,\n  RD_KAFKA_RESP_ERR_UNSTABLE_OFFSET_COMMIT = 88,\n  RD_KAFKA_RESP_ERR_END_ALL,\n} rd_kafka_resp_err_t;\nstruct rd_kafka_err_desc {\n  rd_kafka_resp_err_t code;\n  char *name;\n  char *desc;\n};\nvoid rd_kafka_get_err_descs(const struct rd_kafka_err_desc **errdescs, size_t *cntp);\nconst char *rd_kafka_err2str(rd_kafka_resp_err_t err);\nconst char *rd_kafka_err2name(rd_kafka_resp_err_t err);\nrd_kafka_resp_err_t rd_kafka_last_error(void);\nrd_kafka_resp_err_t rd_kafka_errno2err(int errnox);\nint rd_kafka_errno(void);\nrd_kafka_resp_err_t rd_kafka_fatal_error(rd_kafka_t *rk, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_test_fatal_error(rd_kafka_t *rk, rd_kafka_resp_err_t err, const char *reason);\nrd_kafka_resp_err_t rd_kafka_error_code(const rd_kafka_error_t *error);\nconst char *rd_kafka_error_name(const rd_kafka_error_t *error);\nconst char *rd_kafka_error_string(const rd_kafka_error_t *error);\nint rd_kafka_error_is_fatal(const rd_kafka_error_t *error);\nint rd_kafka_error_is_retriable(const rd_kafka_error_t *error);\nint rd_kafka_error_txn_requires_abort(const rd_kafka_error_t *error);\nvoid rd_kafka_error_destroy(rd_kafka_error_t *error);\nrd_kafka_error_t *rd_kafka_error_new(rd_kafka_resp_err_t code, const char *fmt, ...);\ntypedef struct rd_kafka_topic_partition_s {\n  char *topic;\n  int32_t partition;\n  int64_t offset;\n  void *metadata;\n  size_t metadata_size;\n  void *opaque;\n  rd_kafka_resp_err_t err;\n  void *_private;\n} rd_kafka_topic_partition_t;\nvoid rd_kafka_topic_partition_destroy(rd_kafka_topic_partition_t *rktpar);\ntypedef struct rd_kafka_topic_partition_list_s {\n  int cnt;\n  int size;\n  rd_kafka_topic_partition_t *elems;\n} rd_kafka_topic_partition_list_t;\nrd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_new(int size);\nvoid rd_kafka_topic_partition_list_destroy(rd_kafka_topic_partition_list_t *rkparlist);\nrd_kafka_topic_partition_t *rd_kafka_topic_partition_list_add(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);\nvoid rd_kafka_topic_partition_list_add_range(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t start, int32_t stop);\nint rd_kafka_topic_partition_list_del(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);\nint rd_kafka_topic_partition_list_del_by_idx(rd_kafka_topic_partition_list_t *rktparlist, int idx);\nrd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_copy(const rd_kafka_topic_partition_list_t *src);\nrd_kafka_resp_err_t rd_kafka_topic_partition_list_set_offset(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition, int64_t offset);\nrd_kafka_topic_partition_t *rd_kafka_topic_partition_list_find(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);\nvoid rd_kafka_topic_partition_list_sort(rd_kafka_topic_partition_list_t *rktparlist, int (*cmp)(const void *a, const void *b, void *cmp_opaque), void *cmp_opaque);\ntypedef enum rd_kafka_vtype_t {\n  RD_KAFKA_VTYPE_END,\n  RD_KAFKA_VTYPE_TOPIC,\n  RD_KAFKA_VTYPE_RKT,\n  RD_KAFKA_VTYPE_PARTITION,\n  RD_KAFKA_VTYPE_VALUE,\n  RD_KAFKA_VTYPE_KEY,\n  RD_KAFKA_VTYPE_OPAQUE,\n  RD_KAFKA_VTYPE_MSGFLAGS,\n  RD_KAFKA_VTYPE_TIMESTAMP,\n  RD_KAFKA_VTYPE_HEADER,\n  RD_KAFKA_VTYPE_HEADERS,\n} rd_kafka_vtype_t;\ntypedef struct rd_kafka_vu_s {\n  rd_kafka_vtype_t vtype;\n  union {\n    char *cstr;\n    rd_kafka_topic_t *rkt;\n    int i;\n    int32_t i32;\n    int64_t i64;\n    struct {\n      void *ptr;\n      size_t size;\n    } mem;\n    struct {\n      char *name;\n      void *val;\n      ssize_t size;\n    } header;\n    rd_kafka_headers_t *headers;\n    void *ptr;\n    char _pad[64];\n  } u;\n} rd_kafka_vu_t;\nrd_kafka_headers_t *rd_kafka_headers_new(size_t initial_count);\nvoid rd_kafka_headers_destroy(rd_kafka_headers_t *hdrs);\nrd_kafka_headers_t *rd_kafka_headers_copy(const rd_kafka_headers_t *src);\nrd_kafka_resp_err_t rd_kafka_header_add(rd_kafka_headers_t *hdrs, const char *name, ssize_t name_size, const void *value, ssize_t value_size);\nrd_kafka_resp_err_t rd_kafka_header_remove(rd_kafka_headers_t *hdrs, const char *name);\nrd_kafka_resp_err_t rd_kafka_header_get_last(const rd_kafka_headers_t *hdrs, const char *name, const void **valuep, size_t *sizep);\nrd_kafka_resp_err_t rd_kafka_header_get(const rd_kafka_headers_t *hdrs, size_t idx, const char *name, const void **valuep, size_t *sizep);\nrd_kafka_resp_err_t rd_kafka_header_get_all(const rd_kafka_headers_t *hdrs, size_t idx, const char **namep, const void **valuep, size_t *sizep);\ntypedef struct rd_kafka_message_s {\n  rd_kafka_resp_err_t err;\n  rd_kafka_topic_t *rkt;\n  int32_t partition;\n  void *payload;\n  size_t len;\n  void *key;\n  size_t key_len;\n  int64_t offset;\n  void *_private;\n} rd_kafka_message_t;\nvoid rd_kafka_message_destroy(rd_kafka_message_t *rkmessage);\nconst char *rd_kafka_message_errstr(const rd_kafka_message_t *rkmessage);\nint64_t rd_kafka_message_timestamp(const rd_kafka_message_t *rkmessage, rd_kafka_timestamp_type_t *tstype);\nint64_t rd_kafka_message_latency(const rd_kafka_message_t *rkmessage);\nint32_t rd_kafka_message_broker_id(const rd_kafka_message_t *rkmessage);\nrd_kafka_resp_err_t rd_kafka_message_headers(const rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);\nrd_kafka_resp_err_t rd_kafka_message_detach_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);\nvoid rd_kafka_message_set_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t *hdrs);\nsize_t rd_kafka_header_cnt(const rd_kafka_headers_t *hdrs);\ntypedef enum {\n  RD_KAFKA_MSG_STATUS_NOT_PERSISTED = 0,\n  RD_KAFKA_MSG_STATUS_POSSIBLY_PERSISTED = 1,\n  RD_KAFKA_MSG_STATUS_PERSISTED = 2,\n} rd_kafka_msg_status_t;\nrd_kafka_msg_status_t rd_kafka_message_status(const rd_kafka_message_t *rkmessage);\ntypedef enum {\n  RD_KAFKA_CONF_UNKNOWN = (- 2),\n  RD_KAFKA_CONF_INVALID = (- 1),\n  RD_KAFKA_CONF_OK = 0,\n} rd_kafka_conf_res_t;\nrd_kafka_conf_t *rd_kafka_conf_new(void);\nvoid rd_kafka_conf_destroy(rd_kafka_conf_t *conf);\nrd_kafka_conf_t *rd_kafka_conf_dup(const rd_kafka_conf_t *conf);\nrd_kafka_conf_t *rd_kafka_conf_dup_filter(const rd_kafka_conf_t *conf, size_t filter_cnt, const char **filter);\nconst rd_kafka_conf_t *rd_kafka_conf(rd_kafka_t *rk);\nrd_kafka_conf_res_t rd_kafka_conf_set(rd_kafka_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);\nvoid rd_kafka_conf_set_events(rd_kafka_conf_t *conf, int events);\nvoid rd_kafka_conf_set_background_event_cb(rd_kafka_conf_t *conf, void (*event_cb)(rd_kafka_t *rk, rd_kafka_event_t *rkev, void *opaque));\nvoid rd_kafka_conf_set_dr_cb(rd_kafka_conf_t *conf, void (*dr_cb)(rd_kafka_t *rk, void *payload, size_t len, rd_kafka_resp_err_t err, void *opaque, void *msg_opaque));\nvoid rd_kafka_conf_set_dr_msg_cb(rd_kafka_conf_t *conf, void (*dr_msg_cb)(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, void *opaque));\nvoid rd_kafka_conf_set_consume_cb(rd_kafka_conf_t *conf, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *opaque));\nvoid rd_kafka_conf_set_rebalance_cb(rd_kafka_conf_t *conf, void (*rebalance_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *partitions, void *opaque));\nvoid rd_kafka_conf_set_offset_commit_cb(rd_kafka_conf_t *conf, void (*offset_commit_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *opaque));\nvoid rd_kafka_conf_set_error_cb(rd_kafka_conf_t *conf, void (*error_cb)(rd_kafka_t *rk, int err, const char *reason, void *opaque));\nvoid rd_kafka_conf_set_throttle_cb(rd_kafka_conf_t *conf, void (*throttle_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int throttle_time_ms, void *opaque));\nvoid rd_kafka_conf_set_log_cb(rd_kafka_conf_t *conf, void (*log_cb)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));\nvoid rd_kafka_conf_set_stats_cb(rd_kafka_conf_t *conf, int (*stats_cb)(rd_kafka_t *rk, char *json, size_t json_len, void *opaque));\nvoid rd_kafka_conf_set_oauthbearer_token_refresh_cb(rd_kafka_conf_t *conf, void (*oauthbearer_token_refresh_cb)(rd_kafka_t *rk, const char *oauthbearer_config, void *opaque));\nvoid rd_kafka_conf_set_socket_cb(rd_kafka_conf_t *conf, int (*socket_cb)(int domain, int type, int protocol, void *opaque));\nvoid rd_kafka_conf_set_connect_cb(rd_kafka_conf_t *conf, int (*connect_cb)(int sockfd, const struct sockaddr *addr, int addrlen, const char *id, void *opaque));\nvoid rd_kafka_conf_set_closesocket_cb(rd_kafka_conf_t *conf, int (*closesocket_cb)(int sockfd, void *opaque));\nrd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert_verify_cb(rd_kafka_conf_t *conf, int (*ssl_cert_verify_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int *x509_error, int depth, const char *buf, size_t size, char *errstr, size_t errstr_size, void *opaque));\ntypedef enum rd_kafka_cert_type_t {\n  RD_KAFKA_CERT_PUBLIC_KEY,\n  RD_KAFKA_CERT_PRIVATE_KEY,\n  RD_KAFKA_CERT_CA,\n  RD_KAFKA_CERT__CNT,\n} rd_kafka_cert_type_t;\ntypedef enum rd_kafka_cert_enc_t {\n  RD_KAFKA_CERT_ENC_PKCS12,\n  RD_KAFKA_CERT_ENC_DER,\n  RD_KAFKA_CERT_ENC_PEM,\n  RD_KAFKA_CERT_ENC__CNT,\n} rd_kafka_cert_enc_t;\nrd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert(rd_kafka_conf_t *conf, rd_kafka_cert_type_t cert_type, rd_kafka_cert_enc_t cert_enc, const void *buffer, size_t size, char *errstr, size_t errstr_size);\nvoid rd_kafka_conf_set_opaque(rd_kafka_conf_t *conf, void *opaque);\nvoid *rd_kafka_opaque(const rd_kafka_t *rk);\nvoid rd_kafka_conf_set_default_topic_conf(rd_kafka_conf_t *conf, rd_kafka_topic_conf_t *tconf);\nrd_kafka_conf_res_t rd_kafka_conf_get(const rd_kafka_conf_t *conf, const char *name, char *dest, size_t *dest_size);\nrd_kafka_conf_res_t rd_kafka_topic_conf_get(const rd_kafka_topic_conf_t *conf, const char *name, char *dest, size_t *dest_size);\nconst char **rd_kafka_conf_dump(rd_kafka_conf_t *conf, size_t *cntp);\nconst char **rd_kafka_topic_conf_dump(rd_kafka_topic_conf_t *conf, size_t *cntp);\nvoid rd_kafka_conf_dump_free(const char **arr, size_t cnt);\nvoid rd_kafka_conf_properties_show(FILE *fp);\nrd_kafka_topic_conf_t *rd_kafka_topic_conf_new(void);\nrd_kafka_topic_conf_t *rd_kafka_topic_conf_dup(const rd_kafka_topic_conf_t *conf);\nrd_kafka_topic_conf_t *rd_kafka_default_topic_conf_dup(rd_kafka_t *rk);\nvoid rd_kafka_topic_conf_destroy(rd_kafka_topic_conf_t *topic_conf);\nrd_kafka_conf_res_t rd_kafka_topic_conf_set(rd_kafka_topic_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);\nvoid rd_kafka_topic_conf_set_opaque(rd_kafka_topic_conf_t *conf, void *rkt_opaque);\nvoid rd_kafka_topic_conf_set_partitioner_cb(rd_kafka_topic_conf_t *topic_conf, int32_t (*partitioner)(const rd_kafka_topic_t *rkt, const void *keydata, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque));\nvoid rd_kafka_topic_conf_set_msg_order_cmp(rd_kafka_topic_conf_t *topic_conf, int (*msg_order_cmp)(const rd_kafka_message_t *a, const rd_kafka_message_t *b));\nint rd_kafka_topic_partition_available(const rd_kafka_topic_t *rkt, int32_t partition);\nint32_t rd_kafka_msg_partitioner_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_consistent(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_consistent_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_murmur2(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_murmur2_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_fnv1a(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_fnv1a_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nrd_kafka_t *rd_kafka_new(rd_kafka_type_t type, rd_kafka_conf_t *conf, char *errstr, size_t errstr_size);\nvoid rd_kafka_destroy(rd_kafka_t *rk);\nvoid rd_kafka_destroy_flags(rd_kafka_t *rk, int flags);\nconst char *rd_kafka_name(const rd_kafka_t *rk);\nrd_kafka_type_t rd_kafka_type(const rd_kafka_t *rk);\nchar *rd_kafka_memberid(const rd_kafka_t *rk);\nchar *rd_kafka_clusterid(rd_kafka_t *rk, int timeout_ms);\nint32_t rd_kafka_controllerid(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_topic_t *rd_kafka_topic_new(rd_kafka_t *rk, const char *topic, rd_kafka_topic_conf_t *conf);\nvoid rd_kafka_topic_destroy(rd_kafka_topic_t *rkt);\nconst char *rd_kafka_topic_name(const rd_kafka_topic_t *rkt);\nvoid *rd_kafka_topic_opaque(const rd_kafka_topic_t *rkt);\nint rd_kafka_poll(rd_kafka_t *rk, int timeout_ms);\nvoid rd_kafka_yield(rd_kafka_t *rk);\nrd_kafka_resp_err_t rd_kafka_pause_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_resp_err_t rd_kafka_resume_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_resp_err_t rd_kafka_query_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high, int timeout_ms);\nrd_kafka_resp_err_t rd_kafka_get_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high);\nrd_kafka_resp_err_t rd_kafka_offsets_for_times(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets, int timeout_ms);\nvoid rd_kafka_mem_free(rd_kafka_t *rk, void *ptr);\nrd_kafka_queue_t *rd_kafka_queue_new(rd_kafka_t *rk);\nvoid rd_kafka_queue_destroy(rd_kafka_queue_t *rkqu);\nrd_kafka_queue_t *rd_kafka_queue_get_main(rd_kafka_t *rk);\nrd_kafka_queue_t *rd_kafka_queue_get_consumer(rd_kafka_t *rk);\nrd_kafka_queue_t *rd_kafka_queue_get_partition(rd_kafka_t *rk, const char *topic, int32_t partition);\nrd_kafka_queue_t *rd_kafka_queue_get_background(rd_kafka_t *rk);\nvoid rd_kafka_queue_forward(rd_kafka_queue_t *src, rd_kafka_queue_t *dst);\nrd_kafka_resp_err_t rd_kafka_set_log_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu);\nsize_t rd_kafka_queue_length(rd_kafka_queue_t *rkqu);\nvoid rd_kafka_queue_io_event_enable(rd_kafka_queue_t *rkqu, int fd, const void *payload, size_t size);\nvoid rd_kafka_queue_cb_event_enable(rd_kafka_queue_t *rkqu, void (*event_cb)(rd_kafka_t *rk, void *qev_opaque), void *qev_opaque);\nint rd_kafka_consume_start(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);\nint rd_kafka_consume_start_queue(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, rd_kafka_queue_t *rkqu);\nint rd_kafka_consume_stop(rd_kafka_topic_t *rkt, int32_t partition);\nrd_kafka_resp_err_t rd_kafka_seek(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, int timeout_ms);\nrd_kafka_message_t *rd_kafka_consume(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms);\nssize_t rd_kafka_consume_batch(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);\nint rd_kafka_consume_callback(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);\nrd_kafka_message_t *rd_kafka_consume_queue(rd_kafka_queue_t *rkqu, int timeout_ms);\nssize_t rd_kafka_consume_batch_queue(rd_kafka_queue_t *rkqu, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);\nint rd_kafka_consume_callback_queue(rd_kafka_queue_t *rkqu, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);\nrd_kafka_resp_err_t rd_kafka_offset_store(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);\nrd_kafka_resp_err_t rd_kafka_offsets_store(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets);\nrd_kafka_resp_err_t rd_kafka_subscribe(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *topics);\nrd_kafka_resp_err_t rd_kafka_unsubscribe(rd_kafka_t *rk);\nrd_kafka_resp_err_t rd_kafka_subscription(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **topics);\nrd_kafka_message_t *rd_kafka_consumer_poll(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_resp_err_t rd_kafka_consumer_close(rd_kafka_t *rk);\nrd_kafka_resp_err_t rd_kafka_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_resp_err_t rd_kafka_assignment(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **partitions);\nrd_kafka_resp_err_t rd_kafka_commit(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, int async);\nrd_kafka_resp_err_t rd_kafka_commit_message(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, int async);\nrd_kafka_resp_err_t rd_kafka_commit_queue(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_queue_t *rkqu, void (*cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *commit_opaque), void *commit_opaque);\nrd_kafka_resp_err_t rd_kafka_committed(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms);\nrd_kafka_resp_err_t rd_kafka_position(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata(rd_kafka_t *rk);\nrd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata_new(const char *group_id);\nvoid rd_kafka_consumer_group_metadata_destroy(rd_kafka_consumer_group_metadata_t *);\nrd_kafka_error_t *rd_kafka_consumer_group_metadata_write(const rd_kafka_consumer_group_metadata_t *cgmd, void **bufferp, size_t *sizep);\nrd_kafka_error_t *rd_kafka_consumer_group_metadata_read(rd_kafka_consumer_group_metadata_t **cgmdp, const void *buffer, size_t size);\nint rd_kafka_produce(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, void *payload, size_t len, const void *key, size_t keylen, void *msg_opaque);\nrd_kafka_resp_err_t rd_kafka_producev(rd_kafka_t *rk, ...);\nrd_kafka_error_t *rd_kafka_produceva(rd_kafka_t *rk, const rd_kafka_vu_t *vus, size_t cnt);\nint rd_kafka_produce_batch(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, rd_kafka_message_t *rkmessages, int message_cnt);\nrd_kafka_resp_err_t rd_kafka_flush(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_resp_err_t rd_kafka_purge(rd_kafka_t *rk, int purge_flags);\ntypedef struct rd_kafka_metadata_broker {\n  int32_t id;\n  char *host;\n  int port;\n} rd_kafka_metadata_broker_t;\ntypedef struct rd_kafka_metadata_partition {\n  int32_t id;\n  rd_kafka_resp_err_t err;\n  int32_t leader;\n  int replica_cnt;\n  int32_t *replicas;\n  int isr_cnt;\n  int32_t *isrs;\n} rd_kafka_metadata_partition_t;\ntypedef struct rd_kafka_metadata_topic {\n  char *topic;\n  int partition_cnt;\n  struct rd_kafka_metadata_partition *partitions;\n  rd_kafka_resp_err_t err;\n} rd_kafka_metadata_topic_t;\ntypedef struct rd_kafka_metadata {\n  int broker_cnt;\n  struct rd_kafka_metadata_broker *brokers;\n  int topic_cnt;\n  struct rd_kafka_metadata_topic *topics;\n  int32_t orig_broker_id;\n  char *orig_broker_name;\n} rd_kafka_metadata_t;\nrd_kafka_resp_err_t rd_kafka_metadata(rd_kafka_t *rk, int all_topics, rd_kafka_topic_t *only_rkt, const struct rd_kafka_metadata **metadatap, int timeout_ms);\nvoid rd_kafka_metadata_destroy(const struct rd_kafka_metadata *metadata);\nstruct rd_kafka_group_member_info {\n  char *member_id;\n  char *client_id;\n  char *client_host;\n  void *member_metadata;\n  int member_metadata_size;\n  void *member_assignment;\n  int member_assignment_size;\n};\nstruct rd_kafka_group_info {\n  struct rd_kafka_metadata_broker broker;\n  char *group;\n  rd_kafka_resp_err_t err;\n  char *state;\n  char *protocol_type;\n  char *protocol;\n  struct rd_kafka_group_member_info *members;\n  int member_cnt;\n};\nstruct rd_kafka_group_list {\n  struct rd_kafka_group_info *groups;\n  int group_cnt;\n};\nrd_kafka_resp_err_t rd_kafka_list_groups(rd_kafka_t *rk, const char *group, const struct rd_kafka_group_list **grplistp, int timeout_ms);\nvoid rd_kafka_group_list_destroy(const struct rd_kafka_group_list *grplist);\nint rd_kafka_brokers_add(rd_kafka_t *rk, const char *brokerlist);\nvoid rd_kafka_set_logger(rd_kafka_t *rk, void (*func)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));\nvoid rd_kafka_set_log_level(rd_kafka_t *rk, int level);\nvoid rd_kafka_log_print(const rd_kafka_t *rk, int level, const char *fac, const char *buf);\nvoid rd_kafka_log_syslog(const rd_kafka_t *rk, int level, const char *fac, const char *buf);\nint rd_kafka_outq_len(rd_kafka_t *rk);\nvoid rd_kafka_dump(FILE *fp, rd_kafka_t *rk);\nint rd_kafka_thread_cnt(void);\ntypedef enum rd_kafka_thread_type_t {\n  RD_KAFKA_THREAD_MAIN,\n  RD_KAFKA_THREAD_BACKGROUND,\n  RD_KAFKA_THREAD_BROKER,\n} rd_kafka_thread_type_t;\nint rd_kafka_wait_destroyed(int timeout_ms);\nint rd_kafka_unittest(void);\nrd_kafka_resp_err_t rd_kafka_poll_set_consumer(rd_kafka_t *rk);\ntypedef int rd_kafka_event_type_t;\nrd_kafka_event_type_t rd_kafka_event_type(const rd_kafka_event_t *rkev);\nconst char *rd_kafka_event_name(const rd_kafka_event_t *rkev);\nvoid rd_kafka_event_destroy(rd_kafka_event_t *rkev);\nconst rd_kafka_message_t *rd_kafka_event_message_next(rd_kafka_event_t *rkev);\nsize_t rd_kafka_event_message_array(rd_kafka_event_t *rkev, const rd_kafka_message_t **rkmessages, size_t size);\nsize_t rd_kafka_event_message_count(rd_kafka_event_t *rkev);\nconst char *rd_kafka_event_config_string(rd_kafka_event_t *rkev);\nrd_kafka_resp_err_t rd_kafka_event_error(rd_kafka_event_t *rkev);\nconst char *rd_kafka_event_error_string(rd_kafka_event_t *rkev);\nint rd_kafka_event_error_is_fatal(rd_kafka_event_t *rkev);\nvoid *rd_kafka_event_opaque(rd_kafka_event_t *rkev);\nint rd_kafka_event_log(rd_kafka_event_t *rkev, const char **fac, const char **str, int *level);\nint rd_kafka_event_debug_contexts(rd_kafka_event_t *rkev, char *dst, size_t dstsize);\nconst char *rd_kafka_event_stats(rd_kafka_event_t *rkev);\nrd_kafka_topic_partition_list_t *rd_kafka_event_topic_partition_list(rd_kafka_event_t *rkev);\nrd_kafka_topic_partition_t *rd_kafka_event_topic_partition(rd_kafka_event_t *rkev);\ntypedef rd_kafka_event_t rd_kafka_CreateTopics_result_t;\ntypedef rd_kafka_event_t rd_kafka_DeleteTopics_result_t;\ntypedef rd_kafka_event_t rd_kafka_CreatePartitions_result_t;\ntypedef rd_kafka_event_t rd_kafka_AlterConfigs_result_t;\ntypedef rd_kafka_event_t rd_kafka_DescribeConfigs_result_t;\nconst rd_kafka_CreateTopics_result_t *rd_kafka_event_CreateTopics_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DeleteTopics_result_t *rd_kafka_event_DeleteTopics_result(rd_kafka_event_t *rkev);\nconst rd_kafka_CreatePartitions_result_t *rd_kafka_event_CreatePartitions_result(rd_kafka_event_t *rkev);\nconst rd_kafka_AlterConfigs_result_t *rd_kafka_event_AlterConfigs_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DescribeConfigs_result_t *rd_kafka_event_DescribeConfigs_result(rd_kafka_event_t *rkev);\nrd_kafka_event_t *rd_kafka_queue_poll(rd_kafka_queue_t *rkqu, int timeout_ms);\nint rd_kafka_queue_poll_callback(rd_kafka_queue_t *rkqu, int timeout_ms);\ntypedef rd_kafka_resp_err_t (rd_kafka_plugin_f_conf_init_t)(rd_kafka_conf_t *conf, void **plug_opaquep, char *errstr, size_t errstr_size);\ntypedef rd_kafka_conf_res_t (rd_kafka_interceptor_f_on_conf_set_t)(rd_kafka_conf_t *conf, const char *name, const char *val, char *errstr, size_t errstr_size, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_dup_t)(rd_kafka_conf_t *new_conf, const rd_kafka_conf_t *old_conf, size_t filter_cnt, const char **filter, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_destroy_t)(void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_new_t)(rd_kafka_t *rk, const rd_kafka_conf_t *conf, void *ic_opaque, char *errstr, size_t errstr_size);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_destroy_t)(rd_kafka_t *rk, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_send_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_acknowledgement_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_consume_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_commit_t)(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_resp_err_t err, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_request_sent_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_start_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_exit_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_set(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_set_t *on_conf_set, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_dup(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_dup_t *on_conf_dup, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_destroy(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_destroy_t *on_conf_destroy, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_new(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_new_t *on_new, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_destroy(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_destroy_t *on_destroy, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_send(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_send_t *on_send, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_acknowledgement(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_acknowledgement_t *on_acknowledgement, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_consume(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_consume_t *on_consume, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_commit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_commit_t *on_commit, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_request_sent(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_request_sent_t *on_request_sent, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_start(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_start_t *on_thread_start, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_exit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_exit_t *on_thread_exit, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_topic_result_error(const rd_kafka_topic_result_t *topicres);\nconst char *rd_kafka_topic_result_error_string(const rd_kafka_topic_result_t *topicres);\nconst char *rd_kafka_topic_result_name(const rd_kafka_topic_result_t *topicres);\ntypedef enum rd_kafka_admin_op_t {\n  RD_KAFKA_ADMIN_OP_ANY = 0,\n  RD_KAFKA_ADMIN_OP_CREATETOPICS,\n  RD_KAFKA_ADMIN_OP_DELETETOPICS,\n  RD_KAFKA_ADMIN_OP_CREATEPARTITIONS,\n  RD_KAFKA_ADMIN_OP_ALTERCONFIGS,\n  RD_KAFKA_ADMIN_OP_DESCRIBECONFIGS,\n  RD_KAFKA_ADMIN_OP__CNT,\n} rd_kafka_admin_op_t;\ntypedef struct rd_kafka_AdminOptions_s rd_kafka_AdminOptions_t;\nrd_kafka_AdminOptions_t *rd_kafka_AdminOptions_new(rd_kafka_t *rk, rd_kafka_admin_op_t for_api);\nvoid rd_kafka_AdminOptions_destroy(rd_kafka_AdminOptions_t *options);\nrd_kafka_resp_err_t rd_kafka_AdminOptions_set_request_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_AdminOptions_set_operation_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_AdminOptions_set_validate_only(rd_kafka_AdminOptions_t *options, int true_or_false, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_AdminOptions_set_broker(rd_kafka_AdminOptions_t *options, int32_t broker_id, char *errstr, size_t errstr_size);\nvoid rd_kafka_AdminOptions_set_opaque(rd_kafka_AdminOptions_t *options, void *ev_opaque);\ntypedef struct rd_kafka_NewTopic_s rd_kafka_NewTopic_t;\nrd_kafka_NewTopic_t *rd_kafka_NewTopic_new(const char *topic, int num_partitions, int replication_factor, char *errstr, size_t errstr_size);\nvoid rd_kafka_NewTopic_destroy(rd_kafka_NewTopic_t *new_topic);\nvoid rd_kafka_NewTopic_destroy_array(rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt);\nrd_kafka_resp_err_t rd_kafka_NewTopic_set_replica_assignment(rd_kafka_NewTopic_t *new_topic, int32_t partition, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_NewTopic_set_config(rd_kafka_NewTopic_t *new_topic, const char *name, const char *value);\nvoid rd_kafka_CreateTopics(rd_kafka_t *rk, rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_topic_result_t **rd_kafka_CreateTopics_result_topics(const rd_kafka_CreateTopics_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_DeleteTopic_s rd_kafka_DeleteTopic_t;\nrd_kafka_DeleteTopic_t *rd_kafka_DeleteTopic_new(const char *topic);\nvoid rd_kafka_DeleteTopic_destroy(rd_kafka_DeleteTopic_t *del_topic);\nvoid rd_kafka_DeleteTopic_destroy_array(rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt);\nvoid rd_kafka_DeleteTopics(rd_kafka_t *rk, rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_topic_result_t **rd_kafka_DeleteTopics_result_topics(const rd_kafka_DeleteTopics_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_NewPartitions_s rd_kafka_NewPartitions_t;\nrd_kafka_NewPartitions_t *rd_kafka_NewPartitions_new(const char *topic, size_t new_total_cnt, char *errstr, size_t errstr_size);\nvoid rd_kafka_NewPartitions_destroy(rd_kafka_NewPartitions_t *new_parts);\nvoid rd_kafka_NewPartitions_destroy_array(rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt);\nrd_kafka_resp_err_t rd_kafka_NewPartitions_set_replica_assignment(rd_kafka_NewPartitions_t *new_parts, int32_t new_partition_idx, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);\nvoid rd_kafka_CreatePartitions(rd_kafka_t *rk, rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_topic_result_t **rd_kafka_CreatePartitions_result_topics(const rd_kafka_CreatePartitions_result_t *result, size_t *cntp);\ntypedef enum rd_kafka_ConfigSource_t {\n  RD_KAFKA_CONFIG_SOURCE_UNKNOWN_CONFIG = 0,\n  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_TOPIC_CONFIG = 1,\n  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_BROKER_CONFIG = 2,\n  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_DEFAULT_BROKER_CONFIG = 3,\n  RD_KAFKA_CONFIG_SOURCE_STATIC_BROKER_CONFIG = 4,\n  RD_KAFKA_CONFIG_SOURCE_DEFAULT_CONFIG = 5,\n  RD_KAFKA_CONFIG_SOURCE__CNT,\n} rd_kafka_ConfigSource_t;\nconst char *rd_kafka_ConfigSource_name(rd_kafka_ConfigSource_t confsource);\ntypedef struct rd_kafka_ConfigEntry_s rd_kafka_ConfigEntry_t;\nconst char *rd_kafka_ConfigEntry_name(const rd_kafka_ConfigEntry_t *entry);\nconst char *rd_kafka_ConfigEntry_value(const rd_kafka_ConfigEntry_t *entry);\nrd_kafka_ConfigSource_t rd_kafka_ConfigEntry_source(const rd_kafka_ConfigEntry_t *entry);\nint rd_kafka_ConfigEntry_is_read_only(const rd_kafka_ConfigEntry_t *entry);\nint rd_kafka_ConfigEntry_is_default(const rd_kafka_ConfigEntry_t *entry);\nint rd_kafka_ConfigEntry_is_sensitive(const rd_kafka_ConfigEntry_t *entry);\nint rd_kafka_ConfigEntry_is_synonym(const rd_kafka_ConfigEntry_t *entry);\nconst rd_kafka_ConfigEntry_t **rd_kafka_ConfigEntry_synonyms(const rd_kafka_ConfigEntry_t *entry, size_t *cntp);\ntypedef enum rd_kafka_ResourceType_t {\n  RD_KAFKA_RESOURCE_UNKNOWN = 0,\n  RD_KAFKA_RESOURCE_ANY = 1,\n  RD_KAFKA_RESOURCE_TOPIC = 2,\n  RD_KAFKA_RESOURCE_GROUP = 3,\n  RD_KAFKA_RESOURCE_BROKER = 4,\n  RD_KAFKA_RESOURCE__CNT,\n} rd_kafka_ResourceType_t;\nconst char *rd_kafka_ResourceType_name(rd_kafka_ResourceType_t restype);\ntypedef struct rd_kafka_ConfigResource_s rd_kafka_ConfigResource_t;\nrd_kafka_ConfigResource_t *rd_kafka_ConfigResource_new(rd_kafka_ResourceType_t restype, const char *resname);\nvoid rd_kafka_ConfigResource_destroy(rd_kafka_ConfigResource_t *config);\nvoid rd_kafka_ConfigResource_destroy_array(rd_kafka_ConfigResource_t **config, size_t config_cnt);\nrd_kafka_resp_err_t rd_kafka_ConfigResource_set_config(rd_kafka_ConfigResource_t *config, const char *name, const char *value);\nconst rd_kafka_ConfigEntry_t **rd_kafka_ConfigResource_configs(const rd_kafka_ConfigResource_t *config, size_t *cntp);\nrd_kafka_ResourceType_t rd_kafka_ConfigResource_type(const rd_kafka_ConfigResource_t *config);\nconst char *rd_kafka_ConfigResource_name(const rd_kafka_ConfigResource_t *config);\nrd_kafka_resp_err_t rd_kafka_ConfigResource_error(const rd_kafka_ConfigResource_t *config);\nconst char *rd_kafka_ConfigResource_error_string(const rd_kafka_ConfigResource_t *config);\nvoid rd_kafka_AlterConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_ConfigResource_t **rd_kafka_AlterConfigs_result_resources(const rd_kafka_AlterConfigs_result_t *result, size_t *cntp);\nvoid rd_kafka_DescribeConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_ConfigResource_t **rd_kafka_DescribeConfigs_result_resources(const rd_kafka_DescribeConfigs_result_t *result, size_t *cntp);\nrd_kafka_resp_err_t rd_kafka_oauthbearer_set_token(rd_kafka_t *rk, const char *token_value, int64_t md_lifetime_ms, const char *md_principal_name, const char **extensions, size_t extension_size, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_oauthbearer_set_token_failure(rd_kafka_t *rk, const char *errstr);\nrd_kafka_error_t *rd_kafka_init_transactions(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_error_t *rd_kafka_begin_transaction(rd_kafka_t *rk);\nrd_kafka_error_t *rd_kafka_send_offsets_to_transaction(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, const rd_kafka_consumer_group_metadata_t *cgmetadata, int timeout_ms);\nrd_kafka_error_t *rd_kafka_commit_transaction(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_error_t *rd_kafka_abort_transaction(rd_kafka_t *rk, int timeout_ms);\ntypedef struct rd_kafka_mock_cluster_s rd_kafka_mock_cluster_t;\nrd_kafka_mock_cluster_t *rd_kafka_mock_cluster_new(rd_kafka_t *rk, int broker_cnt);\nvoid rd_kafka_mock_cluster_destroy(rd_kafka_mock_cluster_t *mcluster);\nrd_kafka_t *rd_kafka_mock_cluster_handle(const rd_kafka_mock_cluster_t *mcluster);\nrd_kafka_mock_cluster_t *rd_kafka_handle_mock_cluster(const rd_kafka_t *rk);\nconst char *rd_kafka_mock_cluster_bootstraps(const rd_kafka_mock_cluster_t *mcluster);\nvoid rd_kafka_mock_push_request_errors(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, size_t cnt, ...);\nrd_kafka_resp_err_t rd_kafka_mock_broker_push_request_errors(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int16_t ApiKey, size_t cnt, ...);\nvoid rd_kafka_mock_topic_set_error(rd_kafka_mock_cluster_t *mcluster, const char *topic, rd_kafka_resp_err_t err);\nrd_kafka_resp_err_t rd_kafka_mock_topic_create(rd_kafka_mock_cluster_t *mcluster, const char *topic, int partition_cnt, int replication_factor);\nrd_kafka_resp_err_t rd_kafka_mock_partition_set_leader(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id);\nrd_kafka_resp_err_t rd_kafka_mock_partition_set_follower(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id);\nrd_kafka_resp_err_t rd_kafka_mock_partition_set_follower_wmarks(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int64_t lo, int64_t hi);\nrd_kafka_resp_err_t rd_kafka_mock_broker_set_down(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id);\nrd_kafka_resp_err_t rd_kafka_mock_broker_set_up(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id);\nrd_kafka_resp_err_t rd_kafka_mock_broker_set_rtt(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int rtt_ms);\nrd_kafka_resp_err_t rd_kafka_mock_broker_set_rack(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, const char *rack);\nrd_kafka_resp_err_t rd_kafka_mock_coordinator_set(rd_kafka_mock_cluster_t *mcluster, const char *key_type, const char *key, int32_t broker_id);\nrd_kafka_resp_err_t rd_kafka_mock_set_apiversion(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, int16_t MinVersion, int16_t MaxVersion);\n'\n</code></pre> rdkafka.h, rdkafka_mock.h</p>"},{"location":"api/constants/#rd_kafka_version_12","title":"RD_KAFKA_VERSION","text":"<pre><code>public RD_KAFKA_VERSION = 17105919\n</code></pre> <p>librdkafka version </p> <p>Interpreted as hex <code>MM.mm.rr.xx</code>:</p> <ul> <li>MM = Major</li> <li>mm = minor</li> <li>rr = revision</li> <li>xx = pre-release id (0xff is the final release)</li> </ul> <p>E.g.: <code>0x000801ff</code> = 0.8.1</p> RemarksThis value should only be used during compile time, for runtime checks of version use rd_kafka_version()  <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_unsupported_compression_type_12","title":"RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE","text":"<pre><code>public RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76\n</code></pre> <p>Unsupported compression type </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_end_all_12","title":"RD_KAFKA_RESP_ERR_END_ALL","text":"<p><pre><code>public RD_KAFKA_RESP_ERR_END_ALL = 89\n</code></pre> enum rd_kafka_resp_err_t</p>"},{"location":"api/constants/#rd_kafka_admin_op__cnt_12","title":"RD_KAFKA_ADMIN_OP__CNT","text":"<pre><code>public RD_KAFKA_ADMIN_OP__CNT = 6\n</code></pre> <p>Number of ops defined </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe </li> </ul>"},{"location":"api/constants/#rd_kafka_resource__cnt_12","title":"RD_KAFKA_RESOURCE__CNT","text":"<pre><code>public RD_KAFKA_RESOURCE__CNT = 5\n</code></pre> <p>Number of resource types defined </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#acca83a66d7783ff7683ed2691cc907c9 </li> </ul>"},{"location":"api/constants/#rd_kafka_cdef_12","title":"RD_KAFKA_CDEF","text":"<p><pre><code>public RD_KAFKA_CDEF = 'typedef long int ssize_t;\ntypedef struct _IO_FILE FILE;\ntypedef long int mode_t;\ntypedef signed int int16_t;\ntypedef unsigned int uint16_t;\ntypedef signed int int32_t;\ntypedef signed long int int64_t;\nint rd_kafka_version(void);\nconst char *rd_kafka_version_str(void);\ntypedef enum rd_kafka_type_t {\n  RD_KAFKA_PRODUCER,\n  RD_KAFKA_CONSUMER,\n} rd_kafka_type_t;\ntypedef enum rd_kafka_timestamp_type_t {\n  RD_KAFKA_TIMESTAMP_NOT_AVAILABLE,\n  RD_KAFKA_TIMESTAMP_CREATE_TIME,\n  RD_KAFKA_TIMESTAMP_LOG_APPEND_TIME,\n} rd_kafka_timestamp_type_t;\nconst char *rd_kafka_get_debug_contexts(void);\ntypedef struct rd_kafka_s rd_kafka_t;\ntypedef struct rd_kafka_topic_s rd_kafka_topic_t;\ntypedef struct rd_kafka_conf_s rd_kafka_conf_t;\ntypedef struct rd_kafka_topic_conf_s rd_kafka_topic_conf_t;\ntypedef struct rd_kafka_queue_s rd_kafka_queue_t;\ntypedef struct rd_kafka_op_s rd_kafka_event_t;\ntypedef struct rd_kafka_topic_result_s rd_kafka_topic_result_t;\ntypedef struct rd_kafka_consumer_group_metadata_s rd_kafka_consumer_group_metadata_t;\ntypedef struct rd_kafka_error_s {\n  unsigned int code;\n  char *errstr;\n  unsigned char fatal;\n  unsigned char retriable;\n  unsigned char txn_requires_abort;\n} rd_kafka_error_t;\ntypedef struct rd_kafka_headers_s rd_kafka_headers_t;\ntypedef enum {\n  RD_KAFKA_RESP_ERR__BEGIN = (- 200),\n  RD_KAFKA_RESP_ERR__BAD_MSG = (- 199),\n  RD_KAFKA_RESP_ERR__BAD_COMPRESSION = (- 198),\n  RD_KAFKA_RESP_ERR__DESTROY = (- 197),\n  RD_KAFKA_RESP_ERR__FAIL = (- 196),\n  RD_KAFKA_RESP_ERR__TRANSPORT = (- 195),\n  RD_KAFKA_RESP_ERR__CRIT_SYS_RESOURCE = (- 194),\n  RD_KAFKA_RESP_ERR__RESOLVE = (- 193),\n  RD_KAFKA_RESP_ERR__MSG_TIMED_OUT = (- 192),\n  RD_KAFKA_RESP_ERR__PARTITION_EOF = (- 191),\n  RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION = (- 190),\n  RD_KAFKA_RESP_ERR__FS = (- 189),\n  RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC = (- 188),\n  RD_KAFKA_RESP_ERR__ALL_BROKERS_DOWN = (- 187),\n  RD_KAFKA_RESP_ERR__INVALID_ARG = (- 186),\n  RD_KAFKA_RESP_ERR__TIMED_OUT = (- 185),\n  RD_KAFKA_RESP_ERR__QUEUE_FULL = (- 184),\n  RD_KAFKA_RESP_ERR__ISR_INSUFF = (- 183),\n  RD_KAFKA_RESP_ERR__NODE_UPDATE = (- 182),\n  RD_KAFKA_RESP_ERR__SSL = (- 181),\n  RD_KAFKA_RESP_ERR__WAIT_COORD = (- 180),\n  RD_KAFKA_RESP_ERR__UNKNOWN_GROUP = (- 179),\n  RD_KAFKA_RESP_ERR__IN_PROGRESS = (- 178),\n  RD_KAFKA_RESP_ERR__PREV_IN_PROGRESS = (- 177),\n  RD_KAFKA_RESP_ERR__EXISTING_SUBSCRIPTION = (- 176),\n  RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS = (- 175),\n  RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS = (- 174),\n  RD_KAFKA_RESP_ERR__CONFLICT = (- 173),\n  RD_KAFKA_RESP_ERR__STATE = (- 172),\n  RD_KAFKA_RESP_ERR__UNKNOWN_PROTOCOL = (- 171),\n  RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED = (- 170),\n  RD_KAFKA_RESP_ERR__AUTHENTICATION = (- 169),\n  RD_KAFKA_RESP_ERR__NO_OFFSET = (- 168),\n  RD_KAFKA_RESP_ERR__OUTDATED = (- 167),\n  RD_KAFKA_RESP_ERR__TIMED_OUT_QUEUE = (- 166),\n  RD_KAFKA_RESP_ERR__UNSUPPORTED_FEATURE = (- 165),\n  RD_KAFKA_RESP_ERR__WAIT_CACHE = (- 164),\n  RD_KAFKA_RESP_ERR__INTR = (- 163),\n  RD_KAFKA_RESP_ERR__KEY_SERIALIZATION = (- 162),\n  RD_KAFKA_RESP_ERR__VALUE_SERIALIZATION = (- 161),\n  RD_KAFKA_RESP_ERR__KEY_DESERIALIZATION = (- 160),\n  RD_KAFKA_RESP_ERR__VALUE_DESERIALIZATION = (- 159),\n  RD_KAFKA_RESP_ERR__PARTIAL = (- 158),\n  RD_KAFKA_RESP_ERR__READ_ONLY = (- 157),\n  RD_KAFKA_RESP_ERR__NOENT = (- 156),\n  RD_KAFKA_RESP_ERR__UNDERFLOW = (- 155),\n  RD_KAFKA_RESP_ERR__INVALID_TYPE = (- 154),\n  RD_KAFKA_RESP_ERR__RETRY = (- 153),\n  RD_KAFKA_RESP_ERR__PURGE_QUEUE = (- 152),\n  RD_KAFKA_RESP_ERR__PURGE_INFLIGHT = (- 151),\n  RD_KAFKA_RESP_ERR__FATAL = (- 150),\n  RD_KAFKA_RESP_ERR__INCONSISTENT = (- 149),\n  RD_KAFKA_RESP_ERR__GAPLESS_GUARANTEE = (- 148),\n  RD_KAFKA_RESP_ERR__MAX_POLL_EXCEEDED = (- 147),\n  RD_KAFKA_RESP_ERR__UNKNOWN_BROKER = (- 146),\n  RD_KAFKA_RESP_ERR__NOT_CONFIGURED = (- 145),\n  RD_KAFKA_RESP_ERR__FENCED = (- 144),\n  RD_KAFKA_RESP_ERR__APPLICATION = (- 143),\n  RD_KAFKA_RESP_ERR__END = (- 100),\n  RD_KAFKA_RESP_ERR_UNKNOWN = (- 1),\n  RD_KAFKA_RESP_ERR_NO_ERROR = 0,\n  RD_KAFKA_RESP_ERR_OFFSET_OUT_OF_RANGE = 1,\n  RD_KAFKA_RESP_ERR_INVALID_MSG = 2,\n  RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART = 3,\n  RD_KAFKA_RESP_ERR_INVALID_MSG_SIZE = 4,\n  RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE = 5,\n  RD_KAFKA_RESP_ERR_NOT_LEADER_FOR_PARTITION = 6,\n  RD_KAFKA_RESP_ERR_REQUEST_TIMED_OUT = 7,\n  RD_KAFKA_RESP_ERR_BROKER_NOT_AVAILABLE = 8,\n  RD_KAFKA_RESP_ERR_REPLICA_NOT_AVAILABLE = 9,\n  RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE = 10,\n  RD_KAFKA_RESP_ERR_STALE_CTRL_EPOCH = 11,\n  RD_KAFKA_RESP_ERR_OFFSET_METADATA_TOO_LARGE = 12,\n  RD_KAFKA_RESP_ERR_NETWORK_EXCEPTION = 13,\n  RD_KAFKA_RESP_ERR_COORDINATOR_LOAD_IN_PROGRESS = 14,\n  RD_KAFKA_RESP_ERR_COORDINATOR_NOT_AVAILABLE = 15,\n  RD_KAFKA_RESP_ERR_NOT_COORDINATOR = 16,\n  RD_KAFKA_RESP_ERR_TOPIC_EXCEPTION = 17,\n  RD_KAFKA_RESP_ERR_RECORD_LIST_TOO_LARGE = 18,\n  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS = 19,\n  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS_AFTER_APPEND = 20,\n  RD_KAFKA_RESP_ERR_INVALID_REQUIRED_ACKS = 21,\n  RD_KAFKA_RESP_ERR_ILLEGAL_GENERATION = 22,\n  RD_KAFKA_RESP_ERR_INCONSISTENT_GROUP_PROTOCOL = 23,\n  RD_KAFKA_RESP_ERR_INVALID_GROUP_ID = 24,\n  RD_KAFKA_RESP_ERR_UNKNOWN_MEMBER_ID = 25,\n  RD_KAFKA_RESP_ERR_INVALID_SESSION_TIMEOUT = 26,\n  RD_KAFKA_RESP_ERR_REBALANCE_IN_PROGRESS = 27,\n  RD_KAFKA_RESP_ERR_INVALID_COMMIT_OFFSET_SIZE = 28,\n  RD_KAFKA_RESP_ERR_TOPIC_AUTHORIZATION_FAILED = 29,\n  RD_KAFKA_RESP_ERR_GROUP_AUTHORIZATION_FAILED = 30,\n  RD_KAFKA_RESP_ERR_CLUSTER_AUTHORIZATION_FAILED = 31,\n  RD_KAFKA_RESP_ERR_INVALID_TIMESTAMP = 32,\n  RD_KAFKA_RESP_ERR_UNSUPPORTED_SASL_MECHANISM = 33,\n  RD_KAFKA_RESP_ERR_ILLEGAL_SASL_STATE = 34,\n  RD_KAFKA_RESP_ERR_UNSUPPORTED_VERSION = 35,\n  RD_KAFKA_RESP_ERR_TOPIC_ALREADY_EXISTS = 36,\n  RD_KAFKA_RESP_ERR_INVALID_PARTITIONS = 37,\n  RD_KAFKA_RESP_ERR_INVALID_REPLICATION_FACTOR = 38,\n  RD_KAFKA_RESP_ERR_INVALID_REPLICA_ASSIGNMENT = 39,\n  RD_KAFKA_RESP_ERR_INVALID_CONFIG = 40,\n  RD_KAFKA_RESP_ERR_NOT_CONTROLLER = 41,\n  RD_KAFKA_RESP_ERR_INVALID_REQUEST = 42,\n  RD_KAFKA_RESP_ERR_UNSUPPORTED_FOR_MESSAGE_FORMAT = 43,\n  RD_KAFKA_RESP_ERR_POLICY_VIOLATION = 44,\n  RD_KAFKA_RESP_ERR_OUT_OF_ORDER_SEQUENCE_NUMBER = 45,\n  RD_KAFKA_RESP_ERR_DUPLICATE_SEQUENCE_NUMBER = 46,\n  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_EPOCH = 47,\n  RD_KAFKA_RESP_ERR_INVALID_TXN_STATE = 48,\n  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_ID_MAPPING = 49,\n  RD_KAFKA_RESP_ERR_INVALID_TRANSACTION_TIMEOUT = 50,\n  RD_KAFKA_RESP_ERR_CONCURRENT_TRANSACTIONS = 51,\n  RD_KAFKA_RESP_ERR_TRANSACTION_COORDINATOR_FENCED = 52,\n  RD_KAFKA_RESP_ERR_TRANSACTIONAL_ID_AUTHORIZATION_FAILED = 53,\n  RD_KAFKA_RESP_ERR_SECURITY_DISABLED = 54,\n  RD_KAFKA_RESP_ERR_OPERATION_NOT_ATTEMPTED = 55,\n  RD_KAFKA_RESP_ERR_KAFKA_STORAGE_ERROR = 56,\n  RD_KAFKA_RESP_ERR_LOG_DIR_NOT_FOUND = 57,\n  RD_KAFKA_RESP_ERR_SASL_AUTHENTICATION_FAILED = 58,\n  RD_KAFKA_RESP_ERR_UNKNOWN_PRODUCER_ID = 59,\n  RD_KAFKA_RESP_ERR_REASSIGNMENT_IN_PROGRESS = 60,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTH_DISABLED = 61,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_NOT_FOUND = 62,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_OWNER_MISMATCH = 63,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_REQUEST_NOT_ALLOWED = 64,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTHORIZATION_FAILED = 65,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_EXPIRED = 66,\n  RD_KAFKA_RESP_ERR_INVALID_PRINCIPAL_TYPE = 67,\n  RD_KAFKA_RESP_ERR_NON_EMPTY_GROUP = 68,\n  RD_KAFKA_RESP_ERR_GROUP_ID_NOT_FOUND = 69,\n  RD_KAFKA_RESP_ERR_FETCH_SESSION_ID_NOT_FOUND = 70,\n  RD_KAFKA_RESP_ERR_INVALID_FETCH_SESSION_EPOCH = 71,\n  RD_KAFKA_RESP_ERR_LISTENER_NOT_FOUND = 72,\n  RD_KAFKA_RESP_ERR_TOPIC_DELETION_DISABLED = 73,\n  RD_KAFKA_RESP_ERR_FENCED_LEADER_EPOCH = 74,\n  RD_KAFKA_RESP_ERR_UNKNOWN_LEADER_EPOCH = 75,\n  RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76,\n  RD_KAFKA_RESP_ERR_STALE_BROKER_EPOCH = 77,\n  RD_KAFKA_RESP_ERR_OFFSET_NOT_AVAILABLE = 78,\n  RD_KAFKA_RESP_ERR_MEMBER_ID_REQUIRED = 79,\n  RD_KAFKA_RESP_ERR_PREFERRED_LEADER_NOT_AVAILABLE = 80,\n  RD_KAFKA_RESP_ERR_GROUP_MAX_SIZE_REACHED = 81,\n  RD_KAFKA_RESP_ERR_FENCED_INSTANCE_ID = 82,\n  RD_KAFKA_RESP_ERR_ELIGIBLE_LEADERS_NOT_AVAILABLE = 83,\n  RD_KAFKA_RESP_ERR_ELECTION_NOT_NEEDED = 84,\n  RD_KAFKA_RESP_ERR_NO_REASSIGNMENT_IN_PROGRESS = 85,\n  RD_KAFKA_RESP_ERR_GROUP_SUBSCRIBED_TO_TOPIC = 86,\n  RD_KAFKA_RESP_ERR_INVALID_RECORD = 87,\n  RD_KAFKA_RESP_ERR_UNSTABLE_OFFSET_COMMIT = 88,\n  RD_KAFKA_RESP_ERR_END_ALL,\n} rd_kafka_resp_err_t;\nstruct rd_kafka_err_desc {\n  rd_kafka_resp_err_t code;\n  char *name;\n  char *desc;\n};\nvoid rd_kafka_get_err_descs(const struct rd_kafka_err_desc **errdescs, size_t *cntp);\nconst char *rd_kafka_err2str(rd_kafka_resp_err_t err);\nconst char *rd_kafka_err2name(rd_kafka_resp_err_t err);\nrd_kafka_resp_err_t rd_kafka_last_error(void);\nrd_kafka_resp_err_t rd_kafka_errno2err(int errnox);\nint rd_kafka_errno(void);\nrd_kafka_resp_err_t rd_kafka_fatal_error(rd_kafka_t *rk, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_test_fatal_error(rd_kafka_t *rk, rd_kafka_resp_err_t err, const char *reason);\nrd_kafka_resp_err_t rd_kafka_error_code(const rd_kafka_error_t *error);\nconst char *rd_kafka_error_name(const rd_kafka_error_t *error);\nconst char *rd_kafka_error_string(const rd_kafka_error_t *error);\nint rd_kafka_error_is_fatal(const rd_kafka_error_t *error);\nint rd_kafka_error_is_retriable(const rd_kafka_error_t *error);\nint rd_kafka_error_txn_requires_abort(const rd_kafka_error_t *error);\nvoid rd_kafka_error_destroy(rd_kafka_error_t *error);\nrd_kafka_error_t *rd_kafka_error_new(rd_kafka_resp_err_t code, const char *fmt, ...);\ntypedef struct rd_kafka_topic_partition_s {\n  char *topic;\n  int32_t partition;\n  int64_t offset;\n  void *metadata;\n  size_t metadata_size;\n  void *opaque;\n  rd_kafka_resp_err_t err;\n  void *_private;\n} rd_kafka_topic_partition_t;\nvoid rd_kafka_topic_partition_destroy(rd_kafka_topic_partition_t *rktpar);\ntypedef struct rd_kafka_topic_partition_list_s {\n  int cnt;\n  int size;\n  rd_kafka_topic_partition_t *elems;\n} rd_kafka_topic_partition_list_t;\nrd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_new(int size);\nvoid rd_kafka_topic_partition_list_destroy(rd_kafka_topic_partition_list_t *rkparlist);\nrd_kafka_topic_partition_t *rd_kafka_topic_partition_list_add(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);\nvoid rd_kafka_topic_partition_list_add_range(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t start, int32_t stop);\nint rd_kafka_topic_partition_list_del(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);\nint rd_kafka_topic_partition_list_del_by_idx(rd_kafka_topic_partition_list_t *rktparlist, int idx);\nrd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_copy(const rd_kafka_topic_partition_list_t *src);\nrd_kafka_resp_err_t rd_kafka_topic_partition_list_set_offset(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition, int64_t offset);\nrd_kafka_topic_partition_t *rd_kafka_topic_partition_list_find(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);\nvoid rd_kafka_topic_partition_list_sort(rd_kafka_topic_partition_list_t *rktparlist, int (*cmp)(const void *a, const void *b, void *cmp_opaque), void *cmp_opaque);\ntypedef enum rd_kafka_vtype_t {\n  RD_KAFKA_VTYPE_END,\n  RD_KAFKA_VTYPE_TOPIC,\n  RD_KAFKA_VTYPE_RKT,\n  RD_KAFKA_VTYPE_PARTITION,\n  RD_KAFKA_VTYPE_VALUE,\n  RD_KAFKA_VTYPE_KEY,\n  RD_KAFKA_VTYPE_OPAQUE,\n  RD_KAFKA_VTYPE_MSGFLAGS,\n  RD_KAFKA_VTYPE_TIMESTAMP,\n  RD_KAFKA_VTYPE_HEADER,\n  RD_KAFKA_VTYPE_HEADERS,\n} rd_kafka_vtype_t;\ntypedef struct rd_kafka_vu_s {\n  rd_kafka_vtype_t vtype;\n  union {\n    char *cstr;\n    rd_kafka_topic_t *rkt;\n    int i;\n    int32_t i32;\n    int64_t i64;\n    struct {\n      void *ptr;\n      size_t size;\n    } mem;\n    struct {\n      char *name;\n      void *val;\n      ssize_t size;\n    } header;\n    rd_kafka_headers_t *headers;\n    void *ptr;\n    char _pad[64];\n  } u;\n} rd_kafka_vu_t;\nrd_kafka_headers_t *rd_kafka_headers_new(size_t initial_count);\nvoid rd_kafka_headers_destroy(rd_kafka_headers_t *hdrs);\nrd_kafka_headers_t *rd_kafka_headers_copy(const rd_kafka_headers_t *src);\nrd_kafka_resp_err_t rd_kafka_header_add(rd_kafka_headers_t *hdrs, const char *name, ssize_t name_size, const void *value, ssize_t value_size);\nrd_kafka_resp_err_t rd_kafka_header_remove(rd_kafka_headers_t *hdrs, const char *name);\nrd_kafka_resp_err_t rd_kafka_header_get_last(const rd_kafka_headers_t *hdrs, const char *name, const void **valuep, size_t *sizep);\nrd_kafka_resp_err_t rd_kafka_header_get(const rd_kafka_headers_t *hdrs, size_t idx, const char *name, const void **valuep, size_t *sizep);\nrd_kafka_resp_err_t rd_kafka_header_get_all(const rd_kafka_headers_t *hdrs, size_t idx, const char **namep, const void **valuep, size_t *sizep);\ntypedef struct rd_kafka_message_s {\n  rd_kafka_resp_err_t err;\n  rd_kafka_topic_t *rkt;\n  int32_t partition;\n  void *payload;\n  size_t len;\n  void *key;\n  size_t key_len;\n  int64_t offset;\n  void *_private;\n} rd_kafka_message_t;\nvoid rd_kafka_message_destroy(rd_kafka_message_t *rkmessage);\nconst char *rd_kafka_message_errstr(const rd_kafka_message_t *rkmessage);\nint64_t rd_kafka_message_timestamp(const rd_kafka_message_t *rkmessage, rd_kafka_timestamp_type_t *tstype);\nint64_t rd_kafka_message_latency(const rd_kafka_message_t *rkmessage);\nint32_t rd_kafka_message_broker_id(const rd_kafka_message_t *rkmessage);\nrd_kafka_resp_err_t rd_kafka_message_headers(const rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);\nrd_kafka_resp_err_t rd_kafka_message_detach_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);\nvoid rd_kafka_message_set_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t *hdrs);\nsize_t rd_kafka_header_cnt(const rd_kafka_headers_t *hdrs);\ntypedef enum {\n  RD_KAFKA_MSG_STATUS_NOT_PERSISTED = 0,\n  RD_KAFKA_MSG_STATUS_POSSIBLY_PERSISTED = 1,\n  RD_KAFKA_MSG_STATUS_PERSISTED = 2,\n} rd_kafka_msg_status_t;\nrd_kafka_msg_status_t rd_kafka_message_status(const rd_kafka_message_t *rkmessage);\ntypedef enum {\n  RD_KAFKA_CONF_UNKNOWN = (- 2),\n  RD_KAFKA_CONF_INVALID = (- 1),\n  RD_KAFKA_CONF_OK = 0,\n} rd_kafka_conf_res_t;\nrd_kafka_conf_t *rd_kafka_conf_new(void);\nvoid rd_kafka_conf_destroy(rd_kafka_conf_t *conf);\nrd_kafka_conf_t *rd_kafka_conf_dup(const rd_kafka_conf_t *conf);\nrd_kafka_conf_t *rd_kafka_conf_dup_filter(const rd_kafka_conf_t *conf, size_t filter_cnt, const char **filter);\nconst rd_kafka_conf_t *rd_kafka_conf(rd_kafka_t *rk);\nrd_kafka_conf_res_t rd_kafka_conf_set(rd_kafka_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);\nvoid rd_kafka_conf_set_events(rd_kafka_conf_t *conf, int events);\nvoid rd_kafka_conf_set_background_event_cb(rd_kafka_conf_t *conf, void (*event_cb)(rd_kafka_t *rk, rd_kafka_event_t *rkev, void *opaque));\nvoid rd_kafka_conf_set_dr_cb(rd_kafka_conf_t *conf, void (*dr_cb)(rd_kafka_t *rk, void *payload, size_t len, rd_kafka_resp_err_t err, void *opaque, void *msg_opaque));\nvoid rd_kafka_conf_set_dr_msg_cb(rd_kafka_conf_t *conf, void (*dr_msg_cb)(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, void *opaque));\nvoid rd_kafka_conf_set_consume_cb(rd_kafka_conf_t *conf, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *opaque));\nvoid rd_kafka_conf_set_rebalance_cb(rd_kafka_conf_t *conf, void (*rebalance_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *partitions, void *opaque));\nvoid rd_kafka_conf_set_offset_commit_cb(rd_kafka_conf_t *conf, void (*offset_commit_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *opaque));\nvoid rd_kafka_conf_set_error_cb(rd_kafka_conf_t *conf, void (*error_cb)(rd_kafka_t *rk, int err, const char *reason, void *opaque));\nvoid rd_kafka_conf_set_throttle_cb(rd_kafka_conf_t *conf, void (*throttle_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int throttle_time_ms, void *opaque));\nvoid rd_kafka_conf_set_log_cb(rd_kafka_conf_t *conf, void (*log_cb)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));\nvoid rd_kafka_conf_set_stats_cb(rd_kafka_conf_t *conf, int (*stats_cb)(rd_kafka_t *rk, char *json, size_t json_len, void *opaque));\nvoid rd_kafka_conf_set_oauthbearer_token_refresh_cb(rd_kafka_conf_t *conf, void (*oauthbearer_token_refresh_cb)(rd_kafka_t *rk, const char *oauthbearer_config, void *opaque));\nvoid rd_kafka_conf_set_socket_cb(rd_kafka_conf_t *conf, int (*socket_cb)(int domain, int type, int protocol, void *opaque));\nvoid rd_kafka_conf_set_connect_cb(rd_kafka_conf_t *conf, int (*connect_cb)(int sockfd, const struct sockaddr *addr, int addrlen, const char *id, void *opaque));\nvoid rd_kafka_conf_set_closesocket_cb(rd_kafka_conf_t *conf, int (*closesocket_cb)(int sockfd, void *opaque));\nrd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert_verify_cb(rd_kafka_conf_t *conf, int (*ssl_cert_verify_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int *x509_error, int depth, const char *buf, size_t size, char *errstr, size_t errstr_size, void *opaque));\ntypedef enum rd_kafka_cert_type_t {\n  RD_KAFKA_CERT_PUBLIC_KEY,\n  RD_KAFKA_CERT_PRIVATE_KEY,\n  RD_KAFKA_CERT_CA,\n  RD_KAFKA_CERT__CNT,\n} rd_kafka_cert_type_t;\ntypedef enum rd_kafka_cert_enc_t {\n  RD_KAFKA_CERT_ENC_PKCS12,\n  RD_KAFKA_CERT_ENC_DER,\n  RD_KAFKA_CERT_ENC_PEM,\n  RD_KAFKA_CERT_ENC__CNT,\n} rd_kafka_cert_enc_t;\nrd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert(rd_kafka_conf_t *conf, rd_kafka_cert_type_t cert_type, rd_kafka_cert_enc_t cert_enc, const void *buffer, size_t size, char *errstr, size_t errstr_size);\nvoid rd_kafka_conf_set_opaque(rd_kafka_conf_t *conf, void *opaque);\nvoid *rd_kafka_opaque(const rd_kafka_t *rk);\nvoid rd_kafka_conf_set_default_topic_conf(rd_kafka_conf_t *conf, rd_kafka_topic_conf_t *tconf);\nrd_kafka_conf_res_t rd_kafka_conf_get(const rd_kafka_conf_t *conf, const char *name, char *dest, size_t *dest_size);\nrd_kafka_conf_res_t rd_kafka_topic_conf_get(const rd_kafka_topic_conf_t *conf, const char *name, char *dest, size_t *dest_size);\nconst char **rd_kafka_conf_dump(rd_kafka_conf_t *conf, size_t *cntp);\nconst char **rd_kafka_topic_conf_dump(rd_kafka_topic_conf_t *conf, size_t *cntp);\nvoid rd_kafka_conf_dump_free(const char **arr, size_t cnt);\nvoid rd_kafka_conf_properties_show(FILE *fp);\nrd_kafka_topic_conf_t *rd_kafka_topic_conf_new(void);\nrd_kafka_topic_conf_t *rd_kafka_topic_conf_dup(const rd_kafka_topic_conf_t *conf);\nrd_kafka_topic_conf_t *rd_kafka_default_topic_conf_dup(rd_kafka_t *rk);\nvoid rd_kafka_topic_conf_destroy(rd_kafka_topic_conf_t *topic_conf);\nrd_kafka_conf_res_t rd_kafka_topic_conf_set(rd_kafka_topic_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);\nvoid rd_kafka_topic_conf_set_opaque(rd_kafka_topic_conf_t *conf, void *rkt_opaque);\nvoid rd_kafka_topic_conf_set_partitioner_cb(rd_kafka_topic_conf_t *topic_conf, int32_t (*partitioner)(const rd_kafka_topic_t *rkt, const void *keydata, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque));\nvoid rd_kafka_topic_conf_set_msg_order_cmp(rd_kafka_topic_conf_t *topic_conf, int (*msg_order_cmp)(const rd_kafka_message_t *a, const rd_kafka_message_t *b));\nint rd_kafka_topic_partition_available(const rd_kafka_topic_t *rkt, int32_t partition);\nint32_t rd_kafka_msg_partitioner_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_consistent(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_consistent_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_murmur2(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_murmur2_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_fnv1a(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_fnv1a_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nrd_kafka_t *rd_kafka_new(rd_kafka_type_t type, rd_kafka_conf_t *conf, char *errstr, size_t errstr_size);\nvoid rd_kafka_destroy(rd_kafka_t *rk);\nvoid rd_kafka_destroy_flags(rd_kafka_t *rk, int flags);\nconst char *rd_kafka_name(const rd_kafka_t *rk);\nrd_kafka_type_t rd_kafka_type(const rd_kafka_t *rk);\nchar *rd_kafka_memberid(const rd_kafka_t *rk);\nchar *rd_kafka_clusterid(rd_kafka_t *rk, int timeout_ms);\nint32_t rd_kafka_controllerid(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_topic_t *rd_kafka_topic_new(rd_kafka_t *rk, const char *topic, rd_kafka_topic_conf_t *conf);\nvoid rd_kafka_topic_destroy(rd_kafka_topic_t *rkt);\nconst char *rd_kafka_topic_name(const rd_kafka_topic_t *rkt);\nvoid *rd_kafka_topic_opaque(const rd_kafka_topic_t *rkt);\nint rd_kafka_poll(rd_kafka_t *rk, int timeout_ms);\nvoid rd_kafka_yield(rd_kafka_t *rk);\nrd_kafka_resp_err_t rd_kafka_pause_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_resp_err_t rd_kafka_resume_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_resp_err_t rd_kafka_query_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high, int timeout_ms);\nrd_kafka_resp_err_t rd_kafka_get_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high);\nrd_kafka_resp_err_t rd_kafka_offsets_for_times(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets, int timeout_ms);\nvoid rd_kafka_mem_free(rd_kafka_t *rk, void *ptr);\nrd_kafka_queue_t *rd_kafka_queue_new(rd_kafka_t *rk);\nvoid rd_kafka_queue_destroy(rd_kafka_queue_t *rkqu);\nrd_kafka_queue_t *rd_kafka_queue_get_main(rd_kafka_t *rk);\nrd_kafka_queue_t *rd_kafka_queue_get_consumer(rd_kafka_t *rk);\nrd_kafka_queue_t *rd_kafka_queue_get_partition(rd_kafka_t *rk, const char *topic, int32_t partition);\nrd_kafka_queue_t *rd_kafka_queue_get_background(rd_kafka_t *rk);\nvoid rd_kafka_queue_forward(rd_kafka_queue_t *src, rd_kafka_queue_t *dst);\nrd_kafka_resp_err_t rd_kafka_set_log_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu);\nsize_t rd_kafka_queue_length(rd_kafka_queue_t *rkqu);\nvoid rd_kafka_queue_io_event_enable(rd_kafka_queue_t *rkqu, int fd, const void *payload, size_t size);\nvoid rd_kafka_queue_cb_event_enable(rd_kafka_queue_t *rkqu, void (*event_cb)(rd_kafka_t *rk, void *qev_opaque), void *qev_opaque);\nint rd_kafka_consume_start(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);\nint rd_kafka_consume_start_queue(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, rd_kafka_queue_t *rkqu);\nint rd_kafka_consume_stop(rd_kafka_topic_t *rkt, int32_t partition);\nrd_kafka_resp_err_t rd_kafka_seek(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, int timeout_ms);\nrd_kafka_message_t *rd_kafka_consume(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms);\nssize_t rd_kafka_consume_batch(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);\nint rd_kafka_consume_callback(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);\nrd_kafka_message_t *rd_kafka_consume_queue(rd_kafka_queue_t *rkqu, int timeout_ms);\nssize_t rd_kafka_consume_batch_queue(rd_kafka_queue_t *rkqu, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);\nint rd_kafka_consume_callback_queue(rd_kafka_queue_t *rkqu, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);\nrd_kafka_resp_err_t rd_kafka_offset_store(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);\nrd_kafka_resp_err_t rd_kafka_offsets_store(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets);\nrd_kafka_resp_err_t rd_kafka_subscribe(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *topics);\nrd_kafka_resp_err_t rd_kafka_unsubscribe(rd_kafka_t *rk);\nrd_kafka_resp_err_t rd_kafka_subscription(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **topics);\nrd_kafka_message_t *rd_kafka_consumer_poll(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_resp_err_t rd_kafka_consumer_close(rd_kafka_t *rk);\nrd_kafka_resp_err_t rd_kafka_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_resp_err_t rd_kafka_assignment(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **partitions);\nrd_kafka_resp_err_t rd_kafka_commit(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, int async);\nrd_kafka_resp_err_t rd_kafka_commit_message(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, int async);\nrd_kafka_resp_err_t rd_kafka_commit_queue(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_queue_t *rkqu, void (*cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *commit_opaque), void *commit_opaque);\nrd_kafka_resp_err_t rd_kafka_committed(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms);\nrd_kafka_resp_err_t rd_kafka_position(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata(rd_kafka_t *rk);\nrd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata_new(const char *group_id);\nvoid rd_kafka_consumer_group_metadata_destroy(rd_kafka_consumer_group_metadata_t *);\nrd_kafka_error_t *rd_kafka_consumer_group_metadata_write(const rd_kafka_consumer_group_metadata_t *cgmd, void **bufferp, size_t *sizep);\nrd_kafka_error_t *rd_kafka_consumer_group_metadata_read(rd_kafka_consumer_group_metadata_t **cgmdp, const void *buffer, size_t size);\nint rd_kafka_produce(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, void *payload, size_t len, const void *key, size_t keylen, void *msg_opaque);\nrd_kafka_resp_err_t rd_kafka_producev(rd_kafka_t *rk, ...);\nrd_kafka_error_t *rd_kafka_produceva(rd_kafka_t *rk, const rd_kafka_vu_t *vus, size_t cnt);\nint rd_kafka_produce_batch(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, rd_kafka_message_t *rkmessages, int message_cnt);\nrd_kafka_resp_err_t rd_kafka_flush(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_resp_err_t rd_kafka_purge(rd_kafka_t *rk, int purge_flags);\ntypedef struct rd_kafka_metadata_broker {\n  int32_t id;\n  char *host;\n  int port;\n} rd_kafka_metadata_broker_t;\ntypedef struct rd_kafka_metadata_partition {\n  int32_t id;\n  rd_kafka_resp_err_t err;\n  int32_t leader;\n  int replica_cnt;\n  int32_t *replicas;\n  int isr_cnt;\n  int32_t *isrs;\n} rd_kafka_metadata_partition_t;\ntypedef struct rd_kafka_metadata_topic {\n  char *topic;\n  int partition_cnt;\n  struct rd_kafka_metadata_partition *partitions;\n  rd_kafka_resp_err_t err;\n} rd_kafka_metadata_topic_t;\ntypedef struct rd_kafka_metadata {\n  int broker_cnt;\n  struct rd_kafka_metadata_broker *brokers;\n  int topic_cnt;\n  struct rd_kafka_metadata_topic *topics;\n  int32_t orig_broker_id;\n  char *orig_broker_name;\n} rd_kafka_metadata_t;\nrd_kafka_resp_err_t rd_kafka_metadata(rd_kafka_t *rk, int all_topics, rd_kafka_topic_t *only_rkt, const struct rd_kafka_metadata **metadatap, int timeout_ms);\nvoid rd_kafka_metadata_destroy(const struct rd_kafka_metadata *metadata);\nstruct rd_kafka_group_member_info {\n  char *member_id;\n  char *client_id;\n  char *client_host;\n  void *member_metadata;\n  int member_metadata_size;\n  void *member_assignment;\n  int member_assignment_size;\n};\nstruct rd_kafka_group_info {\n  struct rd_kafka_metadata_broker broker;\n  char *group;\n  rd_kafka_resp_err_t err;\n  char *state;\n  char *protocol_type;\n  char *protocol;\n  struct rd_kafka_group_member_info *members;\n  int member_cnt;\n};\nstruct rd_kafka_group_list {\n  struct rd_kafka_group_info *groups;\n  int group_cnt;\n};\nrd_kafka_resp_err_t rd_kafka_list_groups(rd_kafka_t *rk, const char *group, const struct rd_kafka_group_list **grplistp, int timeout_ms);\nvoid rd_kafka_group_list_destroy(const struct rd_kafka_group_list *grplist);\nint rd_kafka_brokers_add(rd_kafka_t *rk, const char *brokerlist);\nvoid rd_kafka_set_logger(rd_kafka_t *rk, void (*func)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));\nvoid rd_kafka_set_log_level(rd_kafka_t *rk, int level);\nvoid rd_kafka_log_print(const rd_kafka_t *rk, int level, const char *fac, const char *buf);\nvoid rd_kafka_log_syslog(const rd_kafka_t *rk, int level, const char *fac, const char *buf);\nint rd_kafka_outq_len(rd_kafka_t *rk);\nvoid rd_kafka_dump(FILE *fp, rd_kafka_t *rk);\nint rd_kafka_thread_cnt(void);\ntypedef enum rd_kafka_thread_type_t {\n  RD_KAFKA_THREAD_MAIN,\n  RD_KAFKA_THREAD_BACKGROUND,\n  RD_KAFKA_THREAD_BROKER,\n} rd_kafka_thread_type_t;\nint rd_kafka_wait_destroyed(int timeout_ms);\nint rd_kafka_unittest(void);\nrd_kafka_resp_err_t rd_kafka_poll_set_consumer(rd_kafka_t *rk);\ntypedef int rd_kafka_event_type_t;\nrd_kafka_event_type_t rd_kafka_event_type(const rd_kafka_event_t *rkev);\nconst char *rd_kafka_event_name(const rd_kafka_event_t *rkev);\nvoid rd_kafka_event_destroy(rd_kafka_event_t *rkev);\nconst rd_kafka_message_t *rd_kafka_event_message_next(rd_kafka_event_t *rkev);\nsize_t rd_kafka_event_message_array(rd_kafka_event_t *rkev, const rd_kafka_message_t **rkmessages, size_t size);\nsize_t rd_kafka_event_message_count(rd_kafka_event_t *rkev);\nconst char *rd_kafka_event_config_string(rd_kafka_event_t *rkev);\nrd_kafka_resp_err_t rd_kafka_event_error(rd_kafka_event_t *rkev);\nconst char *rd_kafka_event_error_string(rd_kafka_event_t *rkev);\nint rd_kafka_event_error_is_fatal(rd_kafka_event_t *rkev);\nvoid *rd_kafka_event_opaque(rd_kafka_event_t *rkev);\nint rd_kafka_event_log(rd_kafka_event_t *rkev, const char **fac, const char **str, int *level);\nint rd_kafka_event_debug_contexts(rd_kafka_event_t *rkev, char *dst, size_t dstsize);\nconst char *rd_kafka_event_stats(rd_kafka_event_t *rkev);\nrd_kafka_topic_partition_list_t *rd_kafka_event_topic_partition_list(rd_kafka_event_t *rkev);\nrd_kafka_topic_partition_t *rd_kafka_event_topic_partition(rd_kafka_event_t *rkev);\ntypedef rd_kafka_event_t rd_kafka_CreateTopics_result_t;\ntypedef rd_kafka_event_t rd_kafka_DeleteTopics_result_t;\ntypedef rd_kafka_event_t rd_kafka_CreatePartitions_result_t;\ntypedef rd_kafka_event_t rd_kafka_AlterConfigs_result_t;\ntypedef rd_kafka_event_t rd_kafka_DescribeConfigs_result_t;\nconst rd_kafka_CreateTopics_result_t *rd_kafka_event_CreateTopics_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DeleteTopics_result_t *rd_kafka_event_DeleteTopics_result(rd_kafka_event_t *rkev);\nconst rd_kafka_CreatePartitions_result_t *rd_kafka_event_CreatePartitions_result(rd_kafka_event_t *rkev);\nconst rd_kafka_AlterConfigs_result_t *rd_kafka_event_AlterConfigs_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DescribeConfigs_result_t *rd_kafka_event_DescribeConfigs_result(rd_kafka_event_t *rkev);\nrd_kafka_event_t *rd_kafka_queue_poll(rd_kafka_queue_t *rkqu, int timeout_ms);\nint rd_kafka_queue_poll_callback(rd_kafka_queue_t *rkqu, int timeout_ms);\ntypedef rd_kafka_resp_err_t (rd_kafka_plugin_f_conf_init_t)(rd_kafka_conf_t *conf, void **plug_opaquep, char *errstr, size_t errstr_size);\ntypedef rd_kafka_conf_res_t (rd_kafka_interceptor_f_on_conf_set_t)(rd_kafka_conf_t *conf, const char *name, const char *val, char *errstr, size_t errstr_size, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_dup_t)(rd_kafka_conf_t *new_conf, const rd_kafka_conf_t *old_conf, size_t filter_cnt, const char **filter, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_destroy_t)(void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_new_t)(rd_kafka_t *rk, const rd_kafka_conf_t *conf, void *ic_opaque, char *errstr, size_t errstr_size);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_destroy_t)(rd_kafka_t *rk, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_send_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_acknowledgement_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_consume_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_commit_t)(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_resp_err_t err, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_request_sent_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_start_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_exit_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_set(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_set_t *on_conf_set, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_dup(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_dup_t *on_conf_dup, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_destroy(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_destroy_t *on_conf_destroy, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_new(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_new_t *on_new, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_destroy(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_destroy_t *on_destroy, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_send(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_send_t *on_send, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_acknowledgement(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_acknowledgement_t *on_acknowledgement, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_consume(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_consume_t *on_consume, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_commit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_commit_t *on_commit, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_request_sent(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_request_sent_t *on_request_sent, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_start(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_start_t *on_thread_start, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_exit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_exit_t *on_thread_exit, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_topic_result_error(const rd_kafka_topic_result_t *topicres);\nconst char *rd_kafka_topic_result_error_string(const rd_kafka_topic_result_t *topicres);\nconst char *rd_kafka_topic_result_name(const rd_kafka_topic_result_t *topicres);\ntypedef enum rd_kafka_admin_op_t {\n  RD_KAFKA_ADMIN_OP_ANY = 0,\n  RD_KAFKA_ADMIN_OP_CREATETOPICS,\n  RD_KAFKA_ADMIN_OP_DELETETOPICS,\n  RD_KAFKA_ADMIN_OP_CREATEPARTITIONS,\n  RD_KAFKA_ADMIN_OP_ALTERCONFIGS,\n  RD_KAFKA_ADMIN_OP_DESCRIBECONFIGS,\n  RD_KAFKA_ADMIN_OP__CNT,\n} rd_kafka_admin_op_t;\ntypedef struct rd_kafka_AdminOptions_s rd_kafka_AdminOptions_t;\nrd_kafka_AdminOptions_t *rd_kafka_AdminOptions_new(rd_kafka_t *rk, rd_kafka_admin_op_t for_api);\nvoid rd_kafka_AdminOptions_destroy(rd_kafka_AdminOptions_t *options);\nrd_kafka_resp_err_t rd_kafka_AdminOptions_set_request_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_AdminOptions_set_operation_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_AdminOptions_set_validate_only(rd_kafka_AdminOptions_t *options, int true_or_false, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_AdminOptions_set_broker(rd_kafka_AdminOptions_t *options, int32_t broker_id, char *errstr, size_t errstr_size);\nvoid rd_kafka_AdminOptions_set_opaque(rd_kafka_AdminOptions_t *options, void *ev_opaque);\ntypedef struct rd_kafka_NewTopic_s rd_kafka_NewTopic_t;\nrd_kafka_NewTopic_t *rd_kafka_NewTopic_new(const char *topic, int num_partitions, int replication_factor, char *errstr, size_t errstr_size);\nvoid rd_kafka_NewTopic_destroy(rd_kafka_NewTopic_t *new_topic);\nvoid rd_kafka_NewTopic_destroy_array(rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt);\nrd_kafka_resp_err_t rd_kafka_NewTopic_set_replica_assignment(rd_kafka_NewTopic_t *new_topic, int32_t partition, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_NewTopic_set_config(rd_kafka_NewTopic_t *new_topic, const char *name, const char *value);\nvoid rd_kafka_CreateTopics(rd_kafka_t *rk, rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_topic_result_t **rd_kafka_CreateTopics_result_topics(const rd_kafka_CreateTopics_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_DeleteTopic_s rd_kafka_DeleteTopic_t;\nrd_kafka_DeleteTopic_t *rd_kafka_DeleteTopic_new(const char *topic);\nvoid rd_kafka_DeleteTopic_destroy(rd_kafka_DeleteTopic_t *del_topic);\nvoid rd_kafka_DeleteTopic_destroy_array(rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt);\nvoid rd_kafka_DeleteTopics(rd_kafka_t *rk, rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_topic_result_t **rd_kafka_DeleteTopics_result_topics(const rd_kafka_DeleteTopics_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_NewPartitions_s rd_kafka_NewPartitions_t;\nrd_kafka_NewPartitions_t *rd_kafka_NewPartitions_new(const char *topic, size_t new_total_cnt, char *errstr, size_t errstr_size);\nvoid rd_kafka_NewPartitions_destroy(rd_kafka_NewPartitions_t *new_parts);\nvoid rd_kafka_NewPartitions_destroy_array(rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt);\nrd_kafka_resp_err_t rd_kafka_NewPartitions_set_replica_assignment(rd_kafka_NewPartitions_t *new_parts, int32_t new_partition_idx, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);\nvoid rd_kafka_CreatePartitions(rd_kafka_t *rk, rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_topic_result_t **rd_kafka_CreatePartitions_result_topics(const rd_kafka_CreatePartitions_result_t *result, size_t *cntp);\ntypedef enum rd_kafka_ConfigSource_t {\n  RD_KAFKA_CONFIG_SOURCE_UNKNOWN_CONFIG = 0,\n  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_TOPIC_CONFIG = 1,\n  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_BROKER_CONFIG = 2,\n  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_DEFAULT_BROKER_CONFIG = 3,\n  RD_KAFKA_CONFIG_SOURCE_STATIC_BROKER_CONFIG = 4,\n  RD_KAFKA_CONFIG_SOURCE_DEFAULT_CONFIG = 5,\n  RD_KAFKA_CONFIG_SOURCE__CNT,\n} rd_kafka_ConfigSource_t;\nconst char *rd_kafka_ConfigSource_name(rd_kafka_ConfigSource_t confsource);\ntypedef struct rd_kafka_ConfigEntry_s rd_kafka_ConfigEntry_t;\nconst char *rd_kafka_ConfigEntry_name(const rd_kafka_ConfigEntry_t *entry);\nconst char *rd_kafka_ConfigEntry_value(const rd_kafka_ConfigEntry_t *entry);\nrd_kafka_ConfigSource_t rd_kafka_ConfigEntry_source(const rd_kafka_ConfigEntry_t *entry);\nint rd_kafka_ConfigEntry_is_read_only(const rd_kafka_ConfigEntry_t *entry);\nint rd_kafka_ConfigEntry_is_default(const rd_kafka_ConfigEntry_t *entry);\nint rd_kafka_ConfigEntry_is_sensitive(const rd_kafka_ConfigEntry_t *entry);\nint rd_kafka_ConfigEntry_is_synonym(const rd_kafka_ConfigEntry_t *entry);\nconst rd_kafka_ConfigEntry_t **rd_kafka_ConfigEntry_synonyms(const rd_kafka_ConfigEntry_t *entry, size_t *cntp);\ntypedef enum rd_kafka_ResourceType_t {\n  RD_KAFKA_RESOURCE_UNKNOWN = 0,\n  RD_KAFKA_RESOURCE_ANY = 1,\n  RD_KAFKA_RESOURCE_TOPIC = 2,\n  RD_KAFKA_RESOURCE_GROUP = 3,\n  RD_KAFKA_RESOURCE_BROKER = 4,\n  RD_KAFKA_RESOURCE__CNT,\n} rd_kafka_ResourceType_t;\nconst char *rd_kafka_ResourceType_name(rd_kafka_ResourceType_t restype);\ntypedef struct rd_kafka_ConfigResource_s rd_kafka_ConfigResource_t;\nrd_kafka_ConfigResource_t *rd_kafka_ConfigResource_new(rd_kafka_ResourceType_t restype, const char *resname);\nvoid rd_kafka_ConfigResource_destroy(rd_kafka_ConfigResource_t *config);\nvoid rd_kafka_ConfigResource_destroy_array(rd_kafka_ConfigResource_t **config, size_t config_cnt);\nrd_kafka_resp_err_t rd_kafka_ConfigResource_set_config(rd_kafka_ConfigResource_t *config, const char *name, const char *value);\nconst rd_kafka_ConfigEntry_t **rd_kafka_ConfigResource_configs(const rd_kafka_ConfigResource_t *config, size_t *cntp);\nrd_kafka_ResourceType_t rd_kafka_ConfigResource_type(const rd_kafka_ConfigResource_t *config);\nconst char *rd_kafka_ConfigResource_name(const rd_kafka_ConfigResource_t *config);\nrd_kafka_resp_err_t rd_kafka_ConfigResource_error(const rd_kafka_ConfigResource_t *config);\nconst char *rd_kafka_ConfigResource_error_string(const rd_kafka_ConfigResource_t *config);\nvoid rd_kafka_AlterConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_ConfigResource_t **rd_kafka_AlterConfigs_result_resources(const rd_kafka_AlterConfigs_result_t *result, size_t *cntp);\nvoid rd_kafka_DescribeConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_ConfigResource_t **rd_kafka_DescribeConfigs_result_resources(const rd_kafka_DescribeConfigs_result_t *result, size_t *cntp);\nrd_kafka_resp_err_t rd_kafka_oauthbearer_set_token(rd_kafka_t *rk, const char *token_value, int64_t md_lifetime_ms, const char *md_principal_name, const char **extensions, size_t extension_size, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_oauthbearer_set_token_failure(rd_kafka_t *rk, const char *errstr);\nrd_kafka_error_t *rd_kafka_init_transactions(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_error_t *rd_kafka_begin_transaction(rd_kafka_t *rk);\nrd_kafka_error_t *rd_kafka_send_offsets_to_transaction(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, const rd_kafka_consumer_group_metadata_t *cgmetadata, int timeout_ms);\nrd_kafka_error_t *rd_kafka_commit_transaction(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_error_t *rd_kafka_abort_transaction(rd_kafka_t *rk, int timeout_ms);\ntypedef struct rd_kafka_mock_cluster_s rd_kafka_mock_cluster_t;\nrd_kafka_mock_cluster_t *rd_kafka_mock_cluster_new(rd_kafka_t *rk, int broker_cnt);\nvoid rd_kafka_mock_cluster_destroy(rd_kafka_mock_cluster_t *mcluster);\nrd_kafka_t *rd_kafka_mock_cluster_handle(const rd_kafka_mock_cluster_t *mcluster);\nrd_kafka_mock_cluster_t *rd_kafka_handle_mock_cluster(const rd_kafka_t *rk);\nconst char *rd_kafka_mock_cluster_bootstraps(const rd_kafka_mock_cluster_t *mcluster);\nvoid rd_kafka_mock_push_request_errors(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, size_t cnt, ...);\nrd_kafka_resp_err_t rd_kafka_mock_broker_push_request_errors(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int16_t ApiKey, size_t cnt, ...);\nvoid rd_kafka_mock_topic_set_error(rd_kafka_mock_cluster_t *mcluster, const char *topic, rd_kafka_resp_err_t err);\nrd_kafka_resp_err_t rd_kafka_mock_topic_create(rd_kafka_mock_cluster_t *mcluster, const char *topic, int partition_cnt, int replication_factor);\nrd_kafka_resp_err_t rd_kafka_mock_partition_set_leader(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id);\nrd_kafka_resp_err_t rd_kafka_mock_partition_set_follower(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id);\nrd_kafka_resp_err_t rd_kafka_mock_partition_set_follower_wmarks(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int64_t lo, int64_t hi);\nrd_kafka_resp_err_t rd_kafka_mock_broker_set_down(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id);\nrd_kafka_resp_err_t rd_kafka_mock_broker_set_up(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id);\nrd_kafka_resp_err_t rd_kafka_mock_broker_set_rtt(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int rtt_ms);\nrd_kafka_resp_err_t rd_kafka_mock_broker_set_rack(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, const char *rack);\nrd_kafka_resp_err_t rd_kafka_mock_coordinator_set(rd_kafka_mock_cluster_t *mcluster, const char *key_type, const char *key, int32_t broker_id);\nrd_kafka_resp_err_t rd_kafka_mock_set_apiversion(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, int16_t MinVersion, int16_t MaxVersion);\n'\n</code></pre> rdkafka.h, rdkafka_mock.h</p>"},{"location":"api/constants/#rd_kafka_version_13","title":"RD_KAFKA_VERSION","text":"<pre><code>public RD_KAFKA_VERSION = 17170687\n</code></pre> <p>librdkafka version </p> <p>Interpreted as hex <code>MM.mm.rr.xx</code>:</p> <ul> <li>MM = Major</li> <li>mm = minor</li> <li>rr = revision</li> <li>xx = pre-release id (0xff is the final release)</li> </ul> <p>E.g.: <code>0x000801ff</code> = 0.8.1</p> RemarksThis value should only be used during compile time, for runtime checks of version use rd_kafka_version()  <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_unsupported_compression_type_13","title":"RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE","text":"<pre><code>public RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76\n</code></pre> <p>Unsupported compression type </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_end_all_13","title":"RD_KAFKA_RESP_ERR_END_ALL","text":"<p><pre><code>public RD_KAFKA_RESP_ERR_END_ALL = 98\n</code></pre> enum rd_kafka_resp_err_t</p>"},{"location":"api/constants/#rd_kafka_admin_op__cnt_13","title":"RD_KAFKA_ADMIN_OP__CNT","text":"<pre><code>public RD_KAFKA_ADMIN_OP__CNT = 9\n</code></pre> <p>Number of ops defined </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe </li> </ul>"},{"location":"api/constants/#rd_kafka_resource__cnt_13","title":"RD_KAFKA_RESOURCE__CNT","text":"<pre><code>public RD_KAFKA_RESOURCE__CNT = 5\n</code></pre> <p>Number of resource types defined </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#acca83a66d7783ff7683ed2691cc907c9 </li> </ul>"},{"location":"api/constants/#rd_kafka_cdef_13","title":"RD_KAFKA_CDEF","text":"<p><pre><code>public RD_KAFKA_CDEF = 'typedef long int ssize_t;\ntypedef struct _IO_FILE FILE;\ntypedef long int mode_t;\ntypedef signed int int16_t;\ntypedef unsigned int uint16_t;\ntypedef signed int int32_t;\ntypedef signed long int int64_t;\nint rd_kafka_version(void);\nconst char *rd_kafka_version_str(void);\ntypedef enum rd_kafka_type_t {\n  RD_KAFKA_PRODUCER,\n  RD_KAFKA_CONSUMER,\n} rd_kafka_type_t;\ntypedef enum rd_kafka_timestamp_type_t {\n  RD_KAFKA_TIMESTAMP_NOT_AVAILABLE,\n  RD_KAFKA_TIMESTAMP_CREATE_TIME,\n  RD_KAFKA_TIMESTAMP_LOG_APPEND_TIME,\n} rd_kafka_timestamp_type_t;\nconst char *rd_kafka_get_debug_contexts(void);\ntypedef struct rd_kafka_s rd_kafka_t;\ntypedef struct rd_kafka_topic_s rd_kafka_topic_t;\ntypedef struct rd_kafka_conf_s rd_kafka_conf_t;\ntypedef struct rd_kafka_topic_conf_s rd_kafka_topic_conf_t;\ntypedef struct rd_kafka_queue_s rd_kafka_queue_t;\ntypedef struct rd_kafka_op_s rd_kafka_event_t;\ntypedef struct rd_kafka_topic_result_s rd_kafka_topic_result_t;\ntypedef struct rd_kafka_consumer_group_metadata_s rd_kafka_consumer_group_metadata_t;\ntypedef struct rd_kafka_error_s {\n  unsigned int code;\n  char *errstr;\n  unsigned char fatal;\n  unsigned char retriable;\n  unsigned char txn_requires_abort;\n} rd_kafka_error_t;\ntypedef struct rd_kafka_headers_s rd_kafka_headers_t;\ntypedef struct rd_kafka_group_result_s rd_kafka_group_result_t;\ntypedef enum {\n  RD_KAFKA_RESP_ERR__BEGIN = (- 200),\n  RD_KAFKA_RESP_ERR__BAD_MSG = (- 199),\n  RD_KAFKA_RESP_ERR__BAD_COMPRESSION = (- 198),\n  RD_KAFKA_RESP_ERR__DESTROY = (- 197),\n  RD_KAFKA_RESP_ERR__FAIL = (- 196),\n  RD_KAFKA_RESP_ERR__TRANSPORT = (- 195),\n  RD_KAFKA_RESP_ERR__CRIT_SYS_RESOURCE = (- 194),\n  RD_KAFKA_RESP_ERR__RESOLVE = (- 193),\n  RD_KAFKA_RESP_ERR__MSG_TIMED_OUT = (- 192),\n  RD_KAFKA_RESP_ERR__PARTITION_EOF = (- 191),\n  RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION = (- 190),\n  RD_KAFKA_RESP_ERR__FS = (- 189),\n  RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC = (- 188),\n  RD_KAFKA_RESP_ERR__ALL_BROKERS_DOWN = (- 187),\n  RD_KAFKA_RESP_ERR__INVALID_ARG = (- 186),\n  RD_KAFKA_RESP_ERR__TIMED_OUT = (- 185),\n  RD_KAFKA_RESP_ERR__QUEUE_FULL = (- 184),\n  RD_KAFKA_RESP_ERR__ISR_INSUFF = (- 183),\n  RD_KAFKA_RESP_ERR__NODE_UPDATE = (- 182),\n  RD_KAFKA_RESP_ERR__SSL = (- 181),\n  RD_KAFKA_RESP_ERR__WAIT_COORD = (- 180),\n  RD_KAFKA_RESP_ERR__UNKNOWN_GROUP = (- 179),\n  RD_KAFKA_RESP_ERR__IN_PROGRESS = (- 178),\n  RD_KAFKA_RESP_ERR__PREV_IN_PROGRESS = (- 177),\n  RD_KAFKA_RESP_ERR__EXISTING_SUBSCRIPTION = (- 176),\n  RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS = (- 175),\n  RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS = (- 174),\n  RD_KAFKA_RESP_ERR__CONFLICT = (- 173),\n  RD_KAFKA_RESP_ERR__STATE = (- 172),\n  RD_KAFKA_RESP_ERR__UNKNOWN_PROTOCOL = (- 171),\n  RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED = (- 170),\n  RD_KAFKA_RESP_ERR__AUTHENTICATION = (- 169),\n  RD_KAFKA_RESP_ERR__NO_OFFSET = (- 168),\n  RD_KAFKA_RESP_ERR__OUTDATED = (- 167),\n  RD_KAFKA_RESP_ERR__TIMED_OUT_QUEUE = (- 166),\n  RD_KAFKA_RESP_ERR__UNSUPPORTED_FEATURE = (- 165),\n  RD_KAFKA_RESP_ERR__WAIT_CACHE = (- 164),\n  RD_KAFKA_RESP_ERR__INTR = (- 163),\n  RD_KAFKA_RESP_ERR__KEY_SERIALIZATION = (- 162),\n  RD_KAFKA_RESP_ERR__VALUE_SERIALIZATION = (- 161),\n  RD_KAFKA_RESP_ERR__KEY_DESERIALIZATION = (- 160),\n  RD_KAFKA_RESP_ERR__VALUE_DESERIALIZATION = (- 159),\n  RD_KAFKA_RESP_ERR__PARTIAL = (- 158),\n  RD_KAFKA_RESP_ERR__READ_ONLY = (- 157),\n  RD_KAFKA_RESP_ERR__NOENT = (- 156),\n  RD_KAFKA_RESP_ERR__UNDERFLOW = (- 155),\n  RD_KAFKA_RESP_ERR__INVALID_TYPE = (- 154),\n  RD_KAFKA_RESP_ERR__RETRY = (- 153),\n  RD_KAFKA_RESP_ERR__PURGE_QUEUE = (- 152),\n  RD_KAFKA_RESP_ERR__PURGE_INFLIGHT = (- 151),\n  RD_KAFKA_RESP_ERR__FATAL = (- 150),\n  RD_KAFKA_RESP_ERR__INCONSISTENT = (- 149),\n  RD_KAFKA_RESP_ERR__GAPLESS_GUARANTEE = (- 148),\n  RD_KAFKA_RESP_ERR__MAX_POLL_EXCEEDED = (- 147),\n  RD_KAFKA_RESP_ERR__UNKNOWN_BROKER = (- 146),\n  RD_KAFKA_RESP_ERR__NOT_CONFIGURED = (- 145),\n  RD_KAFKA_RESP_ERR__FENCED = (- 144),\n  RD_KAFKA_RESP_ERR__APPLICATION = (- 143),\n  RD_KAFKA_RESP_ERR__ASSIGNMENT_LOST = (- 142),\n  RD_KAFKA_RESP_ERR__NOOP = (- 141),\n  RD_KAFKA_RESP_ERR__END = (- 100),\n  RD_KAFKA_RESP_ERR_UNKNOWN = (- 1),\n  RD_KAFKA_RESP_ERR_NO_ERROR = 0,\n  RD_KAFKA_RESP_ERR_OFFSET_OUT_OF_RANGE = 1,\n  RD_KAFKA_RESP_ERR_INVALID_MSG = 2,\n  RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART = 3,\n  RD_KAFKA_RESP_ERR_INVALID_MSG_SIZE = 4,\n  RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE = 5,\n  RD_KAFKA_RESP_ERR_NOT_LEADER_FOR_PARTITION = 6,\n  RD_KAFKA_RESP_ERR_REQUEST_TIMED_OUT = 7,\n  RD_KAFKA_RESP_ERR_BROKER_NOT_AVAILABLE = 8,\n  RD_KAFKA_RESP_ERR_REPLICA_NOT_AVAILABLE = 9,\n  RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE = 10,\n  RD_KAFKA_RESP_ERR_STALE_CTRL_EPOCH = 11,\n  RD_KAFKA_RESP_ERR_OFFSET_METADATA_TOO_LARGE = 12,\n  RD_KAFKA_RESP_ERR_NETWORK_EXCEPTION = 13,\n  RD_KAFKA_RESP_ERR_COORDINATOR_LOAD_IN_PROGRESS = 14,\n  RD_KAFKA_RESP_ERR_COORDINATOR_NOT_AVAILABLE = 15,\n  RD_KAFKA_RESP_ERR_NOT_COORDINATOR = 16,\n  RD_KAFKA_RESP_ERR_TOPIC_EXCEPTION = 17,\n  RD_KAFKA_RESP_ERR_RECORD_LIST_TOO_LARGE = 18,\n  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS = 19,\n  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS_AFTER_APPEND = 20,\n  RD_KAFKA_RESP_ERR_INVALID_REQUIRED_ACKS = 21,\n  RD_KAFKA_RESP_ERR_ILLEGAL_GENERATION = 22,\n  RD_KAFKA_RESP_ERR_INCONSISTENT_GROUP_PROTOCOL = 23,\n  RD_KAFKA_RESP_ERR_INVALID_GROUP_ID = 24,\n  RD_KAFKA_RESP_ERR_UNKNOWN_MEMBER_ID = 25,\n  RD_KAFKA_RESP_ERR_INVALID_SESSION_TIMEOUT = 26,\n  RD_KAFKA_RESP_ERR_REBALANCE_IN_PROGRESS = 27,\n  RD_KAFKA_RESP_ERR_INVALID_COMMIT_OFFSET_SIZE = 28,\n  RD_KAFKA_RESP_ERR_TOPIC_AUTHORIZATION_FAILED = 29,\n  RD_KAFKA_RESP_ERR_GROUP_AUTHORIZATION_FAILED = 30,\n  RD_KAFKA_RESP_ERR_CLUSTER_AUTHORIZATION_FAILED = 31,\n  RD_KAFKA_RESP_ERR_INVALID_TIMESTAMP = 32,\n  RD_KAFKA_RESP_ERR_UNSUPPORTED_SASL_MECHANISM = 33,\n  RD_KAFKA_RESP_ERR_ILLEGAL_SASL_STATE = 34,\n  RD_KAFKA_RESP_ERR_UNSUPPORTED_VERSION = 35,\n  RD_KAFKA_RESP_ERR_TOPIC_ALREADY_EXISTS = 36,\n  RD_KAFKA_RESP_ERR_INVALID_PARTITIONS = 37,\n  RD_KAFKA_RESP_ERR_INVALID_REPLICATION_FACTOR = 38,\n  RD_KAFKA_RESP_ERR_INVALID_REPLICA_ASSIGNMENT = 39,\n  RD_KAFKA_RESP_ERR_INVALID_CONFIG = 40,\n  RD_KAFKA_RESP_ERR_NOT_CONTROLLER = 41,\n  RD_KAFKA_RESP_ERR_INVALID_REQUEST = 42,\n  RD_KAFKA_RESP_ERR_UNSUPPORTED_FOR_MESSAGE_FORMAT = 43,\n  RD_KAFKA_RESP_ERR_POLICY_VIOLATION = 44,\n  RD_KAFKA_RESP_ERR_OUT_OF_ORDER_SEQUENCE_NUMBER = 45,\n  RD_KAFKA_RESP_ERR_DUPLICATE_SEQUENCE_NUMBER = 46,\n  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_EPOCH = 47,\n  RD_KAFKA_RESP_ERR_INVALID_TXN_STATE = 48,\n  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_ID_MAPPING = 49,\n  RD_KAFKA_RESP_ERR_INVALID_TRANSACTION_TIMEOUT = 50,\n  RD_KAFKA_RESP_ERR_CONCURRENT_TRANSACTIONS = 51,\n  RD_KAFKA_RESP_ERR_TRANSACTION_COORDINATOR_FENCED = 52,\n  RD_KAFKA_RESP_ERR_TRANSACTIONAL_ID_AUTHORIZATION_FAILED = 53,\n  RD_KAFKA_RESP_ERR_SECURITY_DISABLED = 54,\n  RD_KAFKA_RESP_ERR_OPERATION_NOT_ATTEMPTED = 55,\n  RD_KAFKA_RESP_ERR_KAFKA_STORAGE_ERROR = 56,\n  RD_KAFKA_RESP_ERR_LOG_DIR_NOT_FOUND = 57,\n  RD_KAFKA_RESP_ERR_SASL_AUTHENTICATION_FAILED = 58,\n  RD_KAFKA_RESP_ERR_UNKNOWN_PRODUCER_ID = 59,\n  RD_KAFKA_RESP_ERR_REASSIGNMENT_IN_PROGRESS = 60,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTH_DISABLED = 61,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_NOT_FOUND = 62,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_OWNER_MISMATCH = 63,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_REQUEST_NOT_ALLOWED = 64,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTHORIZATION_FAILED = 65,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_EXPIRED = 66,\n  RD_KAFKA_RESP_ERR_INVALID_PRINCIPAL_TYPE = 67,\n  RD_KAFKA_RESP_ERR_NON_EMPTY_GROUP = 68,\n  RD_KAFKA_RESP_ERR_GROUP_ID_NOT_FOUND = 69,\n  RD_KAFKA_RESP_ERR_FETCH_SESSION_ID_NOT_FOUND = 70,\n  RD_KAFKA_RESP_ERR_INVALID_FETCH_SESSION_EPOCH = 71,\n  RD_KAFKA_RESP_ERR_LISTENER_NOT_FOUND = 72,\n  RD_KAFKA_RESP_ERR_TOPIC_DELETION_DISABLED = 73,\n  RD_KAFKA_RESP_ERR_FENCED_LEADER_EPOCH = 74,\n  RD_KAFKA_RESP_ERR_UNKNOWN_LEADER_EPOCH = 75,\n  RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76,\n  RD_KAFKA_RESP_ERR_STALE_BROKER_EPOCH = 77,\n  RD_KAFKA_RESP_ERR_OFFSET_NOT_AVAILABLE = 78,\n  RD_KAFKA_RESP_ERR_MEMBER_ID_REQUIRED = 79,\n  RD_KAFKA_RESP_ERR_PREFERRED_LEADER_NOT_AVAILABLE = 80,\n  RD_KAFKA_RESP_ERR_GROUP_MAX_SIZE_REACHED = 81,\n  RD_KAFKA_RESP_ERR_FENCED_INSTANCE_ID = 82,\n  RD_KAFKA_RESP_ERR_ELIGIBLE_LEADERS_NOT_AVAILABLE = 83,\n  RD_KAFKA_RESP_ERR_ELECTION_NOT_NEEDED = 84,\n  RD_KAFKA_RESP_ERR_NO_REASSIGNMENT_IN_PROGRESS = 85,\n  RD_KAFKA_RESP_ERR_GROUP_SUBSCRIBED_TO_TOPIC = 86,\n  RD_KAFKA_RESP_ERR_INVALID_RECORD = 87,\n  RD_KAFKA_RESP_ERR_UNSTABLE_OFFSET_COMMIT = 88,\n  RD_KAFKA_RESP_ERR_THROTTLING_QUOTA_EXCEEDED = 89,\n  RD_KAFKA_RESP_ERR_PRODUCER_FENCED = 90,\n  RD_KAFKA_RESP_ERR_RESOURCE_NOT_FOUND = 91,\n  RD_KAFKA_RESP_ERR_DUPLICATE_RESOURCE = 92,\n  RD_KAFKA_RESP_ERR_UNACCEPTABLE_CREDENTIAL = 93,\n  RD_KAFKA_RESP_ERR_INCONSISTENT_VOTER_SET = 94,\n  RD_KAFKA_RESP_ERR_INVALID_UPDATE_VERSION = 95,\n  RD_KAFKA_RESP_ERR_FEATURE_UPDATE_FAILED = 96,\n  RD_KAFKA_RESP_ERR_PRINCIPAL_DESERIALIZATION_FAILURE = 97,\n  RD_KAFKA_RESP_ERR_END_ALL,\n} rd_kafka_resp_err_t;\nstruct rd_kafka_err_desc {\n  rd_kafka_resp_err_t code;\n  char *name;\n  char *desc;\n};\nvoid rd_kafka_get_err_descs(const struct rd_kafka_err_desc **errdescs, size_t *cntp);\nconst char *rd_kafka_err2str(rd_kafka_resp_err_t err);\nconst char *rd_kafka_err2name(rd_kafka_resp_err_t err);\nrd_kafka_resp_err_t rd_kafka_last_error(void);\nrd_kafka_resp_err_t rd_kafka_errno2err(int errnox);\nint rd_kafka_errno(void);\nrd_kafka_resp_err_t rd_kafka_fatal_error(rd_kafka_t *rk, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_test_fatal_error(rd_kafka_t *rk, rd_kafka_resp_err_t err, const char *reason);\nrd_kafka_resp_err_t rd_kafka_error_code(const rd_kafka_error_t *error);\nconst char *rd_kafka_error_name(const rd_kafka_error_t *error);\nconst char *rd_kafka_error_string(const rd_kafka_error_t *error);\nint rd_kafka_error_is_fatal(const rd_kafka_error_t *error);\nint rd_kafka_error_is_retriable(const rd_kafka_error_t *error);\nint rd_kafka_error_txn_requires_abort(const rd_kafka_error_t *error);\nvoid rd_kafka_error_destroy(rd_kafka_error_t *error);\nrd_kafka_error_t *rd_kafka_error_new(rd_kafka_resp_err_t code, const char *fmt, ...);\ntypedef struct rd_kafka_topic_partition_s {\n  char *topic;\n  int32_t partition;\n  int64_t offset;\n  void *metadata;\n  size_t metadata_size;\n  void *opaque;\n  rd_kafka_resp_err_t err;\n  void *_private;\n} rd_kafka_topic_partition_t;\nvoid rd_kafka_topic_partition_destroy(rd_kafka_topic_partition_t *rktpar);\ntypedef struct rd_kafka_topic_partition_list_s {\n  int cnt;\n  int size;\n  rd_kafka_topic_partition_t *elems;\n} rd_kafka_topic_partition_list_t;\nrd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_new(int size);\nvoid rd_kafka_topic_partition_list_destroy(rd_kafka_topic_partition_list_t *rkparlist);\nrd_kafka_topic_partition_t *rd_kafka_topic_partition_list_add(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);\nvoid rd_kafka_topic_partition_list_add_range(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t start, int32_t stop);\nint rd_kafka_topic_partition_list_del(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);\nint rd_kafka_topic_partition_list_del_by_idx(rd_kafka_topic_partition_list_t *rktparlist, int idx);\nrd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_copy(const rd_kafka_topic_partition_list_t *src);\nrd_kafka_resp_err_t rd_kafka_topic_partition_list_set_offset(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition, int64_t offset);\nrd_kafka_topic_partition_t *rd_kafka_topic_partition_list_find(const rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);\nvoid rd_kafka_topic_partition_list_sort(rd_kafka_topic_partition_list_t *rktparlist, int (*cmp)(const void *a, const void *b, void *cmp_opaque), void *cmp_opaque);\ntypedef enum rd_kafka_vtype_t {\n  RD_KAFKA_VTYPE_END,\n  RD_KAFKA_VTYPE_TOPIC,\n  RD_KAFKA_VTYPE_RKT,\n  RD_KAFKA_VTYPE_PARTITION,\n  RD_KAFKA_VTYPE_VALUE,\n  RD_KAFKA_VTYPE_KEY,\n  RD_KAFKA_VTYPE_OPAQUE,\n  RD_KAFKA_VTYPE_MSGFLAGS,\n  RD_KAFKA_VTYPE_TIMESTAMP,\n  RD_KAFKA_VTYPE_HEADER,\n  RD_KAFKA_VTYPE_HEADERS,\n} rd_kafka_vtype_t;\ntypedef struct rd_kafka_vu_s {\n  rd_kafka_vtype_t vtype;\n  union {\n    char *cstr;\n    rd_kafka_topic_t *rkt;\n    int i;\n    int32_t i32;\n    int64_t i64;\n    struct {\n      void *ptr;\n      size_t size;\n    } mem;\n    struct {\n      char *name;\n      void *val;\n      ssize_t size;\n    } header;\n    rd_kafka_headers_t *headers;\n    void *ptr;\n    char _pad[64];\n  } u;\n} rd_kafka_vu_t;\nrd_kafka_headers_t *rd_kafka_headers_new(size_t initial_count);\nvoid rd_kafka_headers_destroy(rd_kafka_headers_t *hdrs);\nrd_kafka_headers_t *rd_kafka_headers_copy(const rd_kafka_headers_t *src);\nrd_kafka_resp_err_t rd_kafka_header_add(rd_kafka_headers_t *hdrs, const char *name, ssize_t name_size, const void *value, ssize_t value_size);\nrd_kafka_resp_err_t rd_kafka_header_remove(rd_kafka_headers_t *hdrs, const char *name);\nrd_kafka_resp_err_t rd_kafka_header_get_last(const rd_kafka_headers_t *hdrs, const char *name, const void **valuep, size_t *sizep);\nrd_kafka_resp_err_t rd_kafka_header_get(const rd_kafka_headers_t *hdrs, size_t idx, const char *name, const void **valuep, size_t *sizep);\nrd_kafka_resp_err_t rd_kafka_header_get_all(const rd_kafka_headers_t *hdrs, size_t idx, const char **namep, const void **valuep, size_t *sizep);\ntypedef struct rd_kafka_message_s {\n  rd_kafka_resp_err_t err;\n  rd_kafka_topic_t *rkt;\n  int32_t partition;\n  void *payload;\n  size_t len;\n  void *key;\n  size_t key_len;\n  int64_t offset;\n  void *_private;\n} rd_kafka_message_t;\nvoid rd_kafka_message_destroy(rd_kafka_message_t *rkmessage);\nconst char *rd_kafka_message_errstr(const rd_kafka_message_t *rkmessage);\nint64_t rd_kafka_message_timestamp(const rd_kafka_message_t *rkmessage, rd_kafka_timestamp_type_t *tstype);\nint64_t rd_kafka_message_latency(const rd_kafka_message_t *rkmessage);\nint32_t rd_kafka_message_broker_id(const rd_kafka_message_t *rkmessage);\nrd_kafka_resp_err_t rd_kafka_message_headers(const rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);\nrd_kafka_resp_err_t rd_kafka_message_detach_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);\nvoid rd_kafka_message_set_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t *hdrs);\nsize_t rd_kafka_header_cnt(const rd_kafka_headers_t *hdrs);\ntypedef enum {\n  RD_KAFKA_MSG_STATUS_NOT_PERSISTED = 0,\n  RD_KAFKA_MSG_STATUS_POSSIBLY_PERSISTED = 1,\n  RD_KAFKA_MSG_STATUS_PERSISTED = 2,\n} rd_kafka_msg_status_t;\nrd_kafka_msg_status_t rd_kafka_message_status(const rd_kafka_message_t *rkmessage);\ntypedef enum {\n  RD_KAFKA_CONF_UNKNOWN = (- 2),\n  RD_KAFKA_CONF_INVALID = (- 1),\n  RD_KAFKA_CONF_OK = 0,\n} rd_kafka_conf_res_t;\nrd_kafka_conf_t *rd_kafka_conf_new(void);\nvoid rd_kafka_conf_destroy(rd_kafka_conf_t *conf);\nrd_kafka_conf_t *rd_kafka_conf_dup(const rd_kafka_conf_t *conf);\nrd_kafka_conf_t *rd_kafka_conf_dup_filter(const rd_kafka_conf_t *conf, size_t filter_cnt, const char **filter);\nconst rd_kafka_conf_t *rd_kafka_conf(rd_kafka_t *rk);\nrd_kafka_conf_res_t rd_kafka_conf_set(rd_kafka_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);\nvoid rd_kafka_conf_set_events(rd_kafka_conf_t *conf, int events);\nvoid rd_kafka_conf_set_background_event_cb(rd_kafka_conf_t *conf, void (*event_cb)(rd_kafka_t *rk, rd_kafka_event_t *rkev, void *opaque));\nvoid rd_kafka_conf_set_dr_cb(rd_kafka_conf_t *conf, void (*dr_cb)(rd_kafka_t *rk, void *payload, size_t len, rd_kafka_resp_err_t err, void *opaque, void *msg_opaque));\nvoid rd_kafka_conf_set_dr_msg_cb(rd_kafka_conf_t *conf, void (*dr_msg_cb)(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, void *opaque));\nvoid rd_kafka_conf_set_consume_cb(rd_kafka_conf_t *conf, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *opaque));\nvoid rd_kafka_conf_set_rebalance_cb(rd_kafka_conf_t *conf, void (*rebalance_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *partitions, void *opaque));\nvoid rd_kafka_conf_set_offset_commit_cb(rd_kafka_conf_t *conf, void (*offset_commit_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *opaque));\nvoid rd_kafka_conf_set_error_cb(rd_kafka_conf_t *conf, void (*error_cb)(rd_kafka_t *rk, int err, const char *reason, void *opaque));\nvoid rd_kafka_conf_set_throttle_cb(rd_kafka_conf_t *conf, void (*throttle_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int throttle_time_ms, void *opaque));\nvoid rd_kafka_conf_set_log_cb(rd_kafka_conf_t *conf, void (*log_cb)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));\nvoid rd_kafka_conf_set_stats_cb(rd_kafka_conf_t *conf, int (*stats_cb)(rd_kafka_t *rk, char *json, size_t json_len, void *opaque));\nvoid rd_kafka_conf_set_oauthbearer_token_refresh_cb(rd_kafka_conf_t *conf, void (*oauthbearer_token_refresh_cb)(rd_kafka_t *rk, const char *oauthbearer_config, void *opaque));\nvoid rd_kafka_conf_set_socket_cb(rd_kafka_conf_t *conf, int (*socket_cb)(int domain, int type, int protocol, void *opaque));\nvoid rd_kafka_conf_set_connect_cb(rd_kafka_conf_t *conf, int (*connect_cb)(int sockfd, const struct sockaddr *addr, int addrlen, const char *id, void *opaque));\nvoid rd_kafka_conf_set_closesocket_cb(rd_kafka_conf_t *conf, int (*closesocket_cb)(int sockfd, void *opaque));\nrd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert_verify_cb(rd_kafka_conf_t *conf, int (*ssl_cert_verify_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int *x509_error, int depth, const char *buf, size_t size, char *errstr, size_t errstr_size, void *opaque));\ntypedef enum rd_kafka_cert_type_t {\n  RD_KAFKA_CERT_PUBLIC_KEY,\n  RD_KAFKA_CERT_PRIVATE_KEY,\n  RD_KAFKA_CERT_CA,\n  RD_KAFKA_CERT__CNT,\n} rd_kafka_cert_type_t;\ntypedef enum rd_kafka_cert_enc_t {\n  RD_KAFKA_CERT_ENC_PKCS12,\n  RD_KAFKA_CERT_ENC_DER,\n  RD_KAFKA_CERT_ENC_PEM,\n  RD_KAFKA_CERT_ENC__CNT,\n} rd_kafka_cert_enc_t;\nrd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert(rd_kafka_conf_t *conf, rd_kafka_cert_type_t cert_type, rd_kafka_cert_enc_t cert_enc, const void *buffer, size_t size, char *errstr, size_t errstr_size);\nvoid rd_kafka_conf_set_opaque(rd_kafka_conf_t *conf, void *opaque);\nvoid *rd_kafka_opaque(const rd_kafka_t *rk);\nvoid rd_kafka_conf_set_default_topic_conf(rd_kafka_conf_t *conf, rd_kafka_topic_conf_t *tconf);\nrd_kafka_topic_conf_t *rd_kafka_conf_get_default_topic_conf(rd_kafka_conf_t *conf);\nrd_kafka_conf_res_t rd_kafka_conf_get(const rd_kafka_conf_t *conf, const char *name, char *dest, size_t *dest_size);\nrd_kafka_conf_res_t rd_kafka_topic_conf_get(const rd_kafka_topic_conf_t *conf, const char *name, char *dest, size_t *dest_size);\nconst char **rd_kafka_conf_dump(rd_kafka_conf_t *conf, size_t *cntp);\nconst char **rd_kafka_topic_conf_dump(rd_kafka_topic_conf_t *conf, size_t *cntp);\nvoid rd_kafka_conf_dump_free(const char **arr, size_t cnt);\nvoid rd_kafka_conf_properties_show(FILE *fp);\nrd_kafka_topic_conf_t *rd_kafka_topic_conf_new(void);\nrd_kafka_topic_conf_t *rd_kafka_topic_conf_dup(const rd_kafka_topic_conf_t *conf);\nrd_kafka_topic_conf_t *rd_kafka_default_topic_conf_dup(rd_kafka_t *rk);\nvoid rd_kafka_topic_conf_destroy(rd_kafka_topic_conf_t *topic_conf);\nrd_kafka_conf_res_t rd_kafka_topic_conf_set(rd_kafka_topic_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);\nvoid rd_kafka_topic_conf_set_opaque(rd_kafka_topic_conf_t *conf, void *rkt_opaque);\nvoid rd_kafka_topic_conf_set_partitioner_cb(rd_kafka_topic_conf_t *topic_conf, int32_t (*partitioner)(const rd_kafka_topic_t *rkt, const void *keydata, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque));\nvoid rd_kafka_topic_conf_set_msg_order_cmp(rd_kafka_topic_conf_t *topic_conf, int (*msg_order_cmp)(const rd_kafka_message_t *a, const rd_kafka_message_t *b));\nint rd_kafka_topic_partition_available(const rd_kafka_topic_t *rkt, int32_t partition);\nint32_t rd_kafka_msg_partitioner_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_consistent(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_consistent_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_murmur2(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_murmur2_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_fnv1a(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_fnv1a_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nrd_kafka_t *rd_kafka_new(rd_kafka_type_t type, rd_kafka_conf_t *conf, char *errstr, size_t errstr_size);\nvoid rd_kafka_destroy(rd_kafka_t *rk);\nvoid rd_kafka_destroy_flags(rd_kafka_t *rk, int flags);\nconst char *rd_kafka_name(const rd_kafka_t *rk);\nrd_kafka_type_t rd_kafka_type(const rd_kafka_t *rk);\nchar *rd_kafka_memberid(const rd_kafka_t *rk);\nchar *rd_kafka_clusterid(rd_kafka_t *rk, int timeout_ms);\nint32_t rd_kafka_controllerid(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_topic_t *rd_kafka_topic_new(rd_kafka_t *rk, const char *topic, rd_kafka_topic_conf_t *conf);\nvoid rd_kafka_topic_destroy(rd_kafka_topic_t *rkt);\nconst char *rd_kafka_topic_name(const rd_kafka_topic_t *rkt);\nvoid *rd_kafka_topic_opaque(const rd_kafka_topic_t *rkt);\nint rd_kafka_poll(rd_kafka_t *rk, int timeout_ms);\nvoid rd_kafka_yield(rd_kafka_t *rk);\nrd_kafka_resp_err_t rd_kafka_pause_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_resp_err_t rd_kafka_resume_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_resp_err_t rd_kafka_query_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high, int timeout_ms);\nrd_kafka_resp_err_t rd_kafka_get_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high);\nrd_kafka_resp_err_t rd_kafka_offsets_for_times(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets, int timeout_ms);\nvoid rd_kafka_mem_free(rd_kafka_t *rk, void *ptr);\nrd_kafka_queue_t *rd_kafka_queue_new(rd_kafka_t *rk);\nvoid rd_kafka_queue_destroy(rd_kafka_queue_t *rkqu);\nrd_kafka_queue_t *rd_kafka_queue_get_main(rd_kafka_t *rk);\nrd_kafka_queue_t *rd_kafka_queue_get_consumer(rd_kafka_t *rk);\nrd_kafka_queue_t *rd_kafka_queue_get_partition(rd_kafka_t *rk, const char *topic, int32_t partition);\nrd_kafka_queue_t *rd_kafka_queue_get_background(rd_kafka_t *rk);\nvoid rd_kafka_queue_forward(rd_kafka_queue_t *src, rd_kafka_queue_t *dst);\nrd_kafka_resp_err_t rd_kafka_set_log_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu);\nsize_t rd_kafka_queue_length(rd_kafka_queue_t *rkqu);\nvoid rd_kafka_queue_io_event_enable(rd_kafka_queue_t *rkqu, int fd, const void *payload, size_t size);\nvoid rd_kafka_queue_cb_event_enable(rd_kafka_queue_t *rkqu, void (*event_cb)(rd_kafka_t *rk, void *qev_opaque), void *qev_opaque);\nvoid rd_kafka_queue_yield(rd_kafka_queue_t *rkqu);\nint rd_kafka_consume_start(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);\nint rd_kafka_consume_start_queue(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, rd_kafka_queue_t *rkqu);\nint rd_kafka_consume_stop(rd_kafka_topic_t *rkt, int32_t partition);\nrd_kafka_resp_err_t rd_kafka_seek(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, int timeout_ms);\nrd_kafka_error_t *rd_kafka_seek_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms);\nrd_kafka_message_t *rd_kafka_consume(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms);\nssize_t rd_kafka_consume_batch(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);\nint rd_kafka_consume_callback(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);\nrd_kafka_message_t *rd_kafka_consume_queue(rd_kafka_queue_t *rkqu, int timeout_ms);\nssize_t rd_kafka_consume_batch_queue(rd_kafka_queue_t *rkqu, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);\nint rd_kafka_consume_callback_queue(rd_kafka_queue_t *rkqu, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);\nrd_kafka_resp_err_t rd_kafka_offset_store(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);\nrd_kafka_resp_err_t rd_kafka_offsets_store(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets);\nrd_kafka_resp_err_t rd_kafka_subscribe(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *topics);\nrd_kafka_resp_err_t rd_kafka_unsubscribe(rd_kafka_t *rk);\nrd_kafka_resp_err_t rd_kafka_subscription(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **topics);\nrd_kafka_message_t *rd_kafka_consumer_poll(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_resp_err_t rd_kafka_consumer_close(rd_kafka_t *rk);\nrd_kafka_error_t *rd_kafka_incremental_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_error_t *rd_kafka_incremental_unassign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);\nconst char *rd_kafka_rebalance_protocol(rd_kafka_t *rk);\nrd_kafka_resp_err_t rd_kafka_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_resp_err_t rd_kafka_assignment(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **partitions);\nint rd_kafka_assignment_lost(rd_kafka_t *rk);\nrd_kafka_resp_err_t rd_kafka_commit(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, int async);\nrd_kafka_resp_err_t rd_kafka_commit_message(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, int async);\nrd_kafka_resp_err_t rd_kafka_commit_queue(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_queue_t *rkqu, void (*cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *commit_opaque), void *commit_opaque);\nrd_kafka_resp_err_t rd_kafka_committed(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms);\nrd_kafka_resp_err_t rd_kafka_position(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata(rd_kafka_t *rk);\nrd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata_new(const char *group_id);\nrd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata_new_with_genid(const char *group_id, int32_t generation_id, const char *member_id, const char *group_instance_id);\nvoid rd_kafka_consumer_group_metadata_destroy(rd_kafka_consumer_group_metadata_t *);\nrd_kafka_error_t *rd_kafka_consumer_group_metadata_write(const rd_kafka_consumer_group_metadata_t *cgmd, void **bufferp, size_t *sizep);\nrd_kafka_error_t *rd_kafka_consumer_group_metadata_read(rd_kafka_consumer_group_metadata_t **cgmdp, const void *buffer, size_t size);\nint rd_kafka_produce(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, void *payload, size_t len, const void *key, size_t keylen, void *msg_opaque);\nrd_kafka_resp_err_t rd_kafka_producev(rd_kafka_t *rk, ...);\nrd_kafka_error_t *rd_kafka_produceva(rd_kafka_t *rk, const rd_kafka_vu_t *vus, size_t cnt);\nint rd_kafka_produce_batch(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, rd_kafka_message_t *rkmessages, int message_cnt);\nrd_kafka_resp_err_t rd_kafka_flush(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_resp_err_t rd_kafka_purge(rd_kafka_t *rk, int purge_flags);\ntypedef struct rd_kafka_metadata_broker {\n  int32_t id;\n  char *host;\n  int port;\n} rd_kafka_metadata_broker_t;\ntypedef struct rd_kafka_metadata_partition {\n  int32_t id;\n  rd_kafka_resp_err_t err;\n  int32_t leader;\n  int replica_cnt;\n  int32_t *replicas;\n  int isr_cnt;\n  int32_t *isrs;\n} rd_kafka_metadata_partition_t;\ntypedef struct rd_kafka_metadata_topic {\n  char *topic;\n  int partition_cnt;\n  struct rd_kafka_metadata_partition *partitions;\n  rd_kafka_resp_err_t err;\n} rd_kafka_metadata_topic_t;\ntypedef struct rd_kafka_metadata {\n  int broker_cnt;\n  struct rd_kafka_metadata_broker *brokers;\n  int topic_cnt;\n  struct rd_kafka_metadata_topic *topics;\n  int32_t orig_broker_id;\n  char *orig_broker_name;\n} rd_kafka_metadata_t;\nrd_kafka_resp_err_t rd_kafka_metadata(rd_kafka_t *rk, int all_topics, rd_kafka_topic_t *only_rkt, const struct rd_kafka_metadata **metadatap, int timeout_ms);\nvoid rd_kafka_metadata_destroy(const struct rd_kafka_metadata *metadata);\nstruct rd_kafka_group_member_info {\n  char *member_id;\n  char *client_id;\n  char *client_host;\n  void *member_metadata;\n  int member_metadata_size;\n  void *member_assignment;\n  int member_assignment_size;\n};\nstruct rd_kafka_group_info {\n  struct rd_kafka_metadata_broker broker;\n  char *group;\n  rd_kafka_resp_err_t err;\n  char *state;\n  char *protocol_type;\n  char *protocol;\n  struct rd_kafka_group_member_info *members;\n  int member_cnt;\n};\nstruct rd_kafka_group_list {\n  struct rd_kafka_group_info *groups;\n  int group_cnt;\n};\nrd_kafka_resp_err_t rd_kafka_list_groups(rd_kafka_t *rk, const char *group, const struct rd_kafka_group_list **grplistp, int timeout_ms);\nvoid rd_kafka_group_list_destroy(const struct rd_kafka_group_list *grplist);\nint rd_kafka_brokers_add(rd_kafka_t *rk, const char *brokerlist);\nvoid rd_kafka_set_logger(rd_kafka_t *rk, void (*func)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));\nvoid rd_kafka_set_log_level(rd_kafka_t *rk, int level);\nvoid rd_kafka_log_print(const rd_kafka_t *rk, int level, const char *fac, const char *buf);\nvoid rd_kafka_log_syslog(const rd_kafka_t *rk, int level, const char *fac, const char *buf);\nint rd_kafka_outq_len(rd_kafka_t *rk);\nvoid rd_kafka_dump(FILE *fp, rd_kafka_t *rk);\nint rd_kafka_thread_cnt(void);\ntypedef enum rd_kafka_thread_type_t {\n  RD_KAFKA_THREAD_MAIN,\n  RD_KAFKA_THREAD_BACKGROUND,\n  RD_KAFKA_THREAD_BROKER,\n} rd_kafka_thread_type_t;\nint rd_kafka_wait_destroyed(int timeout_ms);\nint rd_kafka_unittest(void);\nrd_kafka_resp_err_t rd_kafka_poll_set_consumer(rd_kafka_t *rk);\ntypedef int rd_kafka_event_type_t;\nrd_kafka_event_type_t rd_kafka_event_type(const rd_kafka_event_t *rkev);\nconst char *rd_kafka_event_name(const rd_kafka_event_t *rkev);\nvoid rd_kafka_event_destroy(rd_kafka_event_t *rkev);\nconst rd_kafka_message_t *rd_kafka_event_message_next(rd_kafka_event_t *rkev);\nsize_t rd_kafka_event_message_array(rd_kafka_event_t *rkev, const rd_kafka_message_t **rkmessages, size_t size);\nsize_t rd_kafka_event_message_count(rd_kafka_event_t *rkev);\nconst char *rd_kafka_event_config_string(rd_kafka_event_t *rkev);\nrd_kafka_resp_err_t rd_kafka_event_error(rd_kafka_event_t *rkev);\nconst char *rd_kafka_event_error_string(rd_kafka_event_t *rkev);\nint rd_kafka_event_error_is_fatal(rd_kafka_event_t *rkev);\nvoid *rd_kafka_event_opaque(rd_kafka_event_t *rkev);\nint rd_kafka_event_log(rd_kafka_event_t *rkev, const char **fac, const char **str, int *level);\nint rd_kafka_event_debug_contexts(rd_kafka_event_t *rkev, char *dst, size_t dstsize);\nconst char *rd_kafka_event_stats(rd_kafka_event_t *rkev);\nrd_kafka_topic_partition_list_t *rd_kafka_event_topic_partition_list(rd_kafka_event_t *rkev);\nrd_kafka_topic_partition_t *rd_kafka_event_topic_partition(rd_kafka_event_t *rkev);\ntypedef rd_kafka_event_t rd_kafka_CreateTopics_result_t;\ntypedef rd_kafka_event_t rd_kafka_DeleteTopics_result_t;\ntypedef rd_kafka_event_t rd_kafka_CreatePartitions_result_t;\ntypedef rd_kafka_event_t rd_kafka_AlterConfigs_result_t;\ntypedef rd_kafka_event_t rd_kafka_DescribeConfigs_result_t;\ntypedef rd_kafka_event_t rd_kafka_DeleteRecords_result_t;\ntypedef rd_kafka_event_t rd_kafka_DeleteGroups_result_t;\ntypedef rd_kafka_event_t rd_kafka_DeleteConsumerGroupOffsets_result_t;\nconst rd_kafka_CreateTopics_result_t *rd_kafka_event_CreateTopics_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DeleteTopics_result_t *rd_kafka_event_DeleteTopics_result(rd_kafka_event_t *rkev);\nconst rd_kafka_CreatePartitions_result_t *rd_kafka_event_CreatePartitions_result(rd_kafka_event_t *rkev);\nconst rd_kafka_AlterConfigs_result_t *rd_kafka_event_AlterConfigs_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DescribeConfigs_result_t *rd_kafka_event_DescribeConfigs_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DeleteRecords_result_t *rd_kafka_event_DeleteRecords_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DeleteGroups_result_t *rd_kafka_event_DeleteGroups_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DeleteConsumerGroupOffsets_result_t *rd_kafka_event_DeleteConsumerGroupOffsets_result(rd_kafka_event_t *rkev);\nrd_kafka_event_t *rd_kafka_queue_poll(rd_kafka_queue_t *rkqu, int timeout_ms);\nint rd_kafka_queue_poll_callback(rd_kafka_queue_t *rkqu, int timeout_ms);\ntypedef rd_kafka_resp_err_t (rd_kafka_plugin_f_conf_init_t)(rd_kafka_conf_t *conf, void **plug_opaquep, char *errstr, size_t errstr_size);\ntypedef rd_kafka_conf_res_t (rd_kafka_interceptor_f_on_conf_set_t)(rd_kafka_conf_t *conf, const char *name, const char *val, char *errstr, size_t errstr_size, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_dup_t)(rd_kafka_conf_t *new_conf, const rd_kafka_conf_t *old_conf, size_t filter_cnt, const char **filter, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_destroy_t)(void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_new_t)(rd_kafka_t *rk, const rd_kafka_conf_t *conf, void *ic_opaque, char *errstr, size_t errstr_size);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_destroy_t)(rd_kafka_t *rk, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_send_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_acknowledgement_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_consume_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_commit_t)(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_resp_err_t err, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_request_sent_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_start_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_exit_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_set(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_set_t *on_conf_set, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_dup(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_dup_t *on_conf_dup, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_destroy(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_destroy_t *on_conf_destroy, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_new(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_new_t *on_new, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_destroy(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_destroy_t *on_destroy, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_send(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_send_t *on_send, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_acknowledgement(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_acknowledgement_t *on_acknowledgement, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_consume(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_consume_t *on_consume, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_commit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_commit_t *on_commit, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_request_sent(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_request_sent_t *on_request_sent, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_start(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_start_t *on_thread_start, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_exit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_exit_t *on_thread_exit, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_topic_result_error(const rd_kafka_topic_result_t *topicres);\nconst char *rd_kafka_topic_result_error_string(const rd_kafka_topic_result_t *topicres);\nconst char *rd_kafka_topic_result_name(const rd_kafka_topic_result_t *topicres);\nconst rd_kafka_error_t *rd_kafka_group_result_error(const rd_kafka_group_result_t *groupres);\nconst char *rd_kafka_group_result_name(const rd_kafka_group_result_t *groupres);\nconst rd_kafka_topic_partition_list_t *rd_kafka_group_result_partitions(const rd_kafka_group_result_t *groupres);\ntypedef enum rd_kafka_admin_op_t {\n  RD_KAFKA_ADMIN_OP_ANY = 0,\n  RD_KAFKA_ADMIN_OP_CREATETOPICS,\n  RD_KAFKA_ADMIN_OP_DELETETOPICS,\n  RD_KAFKA_ADMIN_OP_CREATEPARTITIONS,\n  RD_KAFKA_ADMIN_OP_ALTERCONFIGS,\n  RD_KAFKA_ADMIN_OP_DESCRIBECONFIGS,\n  RD_KAFKA_ADMIN_OP_DELETERECORDS,\n  RD_KAFKA_ADMIN_OP_DELETEGROUPS,\n  RD_KAFKA_ADMIN_OP_DELETECONSUMERGROUPOFFSETS,\n  RD_KAFKA_ADMIN_OP__CNT,\n} rd_kafka_admin_op_t;\ntypedef struct rd_kafka_AdminOptions_s rd_kafka_AdminOptions_t;\nrd_kafka_AdminOptions_t *rd_kafka_AdminOptions_new(rd_kafka_t *rk, rd_kafka_admin_op_t for_api);\nvoid rd_kafka_AdminOptions_destroy(rd_kafka_AdminOptions_t *options);\nrd_kafka_resp_err_t rd_kafka_AdminOptions_set_request_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_AdminOptions_set_operation_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_AdminOptions_set_validate_only(rd_kafka_AdminOptions_t *options, int true_or_false, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_AdminOptions_set_broker(rd_kafka_AdminOptions_t *options, int32_t broker_id, char *errstr, size_t errstr_size);\nvoid rd_kafka_AdminOptions_set_opaque(rd_kafka_AdminOptions_t *options, void *ev_opaque);\ntypedef struct rd_kafka_NewTopic_s rd_kafka_NewTopic_t;\nrd_kafka_NewTopic_t *rd_kafka_NewTopic_new(const char *topic, int num_partitions, int replication_factor, char *errstr, size_t errstr_size);\nvoid rd_kafka_NewTopic_destroy(rd_kafka_NewTopic_t *new_topic);\nvoid rd_kafka_NewTopic_destroy_array(rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt);\nrd_kafka_resp_err_t rd_kafka_NewTopic_set_replica_assignment(rd_kafka_NewTopic_t *new_topic, int32_t partition, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_NewTopic_set_config(rd_kafka_NewTopic_t *new_topic, const char *name, const char *value);\nvoid rd_kafka_CreateTopics(rd_kafka_t *rk, rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_topic_result_t **rd_kafka_CreateTopics_result_topics(const rd_kafka_CreateTopics_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_DeleteTopic_s rd_kafka_DeleteTopic_t;\nrd_kafka_DeleteTopic_t *rd_kafka_DeleteTopic_new(const char *topic);\nvoid rd_kafka_DeleteTopic_destroy(rd_kafka_DeleteTopic_t *del_topic);\nvoid rd_kafka_DeleteTopic_destroy_array(rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt);\nvoid rd_kafka_DeleteTopics(rd_kafka_t *rk, rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_topic_result_t **rd_kafka_DeleteTopics_result_topics(const rd_kafka_DeleteTopics_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_NewPartitions_s rd_kafka_NewPartitions_t;\nrd_kafka_NewPartitions_t *rd_kafka_NewPartitions_new(const char *topic, size_t new_total_cnt, char *errstr, size_t errstr_size);\nvoid rd_kafka_NewPartitions_destroy(rd_kafka_NewPartitions_t *new_parts);\nvoid rd_kafka_NewPartitions_destroy_array(rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt);\nrd_kafka_resp_err_t rd_kafka_NewPartitions_set_replica_assignment(rd_kafka_NewPartitions_t *new_parts, int32_t new_partition_idx, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);\nvoid rd_kafka_CreatePartitions(rd_kafka_t *rk, rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_topic_result_t **rd_kafka_CreatePartitions_result_topics(const rd_kafka_CreatePartitions_result_t *result, size_t *cntp);\ntypedef enum rd_kafka_ConfigSource_t {\n  RD_KAFKA_CONFIG_SOURCE_UNKNOWN_CONFIG = 0,\n  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_TOPIC_CONFIG = 1,\n  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_BROKER_CONFIG = 2,\n  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_DEFAULT_BROKER_CONFIG = 3,\n  RD_KAFKA_CONFIG_SOURCE_STATIC_BROKER_CONFIG = 4,\n  RD_KAFKA_CONFIG_SOURCE_DEFAULT_CONFIG = 5,\n  RD_KAFKA_CONFIG_SOURCE__CNT,\n} rd_kafka_ConfigSource_t;\nconst char *rd_kafka_ConfigSource_name(rd_kafka_ConfigSource_t confsource);\ntypedef struct rd_kafka_ConfigEntry_s rd_kafka_ConfigEntry_t;\nconst char *rd_kafka_ConfigEntry_name(const rd_kafka_ConfigEntry_t *entry);\nconst char *rd_kafka_ConfigEntry_value(const rd_kafka_ConfigEntry_t *entry);\nrd_kafka_ConfigSource_t rd_kafka_ConfigEntry_source(const rd_kafka_ConfigEntry_t *entry);\nint rd_kafka_ConfigEntry_is_read_only(const rd_kafka_ConfigEntry_t *entry);\nint rd_kafka_ConfigEntry_is_default(const rd_kafka_ConfigEntry_t *entry);\nint rd_kafka_ConfigEntry_is_sensitive(const rd_kafka_ConfigEntry_t *entry);\nint rd_kafka_ConfigEntry_is_synonym(const rd_kafka_ConfigEntry_t *entry);\nconst rd_kafka_ConfigEntry_t **rd_kafka_ConfigEntry_synonyms(const rd_kafka_ConfigEntry_t *entry, size_t *cntp);\ntypedef enum rd_kafka_ResourceType_t {\n  RD_KAFKA_RESOURCE_UNKNOWN = 0,\n  RD_KAFKA_RESOURCE_ANY = 1,\n  RD_KAFKA_RESOURCE_TOPIC = 2,\n  RD_KAFKA_RESOURCE_GROUP = 3,\n  RD_KAFKA_RESOURCE_BROKER = 4,\n  RD_KAFKA_RESOURCE__CNT,\n} rd_kafka_ResourceType_t;\nconst char *rd_kafka_ResourceType_name(rd_kafka_ResourceType_t restype);\ntypedef struct rd_kafka_ConfigResource_s rd_kafka_ConfigResource_t;\nrd_kafka_ConfigResource_t *rd_kafka_ConfigResource_new(rd_kafka_ResourceType_t restype, const char *resname);\nvoid rd_kafka_ConfigResource_destroy(rd_kafka_ConfigResource_t *config);\nvoid rd_kafka_ConfigResource_destroy_array(rd_kafka_ConfigResource_t **config, size_t config_cnt);\nrd_kafka_resp_err_t rd_kafka_ConfigResource_set_config(rd_kafka_ConfigResource_t *config, const char *name, const char *value);\nconst rd_kafka_ConfigEntry_t **rd_kafka_ConfigResource_configs(const rd_kafka_ConfigResource_t *config, size_t *cntp);\nrd_kafka_ResourceType_t rd_kafka_ConfigResource_type(const rd_kafka_ConfigResource_t *config);\nconst char *rd_kafka_ConfigResource_name(const rd_kafka_ConfigResource_t *config);\nrd_kafka_resp_err_t rd_kafka_ConfigResource_error(const rd_kafka_ConfigResource_t *config);\nconst char *rd_kafka_ConfigResource_error_string(const rd_kafka_ConfigResource_t *config);\nvoid rd_kafka_AlterConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_ConfigResource_t **rd_kafka_AlterConfigs_result_resources(const rd_kafka_AlterConfigs_result_t *result, size_t *cntp);\nvoid rd_kafka_DescribeConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_ConfigResource_t **rd_kafka_DescribeConfigs_result_resources(const rd_kafka_DescribeConfigs_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_DeleteRecords_s rd_kafka_DeleteRecords_t;\nrd_kafka_DeleteRecords_t *rd_kafka_DeleteRecords_new(const rd_kafka_topic_partition_list_t *before_offsets);\nvoid rd_kafka_DeleteRecords_destroy(rd_kafka_DeleteRecords_t *del_records);\nvoid rd_kafka_DeleteRecords_destroy_array(rd_kafka_DeleteRecords_t **del_records, size_t del_record_cnt);\nvoid rd_kafka_DeleteRecords(rd_kafka_t *rk, rd_kafka_DeleteRecords_t **del_records, size_t del_record_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_topic_partition_list_t *rd_kafka_DeleteRecords_result_offsets(const rd_kafka_DeleteRecords_result_t *result);\ntypedef struct rd_kafka_DeleteGroup_s rd_kafka_DeleteGroup_t;\nrd_kafka_DeleteGroup_t *rd_kafka_DeleteGroup_new(const char *group);\nvoid rd_kafka_DeleteGroup_destroy(rd_kafka_DeleteGroup_t *del_group);\nvoid rd_kafka_DeleteGroup_destroy_array(rd_kafka_DeleteGroup_t **del_groups, size_t del_group_cnt);\nvoid rd_kafka_DeleteGroups(rd_kafka_t *rk, rd_kafka_DeleteGroup_t **del_groups, size_t del_group_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_group_result_t **rd_kafka_DeleteGroups_result_groups(const rd_kafka_DeleteGroups_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_DeleteConsumerGroupOffsets_s rd_kafka_DeleteConsumerGroupOffsets_t;\nrd_kafka_DeleteConsumerGroupOffsets_t *rd_kafka_DeleteConsumerGroupOffsets_new(const char *group, const rd_kafka_topic_partition_list_t *partitions);\nvoid rd_kafka_DeleteConsumerGroupOffsets_destroy(rd_kafka_DeleteConsumerGroupOffsets_t *del_grpoffsets);\nvoid rd_kafka_DeleteConsumerGroupOffsets_destroy_array(rd_kafka_DeleteConsumerGroupOffsets_t **del_grpoffsets, size_t del_grpoffset_cnt);\nvoid rd_kafka_DeleteConsumerGroupOffsets(rd_kafka_t *rk, rd_kafka_DeleteConsumerGroupOffsets_t **del_grpoffsets, size_t del_grpoffsets_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_group_result_t **rd_kafka_DeleteConsumerGroupOffsets_result_groups(const rd_kafka_DeleteConsumerGroupOffsets_result_t *result, size_t *cntp);\nrd_kafka_resp_err_t rd_kafka_oauthbearer_set_token(rd_kafka_t *rk, const char *token_value, int64_t md_lifetime_ms, const char *md_principal_name, const char **extensions, size_t extension_size, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_oauthbearer_set_token_failure(rd_kafka_t *rk, const char *errstr);\nrd_kafka_error_t *rd_kafka_init_transactions(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_error_t *rd_kafka_begin_transaction(rd_kafka_t *rk);\nrd_kafka_error_t *rd_kafka_send_offsets_to_transaction(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, const rd_kafka_consumer_group_metadata_t *cgmetadata, int timeout_ms);\nrd_kafka_error_t *rd_kafka_commit_transaction(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_error_t *rd_kafka_abort_transaction(rd_kafka_t *rk, int timeout_ms);\ntypedef struct rd_kafka_mock_cluster_s rd_kafka_mock_cluster_t;\nrd_kafka_mock_cluster_t *rd_kafka_mock_cluster_new(rd_kafka_t *rk, int broker_cnt);\nvoid rd_kafka_mock_cluster_destroy(rd_kafka_mock_cluster_t *mcluster);\nrd_kafka_t *rd_kafka_mock_cluster_handle(const rd_kafka_mock_cluster_t *mcluster);\nrd_kafka_mock_cluster_t *rd_kafka_handle_mock_cluster(const rd_kafka_t *rk);\nconst char *rd_kafka_mock_cluster_bootstraps(const rd_kafka_mock_cluster_t *mcluster);\nvoid rd_kafka_mock_clear_request_errors(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey);\nvoid rd_kafka_mock_push_request_errors(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, size_t cnt, ...);\nvoid rd_kafka_mock_push_request_errors_array(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, size_t cnt, const rd_kafka_resp_err_t *errors);\nrd_kafka_resp_err_t rd_kafka_mock_broker_push_request_errors(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int16_t ApiKey, size_t cnt, ...);\nvoid rd_kafka_mock_topic_set_error(rd_kafka_mock_cluster_t *mcluster, const char *topic, rd_kafka_resp_err_t err);\nrd_kafka_resp_err_t rd_kafka_mock_topic_create(rd_kafka_mock_cluster_t *mcluster, const char *topic, int partition_cnt, int replication_factor);\nrd_kafka_resp_err_t rd_kafka_mock_partition_set_leader(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id);\nrd_kafka_resp_err_t rd_kafka_mock_partition_set_follower(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id);\nrd_kafka_resp_err_t rd_kafka_mock_partition_set_follower_wmarks(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int64_t lo, int64_t hi);\nrd_kafka_resp_err_t rd_kafka_mock_broker_set_down(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id);\nrd_kafka_resp_err_t rd_kafka_mock_broker_set_up(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id);\nrd_kafka_resp_err_t rd_kafka_mock_broker_set_rtt(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int rtt_ms);\nrd_kafka_resp_err_t rd_kafka_mock_broker_set_rack(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, const char *rack);\nrd_kafka_resp_err_t rd_kafka_mock_coordinator_set(rd_kafka_mock_cluster_t *mcluster, const char *key_type, const char *key, int32_t broker_id);\nrd_kafka_resp_err_t rd_kafka_mock_set_apiversion(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, int16_t MinVersion, int16_t MaxVersion);\n'\n</code></pre> rdkafka.h, rdkafka_mock.h</p>"},{"location":"api/constants/#rd_kafka_version_14","title":"RD_KAFKA_VERSION","text":"<pre><code>public RD_KAFKA_VERSION = 17170943\n</code></pre> <p>librdkafka version </p> <p>Interpreted as hex <code>MM.mm.rr.xx</code>:</p> <ul> <li>MM = Major</li> <li>mm = minor</li> <li>rr = revision</li> <li>xx = pre-release id (0xff is the final release)</li> </ul> <p>E.g.: <code>0x000801ff</code> = 0.8.1</p> RemarksThis value should only be used during compile time, for runtime checks of version use rd_kafka_version()  <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_unsupported_compression_type_14","title":"RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE","text":"<pre><code>public RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76\n</code></pre> <p>Unsupported compression type </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_end_all_14","title":"RD_KAFKA_RESP_ERR_END_ALL","text":"<p><pre><code>public RD_KAFKA_RESP_ERR_END_ALL = 98\n</code></pre> enum rd_kafka_resp_err_t</p>"},{"location":"api/constants/#rd_kafka_admin_op__cnt_14","title":"RD_KAFKA_ADMIN_OP__CNT","text":"<pre><code>public RD_KAFKA_ADMIN_OP__CNT = 9\n</code></pre> <p>Number of ops defined </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe </li> </ul>"},{"location":"api/constants/#rd_kafka_resource__cnt_14","title":"RD_KAFKA_RESOURCE__CNT","text":"<pre><code>public RD_KAFKA_RESOURCE__CNT = 5\n</code></pre> <p>Number of resource types defined </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#acca83a66d7783ff7683ed2691cc907c9 </li> </ul>"},{"location":"api/constants/#rd_kafka_cdef_14","title":"RD_KAFKA_CDEF","text":"<p><pre><code>public RD_KAFKA_CDEF = 'typedef long int ssize_t;\ntypedef struct _IO_FILE FILE;\ntypedef long int mode_t;\ntypedef signed int int16_t;\ntypedef unsigned int uint16_t;\ntypedef signed int int32_t;\ntypedef signed long int int64_t;\nint rd_kafka_version(void);\nconst char *rd_kafka_version_str(void);\ntypedef enum rd_kafka_type_t {\n  RD_KAFKA_PRODUCER,\n  RD_KAFKA_CONSUMER,\n} rd_kafka_type_t;\ntypedef enum rd_kafka_timestamp_type_t {\n  RD_KAFKA_TIMESTAMP_NOT_AVAILABLE,\n  RD_KAFKA_TIMESTAMP_CREATE_TIME,\n  RD_KAFKA_TIMESTAMP_LOG_APPEND_TIME,\n} rd_kafka_timestamp_type_t;\nconst char *rd_kafka_get_debug_contexts(void);\ntypedef struct rd_kafka_s rd_kafka_t;\ntypedef struct rd_kafka_topic_s rd_kafka_topic_t;\ntypedef struct rd_kafka_conf_s rd_kafka_conf_t;\ntypedef struct rd_kafka_topic_conf_s rd_kafka_topic_conf_t;\ntypedef struct rd_kafka_queue_s rd_kafka_queue_t;\ntypedef struct rd_kafka_op_s rd_kafka_event_t;\ntypedef struct rd_kafka_topic_result_s rd_kafka_topic_result_t;\ntypedef struct rd_kafka_consumer_group_metadata_s rd_kafka_consumer_group_metadata_t;\ntypedef struct rd_kafka_error_s {\n  unsigned int code;\n  char *errstr;\n  unsigned char fatal;\n  unsigned char retriable;\n  unsigned char txn_requires_abort;\n} rd_kafka_error_t;\ntypedef struct rd_kafka_headers_s rd_kafka_headers_t;\ntypedef struct rd_kafka_group_result_s rd_kafka_group_result_t;\ntypedef enum {\n  RD_KAFKA_RESP_ERR__BEGIN = (- 200),\n  RD_KAFKA_RESP_ERR__BAD_MSG = (- 199),\n  RD_KAFKA_RESP_ERR__BAD_COMPRESSION = (- 198),\n  RD_KAFKA_RESP_ERR__DESTROY = (- 197),\n  RD_KAFKA_RESP_ERR__FAIL = (- 196),\n  RD_KAFKA_RESP_ERR__TRANSPORT = (- 195),\n  RD_KAFKA_RESP_ERR__CRIT_SYS_RESOURCE = (- 194),\n  RD_KAFKA_RESP_ERR__RESOLVE = (- 193),\n  RD_KAFKA_RESP_ERR__MSG_TIMED_OUT = (- 192),\n  RD_KAFKA_RESP_ERR__PARTITION_EOF = (- 191),\n  RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION = (- 190),\n  RD_KAFKA_RESP_ERR__FS = (- 189),\n  RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC = (- 188),\n  RD_KAFKA_RESP_ERR__ALL_BROKERS_DOWN = (- 187),\n  RD_KAFKA_RESP_ERR__INVALID_ARG = (- 186),\n  RD_KAFKA_RESP_ERR__TIMED_OUT = (- 185),\n  RD_KAFKA_RESP_ERR__QUEUE_FULL = (- 184),\n  RD_KAFKA_RESP_ERR__ISR_INSUFF = (- 183),\n  RD_KAFKA_RESP_ERR__NODE_UPDATE = (- 182),\n  RD_KAFKA_RESP_ERR__SSL = (- 181),\n  RD_KAFKA_RESP_ERR__WAIT_COORD = (- 180),\n  RD_KAFKA_RESP_ERR__UNKNOWN_GROUP = (- 179),\n  RD_KAFKA_RESP_ERR__IN_PROGRESS = (- 178),\n  RD_KAFKA_RESP_ERR__PREV_IN_PROGRESS = (- 177),\n  RD_KAFKA_RESP_ERR__EXISTING_SUBSCRIPTION = (- 176),\n  RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS = (- 175),\n  RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS = (- 174),\n  RD_KAFKA_RESP_ERR__CONFLICT = (- 173),\n  RD_KAFKA_RESP_ERR__STATE = (- 172),\n  RD_KAFKA_RESP_ERR__UNKNOWN_PROTOCOL = (- 171),\n  RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED = (- 170),\n  RD_KAFKA_RESP_ERR__AUTHENTICATION = (- 169),\n  RD_KAFKA_RESP_ERR__NO_OFFSET = (- 168),\n  RD_KAFKA_RESP_ERR__OUTDATED = (- 167),\n  RD_KAFKA_RESP_ERR__TIMED_OUT_QUEUE = (- 166),\n  RD_KAFKA_RESP_ERR__UNSUPPORTED_FEATURE = (- 165),\n  RD_KAFKA_RESP_ERR__WAIT_CACHE = (- 164),\n  RD_KAFKA_RESP_ERR__INTR = (- 163),\n  RD_KAFKA_RESP_ERR__KEY_SERIALIZATION = (- 162),\n  RD_KAFKA_RESP_ERR__VALUE_SERIALIZATION = (- 161),\n  RD_KAFKA_RESP_ERR__KEY_DESERIALIZATION = (- 160),\n  RD_KAFKA_RESP_ERR__VALUE_DESERIALIZATION = (- 159),\n  RD_KAFKA_RESP_ERR__PARTIAL = (- 158),\n  RD_KAFKA_RESP_ERR__READ_ONLY = (- 157),\n  RD_KAFKA_RESP_ERR__NOENT = (- 156),\n  RD_KAFKA_RESP_ERR__UNDERFLOW = (- 155),\n  RD_KAFKA_RESP_ERR__INVALID_TYPE = (- 154),\n  RD_KAFKA_RESP_ERR__RETRY = (- 153),\n  RD_KAFKA_RESP_ERR__PURGE_QUEUE = (- 152),\n  RD_KAFKA_RESP_ERR__PURGE_INFLIGHT = (- 151),\n  RD_KAFKA_RESP_ERR__FATAL = (- 150),\n  RD_KAFKA_RESP_ERR__INCONSISTENT = (- 149),\n  RD_KAFKA_RESP_ERR__GAPLESS_GUARANTEE = (- 148),\n  RD_KAFKA_RESP_ERR__MAX_POLL_EXCEEDED = (- 147),\n  RD_KAFKA_RESP_ERR__UNKNOWN_BROKER = (- 146),\n  RD_KAFKA_RESP_ERR__NOT_CONFIGURED = (- 145),\n  RD_KAFKA_RESP_ERR__FENCED = (- 144),\n  RD_KAFKA_RESP_ERR__APPLICATION = (- 143),\n  RD_KAFKA_RESP_ERR__ASSIGNMENT_LOST = (- 142),\n  RD_KAFKA_RESP_ERR__NOOP = (- 141),\n  RD_KAFKA_RESP_ERR__AUTO_OFFSET_RESET = (- 140),\n  RD_KAFKA_RESP_ERR__END = (- 100),\n  RD_KAFKA_RESP_ERR_UNKNOWN = (- 1),\n  RD_KAFKA_RESP_ERR_NO_ERROR = 0,\n  RD_KAFKA_RESP_ERR_OFFSET_OUT_OF_RANGE = 1,\n  RD_KAFKA_RESP_ERR_INVALID_MSG = 2,\n  RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART = 3,\n  RD_KAFKA_RESP_ERR_INVALID_MSG_SIZE = 4,\n  RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE = 5,\n  RD_KAFKA_RESP_ERR_NOT_LEADER_FOR_PARTITION = 6,\n  RD_KAFKA_RESP_ERR_REQUEST_TIMED_OUT = 7,\n  RD_KAFKA_RESP_ERR_BROKER_NOT_AVAILABLE = 8,\n  RD_KAFKA_RESP_ERR_REPLICA_NOT_AVAILABLE = 9,\n  RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE = 10,\n  RD_KAFKA_RESP_ERR_STALE_CTRL_EPOCH = 11,\n  RD_KAFKA_RESP_ERR_OFFSET_METADATA_TOO_LARGE = 12,\n  RD_KAFKA_RESP_ERR_NETWORK_EXCEPTION = 13,\n  RD_KAFKA_RESP_ERR_COORDINATOR_LOAD_IN_PROGRESS = 14,\n  RD_KAFKA_RESP_ERR_COORDINATOR_NOT_AVAILABLE = 15,\n  RD_KAFKA_RESP_ERR_NOT_COORDINATOR = 16,\n  RD_KAFKA_RESP_ERR_TOPIC_EXCEPTION = 17,\n  RD_KAFKA_RESP_ERR_RECORD_LIST_TOO_LARGE = 18,\n  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS = 19,\n  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS_AFTER_APPEND = 20,\n  RD_KAFKA_RESP_ERR_INVALID_REQUIRED_ACKS = 21,\n  RD_KAFKA_RESP_ERR_ILLEGAL_GENERATION = 22,\n  RD_KAFKA_RESP_ERR_INCONSISTENT_GROUP_PROTOCOL = 23,\n  RD_KAFKA_RESP_ERR_INVALID_GROUP_ID = 24,\n  RD_KAFKA_RESP_ERR_UNKNOWN_MEMBER_ID = 25,\n  RD_KAFKA_RESP_ERR_INVALID_SESSION_TIMEOUT = 26,\n  RD_KAFKA_RESP_ERR_REBALANCE_IN_PROGRESS = 27,\n  RD_KAFKA_RESP_ERR_INVALID_COMMIT_OFFSET_SIZE = 28,\n  RD_KAFKA_RESP_ERR_TOPIC_AUTHORIZATION_FAILED = 29,\n  RD_KAFKA_RESP_ERR_GROUP_AUTHORIZATION_FAILED = 30,\n  RD_KAFKA_RESP_ERR_CLUSTER_AUTHORIZATION_FAILED = 31,\n  RD_KAFKA_RESP_ERR_INVALID_TIMESTAMP = 32,\n  RD_KAFKA_RESP_ERR_UNSUPPORTED_SASL_MECHANISM = 33,\n  RD_KAFKA_RESP_ERR_ILLEGAL_SASL_STATE = 34,\n  RD_KAFKA_RESP_ERR_UNSUPPORTED_VERSION = 35,\n  RD_KAFKA_RESP_ERR_TOPIC_ALREADY_EXISTS = 36,\n  RD_KAFKA_RESP_ERR_INVALID_PARTITIONS = 37,\n  RD_KAFKA_RESP_ERR_INVALID_REPLICATION_FACTOR = 38,\n  RD_KAFKA_RESP_ERR_INVALID_REPLICA_ASSIGNMENT = 39,\n  RD_KAFKA_RESP_ERR_INVALID_CONFIG = 40,\n  RD_KAFKA_RESP_ERR_NOT_CONTROLLER = 41,\n  RD_KAFKA_RESP_ERR_INVALID_REQUEST = 42,\n  RD_KAFKA_RESP_ERR_UNSUPPORTED_FOR_MESSAGE_FORMAT = 43,\n  RD_KAFKA_RESP_ERR_POLICY_VIOLATION = 44,\n  RD_KAFKA_RESP_ERR_OUT_OF_ORDER_SEQUENCE_NUMBER = 45,\n  RD_KAFKA_RESP_ERR_DUPLICATE_SEQUENCE_NUMBER = 46,\n  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_EPOCH = 47,\n  RD_KAFKA_RESP_ERR_INVALID_TXN_STATE = 48,\n  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_ID_MAPPING = 49,\n  RD_KAFKA_RESP_ERR_INVALID_TRANSACTION_TIMEOUT = 50,\n  RD_KAFKA_RESP_ERR_CONCURRENT_TRANSACTIONS = 51,\n  RD_KAFKA_RESP_ERR_TRANSACTION_COORDINATOR_FENCED = 52,\n  RD_KAFKA_RESP_ERR_TRANSACTIONAL_ID_AUTHORIZATION_FAILED = 53,\n  RD_KAFKA_RESP_ERR_SECURITY_DISABLED = 54,\n  RD_KAFKA_RESP_ERR_OPERATION_NOT_ATTEMPTED = 55,\n  RD_KAFKA_RESP_ERR_KAFKA_STORAGE_ERROR = 56,\n  RD_KAFKA_RESP_ERR_LOG_DIR_NOT_FOUND = 57,\n  RD_KAFKA_RESP_ERR_SASL_AUTHENTICATION_FAILED = 58,\n  RD_KAFKA_RESP_ERR_UNKNOWN_PRODUCER_ID = 59,\n  RD_KAFKA_RESP_ERR_REASSIGNMENT_IN_PROGRESS = 60,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTH_DISABLED = 61,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_NOT_FOUND = 62,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_OWNER_MISMATCH = 63,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_REQUEST_NOT_ALLOWED = 64,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTHORIZATION_FAILED = 65,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_EXPIRED = 66,\n  RD_KAFKA_RESP_ERR_INVALID_PRINCIPAL_TYPE = 67,\n  RD_KAFKA_RESP_ERR_NON_EMPTY_GROUP = 68,\n  RD_KAFKA_RESP_ERR_GROUP_ID_NOT_FOUND = 69,\n  RD_KAFKA_RESP_ERR_FETCH_SESSION_ID_NOT_FOUND = 70,\n  RD_KAFKA_RESP_ERR_INVALID_FETCH_SESSION_EPOCH = 71,\n  RD_KAFKA_RESP_ERR_LISTENER_NOT_FOUND = 72,\n  RD_KAFKA_RESP_ERR_TOPIC_DELETION_DISABLED = 73,\n  RD_KAFKA_RESP_ERR_FENCED_LEADER_EPOCH = 74,\n  RD_KAFKA_RESP_ERR_UNKNOWN_LEADER_EPOCH = 75,\n  RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76,\n  RD_KAFKA_RESP_ERR_STALE_BROKER_EPOCH = 77,\n  RD_KAFKA_RESP_ERR_OFFSET_NOT_AVAILABLE = 78,\n  RD_KAFKA_RESP_ERR_MEMBER_ID_REQUIRED = 79,\n  RD_KAFKA_RESP_ERR_PREFERRED_LEADER_NOT_AVAILABLE = 80,\n  RD_KAFKA_RESP_ERR_GROUP_MAX_SIZE_REACHED = 81,\n  RD_KAFKA_RESP_ERR_FENCED_INSTANCE_ID = 82,\n  RD_KAFKA_RESP_ERR_ELIGIBLE_LEADERS_NOT_AVAILABLE = 83,\n  RD_KAFKA_RESP_ERR_ELECTION_NOT_NEEDED = 84,\n  RD_KAFKA_RESP_ERR_NO_REASSIGNMENT_IN_PROGRESS = 85,\n  RD_KAFKA_RESP_ERR_GROUP_SUBSCRIBED_TO_TOPIC = 86,\n  RD_KAFKA_RESP_ERR_INVALID_RECORD = 87,\n  RD_KAFKA_RESP_ERR_UNSTABLE_OFFSET_COMMIT = 88,\n  RD_KAFKA_RESP_ERR_THROTTLING_QUOTA_EXCEEDED = 89,\n  RD_KAFKA_RESP_ERR_PRODUCER_FENCED = 90,\n  RD_KAFKA_RESP_ERR_RESOURCE_NOT_FOUND = 91,\n  RD_KAFKA_RESP_ERR_DUPLICATE_RESOURCE = 92,\n  RD_KAFKA_RESP_ERR_UNACCEPTABLE_CREDENTIAL = 93,\n  RD_KAFKA_RESP_ERR_INCONSISTENT_VOTER_SET = 94,\n  RD_KAFKA_RESP_ERR_INVALID_UPDATE_VERSION = 95,\n  RD_KAFKA_RESP_ERR_FEATURE_UPDATE_FAILED = 96,\n  RD_KAFKA_RESP_ERR_PRINCIPAL_DESERIALIZATION_FAILURE = 97,\n  RD_KAFKA_RESP_ERR_END_ALL,\n} rd_kafka_resp_err_t;\nstruct rd_kafka_err_desc {\n  rd_kafka_resp_err_t code;\n  char *name;\n  char *desc;\n};\nvoid rd_kafka_get_err_descs(const struct rd_kafka_err_desc **errdescs, size_t *cntp);\nconst char *rd_kafka_err2str(rd_kafka_resp_err_t err);\nconst char *rd_kafka_err2name(rd_kafka_resp_err_t err);\nrd_kafka_resp_err_t rd_kafka_last_error(void);\nrd_kafka_resp_err_t rd_kafka_errno2err(int errnox);\nint rd_kafka_errno(void);\nrd_kafka_resp_err_t rd_kafka_fatal_error(rd_kafka_t *rk, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_test_fatal_error(rd_kafka_t *rk, rd_kafka_resp_err_t err, const char *reason);\nrd_kafka_resp_err_t rd_kafka_error_code(const rd_kafka_error_t *error);\nconst char *rd_kafka_error_name(const rd_kafka_error_t *error);\nconst char *rd_kafka_error_string(const rd_kafka_error_t *error);\nint rd_kafka_error_is_fatal(const rd_kafka_error_t *error);\nint rd_kafka_error_is_retriable(const rd_kafka_error_t *error);\nint rd_kafka_error_txn_requires_abort(const rd_kafka_error_t *error);\nvoid rd_kafka_error_destroy(rd_kafka_error_t *error);\nrd_kafka_error_t *rd_kafka_error_new(rd_kafka_resp_err_t code, const char *fmt, ...);\ntypedef struct rd_kafka_topic_partition_s {\n  char *topic;\n  int32_t partition;\n  int64_t offset;\n  void *metadata;\n  size_t metadata_size;\n  void *opaque;\n  rd_kafka_resp_err_t err;\n  void *_private;\n} rd_kafka_topic_partition_t;\nvoid rd_kafka_topic_partition_destroy(rd_kafka_topic_partition_t *rktpar);\ntypedef struct rd_kafka_topic_partition_list_s {\n  int cnt;\n  int size;\n  rd_kafka_topic_partition_t *elems;\n} rd_kafka_topic_partition_list_t;\nrd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_new(int size);\nvoid rd_kafka_topic_partition_list_destroy(rd_kafka_topic_partition_list_t *rkparlist);\nrd_kafka_topic_partition_t *rd_kafka_topic_partition_list_add(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);\nvoid rd_kafka_topic_partition_list_add_range(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t start, int32_t stop);\nint rd_kafka_topic_partition_list_del(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);\nint rd_kafka_topic_partition_list_del_by_idx(rd_kafka_topic_partition_list_t *rktparlist, int idx);\nrd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_copy(const rd_kafka_topic_partition_list_t *src);\nrd_kafka_resp_err_t rd_kafka_topic_partition_list_set_offset(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition, int64_t offset);\nrd_kafka_topic_partition_t *rd_kafka_topic_partition_list_find(const rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);\nvoid rd_kafka_topic_partition_list_sort(rd_kafka_topic_partition_list_t *rktparlist, int (*cmp)(const void *a, const void *b, void *cmp_opaque), void *cmp_opaque);\ntypedef enum rd_kafka_vtype_t {\n  RD_KAFKA_VTYPE_END,\n  RD_KAFKA_VTYPE_TOPIC,\n  RD_KAFKA_VTYPE_RKT,\n  RD_KAFKA_VTYPE_PARTITION,\n  RD_KAFKA_VTYPE_VALUE,\n  RD_KAFKA_VTYPE_KEY,\n  RD_KAFKA_VTYPE_OPAQUE,\n  RD_KAFKA_VTYPE_MSGFLAGS,\n  RD_KAFKA_VTYPE_TIMESTAMP,\n  RD_KAFKA_VTYPE_HEADER,\n  RD_KAFKA_VTYPE_HEADERS,\n} rd_kafka_vtype_t;\ntypedef struct rd_kafka_vu_s {\n  rd_kafka_vtype_t vtype;\n  union {\n    char *cstr;\n    rd_kafka_topic_t *rkt;\n    int i;\n    int32_t i32;\n    int64_t i64;\n    struct {\n      void *ptr;\n      size_t size;\n    } mem;\n    struct {\n      char *name;\n      void *val;\n      ssize_t size;\n    } header;\n    rd_kafka_headers_t *headers;\n    void *ptr;\n    char _pad[64];\n  } u;\n} rd_kafka_vu_t;\nrd_kafka_headers_t *rd_kafka_headers_new(size_t initial_count);\nvoid rd_kafka_headers_destroy(rd_kafka_headers_t *hdrs);\nrd_kafka_headers_t *rd_kafka_headers_copy(const rd_kafka_headers_t *src);\nrd_kafka_resp_err_t rd_kafka_header_add(rd_kafka_headers_t *hdrs, const char *name, ssize_t name_size, const void *value, ssize_t value_size);\nrd_kafka_resp_err_t rd_kafka_header_remove(rd_kafka_headers_t *hdrs, const char *name);\nrd_kafka_resp_err_t rd_kafka_header_get_last(const rd_kafka_headers_t *hdrs, const char *name, const void **valuep, size_t *sizep);\nrd_kafka_resp_err_t rd_kafka_header_get(const rd_kafka_headers_t *hdrs, size_t idx, const char *name, const void **valuep, size_t *sizep);\nrd_kafka_resp_err_t rd_kafka_header_get_all(const rd_kafka_headers_t *hdrs, size_t idx, const char **namep, const void **valuep, size_t *sizep);\ntypedef struct rd_kafka_message_s {\n  rd_kafka_resp_err_t err;\n  rd_kafka_topic_t *rkt;\n  int32_t partition;\n  void *payload;\n  size_t len;\n  void *key;\n  size_t key_len;\n  int64_t offset;\n  void *_private;\n} rd_kafka_message_t;\nvoid rd_kafka_message_destroy(rd_kafka_message_t *rkmessage);\nconst char *rd_kafka_message_errstr(const rd_kafka_message_t *rkmessage);\nint64_t rd_kafka_message_timestamp(const rd_kafka_message_t *rkmessage, rd_kafka_timestamp_type_t *tstype);\nint64_t rd_kafka_message_latency(const rd_kafka_message_t *rkmessage);\nint32_t rd_kafka_message_broker_id(const rd_kafka_message_t *rkmessage);\nrd_kafka_resp_err_t rd_kafka_message_headers(const rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);\nrd_kafka_resp_err_t rd_kafka_message_detach_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);\nvoid rd_kafka_message_set_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t *hdrs);\nsize_t rd_kafka_header_cnt(const rd_kafka_headers_t *hdrs);\ntypedef enum {\n  RD_KAFKA_MSG_STATUS_NOT_PERSISTED = 0,\n  RD_KAFKA_MSG_STATUS_POSSIBLY_PERSISTED = 1,\n  RD_KAFKA_MSG_STATUS_PERSISTED = 2,\n} rd_kafka_msg_status_t;\nrd_kafka_msg_status_t rd_kafka_message_status(const rd_kafka_message_t *rkmessage);\ntypedef enum {\n  RD_KAFKA_CONF_UNKNOWN = (- 2),\n  RD_KAFKA_CONF_INVALID = (- 1),\n  RD_KAFKA_CONF_OK = 0,\n} rd_kafka_conf_res_t;\nrd_kafka_conf_t *rd_kafka_conf_new(void);\nvoid rd_kafka_conf_destroy(rd_kafka_conf_t *conf);\nrd_kafka_conf_t *rd_kafka_conf_dup(const rd_kafka_conf_t *conf);\nrd_kafka_conf_t *rd_kafka_conf_dup_filter(const rd_kafka_conf_t *conf, size_t filter_cnt, const char **filter);\nconst rd_kafka_conf_t *rd_kafka_conf(rd_kafka_t *rk);\nrd_kafka_conf_res_t rd_kafka_conf_set(rd_kafka_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);\nvoid rd_kafka_conf_set_events(rd_kafka_conf_t *conf, int events);\nvoid rd_kafka_conf_set_background_event_cb(rd_kafka_conf_t *conf, void (*event_cb)(rd_kafka_t *rk, rd_kafka_event_t *rkev, void *opaque));\nvoid rd_kafka_conf_set_dr_cb(rd_kafka_conf_t *conf, void (*dr_cb)(rd_kafka_t *rk, void *payload, size_t len, rd_kafka_resp_err_t err, void *opaque, void *msg_opaque));\nvoid rd_kafka_conf_set_dr_msg_cb(rd_kafka_conf_t *conf, void (*dr_msg_cb)(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, void *opaque));\nvoid rd_kafka_conf_set_consume_cb(rd_kafka_conf_t *conf, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *opaque));\nvoid rd_kafka_conf_set_rebalance_cb(rd_kafka_conf_t *conf, void (*rebalance_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *partitions, void *opaque));\nvoid rd_kafka_conf_set_offset_commit_cb(rd_kafka_conf_t *conf, void (*offset_commit_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *opaque));\nvoid rd_kafka_conf_set_error_cb(rd_kafka_conf_t *conf, void (*error_cb)(rd_kafka_t *rk, int err, const char *reason, void *opaque));\nvoid rd_kafka_conf_set_throttle_cb(rd_kafka_conf_t *conf, void (*throttle_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int throttle_time_ms, void *opaque));\nvoid rd_kafka_conf_set_log_cb(rd_kafka_conf_t *conf, void (*log_cb)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));\nvoid rd_kafka_conf_set_stats_cb(rd_kafka_conf_t *conf, int (*stats_cb)(rd_kafka_t *rk, char *json, size_t json_len, void *opaque));\nvoid rd_kafka_conf_set_oauthbearer_token_refresh_cb(rd_kafka_conf_t *conf, void (*oauthbearer_token_refresh_cb)(rd_kafka_t *rk, const char *oauthbearer_config, void *opaque));\nvoid rd_kafka_conf_set_socket_cb(rd_kafka_conf_t *conf, int (*socket_cb)(int domain, int type, int protocol, void *opaque));\nvoid rd_kafka_conf_set_connect_cb(rd_kafka_conf_t *conf, int (*connect_cb)(int sockfd, const struct sockaddr *addr, int addrlen, const char *id, void *opaque));\nvoid rd_kafka_conf_set_closesocket_cb(rd_kafka_conf_t *conf, int (*closesocket_cb)(int sockfd, void *opaque));\nrd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert_verify_cb(rd_kafka_conf_t *conf, int (*ssl_cert_verify_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int *x509_error, int depth, const char *buf, size_t size, char *errstr, size_t errstr_size, void *opaque));\ntypedef enum rd_kafka_cert_type_t {\n  RD_KAFKA_CERT_PUBLIC_KEY,\n  RD_KAFKA_CERT_PRIVATE_KEY,\n  RD_KAFKA_CERT_CA,\n  RD_KAFKA_CERT__CNT,\n} rd_kafka_cert_type_t;\ntypedef enum rd_kafka_cert_enc_t {\n  RD_KAFKA_CERT_ENC_PKCS12,\n  RD_KAFKA_CERT_ENC_DER,\n  RD_KAFKA_CERT_ENC_PEM,\n  RD_KAFKA_CERT_ENC__CNT,\n} rd_kafka_cert_enc_t;\nrd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert(rd_kafka_conf_t *conf, rd_kafka_cert_type_t cert_type, rd_kafka_cert_enc_t cert_enc, const void *buffer, size_t size, char *errstr, size_t errstr_size);\nvoid rd_kafka_conf_set_opaque(rd_kafka_conf_t *conf, void *opaque);\nvoid *rd_kafka_opaque(const rd_kafka_t *rk);\nvoid rd_kafka_conf_set_default_topic_conf(rd_kafka_conf_t *conf, rd_kafka_topic_conf_t *tconf);\nrd_kafka_topic_conf_t *rd_kafka_conf_get_default_topic_conf(rd_kafka_conf_t *conf);\nrd_kafka_conf_res_t rd_kafka_conf_get(const rd_kafka_conf_t *conf, const char *name, char *dest, size_t *dest_size);\nrd_kafka_conf_res_t rd_kafka_topic_conf_get(const rd_kafka_topic_conf_t *conf, const char *name, char *dest, size_t *dest_size);\nconst char **rd_kafka_conf_dump(rd_kafka_conf_t *conf, size_t *cntp);\nconst char **rd_kafka_topic_conf_dump(rd_kafka_topic_conf_t *conf, size_t *cntp);\nvoid rd_kafka_conf_dump_free(const char **arr, size_t cnt);\nvoid rd_kafka_conf_properties_show(FILE *fp);\nrd_kafka_topic_conf_t *rd_kafka_topic_conf_new(void);\nrd_kafka_topic_conf_t *rd_kafka_topic_conf_dup(const rd_kafka_topic_conf_t *conf);\nrd_kafka_topic_conf_t *rd_kafka_default_topic_conf_dup(rd_kafka_t *rk);\nvoid rd_kafka_topic_conf_destroy(rd_kafka_topic_conf_t *topic_conf);\nrd_kafka_conf_res_t rd_kafka_topic_conf_set(rd_kafka_topic_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);\nvoid rd_kafka_topic_conf_set_opaque(rd_kafka_topic_conf_t *conf, void *rkt_opaque);\nvoid rd_kafka_topic_conf_set_partitioner_cb(rd_kafka_topic_conf_t *topic_conf, int32_t (*partitioner)(const rd_kafka_topic_t *rkt, const void *keydata, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque));\nvoid rd_kafka_topic_conf_set_msg_order_cmp(rd_kafka_topic_conf_t *topic_conf, int (*msg_order_cmp)(const rd_kafka_message_t *a, const rd_kafka_message_t *b));\nint rd_kafka_topic_partition_available(const rd_kafka_topic_t *rkt, int32_t partition);\nint32_t rd_kafka_msg_partitioner_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_consistent(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_consistent_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_murmur2(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_murmur2_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_fnv1a(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_fnv1a_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nrd_kafka_t *rd_kafka_new(rd_kafka_type_t type, rd_kafka_conf_t *conf, char *errstr, size_t errstr_size);\nvoid rd_kafka_destroy(rd_kafka_t *rk);\nvoid rd_kafka_destroy_flags(rd_kafka_t *rk, int flags);\nconst char *rd_kafka_name(const rd_kafka_t *rk);\nrd_kafka_type_t rd_kafka_type(const rd_kafka_t *rk);\nchar *rd_kafka_memberid(const rd_kafka_t *rk);\nchar *rd_kafka_clusterid(rd_kafka_t *rk, int timeout_ms);\nint32_t rd_kafka_controllerid(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_topic_t *rd_kafka_topic_new(rd_kafka_t *rk, const char *topic, rd_kafka_topic_conf_t *conf);\nvoid rd_kafka_topic_destroy(rd_kafka_topic_t *rkt);\nconst char *rd_kafka_topic_name(const rd_kafka_topic_t *rkt);\nvoid *rd_kafka_topic_opaque(const rd_kafka_topic_t *rkt);\nint rd_kafka_poll(rd_kafka_t *rk, int timeout_ms);\nvoid rd_kafka_yield(rd_kafka_t *rk);\nrd_kafka_resp_err_t rd_kafka_pause_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_resp_err_t rd_kafka_resume_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_resp_err_t rd_kafka_query_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high, int timeout_ms);\nrd_kafka_resp_err_t rd_kafka_get_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high);\nrd_kafka_resp_err_t rd_kafka_offsets_for_times(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets, int timeout_ms);\nvoid rd_kafka_mem_free(rd_kafka_t *rk, void *ptr);\nrd_kafka_queue_t *rd_kafka_queue_new(rd_kafka_t *rk);\nvoid rd_kafka_queue_destroy(rd_kafka_queue_t *rkqu);\nrd_kafka_queue_t *rd_kafka_queue_get_main(rd_kafka_t *rk);\nrd_kafka_queue_t *rd_kafka_queue_get_consumer(rd_kafka_t *rk);\nrd_kafka_queue_t *rd_kafka_queue_get_partition(rd_kafka_t *rk, const char *topic, int32_t partition);\nrd_kafka_queue_t *rd_kafka_queue_get_background(rd_kafka_t *rk);\nvoid rd_kafka_queue_forward(rd_kafka_queue_t *src, rd_kafka_queue_t *dst);\nrd_kafka_resp_err_t rd_kafka_set_log_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu);\nsize_t rd_kafka_queue_length(rd_kafka_queue_t *rkqu);\nvoid rd_kafka_queue_io_event_enable(rd_kafka_queue_t *rkqu, int fd, const void *payload, size_t size);\nvoid rd_kafka_queue_cb_event_enable(rd_kafka_queue_t *rkqu, void (*event_cb)(rd_kafka_t *rk, void *qev_opaque), void *qev_opaque);\nvoid rd_kafka_queue_yield(rd_kafka_queue_t *rkqu);\nint rd_kafka_consume_start(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);\nint rd_kafka_consume_start_queue(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, rd_kafka_queue_t *rkqu);\nint rd_kafka_consume_stop(rd_kafka_topic_t *rkt, int32_t partition);\nrd_kafka_resp_err_t rd_kafka_seek(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, int timeout_ms);\nrd_kafka_error_t *rd_kafka_seek_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms);\nrd_kafka_message_t *rd_kafka_consume(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms);\nssize_t rd_kafka_consume_batch(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);\nint rd_kafka_consume_callback(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);\nrd_kafka_message_t *rd_kafka_consume_queue(rd_kafka_queue_t *rkqu, int timeout_ms);\nssize_t rd_kafka_consume_batch_queue(rd_kafka_queue_t *rkqu, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);\nint rd_kafka_consume_callback_queue(rd_kafka_queue_t *rkqu, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);\nrd_kafka_resp_err_t rd_kafka_offset_store(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);\nrd_kafka_resp_err_t rd_kafka_offsets_store(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets);\nrd_kafka_resp_err_t rd_kafka_subscribe(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *topics);\nrd_kafka_resp_err_t rd_kafka_unsubscribe(rd_kafka_t *rk);\nrd_kafka_resp_err_t rd_kafka_subscription(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **topics);\nrd_kafka_message_t *rd_kafka_consumer_poll(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_resp_err_t rd_kafka_consumer_close(rd_kafka_t *rk);\nrd_kafka_error_t *rd_kafka_incremental_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_error_t *rd_kafka_incremental_unassign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);\nconst char *rd_kafka_rebalance_protocol(rd_kafka_t *rk);\nrd_kafka_resp_err_t rd_kafka_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_resp_err_t rd_kafka_assignment(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **partitions);\nint rd_kafka_assignment_lost(rd_kafka_t *rk);\nrd_kafka_resp_err_t rd_kafka_commit(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, int async);\nrd_kafka_resp_err_t rd_kafka_commit_message(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, int async);\nrd_kafka_resp_err_t rd_kafka_commit_queue(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_queue_t *rkqu, void (*cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *commit_opaque), void *commit_opaque);\nrd_kafka_resp_err_t rd_kafka_committed(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms);\nrd_kafka_resp_err_t rd_kafka_position(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata(rd_kafka_t *rk);\nrd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata_new(const char *group_id);\nrd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata_new_with_genid(const char *group_id, int32_t generation_id, const char *member_id, const char *group_instance_id);\nvoid rd_kafka_consumer_group_metadata_destroy(rd_kafka_consumer_group_metadata_t *);\nrd_kafka_error_t *rd_kafka_consumer_group_metadata_write(const rd_kafka_consumer_group_metadata_t *cgmd, void **bufferp, size_t *sizep);\nrd_kafka_error_t *rd_kafka_consumer_group_metadata_read(rd_kafka_consumer_group_metadata_t **cgmdp, const void *buffer, size_t size);\nint rd_kafka_produce(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, void *payload, size_t len, const void *key, size_t keylen, void *msg_opaque);\nrd_kafka_resp_err_t rd_kafka_producev(rd_kafka_t *rk, ...);\nrd_kafka_error_t *rd_kafka_produceva(rd_kafka_t *rk, const rd_kafka_vu_t *vus, size_t cnt);\nint rd_kafka_produce_batch(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, rd_kafka_message_t *rkmessages, int message_cnt);\nrd_kafka_resp_err_t rd_kafka_flush(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_resp_err_t rd_kafka_purge(rd_kafka_t *rk, int purge_flags);\ntypedef struct rd_kafka_metadata_broker {\n  int32_t id;\n  char *host;\n  int port;\n} rd_kafka_metadata_broker_t;\ntypedef struct rd_kafka_metadata_partition {\n  int32_t id;\n  rd_kafka_resp_err_t err;\n  int32_t leader;\n  int replica_cnt;\n  int32_t *replicas;\n  int isr_cnt;\n  int32_t *isrs;\n} rd_kafka_metadata_partition_t;\ntypedef struct rd_kafka_metadata_topic {\n  char *topic;\n  int partition_cnt;\n  struct rd_kafka_metadata_partition *partitions;\n  rd_kafka_resp_err_t err;\n} rd_kafka_metadata_topic_t;\ntypedef struct rd_kafka_metadata {\n  int broker_cnt;\n  struct rd_kafka_metadata_broker *brokers;\n  int topic_cnt;\n  struct rd_kafka_metadata_topic *topics;\n  int32_t orig_broker_id;\n  char *orig_broker_name;\n} rd_kafka_metadata_t;\nrd_kafka_resp_err_t rd_kafka_metadata(rd_kafka_t *rk, int all_topics, rd_kafka_topic_t *only_rkt, const struct rd_kafka_metadata **metadatap, int timeout_ms);\nvoid rd_kafka_metadata_destroy(const struct rd_kafka_metadata *metadata);\nstruct rd_kafka_group_member_info {\n  char *member_id;\n  char *client_id;\n  char *client_host;\n  void *member_metadata;\n  int member_metadata_size;\n  void *member_assignment;\n  int member_assignment_size;\n};\nstruct rd_kafka_group_info {\n  struct rd_kafka_metadata_broker broker;\n  char *group;\n  rd_kafka_resp_err_t err;\n  char *state;\n  char *protocol_type;\n  char *protocol;\n  struct rd_kafka_group_member_info *members;\n  int member_cnt;\n};\nstruct rd_kafka_group_list {\n  struct rd_kafka_group_info *groups;\n  int group_cnt;\n};\nrd_kafka_resp_err_t rd_kafka_list_groups(rd_kafka_t *rk, const char *group, const struct rd_kafka_group_list **grplistp, int timeout_ms);\nvoid rd_kafka_group_list_destroy(const struct rd_kafka_group_list *grplist);\nint rd_kafka_brokers_add(rd_kafka_t *rk, const char *brokerlist);\nvoid rd_kafka_set_logger(rd_kafka_t *rk, void (*func)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));\nvoid rd_kafka_set_log_level(rd_kafka_t *rk, int level);\nvoid rd_kafka_log_print(const rd_kafka_t *rk, int level, const char *fac, const char *buf);\nvoid rd_kafka_log_syslog(const rd_kafka_t *rk, int level, const char *fac, const char *buf);\nint rd_kafka_outq_len(rd_kafka_t *rk);\nvoid rd_kafka_dump(FILE *fp, rd_kafka_t *rk);\nint rd_kafka_thread_cnt(void);\ntypedef enum rd_kafka_thread_type_t {\n  RD_KAFKA_THREAD_MAIN,\n  RD_KAFKA_THREAD_BACKGROUND,\n  RD_KAFKA_THREAD_BROKER,\n} rd_kafka_thread_type_t;\nint rd_kafka_wait_destroyed(int timeout_ms);\nint rd_kafka_unittest(void);\nrd_kafka_resp_err_t rd_kafka_poll_set_consumer(rd_kafka_t *rk);\ntypedef int rd_kafka_event_type_t;\nrd_kafka_event_type_t rd_kafka_event_type(const rd_kafka_event_t *rkev);\nconst char *rd_kafka_event_name(const rd_kafka_event_t *rkev);\nvoid rd_kafka_event_destroy(rd_kafka_event_t *rkev);\nconst rd_kafka_message_t *rd_kafka_event_message_next(rd_kafka_event_t *rkev);\nsize_t rd_kafka_event_message_array(rd_kafka_event_t *rkev, const rd_kafka_message_t **rkmessages, size_t size);\nsize_t rd_kafka_event_message_count(rd_kafka_event_t *rkev);\nconst char *rd_kafka_event_config_string(rd_kafka_event_t *rkev);\nrd_kafka_resp_err_t rd_kafka_event_error(rd_kafka_event_t *rkev);\nconst char *rd_kafka_event_error_string(rd_kafka_event_t *rkev);\nint rd_kafka_event_error_is_fatal(rd_kafka_event_t *rkev);\nvoid *rd_kafka_event_opaque(rd_kafka_event_t *rkev);\nint rd_kafka_event_log(rd_kafka_event_t *rkev, const char **fac, const char **str, int *level);\nint rd_kafka_event_debug_contexts(rd_kafka_event_t *rkev, char *dst, size_t dstsize);\nconst char *rd_kafka_event_stats(rd_kafka_event_t *rkev);\nrd_kafka_topic_partition_list_t *rd_kafka_event_topic_partition_list(rd_kafka_event_t *rkev);\nrd_kafka_topic_partition_t *rd_kafka_event_topic_partition(rd_kafka_event_t *rkev);\ntypedef rd_kafka_event_t rd_kafka_CreateTopics_result_t;\ntypedef rd_kafka_event_t rd_kafka_DeleteTopics_result_t;\ntypedef rd_kafka_event_t rd_kafka_CreatePartitions_result_t;\ntypedef rd_kafka_event_t rd_kafka_AlterConfigs_result_t;\ntypedef rd_kafka_event_t rd_kafka_DescribeConfigs_result_t;\ntypedef rd_kafka_event_t rd_kafka_DeleteRecords_result_t;\ntypedef rd_kafka_event_t rd_kafka_DeleteGroups_result_t;\ntypedef rd_kafka_event_t rd_kafka_DeleteConsumerGroupOffsets_result_t;\nconst rd_kafka_CreateTopics_result_t *rd_kafka_event_CreateTopics_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DeleteTopics_result_t *rd_kafka_event_DeleteTopics_result(rd_kafka_event_t *rkev);\nconst rd_kafka_CreatePartitions_result_t *rd_kafka_event_CreatePartitions_result(rd_kafka_event_t *rkev);\nconst rd_kafka_AlterConfigs_result_t *rd_kafka_event_AlterConfigs_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DescribeConfigs_result_t *rd_kafka_event_DescribeConfigs_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DeleteRecords_result_t *rd_kafka_event_DeleteRecords_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DeleteGroups_result_t *rd_kafka_event_DeleteGroups_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DeleteConsumerGroupOffsets_result_t *rd_kafka_event_DeleteConsumerGroupOffsets_result(rd_kafka_event_t *rkev);\nrd_kafka_event_t *rd_kafka_queue_poll(rd_kafka_queue_t *rkqu, int timeout_ms);\nint rd_kafka_queue_poll_callback(rd_kafka_queue_t *rkqu, int timeout_ms);\ntypedef rd_kafka_resp_err_t (rd_kafka_plugin_f_conf_init_t)(rd_kafka_conf_t *conf, void **plug_opaquep, char *errstr, size_t errstr_size);\ntypedef rd_kafka_conf_res_t (rd_kafka_interceptor_f_on_conf_set_t)(rd_kafka_conf_t *conf, const char *name, const char *val, char *errstr, size_t errstr_size, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_dup_t)(rd_kafka_conf_t *new_conf, const rd_kafka_conf_t *old_conf, size_t filter_cnt, const char **filter, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_destroy_t)(void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_new_t)(rd_kafka_t *rk, const rd_kafka_conf_t *conf, void *ic_opaque, char *errstr, size_t errstr_size);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_destroy_t)(rd_kafka_t *rk, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_send_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_acknowledgement_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_consume_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_commit_t)(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_resp_err_t err, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_request_sent_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_response_received_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, int64_t rtt, rd_kafka_resp_err_t err, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_start_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_exit_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_set(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_set_t *on_conf_set, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_dup(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_dup_t *on_conf_dup, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_destroy(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_destroy_t *on_conf_destroy, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_new(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_new_t *on_new, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_destroy(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_destroy_t *on_destroy, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_send(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_send_t *on_send, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_acknowledgement(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_acknowledgement_t *on_acknowledgement, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_consume(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_consume_t *on_consume, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_commit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_commit_t *on_commit, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_request_sent(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_request_sent_t *on_request_sent, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_response_received(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_response_received_t *on_response_received, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_start(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_start_t *on_thread_start, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_exit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_exit_t *on_thread_exit, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_topic_result_error(const rd_kafka_topic_result_t *topicres);\nconst char *rd_kafka_topic_result_error_string(const rd_kafka_topic_result_t *topicres);\nconst char *rd_kafka_topic_result_name(const rd_kafka_topic_result_t *topicres);\nconst rd_kafka_error_t *rd_kafka_group_result_error(const rd_kafka_group_result_t *groupres);\nconst char *rd_kafka_group_result_name(const rd_kafka_group_result_t *groupres);\nconst rd_kafka_topic_partition_list_t *rd_kafka_group_result_partitions(const rd_kafka_group_result_t *groupres);\ntypedef enum rd_kafka_admin_op_t {\n  RD_KAFKA_ADMIN_OP_ANY = 0,\n  RD_KAFKA_ADMIN_OP_CREATETOPICS,\n  RD_KAFKA_ADMIN_OP_DELETETOPICS,\n  RD_KAFKA_ADMIN_OP_CREATEPARTITIONS,\n  RD_KAFKA_ADMIN_OP_ALTERCONFIGS,\n  RD_KAFKA_ADMIN_OP_DESCRIBECONFIGS,\n  RD_KAFKA_ADMIN_OP_DELETERECORDS,\n  RD_KAFKA_ADMIN_OP_DELETEGROUPS,\n  RD_KAFKA_ADMIN_OP_DELETECONSUMERGROUPOFFSETS,\n  RD_KAFKA_ADMIN_OP__CNT,\n} rd_kafka_admin_op_t;\ntypedef struct rd_kafka_AdminOptions_s rd_kafka_AdminOptions_t;\nrd_kafka_AdminOptions_t *rd_kafka_AdminOptions_new(rd_kafka_t *rk, rd_kafka_admin_op_t for_api);\nvoid rd_kafka_AdminOptions_destroy(rd_kafka_AdminOptions_t *options);\nrd_kafka_resp_err_t rd_kafka_AdminOptions_set_request_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_AdminOptions_set_operation_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_AdminOptions_set_validate_only(rd_kafka_AdminOptions_t *options, int true_or_false, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_AdminOptions_set_broker(rd_kafka_AdminOptions_t *options, int32_t broker_id, char *errstr, size_t errstr_size);\nvoid rd_kafka_AdminOptions_set_opaque(rd_kafka_AdminOptions_t *options, void *ev_opaque);\ntypedef struct rd_kafka_NewTopic_s rd_kafka_NewTopic_t;\nrd_kafka_NewTopic_t *rd_kafka_NewTopic_new(const char *topic, int num_partitions, int replication_factor, char *errstr, size_t errstr_size);\nvoid rd_kafka_NewTopic_destroy(rd_kafka_NewTopic_t *new_topic);\nvoid rd_kafka_NewTopic_destroy_array(rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt);\nrd_kafka_resp_err_t rd_kafka_NewTopic_set_replica_assignment(rd_kafka_NewTopic_t *new_topic, int32_t partition, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_NewTopic_set_config(rd_kafka_NewTopic_t *new_topic, const char *name, const char *value);\nvoid rd_kafka_CreateTopics(rd_kafka_t *rk, rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_topic_result_t **rd_kafka_CreateTopics_result_topics(const rd_kafka_CreateTopics_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_DeleteTopic_s rd_kafka_DeleteTopic_t;\nrd_kafka_DeleteTopic_t *rd_kafka_DeleteTopic_new(const char *topic);\nvoid rd_kafka_DeleteTopic_destroy(rd_kafka_DeleteTopic_t *del_topic);\nvoid rd_kafka_DeleteTopic_destroy_array(rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt);\nvoid rd_kafka_DeleteTopics(rd_kafka_t *rk, rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_topic_result_t **rd_kafka_DeleteTopics_result_topics(const rd_kafka_DeleteTopics_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_NewPartitions_s rd_kafka_NewPartitions_t;\nrd_kafka_NewPartitions_t *rd_kafka_NewPartitions_new(const char *topic, size_t new_total_cnt, char *errstr, size_t errstr_size);\nvoid rd_kafka_NewPartitions_destroy(rd_kafka_NewPartitions_t *new_parts);\nvoid rd_kafka_NewPartitions_destroy_array(rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt);\nrd_kafka_resp_err_t rd_kafka_NewPartitions_set_replica_assignment(rd_kafka_NewPartitions_t *new_parts, int32_t new_partition_idx, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);\nvoid rd_kafka_CreatePartitions(rd_kafka_t *rk, rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_topic_result_t **rd_kafka_CreatePartitions_result_topics(const rd_kafka_CreatePartitions_result_t *result, size_t *cntp);\ntypedef enum rd_kafka_ConfigSource_t {\n  RD_KAFKA_CONFIG_SOURCE_UNKNOWN_CONFIG = 0,\n  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_TOPIC_CONFIG = 1,\n  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_BROKER_CONFIG = 2,\n  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_DEFAULT_BROKER_CONFIG = 3,\n  RD_KAFKA_CONFIG_SOURCE_STATIC_BROKER_CONFIG = 4,\n  RD_KAFKA_CONFIG_SOURCE_DEFAULT_CONFIG = 5,\n  RD_KAFKA_CONFIG_SOURCE__CNT,\n} rd_kafka_ConfigSource_t;\nconst char *rd_kafka_ConfigSource_name(rd_kafka_ConfigSource_t confsource);\ntypedef struct rd_kafka_ConfigEntry_s rd_kafka_ConfigEntry_t;\nconst char *rd_kafka_ConfigEntry_name(const rd_kafka_ConfigEntry_t *entry);\nconst char *rd_kafka_ConfigEntry_value(const rd_kafka_ConfigEntry_t *entry);\nrd_kafka_ConfigSource_t rd_kafka_ConfigEntry_source(const rd_kafka_ConfigEntry_t *entry);\nint rd_kafka_ConfigEntry_is_read_only(const rd_kafka_ConfigEntry_t *entry);\nint rd_kafka_ConfigEntry_is_default(const rd_kafka_ConfigEntry_t *entry);\nint rd_kafka_ConfigEntry_is_sensitive(const rd_kafka_ConfigEntry_t *entry);\nint rd_kafka_ConfigEntry_is_synonym(const rd_kafka_ConfigEntry_t *entry);\nconst rd_kafka_ConfigEntry_t **rd_kafka_ConfigEntry_synonyms(const rd_kafka_ConfigEntry_t *entry, size_t *cntp);\ntypedef enum rd_kafka_ResourceType_t {\n  RD_KAFKA_RESOURCE_UNKNOWN = 0,\n  RD_KAFKA_RESOURCE_ANY = 1,\n  RD_KAFKA_RESOURCE_TOPIC = 2,\n  RD_KAFKA_RESOURCE_GROUP = 3,\n  RD_KAFKA_RESOURCE_BROKER = 4,\n  RD_KAFKA_RESOURCE__CNT,\n} rd_kafka_ResourceType_t;\nconst char *rd_kafka_ResourceType_name(rd_kafka_ResourceType_t restype);\ntypedef struct rd_kafka_ConfigResource_s rd_kafka_ConfigResource_t;\nrd_kafka_ConfigResource_t *rd_kafka_ConfigResource_new(rd_kafka_ResourceType_t restype, const char *resname);\nvoid rd_kafka_ConfigResource_destroy(rd_kafka_ConfigResource_t *config);\nvoid rd_kafka_ConfigResource_destroy_array(rd_kafka_ConfigResource_t **config, size_t config_cnt);\nrd_kafka_resp_err_t rd_kafka_ConfigResource_set_config(rd_kafka_ConfigResource_t *config, const char *name, const char *value);\nconst rd_kafka_ConfigEntry_t **rd_kafka_ConfigResource_configs(const rd_kafka_ConfigResource_t *config, size_t *cntp);\nrd_kafka_ResourceType_t rd_kafka_ConfigResource_type(const rd_kafka_ConfigResource_t *config);\nconst char *rd_kafka_ConfigResource_name(const rd_kafka_ConfigResource_t *config);\nrd_kafka_resp_err_t rd_kafka_ConfigResource_error(const rd_kafka_ConfigResource_t *config);\nconst char *rd_kafka_ConfigResource_error_string(const rd_kafka_ConfigResource_t *config);\nvoid rd_kafka_AlterConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_ConfigResource_t **rd_kafka_AlterConfigs_result_resources(const rd_kafka_AlterConfigs_result_t *result, size_t *cntp);\nvoid rd_kafka_DescribeConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_ConfigResource_t **rd_kafka_DescribeConfigs_result_resources(const rd_kafka_DescribeConfigs_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_DeleteRecords_s rd_kafka_DeleteRecords_t;\nrd_kafka_DeleteRecords_t *rd_kafka_DeleteRecords_new(const rd_kafka_topic_partition_list_t *before_offsets);\nvoid rd_kafka_DeleteRecords_destroy(rd_kafka_DeleteRecords_t *del_records);\nvoid rd_kafka_DeleteRecords_destroy_array(rd_kafka_DeleteRecords_t **del_records, size_t del_record_cnt);\nvoid rd_kafka_DeleteRecords(rd_kafka_t *rk, rd_kafka_DeleteRecords_t **del_records, size_t del_record_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_topic_partition_list_t *rd_kafka_DeleteRecords_result_offsets(const rd_kafka_DeleteRecords_result_t *result);\ntypedef struct rd_kafka_DeleteGroup_s rd_kafka_DeleteGroup_t;\nrd_kafka_DeleteGroup_t *rd_kafka_DeleteGroup_new(const char *group);\nvoid rd_kafka_DeleteGroup_destroy(rd_kafka_DeleteGroup_t *del_group);\nvoid rd_kafka_DeleteGroup_destroy_array(rd_kafka_DeleteGroup_t **del_groups, size_t del_group_cnt);\nvoid rd_kafka_DeleteGroups(rd_kafka_t *rk, rd_kafka_DeleteGroup_t **del_groups, size_t del_group_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_group_result_t **rd_kafka_DeleteGroups_result_groups(const rd_kafka_DeleteGroups_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_DeleteConsumerGroupOffsets_s rd_kafka_DeleteConsumerGroupOffsets_t;\nrd_kafka_DeleteConsumerGroupOffsets_t *rd_kafka_DeleteConsumerGroupOffsets_new(const char *group, const rd_kafka_topic_partition_list_t *partitions);\nvoid rd_kafka_DeleteConsumerGroupOffsets_destroy(rd_kafka_DeleteConsumerGroupOffsets_t *del_grpoffsets);\nvoid rd_kafka_DeleteConsumerGroupOffsets_destroy_array(rd_kafka_DeleteConsumerGroupOffsets_t **del_grpoffsets, size_t del_grpoffset_cnt);\nvoid rd_kafka_DeleteConsumerGroupOffsets(rd_kafka_t *rk, rd_kafka_DeleteConsumerGroupOffsets_t **del_grpoffsets, size_t del_grpoffsets_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_group_result_t **rd_kafka_DeleteConsumerGroupOffsets_result_groups(const rd_kafka_DeleteConsumerGroupOffsets_result_t *result, size_t *cntp);\nrd_kafka_resp_err_t rd_kafka_oauthbearer_set_token(rd_kafka_t *rk, const char *token_value, int64_t md_lifetime_ms, const char *md_principal_name, const char **extensions, size_t extension_size, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_oauthbearer_set_token_failure(rd_kafka_t *rk, const char *errstr);\nrd_kafka_error_t *rd_kafka_init_transactions(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_error_t *rd_kafka_begin_transaction(rd_kafka_t *rk);\nrd_kafka_error_t *rd_kafka_send_offsets_to_transaction(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, const rd_kafka_consumer_group_metadata_t *cgmetadata, int timeout_ms);\nrd_kafka_error_t *rd_kafka_commit_transaction(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_error_t *rd_kafka_abort_transaction(rd_kafka_t *rk, int timeout_ms);\ntypedef struct rd_kafka_mock_cluster_s rd_kafka_mock_cluster_t;\nrd_kafka_mock_cluster_t *rd_kafka_mock_cluster_new(rd_kafka_t *rk, int broker_cnt);\nvoid rd_kafka_mock_cluster_destroy(rd_kafka_mock_cluster_t *mcluster);\nrd_kafka_t *rd_kafka_mock_cluster_handle(const rd_kafka_mock_cluster_t *mcluster);\nrd_kafka_mock_cluster_t *rd_kafka_handle_mock_cluster(const rd_kafka_t *rk);\nconst char *rd_kafka_mock_cluster_bootstraps(const rd_kafka_mock_cluster_t *mcluster);\nvoid rd_kafka_mock_clear_request_errors(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey);\nvoid rd_kafka_mock_push_request_errors(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, size_t cnt, ...);\nvoid rd_kafka_mock_push_request_errors_array(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, size_t cnt, const rd_kafka_resp_err_t *errors);\nrd_kafka_resp_err_t rd_kafka_mock_broker_push_request_errors(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int16_t ApiKey, size_t cnt, ...);\nvoid rd_kafka_mock_topic_set_error(rd_kafka_mock_cluster_t *mcluster, const char *topic, rd_kafka_resp_err_t err);\nrd_kafka_resp_err_t rd_kafka_mock_topic_create(rd_kafka_mock_cluster_t *mcluster, const char *topic, int partition_cnt, int replication_factor);\nrd_kafka_resp_err_t rd_kafka_mock_partition_set_leader(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id);\nrd_kafka_resp_err_t rd_kafka_mock_partition_set_follower(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id);\nrd_kafka_resp_err_t rd_kafka_mock_partition_set_follower_wmarks(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int64_t lo, int64_t hi);\nrd_kafka_resp_err_t rd_kafka_mock_broker_set_down(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id);\nrd_kafka_resp_err_t rd_kafka_mock_broker_set_up(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id);\nrd_kafka_resp_err_t rd_kafka_mock_broker_set_rtt(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int rtt_ms);\nrd_kafka_resp_err_t rd_kafka_mock_broker_set_rack(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, const char *rack);\nrd_kafka_resp_err_t rd_kafka_mock_coordinator_set(rd_kafka_mock_cluster_t *mcluster, const char *key_type, const char *key, int32_t broker_id);\nrd_kafka_resp_err_t rd_kafka_mock_set_apiversion(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, int16_t MinVersion, int16_t MaxVersion);\n'\n</code></pre> rdkafka.h, rdkafka_mock.h</p>"},{"location":"api/constants/#rd_kafka_version_15","title":"RD_KAFKA_VERSION","text":"<pre><code>public RD_KAFKA_VERSION = 17171199\n</code></pre> <p>librdkafka version </p> <p>Interpreted as hex <code>MM.mm.rr.xx</code>:</p> <ul> <li>MM = Major</li> <li>mm = minor</li> <li>rr = revision</li> <li>xx = pre-release id (0xff is the final release)</li> </ul> <p>E.g.: <code>0x000801ff</code> = 0.8.1</p> RemarksThis value should only be used during compile time, for runtime checks of version use rd_kafka_version()  <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_unsupported_compression_type_15","title":"RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE","text":"<pre><code>public RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76\n</code></pre> <p>Unsupported compression type </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_end_all_15","title":"RD_KAFKA_RESP_ERR_END_ALL","text":"<p><pre><code>public RD_KAFKA_RESP_ERR_END_ALL = 98\n</code></pre> enum rd_kafka_resp_err_t</p>"},{"location":"api/constants/#rd_kafka_admin_op__cnt_15","title":"RD_KAFKA_ADMIN_OP__CNT","text":"<pre><code>public RD_KAFKA_ADMIN_OP__CNT = 9\n</code></pre> <p>Number of ops defined </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe </li> </ul>"},{"location":"api/constants/#rd_kafka_resource__cnt_15","title":"RD_KAFKA_RESOURCE__CNT","text":"<pre><code>public RD_KAFKA_RESOURCE__CNT = 5\n</code></pre> <p>Number of resource types defined </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#acca83a66d7783ff7683ed2691cc907c9 </li> </ul>"},{"location":"api/constants/#rd_kafka_cdef_15","title":"RD_KAFKA_CDEF","text":"<p><pre><code>public RD_KAFKA_CDEF = 'typedef long int ssize_t;\ntypedef struct _IO_FILE FILE;\ntypedef long int mode_t;\ntypedef signed int int16_t;\ntypedef unsigned int uint16_t;\ntypedef signed int int32_t;\ntypedef signed long int int64_t;\nint rd_kafka_version(void);\nconst char *rd_kafka_version_str(void);\ntypedef enum rd_kafka_type_t {\n  RD_KAFKA_PRODUCER,\n  RD_KAFKA_CONSUMER,\n} rd_kafka_type_t;\ntypedef enum rd_kafka_timestamp_type_t {\n  RD_KAFKA_TIMESTAMP_NOT_AVAILABLE,\n  RD_KAFKA_TIMESTAMP_CREATE_TIME,\n  RD_KAFKA_TIMESTAMP_LOG_APPEND_TIME,\n} rd_kafka_timestamp_type_t;\nconst char *rd_kafka_get_debug_contexts(void);\ntypedef struct rd_kafka_s rd_kafka_t;\ntypedef struct rd_kafka_topic_s rd_kafka_topic_t;\ntypedef struct rd_kafka_conf_s rd_kafka_conf_t;\ntypedef struct rd_kafka_topic_conf_s rd_kafka_topic_conf_t;\ntypedef struct rd_kafka_queue_s rd_kafka_queue_t;\ntypedef struct rd_kafka_op_s rd_kafka_event_t;\ntypedef struct rd_kafka_topic_result_s rd_kafka_topic_result_t;\ntypedef struct rd_kafka_consumer_group_metadata_s rd_kafka_consumer_group_metadata_t;\ntypedef struct rd_kafka_error_s {\n  unsigned int code;\n  char *errstr;\n  unsigned char fatal;\n  unsigned char retriable;\n  unsigned char txn_requires_abort;\n} rd_kafka_error_t;\ntypedef struct rd_kafka_headers_s rd_kafka_headers_t;\ntypedef struct rd_kafka_group_result_s rd_kafka_group_result_t;\ntypedef enum {\n  RD_KAFKA_RESP_ERR__BEGIN = (- 200),\n  RD_KAFKA_RESP_ERR__BAD_MSG = (- 199),\n  RD_KAFKA_RESP_ERR__BAD_COMPRESSION = (- 198),\n  RD_KAFKA_RESP_ERR__DESTROY = (- 197),\n  RD_KAFKA_RESP_ERR__FAIL = (- 196),\n  RD_KAFKA_RESP_ERR__TRANSPORT = (- 195),\n  RD_KAFKA_RESP_ERR__CRIT_SYS_RESOURCE = (- 194),\n  RD_KAFKA_RESP_ERR__RESOLVE = (- 193),\n  RD_KAFKA_RESP_ERR__MSG_TIMED_OUT = (- 192),\n  RD_KAFKA_RESP_ERR__PARTITION_EOF = (- 191),\n  RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION = (- 190),\n  RD_KAFKA_RESP_ERR__FS = (- 189),\n  RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC = (- 188),\n  RD_KAFKA_RESP_ERR__ALL_BROKERS_DOWN = (- 187),\n  RD_KAFKA_RESP_ERR__INVALID_ARG = (- 186),\n  RD_KAFKA_RESP_ERR__TIMED_OUT = (- 185),\n  RD_KAFKA_RESP_ERR__QUEUE_FULL = (- 184),\n  RD_KAFKA_RESP_ERR__ISR_INSUFF = (- 183),\n  RD_KAFKA_RESP_ERR__NODE_UPDATE = (- 182),\n  RD_KAFKA_RESP_ERR__SSL = (- 181),\n  RD_KAFKA_RESP_ERR__WAIT_COORD = (- 180),\n  RD_KAFKA_RESP_ERR__UNKNOWN_GROUP = (- 179),\n  RD_KAFKA_RESP_ERR__IN_PROGRESS = (- 178),\n  RD_KAFKA_RESP_ERR__PREV_IN_PROGRESS = (- 177),\n  RD_KAFKA_RESP_ERR__EXISTING_SUBSCRIPTION = (- 176),\n  RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS = (- 175),\n  RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS = (- 174),\n  RD_KAFKA_RESP_ERR__CONFLICT = (- 173),\n  RD_KAFKA_RESP_ERR__STATE = (- 172),\n  RD_KAFKA_RESP_ERR__UNKNOWN_PROTOCOL = (- 171),\n  RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED = (- 170),\n  RD_KAFKA_RESP_ERR__AUTHENTICATION = (- 169),\n  RD_KAFKA_RESP_ERR__NO_OFFSET = (- 168),\n  RD_KAFKA_RESP_ERR__OUTDATED = (- 167),\n  RD_KAFKA_RESP_ERR__TIMED_OUT_QUEUE = (- 166),\n  RD_KAFKA_RESP_ERR__UNSUPPORTED_FEATURE = (- 165),\n  RD_KAFKA_RESP_ERR__WAIT_CACHE = (- 164),\n  RD_KAFKA_RESP_ERR__INTR = (- 163),\n  RD_KAFKA_RESP_ERR__KEY_SERIALIZATION = (- 162),\n  RD_KAFKA_RESP_ERR__VALUE_SERIALIZATION = (- 161),\n  RD_KAFKA_RESP_ERR__KEY_DESERIALIZATION = (- 160),\n  RD_KAFKA_RESP_ERR__VALUE_DESERIALIZATION = (- 159),\n  RD_KAFKA_RESP_ERR__PARTIAL = (- 158),\n  RD_KAFKA_RESP_ERR__READ_ONLY = (- 157),\n  RD_KAFKA_RESP_ERR__NOENT = (- 156),\n  RD_KAFKA_RESP_ERR__UNDERFLOW = (- 155),\n  RD_KAFKA_RESP_ERR__INVALID_TYPE = (- 154),\n  RD_KAFKA_RESP_ERR__RETRY = (- 153),\n  RD_KAFKA_RESP_ERR__PURGE_QUEUE = (- 152),\n  RD_KAFKA_RESP_ERR__PURGE_INFLIGHT = (- 151),\n  RD_KAFKA_RESP_ERR__FATAL = (- 150),\n  RD_KAFKA_RESP_ERR__INCONSISTENT = (- 149),\n  RD_KAFKA_RESP_ERR__GAPLESS_GUARANTEE = (- 148),\n  RD_KAFKA_RESP_ERR__MAX_POLL_EXCEEDED = (- 147),\n  RD_KAFKA_RESP_ERR__UNKNOWN_BROKER = (- 146),\n  RD_KAFKA_RESP_ERR__NOT_CONFIGURED = (- 145),\n  RD_KAFKA_RESP_ERR__FENCED = (- 144),\n  RD_KAFKA_RESP_ERR__APPLICATION = (- 143),\n  RD_KAFKA_RESP_ERR__ASSIGNMENT_LOST = (- 142),\n  RD_KAFKA_RESP_ERR__NOOP = (- 141),\n  RD_KAFKA_RESP_ERR__AUTO_OFFSET_RESET = (- 140),\n  RD_KAFKA_RESP_ERR__END = (- 100),\n  RD_KAFKA_RESP_ERR_UNKNOWN = (- 1),\n  RD_KAFKA_RESP_ERR_NO_ERROR = 0,\n  RD_KAFKA_RESP_ERR_OFFSET_OUT_OF_RANGE = 1,\n  RD_KAFKA_RESP_ERR_INVALID_MSG = 2,\n  RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART = 3,\n  RD_KAFKA_RESP_ERR_INVALID_MSG_SIZE = 4,\n  RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE = 5,\n  RD_KAFKA_RESP_ERR_NOT_LEADER_FOR_PARTITION = 6,\n  RD_KAFKA_RESP_ERR_REQUEST_TIMED_OUT = 7,\n  RD_KAFKA_RESP_ERR_BROKER_NOT_AVAILABLE = 8,\n  RD_KAFKA_RESP_ERR_REPLICA_NOT_AVAILABLE = 9,\n  RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE = 10,\n  RD_KAFKA_RESP_ERR_STALE_CTRL_EPOCH = 11,\n  RD_KAFKA_RESP_ERR_OFFSET_METADATA_TOO_LARGE = 12,\n  RD_KAFKA_RESP_ERR_NETWORK_EXCEPTION = 13,\n  RD_KAFKA_RESP_ERR_COORDINATOR_LOAD_IN_PROGRESS = 14,\n  RD_KAFKA_RESP_ERR_COORDINATOR_NOT_AVAILABLE = 15,\n  RD_KAFKA_RESP_ERR_NOT_COORDINATOR = 16,\n  RD_KAFKA_RESP_ERR_TOPIC_EXCEPTION = 17,\n  RD_KAFKA_RESP_ERR_RECORD_LIST_TOO_LARGE = 18,\n  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS = 19,\n  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS_AFTER_APPEND = 20,\n  RD_KAFKA_RESP_ERR_INVALID_REQUIRED_ACKS = 21,\n  RD_KAFKA_RESP_ERR_ILLEGAL_GENERATION = 22,\n  RD_KAFKA_RESP_ERR_INCONSISTENT_GROUP_PROTOCOL = 23,\n  RD_KAFKA_RESP_ERR_INVALID_GROUP_ID = 24,\n  RD_KAFKA_RESP_ERR_UNKNOWN_MEMBER_ID = 25,\n  RD_KAFKA_RESP_ERR_INVALID_SESSION_TIMEOUT = 26,\n  RD_KAFKA_RESP_ERR_REBALANCE_IN_PROGRESS = 27,\n  RD_KAFKA_RESP_ERR_INVALID_COMMIT_OFFSET_SIZE = 28,\n  RD_KAFKA_RESP_ERR_TOPIC_AUTHORIZATION_FAILED = 29,\n  RD_KAFKA_RESP_ERR_GROUP_AUTHORIZATION_FAILED = 30,\n  RD_KAFKA_RESP_ERR_CLUSTER_AUTHORIZATION_FAILED = 31,\n  RD_KAFKA_RESP_ERR_INVALID_TIMESTAMP = 32,\n  RD_KAFKA_RESP_ERR_UNSUPPORTED_SASL_MECHANISM = 33,\n  RD_KAFKA_RESP_ERR_ILLEGAL_SASL_STATE = 34,\n  RD_KAFKA_RESP_ERR_UNSUPPORTED_VERSION = 35,\n  RD_KAFKA_RESP_ERR_TOPIC_ALREADY_EXISTS = 36,\n  RD_KAFKA_RESP_ERR_INVALID_PARTITIONS = 37,\n  RD_KAFKA_RESP_ERR_INVALID_REPLICATION_FACTOR = 38,\n  RD_KAFKA_RESP_ERR_INVALID_REPLICA_ASSIGNMENT = 39,\n  RD_KAFKA_RESP_ERR_INVALID_CONFIG = 40,\n  RD_KAFKA_RESP_ERR_NOT_CONTROLLER = 41,\n  RD_KAFKA_RESP_ERR_INVALID_REQUEST = 42,\n  RD_KAFKA_RESP_ERR_UNSUPPORTED_FOR_MESSAGE_FORMAT = 43,\n  RD_KAFKA_RESP_ERR_POLICY_VIOLATION = 44,\n  RD_KAFKA_RESP_ERR_OUT_OF_ORDER_SEQUENCE_NUMBER = 45,\n  RD_KAFKA_RESP_ERR_DUPLICATE_SEQUENCE_NUMBER = 46,\n  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_EPOCH = 47,\n  RD_KAFKA_RESP_ERR_INVALID_TXN_STATE = 48,\n  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_ID_MAPPING = 49,\n  RD_KAFKA_RESP_ERR_INVALID_TRANSACTION_TIMEOUT = 50,\n  RD_KAFKA_RESP_ERR_CONCURRENT_TRANSACTIONS = 51,\n  RD_KAFKA_RESP_ERR_TRANSACTION_COORDINATOR_FENCED = 52,\n  RD_KAFKA_RESP_ERR_TRANSACTIONAL_ID_AUTHORIZATION_FAILED = 53,\n  RD_KAFKA_RESP_ERR_SECURITY_DISABLED = 54,\n  RD_KAFKA_RESP_ERR_OPERATION_NOT_ATTEMPTED = 55,\n  RD_KAFKA_RESP_ERR_KAFKA_STORAGE_ERROR = 56,\n  RD_KAFKA_RESP_ERR_LOG_DIR_NOT_FOUND = 57,\n  RD_KAFKA_RESP_ERR_SASL_AUTHENTICATION_FAILED = 58,\n  RD_KAFKA_RESP_ERR_UNKNOWN_PRODUCER_ID = 59,\n  RD_KAFKA_RESP_ERR_REASSIGNMENT_IN_PROGRESS = 60,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTH_DISABLED = 61,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_NOT_FOUND = 62,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_OWNER_MISMATCH = 63,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_REQUEST_NOT_ALLOWED = 64,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTHORIZATION_FAILED = 65,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_EXPIRED = 66,\n  RD_KAFKA_RESP_ERR_INVALID_PRINCIPAL_TYPE = 67,\n  RD_KAFKA_RESP_ERR_NON_EMPTY_GROUP = 68,\n  RD_KAFKA_RESP_ERR_GROUP_ID_NOT_FOUND = 69,\n  RD_KAFKA_RESP_ERR_FETCH_SESSION_ID_NOT_FOUND = 70,\n  RD_KAFKA_RESP_ERR_INVALID_FETCH_SESSION_EPOCH = 71,\n  RD_KAFKA_RESP_ERR_LISTENER_NOT_FOUND = 72,\n  RD_KAFKA_RESP_ERR_TOPIC_DELETION_DISABLED = 73,\n  RD_KAFKA_RESP_ERR_FENCED_LEADER_EPOCH = 74,\n  RD_KAFKA_RESP_ERR_UNKNOWN_LEADER_EPOCH = 75,\n  RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76,\n  RD_KAFKA_RESP_ERR_STALE_BROKER_EPOCH = 77,\n  RD_KAFKA_RESP_ERR_OFFSET_NOT_AVAILABLE = 78,\n  RD_KAFKA_RESP_ERR_MEMBER_ID_REQUIRED = 79,\n  RD_KAFKA_RESP_ERR_PREFERRED_LEADER_NOT_AVAILABLE = 80,\n  RD_KAFKA_RESP_ERR_GROUP_MAX_SIZE_REACHED = 81,\n  RD_KAFKA_RESP_ERR_FENCED_INSTANCE_ID = 82,\n  RD_KAFKA_RESP_ERR_ELIGIBLE_LEADERS_NOT_AVAILABLE = 83,\n  RD_KAFKA_RESP_ERR_ELECTION_NOT_NEEDED = 84,\n  RD_KAFKA_RESP_ERR_NO_REASSIGNMENT_IN_PROGRESS = 85,\n  RD_KAFKA_RESP_ERR_GROUP_SUBSCRIBED_TO_TOPIC = 86,\n  RD_KAFKA_RESP_ERR_INVALID_RECORD = 87,\n  RD_KAFKA_RESP_ERR_UNSTABLE_OFFSET_COMMIT = 88,\n  RD_KAFKA_RESP_ERR_THROTTLING_QUOTA_EXCEEDED = 89,\n  RD_KAFKA_RESP_ERR_PRODUCER_FENCED = 90,\n  RD_KAFKA_RESP_ERR_RESOURCE_NOT_FOUND = 91,\n  RD_KAFKA_RESP_ERR_DUPLICATE_RESOURCE = 92,\n  RD_KAFKA_RESP_ERR_UNACCEPTABLE_CREDENTIAL = 93,\n  RD_KAFKA_RESP_ERR_INCONSISTENT_VOTER_SET = 94,\n  RD_KAFKA_RESP_ERR_INVALID_UPDATE_VERSION = 95,\n  RD_KAFKA_RESP_ERR_FEATURE_UPDATE_FAILED = 96,\n  RD_KAFKA_RESP_ERR_PRINCIPAL_DESERIALIZATION_FAILURE = 97,\n  RD_KAFKA_RESP_ERR_END_ALL,\n} rd_kafka_resp_err_t;\nstruct rd_kafka_err_desc {\n  rd_kafka_resp_err_t code;\n  char *name;\n  char *desc;\n};\nvoid rd_kafka_get_err_descs(const struct rd_kafka_err_desc **errdescs, size_t *cntp);\nconst char *rd_kafka_err2str(rd_kafka_resp_err_t err);\nconst char *rd_kafka_err2name(rd_kafka_resp_err_t err);\nrd_kafka_resp_err_t rd_kafka_last_error(void);\nrd_kafka_resp_err_t rd_kafka_errno2err(int errnox);\nint rd_kafka_errno(void);\nrd_kafka_resp_err_t rd_kafka_fatal_error(rd_kafka_t *rk, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_test_fatal_error(rd_kafka_t *rk, rd_kafka_resp_err_t err, const char *reason);\nrd_kafka_resp_err_t rd_kafka_error_code(const rd_kafka_error_t *error);\nconst char *rd_kafka_error_name(const rd_kafka_error_t *error);\nconst char *rd_kafka_error_string(const rd_kafka_error_t *error);\nint rd_kafka_error_is_fatal(const rd_kafka_error_t *error);\nint rd_kafka_error_is_retriable(const rd_kafka_error_t *error);\nint rd_kafka_error_txn_requires_abort(const rd_kafka_error_t *error);\nvoid rd_kafka_error_destroy(rd_kafka_error_t *error);\nrd_kafka_error_t *rd_kafka_error_new(rd_kafka_resp_err_t code, const char *fmt, ...);\ntypedef struct rd_kafka_topic_partition_s {\n  char *topic;\n  int32_t partition;\n  int64_t offset;\n  void *metadata;\n  size_t metadata_size;\n  void *opaque;\n  rd_kafka_resp_err_t err;\n  void *_private;\n} rd_kafka_topic_partition_t;\nvoid rd_kafka_topic_partition_destroy(rd_kafka_topic_partition_t *rktpar);\ntypedef struct rd_kafka_topic_partition_list_s {\n  int cnt;\n  int size;\n  rd_kafka_topic_partition_t *elems;\n} rd_kafka_topic_partition_list_t;\nrd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_new(int size);\nvoid rd_kafka_topic_partition_list_destroy(rd_kafka_topic_partition_list_t *rkparlist);\nrd_kafka_topic_partition_t *rd_kafka_topic_partition_list_add(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);\nvoid rd_kafka_topic_partition_list_add_range(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t start, int32_t stop);\nint rd_kafka_topic_partition_list_del(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);\nint rd_kafka_topic_partition_list_del_by_idx(rd_kafka_topic_partition_list_t *rktparlist, int idx);\nrd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_copy(const rd_kafka_topic_partition_list_t *src);\nrd_kafka_resp_err_t rd_kafka_topic_partition_list_set_offset(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition, int64_t offset);\nrd_kafka_topic_partition_t *rd_kafka_topic_partition_list_find(const rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);\nvoid rd_kafka_topic_partition_list_sort(rd_kafka_topic_partition_list_t *rktparlist, int (*cmp)(const void *a, const void *b, void *cmp_opaque), void *cmp_opaque);\ntypedef enum rd_kafka_vtype_t {\n  RD_KAFKA_VTYPE_END,\n  RD_KAFKA_VTYPE_TOPIC,\n  RD_KAFKA_VTYPE_RKT,\n  RD_KAFKA_VTYPE_PARTITION,\n  RD_KAFKA_VTYPE_VALUE,\n  RD_KAFKA_VTYPE_KEY,\n  RD_KAFKA_VTYPE_OPAQUE,\n  RD_KAFKA_VTYPE_MSGFLAGS,\n  RD_KAFKA_VTYPE_TIMESTAMP,\n  RD_KAFKA_VTYPE_HEADER,\n  RD_KAFKA_VTYPE_HEADERS,\n} rd_kafka_vtype_t;\ntypedef struct rd_kafka_vu_s {\n  rd_kafka_vtype_t vtype;\n  union {\n    char *cstr;\n    rd_kafka_topic_t *rkt;\n    int i;\n    int32_t i32;\n    int64_t i64;\n    struct {\n      void *ptr;\n      size_t size;\n    } mem;\n    struct {\n      char *name;\n      void *val;\n      ssize_t size;\n    } header;\n    rd_kafka_headers_t *headers;\n    void *ptr;\n    char _pad[64];\n  } u;\n} rd_kafka_vu_t;\nrd_kafka_headers_t *rd_kafka_headers_new(size_t initial_count);\nvoid rd_kafka_headers_destroy(rd_kafka_headers_t *hdrs);\nrd_kafka_headers_t *rd_kafka_headers_copy(const rd_kafka_headers_t *src);\nrd_kafka_resp_err_t rd_kafka_header_add(rd_kafka_headers_t *hdrs, const char *name, ssize_t name_size, const void *value, ssize_t value_size);\nrd_kafka_resp_err_t rd_kafka_header_remove(rd_kafka_headers_t *hdrs, const char *name);\nrd_kafka_resp_err_t rd_kafka_header_get_last(const rd_kafka_headers_t *hdrs, const char *name, const void **valuep, size_t *sizep);\nrd_kafka_resp_err_t rd_kafka_header_get(const rd_kafka_headers_t *hdrs, size_t idx, const char *name, const void **valuep, size_t *sizep);\nrd_kafka_resp_err_t rd_kafka_header_get_all(const rd_kafka_headers_t *hdrs, size_t idx, const char **namep, const void **valuep, size_t *sizep);\ntypedef struct rd_kafka_message_s {\n  rd_kafka_resp_err_t err;\n  rd_kafka_topic_t *rkt;\n  int32_t partition;\n  void *payload;\n  size_t len;\n  void *key;\n  size_t key_len;\n  int64_t offset;\n  void *_private;\n} rd_kafka_message_t;\nvoid rd_kafka_message_destroy(rd_kafka_message_t *rkmessage);\nconst char *rd_kafka_message_errstr(const rd_kafka_message_t *rkmessage);\nint64_t rd_kafka_message_timestamp(const rd_kafka_message_t *rkmessage, rd_kafka_timestamp_type_t *tstype);\nint64_t rd_kafka_message_latency(const rd_kafka_message_t *rkmessage);\nint32_t rd_kafka_message_broker_id(const rd_kafka_message_t *rkmessage);\nrd_kafka_resp_err_t rd_kafka_message_headers(const rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);\nrd_kafka_resp_err_t rd_kafka_message_detach_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);\nvoid rd_kafka_message_set_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t *hdrs);\nsize_t rd_kafka_header_cnt(const rd_kafka_headers_t *hdrs);\ntypedef enum {\n  RD_KAFKA_MSG_STATUS_NOT_PERSISTED = 0,\n  RD_KAFKA_MSG_STATUS_POSSIBLY_PERSISTED = 1,\n  RD_KAFKA_MSG_STATUS_PERSISTED = 2,\n} rd_kafka_msg_status_t;\nrd_kafka_msg_status_t rd_kafka_message_status(const rd_kafka_message_t *rkmessage);\ntypedef enum {\n  RD_KAFKA_CONF_UNKNOWN = (- 2),\n  RD_KAFKA_CONF_INVALID = (- 1),\n  RD_KAFKA_CONF_OK = 0,\n} rd_kafka_conf_res_t;\nrd_kafka_conf_t *rd_kafka_conf_new(void);\nvoid rd_kafka_conf_destroy(rd_kafka_conf_t *conf);\nrd_kafka_conf_t *rd_kafka_conf_dup(const rd_kafka_conf_t *conf);\nrd_kafka_conf_t *rd_kafka_conf_dup_filter(const rd_kafka_conf_t *conf, size_t filter_cnt, const char **filter);\nconst rd_kafka_conf_t *rd_kafka_conf(rd_kafka_t *rk);\nrd_kafka_conf_res_t rd_kafka_conf_set(rd_kafka_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);\nvoid rd_kafka_conf_set_events(rd_kafka_conf_t *conf, int events);\nvoid rd_kafka_conf_set_background_event_cb(rd_kafka_conf_t *conf, void (*event_cb)(rd_kafka_t *rk, rd_kafka_event_t *rkev, void *opaque));\nvoid rd_kafka_conf_set_dr_cb(rd_kafka_conf_t *conf, void (*dr_cb)(rd_kafka_t *rk, void *payload, size_t len, rd_kafka_resp_err_t err, void *opaque, void *msg_opaque));\nvoid rd_kafka_conf_set_dr_msg_cb(rd_kafka_conf_t *conf, void (*dr_msg_cb)(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, void *opaque));\nvoid rd_kafka_conf_set_consume_cb(rd_kafka_conf_t *conf, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *opaque));\nvoid rd_kafka_conf_set_rebalance_cb(rd_kafka_conf_t *conf, void (*rebalance_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *partitions, void *opaque));\nvoid rd_kafka_conf_set_offset_commit_cb(rd_kafka_conf_t *conf, void (*offset_commit_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *opaque));\nvoid rd_kafka_conf_set_error_cb(rd_kafka_conf_t *conf, void (*error_cb)(rd_kafka_t *rk, int err, const char *reason, void *opaque));\nvoid rd_kafka_conf_set_throttle_cb(rd_kafka_conf_t *conf, void (*throttle_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int throttle_time_ms, void *opaque));\nvoid rd_kafka_conf_set_log_cb(rd_kafka_conf_t *conf, void (*log_cb)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));\nvoid rd_kafka_conf_set_stats_cb(rd_kafka_conf_t *conf, int (*stats_cb)(rd_kafka_t *rk, char *json, size_t json_len, void *opaque));\nvoid rd_kafka_conf_set_oauthbearer_token_refresh_cb(rd_kafka_conf_t *conf, void (*oauthbearer_token_refresh_cb)(rd_kafka_t *rk, const char *oauthbearer_config, void *opaque));\nvoid rd_kafka_conf_set_socket_cb(rd_kafka_conf_t *conf, int (*socket_cb)(int domain, int type, int protocol, void *opaque));\nvoid rd_kafka_conf_set_connect_cb(rd_kafka_conf_t *conf, int (*connect_cb)(int sockfd, const struct sockaddr *addr, int addrlen, const char *id, void *opaque));\nvoid rd_kafka_conf_set_closesocket_cb(rd_kafka_conf_t *conf, int (*closesocket_cb)(int sockfd, void *opaque));\nrd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert_verify_cb(rd_kafka_conf_t *conf, int (*ssl_cert_verify_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int *x509_error, int depth, const char *buf, size_t size, char *errstr, size_t errstr_size, void *opaque));\ntypedef enum rd_kafka_cert_type_t {\n  RD_KAFKA_CERT_PUBLIC_KEY,\n  RD_KAFKA_CERT_PRIVATE_KEY,\n  RD_KAFKA_CERT_CA,\n  RD_KAFKA_CERT__CNT,\n} rd_kafka_cert_type_t;\ntypedef enum rd_kafka_cert_enc_t {\n  RD_KAFKA_CERT_ENC_PKCS12,\n  RD_KAFKA_CERT_ENC_DER,\n  RD_KAFKA_CERT_ENC_PEM,\n  RD_KAFKA_CERT_ENC__CNT,\n} rd_kafka_cert_enc_t;\nrd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert(rd_kafka_conf_t *conf, rd_kafka_cert_type_t cert_type, rd_kafka_cert_enc_t cert_enc, const void *buffer, size_t size, char *errstr, size_t errstr_size);\nvoid rd_kafka_conf_set_opaque(rd_kafka_conf_t *conf, void *opaque);\nvoid *rd_kafka_opaque(const rd_kafka_t *rk);\nvoid rd_kafka_conf_set_default_topic_conf(rd_kafka_conf_t *conf, rd_kafka_topic_conf_t *tconf);\nrd_kafka_topic_conf_t *rd_kafka_conf_get_default_topic_conf(rd_kafka_conf_t *conf);\nrd_kafka_conf_res_t rd_kafka_conf_get(const rd_kafka_conf_t *conf, const char *name, char *dest, size_t *dest_size);\nrd_kafka_conf_res_t rd_kafka_topic_conf_get(const rd_kafka_topic_conf_t *conf, const char *name, char *dest, size_t *dest_size);\nconst char **rd_kafka_conf_dump(rd_kafka_conf_t *conf, size_t *cntp);\nconst char **rd_kafka_topic_conf_dump(rd_kafka_topic_conf_t *conf, size_t *cntp);\nvoid rd_kafka_conf_dump_free(const char **arr, size_t cnt);\nvoid rd_kafka_conf_properties_show(FILE *fp);\nrd_kafka_topic_conf_t *rd_kafka_topic_conf_new(void);\nrd_kafka_topic_conf_t *rd_kafka_topic_conf_dup(const rd_kafka_topic_conf_t *conf);\nrd_kafka_topic_conf_t *rd_kafka_default_topic_conf_dup(rd_kafka_t *rk);\nvoid rd_kafka_topic_conf_destroy(rd_kafka_topic_conf_t *topic_conf);\nrd_kafka_conf_res_t rd_kafka_topic_conf_set(rd_kafka_topic_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);\nvoid rd_kafka_topic_conf_set_opaque(rd_kafka_topic_conf_t *conf, void *rkt_opaque);\nvoid rd_kafka_topic_conf_set_partitioner_cb(rd_kafka_topic_conf_t *topic_conf, int32_t (*partitioner)(const rd_kafka_topic_t *rkt, const void *keydata, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque));\nvoid rd_kafka_topic_conf_set_msg_order_cmp(rd_kafka_topic_conf_t *topic_conf, int (*msg_order_cmp)(const rd_kafka_message_t *a, const rd_kafka_message_t *b));\nint rd_kafka_topic_partition_available(const rd_kafka_topic_t *rkt, int32_t partition);\nint32_t rd_kafka_msg_partitioner_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_consistent(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_consistent_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_murmur2(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_murmur2_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_fnv1a(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_fnv1a_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nrd_kafka_t *rd_kafka_new(rd_kafka_type_t type, rd_kafka_conf_t *conf, char *errstr, size_t errstr_size);\nvoid rd_kafka_destroy(rd_kafka_t *rk);\nvoid rd_kafka_destroy_flags(rd_kafka_t *rk, int flags);\nconst char *rd_kafka_name(const rd_kafka_t *rk);\nrd_kafka_type_t rd_kafka_type(const rd_kafka_t *rk);\nchar *rd_kafka_memberid(const rd_kafka_t *rk);\nchar *rd_kafka_clusterid(rd_kafka_t *rk, int timeout_ms);\nint32_t rd_kafka_controllerid(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_topic_t *rd_kafka_topic_new(rd_kafka_t *rk, const char *topic, rd_kafka_topic_conf_t *conf);\nvoid rd_kafka_topic_destroy(rd_kafka_topic_t *rkt);\nconst char *rd_kafka_topic_name(const rd_kafka_topic_t *rkt);\nvoid *rd_kafka_topic_opaque(const rd_kafka_topic_t *rkt);\nint rd_kafka_poll(rd_kafka_t *rk, int timeout_ms);\nvoid rd_kafka_yield(rd_kafka_t *rk);\nrd_kafka_resp_err_t rd_kafka_pause_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_resp_err_t rd_kafka_resume_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_resp_err_t rd_kafka_query_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high, int timeout_ms);\nrd_kafka_resp_err_t rd_kafka_get_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high);\nrd_kafka_resp_err_t rd_kafka_offsets_for_times(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets, int timeout_ms);\nvoid rd_kafka_mem_free(rd_kafka_t *rk, void *ptr);\nrd_kafka_queue_t *rd_kafka_queue_new(rd_kafka_t *rk);\nvoid rd_kafka_queue_destroy(rd_kafka_queue_t *rkqu);\nrd_kafka_queue_t *rd_kafka_queue_get_main(rd_kafka_t *rk);\nrd_kafka_queue_t *rd_kafka_queue_get_consumer(rd_kafka_t *rk);\nrd_kafka_queue_t *rd_kafka_queue_get_partition(rd_kafka_t *rk, const char *topic, int32_t partition);\nrd_kafka_queue_t *rd_kafka_queue_get_background(rd_kafka_t *rk);\nvoid rd_kafka_queue_forward(rd_kafka_queue_t *src, rd_kafka_queue_t *dst);\nrd_kafka_resp_err_t rd_kafka_set_log_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu);\nsize_t rd_kafka_queue_length(rd_kafka_queue_t *rkqu);\nvoid rd_kafka_queue_io_event_enable(rd_kafka_queue_t *rkqu, int fd, const void *payload, size_t size);\nvoid rd_kafka_queue_cb_event_enable(rd_kafka_queue_t *rkqu, void (*event_cb)(rd_kafka_t *rk, void *qev_opaque), void *qev_opaque);\nvoid rd_kafka_queue_yield(rd_kafka_queue_t *rkqu);\nint rd_kafka_consume_start(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);\nint rd_kafka_consume_start_queue(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, rd_kafka_queue_t *rkqu);\nint rd_kafka_consume_stop(rd_kafka_topic_t *rkt, int32_t partition);\nrd_kafka_resp_err_t rd_kafka_seek(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, int timeout_ms);\nrd_kafka_error_t *rd_kafka_seek_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms);\nrd_kafka_message_t *rd_kafka_consume(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms);\nssize_t rd_kafka_consume_batch(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);\nint rd_kafka_consume_callback(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);\nrd_kafka_message_t *rd_kafka_consume_queue(rd_kafka_queue_t *rkqu, int timeout_ms);\nssize_t rd_kafka_consume_batch_queue(rd_kafka_queue_t *rkqu, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);\nint rd_kafka_consume_callback_queue(rd_kafka_queue_t *rkqu, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);\nrd_kafka_resp_err_t rd_kafka_offset_store(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);\nrd_kafka_resp_err_t rd_kafka_offsets_store(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets);\nrd_kafka_resp_err_t rd_kafka_subscribe(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *topics);\nrd_kafka_resp_err_t rd_kafka_unsubscribe(rd_kafka_t *rk);\nrd_kafka_resp_err_t rd_kafka_subscription(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **topics);\nrd_kafka_message_t *rd_kafka_consumer_poll(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_resp_err_t rd_kafka_consumer_close(rd_kafka_t *rk);\nrd_kafka_error_t *rd_kafka_incremental_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_error_t *rd_kafka_incremental_unassign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);\nconst char *rd_kafka_rebalance_protocol(rd_kafka_t *rk);\nrd_kafka_resp_err_t rd_kafka_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_resp_err_t rd_kafka_assignment(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **partitions);\nint rd_kafka_assignment_lost(rd_kafka_t *rk);\nrd_kafka_resp_err_t rd_kafka_commit(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, int async);\nrd_kafka_resp_err_t rd_kafka_commit_message(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, int async);\nrd_kafka_resp_err_t rd_kafka_commit_queue(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_queue_t *rkqu, void (*cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *commit_opaque), void *commit_opaque);\nrd_kafka_resp_err_t rd_kafka_committed(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms);\nrd_kafka_resp_err_t rd_kafka_position(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata(rd_kafka_t *rk);\nrd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata_new(const char *group_id);\nrd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata_new_with_genid(const char *group_id, int32_t generation_id, const char *member_id, const char *group_instance_id);\nvoid rd_kafka_consumer_group_metadata_destroy(rd_kafka_consumer_group_metadata_t *);\nrd_kafka_error_t *rd_kafka_consumer_group_metadata_write(const rd_kafka_consumer_group_metadata_t *cgmd, void **bufferp, size_t *sizep);\nrd_kafka_error_t *rd_kafka_consumer_group_metadata_read(rd_kafka_consumer_group_metadata_t **cgmdp, const void *buffer, size_t size);\nint rd_kafka_produce(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, void *payload, size_t len, const void *key, size_t keylen, void *msg_opaque);\nrd_kafka_resp_err_t rd_kafka_producev(rd_kafka_t *rk, ...);\nrd_kafka_error_t *rd_kafka_produceva(rd_kafka_t *rk, const rd_kafka_vu_t *vus, size_t cnt);\nint rd_kafka_produce_batch(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, rd_kafka_message_t *rkmessages, int message_cnt);\nrd_kafka_resp_err_t rd_kafka_flush(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_resp_err_t rd_kafka_purge(rd_kafka_t *rk, int purge_flags);\ntypedef struct rd_kafka_metadata_broker {\n  int32_t id;\n  char *host;\n  int port;\n} rd_kafka_metadata_broker_t;\ntypedef struct rd_kafka_metadata_partition {\n  int32_t id;\n  rd_kafka_resp_err_t err;\n  int32_t leader;\n  int replica_cnt;\n  int32_t *replicas;\n  int isr_cnt;\n  int32_t *isrs;\n} rd_kafka_metadata_partition_t;\ntypedef struct rd_kafka_metadata_topic {\n  char *topic;\n  int partition_cnt;\n  struct rd_kafka_metadata_partition *partitions;\n  rd_kafka_resp_err_t err;\n} rd_kafka_metadata_topic_t;\ntypedef struct rd_kafka_metadata {\n  int broker_cnt;\n  struct rd_kafka_metadata_broker *brokers;\n  int topic_cnt;\n  struct rd_kafka_metadata_topic *topics;\n  int32_t orig_broker_id;\n  char *orig_broker_name;\n} rd_kafka_metadata_t;\nrd_kafka_resp_err_t rd_kafka_metadata(rd_kafka_t *rk, int all_topics, rd_kafka_topic_t *only_rkt, const struct rd_kafka_metadata **metadatap, int timeout_ms);\nvoid rd_kafka_metadata_destroy(const struct rd_kafka_metadata *metadata);\nstruct rd_kafka_group_member_info {\n  char *member_id;\n  char *client_id;\n  char *client_host;\n  void *member_metadata;\n  int member_metadata_size;\n  void *member_assignment;\n  int member_assignment_size;\n};\nstruct rd_kafka_group_info {\n  struct rd_kafka_metadata_broker broker;\n  char *group;\n  rd_kafka_resp_err_t err;\n  char *state;\n  char *protocol_type;\n  char *protocol;\n  struct rd_kafka_group_member_info *members;\n  int member_cnt;\n};\nstruct rd_kafka_group_list {\n  struct rd_kafka_group_info *groups;\n  int group_cnt;\n};\nrd_kafka_resp_err_t rd_kafka_list_groups(rd_kafka_t *rk, const char *group, const struct rd_kafka_group_list **grplistp, int timeout_ms);\nvoid rd_kafka_group_list_destroy(const struct rd_kafka_group_list *grplist);\nint rd_kafka_brokers_add(rd_kafka_t *rk, const char *brokerlist);\nvoid rd_kafka_set_logger(rd_kafka_t *rk, void (*func)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));\nvoid rd_kafka_set_log_level(rd_kafka_t *rk, int level);\nvoid rd_kafka_log_print(const rd_kafka_t *rk, int level, const char *fac, const char *buf);\nvoid rd_kafka_log_syslog(const rd_kafka_t *rk, int level, const char *fac, const char *buf);\nint rd_kafka_outq_len(rd_kafka_t *rk);\nvoid rd_kafka_dump(FILE *fp, rd_kafka_t *rk);\nint rd_kafka_thread_cnt(void);\ntypedef enum rd_kafka_thread_type_t {\n  RD_KAFKA_THREAD_MAIN,\n  RD_KAFKA_THREAD_BACKGROUND,\n  RD_KAFKA_THREAD_BROKER,\n} rd_kafka_thread_type_t;\nint rd_kafka_wait_destroyed(int timeout_ms);\nint rd_kafka_unittest(void);\nrd_kafka_resp_err_t rd_kafka_poll_set_consumer(rd_kafka_t *rk);\ntypedef int rd_kafka_event_type_t;\nrd_kafka_event_type_t rd_kafka_event_type(const rd_kafka_event_t *rkev);\nconst char *rd_kafka_event_name(const rd_kafka_event_t *rkev);\nvoid rd_kafka_event_destroy(rd_kafka_event_t *rkev);\nconst rd_kafka_message_t *rd_kafka_event_message_next(rd_kafka_event_t *rkev);\nsize_t rd_kafka_event_message_array(rd_kafka_event_t *rkev, const rd_kafka_message_t **rkmessages, size_t size);\nsize_t rd_kafka_event_message_count(rd_kafka_event_t *rkev);\nconst char *rd_kafka_event_config_string(rd_kafka_event_t *rkev);\nrd_kafka_resp_err_t rd_kafka_event_error(rd_kafka_event_t *rkev);\nconst char *rd_kafka_event_error_string(rd_kafka_event_t *rkev);\nint rd_kafka_event_error_is_fatal(rd_kafka_event_t *rkev);\nvoid *rd_kafka_event_opaque(rd_kafka_event_t *rkev);\nint rd_kafka_event_log(rd_kafka_event_t *rkev, const char **fac, const char **str, int *level);\nint rd_kafka_event_debug_contexts(rd_kafka_event_t *rkev, char *dst, size_t dstsize);\nconst char *rd_kafka_event_stats(rd_kafka_event_t *rkev);\nrd_kafka_topic_partition_list_t *rd_kafka_event_topic_partition_list(rd_kafka_event_t *rkev);\nrd_kafka_topic_partition_t *rd_kafka_event_topic_partition(rd_kafka_event_t *rkev);\ntypedef rd_kafka_event_t rd_kafka_CreateTopics_result_t;\ntypedef rd_kafka_event_t rd_kafka_DeleteTopics_result_t;\ntypedef rd_kafka_event_t rd_kafka_CreatePartitions_result_t;\ntypedef rd_kafka_event_t rd_kafka_AlterConfigs_result_t;\ntypedef rd_kafka_event_t rd_kafka_DescribeConfigs_result_t;\ntypedef rd_kafka_event_t rd_kafka_DeleteRecords_result_t;\ntypedef rd_kafka_event_t rd_kafka_DeleteGroups_result_t;\ntypedef rd_kafka_event_t rd_kafka_DeleteConsumerGroupOffsets_result_t;\nconst rd_kafka_CreateTopics_result_t *rd_kafka_event_CreateTopics_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DeleteTopics_result_t *rd_kafka_event_DeleteTopics_result(rd_kafka_event_t *rkev);\nconst rd_kafka_CreatePartitions_result_t *rd_kafka_event_CreatePartitions_result(rd_kafka_event_t *rkev);\nconst rd_kafka_AlterConfigs_result_t *rd_kafka_event_AlterConfigs_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DescribeConfigs_result_t *rd_kafka_event_DescribeConfigs_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DeleteRecords_result_t *rd_kafka_event_DeleteRecords_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DeleteGroups_result_t *rd_kafka_event_DeleteGroups_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DeleteConsumerGroupOffsets_result_t *rd_kafka_event_DeleteConsumerGroupOffsets_result(rd_kafka_event_t *rkev);\nrd_kafka_event_t *rd_kafka_queue_poll(rd_kafka_queue_t *rkqu, int timeout_ms);\nint rd_kafka_queue_poll_callback(rd_kafka_queue_t *rkqu, int timeout_ms);\ntypedef rd_kafka_resp_err_t (rd_kafka_plugin_f_conf_init_t)(rd_kafka_conf_t *conf, void **plug_opaquep, char *errstr, size_t errstr_size);\ntypedef rd_kafka_conf_res_t (rd_kafka_interceptor_f_on_conf_set_t)(rd_kafka_conf_t *conf, const char *name, const char *val, char *errstr, size_t errstr_size, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_dup_t)(rd_kafka_conf_t *new_conf, const rd_kafka_conf_t *old_conf, size_t filter_cnt, const char **filter, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_destroy_t)(void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_new_t)(rd_kafka_t *rk, const rd_kafka_conf_t *conf, void *ic_opaque, char *errstr, size_t errstr_size);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_destroy_t)(rd_kafka_t *rk, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_send_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_acknowledgement_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_consume_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_commit_t)(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_resp_err_t err, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_request_sent_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_response_received_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, int64_t rtt, rd_kafka_resp_err_t err, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_start_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_exit_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_set(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_set_t *on_conf_set, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_dup(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_dup_t *on_conf_dup, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_destroy(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_destroy_t *on_conf_destroy, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_new(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_new_t *on_new, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_destroy(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_destroy_t *on_destroy, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_send(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_send_t *on_send, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_acknowledgement(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_acknowledgement_t *on_acknowledgement, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_consume(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_consume_t *on_consume, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_commit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_commit_t *on_commit, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_request_sent(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_request_sent_t *on_request_sent, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_response_received(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_response_received_t *on_response_received, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_start(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_start_t *on_thread_start, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_exit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_exit_t *on_thread_exit, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_topic_result_error(const rd_kafka_topic_result_t *topicres);\nconst char *rd_kafka_topic_result_error_string(const rd_kafka_topic_result_t *topicres);\nconst char *rd_kafka_topic_result_name(const rd_kafka_topic_result_t *topicres);\nconst rd_kafka_error_t *rd_kafka_group_result_error(const rd_kafka_group_result_t *groupres);\nconst char *rd_kafka_group_result_name(const rd_kafka_group_result_t *groupres);\nconst rd_kafka_topic_partition_list_t *rd_kafka_group_result_partitions(const rd_kafka_group_result_t *groupres);\ntypedef enum rd_kafka_admin_op_t {\n  RD_KAFKA_ADMIN_OP_ANY = 0,\n  RD_KAFKA_ADMIN_OP_CREATETOPICS,\n  RD_KAFKA_ADMIN_OP_DELETETOPICS,\n  RD_KAFKA_ADMIN_OP_CREATEPARTITIONS,\n  RD_KAFKA_ADMIN_OP_ALTERCONFIGS,\n  RD_KAFKA_ADMIN_OP_DESCRIBECONFIGS,\n  RD_KAFKA_ADMIN_OP_DELETERECORDS,\n  RD_KAFKA_ADMIN_OP_DELETEGROUPS,\n  RD_KAFKA_ADMIN_OP_DELETECONSUMERGROUPOFFSETS,\n  RD_KAFKA_ADMIN_OP__CNT,\n} rd_kafka_admin_op_t;\ntypedef struct rd_kafka_AdminOptions_s rd_kafka_AdminOptions_t;\nrd_kafka_AdminOptions_t *rd_kafka_AdminOptions_new(rd_kafka_t *rk, rd_kafka_admin_op_t for_api);\nvoid rd_kafka_AdminOptions_destroy(rd_kafka_AdminOptions_t *options);\nrd_kafka_resp_err_t rd_kafka_AdminOptions_set_request_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_AdminOptions_set_operation_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_AdminOptions_set_validate_only(rd_kafka_AdminOptions_t *options, int true_or_false, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_AdminOptions_set_broker(rd_kafka_AdminOptions_t *options, int32_t broker_id, char *errstr, size_t errstr_size);\nvoid rd_kafka_AdminOptions_set_opaque(rd_kafka_AdminOptions_t *options, void *ev_opaque);\ntypedef struct rd_kafka_NewTopic_s rd_kafka_NewTopic_t;\nrd_kafka_NewTopic_t *rd_kafka_NewTopic_new(const char *topic, int num_partitions, int replication_factor, char *errstr, size_t errstr_size);\nvoid rd_kafka_NewTopic_destroy(rd_kafka_NewTopic_t *new_topic);\nvoid rd_kafka_NewTopic_destroy_array(rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt);\nrd_kafka_resp_err_t rd_kafka_NewTopic_set_replica_assignment(rd_kafka_NewTopic_t *new_topic, int32_t partition, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_NewTopic_set_config(rd_kafka_NewTopic_t *new_topic, const char *name, const char *value);\nvoid rd_kafka_CreateTopics(rd_kafka_t *rk, rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_topic_result_t **rd_kafka_CreateTopics_result_topics(const rd_kafka_CreateTopics_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_DeleteTopic_s rd_kafka_DeleteTopic_t;\nrd_kafka_DeleteTopic_t *rd_kafka_DeleteTopic_new(const char *topic);\nvoid rd_kafka_DeleteTopic_destroy(rd_kafka_DeleteTopic_t *del_topic);\nvoid rd_kafka_DeleteTopic_destroy_array(rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt);\nvoid rd_kafka_DeleteTopics(rd_kafka_t *rk, rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_topic_result_t **rd_kafka_DeleteTopics_result_topics(const rd_kafka_DeleteTopics_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_NewPartitions_s rd_kafka_NewPartitions_t;\nrd_kafka_NewPartitions_t *rd_kafka_NewPartitions_new(const char *topic, size_t new_total_cnt, char *errstr, size_t errstr_size);\nvoid rd_kafka_NewPartitions_destroy(rd_kafka_NewPartitions_t *new_parts);\nvoid rd_kafka_NewPartitions_destroy_array(rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt);\nrd_kafka_resp_err_t rd_kafka_NewPartitions_set_replica_assignment(rd_kafka_NewPartitions_t *new_parts, int32_t new_partition_idx, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);\nvoid rd_kafka_CreatePartitions(rd_kafka_t *rk, rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_topic_result_t **rd_kafka_CreatePartitions_result_topics(const rd_kafka_CreatePartitions_result_t *result, size_t *cntp);\ntypedef enum rd_kafka_ConfigSource_t {\n  RD_KAFKA_CONFIG_SOURCE_UNKNOWN_CONFIG = 0,\n  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_TOPIC_CONFIG = 1,\n  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_BROKER_CONFIG = 2,\n  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_DEFAULT_BROKER_CONFIG = 3,\n  RD_KAFKA_CONFIG_SOURCE_STATIC_BROKER_CONFIG = 4,\n  RD_KAFKA_CONFIG_SOURCE_DEFAULT_CONFIG = 5,\n  RD_KAFKA_CONFIG_SOURCE__CNT,\n} rd_kafka_ConfigSource_t;\nconst char *rd_kafka_ConfigSource_name(rd_kafka_ConfigSource_t confsource);\ntypedef struct rd_kafka_ConfigEntry_s rd_kafka_ConfigEntry_t;\nconst char *rd_kafka_ConfigEntry_name(const rd_kafka_ConfigEntry_t *entry);\nconst char *rd_kafka_ConfigEntry_value(const rd_kafka_ConfigEntry_t *entry);\nrd_kafka_ConfigSource_t rd_kafka_ConfigEntry_source(const rd_kafka_ConfigEntry_t *entry);\nint rd_kafka_ConfigEntry_is_read_only(const rd_kafka_ConfigEntry_t *entry);\nint rd_kafka_ConfigEntry_is_default(const rd_kafka_ConfigEntry_t *entry);\nint rd_kafka_ConfigEntry_is_sensitive(const rd_kafka_ConfigEntry_t *entry);\nint rd_kafka_ConfigEntry_is_synonym(const rd_kafka_ConfigEntry_t *entry);\nconst rd_kafka_ConfigEntry_t **rd_kafka_ConfigEntry_synonyms(const rd_kafka_ConfigEntry_t *entry, size_t *cntp);\ntypedef enum rd_kafka_ResourceType_t {\n  RD_KAFKA_RESOURCE_UNKNOWN = 0,\n  RD_KAFKA_RESOURCE_ANY = 1,\n  RD_KAFKA_RESOURCE_TOPIC = 2,\n  RD_KAFKA_RESOURCE_GROUP = 3,\n  RD_KAFKA_RESOURCE_BROKER = 4,\n  RD_KAFKA_RESOURCE__CNT,\n} rd_kafka_ResourceType_t;\nconst char *rd_kafka_ResourceType_name(rd_kafka_ResourceType_t restype);\ntypedef struct rd_kafka_ConfigResource_s rd_kafka_ConfigResource_t;\nrd_kafka_ConfigResource_t *rd_kafka_ConfigResource_new(rd_kafka_ResourceType_t restype, const char *resname);\nvoid rd_kafka_ConfigResource_destroy(rd_kafka_ConfigResource_t *config);\nvoid rd_kafka_ConfigResource_destroy_array(rd_kafka_ConfigResource_t **config, size_t config_cnt);\nrd_kafka_resp_err_t rd_kafka_ConfigResource_set_config(rd_kafka_ConfigResource_t *config, const char *name, const char *value);\nconst rd_kafka_ConfigEntry_t **rd_kafka_ConfigResource_configs(const rd_kafka_ConfigResource_t *config, size_t *cntp);\nrd_kafka_ResourceType_t rd_kafka_ConfigResource_type(const rd_kafka_ConfigResource_t *config);\nconst char *rd_kafka_ConfigResource_name(const rd_kafka_ConfigResource_t *config);\nrd_kafka_resp_err_t rd_kafka_ConfigResource_error(const rd_kafka_ConfigResource_t *config);\nconst char *rd_kafka_ConfigResource_error_string(const rd_kafka_ConfigResource_t *config);\nvoid rd_kafka_AlterConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_ConfigResource_t **rd_kafka_AlterConfigs_result_resources(const rd_kafka_AlterConfigs_result_t *result, size_t *cntp);\nvoid rd_kafka_DescribeConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_ConfigResource_t **rd_kafka_DescribeConfigs_result_resources(const rd_kafka_DescribeConfigs_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_DeleteRecords_s rd_kafka_DeleteRecords_t;\nrd_kafka_DeleteRecords_t *rd_kafka_DeleteRecords_new(const rd_kafka_topic_partition_list_t *before_offsets);\nvoid rd_kafka_DeleteRecords_destroy(rd_kafka_DeleteRecords_t *del_records);\nvoid rd_kafka_DeleteRecords_destroy_array(rd_kafka_DeleteRecords_t **del_records, size_t del_record_cnt);\nvoid rd_kafka_DeleteRecords(rd_kafka_t *rk, rd_kafka_DeleteRecords_t **del_records, size_t del_record_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_topic_partition_list_t *rd_kafka_DeleteRecords_result_offsets(const rd_kafka_DeleteRecords_result_t *result);\ntypedef struct rd_kafka_DeleteGroup_s rd_kafka_DeleteGroup_t;\nrd_kafka_DeleteGroup_t *rd_kafka_DeleteGroup_new(const char *group);\nvoid rd_kafka_DeleteGroup_destroy(rd_kafka_DeleteGroup_t *del_group);\nvoid rd_kafka_DeleteGroup_destroy_array(rd_kafka_DeleteGroup_t **del_groups, size_t del_group_cnt);\nvoid rd_kafka_DeleteGroups(rd_kafka_t *rk, rd_kafka_DeleteGroup_t **del_groups, size_t del_group_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_group_result_t **rd_kafka_DeleteGroups_result_groups(const rd_kafka_DeleteGroups_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_DeleteConsumerGroupOffsets_s rd_kafka_DeleteConsumerGroupOffsets_t;\nrd_kafka_DeleteConsumerGroupOffsets_t *rd_kafka_DeleteConsumerGroupOffsets_new(const char *group, const rd_kafka_topic_partition_list_t *partitions);\nvoid rd_kafka_DeleteConsumerGroupOffsets_destroy(rd_kafka_DeleteConsumerGroupOffsets_t *del_grpoffsets);\nvoid rd_kafka_DeleteConsumerGroupOffsets_destroy_array(rd_kafka_DeleteConsumerGroupOffsets_t **del_grpoffsets, size_t del_grpoffset_cnt);\nvoid rd_kafka_DeleteConsumerGroupOffsets(rd_kafka_t *rk, rd_kafka_DeleteConsumerGroupOffsets_t **del_grpoffsets, size_t del_grpoffsets_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_group_result_t **rd_kafka_DeleteConsumerGroupOffsets_result_groups(const rd_kafka_DeleteConsumerGroupOffsets_result_t *result, size_t *cntp);\nrd_kafka_resp_err_t rd_kafka_oauthbearer_set_token(rd_kafka_t *rk, const char *token_value, int64_t md_lifetime_ms, const char *md_principal_name, const char **extensions, size_t extension_size, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_oauthbearer_set_token_failure(rd_kafka_t *rk, const char *errstr);\nrd_kafka_error_t *rd_kafka_init_transactions(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_error_t *rd_kafka_begin_transaction(rd_kafka_t *rk);\nrd_kafka_error_t *rd_kafka_send_offsets_to_transaction(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, const rd_kafka_consumer_group_metadata_t *cgmetadata, int timeout_ms);\nrd_kafka_error_t *rd_kafka_commit_transaction(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_error_t *rd_kafka_abort_transaction(rd_kafka_t *rk, int timeout_ms);\ntypedef struct rd_kafka_mock_cluster_s rd_kafka_mock_cluster_t;\nrd_kafka_mock_cluster_t *rd_kafka_mock_cluster_new(rd_kafka_t *rk, int broker_cnt);\nvoid rd_kafka_mock_cluster_destroy(rd_kafka_mock_cluster_t *mcluster);\nrd_kafka_t *rd_kafka_mock_cluster_handle(const rd_kafka_mock_cluster_t *mcluster);\nrd_kafka_mock_cluster_t *rd_kafka_handle_mock_cluster(const rd_kafka_t *rk);\nconst char *rd_kafka_mock_cluster_bootstraps(const rd_kafka_mock_cluster_t *mcluster);\nvoid rd_kafka_mock_clear_request_errors(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey);\nvoid rd_kafka_mock_push_request_errors(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, size_t cnt, ...);\nvoid rd_kafka_mock_push_request_errors_array(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, size_t cnt, const rd_kafka_resp_err_t *errors);\nrd_kafka_resp_err_t rd_kafka_mock_broker_push_request_errors(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int16_t ApiKey, size_t cnt, ...);\nvoid rd_kafka_mock_topic_set_error(rd_kafka_mock_cluster_t *mcluster, const char *topic, rd_kafka_resp_err_t err);\nrd_kafka_resp_err_t rd_kafka_mock_topic_create(rd_kafka_mock_cluster_t *mcluster, const char *topic, int partition_cnt, int replication_factor);\nrd_kafka_resp_err_t rd_kafka_mock_partition_set_leader(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id);\nrd_kafka_resp_err_t rd_kafka_mock_partition_set_follower(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id);\nrd_kafka_resp_err_t rd_kafka_mock_partition_set_follower_wmarks(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int64_t lo, int64_t hi);\nrd_kafka_resp_err_t rd_kafka_mock_broker_set_down(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id);\nrd_kafka_resp_err_t rd_kafka_mock_broker_set_up(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id);\nrd_kafka_resp_err_t rd_kafka_mock_broker_set_rtt(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int rtt_ms);\nrd_kafka_resp_err_t rd_kafka_mock_broker_set_rack(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, const char *rack);\nrd_kafka_resp_err_t rd_kafka_mock_coordinator_set(rd_kafka_mock_cluster_t *mcluster, const char *key_type, const char *key, int32_t broker_id);\nrd_kafka_resp_err_t rd_kafka_mock_set_apiversion(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, int16_t MinVersion, int16_t MaxVersion);\n'\n</code></pre> rdkafka.h, rdkafka_mock.h</p>"},{"location":"api/constants/#rd_kafka_version_16","title":"RD_KAFKA_VERSION","text":"<pre><code>public RD_KAFKA_VERSION = 17236223\n</code></pre> <p>librdkafka version </p> <p>Interpreted as hex <code>MM.mm.rr.xx</code>:</p> <ul> <li>MM = Major</li> <li>mm = minor</li> <li>rr = revision</li> <li>xx = pre-release id (0xff is the final release)</li> </ul> <p>E.g.: <code>0x000801ff</code> = 0.8.1</p> RemarksThis value should only be used during compile time, for runtime checks of version use rd_kafka_version()  <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_unsupported_compression_type_16","title":"RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE","text":"<pre><code>public RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76\n</code></pre> <p>Unsupported compression type </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_end_all_16","title":"RD_KAFKA_RESP_ERR_END_ALL","text":"<p><pre><code>public RD_KAFKA_RESP_ERR_END_ALL = 98\n</code></pre> enum rd_kafka_resp_err_t</p>"},{"location":"api/constants/#rd_kafka_admin_op__cnt_16","title":"RD_KAFKA_ADMIN_OP__CNT","text":"<pre><code>public RD_KAFKA_ADMIN_OP__CNT = 9\n</code></pre> <p>Number of ops defined </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe </li> </ul>"},{"location":"api/constants/#rd_kafka_resource__cnt_16","title":"RD_KAFKA_RESOURCE__CNT","text":"<pre><code>public RD_KAFKA_RESOURCE__CNT = 5\n</code></pre> <p>Number of resource types defined </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#acca83a66d7783ff7683ed2691cc907c9 </li> </ul>"},{"location":"api/constants/#rd_kafka_cdef_16","title":"RD_KAFKA_CDEF","text":"<p><pre><code>public RD_KAFKA_CDEF = 'typedef long int ssize_t;\ntypedef struct _IO_FILE FILE;\ntypedef long int mode_t;\ntypedef signed int int16_t;\ntypedef unsigned int uint16_t;\ntypedef signed int int32_t;\ntypedef signed long int int64_t;\nint rd_kafka_version(void);\nconst char *rd_kafka_version_str(void);\ntypedef enum rd_kafka_type_t {\n  RD_KAFKA_PRODUCER,\n  RD_KAFKA_CONSUMER,\n} rd_kafka_type_t;\ntypedef enum rd_kafka_timestamp_type_t {\n  RD_KAFKA_TIMESTAMP_NOT_AVAILABLE,\n  RD_KAFKA_TIMESTAMP_CREATE_TIME,\n  RD_KAFKA_TIMESTAMP_LOG_APPEND_TIME,\n} rd_kafka_timestamp_type_t;\nconst char *rd_kafka_get_debug_contexts(void);\ntypedef struct rd_kafka_s rd_kafka_t;\ntypedef struct rd_kafka_topic_s rd_kafka_topic_t;\ntypedef struct rd_kafka_conf_s rd_kafka_conf_t;\ntypedef struct rd_kafka_topic_conf_s rd_kafka_topic_conf_t;\ntypedef struct rd_kafka_queue_s rd_kafka_queue_t;\ntypedef struct rd_kafka_op_s rd_kafka_event_t;\ntypedef struct rd_kafka_topic_result_s rd_kafka_topic_result_t;\ntypedef struct rd_kafka_consumer_group_metadata_s rd_kafka_consumer_group_metadata_t;\ntypedef struct rd_kafka_error_s {\n  unsigned int code;\n  char *errstr;\n  unsigned char fatal;\n  unsigned char retriable;\n  unsigned char txn_requires_abort;\n} rd_kafka_error_t;\ntypedef struct rd_kafka_headers_s rd_kafka_headers_t;\ntypedef struct rd_kafka_group_result_s rd_kafka_group_result_t;\ntypedef enum {\n  RD_KAFKA_RESP_ERR__BEGIN = (- 200),\n  RD_KAFKA_RESP_ERR__BAD_MSG = (- 199),\n  RD_KAFKA_RESP_ERR__BAD_COMPRESSION = (- 198),\n  RD_KAFKA_RESP_ERR__DESTROY = (- 197),\n  RD_KAFKA_RESP_ERR__FAIL = (- 196),\n  RD_KAFKA_RESP_ERR__TRANSPORT = (- 195),\n  RD_KAFKA_RESP_ERR__CRIT_SYS_RESOURCE = (- 194),\n  RD_KAFKA_RESP_ERR__RESOLVE = (- 193),\n  RD_KAFKA_RESP_ERR__MSG_TIMED_OUT = (- 192),\n  RD_KAFKA_RESP_ERR__PARTITION_EOF = (- 191),\n  RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION = (- 190),\n  RD_KAFKA_RESP_ERR__FS = (- 189),\n  RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC = (- 188),\n  RD_KAFKA_RESP_ERR__ALL_BROKERS_DOWN = (- 187),\n  RD_KAFKA_RESP_ERR__INVALID_ARG = (- 186),\n  RD_KAFKA_RESP_ERR__TIMED_OUT = (- 185),\n  RD_KAFKA_RESP_ERR__QUEUE_FULL = (- 184),\n  RD_KAFKA_RESP_ERR__ISR_INSUFF = (- 183),\n  RD_KAFKA_RESP_ERR__NODE_UPDATE = (- 182),\n  RD_KAFKA_RESP_ERR__SSL = (- 181),\n  RD_KAFKA_RESP_ERR__WAIT_COORD = (- 180),\n  RD_KAFKA_RESP_ERR__UNKNOWN_GROUP = (- 179),\n  RD_KAFKA_RESP_ERR__IN_PROGRESS = (- 178),\n  RD_KAFKA_RESP_ERR__PREV_IN_PROGRESS = (- 177),\n  RD_KAFKA_RESP_ERR__EXISTING_SUBSCRIPTION = (- 176),\n  RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS = (- 175),\n  RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS = (- 174),\n  RD_KAFKA_RESP_ERR__CONFLICT = (- 173),\n  RD_KAFKA_RESP_ERR__STATE = (- 172),\n  RD_KAFKA_RESP_ERR__UNKNOWN_PROTOCOL = (- 171),\n  RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED = (- 170),\n  RD_KAFKA_RESP_ERR__AUTHENTICATION = (- 169),\n  RD_KAFKA_RESP_ERR__NO_OFFSET = (- 168),\n  RD_KAFKA_RESP_ERR__OUTDATED = (- 167),\n  RD_KAFKA_RESP_ERR__TIMED_OUT_QUEUE = (- 166),\n  RD_KAFKA_RESP_ERR__UNSUPPORTED_FEATURE = (- 165),\n  RD_KAFKA_RESP_ERR__WAIT_CACHE = (- 164),\n  RD_KAFKA_RESP_ERR__INTR = (- 163),\n  RD_KAFKA_RESP_ERR__KEY_SERIALIZATION = (- 162),\n  RD_KAFKA_RESP_ERR__VALUE_SERIALIZATION = (- 161),\n  RD_KAFKA_RESP_ERR__KEY_DESERIALIZATION = (- 160),\n  RD_KAFKA_RESP_ERR__VALUE_DESERIALIZATION = (- 159),\n  RD_KAFKA_RESP_ERR__PARTIAL = (- 158),\n  RD_KAFKA_RESP_ERR__READ_ONLY = (- 157),\n  RD_KAFKA_RESP_ERR__NOENT = (- 156),\n  RD_KAFKA_RESP_ERR__UNDERFLOW = (- 155),\n  RD_KAFKA_RESP_ERR__INVALID_TYPE = (- 154),\n  RD_KAFKA_RESP_ERR__RETRY = (- 153),\n  RD_KAFKA_RESP_ERR__PURGE_QUEUE = (- 152),\n  RD_KAFKA_RESP_ERR__PURGE_INFLIGHT = (- 151),\n  RD_KAFKA_RESP_ERR__FATAL = (- 150),\n  RD_KAFKA_RESP_ERR__INCONSISTENT = (- 149),\n  RD_KAFKA_RESP_ERR__GAPLESS_GUARANTEE = (- 148),\n  RD_KAFKA_RESP_ERR__MAX_POLL_EXCEEDED = (- 147),\n  RD_KAFKA_RESP_ERR__UNKNOWN_BROKER = (- 146),\n  RD_KAFKA_RESP_ERR__NOT_CONFIGURED = (- 145),\n  RD_KAFKA_RESP_ERR__FENCED = (- 144),\n  RD_KAFKA_RESP_ERR__APPLICATION = (- 143),\n  RD_KAFKA_RESP_ERR__ASSIGNMENT_LOST = (- 142),\n  RD_KAFKA_RESP_ERR__NOOP = (- 141),\n  RD_KAFKA_RESP_ERR__AUTO_OFFSET_RESET = (- 140),\n  RD_KAFKA_RESP_ERR__END = (- 100),\n  RD_KAFKA_RESP_ERR_UNKNOWN = (- 1),\n  RD_KAFKA_RESP_ERR_NO_ERROR = 0,\n  RD_KAFKA_RESP_ERR_OFFSET_OUT_OF_RANGE = 1,\n  RD_KAFKA_RESP_ERR_INVALID_MSG = 2,\n  RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART = 3,\n  RD_KAFKA_RESP_ERR_INVALID_MSG_SIZE = 4,\n  RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE = 5,\n  RD_KAFKA_RESP_ERR_NOT_LEADER_FOR_PARTITION = 6,\n  RD_KAFKA_RESP_ERR_REQUEST_TIMED_OUT = 7,\n  RD_KAFKA_RESP_ERR_BROKER_NOT_AVAILABLE = 8,\n  RD_KAFKA_RESP_ERR_REPLICA_NOT_AVAILABLE = 9,\n  RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE = 10,\n  RD_KAFKA_RESP_ERR_STALE_CTRL_EPOCH = 11,\n  RD_KAFKA_RESP_ERR_OFFSET_METADATA_TOO_LARGE = 12,\n  RD_KAFKA_RESP_ERR_NETWORK_EXCEPTION = 13,\n  RD_KAFKA_RESP_ERR_COORDINATOR_LOAD_IN_PROGRESS = 14,\n  RD_KAFKA_RESP_ERR_COORDINATOR_NOT_AVAILABLE = 15,\n  RD_KAFKA_RESP_ERR_NOT_COORDINATOR = 16,\n  RD_KAFKA_RESP_ERR_TOPIC_EXCEPTION = 17,\n  RD_KAFKA_RESP_ERR_RECORD_LIST_TOO_LARGE = 18,\n  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS = 19,\n  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS_AFTER_APPEND = 20,\n  RD_KAFKA_RESP_ERR_INVALID_REQUIRED_ACKS = 21,\n  RD_KAFKA_RESP_ERR_ILLEGAL_GENERATION = 22,\n  RD_KAFKA_RESP_ERR_INCONSISTENT_GROUP_PROTOCOL = 23,\n  RD_KAFKA_RESP_ERR_INVALID_GROUP_ID = 24,\n  RD_KAFKA_RESP_ERR_UNKNOWN_MEMBER_ID = 25,\n  RD_KAFKA_RESP_ERR_INVALID_SESSION_TIMEOUT = 26,\n  RD_KAFKA_RESP_ERR_REBALANCE_IN_PROGRESS = 27,\n  RD_KAFKA_RESP_ERR_INVALID_COMMIT_OFFSET_SIZE = 28,\n  RD_KAFKA_RESP_ERR_TOPIC_AUTHORIZATION_FAILED = 29,\n  RD_KAFKA_RESP_ERR_GROUP_AUTHORIZATION_FAILED = 30,\n  RD_KAFKA_RESP_ERR_CLUSTER_AUTHORIZATION_FAILED = 31,\n  RD_KAFKA_RESP_ERR_INVALID_TIMESTAMP = 32,\n  RD_KAFKA_RESP_ERR_UNSUPPORTED_SASL_MECHANISM = 33,\n  RD_KAFKA_RESP_ERR_ILLEGAL_SASL_STATE = 34,\n  RD_KAFKA_RESP_ERR_UNSUPPORTED_VERSION = 35,\n  RD_KAFKA_RESP_ERR_TOPIC_ALREADY_EXISTS = 36,\n  RD_KAFKA_RESP_ERR_INVALID_PARTITIONS = 37,\n  RD_KAFKA_RESP_ERR_INVALID_REPLICATION_FACTOR = 38,\n  RD_KAFKA_RESP_ERR_INVALID_REPLICA_ASSIGNMENT = 39,\n  RD_KAFKA_RESP_ERR_INVALID_CONFIG = 40,\n  RD_KAFKA_RESP_ERR_NOT_CONTROLLER = 41,\n  RD_KAFKA_RESP_ERR_INVALID_REQUEST = 42,\n  RD_KAFKA_RESP_ERR_UNSUPPORTED_FOR_MESSAGE_FORMAT = 43,\n  RD_KAFKA_RESP_ERR_POLICY_VIOLATION = 44,\n  RD_KAFKA_RESP_ERR_OUT_OF_ORDER_SEQUENCE_NUMBER = 45,\n  RD_KAFKA_RESP_ERR_DUPLICATE_SEQUENCE_NUMBER = 46,\n  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_EPOCH = 47,\n  RD_KAFKA_RESP_ERR_INVALID_TXN_STATE = 48,\n  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_ID_MAPPING = 49,\n  RD_KAFKA_RESP_ERR_INVALID_TRANSACTION_TIMEOUT = 50,\n  RD_KAFKA_RESP_ERR_CONCURRENT_TRANSACTIONS = 51,\n  RD_KAFKA_RESP_ERR_TRANSACTION_COORDINATOR_FENCED = 52,\n  RD_KAFKA_RESP_ERR_TRANSACTIONAL_ID_AUTHORIZATION_FAILED = 53,\n  RD_KAFKA_RESP_ERR_SECURITY_DISABLED = 54,\n  RD_KAFKA_RESP_ERR_OPERATION_NOT_ATTEMPTED = 55,\n  RD_KAFKA_RESP_ERR_KAFKA_STORAGE_ERROR = 56,\n  RD_KAFKA_RESP_ERR_LOG_DIR_NOT_FOUND = 57,\n  RD_KAFKA_RESP_ERR_SASL_AUTHENTICATION_FAILED = 58,\n  RD_KAFKA_RESP_ERR_UNKNOWN_PRODUCER_ID = 59,\n  RD_KAFKA_RESP_ERR_REASSIGNMENT_IN_PROGRESS = 60,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTH_DISABLED = 61,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_NOT_FOUND = 62,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_OWNER_MISMATCH = 63,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_REQUEST_NOT_ALLOWED = 64,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTHORIZATION_FAILED = 65,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_EXPIRED = 66,\n  RD_KAFKA_RESP_ERR_INVALID_PRINCIPAL_TYPE = 67,\n  RD_KAFKA_RESP_ERR_NON_EMPTY_GROUP = 68,\n  RD_KAFKA_RESP_ERR_GROUP_ID_NOT_FOUND = 69,\n  RD_KAFKA_RESP_ERR_FETCH_SESSION_ID_NOT_FOUND = 70,\n  RD_KAFKA_RESP_ERR_INVALID_FETCH_SESSION_EPOCH = 71,\n  RD_KAFKA_RESP_ERR_LISTENER_NOT_FOUND = 72,\n  RD_KAFKA_RESP_ERR_TOPIC_DELETION_DISABLED = 73,\n  RD_KAFKA_RESP_ERR_FENCED_LEADER_EPOCH = 74,\n  RD_KAFKA_RESP_ERR_UNKNOWN_LEADER_EPOCH = 75,\n  RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76,\n  RD_KAFKA_RESP_ERR_STALE_BROKER_EPOCH = 77,\n  RD_KAFKA_RESP_ERR_OFFSET_NOT_AVAILABLE = 78,\n  RD_KAFKA_RESP_ERR_MEMBER_ID_REQUIRED = 79,\n  RD_KAFKA_RESP_ERR_PREFERRED_LEADER_NOT_AVAILABLE = 80,\n  RD_KAFKA_RESP_ERR_GROUP_MAX_SIZE_REACHED = 81,\n  RD_KAFKA_RESP_ERR_FENCED_INSTANCE_ID = 82,\n  RD_KAFKA_RESP_ERR_ELIGIBLE_LEADERS_NOT_AVAILABLE = 83,\n  RD_KAFKA_RESP_ERR_ELECTION_NOT_NEEDED = 84,\n  RD_KAFKA_RESP_ERR_NO_REASSIGNMENT_IN_PROGRESS = 85,\n  RD_KAFKA_RESP_ERR_GROUP_SUBSCRIBED_TO_TOPIC = 86,\n  RD_KAFKA_RESP_ERR_INVALID_RECORD = 87,\n  RD_KAFKA_RESP_ERR_UNSTABLE_OFFSET_COMMIT = 88,\n  RD_KAFKA_RESP_ERR_THROTTLING_QUOTA_EXCEEDED = 89,\n  RD_KAFKA_RESP_ERR_PRODUCER_FENCED = 90,\n  RD_KAFKA_RESP_ERR_RESOURCE_NOT_FOUND = 91,\n  RD_KAFKA_RESP_ERR_DUPLICATE_RESOURCE = 92,\n  RD_KAFKA_RESP_ERR_UNACCEPTABLE_CREDENTIAL = 93,\n  RD_KAFKA_RESP_ERR_INCONSISTENT_VOTER_SET = 94,\n  RD_KAFKA_RESP_ERR_INVALID_UPDATE_VERSION = 95,\n  RD_KAFKA_RESP_ERR_FEATURE_UPDATE_FAILED = 96,\n  RD_KAFKA_RESP_ERR_PRINCIPAL_DESERIALIZATION_FAILURE = 97,\n  RD_KAFKA_RESP_ERR_END_ALL,\n} rd_kafka_resp_err_t;\nstruct rd_kafka_err_desc {\n  rd_kafka_resp_err_t code;\n  char *name;\n  char *desc;\n};\nvoid rd_kafka_get_err_descs(const struct rd_kafka_err_desc **errdescs, size_t *cntp);\nconst char *rd_kafka_err2str(rd_kafka_resp_err_t err);\nconst char *rd_kafka_err2name(rd_kafka_resp_err_t err);\nrd_kafka_resp_err_t rd_kafka_last_error(void);\nrd_kafka_resp_err_t rd_kafka_errno2err(int errnox);\nint rd_kafka_errno(void);\nrd_kafka_resp_err_t rd_kafka_fatal_error(rd_kafka_t *rk, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_test_fatal_error(rd_kafka_t *rk, rd_kafka_resp_err_t err, const char *reason);\nrd_kafka_resp_err_t rd_kafka_error_code(const rd_kafka_error_t *error);\nconst char *rd_kafka_error_name(const rd_kafka_error_t *error);\nconst char *rd_kafka_error_string(const rd_kafka_error_t *error);\nint rd_kafka_error_is_fatal(const rd_kafka_error_t *error);\nint rd_kafka_error_is_retriable(const rd_kafka_error_t *error);\nint rd_kafka_error_txn_requires_abort(const rd_kafka_error_t *error);\nvoid rd_kafka_error_destroy(rd_kafka_error_t *error);\nrd_kafka_error_t *rd_kafka_error_new(rd_kafka_resp_err_t code, const char *fmt, ...);\ntypedef struct rd_kafka_topic_partition_s {\n  char *topic;\n  int32_t partition;\n  int64_t offset;\n  void *metadata;\n  size_t metadata_size;\n  void *opaque;\n  rd_kafka_resp_err_t err;\n  void *_private;\n} rd_kafka_topic_partition_t;\nvoid rd_kafka_topic_partition_destroy(rd_kafka_topic_partition_t *rktpar);\ntypedef struct rd_kafka_topic_partition_list_s {\n  int cnt;\n  int size;\n  rd_kafka_topic_partition_t *elems;\n} rd_kafka_topic_partition_list_t;\nrd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_new(int size);\nvoid rd_kafka_topic_partition_list_destroy(rd_kafka_topic_partition_list_t *rkparlist);\nrd_kafka_topic_partition_t *rd_kafka_topic_partition_list_add(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);\nvoid rd_kafka_topic_partition_list_add_range(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t start, int32_t stop);\nint rd_kafka_topic_partition_list_del(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);\nint rd_kafka_topic_partition_list_del_by_idx(rd_kafka_topic_partition_list_t *rktparlist, int idx);\nrd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_copy(const rd_kafka_topic_partition_list_t *src);\nrd_kafka_resp_err_t rd_kafka_topic_partition_list_set_offset(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition, int64_t offset);\nrd_kafka_topic_partition_t *rd_kafka_topic_partition_list_find(const rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);\nvoid rd_kafka_topic_partition_list_sort(rd_kafka_topic_partition_list_t *rktparlist, int (*cmp)(const void *a, const void *b, void *cmp_opaque), void *cmp_opaque);\ntypedef enum rd_kafka_vtype_t {\n  RD_KAFKA_VTYPE_END,\n  RD_KAFKA_VTYPE_TOPIC,\n  RD_KAFKA_VTYPE_RKT,\n  RD_KAFKA_VTYPE_PARTITION,\n  RD_KAFKA_VTYPE_VALUE,\n  RD_KAFKA_VTYPE_KEY,\n  RD_KAFKA_VTYPE_OPAQUE,\n  RD_KAFKA_VTYPE_MSGFLAGS,\n  RD_KAFKA_VTYPE_TIMESTAMP,\n  RD_KAFKA_VTYPE_HEADER,\n  RD_KAFKA_VTYPE_HEADERS,\n} rd_kafka_vtype_t;\ntypedef struct rd_kafka_vu_s {\n  rd_kafka_vtype_t vtype;\n  union {\n    char *cstr;\n    rd_kafka_topic_t *rkt;\n    int i;\n    int32_t i32;\n    int64_t i64;\n    struct {\n      void *ptr;\n      size_t size;\n    } mem;\n    struct {\n      char *name;\n      void *val;\n      ssize_t size;\n    } header;\n    rd_kafka_headers_t *headers;\n    void *ptr;\n    char _pad[64];\n  } u;\n} rd_kafka_vu_t;\nrd_kafka_headers_t *rd_kafka_headers_new(size_t initial_count);\nvoid rd_kafka_headers_destroy(rd_kafka_headers_t *hdrs);\nrd_kafka_headers_t *rd_kafka_headers_copy(const rd_kafka_headers_t *src);\nrd_kafka_resp_err_t rd_kafka_header_add(rd_kafka_headers_t *hdrs, const char *name, ssize_t name_size, const void *value, ssize_t value_size);\nrd_kafka_resp_err_t rd_kafka_header_remove(rd_kafka_headers_t *hdrs, const char *name);\nrd_kafka_resp_err_t rd_kafka_header_get_last(const rd_kafka_headers_t *hdrs, const char *name, const void **valuep, size_t *sizep);\nrd_kafka_resp_err_t rd_kafka_header_get(const rd_kafka_headers_t *hdrs, size_t idx, const char *name, const void **valuep, size_t *sizep);\nrd_kafka_resp_err_t rd_kafka_header_get_all(const rd_kafka_headers_t *hdrs, size_t idx, const char **namep, const void **valuep, size_t *sizep);\ntypedef struct rd_kafka_message_s {\n  rd_kafka_resp_err_t err;\n  rd_kafka_topic_t *rkt;\n  int32_t partition;\n  void *payload;\n  size_t len;\n  void *key;\n  size_t key_len;\n  int64_t offset;\n  void *_private;\n} rd_kafka_message_t;\nvoid rd_kafka_message_destroy(rd_kafka_message_t *rkmessage);\nconst char *rd_kafka_message_errstr(const rd_kafka_message_t *rkmessage);\nint64_t rd_kafka_message_timestamp(const rd_kafka_message_t *rkmessage, rd_kafka_timestamp_type_t *tstype);\nint64_t rd_kafka_message_latency(const rd_kafka_message_t *rkmessage);\nint32_t rd_kafka_message_broker_id(const rd_kafka_message_t *rkmessage);\nrd_kafka_resp_err_t rd_kafka_message_headers(const rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);\nrd_kafka_resp_err_t rd_kafka_message_detach_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);\nvoid rd_kafka_message_set_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t *hdrs);\nsize_t rd_kafka_header_cnt(const rd_kafka_headers_t *hdrs);\ntypedef enum {\n  RD_KAFKA_MSG_STATUS_NOT_PERSISTED = 0,\n  RD_KAFKA_MSG_STATUS_POSSIBLY_PERSISTED = 1,\n  RD_KAFKA_MSG_STATUS_PERSISTED = 2,\n} rd_kafka_msg_status_t;\nrd_kafka_msg_status_t rd_kafka_message_status(const rd_kafka_message_t *rkmessage);\ntypedef enum {\n  RD_KAFKA_CONF_UNKNOWN = (- 2),\n  RD_KAFKA_CONF_INVALID = (- 1),\n  RD_KAFKA_CONF_OK = 0,\n} rd_kafka_conf_res_t;\nrd_kafka_conf_t *rd_kafka_conf_new(void);\nvoid rd_kafka_conf_destroy(rd_kafka_conf_t *conf);\nrd_kafka_conf_t *rd_kafka_conf_dup(const rd_kafka_conf_t *conf);\nrd_kafka_conf_t *rd_kafka_conf_dup_filter(const rd_kafka_conf_t *conf, size_t filter_cnt, const char **filter);\nconst rd_kafka_conf_t *rd_kafka_conf(rd_kafka_t *rk);\nrd_kafka_conf_res_t rd_kafka_conf_set(rd_kafka_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);\nvoid rd_kafka_conf_set_events(rd_kafka_conf_t *conf, int events);\nvoid rd_kafka_conf_set_background_event_cb(rd_kafka_conf_t *conf, void (*event_cb)(rd_kafka_t *rk, rd_kafka_event_t *rkev, void *opaque));\nvoid rd_kafka_conf_set_dr_cb(rd_kafka_conf_t *conf, void (*dr_cb)(rd_kafka_t *rk, void *payload, size_t len, rd_kafka_resp_err_t err, void *opaque, void *msg_opaque));\nvoid rd_kafka_conf_set_dr_msg_cb(rd_kafka_conf_t *conf, void (*dr_msg_cb)(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, void *opaque));\nvoid rd_kafka_conf_set_consume_cb(rd_kafka_conf_t *conf, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *opaque));\nvoid rd_kafka_conf_set_rebalance_cb(rd_kafka_conf_t *conf, void (*rebalance_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *partitions, void *opaque));\nvoid rd_kafka_conf_set_offset_commit_cb(rd_kafka_conf_t *conf, void (*offset_commit_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *opaque));\nvoid rd_kafka_conf_set_error_cb(rd_kafka_conf_t *conf, void (*error_cb)(rd_kafka_t *rk, int err, const char *reason, void *opaque));\nvoid rd_kafka_conf_set_throttle_cb(rd_kafka_conf_t *conf, void (*throttle_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int throttle_time_ms, void *opaque));\nvoid rd_kafka_conf_set_log_cb(rd_kafka_conf_t *conf, void (*log_cb)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));\nvoid rd_kafka_conf_set_stats_cb(rd_kafka_conf_t *conf, int (*stats_cb)(rd_kafka_t *rk, char *json, size_t json_len, void *opaque));\nvoid rd_kafka_conf_set_oauthbearer_token_refresh_cb(rd_kafka_conf_t *conf, void (*oauthbearer_token_refresh_cb)(rd_kafka_t *rk, const char *oauthbearer_config, void *opaque));\nvoid rd_kafka_conf_set_socket_cb(rd_kafka_conf_t *conf, int (*socket_cb)(int domain, int type, int protocol, void *opaque));\nvoid rd_kafka_conf_set_connect_cb(rd_kafka_conf_t *conf, int (*connect_cb)(int sockfd, const struct sockaddr *addr, int addrlen, const char *id, void *opaque));\nvoid rd_kafka_conf_set_closesocket_cb(rd_kafka_conf_t *conf, int (*closesocket_cb)(int sockfd, void *opaque));\nrd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert_verify_cb(rd_kafka_conf_t *conf, int (*ssl_cert_verify_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int *x509_error, int depth, const char *buf, size_t size, char *errstr, size_t errstr_size, void *opaque));\ntypedef enum rd_kafka_cert_type_t {\n  RD_KAFKA_CERT_PUBLIC_KEY,\n  RD_KAFKA_CERT_PRIVATE_KEY,\n  RD_KAFKA_CERT_CA,\n  RD_KAFKA_CERT__CNT,\n} rd_kafka_cert_type_t;\ntypedef enum rd_kafka_cert_enc_t {\n  RD_KAFKA_CERT_ENC_PKCS12,\n  RD_KAFKA_CERT_ENC_DER,\n  RD_KAFKA_CERT_ENC_PEM,\n  RD_KAFKA_CERT_ENC__CNT,\n} rd_kafka_cert_enc_t;\nrd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert(rd_kafka_conf_t *conf, rd_kafka_cert_type_t cert_type, rd_kafka_cert_enc_t cert_enc, const void *buffer, size_t size, char *errstr, size_t errstr_size);\nvoid rd_kafka_conf_set_engine_callback_data(rd_kafka_conf_t *conf, void *callback_data);\nvoid rd_kafka_conf_set_opaque(rd_kafka_conf_t *conf, void *opaque);\nvoid *rd_kafka_opaque(const rd_kafka_t *rk);\nvoid rd_kafka_conf_set_default_topic_conf(rd_kafka_conf_t *conf, rd_kafka_topic_conf_t *tconf);\nrd_kafka_topic_conf_t *rd_kafka_conf_get_default_topic_conf(rd_kafka_conf_t *conf);\nrd_kafka_conf_res_t rd_kafka_conf_get(const rd_kafka_conf_t *conf, const char *name, char *dest, size_t *dest_size);\nrd_kafka_conf_res_t rd_kafka_topic_conf_get(const rd_kafka_topic_conf_t *conf, const char *name, char *dest, size_t *dest_size);\nconst char **rd_kafka_conf_dump(rd_kafka_conf_t *conf, size_t *cntp);\nconst char **rd_kafka_topic_conf_dump(rd_kafka_topic_conf_t *conf, size_t *cntp);\nvoid rd_kafka_conf_dump_free(const char **arr, size_t cnt);\nvoid rd_kafka_conf_properties_show(FILE *fp);\nrd_kafka_topic_conf_t *rd_kafka_topic_conf_new(void);\nrd_kafka_topic_conf_t *rd_kafka_topic_conf_dup(const rd_kafka_topic_conf_t *conf);\nrd_kafka_topic_conf_t *rd_kafka_default_topic_conf_dup(rd_kafka_t *rk);\nvoid rd_kafka_topic_conf_destroy(rd_kafka_topic_conf_t *topic_conf);\nrd_kafka_conf_res_t rd_kafka_topic_conf_set(rd_kafka_topic_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);\nvoid rd_kafka_topic_conf_set_opaque(rd_kafka_topic_conf_t *conf, void *rkt_opaque);\nvoid rd_kafka_topic_conf_set_partitioner_cb(rd_kafka_topic_conf_t *topic_conf, int32_t (*partitioner)(const rd_kafka_topic_t *rkt, const void *keydata, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque));\nvoid rd_kafka_topic_conf_set_msg_order_cmp(rd_kafka_topic_conf_t *topic_conf, int (*msg_order_cmp)(const rd_kafka_message_t *a, const rd_kafka_message_t *b));\nint rd_kafka_topic_partition_available(const rd_kafka_topic_t *rkt, int32_t partition);\nint32_t rd_kafka_msg_partitioner_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_consistent(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_consistent_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_murmur2(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_murmur2_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_fnv1a(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_fnv1a_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nrd_kafka_t *rd_kafka_new(rd_kafka_type_t type, rd_kafka_conf_t *conf, char *errstr, size_t errstr_size);\nvoid rd_kafka_destroy(rd_kafka_t *rk);\nvoid rd_kafka_destroy_flags(rd_kafka_t *rk, int flags);\nconst char *rd_kafka_name(const rd_kafka_t *rk);\nrd_kafka_type_t rd_kafka_type(const rd_kafka_t *rk);\nchar *rd_kafka_memberid(const rd_kafka_t *rk);\nchar *rd_kafka_clusterid(rd_kafka_t *rk, int timeout_ms);\nint32_t rd_kafka_controllerid(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_topic_t *rd_kafka_topic_new(rd_kafka_t *rk, const char *topic, rd_kafka_topic_conf_t *conf);\nvoid rd_kafka_topic_destroy(rd_kafka_topic_t *rkt);\nconst char *rd_kafka_topic_name(const rd_kafka_topic_t *rkt);\nvoid *rd_kafka_topic_opaque(const rd_kafka_topic_t *rkt);\nint rd_kafka_poll(rd_kafka_t *rk, int timeout_ms);\nvoid rd_kafka_yield(rd_kafka_t *rk);\nrd_kafka_resp_err_t rd_kafka_pause_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_resp_err_t rd_kafka_resume_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_resp_err_t rd_kafka_query_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high, int timeout_ms);\nrd_kafka_resp_err_t rd_kafka_get_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high);\nrd_kafka_resp_err_t rd_kafka_offsets_for_times(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets, int timeout_ms);\nvoid *rd_kafka_mem_calloc(rd_kafka_t *rk, size_t num, size_t size);\nvoid *rd_kafka_mem_malloc(rd_kafka_t *rk, size_t size);\nvoid rd_kafka_mem_free(rd_kafka_t *rk, void *ptr);\nrd_kafka_queue_t *rd_kafka_queue_new(rd_kafka_t *rk);\nvoid rd_kafka_queue_destroy(rd_kafka_queue_t *rkqu);\nrd_kafka_queue_t *rd_kafka_queue_get_main(rd_kafka_t *rk);\nrd_kafka_queue_t *rd_kafka_queue_get_consumer(rd_kafka_t *rk);\nrd_kafka_queue_t *rd_kafka_queue_get_partition(rd_kafka_t *rk, const char *topic, int32_t partition);\nrd_kafka_queue_t *rd_kafka_queue_get_background(rd_kafka_t *rk);\nvoid rd_kafka_queue_forward(rd_kafka_queue_t *src, rd_kafka_queue_t *dst);\nrd_kafka_resp_err_t rd_kafka_set_log_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu);\nsize_t rd_kafka_queue_length(rd_kafka_queue_t *rkqu);\nvoid rd_kafka_queue_io_event_enable(rd_kafka_queue_t *rkqu, int fd, const void *payload, size_t size);\nvoid rd_kafka_queue_cb_event_enable(rd_kafka_queue_t *rkqu, void (*event_cb)(rd_kafka_t *rk, void *qev_opaque), void *qev_opaque);\nvoid rd_kafka_queue_yield(rd_kafka_queue_t *rkqu);\nint rd_kafka_consume_start(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);\nint rd_kafka_consume_start_queue(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, rd_kafka_queue_t *rkqu);\nint rd_kafka_consume_stop(rd_kafka_topic_t *rkt, int32_t partition);\nrd_kafka_resp_err_t rd_kafka_seek(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, int timeout_ms);\nrd_kafka_error_t *rd_kafka_seek_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms);\nrd_kafka_message_t *rd_kafka_consume(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms);\nssize_t rd_kafka_consume_batch(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);\nint rd_kafka_consume_callback(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);\nrd_kafka_message_t *rd_kafka_consume_queue(rd_kafka_queue_t *rkqu, int timeout_ms);\nssize_t rd_kafka_consume_batch_queue(rd_kafka_queue_t *rkqu, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);\nint rd_kafka_consume_callback_queue(rd_kafka_queue_t *rkqu, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);\nrd_kafka_resp_err_t rd_kafka_offset_store(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);\nrd_kafka_resp_err_t rd_kafka_offsets_store(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets);\nrd_kafka_resp_err_t rd_kafka_subscribe(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *topics);\nrd_kafka_resp_err_t rd_kafka_unsubscribe(rd_kafka_t *rk);\nrd_kafka_resp_err_t rd_kafka_subscription(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **topics);\nrd_kafka_message_t *rd_kafka_consumer_poll(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_resp_err_t rd_kafka_consumer_close(rd_kafka_t *rk);\nrd_kafka_error_t *rd_kafka_incremental_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_error_t *rd_kafka_incremental_unassign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);\nconst char *rd_kafka_rebalance_protocol(rd_kafka_t *rk);\nrd_kafka_resp_err_t rd_kafka_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_resp_err_t rd_kafka_assignment(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **partitions);\nint rd_kafka_assignment_lost(rd_kafka_t *rk);\nrd_kafka_resp_err_t rd_kafka_commit(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, int async);\nrd_kafka_resp_err_t rd_kafka_commit_message(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, int async);\nrd_kafka_resp_err_t rd_kafka_commit_queue(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_queue_t *rkqu, void (*cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *commit_opaque), void *commit_opaque);\nrd_kafka_resp_err_t rd_kafka_committed(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms);\nrd_kafka_resp_err_t rd_kafka_position(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata(rd_kafka_t *rk);\nrd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata_new(const char *group_id);\nrd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata_new_with_genid(const char *group_id, int32_t generation_id, const char *member_id, const char *group_instance_id);\nvoid rd_kafka_consumer_group_metadata_destroy(rd_kafka_consumer_group_metadata_t *);\nrd_kafka_error_t *rd_kafka_consumer_group_metadata_write(const rd_kafka_consumer_group_metadata_t *cgmd, void **bufferp, size_t *sizep);\nrd_kafka_error_t *rd_kafka_consumer_group_metadata_read(rd_kafka_consumer_group_metadata_t **cgmdp, const void *buffer, size_t size);\nint rd_kafka_produce(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, void *payload, size_t len, const void *key, size_t keylen, void *msg_opaque);\nrd_kafka_resp_err_t rd_kafka_producev(rd_kafka_t *rk, ...);\nrd_kafka_error_t *rd_kafka_produceva(rd_kafka_t *rk, const rd_kafka_vu_t *vus, size_t cnt);\nint rd_kafka_produce_batch(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, rd_kafka_message_t *rkmessages, int message_cnt);\nrd_kafka_resp_err_t rd_kafka_flush(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_resp_err_t rd_kafka_purge(rd_kafka_t *rk, int purge_flags);\ntypedef struct rd_kafka_metadata_broker {\n  int32_t id;\n  char *host;\n  int port;\n} rd_kafka_metadata_broker_t;\ntypedef struct rd_kafka_metadata_partition {\n  int32_t id;\n  rd_kafka_resp_err_t err;\n  int32_t leader;\n  int replica_cnt;\n  int32_t *replicas;\n  int isr_cnt;\n  int32_t *isrs;\n} rd_kafka_metadata_partition_t;\ntypedef struct rd_kafka_metadata_topic {\n  char *topic;\n  int partition_cnt;\n  struct rd_kafka_metadata_partition *partitions;\n  rd_kafka_resp_err_t err;\n} rd_kafka_metadata_topic_t;\ntypedef struct rd_kafka_metadata {\n  int broker_cnt;\n  struct rd_kafka_metadata_broker *brokers;\n  int topic_cnt;\n  struct rd_kafka_metadata_topic *topics;\n  int32_t orig_broker_id;\n  char *orig_broker_name;\n} rd_kafka_metadata_t;\nrd_kafka_resp_err_t rd_kafka_metadata(rd_kafka_t *rk, int all_topics, rd_kafka_topic_t *only_rkt, const struct rd_kafka_metadata **metadatap, int timeout_ms);\nvoid rd_kafka_metadata_destroy(const struct rd_kafka_metadata *metadata);\nstruct rd_kafka_group_member_info {\n  char *member_id;\n  char *client_id;\n  char *client_host;\n  void *member_metadata;\n  int member_metadata_size;\n  void *member_assignment;\n  int member_assignment_size;\n};\nstruct rd_kafka_group_info {\n  struct rd_kafka_metadata_broker broker;\n  char *group;\n  rd_kafka_resp_err_t err;\n  char *state;\n  char *protocol_type;\n  char *protocol;\n  struct rd_kafka_group_member_info *members;\n  int member_cnt;\n};\nstruct rd_kafka_group_list {\n  struct rd_kafka_group_info *groups;\n  int group_cnt;\n};\nrd_kafka_resp_err_t rd_kafka_list_groups(rd_kafka_t *rk, const char *group, const struct rd_kafka_group_list **grplistp, int timeout_ms);\nvoid rd_kafka_group_list_destroy(const struct rd_kafka_group_list *grplist);\nint rd_kafka_brokers_add(rd_kafka_t *rk, const char *brokerlist);\nvoid rd_kafka_set_logger(rd_kafka_t *rk, void (*func)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));\nvoid rd_kafka_set_log_level(rd_kafka_t *rk, int level);\nvoid rd_kafka_log_print(const rd_kafka_t *rk, int level, const char *fac, const char *buf);\nvoid rd_kafka_log_syslog(const rd_kafka_t *rk, int level, const char *fac, const char *buf);\nint rd_kafka_outq_len(rd_kafka_t *rk);\nvoid rd_kafka_dump(FILE *fp, rd_kafka_t *rk);\nint rd_kafka_thread_cnt(void);\ntypedef enum rd_kafka_thread_type_t {\n  RD_KAFKA_THREAD_MAIN,\n  RD_KAFKA_THREAD_BACKGROUND,\n  RD_KAFKA_THREAD_BROKER,\n} rd_kafka_thread_type_t;\nint rd_kafka_wait_destroyed(int timeout_ms);\nint rd_kafka_unittest(void);\nrd_kafka_resp_err_t rd_kafka_poll_set_consumer(rd_kafka_t *rk);\ntypedef int rd_kafka_event_type_t;\nrd_kafka_event_type_t rd_kafka_event_type(const rd_kafka_event_t *rkev);\nconst char *rd_kafka_event_name(const rd_kafka_event_t *rkev);\nvoid rd_kafka_event_destroy(rd_kafka_event_t *rkev);\nconst rd_kafka_message_t *rd_kafka_event_message_next(rd_kafka_event_t *rkev);\nsize_t rd_kafka_event_message_array(rd_kafka_event_t *rkev, const rd_kafka_message_t **rkmessages, size_t size);\nsize_t rd_kafka_event_message_count(rd_kafka_event_t *rkev);\nconst char *rd_kafka_event_config_string(rd_kafka_event_t *rkev);\nrd_kafka_resp_err_t rd_kafka_event_error(rd_kafka_event_t *rkev);\nconst char *rd_kafka_event_error_string(rd_kafka_event_t *rkev);\nint rd_kafka_event_error_is_fatal(rd_kafka_event_t *rkev);\nvoid *rd_kafka_event_opaque(rd_kafka_event_t *rkev);\nint rd_kafka_event_log(rd_kafka_event_t *rkev, const char **fac, const char **str, int *level);\nint rd_kafka_event_debug_contexts(rd_kafka_event_t *rkev, char *dst, size_t dstsize);\nconst char *rd_kafka_event_stats(rd_kafka_event_t *rkev);\nrd_kafka_topic_partition_list_t *rd_kafka_event_topic_partition_list(rd_kafka_event_t *rkev);\nrd_kafka_topic_partition_t *rd_kafka_event_topic_partition(rd_kafka_event_t *rkev);\ntypedef rd_kafka_event_t rd_kafka_CreateTopics_result_t;\ntypedef rd_kafka_event_t rd_kafka_DeleteTopics_result_t;\ntypedef rd_kafka_event_t rd_kafka_CreatePartitions_result_t;\ntypedef rd_kafka_event_t rd_kafka_AlterConfigs_result_t;\ntypedef rd_kafka_event_t rd_kafka_DescribeConfigs_result_t;\ntypedef rd_kafka_event_t rd_kafka_DeleteRecords_result_t;\ntypedef rd_kafka_event_t rd_kafka_DeleteGroups_result_t;\ntypedef rd_kafka_event_t rd_kafka_DeleteConsumerGroupOffsets_result_t;\nconst rd_kafka_CreateTopics_result_t *rd_kafka_event_CreateTopics_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DeleteTopics_result_t *rd_kafka_event_DeleteTopics_result(rd_kafka_event_t *rkev);\nconst rd_kafka_CreatePartitions_result_t *rd_kafka_event_CreatePartitions_result(rd_kafka_event_t *rkev);\nconst rd_kafka_AlterConfigs_result_t *rd_kafka_event_AlterConfigs_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DescribeConfigs_result_t *rd_kafka_event_DescribeConfigs_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DeleteRecords_result_t *rd_kafka_event_DeleteRecords_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DeleteGroups_result_t *rd_kafka_event_DeleteGroups_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DeleteConsumerGroupOffsets_result_t *rd_kafka_event_DeleteConsumerGroupOffsets_result(rd_kafka_event_t *rkev);\nrd_kafka_event_t *rd_kafka_queue_poll(rd_kafka_queue_t *rkqu, int timeout_ms);\nint rd_kafka_queue_poll_callback(rd_kafka_queue_t *rkqu, int timeout_ms);\ntypedef rd_kafka_resp_err_t (rd_kafka_plugin_f_conf_init_t)(rd_kafka_conf_t *conf, void **plug_opaquep, char *errstr, size_t errstr_size);\ntypedef rd_kafka_conf_res_t (rd_kafka_interceptor_f_on_conf_set_t)(rd_kafka_conf_t *conf, const char *name, const char *val, char *errstr, size_t errstr_size, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_dup_t)(rd_kafka_conf_t *new_conf, const rd_kafka_conf_t *old_conf, size_t filter_cnt, const char **filter, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_destroy_t)(void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_new_t)(rd_kafka_t *rk, const rd_kafka_conf_t *conf, void *ic_opaque, char *errstr, size_t errstr_size);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_destroy_t)(rd_kafka_t *rk, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_send_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_acknowledgement_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_consume_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_commit_t)(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_resp_err_t err, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_request_sent_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_response_received_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, int64_t rtt, rd_kafka_resp_err_t err, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_start_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_exit_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_set(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_set_t *on_conf_set, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_dup(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_dup_t *on_conf_dup, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_destroy(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_destroy_t *on_conf_destroy, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_new(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_new_t *on_new, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_destroy(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_destroy_t *on_destroy, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_send(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_send_t *on_send, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_acknowledgement(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_acknowledgement_t *on_acknowledgement, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_consume(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_consume_t *on_consume, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_commit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_commit_t *on_commit, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_request_sent(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_request_sent_t *on_request_sent, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_response_received(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_response_received_t *on_response_received, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_start(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_start_t *on_thread_start, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_exit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_exit_t *on_thread_exit, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_topic_result_error(const rd_kafka_topic_result_t *topicres);\nconst char *rd_kafka_topic_result_error_string(const rd_kafka_topic_result_t *topicres);\nconst char *rd_kafka_topic_result_name(const rd_kafka_topic_result_t *topicres);\nconst rd_kafka_error_t *rd_kafka_group_result_error(const rd_kafka_group_result_t *groupres);\nconst char *rd_kafka_group_result_name(const rd_kafka_group_result_t *groupres);\nconst rd_kafka_topic_partition_list_t *rd_kafka_group_result_partitions(const rd_kafka_group_result_t *groupres);\ntypedef enum rd_kafka_admin_op_t {\n  RD_KAFKA_ADMIN_OP_ANY = 0,\n  RD_KAFKA_ADMIN_OP_CREATETOPICS,\n  RD_KAFKA_ADMIN_OP_DELETETOPICS,\n  RD_KAFKA_ADMIN_OP_CREATEPARTITIONS,\n  RD_KAFKA_ADMIN_OP_ALTERCONFIGS,\n  RD_KAFKA_ADMIN_OP_DESCRIBECONFIGS,\n  RD_KAFKA_ADMIN_OP_DELETERECORDS,\n  RD_KAFKA_ADMIN_OP_DELETEGROUPS,\n  RD_KAFKA_ADMIN_OP_DELETECONSUMERGROUPOFFSETS,\n  RD_KAFKA_ADMIN_OP__CNT,\n} rd_kafka_admin_op_t;\ntypedef struct rd_kafka_AdminOptions_s rd_kafka_AdminOptions_t;\nrd_kafka_AdminOptions_t *rd_kafka_AdminOptions_new(rd_kafka_t *rk, rd_kafka_admin_op_t for_api);\nvoid rd_kafka_AdminOptions_destroy(rd_kafka_AdminOptions_t *options);\nrd_kafka_resp_err_t rd_kafka_AdminOptions_set_request_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_AdminOptions_set_operation_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_AdminOptions_set_validate_only(rd_kafka_AdminOptions_t *options, int true_or_false, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_AdminOptions_set_broker(rd_kafka_AdminOptions_t *options, int32_t broker_id, char *errstr, size_t errstr_size);\nvoid rd_kafka_AdminOptions_set_opaque(rd_kafka_AdminOptions_t *options, void *ev_opaque);\ntypedef struct rd_kafka_NewTopic_s rd_kafka_NewTopic_t;\nrd_kafka_NewTopic_t *rd_kafka_NewTopic_new(const char *topic, int num_partitions, int replication_factor, char *errstr, size_t errstr_size);\nvoid rd_kafka_NewTopic_destroy(rd_kafka_NewTopic_t *new_topic);\nvoid rd_kafka_NewTopic_destroy_array(rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt);\nrd_kafka_resp_err_t rd_kafka_NewTopic_set_replica_assignment(rd_kafka_NewTopic_t *new_topic, int32_t partition, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_NewTopic_set_config(rd_kafka_NewTopic_t *new_topic, const char *name, const char *value);\nvoid rd_kafka_CreateTopics(rd_kafka_t *rk, rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_topic_result_t **rd_kafka_CreateTopics_result_topics(const rd_kafka_CreateTopics_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_DeleteTopic_s rd_kafka_DeleteTopic_t;\nrd_kafka_DeleteTopic_t *rd_kafka_DeleteTopic_new(const char *topic);\nvoid rd_kafka_DeleteTopic_destroy(rd_kafka_DeleteTopic_t *del_topic);\nvoid rd_kafka_DeleteTopic_destroy_array(rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt);\nvoid rd_kafka_DeleteTopics(rd_kafka_t *rk, rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_topic_result_t **rd_kafka_DeleteTopics_result_topics(const rd_kafka_DeleteTopics_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_NewPartitions_s rd_kafka_NewPartitions_t;\nrd_kafka_NewPartitions_t *rd_kafka_NewPartitions_new(const char *topic, size_t new_total_cnt, char *errstr, size_t errstr_size);\nvoid rd_kafka_NewPartitions_destroy(rd_kafka_NewPartitions_t *new_parts);\nvoid rd_kafka_NewPartitions_destroy_array(rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt);\nrd_kafka_resp_err_t rd_kafka_NewPartitions_set_replica_assignment(rd_kafka_NewPartitions_t *new_parts, int32_t new_partition_idx, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);\nvoid rd_kafka_CreatePartitions(rd_kafka_t *rk, rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_topic_result_t **rd_kafka_CreatePartitions_result_topics(const rd_kafka_CreatePartitions_result_t *result, size_t *cntp);\ntypedef enum rd_kafka_ConfigSource_t {\n  RD_KAFKA_CONFIG_SOURCE_UNKNOWN_CONFIG = 0,\n  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_TOPIC_CONFIG = 1,\n  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_BROKER_CONFIG = 2,\n  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_DEFAULT_BROKER_CONFIG = 3,\n  RD_KAFKA_CONFIG_SOURCE_STATIC_BROKER_CONFIG = 4,\n  RD_KAFKA_CONFIG_SOURCE_DEFAULT_CONFIG = 5,\n  RD_KAFKA_CONFIG_SOURCE__CNT,\n} rd_kafka_ConfigSource_t;\nconst char *rd_kafka_ConfigSource_name(rd_kafka_ConfigSource_t confsource);\ntypedef struct rd_kafka_ConfigEntry_s rd_kafka_ConfigEntry_t;\nconst char *rd_kafka_ConfigEntry_name(const rd_kafka_ConfigEntry_t *entry);\nconst char *rd_kafka_ConfigEntry_value(const rd_kafka_ConfigEntry_t *entry);\nrd_kafka_ConfigSource_t rd_kafka_ConfigEntry_source(const rd_kafka_ConfigEntry_t *entry);\nint rd_kafka_ConfigEntry_is_read_only(const rd_kafka_ConfigEntry_t *entry);\nint rd_kafka_ConfigEntry_is_default(const rd_kafka_ConfigEntry_t *entry);\nint rd_kafka_ConfigEntry_is_sensitive(const rd_kafka_ConfigEntry_t *entry);\nint rd_kafka_ConfigEntry_is_synonym(const rd_kafka_ConfigEntry_t *entry);\nconst rd_kafka_ConfigEntry_t **rd_kafka_ConfigEntry_synonyms(const rd_kafka_ConfigEntry_t *entry, size_t *cntp);\ntypedef enum rd_kafka_ResourceType_t {\n  RD_KAFKA_RESOURCE_UNKNOWN = 0,\n  RD_KAFKA_RESOURCE_ANY = 1,\n  RD_KAFKA_RESOURCE_TOPIC = 2,\n  RD_KAFKA_RESOURCE_GROUP = 3,\n  RD_KAFKA_RESOURCE_BROKER = 4,\n  RD_KAFKA_RESOURCE__CNT,\n} rd_kafka_ResourceType_t;\nconst char *rd_kafka_ResourceType_name(rd_kafka_ResourceType_t restype);\ntypedef struct rd_kafka_ConfigResource_s rd_kafka_ConfigResource_t;\nrd_kafka_ConfigResource_t *rd_kafka_ConfigResource_new(rd_kafka_ResourceType_t restype, const char *resname);\nvoid rd_kafka_ConfigResource_destroy(rd_kafka_ConfigResource_t *config);\nvoid rd_kafka_ConfigResource_destroy_array(rd_kafka_ConfigResource_t **config, size_t config_cnt);\nrd_kafka_resp_err_t rd_kafka_ConfigResource_set_config(rd_kafka_ConfigResource_t *config, const char *name, const char *value);\nconst rd_kafka_ConfigEntry_t **rd_kafka_ConfigResource_configs(const rd_kafka_ConfigResource_t *config, size_t *cntp);\nrd_kafka_ResourceType_t rd_kafka_ConfigResource_type(const rd_kafka_ConfigResource_t *config);\nconst char *rd_kafka_ConfigResource_name(const rd_kafka_ConfigResource_t *config);\nrd_kafka_resp_err_t rd_kafka_ConfigResource_error(const rd_kafka_ConfigResource_t *config);\nconst char *rd_kafka_ConfigResource_error_string(const rd_kafka_ConfigResource_t *config);\nvoid rd_kafka_AlterConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_ConfigResource_t **rd_kafka_AlterConfigs_result_resources(const rd_kafka_AlterConfigs_result_t *result, size_t *cntp);\nvoid rd_kafka_DescribeConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_ConfigResource_t **rd_kafka_DescribeConfigs_result_resources(const rd_kafka_DescribeConfigs_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_DeleteRecords_s rd_kafka_DeleteRecords_t;\nrd_kafka_DeleteRecords_t *rd_kafka_DeleteRecords_new(const rd_kafka_topic_partition_list_t *before_offsets);\nvoid rd_kafka_DeleteRecords_destroy(rd_kafka_DeleteRecords_t *del_records);\nvoid rd_kafka_DeleteRecords_destroy_array(rd_kafka_DeleteRecords_t **del_records, size_t del_record_cnt);\nvoid rd_kafka_DeleteRecords(rd_kafka_t *rk, rd_kafka_DeleteRecords_t **del_records, size_t del_record_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_topic_partition_list_t *rd_kafka_DeleteRecords_result_offsets(const rd_kafka_DeleteRecords_result_t *result);\ntypedef struct rd_kafka_DeleteGroup_s rd_kafka_DeleteGroup_t;\nrd_kafka_DeleteGroup_t *rd_kafka_DeleteGroup_new(const char *group);\nvoid rd_kafka_DeleteGroup_destroy(rd_kafka_DeleteGroup_t *del_group);\nvoid rd_kafka_DeleteGroup_destroy_array(rd_kafka_DeleteGroup_t **del_groups, size_t del_group_cnt);\nvoid rd_kafka_DeleteGroups(rd_kafka_t *rk, rd_kafka_DeleteGroup_t **del_groups, size_t del_group_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_group_result_t **rd_kafka_DeleteGroups_result_groups(const rd_kafka_DeleteGroups_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_DeleteConsumerGroupOffsets_s rd_kafka_DeleteConsumerGroupOffsets_t;\nrd_kafka_DeleteConsumerGroupOffsets_t *rd_kafka_DeleteConsumerGroupOffsets_new(const char *group, const rd_kafka_topic_partition_list_t *partitions);\nvoid rd_kafka_DeleteConsumerGroupOffsets_destroy(rd_kafka_DeleteConsumerGroupOffsets_t *del_grpoffsets);\nvoid rd_kafka_DeleteConsumerGroupOffsets_destroy_array(rd_kafka_DeleteConsumerGroupOffsets_t **del_grpoffsets, size_t del_grpoffset_cnt);\nvoid rd_kafka_DeleteConsumerGroupOffsets(rd_kafka_t *rk, rd_kafka_DeleteConsumerGroupOffsets_t **del_grpoffsets, size_t del_grpoffsets_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_group_result_t **rd_kafka_DeleteConsumerGroupOffsets_result_groups(const rd_kafka_DeleteConsumerGroupOffsets_result_t *result, size_t *cntp);\nrd_kafka_resp_err_t rd_kafka_oauthbearer_set_token(rd_kafka_t *rk, const char *token_value, int64_t md_lifetime_ms, const char *md_principal_name, const char **extensions, size_t extension_size, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_oauthbearer_set_token_failure(rd_kafka_t *rk, const char *errstr);\nrd_kafka_error_t *rd_kafka_init_transactions(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_error_t *rd_kafka_begin_transaction(rd_kafka_t *rk);\nrd_kafka_error_t *rd_kafka_send_offsets_to_transaction(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, const rd_kafka_consumer_group_metadata_t *cgmetadata, int timeout_ms);\nrd_kafka_error_t *rd_kafka_commit_transaction(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_error_t *rd_kafka_abort_transaction(rd_kafka_t *rk, int timeout_ms);\ntypedef struct rd_kafka_mock_cluster_s rd_kafka_mock_cluster_t;\nrd_kafka_mock_cluster_t *rd_kafka_mock_cluster_new(rd_kafka_t *rk, int broker_cnt);\nvoid rd_kafka_mock_cluster_destroy(rd_kafka_mock_cluster_t *mcluster);\nrd_kafka_t *rd_kafka_mock_cluster_handle(const rd_kafka_mock_cluster_t *mcluster);\nrd_kafka_mock_cluster_t *rd_kafka_handle_mock_cluster(const rd_kafka_t *rk);\nconst char *rd_kafka_mock_cluster_bootstraps(const rd_kafka_mock_cluster_t *mcluster);\nvoid rd_kafka_mock_clear_request_errors(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey);\nvoid rd_kafka_mock_push_request_errors(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, size_t cnt, ...);\nvoid rd_kafka_mock_push_request_errors_array(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, size_t cnt, const rd_kafka_resp_err_t *errors);\nrd_kafka_resp_err_t rd_kafka_mock_broker_push_request_error_rtts(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int16_t ApiKey, size_t cnt, ...);\nvoid rd_kafka_mock_topic_set_error(rd_kafka_mock_cluster_t *mcluster, const char *topic, rd_kafka_resp_err_t err);\nrd_kafka_resp_err_t rd_kafka_mock_topic_create(rd_kafka_mock_cluster_t *mcluster, const char *topic, int partition_cnt, int replication_factor);\nrd_kafka_resp_err_t rd_kafka_mock_partition_set_leader(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id);\nrd_kafka_resp_err_t rd_kafka_mock_partition_set_follower(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id);\nrd_kafka_resp_err_t rd_kafka_mock_partition_set_follower_wmarks(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int64_t lo, int64_t hi);\nrd_kafka_resp_err_t rd_kafka_mock_broker_set_down(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id);\nrd_kafka_resp_err_t rd_kafka_mock_broker_set_up(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id);\nrd_kafka_resp_err_t rd_kafka_mock_broker_set_rtt(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int rtt_ms);\nrd_kafka_resp_err_t rd_kafka_mock_broker_set_rack(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, const char *rack);\nrd_kafka_resp_err_t rd_kafka_mock_coordinator_set(rd_kafka_mock_cluster_t *mcluster, const char *key_type, const char *key, int32_t broker_id);\nrd_kafka_resp_err_t rd_kafka_mock_set_apiversion(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, int16_t MinVersion, int16_t MaxVersion);\n'\n</code></pre> rdkafka.h, rdkafka_mock.h</p>"},{"location":"api/constants/#rd_kafka_version_17","title":"RD_KAFKA_VERSION","text":"<pre><code>public RD_KAFKA_VERSION = 17301759\n</code></pre> <p>librdkafka version </p> <p>Interpreted as hex <code>MM.mm.rr.xx</code>:</p> <ul> <li>MM = Major</li> <li>mm = minor</li> <li>rr = revision</li> <li>xx = pre-release id (0xff is the final release)</li> </ul> <p>E.g.: <code>0x000801ff</code> = 0.8.1</p> RemarksThis value should only be used during compile time, for runtime checks of version use rd_kafka_version()  <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_unsupported_compression_type_17","title":"RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE","text":"<pre><code>public RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76\n</code></pre> <p>Unsupported compression type </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_end_all_17","title":"RD_KAFKA_RESP_ERR_END_ALL","text":"<p><pre><code>public RD_KAFKA_RESP_ERR_END_ALL = 98\n</code></pre> enum rd_kafka_resp_err_t</p>"},{"location":"api/constants/#rd_kafka_admin_op__cnt_17","title":"RD_KAFKA_ADMIN_OP__CNT","text":"<pre><code>public RD_KAFKA_ADMIN_OP__CNT = 9\n</code></pre> <p>Number of ops defined </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe </li> </ul>"},{"location":"api/constants/#rd_kafka_resource__cnt_17","title":"RD_KAFKA_RESOURCE__CNT","text":"<pre><code>public RD_KAFKA_RESOURCE__CNT = 5\n</code></pre> <p>Number of resource types defined </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#acca83a66d7783ff7683ed2691cc907c9 </li> </ul>"},{"location":"api/constants/#rd_kafka_cdef_17","title":"RD_KAFKA_CDEF","text":"<p><pre><code>public RD_KAFKA_CDEF = 'typedef long int ssize_t;\ntypedef struct _IO_FILE FILE;\ntypedef long int mode_t;\ntypedef signed int int16_t;\ntypedef unsigned int uint16_t;\ntypedef signed int int32_t;\ntypedef signed long int int64_t;\nint rd_kafka_version(void);\nconst char *rd_kafka_version_str(void);\ntypedef enum rd_kafka_type_t {\n  RD_KAFKA_PRODUCER,\n  RD_KAFKA_CONSUMER,\n} rd_kafka_type_t;\ntypedef enum rd_kafka_timestamp_type_t {\n  RD_KAFKA_TIMESTAMP_NOT_AVAILABLE,\n  RD_KAFKA_TIMESTAMP_CREATE_TIME,\n  RD_KAFKA_TIMESTAMP_LOG_APPEND_TIME,\n} rd_kafka_timestamp_type_t;\nconst char *rd_kafka_get_debug_contexts(void);\ntypedef struct rd_kafka_s rd_kafka_t;\ntypedef struct rd_kafka_topic_s rd_kafka_topic_t;\ntypedef struct rd_kafka_conf_s rd_kafka_conf_t;\ntypedef struct rd_kafka_topic_conf_s rd_kafka_topic_conf_t;\ntypedef struct rd_kafka_queue_s rd_kafka_queue_t;\ntypedef struct rd_kafka_op_s rd_kafka_event_t;\ntypedef struct rd_kafka_topic_result_s rd_kafka_topic_result_t;\ntypedef struct rd_kafka_consumer_group_metadata_s rd_kafka_consumer_group_metadata_t;\ntypedef struct rd_kafka_error_s {\n  unsigned int code;\n  char *errstr;\n  unsigned char fatal;\n  unsigned char retriable;\n  unsigned char txn_requires_abort;\n} rd_kafka_error_t;\ntypedef struct rd_kafka_headers_s rd_kafka_headers_t;\ntypedef struct rd_kafka_group_result_s rd_kafka_group_result_t;\ntypedef enum {\n  RD_KAFKA_RESP_ERR__BEGIN = (- 200),\n  RD_KAFKA_RESP_ERR__BAD_MSG = (- 199),\n  RD_KAFKA_RESP_ERR__BAD_COMPRESSION = (- 198),\n  RD_KAFKA_RESP_ERR__DESTROY = (- 197),\n  RD_KAFKA_RESP_ERR__FAIL = (- 196),\n  RD_KAFKA_RESP_ERR__TRANSPORT = (- 195),\n  RD_KAFKA_RESP_ERR__CRIT_SYS_RESOURCE = (- 194),\n  RD_KAFKA_RESP_ERR__RESOLVE = (- 193),\n  RD_KAFKA_RESP_ERR__MSG_TIMED_OUT = (- 192),\n  RD_KAFKA_RESP_ERR__PARTITION_EOF = (- 191),\n  RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION = (- 190),\n  RD_KAFKA_RESP_ERR__FS = (- 189),\n  RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC = (- 188),\n  RD_KAFKA_RESP_ERR__ALL_BROKERS_DOWN = (- 187),\n  RD_KAFKA_RESP_ERR__INVALID_ARG = (- 186),\n  RD_KAFKA_RESP_ERR__TIMED_OUT = (- 185),\n  RD_KAFKA_RESP_ERR__QUEUE_FULL = (- 184),\n  RD_KAFKA_RESP_ERR__ISR_INSUFF = (- 183),\n  RD_KAFKA_RESP_ERR__NODE_UPDATE = (- 182),\n  RD_KAFKA_RESP_ERR__SSL = (- 181),\n  RD_KAFKA_RESP_ERR__WAIT_COORD = (- 180),\n  RD_KAFKA_RESP_ERR__UNKNOWN_GROUP = (- 179),\n  RD_KAFKA_RESP_ERR__IN_PROGRESS = (- 178),\n  RD_KAFKA_RESP_ERR__PREV_IN_PROGRESS = (- 177),\n  RD_KAFKA_RESP_ERR__EXISTING_SUBSCRIPTION = (- 176),\n  RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS = (- 175),\n  RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS = (- 174),\n  RD_KAFKA_RESP_ERR__CONFLICT = (- 173),\n  RD_KAFKA_RESP_ERR__STATE = (- 172),\n  RD_KAFKA_RESP_ERR__UNKNOWN_PROTOCOL = (- 171),\n  RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED = (- 170),\n  RD_KAFKA_RESP_ERR__AUTHENTICATION = (- 169),\n  RD_KAFKA_RESP_ERR__NO_OFFSET = (- 168),\n  RD_KAFKA_RESP_ERR__OUTDATED = (- 167),\n  RD_KAFKA_RESP_ERR__TIMED_OUT_QUEUE = (- 166),\n  RD_KAFKA_RESP_ERR__UNSUPPORTED_FEATURE = (- 165),\n  RD_KAFKA_RESP_ERR__WAIT_CACHE = (- 164),\n  RD_KAFKA_RESP_ERR__INTR = (- 163),\n  RD_KAFKA_RESP_ERR__KEY_SERIALIZATION = (- 162),\n  RD_KAFKA_RESP_ERR__VALUE_SERIALIZATION = (- 161),\n  RD_KAFKA_RESP_ERR__KEY_DESERIALIZATION = (- 160),\n  RD_KAFKA_RESP_ERR__VALUE_DESERIALIZATION = (- 159),\n  RD_KAFKA_RESP_ERR__PARTIAL = (- 158),\n  RD_KAFKA_RESP_ERR__READ_ONLY = (- 157),\n  RD_KAFKA_RESP_ERR__NOENT = (- 156),\n  RD_KAFKA_RESP_ERR__UNDERFLOW = (- 155),\n  RD_KAFKA_RESP_ERR__INVALID_TYPE = (- 154),\n  RD_KAFKA_RESP_ERR__RETRY = (- 153),\n  RD_KAFKA_RESP_ERR__PURGE_QUEUE = (- 152),\n  RD_KAFKA_RESP_ERR__PURGE_INFLIGHT = (- 151),\n  RD_KAFKA_RESP_ERR__FATAL = (- 150),\n  RD_KAFKA_RESP_ERR__INCONSISTENT = (- 149),\n  RD_KAFKA_RESP_ERR__GAPLESS_GUARANTEE = (- 148),\n  RD_KAFKA_RESP_ERR__MAX_POLL_EXCEEDED = (- 147),\n  RD_KAFKA_RESP_ERR__UNKNOWN_BROKER = (- 146),\n  RD_KAFKA_RESP_ERR__NOT_CONFIGURED = (- 145),\n  RD_KAFKA_RESP_ERR__FENCED = (- 144),\n  RD_KAFKA_RESP_ERR__APPLICATION = (- 143),\n  RD_KAFKA_RESP_ERR__ASSIGNMENT_LOST = (- 142),\n  RD_KAFKA_RESP_ERR__NOOP = (- 141),\n  RD_KAFKA_RESP_ERR__AUTO_OFFSET_RESET = (- 140),\n  RD_KAFKA_RESP_ERR__END = (- 100),\n  RD_KAFKA_RESP_ERR_UNKNOWN = (- 1),\n  RD_KAFKA_RESP_ERR_NO_ERROR = 0,\n  RD_KAFKA_RESP_ERR_OFFSET_OUT_OF_RANGE = 1,\n  RD_KAFKA_RESP_ERR_INVALID_MSG = 2,\n  RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART = 3,\n  RD_KAFKA_RESP_ERR_INVALID_MSG_SIZE = 4,\n  RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE = 5,\n  RD_KAFKA_RESP_ERR_NOT_LEADER_FOR_PARTITION = 6,\n  RD_KAFKA_RESP_ERR_REQUEST_TIMED_OUT = 7,\n  RD_KAFKA_RESP_ERR_BROKER_NOT_AVAILABLE = 8,\n  RD_KAFKA_RESP_ERR_REPLICA_NOT_AVAILABLE = 9,\n  RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE = 10,\n  RD_KAFKA_RESP_ERR_STALE_CTRL_EPOCH = 11,\n  RD_KAFKA_RESP_ERR_OFFSET_METADATA_TOO_LARGE = 12,\n  RD_KAFKA_RESP_ERR_NETWORK_EXCEPTION = 13,\n  RD_KAFKA_RESP_ERR_COORDINATOR_LOAD_IN_PROGRESS = 14,\n  RD_KAFKA_RESP_ERR_COORDINATOR_NOT_AVAILABLE = 15,\n  RD_KAFKA_RESP_ERR_NOT_COORDINATOR = 16,\n  RD_KAFKA_RESP_ERR_TOPIC_EXCEPTION = 17,\n  RD_KAFKA_RESP_ERR_RECORD_LIST_TOO_LARGE = 18,\n  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS = 19,\n  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS_AFTER_APPEND = 20,\n  RD_KAFKA_RESP_ERR_INVALID_REQUIRED_ACKS = 21,\n  RD_KAFKA_RESP_ERR_ILLEGAL_GENERATION = 22,\n  RD_KAFKA_RESP_ERR_INCONSISTENT_GROUP_PROTOCOL = 23,\n  RD_KAFKA_RESP_ERR_INVALID_GROUP_ID = 24,\n  RD_KAFKA_RESP_ERR_UNKNOWN_MEMBER_ID = 25,\n  RD_KAFKA_RESP_ERR_INVALID_SESSION_TIMEOUT = 26,\n  RD_KAFKA_RESP_ERR_REBALANCE_IN_PROGRESS = 27,\n  RD_KAFKA_RESP_ERR_INVALID_COMMIT_OFFSET_SIZE = 28,\n  RD_KAFKA_RESP_ERR_TOPIC_AUTHORIZATION_FAILED = 29,\n  RD_KAFKA_RESP_ERR_GROUP_AUTHORIZATION_FAILED = 30,\n  RD_KAFKA_RESP_ERR_CLUSTER_AUTHORIZATION_FAILED = 31,\n  RD_KAFKA_RESP_ERR_INVALID_TIMESTAMP = 32,\n  RD_KAFKA_RESP_ERR_UNSUPPORTED_SASL_MECHANISM = 33,\n  RD_KAFKA_RESP_ERR_ILLEGAL_SASL_STATE = 34,\n  RD_KAFKA_RESP_ERR_UNSUPPORTED_VERSION = 35,\n  RD_KAFKA_RESP_ERR_TOPIC_ALREADY_EXISTS = 36,\n  RD_KAFKA_RESP_ERR_INVALID_PARTITIONS = 37,\n  RD_KAFKA_RESP_ERR_INVALID_REPLICATION_FACTOR = 38,\n  RD_KAFKA_RESP_ERR_INVALID_REPLICA_ASSIGNMENT = 39,\n  RD_KAFKA_RESP_ERR_INVALID_CONFIG = 40,\n  RD_KAFKA_RESP_ERR_NOT_CONTROLLER = 41,\n  RD_KAFKA_RESP_ERR_INVALID_REQUEST = 42,\n  RD_KAFKA_RESP_ERR_UNSUPPORTED_FOR_MESSAGE_FORMAT = 43,\n  RD_KAFKA_RESP_ERR_POLICY_VIOLATION = 44,\n  RD_KAFKA_RESP_ERR_OUT_OF_ORDER_SEQUENCE_NUMBER = 45,\n  RD_KAFKA_RESP_ERR_DUPLICATE_SEQUENCE_NUMBER = 46,\n  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_EPOCH = 47,\n  RD_KAFKA_RESP_ERR_INVALID_TXN_STATE = 48,\n  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_ID_MAPPING = 49,\n  RD_KAFKA_RESP_ERR_INVALID_TRANSACTION_TIMEOUT = 50,\n  RD_KAFKA_RESP_ERR_CONCURRENT_TRANSACTIONS = 51,\n  RD_KAFKA_RESP_ERR_TRANSACTION_COORDINATOR_FENCED = 52,\n  RD_KAFKA_RESP_ERR_TRANSACTIONAL_ID_AUTHORIZATION_FAILED = 53,\n  RD_KAFKA_RESP_ERR_SECURITY_DISABLED = 54,\n  RD_KAFKA_RESP_ERR_OPERATION_NOT_ATTEMPTED = 55,\n  RD_KAFKA_RESP_ERR_KAFKA_STORAGE_ERROR = 56,\n  RD_KAFKA_RESP_ERR_LOG_DIR_NOT_FOUND = 57,\n  RD_KAFKA_RESP_ERR_SASL_AUTHENTICATION_FAILED = 58,\n  RD_KAFKA_RESP_ERR_UNKNOWN_PRODUCER_ID = 59,\n  RD_KAFKA_RESP_ERR_REASSIGNMENT_IN_PROGRESS = 60,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTH_DISABLED = 61,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_NOT_FOUND = 62,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_OWNER_MISMATCH = 63,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_REQUEST_NOT_ALLOWED = 64,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTHORIZATION_FAILED = 65,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_EXPIRED = 66,\n  RD_KAFKA_RESP_ERR_INVALID_PRINCIPAL_TYPE = 67,\n  RD_KAFKA_RESP_ERR_NON_EMPTY_GROUP = 68,\n  RD_KAFKA_RESP_ERR_GROUP_ID_NOT_FOUND = 69,\n  RD_KAFKA_RESP_ERR_FETCH_SESSION_ID_NOT_FOUND = 70,\n  RD_KAFKA_RESP_ERR_INVALID_FETCH_SESSION_EPOCH = 71,\n  RD_KAFKA_RESP_ERR_LISTENER_NOT_FOUND = 72,\n  RD_KAFKA_RESP_ERR_TOPIC_DELETION_DISABLED = 73,\n  RD_KAFKA_RESP_ERR_FENCED_LEADER_EPOCH = 74,\n  RD_KAFKA_RESP_ERR_UNKNOWN_LEADER_EPOCH = 75,\n  RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76,\n  RD_KAFKA_RESP_ERR_STALE_BROKER_EPOCH = 77,\n  RD_KAFKA_RESP_ERR_OFFSET_NOT_AVAILABLE = 78,\n  RD_KAFKA_RESP_ERR_MEMBER_ID_REQUIRED = 79,\n  RD_KAFKA_RESP_ERR_PREFERRED_LEADER_NOT_AVAILABLE = 80,\n  RD_KAFKA_RESP_ERR_GROUP_MAX_SIZE_REACHED = 81,\n  RD_KAFKA_RESP_ERR_FENCED_INSTANCE_ID = 82,\n  RD_KAFKA_RESP_ERR_ELIGIBLE_LEADERS_NOT_AVAILABLE = 83,\n  RD_KAFKA_RESP_ERR_ELECTION_NOT_NEEDED = 84,\n  RD_KAFKA_RESP_ERR_NO_REASSIGNMENT_IN_PROGRESS = 85,\n  RD_KAFKA_RESP_ERR_GROUP_SUBSCRIBED_TO_TOPIC = 86,\n  RD_KAFKA_RESP_ERR_INVALID_RECORD = 87,\n  RD_KAFKA_RESP_ERR_UNSTABLE_OFFSET_COMMIT = 88,\n  RD_KAFKA_RESP_ERR_THROTTLING_QUOTA_EXCEEDED = 89,\n  RD_KAFKA_RESP_ERR_PRODUCER_FENCED = 90,\n  RD_KAFKA_RESP_ERR_RESOURCE_NOT_FOUND = 91,\n  RD_KAFKA_RESP_ERR_DUPLICATE_RESOURCE = 92,\n  RD_KAFKA_RESP_ERR_UNACCEPTABLE_CREDENTIAL = 93,\n  RD_KAFKA_RESP_ERR_INCONSISTENT_VOTER_SET = 94,\n  RD_KAFKA_RESP_ERR_INVALID_UPDATE_VERSION = 95,\n  RD_KAFKA_RESP_ERR_FEATURE_UPDATE_FAILED = 96,\n  RD_KAFKA_RESP_ERR_PRINCIPAL_DESERIALIZATION_FAILURE = 97,\n  RD_KAFKA_RESP_ERR_END_ALL,\n} rd_kafka_resp_err_t;\nstruct rd_kafka_err_desc {\n  rd_kafka_resp_err_t code;\n  char *name;\n  char *desc;\n};\nvoid rd_kafka_get_err_descs(const struct rd_kafka_err_desc **errdescs, size_t *cntp);\nconst char *rd_kafka_err2str(rd_kafka_resp_err_t err);\nconst char *rd_kafka_err2name(rd_kafka_resp_err_t err);\nrd_kafka_resp_err_t rd_kafka_last_error(void);\nrd_kafka_resp_err_t rd_kafka_errno2err(int errnox);\nint rd_kafka_errno(void);\nrd_kafka_resp_err_t rd_kafka_fatal_error(rd_kafka_t *rk, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_test_fatal_error(rd_kafka_t *rk, rd_kafka_resp_err_t err, const char *reason);\nrd_kafka_resp_err_t rd_kafka_error_code(const rd_kafka_error_t *error);\nconst char *rd_kafka_error_name(const rd_kafka_error_t *error);\nconst char *rd_kafka_error_string(const rd_kafka_error_t *error);\nint rd_kafka_error_is_fatal(const rd_kafka_error_t *error);\nint rd_kafka_error_is_retriable(const rd_kafka_error_t *error);\nint rd_kafka_error_txn_requires_abort(const rd_kafka_error_t *error);\nvoid rd_kafka_error_destroy(rd_kafka_error_t *error);\nrd_kafka_error_t *rd_kafka_error_new(rd_kafka_resp_err_t code, const char *fmt, ...);\ntypedef struct rd_kafka_topic_partition_s {\n  char *topic;\n  int32_t partition;\n  int64_t offset;\n  void *metadata;\n  size_t metadata_size;\n  void *opaque;\n  rd_kafka_resp_err_t err;\n  void *_private;\n} rd_kafka_topic_partition_t;\nvoid rd_kafka_topic_partition_destroy(rd_kafka_topic_partition_t *rktpar);\ntypedef struct rd_kafka_topic_partition_list_s {\n  int cnt;\n  int size;\n  rd_kafka_topic_partition_t *elems;\n} rd_kafka_topic_partition_list_t;\nrd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_new(int size);\nvoid rd_kafka_topic_partition_list_destroy(rd_kafka_topic_partition_list_t *rkparlist);\nrd_kafka_topic_partition_t *rd_kafka_topic_partition_list_add(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);\nvoid rd_kafka_topic_partition_list_add_range(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t start, int32_t stop);\nint rd_kafka_topic_partition_list_del(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);\nint rd_kafka_topic_partition_list_del_by_idx(rd_kafka_topic_partition_list_t *rktparlist, int idx);\nrd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_copy(const rd_kafka_topic_partition_list_t *src);\nrd_kafka_resp_err_t rd_kafka_topic_partition_list_set_offset(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition, int64_t offset);\nrd_kafka_topic_partition_t *rd_kafka_topic_partition_list_find(const rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);\nvoid rd_kafka_topic_partition_list_sort(rd_kafka_topic_partition_list_t *rktparlist, int (*cmp)(const void *a, const void *b, void *cmp_opaque), void *cmp_opaque);\ntypedef enum rd_kafka_vtype_t {\n  RD_KAFKA_VTYPE_END,\n  RD_KAFKA_VTYPE_TOPIC,\n  RD_KAFKA_VTYPE_RKT,\n  RD_KAFKA_VTYPE_PARTITION,\n  RD_KAFKA_VTYPE_VALUE,\n  RD_KAFKA_VTYPE_KEY,\n  RD_KAFKA_VTYPE_OPAQUE,\n  RD_KAFKA_VTYPE_MSGFLAGS,\n  RD_KAFKA_VTYPE_TIMESTAMP,\n  RD_KAFKA_VTYPE_HEADER,\n  RD_KAFKA_VTYPE_HEADERS,\n} rd_kafka_vtype_t;\ntypedef struct rd_kafka_vu_s {\n  rd_kafka_vtype_t vtype;\n  union {\n    char *cstr;\n    rd_kafka_topic_t *rkt;\n    int i;\n    int32_t i32;\n    int64_t i64;\n    struct {\n      void *ptr;\n      size_t size;\n    } mem;\n    struct {\n      char *name;\n      void *val;\n      ssize_t size;\n    } header;\n    rd_kafka_headers_t *headers;\n    void *ptr;\n    char _pad[64];\n  } u;\n} rd_kafka_vu_t;\nrd_kafka_headers_t *rd_kafka_headers_new(size_t initial_count);\nvoid rd_kafka_headers_destroy(rd_kafka_headers_t *hdrs);\nrd_kafka_headers_t *rd_kafka_headers_copy(const rd_kafka_headers_t *src);\nrd_kafka_resp_err_t rd_kafka_header_add(rd_kafka_headers_t *hdrs, const char *name, ssize_t name_size, const void *value, ssize_t value_size);\nrd_kafka_resp_err_t rd_kafka_header_remove(rd_kafka_headers_t *hdrs, const char *name);\nrd_kafka_resp_err_t rd_kafka_header_get_last(const rd_kafka_headers_t *hdrs, const char *name, const void **valuep, size_t *sizep);\nrd_kafka_resp_err_t rd_kafka_header_get(const rd_kafka_headers_t *hdrs, size_t idx, const char *name, const void **valuep, size_t *sizep);\nrd_kafka_resp_err_t rd_kafka_header_get_all(const rd_kafka_headers_t *hdrs, size_t idx, const char **namep, const void **valuep, size_t *sizep);\ntypedef struct rd_kafka_message_s {\n  rd_kafka_resp_err_t err;\n  rd_kafka_topic_t *rkt;\n  int32_t partition;\n  void *payload;\n  size_t len;\n  void *key;\n  size_t key_len;\n  int64_t offset;\n  void *_private;\n} rd_kafka_message_t;\nvoid rd_kafka_message_destroy(rd_kafka_message_t *rkmessage);\nconst char *rd_kafka_message_errstr(const rd_kafka_message_t *rkmessage);\nint64_t rd_kafka_message_timestamp(const rd_kafka_message_t *rkmessage, rd_kafka_timestamp_type_t *tstype);\nint64_t rd_kafka_message_latency(const rd_kafka_message_t *rkmessage);\nint32_t rd_kafka_message_broker_id(const rd_kafka_message_t *rkmessage);\nrd_kafka_resp_err_t rd_kafka_message_headers(const rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);\nrd_kafka_resp_err_t rd_kafka_message_detach_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);\nvoid rd_kafka_message_set_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t *hdrs);\nsize_t rd_kafka_header_cnt(const rd_kafka_headers_t *hdrs);\ntypedef enum {\n  RD_KAFKA_MSG_STATUS_NOT_PERSISTED = 0,\n  RD_KAFKA_MSG_STATUS_POSSIBLY_PERSISTED = 1,\n  RD_KAFKA_MSG_STATUS_PERSISTED = 2,\n} rd_kafka_msg_status_t;\nrd_kafka_msg_status_t rd_kafka_message_status(const rd_kafka_message_t *rkmessage);\ntypedef enum {\n  RD_KAFKA_CONF_UNKNOWN = (- 2),\n  RD_KAFKA_CONF_INVALID = (- 1),\n  RD_KAFKA_CONF_OK = 0,\n} rd_kafka_conf_res_t;\nrd_kafka_conf_t *rd_kafka_conf_new(void);\nvoid rd_kafka_conf_destroy(rd_kafka_conf_t *conf);\nrd_kafka_conf_t *rd_kafka_conf_dup(const rd_kafka_conf_t *conf);\nrd_kafka_conf_t *rd_kafka_conf_dup_filter(const rd_kafka_conf_t *conf, size_t filter_cnt, const char **filter);\nconst rd_kafka_conf_t *rd_kafka_conf(rd_kafka_t *rk);\nrd_kafka_conf_res_t rd_kafka_conf_set(rd_kafka_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);\nvoid rd_kafka_conf_set_events(rd_kafka_conf_t *conf, int events);\nvoid rd_kafka_conf_set_background_event_cb(rd_kafka_conf_t *conf, void (*event_cb)(rd_kafka_t *rk, rd_kafka_event_t *rkev, void *opaque));\nvoid rd_kafka_conf_set_dr_cb(rd_kafka_conf_t *conf, void (*dr_cb)(rd_kafka_t *rk, void *payload, size_t len, rd_kafka_resp_err_t err, void *opaque, void *msg_opaque));\nvoid rd_kafka_conf_set_dr_msg_cb(rd_kafka_conf_t *conf, void (*dr_msg_cb)(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, void *opaque));\nvoid rd_kafka_conf_set_consume_cb(rd_kafka_conf_t *conf, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *opaque));\nvoid rd_kafka_conf_set_rebalance_cb(rd_kafka_conf_t *conf, void (*rebalance_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *partitions, void *opaque));\nvoid rd_kafka_conf_set_offset_commit_cb(rd_kafka_conf_t *conf, void (*offset_commit_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *opaque));\nvoid rd_kafka_conf_set_error_cb(rd_kafka_conf_t *conf, void (*error_cb)(rd_kafka_t *rk, int err, const char *reason, void *opaque));\nvoid rd_kafka_conf_set_throttle_cb(rd_kafka_conf_t *conf, void (*throttle_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int throttle_time_ms, void *opaque));\nvoid rd_kafka_conf_set_log_cb(rd_kafka_conf_t *conf, void (*log_cb)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));\nvoid rd_kafka_conf_set_stats_cb(rd_kafka_conf_t *conf, int (*stats_cb)(rd_kafka_t *rk, char *json, size_t json_len, void *opaque));\nvoid rd_kafka_conf_set_oauthbearer_token_refresh_cb(rd_kafka_conf_t *conf, void (*oauthbearer_token_refresh_cb)(rd_kafka_t *rk, const char *oauthbearer_config, void *opaque));\nvoid rd_kafka_conf_set_socket_cb(rd_kafka_conf_t *conf, int (*socket_cb)(int domain, int type, int protocol, void *opaque));\nvoid rd_kafka_conf_set_connect_cb(rd_kafka_conf_t *conf, int (*connect_cb)(int sockfd, const struct sockaddr *addr, int addrlen, const char *id, void *opaque));\nvoid rd_kafka_conf_set_closesocket_cb(rd_kafka_conf_t *conf, int (*closesocket_cb)(int sockfd, void *opaque));\nrd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert_verify_cb(rd_kafka_conf_t *conf, int (*ssl_cert_verify_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int *x509_error, int depth, const char *buf, size_t size, char *errstr, size_t errstr_size, void *opaque));\ntypedef enum rd_kafka_cert_type_t {\n  RD_KAFKA_CERT_PUBLIC_KEY,\n  RD_KAFKA_CERT_PRIVATE_KEY,\n  RD_KAFKA_CERT_CA,\n  RD_KAFKA_CERT__CNT,\n} rd_kafka_cert_type_t;\ntypedef enum rd_kafka_cert_enc_t {\n  RD_KAFKA_CERT_ENC_PKCS12,\n  RD_KAFKA_CERT_ENC_DER,\n  RD_KAFKA_CERT_ENC_PEM,\n  RD_KAFKA_CERT_ENC__CNT,\n} rd_kafka_cert_enc_t;\nrd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert(rd_kafka_conf_t *conf, rd_kafka_cert_type_t cert_type, rd_kafka_cert_enc_t cert_enc, const void *buffer, size_t size, char *errstr, size_t errstr_size);\nvoid rd_kafka_conf_set_engine_callback_data(rd_kafka_conf_t *conf, void *callback_data);\nvoid rd_kafka_conf_set_opaque(rd_kafka_conf_t *conf, void *opaque);\nvoid *rd_kafka_opaque(const rd_kafka_t *rk);\nvoid rd_kafka_conf_set_default_topic_conf(rd_kafka_conf_t *conf, rd_kafka_topic_conf_t *tconf);\nrd_kafka_topic_conf_t *rd_kafka_conf_get_default_topic_conf(rd_kafka_conf_t *conf);\nrd_kafka_conf_res_t rd_kafka_conf_get(const rd_kafka_conf_t *conf, const char *name, char *dest, size_t *dest_size);\nrd_kafka_conf_res_t rd_kafka_topic_conf_get(const rd_kafka_topic_conf_t *conf, const char *name, char *dest, size_t *dest_size);\nconst char **rd_kafka_conf_dump(rd_kafka_conf_t *conf, size_t *cntp);\nconst char **rd_kafka_topic_conf_dump(rd_kafka_topic_conf_t *conf, size_t *cntp);\nvoid rd_kafka_conf_dump_free(const char **arr, size_t cnt);\nvoid rd_kafka_conf_properties_show(FILE *fp);\nrd_kafka_topic_conf_t *rd_kafka_topic_conf_new(void);\nrd_kafka_topic_conf_t *rd_kafka_topic_conf_dup(const rd_kafka_topic_conf_t *conf);\nrd_kafka_topic_conf_t *rd_kafka_default_topic_conf_dup(rd_kafka_t *rk);\nvoid rd_kafka_topic_conf_destroy(rd_kafka_topic_conf_t *topic_conf);\nrd_kafka_conf_res_t rd_kafka_topic_conf_set(rd_kafka_topic_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);\nvoid rd_kafka_topic_conf_set_opaque(rd_kafka_topic_conf_t *conf, void *rkt_opaque);\nvoid rd_kafka_topic_conf_set_partitioner_cb(rd_kafka_topic_conf_t *topic_conf, int32_t (*partitioner)(const rd_kafka_topic_t *rkt, const void *keydata, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque));\nvoid rd_kafka_topic_conf_set_msg_order_cmp(rd_kafka_topic_conf_t *topic_conf, int (*msg_order_cmp)(const rd_kafka_message_t *a, const rd_kafka_message_t *b));\nint rd_kafka_topic_partition_available(const rd_kafka_topic_t *rkt, int32_t partition);\nint32_t rd_kafka_msg_partitioner_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_consistent(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_consistent_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_murmur2(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_murmur2_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_fnv1a(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_fnv1a_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nrd_kafka_t *rd_kafka_new(rd_kafka_type_t type, rd_kafka_conf_t *conf, char *errstr, size_t errstr_size);\nvoid rd_kafka_destroy(rd_kafka_t *rk);\nvoid rd_kafka_destroy_flags(rd_kafka_t *rk, int flags);\nconst char *rd_kafka_name(const rd_kafka_t *rk);\nrd_kafka_type_t rd_kafka_type(const rd_kafka_t *rk);\nchar *rd_kafka_memberid(const rd_kafka_t *rk);\nchar *rd_kafka_clusterid(rd_kafka_t *rk, int timeout_ms);\nint32_t rd_kafka_controllerid(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_topic_t *rd_kafka_topic_new(rd_kafka_t *rk, const char *topic, rd_kafka_topic_conf_t *conf);\nvoid rd_kafka_topic_destroy(rd_kafka_topic_t *rkt);\nconst char *rd_kafka_topic_name(const rd_kafka_topic_t *rkt);\nvoid *rd_kafka_topic_opaque(const rd_kafka_topic_t *rkt);\nint rd_kafka_poll(rd_kafka_t *rk, int timeout_ms);\nvoid rd_kafka_yield(rd_kafka_t *rk);\nrd_kafka_resp_err_t rd_kafka_pause_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_resp_err_t rd_kafka_resume_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_resp_err_t rd_kafka_query_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high, int timeout_ms);\nrd_kafka_resp_err_t rd_kafka_get_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high);\nrd_kafka_resp_err_t rd_kafka_offsets_for_times(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets, int timeout_ms);\nvoid *rd_kafka_mem_calloc(rd_kafka_t *rk, size_t num, size_t size);\nvoid *rd_kafka_mem_malloc(rd_kafka_t *rk, size_t size);\nvoid rd_kafka_mem_free(rd_kafka_t *rk, void *ptr);\nrd_kafka_queue_t *rd_kafka_queue_new(rd_kafka_t *rk);\nvoid rd_kafka_queue_destroy(rd_kafka_queue_t *rkqu);\nrd_kafka_queue_t *rd_kafka_queue_get_main(rd_kafka_t *rk);\nrd_kafka_queue_t *rd_kafka_queue_get_consumer(rd_kafka_t *rk);\nrd_kafka_queue_t *rd_kafka_queue_get_partition(rd_kafka_t *rk, const char *topic, int32_t partition);\nrd_kafka_queue_t *rd_kafka_queue_get_background(rd_kafka_t *rk);\nvoid rd_kafka_queue_forward(rd_kafka_queue_t *src, rd_kafka_queue_t *dst);\nrd_kafka_resp_err_t rd_kafka_set_log_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu);\nsize_t rd_kafka_queue_length(rd_kafka_queue_t *rkqu);\nvoid rd_kafka_queue_io_event_enable(rd_kafka_queue_t *rkqu, int fd, const void *payload, size_t size);\nvoid rd_kafka_queue_cb_event_enable(rd_kafka_queue_t *rkqu, void (*event_cb)(rd_kafka_t *rk, void *qev_opaque), void *qev_opaque);\nvoid rd_kafka_queue_yield(rd_kafka_queue_t *rkqu);\nint rd_kafka_consume_start(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);\nint rd_kafka_consume_start_queue(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, rd_kafka_queue_t *rkqu);\nint rd_kafka_consume_stop(rd_kafka_topic_t *rkt, int32_t partition);\nrd_kafka_resp_err_t rd_kafka_seek(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, int timeout_ms);\nrd_kafka_error_t *rd_kafka_seek_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms);\nrd_kafka_message_t *rd_kafka_consume(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms);\nssize_t rd_kafka_consume_batch(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);\nint rd_kafka_consume_callback(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);\nrd_kafka_message_t *rd_kafka_consume_queue(rd_kafka_queue_t *rkqu, int timeout_ms);\nssize_t rd_kafka_consume_batch_queue(rd_kafka_queue_t *rkqu, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);\nint rd_kafka_consume_callback_queue(rd_kafka_queue_t *rkqu, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);\nrd_kafka_resp_err_t rd_kafka_offset_store(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);\nrd_kafka_resp_err_t rd_kafka_offsets_store(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets);\nrd_kafka_resp_err_t rd_kafka_subscribe(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *topics);\nrd_kafka_resp_err_t rd_kafka_unsubscribe(rd_kafka_t *rk);\nrd_kafka_resp_err_t rd_kafka_subscription(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **topics);\nrd_kafka_message_t *rd_kafka_consumer_poll(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_resp_err_t rd_kafka_consumer_close(rd_kafka_t *rk);\nrd_kafka_error_t *rd_kafka_incremental_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_error_t *rd_kafka_incremental_unassign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);\nconst char *rd_kafka_rebalance_protocol(rd_kafka_t *rk);\nrd_kafka_resp_err_t rd_kafka_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_resp_err_t rd_kafka_assignment(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **partitions);\nint rd_kafka_assignment_lost(rd_kafka_t *rk);\nrd_kafka_resp_err_t rd_kafka_commit(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, int async);\nrd_kafka_resp_err_t rd_kafka_commit_message(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, int async);\nrd_kafka_resp_err_t rd_kafka_commit_queue(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_queue_t *rkqu, void (*cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *commit_opaque), void *commit_opaque);\nrd_kafka_resp_err_t rd_kafka_committed(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms);\nrd_kafka_resp_err_t rd_kafka_position(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata(rd_kafka_t *rk);\nrd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata_new(const char *group_id);\nrd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata_new_with_genid(const char *group_id, int32_t generation_id, const char *member_id, const char *group_instance_id);\nvoid rd_kafka_consumer_group_metadata_destroy(rd_kafka_consumer_group_metadata_t *);\nrd_kafka_error_t *rd_kafka_consumer_group_metadata_write(const rd_kafka_consumer_group_metadata_t *cgmd, void **bufferp, size_t *sizep);\nrd_kafka_error_t *rd_kafka_consumer_group_metadata_read(rd_kafka_consumer_group_metadata_t **cgmdp, const void *buffer, size_t size);\nint rd_kafka_produce(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, void *payload, size_t len, const void *key, size_t keylen, void *msg_opaque);\nrd_kafka_resp_err_t rd_kafka_producev(rd_kafka_t *rk, ...);\nrd_kafka_error_t *rd_kafka_produceva(rd_kafka_t *rk, const rd_kafka_vu_t *vus, size_t cnt);\nint rd_kafka_produce_batch(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, rd_kafka_message_t *rkmessages, int message_cnt);\nrd_kafka_resp_err_t rd_kafka_flush(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_resp_err_t rd_kafka_purge(rd_kafka_t *rk, int purge_flags);\ntypedef struct rd_kafka_metadata_broker {\n  int32_t id;\n  char *host;\n  int port;\n} rd_kafka_metadata_broker_t;\ntypedef struct rd_kafka_metadata_partition {\n  int32_t id;\n  rd_kafka_resp_err_t err;\n  int32_t leader;\n  int replica_cnt;\n  int32_t *replicas;\n  int isr_cnt;\n  int32_t *isrs;\n} rd_kafka_metadata_partition_t;\ntypedef struct rd_kafka_metadata_topic {\n  char *topic;\n  int partition_cnt;\n  struct rd_kafka_metadata_partition *partitions;\n  rd_kafka_resp_err_t err;\n} rd_kafka_metadata_topic_t;\ntypedef struct rd_kafka_metadata {\n  int broker_cnt;\n  struct rd_kafka_metadata_broker *brokers;\n  int topic_cnt;\n  struct rd_kafka_metadata_topic *topics;\n  int32_t orig_broker_id;\n  char *orig_broker_name;\n} rd_kafka_metadata_t;\nrd_kafka_resp_err_t rd_kafka_metadata(rd_kafka_t *rk, int all_topics, rd_kafka_topic_t *only_rkt, const struct rd_kafka_metadata **metadatap, int timeout_ms);\nvoid rd_kafka_metadata_destroy(const struct rd_kafka_metadata *metadata);\nstruct rd_kafka_group_member_info {\n  char *member_id;\n  char *client_id;\n  char *client_host;\n  void *member_metadata;\n  int member_metadata_size;\n  void *member_assignment;\n  int member_assignment_size;\n};\nstruct rd_kafka_group_info {\n  struct rd_kafka_metadata_broker broker;\n  char *group;\n  rd_kafka_resp_err_t err;\n  char *state;\n  char *protocol_type;\n  char *protocol;\n  struct rd_kafka_group_member_info *members;\n  int member_cnt;\n};\nstruct rd_kafka_group_list {\n  struct rd_kafka_group_info *groups;\n  int group_cnt;\n};\nrd_kafka_resp_err_t rd_kafka_list_groups(rd_kafka_t *rk, const char *group, const struct rd_kafka_group_list **grplistp, int timeout_ms);\nvoid rd_kafka_group_list_destroy(const struct rd_kafka_group_list *grplist);\nint rd_kafka_brokers_add(rd_kafka_t *rk, const char *brokerlist);\nvoid rd_kafka_set_logger(rd_kafka_t *rk, void (*func)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));\nvoid rd_kafka_set_log_level(rd_kafka_t *rk, int level);\nvoid rd_kafka_log_print(const rd_kafka_t *rk, int level, const char *fac, const char *buf);\nvoid rd_kafka_log_syslog(const rd_kafka_t *rk, int level, const char *fac, const char *buf);\nint rd_kafka_outq_len(rd_kafka_t *rk);\nvoid rd_kafka_dump(FILE *fp, rd_kafka_t *rk);\nint rd_kafka_thread_cnt(void);\ntypedef enum rd_kafka_thread_type_t {\n  RD_KAFKA_THREAD_MAIN,\n  RD_KAFKA_THREAD_BACKGROUND,\n  RD_KAFKA_THREAD_BROKER,\n} rd_kafka_thread_type_t;\nint rd_kafka_wait_destroyed(int timeout_ms);\nint rd_kafka_unittest(void);\nrd_kafka_resp_err_t rd_kafka_poll_set_consumer(rd_kafka_t *rk);\ntypedef int rd_kafka_event_type_t;\nrd_kafka_event_type_t rd_kafka_event_type(const rd_kafka_event_t *rkev);\nconst char *rd_kafka_event_name(const rd_kafka_event_t *rkev);\nvoid rd_kafka_event_destroy(rd_kafka_event_t *rkev);\nconst rd_kafka_message_t *rd_kafka_event_message_next(rd_kafka_event_t *rkev);\nsize_t rd_kafka_event_message_array(rd_kafka_event_t *rkev, const rd_kafka_message_t **rkmessages, size_t size);\nsize_t rd_kafka_event_message_count(rd_kafka_event_t *rkev);\nconst char *rd_kafka_event_config_string(rd_kafka_event_t *rkev);\nrd_kafka_resp_err_t rd_kafka_event_error(rd_kafka_event_t *rkev);\nconst char *rd_kafka_event_error_string(rd_kafka_event_t *rkev);\nint rd_kafka_event_error_is_fatal(rd_kafka_event_t *rkev);\nvoid *rd_kafka_event_opaque(rd_kafka_event_t *rkev);\nint rd_kafka_event_log(rd_kafka_event_t *rkev, const char **fac, const char **str, int *level);\nint rd_kafka_event_debug_contexts(rd_kafka_event_t *rkev, char *dst, size_t dstsize);\nconst char *rd_kafka_event_stats(rd_kafka_event_t *rkev);\nrd_kafka_topic_partition_list_t *rd_kafka_event_topic_partition_list(rd_kafka_event_t *rkev);\nrd_kafka_topic_partition_t *rd_kafka_event_topic_partition(rd_kafka_event_t *rkev);\ntypedef rd_kafka_event_t rd_kafka_CreateTopics_result_t;\ntypedef rd_kafka_event_t rd_kafka_DeleteTopics_result_t;\ntypedef rd_kafka_event_t rd_kafka_CreatePartitions_result_t;\ntypedef rd_kafka_event_t rd_kafka_AlterConfigs_result_t;\ntypedef rd_kafka_event_t rd_kafka_DescribeConfigs_result_t;\ntypedef rd_kafka_event_t rd_kafka_DeleteRecords_result_t;\ntypedef rd_kafka_event_t rd_kafka_DeleteGroups_result_t;\ntypedef rd_kafka_event_t rd_kafka_DeleteConsumerGroupOffsets_result_t;\nconst rd_kafka_CreateTopics_result_t *rd_kafka_event_CreateTopics_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DeleteTopics_result_t *rd_kafka_event_DeleteTopics_result(rd_kafka_event_t *rkev);\nconst rd_kafka_CreatePartitions_result_t *rd_kafka_event_CreatePartitions_result(rd_kafka_event_t *rkev);\nconst rd_kafka_AlterConfigs_result_t *rd_kafka_event_AlterConfigs_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DescribeConfigs_result_t *rd_kafka_event_DescribeConfigs_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DeleteRecords_result_t *rd_kafka_event_DeleteRecords_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DeleteGroups_result_t *rd_kafka_event_DeleteGroups_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DeleteConsumerGroupOffsets_result_t *rd_kafka_event_DeleteConsumerGroupOffsets_result(rd_kafka_event_t *rkev);\nrd_kafka_event_t *rd_kafka_queue_poll(rd_kafka_queue_t *rkqu, int timeout_ms);\nint rd_kafka_queue_poll_callback(rd_kafka_queue_t *rkqu, int timeout_ms);\ntypedef rd_kafka_resp_err_t (rd_kafka_plugin_f_conf_init_t)(rd_kafka_conf_t *conf, void **plug_opaquep, char *errstr, size_t errstr_size);\ntypedef rd_kafka_conf_res_t (rd_kafka_interceptor_f_on_conf_set_t)(rd_kafka_conf_t *conf, const char *name, const char *val, char *errstr, size_t errstr_size, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_dup_t)(rd_kafka_conf_t *new_conf, const rd_kafka_conf_t *old_conf, size_t filter_cnt, const char **filter, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_destroy_t)(void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_new_t)(rd_kafka_t *rk, const rd_kafka_conf_t *conf, void *ic_opaque, char *errstr, size_t errstr_size);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_destroy_t)(rd_kafka_t *rk, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_send_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_acknowledgement_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_consume_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_commit_t)(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_resp_err_t err, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_request_sent_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_response_received_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, int64_t rtt, rd_kafka_resp_err_t err, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_start_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_exit_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_set(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_set_t *on_conf_set, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_dup(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_dup_t *on_conf_dup, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_destroy(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_destroy_t *on_conf_destroy, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_new(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_new_t *on_new, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_destroy(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_destroy_t *on_destroy, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_send(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_send_t *on_send, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_acknowledgement(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_acknowledgement_t *on_acknowledgement, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_consume(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_consume_t *on_consume, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_commit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_commit_t *on_commit, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_request_sent(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_request_sent_t *on_request_sent, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_response_received(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_response_received_t *on_response_received, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_start(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_start_t *on_thread_start, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_exit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_exit_t *on_thread_exit, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_topic_result_error(const rd_kafka_topic_result_t *topicres);\nconst char *rd_kafka_topic_result_error_string(const rd_kafka_topic_result_t *topicres);\nconst char *rd_kafka_topic_result_name(const rd_kafka_topic_result_t *topicres);\nconst rd_kafka_error_t *rd_kafka_group_result_error(const rd_kafka_group_result_t *groupres);\nconst char *rd_kafka_group_result_name(const rd_kafka_group_result_t *groupres);\nconst rd_kafka_topic_partition_list_t *rd_kafka_group_result_partitions(const rd_kafka_group_result_t *groupres);\ntypedef enum rd_kafka_admin_op_t {\n  RD_KAFKA_ADMIN_OP_ANY = 0,\n  RD_KAFKA_ADMIN_OP_CREATETOPICS,\n  RD_KAFKA_ADMIN_OP_DELETETOPICS,\n  RD_KAFKA_ADMIN_OP_CREATEPARTITIONS,\n  RD_KAFKA_ADMIN_OP_ALTERCONFIGS,\n  RD_KAFKA_ADMIN_OP_DESCRIBECONFIGS,\n  RD_KAFKA_ADMIN_OP_DELETERECORDS,\n  RD_KAFKA_ADMIN_OP_DELETEGROUPS,\n  RD_KAFKA_ADMIN_OP_DELETECONSUMERGROUPOFFSETS,\n  RD_KAFKA_ADMIN_OP__CNT,\n} rd_kafka_admin_op_t;\ntypedef struct rd_kafka_AdminOptions_s rd_kafka_AdminOptions_t;\nrd_kafka_AdminOptions_t *rd_kafka_AdminOptions_new(rd_kafka_t *rk, rd_kafka_admin_op_t for_api);\nvoid rd_kafka_AdminOptions_destroy(rd_kafka_AdminOptions_t *options);\nrd_kafka_resp_err_t rd_kafka_AdminOptions_set_request_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_AdminOptions_set_operation_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_AdminOptions_set_validate_only(rd_kafka_AdminOptions_t *options, int true_or_false, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_AdminOptions_set_broker(rd_kafka_AdminOptions_t *options, int32_t broker_id, char *errstr, size_t errstr_size);\nvoid rd_kafka_AdminOptions_set_opaque(rd_kafka_AdminOptions_t *options, void *ev_opaque);\ntypedef struct rd_kafka_NewTopic_s rd_kafka_NewTopic_t;\nrd_kafka_NewTopic_t *rd_kafka_NewTopic_new(const char *topic, int num_partitions, int replication_factor, char *errstr, size_t errstr_size);\nvoid rd_kafka_NewTopic_destroy(rd_kafka_NewTopic_t *new_topic);\nvoid rd_kafka_NewTopic_destroy_array(rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt);\nrd_kafka_resp_err_t rd_kafka_NewTopic_set_replica_assignment(rd_kafka_NewTopic_t *new_topic, int32_t partition, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_NewTopic_set_config(rd_kafka_NewTopic_t *new_topic, const char *name, const char *value);\nvoid rd_kafka_CreateTopics(rd_kafka_t *rk, rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_topic_result_t **rd_kafka_CreateTopics_result_topics(const rd_kafka_CreateTopics_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_DeleteTopic_s rd_kafka_DeleteTopic_t;\nrd_kafka_DeleteTopic_t *rd_kafka_DeleteTopic_new(const char *topic);\nvoid rd_kafka_DeleteTopic_destroy(rd_kafka_DeleteTopic_t *del_topic);\nvoid rd_kafka_DeleteTopic_destroy_array(rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt);\nvoid rd_kafka_DeleteTopics(rd_kafka_t *rk, rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_topic_result_t **rd_kafka_DeleteTopics_result_topics(const rd_kafka_DeleteTopics_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_NewPartitions_s rd_kafka_NewPartitions_t;\nrd_kafka_NewPartitions_t *rd_kafka_NewPartitions_new(const char *topic, size_t new_total_cnt, char *errstr, size_t errstr_size);\nvoid rd_kafka_NewPartitions_destroy(rd_kafka_NewPartitions_t *new_parts);\nvoid rd_kafka_NewPartitions_destroy_array(rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt);\nrd_kafka_resp_err_t rd_kafka_NewPartitions_set_replica_assignment(rd_kafka_NewPartitions_t *new_parts, int32_t new_partition_idx, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);\nvoid rd_kafka_CreatePartitions(rd_kafka_t *rk, rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_topic_result_t **rd_kafka_CreatePartitions_result_topics(const rd_kafka_CreatePartitions_result_t *result, size_t *cntp);\ntypedef enum rd_kafka_ConfigSource_t {\n  RD_KAFKA_CONFIG_SOURCE_UNKNOWN_CONFIG = 0,\n  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_TOPIC_CONFIG = 1,\n  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_BROKER_CONFIG = 2,\n  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_DEFAULT_BROKER_CONFIG = 3,\n  RD_KAFKA_CONFIG_SOURCE_STATIC_BROKER_CONFIG = 4,\n  RD_KAFKA_CONFIG_SOURCE_DEFAULT_CONFIG = 5,\n  RD_KAFKA_CONFIG_SOURCE__CNT,\n} rd_kafka_ConfigSource_t;\nconst char *rd_kafka_ConfigSource_name(rd_kafka_ConfigSource_t confsource);\ntypedef struct rd_kafka_ConfigEntry_s rd_kafka_ConfigEntry_t;\nconst char *rd_kafka_ConfigEntry_name(const rd_kafka_ConfigEntry_t *entry);\nconst char *rd_kafka_ConfigEntry_value(const rd_kafka_ConfigEntry_t *entry);\nrd_kafka_ConfigSource_t rd_kafka_ConfigEntry_source(const rd_kafka_ConfigEntry_t *entry);\nint rd_kafka_ConfigEntry_is_read_only(const rd_kafka_ConfigEntry_t *entry);\nint rd_kafka_ConfigEntry_is_default(const rd_kafka_ConfigEntry_t *entry);\nint rd_kafka_ConfigEntry_is_sensitive(const rd_kafka_ConfigEntry_t *entry);\nint rd_kafka_ConfigEntry_is_synonym(const rd_kafka_ConfigEntry_t *entry);\nconst rd_kafka_ConfigEntry_t **rd_kafka_ConfigEntry_synonyms(const rd_kafka_ConfigEntry_t *entry, size_t *cntp);\ntypedef enum rd_kafka_ResourceType_t {\n  RD_KAFKA_RESOURCE_UNKNOWN = 0,\n  RD_KAFKA_RESOURCE_ANY = 1,\n  RD_KAFKA_RESOURCE_TOPIC = 2,\n  RD_KAFKA_RESOURCE_GROUP = 3,\n  RD_KAFKA_RESOURCE_BROKER = 4,\n  RD_KAFKA_RESOURCE__CNT,\n} rd_kafka_ResourceType_t;\nconst char *rd_kafka_ResourceType_name(rd_kafka_ResourceType_t restype);\ntypedef struct rd_kafka_ConfigResource_s rd_kafka_ConfigResource_t;\nrd_kafka_ConfigResource_t *rd_kafka_ConfigResource_new(rd_kafka_ResourceType_t restype, const char *resname);\nvoid rd_kafka_ConfigResource_destroy(rd_kafka_ConfigResource_t *config);\nvoid rd_kafka_ConfigResource_destroy_array(rd_kafka_ConfigResource_t **config, size_t config_cnt);\nrd_kafka_resp_err_t rd_kafka_ConfigResource_set_config(rd_kafka_ConfigResource_t *config, const char *name, const char *value);\nconst rd_kafka_ConfigEntry_t **rd_kafka_ConfigResource_configs(const rd_kafka_ConfigResource_t *config, size_t *cntp);\nrd_kafka_ResourceType_t rd_kafka_ConfigResource_type(const rd_kafka_ConfigResource_t *config);\nconst char *rd_kafka_ConfigResource_name(const rd_kafka_ConfigResource_t *config);\nrd_kafka_resp_err_t rd_kafka_ConfigResource_error(const rd_kafka_ConfigResource_t *config);\nconst char *rd_kafka_ConfigResource_error_string(const rd_kafka_ConfigResource_t *config);\nvoid rd_kafka_AlterConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_ConfigResource_t **rd_kafka_AlterConfigs_result_resources(const rd_kafka_AlterConfigs_result_t *result, size_t *cntp);\nvoid rd_kafka_DescribeConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_ConfigResource_t **rd_kafka_DescribeConfigs_result_resources(const rd_kafka_DescribeConfigs_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_DeleteRecords_s rd_kafka_DeleteRecords_t;\nrd_kafka_DeleteRecords_t *rd_kafka_DeleteRecords_new(const rd_kafka_topic_partition_list_t *before_offsets);\nvoid rd_kafka_DeleteRecords_destroy(rd_kafka_DeleteRecords_t *del_records);\nvoid rd_kafka_DeleteRecords_destroy_array(rd_kafka_DeleteRecords_t **del_records, size_t del_record_cnt);\nvoid rd_kafka_DeleteRecords(rd_kafka_t *rk, rd_kafka_DeleteRecords_t **del_records, size_t del_record_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_topic_partition_list_t *rd_kafka_DeleteRecords_result_offsets(const rd_kafka_DeleteRecords_result_t *result);\ntypedef struct rd_kafka_DeleteGroup_s rd_kafka_DeleteGroup_t;\nrd_kafka_DeleteGroup_t *rd_kafka_DeleteGroup_new(const char *group);\nvoid rd_kafka_DeleteGroup_destroy(rd_kafka_DeleteGroup_t *del_group);\nvoid rd_kafka_DeleteGroup_destroy_array(rd_kafka_DeleteGroup_t **del_groups, size_t del_group_cnt);\nvoid rd_kafka_DeleteGroups(rd_kafka_t *rk, rd_kafka_DeleteGroup_t **del_groups, size_t del_group_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_group_result_t **rd_kafka_DeleteGroups_result_groups(const rd_kafka_DeleteGroups_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_DeleteConsumerGroupOffsets_s rd_kafka_DeleteConsumerGroupOffsets_t;\nrd_kafka_DeleteConsumerGroupOffsets_t *rd_kafka_DeleteConsumerGroupOffsets_new(const char *group, const rd_kafka_topic_partition_list_t *partitions);\nvoid rd_kafka_DeleteConsumerGroupOffsets_destroy(rd_kafka_DeleteConsumerGroupOffsets_t *del_grpoffsets);\nvoid rd_kafka_DeleteConsumerGroupOffsets_destroy_array(rd_kafka_DeleteConsumerGroupOffsets_t **del_grpoffsets, size_t del_grpoffset_cnt);\nvoid rd_kafka_DeleteConsumerGroupOffsets(rd_kafka_t *rk, rd_kafka_DeleteConsumerGroupOffsets_t **del_grpoffsets, size_t del_grpoffsets_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_group_result_t **rd_kafka_DeleteConsumerGroupOffsets_result_groups(const rd_kafka_DeleteConsumerGroupOffsets_result_t *result, size_t *cntp);\nrd_kafka_resp_err_t rd_kafka_oauthbearer_set_token(rd_kafka_t *rk, const char *token_value, int64_t md_lifetime_ms, const char *md_principal_name, const char **extensions, size_t extension_size, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_oauthbearer_set_token_failure(rd_kafka_t *rk, const char *errstr);\nrd_kafka_error_t *rd_kafka_init_transactions(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_error_t *rd_kafka_begin_transaction(rd_kafka_t *rk);\nrd_kafka_error_t *rd_kafka_send_offsets_to_transaction(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, const rd_kafka_consumer_group_metadata_t *cgmetadata, int timeout_ms);\nrd_kafka_error_t *rd_kafka_commit_transaction(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_error_t *rd_kafka_abort_transaction(rd_kafka_t *rk, int timeout_ms);\ntypedef struct rd_kafka_mock_cluster_s rd_kafka_mock_cluster_t;\nrd_kafka_mock_cluster_t *rd_kafka_mock_cluster_new(rd_kafka_t *rk, int broker_cnt);\nvoid rd_kafka_mock_cluster_destroy(rd_kafka_mock_cluster_t *mcluster);\nrd_kafka_t *rd_kafka_mock_cluster_handle(const rd_kafka_mock_cluster_t *mcluster);\nrd_kafka_mock_cluster_t *rd_kafka_handle_mock_cluster(const rd_kafka_t *rk);\nconst char *rd_kafka_mock_cluster_bootstraps(const rd_kafka_mock_cluster_t *mcluster);\nvoid rd_kafka_mock_clear_request_errors(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey);\nvoid rd_kafka_mock_push_request_errors(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, size_t cnt, ...);\nvoid rd_kafka_mock_push_request_errors_array(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, size_t cnt, const rd_kafka_resp_err_t *errors);\nrd_kafka_resp_err_t rd_kafka_mock_broker_push_request_error_rtts(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int16_t ApiKey, size_t cnt, ...);\nvoid rd_kafka_mock_topic_set_error(rd_kafka_mock_cluster_t *mcluster, const char *topic, rd_kafka_resp_err_t err);\nrd_kafka_resp_err_t rd_kafka_mock_topic_create(rd_kafka_mock_cluster_t *mcluster, const char *topic, int partition_cnt, int replication_factor);\nrd_kafka_resp_err_t rd_kafka_mock_partition_set_leader(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id);\nrd_kafka_resp_err_t rd_kafka_mock_partition_set_follower(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id);\nrd_kafka_resp_err_t rd_kafka_mock_partition_set_follower_wmarks(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int64_t lo, int64_t hi);\nrd_kafka_resp_err_t rd_kafka_mock_broker_set_down(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id);\nrd_kafka_resp_err_t rd_kafka_mock_broker_set_up(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id);\nrd_kafka_resp_err_t rd_kafka_mock_broker_set_rtt(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int rtt_ms);\nrd_kafka_resp_err_t rd_kafka_mock_broker_set_rack(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, const char *rack);\nrd_kafka_resp_err_t rd_kafka_mock_coordinator_set(rd_kafka_mock_cluster_t *mcluster, const char *key_type, const char *key, int32_t broker_id);\nrd_kafka_resp_err_t rd_kafka_mock_set_apiversion(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, int16_t MinVersion, int16_t MaxVersion);\n'\n</code></pre> rdkafka.h, rdkafka_mock.h</p>"},{"location":"api/constants/#rd_kafka_version_18","title":"RD_KAFKA_VERSION","text":"<pre><code>public RD_KAFKA_VERSION = 17302271\n</code></pre> <p>librdkafka version </p> <p>Interpreted as hex <code>MM.mm.rr.xx</code>:</p> <ul> <li>MM = Major</li> <li>mm = minor</li> <li>rr = revision</li> <li>xx = pre-release id (0xff is the final release)</li> </ul> <p>E.g.: <code>0x000801ff</code> = 0.8.1</p> RemarksThis value should only be used during compile time, for runtime checks of version use rd_kafka_version()  <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_unsupported_compression_type_18","title":"RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE","text":"<pre><code>public RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76\n</code></pre> <p>Unsupported compression type </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_end_all_18","title":"RD_KAFKA_RESP_ERR_END_ALL","text":"<p><pre><code>public RD_KAFKA_RESP_ERR_END_ALL = 98\n</code></pre> enum rd_kafka_resp_err_t</p>"},{"location":"api/constants/#rd_kafka_admin_op__cnt_18","title":"RD_KAFKA_ADMIN_OP__CNT","text":"<pre><code>public RD_KAFKA_ADMIN_OP__CNT = 9\n</code></pre> <p>Number of ops defined </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe </li> </ul>"},{"location":"api/constants/#rd_kafka_resource__cnt_18","title":"RD_KAFKA_RESOURCE__CNT","text":"<pre><code>public RD_KAFKA_RESOURCE__CNT = 5\n</code></pre> <p>Number of resource types defined </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#acca83a66d7783ff7683ed2691cc907c9 </li> </ul>"},{"location":"api/constants/#rd_kafka_cdef_18","title":"RD_KAFKA_CDEF","text":"<p><pre><code>public RD_KAFKA_CDEF = 'typedef long int ssize_t;\ntypedef struct _IO_FILE FILE;\ntypedef long int mode_t;\ntypedef signed int int16_t;\ntypedef unsigned int uint16_t;\ntypedef signed int int32_t;\ntypedef signed long int int64_t;\nint rd_kafka_version(void);\nconst char *rd_kafka_version_str(void);\ntypedef enum rd_kafka_type_t {\n  RD_KAFKA_PRODUCER,\n  RD_KAFKA_CONSUMER,\n} rd_kafka_type_t;\ntypedef enum rd_kafka_timestamp_type_t {\n  RD_KAFKA_TIMESTAMP_NOT_AVAILABLE,\n  RD_KAFKA_TIMESTAMP_CREATE_TIME,\n  RD_KAFKA_TIMESTAMP_LOG_APPEND_TIME,\n} rd_kafka_timestamp_type_t;\nconst char *rd_kafka_get_debug_contexts(void);\ntypedef struct rd_kafka_s rd_kafka_t;\ntypedef struct rd_kafka_topic_s rd_kafka_topic_t;\ntypedef struct rd_kafka_conf_s rd_kafka_conf_t;\ntypedef struct rd_kafka_topic_conf_s rd_kafka_topic_conf_t;\ntypedef struct rd_kafka_queue_s rd_kafka_queue_t;\ntypedef struct rd_kafka_op_s rd_kafka_event_t;\ntypedef struct rd_kafka_topic_result_s rd_kafka_topic_result_t;\ntypedef struct rd_kafka_consumer_group_metadata_s rd_kafka_consumer_group_metadata_t;\ntypedef struct rd_kafka_error_s {\n  unsigned int code;\n  char *errstr;\n  unsigned char fatal;\n  unsigned char retriable;\n  unsigned char txn_requires_abort;\n} rd_kafka_error_t;\ntypedef struct rd_kafka_headers_s rd_kafka_headers_t;\ntypedef struct rd_kafka_group_result_s rd_kafka_group_result_t;\ntypedef enum {\n  RD_KAFKA_RESP_ERR__BEGIN = (- 200),\n  RD_KAFKA_RESP_ERR__BAD_MSG = (- 199),\n  RD_KAFKA_RESP_ERR__BAD_COMPRESSION = (- 198),\n  RD_KAFKA_RESP_ERR__DESTROY = (- 197),\n  RD_KAFKA_RESP_ERR__FAIL = (- 196),\n  RD_KAFKA_RESP_ERR__TRANSPORT = (- 195),\n  RD_KAFKA_RESP_ERR__CRIT_SYS_RESOURCE = (- 194),\n  RD_KAFKA_RESP_ERR__RESOLVE = (- 193),\n  RD_KAFKA_RESP_ERR__MSG_TIMED_OUT = (- 192),\n  RD_KAFKA_RESP_ERR__PARTITION_EOF = (- 191),\n  RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION = (- 190),\n  RD_KAFKA_RESP_ERR__FS = (- 189),\n  RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC = (- 188),\n  RD_KAFKA_RESP_ERR__ALL_BROKERS_DOWN = (- 187),\n  RD_KAFKA_RESP_ERR__INVALID_ARG = (- 186),\n  RD_KAFKA_RESP_ERR__TIMED_OUT = (- 185),\n  RD_KAFKA_RESP_ERR__QUEUE_FULL = (- 184),\n  RD_KAFKA_RESP_ERR__ISR_INSUFF = (- 183),\n  RD_KAFKA_RESP_ERR__NODE_UPDATE = (- 182),\n  RD_KAFKA_RESP_ERR__SSL = (- 181),\n  RD_KAFKA_RESP_ERR__WAIT_COORD = (- 180),\n  RD_KAFKA_RESP_ERR__UNKNOWN_GROUP = (- 179),\n  RD_KAFKA_RESP_ERR__IN_PROGRESS = (- 178),\n  RD_KAFKA_RESP_ERR__PREV_IN_PROGRESS = (- 177),\n  RD_KAFKA_RESP_ERR__EXISTING_SUBSCRIPTION = (- 176),\n  RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS = (- 175),\n  RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS = (- 174),\n  RD_KAFKA_RESP_ERR__CONFLICT = (- 173),\n  RD_KAFKA_RESP_ERR__STATE = (- 172),\n  RD_KAFKA_RESP_ERR__UNKNOWN_PROTOCOL = (- 171),\n  RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED = (- 170),\n  RD_KAFKA_RESP_ERR__AUTHENTICATION = (- 169),\n  RD_KAFKA_RESP_ERR__NO_OFFSET = (- 168),\n  RD_KAFKA_RESP_ERR__OUTDATED = (- 167),\n  RD_KAFKA_RESP_ERR__TIMED_OUT_QUEUE = (- 166),\n  RD_KAFKA_RESP_ERR__UNSUPPORTED_FEATURE = (- 165),\n  RD_KAFKA_RESP_ERR__WAIT_CACHE = (- 164),\n  RD_KAFKA_RESP_ERR__INTR = (- 163),\n  RD_KAFKA_RESP_ERR__KEY_SERIALIZATION = (- 162),\n  RD_KAFKA_RESP_ERR__VALUE_SERIALIZATION = (- 161),\n  RD_KAFKA_RESP_ERR__KEY_DESERIALIZATION = (- 160),\n  RD_KAFKA_RESP_ERR__VALUE_DESERIALIZATION = (- 159),\n  RD_KAFKA_RESP_ERR__PARTIAL = (- 158),\n  RD_KAFKA_RESP_ERR__READ_ONLY = (- 157),\n  RD_KAFKA_RESP_ERR__NOENT = (- 156),\n  RD_KAFKA_RESP_ERR__UNDERFLOW = (- 155),\n  RD_KAFKA_RESP_ERR__INVALID_TYPE = (- 154),\n  RD_KAFKA_RESP_ERR__RETRY = (- 153),\n  RD_KAFKA_RESP_ERR__PURGE_QUEUE = (- 152),\n  RD_KAFKA_RESP_ERR__PURGE_INFLIGHT = (- 151),\n  RD_KAFKA_RESP_ERR__FATAL = (- 150),\n  RD_KAFKA_RESP_ERR__INCONSISTENT = (- 149),\n  RD_KAFKA_RESP_ERR__GAPLESS_GUARANTEE = (- 148),\n  RD_KAFKA_RESP_ERR__MAX_POLL_EXCEEDED = (- 147),\n  RD_KAFKA_RESP_ERR__UNKNOWN_BROKER = (- 146),\n  RD_KAFKA_RESP_ERR__NOT_CONFIGURED = (- 145),\n  RD_KAFKA_RESP_ERR__FENCED = (- 144),\n  RD_KAFKA_RESP_ERR__APPLICATION = (- 143),\n  RD_KAFKA_RESP_ERR__ASSIGNMENT_LOST = (- 142),\n  RD_KAFKA_RESP_ERR__NOOP = (- 141),\n  RD_KAFKA_RESP_ERR__AUTO_OFFSET_RESET = (- 140),\n  RD_KAFKA_RESP_ERR__END = (- 100),\n  RD_KAFKA_RESP_ERR_UNKNOWN = (- 1),\n  RD_KAFKA_RESP_ERR_NO_ERROR = 0,\n  RD_KAFKA_RESP_ERR_OFFSET_OUT_OF_RANGE = 1,\n  RD_KAFKA_RESP_ERR_INVALID_MSG = 2,\n  RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART = 3,\n  RD_KAFKA_RESP_ERR_INVALID_MSG_SIZE = 4,\n  RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE = 5,\n  RD_KAFKA_RESP_ERR_NOT_LEADER_FOR_PARTITION = 6,\n  RD_KAFKA_RESP_ERR_REQUEST_TIMED_OUT = 7,\n  RD_KAFKA_RESP_ERR_BROKER_NOT_AVAILABLE = 8,\n  RD_KAFKA_RESP_ERR_REPLICA_NOT_AVAILABLE = 9,\n  RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE = 10,\n  RD_KAFKA_RESP_ERR_STALE_CTRL_EPOCH = 11,\n  RD_KAFKA_RESP_ERR_OFFSET_METADATA_TOO_LARGE = 12,\n  RD_KAFKA_RESP_ERR_NETWORK_EXCEPTION = 13,\n  RD_KAFKA_RESP_ERR_COORDINATOR_LOAD_IN_PROGRESS = 14,\n  RD_KAFKA_RESP_ERR_COORDINATOR_NOT_AVAILABLE = 15,\n  RD_KAFKA_RESP_ERR_NOT_COORDINATOR = 16,\n  RD_KAFKA_RESP_ERR_TOPIC_EXCEPTION = 17,\n  RD_KAFKA_RESP_ERR_RECORD_LIST_TOO_LARGE = 18,\n  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS = 19,\n  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS_AFTER_APPEND = 20,\n  RD_KAFKA_RESP_ERR_INVALID_REQUIRED_ACKS = 21,\n  RD_KAFKA_RESP_ERR_ILLEGAL_GENERATION = 22,\n  RD_KAFKA_RESP_ERR_INCONSISTENT_GROUP_PROTOCOL = 23,\n  RD_KAFKA_RESP_ERR_INVALID_GROUP_ID = 24,\n  RD_KAFKA_RESP_ERR_UNKNOWN_MEMBER_ID = 25,\n  RD_KAFKA_RESP_ERR_INVALID_SESSION_TIMEOUT = 26,\n  RD_KAFKA_RESP_ERR_REBALANCE_IN_PROGRESS = 27,\n  RD_KAFKA_RESP_ERR_INVALID_COMMIT_OFFSET_SIZE = 28,\n  RD_KAFKA_RESP_ERR_TOPIC_AUTHORIZATION_FAILED = 29,\n  RD_KAFKA_RESP_ERR_GROUP_AUTHORIZATION_FAILED = 30,\n  RD_KAFKA_RESP_ERR_CLUSTER_AUTHORIZATION_FAILED = 31,\n  RD_KAFKA_RESP_ERR_INVALID_TIMESTAMP = 32,\n  RD_KAFKA_RESP_ERR_UNSUPPORTED_SASL_MECHANISM = 33,\n  RD_KAFKA_RESP_ERR_ILLEGAL_SASL_STATE = 34,\n  RD_KAFKA_RESP_ERR_UNSUPPORTED_VERSION = 35,\n  RD_KAFKA_RESP_ERR_TOPIC_ALREADY_EXISTS = 36,\n  RD_KAFKA_RESP_ERR_INVALID_PARTITIONS = 37,\n  RD_KAFKA_RESP_ERR_INVALID_REPLICATION_FACTOR = 38,\n  RD_KAFKA_RESP_ERR_INVALID_REPLICA_ASSIGNMENT = 39,\n  RD_KAFKA_RESP_ERR_INVALID_CONFIG = 40,\n  RD_KAFKA_RESP_ERR_NOT_CONTROLLER = 41,\n  RD_KAFKA_RESP_ERR_INVALID_REQUEST = 42,\n  RD_KAFKA_RESP_ERR_UNSUPPORTED_FOR_MESSAGE_FORMAT = 43,\n  RD_KAFKA_RESP_ERR_POLICY_VIOLATION = 44,\n  RD_KAFKA_RESP_ERR_OUT_OF_ORDER_SEQUENCE_NUMBER = 45,\n  RD_KAFKA_RESP_ERR_DUPLICATE_SEQUENCE_NUMBER = 46,\n  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_EPOCH = 47,\n  RD_KAFKA_RESP_ERR_INVALID_TXN_STATE = 48,\n  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_ID_MAPPING = 49,\n  RD_KAFKA_RESP_ERR_INVALID_TRANSACTION_TIMEOUT = 50,\n  RD_KAFKA_RESP_ERR_CONCURRENT_TRANSACTIONS = 51,\n  RD_KAFKA_RESP_ERR_TRANSACTION_COORDINATOR_FENCED = 52,\n  RD_KAFKA_RESP_ERR_TRANSACTIONAL_ID_AUTHORIZATION_FAILED = 53,\n  RD_KAFKA_RESP_ERR_SECURITY_DISABLED = 54,\n  RD_KAFKA_RESP_ERR_OPERATION_NOT_ATTEMPTED = 55,\n  RD_KAFKA_RESP_ERR_KAFKA_STORAGE_ERROR = 56,\n  RD_KAFKA_RESP_ERR_LOG_DIR_NOT_FOUND = 57,\n  RD_KAFKA_RESP_ERR_SASL_AUTHENTICATION_FAILED = 58,\n  RD_KAFKA_RESP_ERR_UNKNOWN_PRODUCER_ID = 59,\n  RD_KAFKA_RESP_ERR_REASSIGNMENT_IN_PROGRESS = 60,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTH_DISABLED = 61,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_NOT_FOUND = 62,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_OWNER_MISMATCH = 63,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_REQUEST_NOT_ALLOWED = 64,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTHORIZATION_FAILED = 65,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_EXPIRED = 66,\n  RD_KAFKA_RESP_ERR_INVALID_PRINCIPAL_TYPE = 67,\n  RD_KAFKA_RESP_ERR_NON_EMPTY_GROUP = 68,\n  RD_KAFKA_RESP_ERR_GROUP_ID_NOT_FOUND = 69,\n  RD_KAFKA_RESP_ERR_FETCH_SESSION_ID_NOT_FOUND = 70,\n  RD_KAFKA_RESP_ERR_INVALID_FETCH_SESSION_EPOCH = 71,\n  RD_KAFKA_RESP_ERR_LISTENER_NOT_FOUND = 72,\n  RD_KAFKA_RESP_ERR_TOPIC_DELETION_DISABLED = 73,\n  RD_KAFKA_RESP_ERR_FENCED_LEADER_EPOCH = 74,\n  RD_KAFKA_RESP_ERR_UNKNOWN_LEADER_EPOCH = 75,\n  RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76,\n  RD_KAFKA_RESP_ERR_STALE_BROKER_EPOCH = 77,\n  RD_KAFKA_RESP_ERR_OFFSET_NOT_AVAILABLE = 78,\n  RD_KAFKA_RESP_ERR_MEMBER_ID_REQUIRED = 79,\n  RD_KAFKA_RESP_ERR_PREFERRED_LEADER_NOT_AVAILABLE = 80,\n  RD_KAFKA_RESP_ERR_GROUP_MAX_SIZE_REACHED = 81,\n  RD_KAFKA_RESP_ERR_FENCED_INSTANCE_ID = 82,\n  RD_KAFKA_RESP_ERR_ELIGIBLE_LEADERS_NOT_AVAILABLE = 83,\n  RD_KAFKA_RESP_ERR_ELECTION_NOT_NEEDED = 84,\n  RD_KAFKA_RESP_ERR_NO_REASSIGNMENT_IN_PROGRESS = 85,\n  RD_KAFKA_RESP_ERR_GROUP_SUBSCRIBED_TO_TOPIC = 86,\n  RD_KAFKA_RESP_ERR_INVALID_RECORD = 87,\n  RD_KAFKA_RESP_ERR_UNSTABLE_OFFSET_COMMIT = 88,\n  RD_KAFKA_RESP_ERR_THROTTLING_QUOTA_EXCEEDED = 89,\n  RD_KAFKA_RESP_ERR_PRODUCER_FENCED = 90,\n  RD_KAFKA_RESP_ERR_RESOURCE_NOT_FOUND = 91,\n  RD_KAFKA_RESP_ERR_DUPLICATE_RESOURCE = 92,\n  RD_KAFKA_RESP_ERR_UNACCEPTABLE_CREDENTIAL = 93,\n  RD_KAFKA_RESP_ERR_INCONSISTENT_VOTER_SET = 94,\n  RD_KAFKA_RESP_ERR_INVALID_UPDATE_VERSION = 95,\n  RD_KAFKA_RESP_ERR_FEATURE_UPDATE_FAILED = 96,\n  RD_KAFKA_RESP_ERR_PRINCIPAL_DESERIALIZATION_FAILURE = 97,\n  RD_KAFKA_RESP_ERR_END_ALL,\n} rd_kafka_resp_err_t;\nstruct rd_kafka_err_desc {\n  rd_kafka_resp_err_t code;\n  char *name;\n  char *desc;\n};\nvoid rd_kafka_get_err_descs(const struct rd_kafka_err_desc **errdescs, size_t *cntp);\nconst char *rd_kafka_err2str(rd_kafka_resp_err_t err);\nconst char *rd_kafka_err2name(rd_kafka_resp_err_t err);\nrd_kafka_resp_err_t rd_kafka_last_error(void);\nrd_kafka_resp_err_t rd_kafka_errno2err(int errnox);\nint rd_kafka_errno(void);\nrd_kafka_resp_err_t rd_kafka_fatal_error(rd_kafka_t *rk, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_test_fatal_error(rd_kafka_t *rk, rd_kafka_resp_err_t err, const char *reason);\nrd_kafka_resp_err_t rd_kafka_error_code(const rd_kafka_error_t *error);\nconst char *rd_kafka_error_name(const rd_kafka_error_t *error);\nconst char *rd_kafka_error_string(const rd_kafka_error_t *error);\nint rd_kafka_error_is_fatal(const rd_kafka_error_t *error);\nint rd_kafka_error_is_retriable(const rd_kafka_error_t *error);\nint rd_kafka_error_txn_requires_abort(const rd_kafka_error_t *error);\nvoid rd_kafka_error_destroy(rd_kafka_error_t *error);\nrd_kafka_error_t *rd_kafka_error_new(rd_kafka_resp_err_t code, const char *fmt, ...);\ntypedef struct rd_kafka_topic_partition_s {\n  char *topic;\n  int32_t partition;\n  int64_t offset;\n  void *metadata;\n  size_t metadata_size;\n  void *opaque;\n  rd_kafka_resp_err_t err;\n  void *_private;\n} rd_kafka_topic_partition_t;\nvoid rd_kafka_topic_partition_destroy(rd_kafka_topic_partition_t *rktpar);\ntypedef struct rd_kafka_topic_partition_list_s {\n  int cnt;\n  int size;\n  rd_kafka_topic_partition_t *elems;\n} rd_kafka_topic_partition_list_t;\nrd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_new(int size);\nvoid rd_kafka_topic_partition_list_destroy(rd_kafka_topic_partition_list_t *rkparlist);\nrd_kafka_topic_partition_t *rd_kafka_topic_partition_list_add(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);\nvoid rd_kafka_topic_partition_list_add_range(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t start, int32_t stop);\nint rd_kafka_topic_partition_list_del(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);\nint rd_kafka_topic_partition_list_del_by_idx(rd_kafka_topic_partition_list_t *rktparlist, int idx);\nrd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_copy(const rd_kafka_topic_partition_list_t *src);\nrd_kafka_resp_err_t rd_kafka_topic_partition_list_set_offset(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition, int64_t offset);\nrd_kafka_topic_partition_t *rd_kafka_topic_partition_list_find(const rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);\nvoid rd_kafka_topic_partition_list_sort(rd_kafka_topic_partition_list_t *rktparlist, int (*cmp)(const void *a, const void *b, void *cmp_opaque), void *cmp_opaque);\ntypedef enum rd_kafka_vtype_t {\n  RD_KAFKA_VTYPE_END,\n  RD_KAFKA_VTYPE_TOPIC,\n  RD_KAFKA_VTYPE_RKT,\n  RD_KAFKA_VTYPE_PARTITION,\n  RD_KAFKA_VTYPE_VALUE,\n  RD_KAFKA_VTYPE_KEY,\n  RD_KAFKA_VTYPE_OPAQUE,\n  RD_KAFKA_VTYPE_MSGFLAGS,\n  RD_KAFKA_VTYPE_TIMESTAMP,\n  RD_KAFKA_VTYPE_HEADER,\n  RD_KAFKA_VTYPE_HEADERS,\n} rd_kafka_vtype_t;\ntypedef struct rd_kafka_vu_s {\n  rd_kafka_vtype_t vtype;\n  union {\n    char *cstr;\n    rd_kafka_topic_t *rkt;\n    int i;\n    int32_t i32;\n    int64_t i64;\n    struct {\n      void *ptr;\n      size_t size;\n    } mem;\n    struct {\n      char *name;\n      void *val;\n      ssize_t size;\n    } header;\n    rd_kafka_headers_t *headers;\n    void *ptr;\n    char _pad[64];\n  } u;\n} rd_kafka_vu_t;\nrd_kafka_headers_t *rd_kafka_headers_new(size_t initial_count);\nvoid rd_kafka_headers_destroy(rd_kafka_headers_t *hdrs);\nrd_kafka_headers_t *rd_kafka_headers_copy(const rd_kafka_headers_t *src);\nrd_kafka_resp_err_t rd_kafka_header_add(rd_kafka_headers_t *hdrs, const char *name, ssize_t name_size, const void *value, ssize_t value_size);\nrd_kafka_resp_err_t rd_kafka_header_remove(rd_kafka_headers_t *hdrs, const char *name);\nrd_kafka_resp_err_t rd_kafka_header_get_last(const rd_kafka_headers_t *hdrs, const char *name, const void **valuep, size_t *sizep);\nrd_kafka_resp_err_t rd_kafka_header_get(const rd_kafka_headers_t *hdrs, size_t idx, const char *name, const void **valuep, size_t *sizep);\nrd_kafka_resp_err_t rd_kafka_header_get_all(const rd_kafka_headers_t *hdrs, size_t idx, const char **namep, const void **valuep, size_t *sizep);\ntypedef struct rd_kafka_message_s {\n  rd_kafka_resp_err_t err;\n  rd_kafka_topic_t *rkt;\n  int32_t partition;\n  void *payload;\n  size_t len;\n  void *key;\n  size_t key_len;\n  int64_t offset;\n  void *_private;\n} rd_kafka_message_t;\nvoid rd_kafka_message_destroy(rd_kafka_message_t *rkmessage);\nconst char *rd_kafka_message_errstr(const rd_kafka_message_t *rkmessage);\nint64_t rd_kafka_message_timestamp(const rd_kafka_message_t *rkmessage, rd_kafka_timestamp_type_t *tstype);\nint64_t rd_kafka_message_latency(const rd_kafka_message_t *rkmessage);\nint32_t rd_kafka_message_broker_id(const rd_kafka_message_t *rkmessage);\nrd_kafka_resp_err_t rd_kafka_message_headers(const rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);\nrd_kafka_resp_err_t rd_kafka_message_detach_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);\nvoid rd_kafka_message_set_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t *hdrs);\nsize_t rd_kafka_header_cnt(const rd_kafka_headers_t *hdrs);\ntypedef enum {\n  RD_KAFKA_MSG_STATUS_NOT_PERSISTED = 0,\n  RD_KAFKA_MSG_STATUS_POSSIBLY_PERSISTED = 1,\n  RD_KAFKA_MSG_STATUS_PERSISTED = 2,\n} rd_kafka_msg_status_t;\nrd_kafka_msg_status_t rd_kafka_message_status(const rd_kafka_message_t *rkmessage);\ntypedef enum {\n  RD_KAFKA_CONF_UNKNOWN = (- 2),\n  RD_KAFKA_CONF_INVALID = (- 1),\n  RD_KAFKA_CONF_OK = 0,\n} rd_kafka_conf_res_t;\nrd_kafka_conf_t *rd_kafka_conf_new(void);\nvoid rd_kafka_conf_destroy(rd_kafka_conf_t *conf);\nrd_kafka_conf_t *rd_kafka_conf_dup(const rd_kafka_conf_t *conf);\nrd_kafka_conf_t *rd_kafka_conf_dup_filter(const rd_kafka_conf_t *conf, size_t filter_cnt, const char **filter);\nconst rd_kafka_conf_t *rd_kafka_conf(rd_kafka_t *rk);\nrd_kafka_conf_res_t rd_kafka_conf_set(rd_kafka_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);\nvoid rd_kafka_conf_set_events(rd_kafka_conf_t *conf, int events);\nvoid rd_kafka_conf_set_background_event_cb(rd_kafka_conf_t *conf, void (*event_cb)(rd_kafka_t *rk, rd_kafka_event_t *rkev, void *opaque));\nvoid rd_kafka_conf_set_dr_cb(rd_kafka_conf_t *conf, void (*dr_cb)(rd_kafka_t *rk, void *payload, size_t len, rd_kafka_resp_err_t err, void *opaque, void *msg_opaque));\nvoid rd_kafka_conf_set_dr_msg_cb(rd_kafka_conf_t *conf, void (*dr_msg_cb)(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, void *opaque));\nvoid rd_kafka_conf_set_consume_cb(rd_kafka_conf_t *conf, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *opaque));\nvoid rd_kafka_conf_set_rebalance_cb(rd_kafka_conf_t *conf, void (*rebalance_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *partitions, void *opaque));\nvoid rd_kafka_conf_set_offset_commit_cb(rd_kafka_conf_t *conf, void (*offset_commit_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *opaque));\nvoid rd_kafka_conf_set_error_cb(rd_kafka_conf_t *conf, void (*error_cb)(rd_kafka_t *rk, int err, const char *reason, void *opaque));\nvoid rd_kafka_conf_set_throttle_cb(rd_kafka_conf_t *conf, void (*throttle_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int throttle_time_ms, void *opaque));\nvoid rd_kafka_conf_set_log_cb(rd_kafka_conf_t *conf, void (*log_cb)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));\nvoid rd_kafka_conf_set_stats_cb(rd_kafka_conf_t *conf, int (*stats_cb)(rd_kafka_t *rk, char *json, size_t json_len, void *opaque));\nvoid rd_kafka_conf_set_oauthbearer_token_refresh_cb(rd_kafka_conf_t *conf, void (*oauthbearer_token_refresh_cb)(rd_kafka_t *rk, const char *oauthbearer_config, void *opaque));\nvoid rd_kafka_conf_set_socket_cb(rd_kafka_conf_t *conf, int (*socket_cb)(int domain, int type, int protocol, void *opaque));\nvoid rd_kafka_conf_set_connect_cb(rd_kafka_conf_t *conf, int (*connect_cb)(int sockfd, const struct sockaddr *addr, int addrlen, const char *id, void *opaque));\nvoid rd_kafka_conf_set_closesocket_cb(rd_kafka_conf_t *conf, int (*closesocket_cb)(int sockfd, void *opaque));\nrd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert_verify_cb(rd_kafka_conf_t *conf, int (*ssl_cert_verify_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int *x509_error, int depth, const char *buf, size_t size, char *errstr, size_t errstr_size, void *opaque));\ntypedef enum rd_kafka_cert_type_t {\n  RD_KAFKA_CERT_PUBLIC_KEY,\n  RD_KAFKA_CERT_PRIVATE_KEY,\n  RD_KAFKA_CERT_CA,\n  RD_KAFKA_CERT__CNT,\n} rd_kafka_cert_type_t;\ntypedef enum rd_kafka_cert_enc_t {\n  RD_KAFKA_CERT_ENC_PKCS12,\n  RD_KAFKA_CERT_ENC_DER,\n  RD_KAFKA_CERT_ENC_PEM,\n  RD_KAFKA_CERT_ENC__CNT,\n} rd_kafka_cert_enc_t;\nrd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert(rd_kafka_conf_t *conf, rd_kafka_cert_type_t cert_type, rd_kafka_cert_enc_t cert_enc, const void *buffer, size_t size, char *errstr, size_t errstr_size);\nvoid rd_kafka_conf_set_engine_callback_data(rd_kafka_conf_t *conf, void *callback_data);\nvoid rd_kafka_conf_set_opaque(rd_kafka_conf_t *conf, void *opaque);\nvoid *rd_kafka_opaque(const rd_kafka_t *rk);\nvoid rd_kafka_conf_set_default_topic_conf(rd_kafka_conf_t *conf, rd_kafka_topic_conf_t *tconf);\nrd_kafka_topic_conf_t *rd_kafka_conf_get_default_topic_conf(rd_kafka_conf_t *conf);\nrd_kafka_conf_res_t rd_kafka_conf_get(const rd_kafka_conf_t *conf, const char *name, char *dest, size_t *dest_size);\nrd_kafka_conf_res_t rd_kafka_topic_conf_get(const rd_kafka_topic_conf_t *conf, const char *name, char *dest, size_t *dest_size);\nconst char **rd_kafka_conf_dump(rd_kafka_conf_t *conf, size_t *cntp);\nconst char **rd_kafka_topic_conf_dump(rd_kafka_topic_conf_t *conf, size_t *cntp);\nvoid rd_kafka_conf_dump_free(const char **arr, size_t cnt);\nvoid rd_kafka_conf_properties_show(FILE *fp);\nrd_kafka_topic_conf_t *rd_kafka_topic_conf_new(void);\nrd_kafka_topic_conf_t *rd_kafka_topic_conf_dup(const rd_kafka_topic_conf_t *conf);\nrd_kafka_topic_conf_t *rd_kafka_default_topic_conf_dup(rd_kafka_t *rk);\nvoid rd_kafka_topic_conf_destroy(rd_kafka_topic_conf_t *topic_conf);\nrd_kafka_conf_res_t rd_kafka_topic_conf_set(rd_kafka_topic_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);\nvoid rd_kafka_topic_conf_set_opaque(rd_kafka_topic_conf_t *conf, void *rkt_opaque);\nvoid rd_kafka_topic_conf_set_partitioner_cb(rd_kafka_topic_conf_t *topic_conf, int32_t (*partitioner)(const rd_kafka_topic_t *rkt, const void *keydata, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque));\nvoid rd_kafka_topic_conf_set_msg_order_cmp(rd_kafka_topic_conf_t *topic_conf, int (*msg_order_cmp)(const rd_kafka_message_t *a, const rd_kafka_message_t *b));\nint rd_kafka_topic_partition_available(const rd_kafka_topic_t *rkt, int32_t partition);\nint32_t rd_kafka_msg_partitioner_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_consistent(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_consistent_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_murmur2(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_murmur2_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_fnv1a(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_fnv1a_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nrd_kafka_t *rd_kafka_new(rd_kafka_type_t type, rd_kafka_conf_t *conf, char *errstr, size_t errstr_size);\nvoid rd_kafka_destroy(rd_kafka_t *rk);\nvoid rd_kafka_destroy_flags(rd_kafka_t *rk, int flags);\nconst char *rd_kafka_name(const rd_kafka_t *rk);\nrd_kafka_type_t rd_kafka_type(const rd_kafka_t *rk);\nchar *rd_kafka_memberid(const rd_kafka_t *rk);\nchar *rd_kafka_clusterid(rd_kafka_t *rk, int timeout_ms);\nint32_t rd_kafka_controllerid(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_topic_t *rd_kafka_topic_new(rd_kafka_t *rk, const char *topic, rd_kafka_topic_conf_t *conf);\nvoid rd_kafka_topic_destroy(rd_kafka_topic_t *rkt);\nconst char *rd_kafka_topic_name(const rd_kafka_topic_t *rkt);\nvoid *rd_kafka_topic_opaque(const rd_kafka_topic_t *rkt);\nint rd_kafka_poll(rd_kafka_t *rk, int timeout_ms);\nvoid rd_kafka_yield(rd_kafka_t *rk);\nrd_kafka_resp_err_t rd_kafka_pause_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_resp_err_t rd_kafka_resume_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_resp_err_t rd_kafka_query_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high, int timeout_ms);\nrd_kafka_resp_err_t rd_kafka_get_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high);\nrd_kafka_resp_err_t rd_kafka_offsets_for_times(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets, int timeout_ms);\nvoid *rd_kafka_mem_calloc(rd_kafka_t *rk, size_t num, size_t size);\nvoid *rd_kafka_mem_malloc(rd_kafka_t *rk, size_t size);\nvoid rd_kafka_mem_free(rd_kafka_t *rk, void *ptr);\nrd_kafka_queue_t *rd_kafka_queue_new(rd_kafka_t *rk);\nvoid rd_kafka_queue_destroy(rd_kafka_queue_t *rkqu);\nrd_kafka_queue_t *rd_kafka_queue_get_main(rd_kafka_t *rk);\nrd_kafka_queue_t *rd_kafka_queue_get_consumer(rd_kafka_t *rk);\nrd_kafka_queue_t *rd_kafka_queue_get_partition(rd_kafka_t *rk, const char *topic, int32_t partition);\nrd_kafka_queue_t *rd_kafka_queue_get_background(rd_kafka_t *rk);\nvoid rd_kafka_queue_forward(rd_kafka_queue_t *src, rd_kafka_queue_t *dst);\nrd_kafka_resp_err_t rd_kafka_set_log_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu);\nsize_t rd_kafka_queue_length(rd_kafka_queue_t *rkqu);\nvoid rd_kafka_queue_io_event_enable(rd_kafka_queue_t *rkqu, int fd, const void *payload, size_t size);\nvoid rd_kafka_queue_cb_event_enable(rd_kafka_queue_t *rkqu, void (*event_cb)(rd_kafka_t *rk, void *qev_opaque), void *qev_opaque);\nvoid rd_kafka_queue_yield(rd_kafka_queue_t *rkqu);\nint rd_kafka_consume_start(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);\nint rd_kafka_consume_start_queue(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, rd_kafka_queue_t *rkqu);\nint rd_kafka_consume_stop(rd_kafka_topic_t *rkt, int32_t partition);\nrd_kafka_resp_err_t rd_kafka_seek(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, int timeout_ms);\nrd_kafka_error_t *rd_kafka_seek_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms);\nrd_kafka_message_t *rd_kafka_consume(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms);\nssize_t rd_kafka_consume_batch(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);\nint rd_kafka_consume_callback(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);\nrd_kafka_message_t *rd_kafka_consume_queue(rd_kafka_queue_t *rkqu, int timeout_ms);\nssize_t rd_kafka_consume_batch_queue(rd_kafka_queue_t *rkqu, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);\nint rd_kafka_consume_callback_queue(rd_kafka_queue_t *rkqu, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);\nrd_kafka_resp_err_t rd_kafka_offset_store(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);\nrd_kafka_resp_err_t rd_kafka_offsets_store(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets);\nrd_kafka_resp_err_t rd_kafka_subscribe(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *topics);\nrd_kafka_resp_err_t rd_kafka_unsubscribe(rd_kafka_t *rk);\nrd_kafka_resp_err_t rd_kafka_subscription(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **topics);\nrd_kafka_message_t *rd_kafka_consumer_poll(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_resp_err_t rd_kafka_consumer_close(rd_kafka_t *rk);\nrd_kafka_error_t *rd_kafka_incremental_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_error_t *rd_kafka_incremental_unassign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);\nconst char *rd_kafka_rebalance_protocol(rd_kafka_t *rk);\nrd_kafka_resp_err_t rd_kafka_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_resp_err_t rd_kafka_assignment(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **partitions);\nint rd_kafka_assignment_lost(rd_kafka_t *rk);\nrd_kafka_resp_err_t rd_kafka_commit(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, int async);\nrd_kafka_resp_err_t rd_kafka_commit_message(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, int async);\nrd_kafka_resp_err_t rd_kafka_commit_queue(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_queue_t *rkqu, void (*cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *commit_opaque), void *commit_opaque);\nrd_kafka_resp_err_t rd_kafka_committed(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms);\nrd_kafka_resp_err_t rd_kafka_position(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata(rd_kafka_t *rk);\nrd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata_new(const char *group_id);\nrd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata_new_with_genid(const char *group_id, int32_t generation_id, const char *member_id, const char *group_instance_id);\nvoid rd_kafka_consumer_group_metadata_destroy(rd_kafka_consumer_group_metadata_t *);\nrd_kafka_error_t *rd_kafka_consumer_group_metadata_write(const rd_kafka_consumer_group_metadata_t *cgmd, void **bufferp, size_t *sizep);\nrd_kafka_error_t *rd_kafka_consumer_group_metadata_read(rd_kafka_consumer_group_metadata_t **cgmdp, const void *buffer, size_t size);\nint rd_kafka_produce(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, void *payload, size_t len, const void *key, size_t keylen, void *msg_opaque);\nrd_kafka_resp_err_t rd_kafka_producev(rd_kafka_t *rk, ...);\nrd_kafka_error_t *rd_kafka_produceva(rd_kafka_t *rk, const rd_kafka_vu_t *vus, size_t cnt);\nint rd_kafka_produce_batch(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, rd_kafka_message_t *rkmessages, int message_cnt);\nrd_kafka_resp_err_t rd_kafka_flush(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_resp_err_t rd_kafka_purge(rd_kafka_t *rk, int purge_flags);\ntypedef struct rd_kafka_metadata_broker {\n  int32_t id;\n  char *host;\n  int port;\n} rd_kafka_metadata_broker_t;\ntypedef struct rd_kafka_metadata_partition {\n  int32_t id;\n  rd_kafka_resp_err_t err;\n  int32_t leader;\n  int replica_cnt;\n  int32_t *replicas;\n  int isr_cnt;\n  int32_t *isrs;\n} rd_kafka_metadata_partition_t;\ntypedef struct rd_kafka_metadata_topic {\n  char *topic;\n  int partition_cnt;\n  struct rd_kafka_metadata_partition *partitions;\n  rd_kafka_resp_err_t err;\n} rd_kafka_metadata_topic_t;\ntypedef struct rd_kafka_metadata {\n  int broker_cnt;\n  struct rd_kafka_metadata_broker *brokers;\n  int topic_cnt;\n  struct rd_kafka_metadata_topic *topics;\n  int32_t orig_broker_id;\n  char *orig_broker_name;\n} rd_kafka_metadata_t;\nrd_kafka_resp_err_t rd_kafka_metadata(rd_kafka_t *rk, int all_topics, rd_kafka_topic_t *only_rkt, const struct rd_kafka_metadata **metadatap, int timeout_ms);\nvoid rd_kafka_metadata_destroy(const struct rd_kafka_metadata *metadata);\nstruct rd_kafka_group_member_info {\n  char *member_id;\n  char *client_id;\n  char *client_host;\n  void *member_metadata;\n  int member_metadata_size;\n  void *member_assignment;\n  int member_assignment_size;\n};\nstruct rd_kafka_group_info {\n  struct rd_kafka_metadata_broker broker;\n  char *group;\n  rd_kafka_resp_err_t err;\n  char *state;\n  char *protocol_type;\n  char *protocol;\n  struct rd_kafka_group_member_info *members;\n  int member_cnt;\n};\nstruct rd_kafka_group_list {\n  struct rd_kafka_group_info *groups;\n  int group_cnt;\n};\nrd_kafka_resp_err_t rd_kafka_list_groups(rd_kafka_t *rk, const char *group, const struct rd_kafka_group_list **grplistp, int timeout_ms);\nvoid rd_kafka_group_list_destroy(const struct rd_kafka_group_list *grplist);\nint rd_kafka_brokers_add(rd_kafka_t *rk, const char *brokerlist);\nvoid rd_kafka_set_logger(rd_kafka_t *rk, void (*func)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));\nvoid rd_kafka_set_log_level(rd_kafka_t *rk, int level);\nvoid rd_kafka_log_print(const rd_kafka_t *rk, int level, const char *fac, const char *buf);\nvoid rd_kafka_log_syslog(const rd_kafka_t *rk, int level, const char *fac, const char *buf);\nint rd_kafka_outq_len(rd_kafka_t *rk);\nvoid rd_kafka_dump(FILE *fp, rd_kafka_t *rk);\nint rd_kafka_thread_cnt(void);\ntypedef enum rd_kafka_thread_type_t {\n  RD_KAFKA_THREAD_MAIN,\n  RD_KAFKA_THREAD_BACKGROUND,\n  RD_KAFKA_THREAD_BROKER,\n} rd_kafka_thread_type_t;\nint rd_kafka_wait_destroyed(int timeout_ms);\nint rd_kafka_unittest(void);\nrd_kafka_resp_err_t rd_kafka_poll_set_consumer(rd_kafka_t *rk);\ntypedef int rd_kafka_event_type_t;\nrd_kafka_event_type_t rd_kafka_event_type(const rd_kafka_event_t *rkev);\nconst char *rd_kafka_event_name(const rd_kafka_event_t *rkev);\nvoid rd_kafka_event_destroy(rd_kafka_event_t *rkev);\nconst rd_kafka_message_t *rd_kafka_event_message_next(rd_kafka_event_t *rkev);\nsize_t rd_kafka_event_message_array(rd_kafka_event_t *rkev, const rd_kafka_message_t **rkmessages, size_t size);\nsize_t rd_kafka_event_message_count(rd_kafka_event_t *rkev);\nconst char *rd_kafka_event_config_string(rd_kafka_event_t *rkev);\nrd_kafka_resp_err_t rd_kafka_event_error(rd_kafka_event_t *rkev);\nconst char *rd_kafka_event_error_string(rd_kafka_event_t *rkev);\nint rd_kafka_event_error_is_fatal(rd_kafka_event_t *rkev);\nvoid *rd_kafka_event_opaque(rd_kafka_event_t *rkev);\nint rd_kafka_event_log(rd_kafka_event_t *rkev, const char **fac, const char **str, int *level);\nint rd_kafka_event_debug_contexts(rd_kafka_event_t *rkev, char *dst, size_t dstsize);\nconst char *rd_kafka_event_stats(rd_kafka_event_t *rkev);\nrd_kafka_topic_partition_list_t *rd_kafka_event_topic_partition_list(rd_kafka_event_t *rkev);\nrd_kafka_topic_partition_t *rd_kafka_event_topic_partition(rd_kafka_event_t *rkev);\ntypedef rd_kafka_event_t rd_kafka_CreateTopics_result_t;\ntypedef rd_kafka_event_t rd_kafka_DeleteTopics_result_t;\ntypedef rd_kafka_event_t rd_kafka_CreatePartitions_result_t;\ntypedef rd_kafka_event_t rd_kafka_AlterConfigs_result_t;\ntypedef rd_kafka_event_t rd_kafka_DescribeConfigs_result_t;\ntypedef rd_kafka_event_t rd_kafka_DeleteRecords_result_t;\ntypedef rd_kafka_event_t rd_kafka_DeleteGroups_result_t;\ntypedef rd_kafka_event_t rd_kafka_DeleteConsumerGroupOffsets_result_t;\nconst rd_kafka_CreateTopics_result_t *rd_kafka_event_CreateTopics_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DeleteTopics_result_t *rd_kafka_event_DeleteTopics_result(rd_kafka_event_t *rkev);\nconst rd_kafka_CreatePartitions_result_t *rd_kafka_event_CreatePartitions_result(rd_kafka_event_t *rkev);\nconst rd_kafka_AlterConfigs_result_t *rd_kafka_event_AlterConfigs_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DescribeConfigs_result_t *rd_kafka_event_DescribeConfigs_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DeleteRecords_result_t *rd_kafka_event_DeleteRecords_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DeleteGroups_result_t *rd_kafka_event_DeleteGroups_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DeleteConsumerGroupOffsets_result_t *rd_kafka_event_DeleteConsumerGroupOffsets_result(rd_kafka_event_t *rkev);\nrd_kafka_event_t *rd_kafka_queue_poll(rd_kafka_queue_t *rkqu, int timeout_ms);\nint rd_kafka_queue_poll_callback(rd_kafka_queue_t *rkqu, int timeout_ms);\ntypedef rd_kafka_resp_err_t (rd_kafka_plugin_f_conf_init_t)(rd_kafka_conf_t *conf, void **plug_opaquep, char *errstr, size_t errstr_size);\ntypedef rd_kafka_conf_res_t (rd_kafka_interceptor_f_on_conf_set_t)(rd_kafka_conf_t *conf, const char *name, const char *val, char *errstr, size_t errstr_size, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_dup_t)(rd_kafka_conf_t *new_conf, const rd_kafka_conf_t *old_conf, size_t filter_cnt, const char **filter, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_destroy_t)(void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_new_t)(rd_kafka_t *rk, const rd_kafka_conf_t *conf, void *ic_opaque, char *errstr, size_t errstr_size);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_destroy_t)(rd_kafka_t *rk, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_send_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_acknowledgement_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_consume_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_commit_t)(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_resp_err_t err, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_request_sent_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_response_received_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, int64_t rtt, rd_kafka_resp_err_t err, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_start_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_exit_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_set(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_set_t *on_conf_set, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_dup(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_dup_t *on_conf_dup, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_destroy(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_destroy_t *on_conf_destroy, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_new(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_new_t *on_new, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_destroy(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_destroy_t *on_destroy, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_send(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_send_t *on_send, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_acknowledgement(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_acknowledgement_t *on_acknowledgement, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_consume(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_consume_t *on_consume, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_commit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_commit_t *on_commit, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_request_sent(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_request_sent_t *on_request_sent, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_response_received(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_response_received_t *on_response_received, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_start(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_start_t *on_thread_start, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_exit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_exit_t *on_thread_exit, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_topic_result_error(const rd_kafka_topic_result_t *topicres);\nconst char *rd_kafka_topic_result_error_string(const rd_kafka_topic_result_t *topicres);\nconst char *rd_kafka_topic_result_name(const rd_kafka_topic_result_t *topicres);\nconst rd_kafka_error_t *rd_kafka_group_result_error(const rd_kafka_group_result_t *groupres);\nconst char *rd_kafka_group_result_name(const rd_kafka_group_result_t *groupres);\nconst rd_kafka_topic_partition_list_t *rd_kafka_group_result_partitions(const rd_kafka_group_result_t *groupres);\ntypedef enum rd_kafka_admin_op_t {\n  RD_KAFKA_ADMIN_OP_ANY = 0,\n  RD_KAFKA_ADMIN_OP_CREATETOPICS,\n  RD_KAFKA_ADMIN_OP_DELETETOPICS,\n  RD_KAFKA_ADMIN_OP_CREATEPARTITIONS,\n  RD_KAFKA_ADMIN_OP_ALTERCONFIGS,\n  RD_KAFKA_ADMIN_OP_DESCRIBECONFIGS,\n  RD_KAFKA_ADMIN_OP_DELETERECORDS,\n  RD_KAFKA_ADMIN_OP_DELETEGROUPS,\n  RD_KAFKA_ADMIN_OP_DELETECONSUMERGROUPOFFSETS,\n  RD_KAFKA_ADMIN_OP__CNT,\n} rd_kafka_admin_op_t;\ntypedef struct rd_kafka_AdminOptions_s rd_kafka_AdminOptions_t;\nrd_kafka_AdminOptions_t *rd_kafka_AdminOptions_new(rd_kafka_t *rk, rd_kafka_admin_op_t for_api);\nvoid rd_kafka_AdminOptions_destroy(rd_kafka_AdminOptions_t *options);\nrd_kafka_resp_err_t rd_kafka_AdminOptions_set_request_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_AdminOptions_set_operation_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_AdminOptions_set_validate_only(rd_kafka_AdminOptions_t *options, int true_or_false, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_AdminOptions_set_broker(rd_kafka_AdminOptions_t *options, int32_t broker_id, char *errstr, size_t errstr_size);\nvoid rd_kafka_AdminOptions_set_opaque(rd_kafka_AdminOptions_t *options, void *ev_opaque);\ntypedef struct rd_kafka_NewTopic_s rd_kafka_NewTopic_t;\nrd_kafka_NewTopic_t *rd_kafka_NewTopic_new(const char *topic, int num_partitions, int replication_factor, char *errstr, size_t errstr_size);\nvoid rd_kafka_NewTopic_destroy(rd_kafka_NewTopic_t *new_topic);\nvoid rd_kafka_NewTopic_destroy_array(rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt);\nrd_kafka_resp_err_t rd_kafka_NewTopic_set_replica_assignment(rd_kafka_NewTopic_t *new_topic, int32_t partition, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_NewTopic_set_config(rd_kafka_NewTopic_t *new_topic, const char *name, const char *value);\nvoid rd_kafka_CreateTopics(rd_kafka_t *rk, rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_topic_result_t **rd_kafka_CreateTopics_result_topics(const rd_kafka_CreateTopics_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_DeleteTopic_s rd_kafka_DeleteTopic_t;\nrd_kafka_DeleteTopic_t *rd_kafka_DeleteTopic_new(const char *topic);\nvoid rd_kafka_DeleteTopic_destroy(rd_kafka_DeleteTopic_t *del_topic);\nvoid rd_kafka_DeleteTopic_destroy_array(rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt);\nvoid rd_kafka_DeleteTopics(rd_kafka_t *rk, rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_topic_result_t **rd_kafka_DeleteTopics_result_topics(const rd_kafka_DeleteTopics_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_NewPartitions_s rd_kafka_NewPartitions_t;\nrd_kafka_NewPartitions_t *rd_kafka_NewPartitions_new(const char *topic, size_t new_total_cnt, char *errstr, size_t errstr_size);\nvoid rd_kafka_NewPartitions_destroy(rd_kafka_NewPartitions_t *new_parts);\nvoid rd_kafka_NewPartitions_destroy_array(rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt);\nrd_kafka_resp_err_t rd_kafka_NewPartitions_set_replica_assignment(rd_kafka_NewPartitions_t *new_parts, int32_t new_partition_idx, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);\nvoid rd_kafka_CreatePartitions(rd_kafka_t *rk, rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_topic_result_t **rd_kafka_CreatePartitions_result_topics(const rd_kafka_CreatePartitions_result_t *result, size_t *cntp);\ntypedef enum rd_kafka_ConfigSource_t {\n  RD_KAFKA_CONFIG_SOURCE_UNKNOWN_CONFIG = 0,\n  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_TOPIC_CONFIG = 1,\n  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_BROKER_CONFIG = 2,\n  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_DEFAULT_BROKER_CONFIG = 3,\n  RD_KAFKA_CONFIG_SOURCE_STATIC_BROKER_CONFIG = 4,\n  RD_KAFKA_CONFIG_SOURCE_DEFAULT_CONFIG = 5,\n  RD_KAFKA_CONFIG_SOURCE__CNT,\n} rd_kafka_ConfigSource_t;\nconst char *rd_kafka_ConfigSource_name(rd_kafka_ConfigSource_t confsource);\ntypedef struct rd_kafka_ConfigEntry_s rd_kafka_ConfigEntry_t;\nconst char *rd_kafka_ConfigEntry_name(const rd_kafka_ConfigEntry_t *entry);\nconst char *rd_kafka_ConfigEntry_value(const rd_kafka_ConfigEntry_t *entry);\nrd_kafka_ConfigSource_t rd_kafka_ConfigEntry_source(const rd_kafka_ConfigEntry_t *entry);\nint rd_kafka_ConfigEntry_is_read_only(const rd_kafka_ConfigEntry_t *entry);\nint rd_kafka_ConfigEntry_is_default(const rd_kafka_ConfigEntry_t *entry);\nint rd_kafka_ConfigEntry_is_sensitive(const rd_kafka_ConfigEntry_t *entry);\nint rd_kafka_ConfigEntry_is_synonym(const rd_kafka_ConfigEntry_t *entry);\nconst rd_kafka_ConfigEntry_t **rd_kafka_ConfigEntry_synonyms(const rd_kafka_ConfigEntry_t *entry, size_t *cntp);\ntypedef enum rd_kafka_ResourceType_t {\n  RD_KAFKA_RESOURCE_UNKNOWN = 0,\n  RD_KAFKA_RESOURCE_ANY = 1,\n  RD_KAFKA_RESOURCE_TOPIC = 2,\n  RD_KAFKA_RESOURCE_GROUP = 3,\n  RD_KAFKA_RESOURCE_BROKER = 4,\n  RD_KAFKA_RESOURCE__CNT,\n} rd_kafka_ResourceType_t;\nconst char *rd_kafka_ResourceType_name(rd_kafka_ResourceType_t restype);\ntypedef struct rd_kafka_ConfigResource_s rd_kafka_ConfigResource_t;\nrd_kafka_ConfigResource_t *rd_kafka_ConfigResource_new(rd_kafka_ResourceType_t restype, const char *resname);\nvoid rd_kafka_ConfigResource_destroy(rd_kafka_ConfigResource_t *config);\nvoid rd_kafka_ConfigResource_destroy_array(rd_kafka_ConfigResource_t **config, size_t config_cnt);\nrd_kafka_resp_err_t rd_kafka_ConfigResource_set_config(rd_kafka_ConfigResource_t *config, const char *name, const char *value);\nconst rd_kafka_ConfigEntry_t **rd_kafka_ConfigResource_configs(const rd_kafka_ConfigResource_t *config, size_t *cntp);\nrd_kafka_ResourceType_t rd_kafka_ConfigResource_type(const rd_kafka_ConfigResource_t *config);\nconst char *rd_kafka_ConfigResource_name(const rd_kafka_ConfigResource_t *config);\nrd_kafka_resp_err_t rd_kafka_ConfigResource_error(const rd_kafka_ConfigResource_t *config);\nconst char *rd_kafka_ConfigResource_error_string(const rd_kafka_ConfigResource_t *config);\nvoid rd_kafka_AlterConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_ConfigResource_t **rd_kafka_AlterConfigs_result_resources(const rd_kafka_AlterConfigs_result_t *result, size_t *cntp);\nvoid rd_kafka_DescribeConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_ConfigResource_t **rd_kafka_DescribeConfigs_result_resources(const rd_kafka_DescribeConfigs_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_DeleteRecords_s rd_kafka_DeleteRecords_t;\nrd_kafka_DeleteRecords_t *rd_kafka_DeleteRecords_new(const rd_kafka_topic_partition_list_t *before_offsets);\nvoid rd_kafka_DeleteRecords_destroy(rd_kafka_DeleteRecords_t *del_records);\nvoid rd_kafka_DeleteRecords_destroy_array(rd_kafka_DeleteRecords_t **del_records, size_t del_record_cnt);\nvoid rd_kafka_DeleteRecords(rd_kafka_t *rk, rd_kafka_DeleteRecords_t **del_records, size_t del_record_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_topic_partition_list_t *rd_kafka_DeleteRecords_result_offsets(const rd_kafka_DeleteRecords_result_t *result);\ntypedef struct rd_kafka_DeleteGroup_s rd_kafka_DeleteGroup_t;\nrd_kafka_DeleteGroup_t *rd_kafka_DeleteGroup_new(const char *group);\nvoid rd_kafka_DeleteGroup_destroy(rd_kafka_DeleteGroup_t *del_group);\nvoid rd_kafka_DeleteGroup_destroy_array(rd_kafka_DeleteGroup_t **del_groups, size_t del_group_cnt);\nvoid rd_kafka_DeleteGroups(rd_kafka_t *rk, rd_kafka_DeleteGroup_t **del_groups, size_t del_group_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_group_result_t **rd_kafka_DeleteGroups_result_groups(const rd_kafka_DeleteGroups_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_DeleteConsumerGroupOffsets_s rd_kafka_DeleteConsumerGroupOffsets_t;\nrd_kafka_DeleteConsumerGroupOffsets_t *rd_kafka_DeleteConsumerGroupOffsets_new(const char *group, const rd_kafka_topic_partition_list_t *partitions);\nvoid rd_kafka_DeleteConsumerGroupOffsets_destroy(rd_kafka_DeleteConsumerGroupOffsets_t *del_grpoffsets);\nvoid rd_kafka_DeleteConsumerGroupOffsets_destroy_array(rd_kafka_DeleteConsumerGroupOffsets_t **del_grpoffsets, size_t del_grpoffset_cnt);\nvoid rd_kafka_DeleteConsumerGroupOffsets(rd_kafka_t *rk, rd_kafka_DeleteConsumerGroupOffsets_t **del_grpoffsets, size_t del_grpoffsets_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_group_result_t **rd_kafka_DeleteConsumerGroupOffsets_result_groups(const rd_kafka_DeleteConsumerGroupOffsets_result_t *result, size_t *cntp);\nrd_kafka_resp_err_t rd_kafka_oauthbearer_set_token(rd_kafka_t *rk, const char *token_value, int64_t md_lifetime_ms, const char *md_principal_name, const char **extensions, size_t extension_size, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_oauthbearer_set_token_failure(rd_kafka_t *rk, const char *errstr);\nrd_kafka_error_t *rd_kafka_init_transactions(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_error_t *rd_kafka_begin_transaction(rd_kafka_t *rk);\nrd_kafka_error_t *rd_kafka_send_offsets_to_transaction(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, const rd_kafka_consumer_group_metadata_t *cgmetadata, int timeout_ms);\nrd_kafka_error_t *rd_kafka_commit_transaction(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_error_t *rd_kafka_abort_transaction(rd_kafka_t *rk, int timeout_ms);\ntypedef struct rd_kafka_mock_cluster_s rd_kafka_mock_cluster_t;\nrd_kafka_mock_cluster_t *rd_kafka_mock_cluster_new(rd_kafka_t *rk, int broker_cnt);\nvoid rd_kafka_mock_cluster_destroy(rd_kafka_mock_cluster_t *mcluster);\nrd_kafka_t *rd_kafka_mock_cluster_handle(const rd_kafka_mock_cluster_t *mcluster);\nrd_kafka_mock_cluster_t *rd_kafka_handle_mock_cluster(const rd_kafka_t *rk);\nconst char *rd_kafka_mock_cluster_bootstraps(const rd_kafka_mock_cluster_t *mcluster);\nvoid rd_kafka_mock_clear_request_errors(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey);\nvoid rd_kafka_mock_push_request_errors(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, size_t cnt, ...);\nvoid rd_kafka_mock_push_request_errors_array(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, size_t cnt, const rd_kafka_resp_err_t *errors);\nrd_kafka_resp_err_t rd_kafka_mock_broker_push_request_error_rtts(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int16_t ApiKey, size_t cnt, ...);\nvoid rd_kafka_mock_topic_set_error(rd_kafka_mock_cluster_t *mcluster, const char *topic, rd_kafka_resp_err_t err);\nrd_kafka_resp_err_t rd_kafka_mock_topic_create(rd_kafka_mock_cluster_t *mcluster, const char *topic, int partition_cnt, int replication_factor);\nrd_kafka_resp_err_t rd_kafka_mock_partition_set_leader(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id);\nrd_kafka_resp_err_t rd_kafka_mock_partition_set_follower(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id);\nrd_kafka_resp_err_t rd_kafka_mock_partition_set_follower_wmarks(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int64_t lo, int64_t hi);\nrd_kafka_resp_err_t rd_kafka_mock_broker_set_down(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id);\nrd_kafka_resp_err_t rd_kafka_mock_broker_set_up(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id);\nrd_kafka_resp_err_t rd_kafka_mock_broker_set_rtt(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int rtt_ms);\nrd_kafka_resp_err_t rd_kafka_mock_broker_set_rack(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, const char *rack);\nrd_kafka_resp_err_t rd_kafka_mock_coordinator_set(rd_kafka_mock_cluster_t *mcluster, const char *key_type, const char *key, int32_t broker_id);\nrd_kafka_resp_err_t rd_kafka_mock_set_apiversion(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, int16_t MinVersion, int16_t MaxVersion);\n'\n</code></pre> rdkafka.h, rdkafka_mock.h</p>"},{"location":"api/constants/#rd_kafka_version_19","title":"RD_KAFKA_VERSION","text":"<pre><code>public RD_KAFKA_VERSION = 17367295\n</code></pre> <p>librdkafka version </p> <p>Interpreted as hex <code>MM.mm.rr.xx</code>:</p> <ul> <li>MM = Major</li> <li>mm = minor</li> <li>rr = revision</li> <li>xx = pre-release id (0xff is the final release)</li> </ul> <p>E.g.: <code>0x000801ff</code> = 0.8.1</p> RemarksThis value should only be used during compile time, for runtime checks of version use rd_kafka_version()  <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_unsupported_compression_type_19","title":"RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE","text":"<pre><code>public RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76\n</code></pre> <p>Unsupported compression type </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_end_all_19","title":"RD_KAFKA_RESP_ERR_END_ALL","text":"<p><pre><code>public RD_KAFKA_RESP_ERR_END_ALL = 98\n</code></pre> enum rd_kafka_resp_err_t</p>"},{"location":"api/constants/#rd_kafka_admin_op__cnt_19","title":"RD_KAFKA_ADMIN_OP__CNT","text":"<pre><code>public RD_KAFKA_ADMIN_OP__CNT = 12\n</code></pre> <p>Number of ops defined </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe </li> </ul>"},{"location":"api/constants/#rd_kafka_resource__cnt_19","title":"RD_KAFKA_RESOURCE__CNT","text":"<pre><code>public RD_KAFKA_RESOURCE__CNT = 5\n</code></pre> <p>Number of resource types defined </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#acca83a66d7783ff7683ed2691cc907c9 </li> </ul>"},{"location":"api/constants/#rd_kafka_cdef_19","title":"RD_KAFKA_CDEF","text":"<p><pre><code>public RD_KAFKA_CDEF = 'typedef long int ssize_t;\ntypedef struct _IO_FILE FILE;\ntypedef long int mode_t;\ntypedef signed int int16_t;\ntypedef unsigned int uint16_t;\ntypedef signed int int32_t;\ntypedef signed long int int64_t;\nint rd_kafka_version(void);\nconst char *rd_kafka_version_str(void);\ntypedef enum rd_kafka_type_t {\n  RD_KAFKA_PRODUCER,\n  RD_KAFKA_CONSUMER,\n} rd_kafka_type_t;\ntypedef enum rd_kafka_timestamp_type_t {\n  RD_KAFKA_TIMESTAMP_NOT_AVAILABLE,\n  RD_KAFKA_TIMESTAMP_CREATE_TIME,\n  RD_KAFKA_TIMESTAMP_LOG_APPEND_TIME,\n} rd_kafka_timestamp_type_t;\nconst char *rd_kafka_get_debug_contexts(void);\ntypedef struct rd_kafka_s rd_kafka_t;\ntypedef struct rd_kafka_topic_s rd_kafka_topic_t;\ntypedef struct rd_kafka_conf_s rd_kafka_conf_t;\ntypedef struct rd_kafka_topic_conf_s rd_kafka_topic_conf_t;\ntypedef struct rd_kafka_queue_s rd_kafka_queue_t;\ntypedef struct rd_kafka_op_s rd_kafka_event_t;\ntypedef struct rd_kafka_topic_result_s rd_kafka_topic_result_t;\ntypedef struct rd_kafka_consumer_group_metadata_s rd_kafka_consumer_group_metadata_t;\ntypedef struct rd_kafka_error_s {\n  unsigned int code;\n  char *errstr;\n  unsigned char fatal;\n  unsigned char retriable;\n  unsigned char txn_requires_abort;\n} rd_kafka_error_t;\ntypedef struct rd_kafka_headers_s rd_kafka_headers_t;\ntypedef struct rd_kafka_group_result_s rd_kafka_group_result_t;\ntypedef struct rd_kafka_acl_result_s rd_kafka_acl_result_t;\ntypedef enum {\n  RD_KAFKA_RESP_ERR__BEGIN = (- 200),\n  RD_KAFKA_RESP_ERR__BAD_MSG = (- 199),\n  RD_KAFKA_RESP_ERR__BAD_COMPRESSION = (- 198),\n  RD_KAFKA_RESP_ERR__DESTROY = (- 197),\n  RD_KAFKA_RESP_ERR__FAIL = (- 196),\n  RD_KAFKA_RESP_ERR__TRANSPORT = (- 195),\n  RD_KAFKA_RESP_ERR__CRIT_SYS_RESOURCE = (- 194),\n  RD_KAFKA_RESP_ERR__RESOLVE = (- 193),\n  RD_KAFKA_RESP_ERR__MSG_TIMED_OUT = (- 192),\n  RD_KAFKA_RESP_ERR__PARTITION_EOF = (- 191),\n  RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION = (- 190),\n  RD_KAFKA_RESP_ERR__FS = (- 189),\n  RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC = (- 188),\n  RD_KAFKA_RESP_ERR__ALL_BROKERS_DOWN = (- 187),\n  RD_KAFKA_RESP_ERR__INVALID_ARG = (- 186),\n  RD_KAFKA_RESP_ERR__TIMED_OUT = (- 185),\n  RD_KAFKA_RESP_ERR__QUEUE_FULL = (- 184),\n  RD_KAFKA_RESP_ERR__ISR_INSUFF = (- 183),\n  RD_KAFKA_RESP_ERR__NODE_UPDATE = (- 182),\n  RD_KAFKA_RESP_ERR__SSL = (- 181),\n  RD_KAFKA_RESP_ERR__WAIT_COORD = (- 180),\n  RD_KAFKA_RESP_ERR__UNKNOWN_GROUP = (- 179),\n  RD_KAFKA_RESP_ERR__IN_PROGRESS = (- 178),\n  RD_KAFKA_RESP_ERR__PREV_IN_PROGRESS = (- 177),\n  RD_KAFKA_RESP_ERR__EXISTING_SUBSCRIPTION = (- 176),\n  RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS = (- 175),\n  RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS = (- 174),\n  RD_KAFKA_RESP_ERR__CONFLICT = (- 173),\n  RD_KAFKA_RESP_ERR__STATE = (- 172),\n  RD_KAFKA_RESP_ERR__UNKNOWN_PROTOCOL = (- 171),\n  RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED = (- 170),\n  RD_KAFKA_RESP_ERR__AUTHENTICATION = (- 169),\n  RD_KAFKA_RESP_ERR__NO_OFFSET = (- 168),\n  RD_KAFKA_RESP_ERR__OUTDATED = (- 167),\n  RD_KAFKA_RESP_ERR__TIMED_OUT_QUEUE = (- 166),\n  RD_KAFKA_RESP_ERR__UNSUPPORTED_FEATURE = (- 165),\n  RD_KAFKA_RESP_ERR__WAIT_CACHE = (- 164),\n  RD_KAFKA_RESP_ERR__INTR = (- 163),\n  RD_KAFKA_RESP_ERR__KEY_SERIALIZATION = (- 162),\n  RD_KAFKA_RESP_ERR__VALUE_SERIALIZATION = (- 161),\n  RD_KAFKA_RESP_ERR__KEY_DESERIALIZATION = (- 160),\n  RD_KAFKA_RESP_ERR__VALUE_DESERIALIZATION = (- 159),\n  RD_KAFKA_RESP_ERR__PARTIAL = (- 158),\n  RD_KAFKA_RESP_ERR__READ_ONLY = (- 157),\n  RD_KAFKA_RESP_ERR__NOENT = (- 156),\n  RD_KAFKA_RESP_ERR__UNDERFLOW = (- 155),\n  RD_KAFKA_RESP_ERR__INVALID_TYPE = (- 154),\n  RD_KAFKA_RESP_ERR__RETRY = (- 153),\n  RD_KAFKA_RESP_ERR__PURGE_QUEUE = (- 152),\n  RD_KAFKA_RESP_ERR__PURGE_INFLIGHT = (- 151),\n  RD_KAFKA_RESP_ERR__FATAL = (- 150),\n  RD_KAFKA_RESP_ERR__INCONSISTENT = (- 149),\n  RD_KAFKA_RESP_ERR__GAPLESS_GUARANTEE = (- 148),\n  RD_KAFKA_RESP_ERR__MAX_POLL_EXCEEDED = (- 147),\n  RD_KAFKA_RESP_ERR__UNKNOWN_BROKER = (- 146),\n  RD_KAFKA_RESP_ERR__NOT_CONFIGURED = (- 145),\n  RD_KAFKA_RESP_ERR__FENCED = (- 144),\n  RD_KAFKA_RESP_ERR__APPLICATION = (- 143),\n  RD_KAFKA_RESP_ERR__ASSIGNMENT_LOST = (- 142),\n  RD_KAFKA_RESP_ERR__NOOP = (- 141),\n  RD_KAFKA_RESP_ERR__AUTO_OFFSET_RESET = (- 140),\n  RD_KAFKA_RESP_ERR__END = (- 100),\n  RD_KAFKA_RESP_ERR_UNKNOWN = (- 1),\n  RD_KAFKA_RESP_ERR_NO_ERROR = 0,\n  RD_KAFKA_RESP_ERR_OFFSET_OUT_OF_RANGE = 1,\n  RD_KAFKA_RESP_ERR_INVALID_MSG = 2,\n  RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART = 3,\n  RD_KAFKA_RESP_ERR_INVALID_MSG_SIZE = 4,\n  RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE = 5,\n  RD_KAFKA_RESP_ERR_NOT_LEADER_FOR_PARTITION = 6,\n  RD_KAFKA_RESP_ERR_REQUEST_TIMED_OUT = 7,\n  RD_KAFKA_RESP_ERR_BROKER_NOT_AVAILABLE = 8,\n  RD_KAFKA_RESP_ERR_REPLICA_NOT_AVAILABLE = 9,\n  RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE = 10,\n  RD_KAFKA_RESP_ERR_STALE_CTRL_EPOCH = 11,\n  RD_KAFKA_RESP_ERR_OFFSET_METADATA_TOO_LARGE = 12,\n  RD_KAFKA_RESP_ERR_NETWORK_EXCEPTION = 13,\n  RD_KAFKA_RESP_ERR_COORDINATOR_LOAD_IN_PROGRESS = 14,\n  RD_KAFKA_RESP_ERR_COORDINATOR_NOT_AVAILABLE = 15,\n  RD_KAFKA_RESP_ERR_NOT_COORDINATOR = 16,\n  RD_KAFKA_RESP_ERR_TOPIC_EXCEPTION = 17,\n  RD_KAFKA_RESP_ERR_RECORD_LIST_TOO_LARGE = 18,\n  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS = 19,\n  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS_AFTER_APPEND = 20,\n  RD_KAFKA_RESP_ERR_INVALID_REQUIRED_ACKS = 21,\n  RD_KAFKA_RESP_ERR_ILLEGAL_GENERATION = 22,\n  RD_KAFKA_RESP_ERR_INCONSISTENT_GROUP_PROTOCOL = 23,\n  RD_KAFKA_RESP_ERR_INVALID_GROUP_ID = 24,\n  RD_KAFKA_RESP_ERR_UNKNOWN_MEMBER_ID = 25,\n  RD_KAFKA_RESP_ERR_INVALID_SESSION_TIMEOUT = 26,\n  RD_KAFKA_RESP_ERR_REBALANCE_IN_PROGRESS = 27,\n  RD_KAFKA_RESP_ERR_INVALID_COMMIT_OFFSET_SIZE = 28,\n  RD_KAFKA_RESP_ERR_TOPIC_AUTHORIZATION_FAILED = 29,\n  RD_KAFKA_RESP_ERR_GROUP_AUTHORIZATION_FAILED = 30,\n  RD_KAFKA_RESP_ERR_CLUSTER_AUTHORIZATION_FAILED = 31,\n  RD_KAFKA_RESP_ERR_INVALID_TIMESTAMP = 32,\n  RD_KAFKA_RESP_ERR_UNSUPPORTED_SASL_MECHANISM = 33,\n  RD_KAFKA_RESP_ERR_ILLEGAL_SASL_STATE = 34,\n  RD_KAFKA_RESP_ERR_UNSUPPORTED_VERSION = 35,\n  RD_KAFKA_RESP_ERR_TOPIC_ALREADY_EXISTS = 36,\n  RD_KAFKA_RESP_ERR_INVALID_PARTITIONS = 37,\n  RD_KAFKA_RESP_ERR_INVALID_REPLICATION_FACTOR = 38,\n  RD_KAFKA_RESP_ERR_INVALID_REPLICA_ASSIGNMENT = 39,\n  RD_KAFKA_RESP_ERR_INVALID_CONFIG = 40,\n  RD_KAFKA_RESP_ERR_NOT_CONTROLLER = 41,\n  RD_KAFKA_RESP_ERR_INVALID_REQUEST = 42,\n  RD_KAFKA_RESP_ERR_UNSUPPORTED_FOR_MESSAGE_FORMAT = 43,\n  RD_KAFKA_RESP_ERR_POLICY_VIOLATION = 44,\n  RD_KAFKA_RESP_ERR_OUT_OF_ORDER_SEQUENCE_NUMBER = 45,\n  RD_KAFKA_RESP_ERR_DUPLICATE_SEQUENCE_NUMBER = 46,\n  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_EPOCH = 47,\n  RD_KAFKA_RESP_ERR_INVALID_TXN_STATE = 48,\n  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_ID_MAPPING = 49,\n  RD_KAFKA_RESP_ERR_INVALID_TRANSACTION_TIMEOUT = 50,\n  RD_KAFKA_RESP_ERR_CONCURRENT_TRANSACTIONS = 51,\n  RD_KAFKA_RESP_ERR_TRANSACTION_COORDINATOR_FENCED = 52,\n  RD_KAFKA_RESP_ERR_TRANSACTIONAL_ID_AUTHORIZATION_FAILED = 53,\n  RD_KAFKA_RESP_ERR_SECURITY_DISABLED = 54,\n  RD_KAFKA_RESP_ERR_OPERATION_NOT_ATTEMPTED = 55,\n  RD_KAFKA_RESP_ERR_KAFKA_STORAGE_ERROR = 56,\n  RD_KAFKA_RESP_ERR_LOG_DIR_NOT_FOUND = 57,\n  RD_KAFKA_RESP_ERR_SASL_AUTHENTICATION_FAILED = 58,\n  RD_KAFKA_RESP_ERR_UNKNOWN_PRODUCER_ID = 59,\n  RD_KAFKA_RESP_ERR_REASSIGNMENT_IN_PROGRESS = 60,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTH_DISABLED = 61,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_NOT_FOUND = 62,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_OWNER_MISMATCH = 63,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_REQUEST_NOT_ALLOWED = 64,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTHORIZATION_FAILED = 65,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_EXPIRED = 66,\n  RD_KAFKA_RESP_ERR_INVALID_PRINCIPAL_TYPE = 67,\n  RD_KAFKA_RESP_ERR_NON_EMPTY_GROUP = 68,\n  RD_KAFKA_RESP_ERR_GROUP_ID_NOT_FOUND = 69,\n  RD_KAFKA_RESP_ERR_FETCH_SESSION_ID_NOT_FOUND = 70,\n  RD_KAFKA_RESP_ERR_INVALID_FETCH_SESSION_EPOCH = 71,\n  RD_KAFKA_RESP_ERR_LISTENER_NOT_FOUND = 72,\n  RD_KAFKA_RESP_ERR_TOPIC_DELETION_DISABLED = 73,\n  RD_KAFKA_RESP_ERR_FENCED_LEADER_EPOCH = 74,\n  RD_KAFKA_RESP_ERR_UNKNOWN_LEADER_EPOCH = 75,\n  RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76,\n  RD_KAFKA_RESP_ERR_STALE_BROKER_EPOCH = 77,\n  RD_KAFKA_RESP_ERR_OFFSET_NOT_AVAILABLE = 78,\n  RD_KAFKA_RESP_ERR_MEMBER_ID_REQUIRED = 79,\n  RD_KAFKA_RESP_ERR_PREFERRED_LEADER_NOT_AVAILABLE = 80,\n  RD_KAFKA_RESP_ERR_GROUP_MAX_SIZE_REACHED = 81,\n  RD_KAFKA_RESP_ERR_FENCED_INSTANCE_ID = 82,\n  RD_KAFKA_RESP_ERR_ELIGIBLE_LEADERS_NOT_AVAILABLE = 83,\n  RD_KAFKA_RESP_ERR_ELECTION_NOT_NEEDED = 84,\n  RD_KAFKA_RESP_ERR_NO_REASSIGNMENT_IN_PROGRESS = 85,\n  RD_KAFKA_RESP_ERR_GROUP_SUBSCRIBED_TO_TOPIC = 86,\n  RD_KAFKA_RESP_ERR_INVALID_RECORD = 87,\n  RD_KAFKA_RESP_ERR_UNSTABLE_OFFSET_COMMIT = 88,\n  RD_KAFKA_RESP_ERR_THROTTLING_QUOTA_EXCEEDED = 89,\n  RD_KAFKA_RESP_ERR_PRODUCER_FENCED = 90,\n  RD_KAFKA_RESP_ERR_RESOURCE_NOT_FOUND = 91,\n  RD_KAFKA_RESP_ERR_DUPLICATE_RESOURCE = 92,\n  RD_KAFKA_RESP_ERR_UNACCEPTABLE_CREDENTIAL = 93,\n  RD_KAFKA_RESP_ERR_INCONSISTENT_VOTER_SET = 94,\n  RD_KAFKA_RESP_ERR_INVALID_UPDATE_VERSION = 95,\n  RD_KAFKA_RESP_ERR_FEATURE_UPDATE_FAILED = 96,\n  RD_KAFKA_RESP_ERR_PRINCIPAL_DESERIALIZATION_FAILURE = 97,\n  RD_KAFKA_RESP_ERR_END_ALL,\n} rd_kafka_resp_err_t;\nstruct rd_kafka_err_desc {\n  rd_kafka_resp_err_t code;\n  char *name;\n  char *desc;\n};\nvoid rd_kafka_get_err_descs(const struct rd_kafka_err_desc **errdescs, size_t *cntp);\nconst char *rd_kafka_err2str(rd_kafka_resp_err_t err);\nconst char *rd_kafka_err2name(rd_kafka_resp_err_t err);\nrd_kafka_resp_err_t rd_kafka_last_error(void);\nrd_kafka_resp_err_t rd_kafka_errno2err(int errnox);\nint rd_kafka_errno(void);\nrd_kafka_resp_err_t rd_kafka_fatal_error(rd_kafka_t *rk, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_test_fatal_error(rd_kafka_t *rk, rd_kafka_resp_err_t err, const char *reason);\nrd_kafka_resp_err_t rd_kafka_error_code(const rd_kafka_error_t *error);\nconst char *rd_kafka_error_name(const rd_kafka_error_t *error);\nconst char *rd_kafka_error_string(const rd_kafka_error_t *error);\nint rd_kafka_error_is_fatal(const rd_kafka_error_t *error);\nint rd_kafka_error_is_retriable(const rd_kafka_error_t *error);\nint rd_kafka_error_txn_requires_abort(const rd_kafka_error_t *error);\nvoid rd_kafka_error_destroy(rd_kafka_error_t *error);\nrd_kafka_error_t *rd_kafka_error_new(rd_kafka_resp_err_t code, const char *fmt, ...);\ntypedef struct rd_kafka_topic_partition_s {\n  char *topic;\n  int32_t partition;\n  int64_t offset;\n  void *metadata;\n  size_t metadata_size;\n  void *opaque;\n  rd_kafka_resp_err_t err;\n  void *_private;\n} rd_kafka_topic_partition_t;\nvoid rd_kafka_topic_partition_destroy(rd_kafka_topic_partition_t *rktpar);\ntypedef struct rd_kafka_topic_partition_list_s {\n  int cnt;\n  int size;\n  rd_kafka_topic_partition_t *elems;\n} rd_kafka_topic_partition_list_t;\nrd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_new(int size);\nvoid rd_kafka_topic_partition_list_destroy(rd_kafka_topic_partition_list_t *rkparlist);\nrd_kafka_topic_partition_t *rd_kafka_topic_partition_list_add(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);\nvoid rd_kafka_topic_partition_list_add_range(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t start, int32_t stop);\nint rd_kafka_topic_partition_list_del(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);\nint rd_kafka_topic_partition_list_del_by_idx(rd_kafka_topic_partition_list_t *rktparlist, int idx);\nrd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_copy(const rd_kafka_topic_partition_list_t *src);\nrd_kafka_resp_err_t rd_kafka_topic_partition_list_set_offset(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition, int64_t offset);\nrd_kafka_topic_partition_t *rd_kafka_topic_partition_list_find(const rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);\nvoid rd_kafka_topic_partition_list_sort(rd_kafka_topic_partition_list_t *rktparlist, int (*cmp)(const void *a, const void *b, void *cmp_opaque), void *cmp_opaque);\ntypedef enum rd_kafka_vtype_t {\n  RD_KAFKA_VTYPE_END,\n  RD_KAFKA_VTYPE_TOPIC,\n  RD_KAFKA_VTYPE_RKT,\n  RD_KAFKA_VTYPE_PARTITION,\n  RD_KAFKA_VTYPE_VALUE,\n  RD_KAFKA_VTYPE_KEY,\n  RD_KAFKA_VTYPE_OPAQUE,\n  RD_KAFKA_VTYPE_MSGFLAGS,\n  RD_KAFKA_VTYPE_TIMESTAMP,\n  RD_KAFKA_VTYPE_HEADER,\n  RD_KAFKA_VTYPE_HEADERS,\n} rd_kafka_vtype_t;\ntypedef struct rd_kafka_vu_s {\n  rd_kafka_vtype_t vtype;\n  union {\n    char *cstr;\n    rd_kafka_topic_t *rkt;\n    int i;\n    int32_t i32;\n    int64_t i64;\n    struct {\n      void *ptr;\n      size_t size;\n    } mem;\n    struct {\n      char *name;\n      void *val;\n      ssize_t size;\n    } header;\n    rd_kafka_headers_t *headers;\n    void *ptr;\n    char _pad[64];\n  } u;\n} rd_kafka_vu_t;\nrd_kafka_headers_t *rd_kafka_headers_new(size_t initial_count);\nvoid rd_kafka_headers_destroy(rd_kafka_headers_t *hdrs);\nrd_kafka_headers_t *rd_kafka_headers_copy(const rd_kafka_headers_t *src);\nrd_kafka_resp_err_t rd_kafka_header_add(rd_kafka_headers_t *hdrs, const char *name, ssize_t name_size, const void *value, ssize_t value_size);\nrd_kafka_resp_err_t rd_kafka_header_remove(rd_kafka_headers_t *hdrs, const char *name);\nrd_kafka_resp_err_t rd_kafka_header_get_last(const rd_kafka_headers_t *hdrs, const char *name, const void **valuep, size_t *sizep);\nrd_kafka_resp_err_t rd_kafka_header_get(const rd_kafka_headers_t *hdrs, size_t idx, const char *name, const void **valuep, size_t *sizep);\nrd_kafka_resp_err_t rd_kafka_header_get_all(const rd_kafka_headers_t *hdrs, size_t idx, const char **namep, const void **valuep, size_t *sizep);\ntypedef struct rd_kafka_message_s {\n  rd_kafka_resp_err_t err;\n  rd_kafka_topic_t *rkt;\n  int32_t partition;\n  void *payload;\n  size_t len;\n  void *key;\n  size_t key_len;\n  int64_t offset;\n  void *_private;\n} rd_kafka_message_t;\nvoid rd_kafka_message_destroy(rd_kafka_message_t *rkmessage);\nconst char *rd_kafka_message_errstr(const rd_kafka_message_t *rkmessage);\nint64_t rd_kafka_message_timestamp(const rd_kafka_message_t *rkmessage, rd_kafka_timestamp_type_t *tstype);\nint64_t rd_kafka_message_latency(const rd_kafka_message_t *rkmessage);\nint32_t rd_kafka_message_broker_id(const rd_kafka_message_t *rkmessage);\nrd_kafka_resp_err_t rd_kafka_message_headers(const rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);\nrd_kafka_resp_err_t rd_kafka_message_detach_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);\nvoid rd_kafka_message_set_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t *hdrs);\nsize_t rd_kafka_header_cnt(const rd_kafka_headers_t *hdrs);\ntypedef enum {\n  RD_KAFKA_MSG_STATUS_NOT_PERSISTED = 0,\n  RD_KAFKA_MSG_STATUS_POSSIBLY_PERSISTED = 1,\n  RD_KAFKA_MSG_STATUS_PERSISTED = 2,\n} rd_kafka_msg_status_t;\nrd_kafka_msg_status_t rd_kafka_message_status(const rd_kafka_message_t *rkmessage);\ntypedef enum {\n  RD_KAFKA_CONF_UNKNOWN = (- 2),\n  RD_KAFKA_CONF_INVALID = (- 1),\n  RD_KAFKA_CONF_OK = 0,\n} rd_kafka_conf_res_t;\nrd_kafka_conf_t *rd_kafka_conf_new(void);\nvoid rd_kafka_conf_destroy(rd_kafka_conf_t *conf);\nrd_kafka_conf_t *rd_kafka_conf_dup(const rd_kafka_conf_t *conf);\nrd_kafka_conf_t *rd_kafka_conf_dup_filter(const rd_kafka_conf_t *conf, size_t filter_cnt, const char **filter);\nconst rd_kafka_conf_t *rd_kafka_conf(rd_kafka_t *rk);\nrd_kafka_conf_res_t rd_kafka_conf_set(rd_kafka_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);\nvoid rd_kafka_conf_set_events(rd_kafka_conf_t *conf, int events);\nvoid rd_kafka_conf_set_background_event_cb(rd_kafka_conf_t *conf, void (*event_cb)(rd_kafka_t *rk, rd_kafka_event_t *rkev, void *opaque));\nvoid rd_kafka_conf_set_dr_cb(rd_kafka_conf_t *conf, void (*dr_cb)(rd_kafka_t *rk, void *payload, size_t len, rd_kafka_resp_err_t err, void *opaque, void *msg_opaque));\nvoid rd_kafka_conf_set_dr_msg_cb(rd_kafka_conf_t *conf, void (*dr_msg_cb)(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, void *opaque));\nvoid rd_kafka_conf_set_consume_cb(rd_kafka_conf_t *conf, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *opaque));\nvoid rd_kafka_conf_set_rebalance_cb(rd_kafka_conf_t *conf, void (*rebalance_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *partitions, void *opaque));\nvoid rd_kafka_conf_set_offset_commit_cb(rd_kafka_conf_t *conf, void (*offset_commit_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *opaque));\nvoid rd_kafka_conf_set_error_cb(rd_kafka_conf_t *conf, void (*error_cb)(rd_kafka_t *rk, int err, const char *reason, void *opaque));\nvoid rd_kafka_conf_set_throttle_cb(rd_kafka_conf_t *conf, void (*throttle_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int throttle_time_ms, void *opaque));\nvoid rd_kafka_conf_set_log_cb(rd_kafka_conf_t *conf, void (*log_cb)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));\nvoid rd_kafka_conf_set_stats_cb(rd_kafka_conf_t *conf, int (*stats_cb)(rd_kafka_t *rk, char *json, size_t json_len, void *opaque));\nvoid rd_kafka_conf_set_oauthbearer_token_refresh_cb(rd_kafka_conf_t *conf, void (*oauthbearer_token_refresh_cb)(rd_kafka_t *rk, const char *oauthbearer_config, void *opaque));\nvoid rd_kafka_conf_enable_sasl_queue(rd_kafka_conf_t *conf, int enable);\nvoid rd_kafka_conf_set_socket_cb(rd_kafka_conf_t *conf, int (*socket_cb)(int domain, int type, int protocol, void *opaque));\nvoid rd_kafka_conf_set_connect_cb(rd_kafka_conf_t *conf, int (*connect_cb)(int sockfd, const struct sockaddr *addr, int addrlen, const char *id, void *opaque));\nvoid rd_kafka_conf_set_closesocket_cb(rd_kafka_conf_t *conf, int (*closesocket_cb)(int sockfd, void *opaque));\nrd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert_verify_cb(rd_kafka_conf_t *conf, int (*ssl_cert_verify_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int *x509_error, int depth, const char *buf, size_t size, char *errstr, size_t errstr_size, void *opaque));\ntypedef enum rd_kafka_cert_type_t {\n  RD_KAFKA_CERT_PUBLIC_KEY,\n  RD_KAFKA_CERT_PRIVATE_KEY,\n  RD_KAFKA_CERT_CA,\n  RD_KAFKA_CERT__CNT,\n} rd_kafka_cert_type_t;\ntypedef enum rd_kafka_cert_enc_t {\n  RD_KAFKA_CERT_ENC_PKCS12,\n  RD_KAFKA_CERT_ENC_DER,\n  RD_KAFKA_CERT_ENC_PEM,\n  RD_KAFKA_CERT_ENC__CNT,\n} rd_kafka_cert_enc_t;\nrd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert(rd_kafka_conf_t *conf, rd_kafka_cert_type_t cert_type, rd_kafka_cert_enc_t cert_enc, const void *buffer, size_t size, char *errstr, size_t errstr_size);\nvoid rd_kafka_conf_set_engine_callback_data(rd_kafka_conf_t *conf, void *callback_data);\nvoid rd_kafka_conf_set_opaque(rd_kafka_conf_t *conf, void *opaque);\nvoid *rd_kafka_opaque(const rd_kafka_t *rk);\nvoid rd_kafka_conf_set_default_topic_conf(rd_kafka_conf_t *conf, rd_kafka_topic_conf_t *tconf);\nrd_kafka_topic_conf_t *rd_kafka_conf_get_default_topic_conf(rd_kafka_conf_t *conf);\nrd_kafka_conf_res_t rd_kafka_conf_get(const rd_kafka_conf_t *conf, const char *name, char *dest, size_t *dest_size);\nrd_kafka_conf_res_t rd_kafka_topic_conf_get(const rd_kafka_topic_conf_t *conf, const char *name, char *dest, size_t *dest_size);\nconst char **rd_kafka_conf_dump(rd_kafka_conf_t *conf, size_t *cntp);\nconst char **rd_kafka_topic_conf_dump(rd_kafka_topic_conf_t *conf, size_t *cntp);\nvoid rd_kafka_conf_dump_free(const char **arr, size_t cnt);\nvoid rd_kafka_conf_properties_show(FILE *fp);\nrd_kafka_topic_conf_t *rd_kafka_topic_conf_new(void);\nrd_kafka_topic_conf_t *rd_kafka_topic_conf_dup(const rd_kafka_topic_conf_t *conf);\nrd_kafka_topic_conf_t *rd_kafka_default_topic_conf_dup(rd_kafka_t *rk);\nvoid rd_kafka_topic_conf_destroy(rd_kafka_topic_conf_t *topic_conf);\nrd_kafka_conf_res_t rd_kafka_topic_conf_set(rd_kafka_topic_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);\nvoid rd_kafka_topic_conf_set_opaque(rd_kafka_topic_conf_t *conf, void *rkt_opaque);\nvoid rd_kafka_topic_conf_set_partitioner_cb(rd_kafka_topic_conf_t *topic_conf, int32_t (*partitioner)(const rd_kafka_topic_t *rkt, const void *keydata, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque));\nvoid rd_kafka_topic_conf_set_msg_order_cmp(rd_kafka_topic_conf_t *topic_conf, int (*msg_order_cmp)(const rd_kafka_message_t *a, const rd_kafka_message_t *b));\nint rd_kafka_topic_partition_available(const rd_kafka_topic_t *rkt, int32_t partition);\nint32_t rd_kafka_msg_partitioner_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_consistent(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_consistent_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_murmur2(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_murmur2_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_fnv1a(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_fnv1a_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nrd_kafka_t *rd_kafka_new(rd_kafka_type_t type, rd_kafka_conf_t *conf, char *errstr, size_t errstr_size);\nvoid rd_kafka_destroy(rd_kafka_t *rk);\nvoid rd_kafka_destroy_flags(rd_kafka_t *rk, int flags);\nconst char *rd_kafka_name(const rd_kafka_t *rk);\nrd_kafka_type_t rd_kafka_type(const rd_kafka_t *rk);\nchar *rd_kafka_memberid(const rd_kafka_t *rk);\nchar *rd_kafka_clusterid(rd_kafka_t *rk, int timeout_ms);\nint32_t rd_kafka_controllerid(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_topic_t *rd_kafka_topic_new(rd_kafka_t *rk, const char *topic, rd_kafka_topic_conf_t *conf);\nvoid rd_kafka_topic_destroy(rd_kafka_topic_t *rkt);\nconst char *rd_kafka_topic_name(const rd_kafka_topic_t *rkt);\nvoid *rd_kafka_topic_opaque(const rd_kafka_topic_t *rkt);\nint rd_kafka_poll(rd_kafka_t *rk, int timeout_ms);\nvoid rd_kafka_yield(rd_kafka_t *rk);\nrd_kafka_resp_err_t rd_kafka_pause_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_resp_err_t rd_kafka_resume_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_resp_err_t rd_kafka_query_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high, int timeout_ms);\nrd_kafka_resp_err_t rd_kafka_get_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high);\nrd_kafka_resp_err_t rd_kafka_offsets_for_times(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets, int timeout_ms);\nvoid *rd_kafka_mem_calloc(rd_kafka_t *rk, size_t num, size_t size);\nvoid *rd_kafka_mem_malloc(rd_kafka_t *rk, size_t size);\nvoid rd_kafka_mem_free(rd_kafka_t *rk, void *ptr);\nrd_kafka_queue_t *rd_kafka_queue_new(rd_kafka_t *rk);\nvoid rd_kafka_queue_destroy(rd_kafka_queue_t *rkqu);\nrd_kafka_queue_t *rd_kafka_queue_get_main(rd_kafka_t *rk);\nrd_kafka_queue_t *rd_kafka_queue_get_sasl(rd_kafka_t *rk);\nrd_kafka_error_t *rd_kafka_sasl_background_callbacks_enable(rd_kafka_t *rk);\nrd_kafka_queue_t *rd_kafka_queue_get_consumer(rd_kafka_t *rk);\nrd_kafka_queue_t *rd_kafka_queue_get_partition(rd_kafka_t *rk, const char *topic, int32_t partition);\nrd_kafka_queue_t *rd_kafka_queue_get_background(rd_kafka_t *rk);\nvoid rd_kafka_queue_forward(rd_kafka_queue_t *src, rd_kafka_queue_t *dst);\nrd_kafka_resp_err_t rd_kafka_set_log_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu);\nsize_t rd_kafka_queue_length(rd_kafka_queue_t *rkqu);\nvoid rd_kafka_queue_io_event_enable(rd_kafka_queue_t *rkqu, int fd, const void *payload, size_t size);\nvoid rd_kafka_queue_cb_event_enable(rd_kafka_queue_t *rkqu, void (*event_cb)(rd_kafka_t *rk, void *qev_opaque), void *qev_opaque);\nvoid rd_kafka_queue_yield(rd_kafka_queue_t *rkqu);\nint rd_kafka_consume_start(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);\nint rd_kafka_consume_start_queue(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, rd_kafka_queue_t *rkqu);\nint rd_kafka_consume_stop(rd_kafka_topic_t *rkt, int32_t partition);\nrd_kafka_resp_err_t rd_kafka_seek(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, int timeout_ms);\nrd_kafka_error_t *rd_kafka_seek_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms);\nrd_kafka_message_t *rd_kafka_consume(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms);\nssize_t rd_kafka_consume_batch(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);\nint rd_kafka_consume_callback(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);\nrd_kafka_message_t *rd_kafka_consume_queue(rd_kafka_queue_t *rkqu, int timeout_ms);\nssize_t rd_kafka_consume_batch_queue(rd_kafka_queue_t *rkqu, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);\nint rd_kafka_consume_callback_queue(rd_kafka_queue_t *rkqu, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);\nrd_kafka_resp_err_t rd_kafka_offset_store(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);\nrd_kafka_resp_err_t rd_kafka_offsets_store(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets);\nrd_kafka_resp_err_t rd_kafka_subscribe(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *topics);\nrd_kafka_resp_err_t rd_kafka_unsubscribe(rd_kafka_t *rk);\nrd_kafka_resp_err_t rd_kafka_subscription(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **topics);\nrd_kafka_message_t *rd_kafka_consumer_poll(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_resp_err_t rd_kafka_consumer_close(rd_kafka_t *rk);\nrd_kafka_error_t *rd_kafka_consumer_close_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu);\nint rd_kafka_consumer_closed(rd_kafka_t *rk);\nrd_kafka_error_t *rd_kafka_incremental_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_error_t *rd_kafka_incremental_unassign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);\nconst char *rd_kafka_rebalance_protocol(rd_kafka_t *rk);\nrd_kafka_resp_err_t rd_kafka_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_resp_err_t rd_kafka_assignment(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **partitions);\nint rd_kafka_assignment_lost(rd_kafka_t *rk);\nrd_kafka_resp_err_t rd_kafka_commit(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, int async);\nrd_kafka_resp_err_t rd_kafka_commit_message(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, int async);\nrd_kafka_resp_err_t rd_kafka_commit_queue(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_queue_t *rkqu, void (*cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *commit_opaque), void *commit_opaque);\nrd_kafka_resp_err_t rd_kafka_committed(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms);\nrd_kafka_resp_err_t rd_kafka_position(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata(rd_kafka_t *rk);\nrd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata_new(const char *group_id);\nrd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata_new_with_genid(const char *group_id, int32_t generation_id, const char *member_id, const char *group_instance_id);\nvoid rd_kafka_consumer_group_metadata_destroy(rd_kafka_consumer_group_metadata_t *);\nrd_kafka_error_t *rd_kafka_consumer_group_metadata_write(const rd_kafka_consumer_group_metadata_t *cgmd, void **bufferp, size_t *sizep);\nrd_kafka_error_t *rd_kafka_consumer_group_metadata_read(rd_kafka_consumer_group_metadata_t **cgmdp, const void *buffer, size_t size);\nint rd_kafka_produce(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, void *payload, size_t len, const void *key, size_t keylen, void *msg_opaque);\nrd_kafka_resp_err_t rd_kafka_producev(rd_kafka_t *rk, ...);\nrd_kafka_error_t *rd_kafka_produceva(rd_kafka_t *rk, const rd_kafka_vu_t *vus, size_t cnt);\nint rd_kafka_produce_batch(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, rd_kafka_message_t *rkmessages, int message_cnt);\nrd_kafka_resp_err_t rd_kafka_flush(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_resp_err_t rd_kafka_purge(rd_kafka_t *rk, int purge_flags);\ntypedef struct rd_kafka_metadata_broker {\n  int32_t id;\n  char *host;\n  int port;\n} rd_kafka_metadata_broker_t;\ntypedef struct rd_kafka_metadata_partition {\n  int32_t id;\n  rd_kafka_resp_err_t err;\n  int32_t leader;\n  int replica_cnt;\n  int32_t *replicas;\n  int isr_cnt;\n  int32_t *isrs;\n} rd_kafka_metadata_partition_t;\ntypedef struct rd_kafka_metadata_topic {\n  char *topic;\n  int partition_cnt;\n  struct rd_kafka_metadata_partition *partitions;\n  rd_kafka_resp_err_t err;\n} rd_kafka_metadata_topic_t;\ntypedef struct rd_kafka_metadata {\n  int broker_cnt;\n  struct rd_kafka_metadata_broker *brokers;\n  int topic_cnt;\n  struct rd_kafka_metadata_topic *topics;\n  int32_t orig_broker_id;\n  char *orig_broker_name;\n} rd_kafka_metadata_t;\nrd_kafka_resp_err_t rd_kafka_metadata(rd_kafka_t *rk, int all_topics, rd_kafka_topic_t *only_rkt, const struct rd_kafka_metadata **metadatap, int timeout_ms);\nvoid rd_kafka_metadata_destroy(const struct rd_kafka_metadata *metadata);\nstruct rd_kafka_group_member_info {\n  char *member_id;\n  char *client_id;\n  char *client_host;\n  void *member_metadata;\n  int member_metadata_size;\n  void *member_assignment;\n  int member_assignment_size;\n};\nstruct rd_kafka_group_info {\n  struct rd_kafka_metadata_broker broker;\n  char *group;\n  rd_kafka_resp_err_t err;\n  char *state;\n  char *protocol_type;\n  char *protocol;\n  struct rd_kafka_group_member_info *members;\n  int member_cnt;\n};\nstruct rd_kafka_group_list {\n  struct rd_kafka_group_info *groups;\n  int group_cnt;\n};\nrd_kafka_resp_err_t rd_kafka_list_groups(rd_kafka_t *rk, const char *group, const struct rd_kafka_group_list **grplistp, int timeout_ms);\nvoid rd_kafka_group_list_destroy(const struct rd_kafka_group_list *grplist);\nint rd_kafka_brokers_add(rd_kafka_t *rk, const char *brokerlist);\nvoid rd_kafka_set_logger(rd_kafka_t *rk, void (*func)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));\nvoid rd_kafka_set_log_level(rd_kafka_t *rk, int level);\nvoid rd_kafka_log_print(const rd_kafka_t *rk, int level, const char *fac, const char *buf);\nvoid rd_kafka_log_syslog(const rd_kafka_t *rk, int level, const char *fac, const char *buf);\nint rd_kafka_outq_len(rd_kafka_t *rk);\nvoid rd_kafka_dump(FILE *fp, rd_kafka_t *rk);\nint rd_kafka_thread_cnt(void);\ntypedef enum rd_kafka_thread_type_t {\n  RD_KAFKA_THREAD_MAIN,\n  RD_KAFKA_THREAD_BACKGROUND,\n  RD_KAFKA_THREAD_BROKER,\n} rd_kafka_thread_type_t;\nint rd_kafka_wait_destroyed(int timeout_ms);\nint rd_kafka_unittest(void);\nrd_kafka_resp_err_t rd_kafka_poll_set_consumer(rd_kafka_t *rk);\ntypedef int rd_kafka_event_type_t;\nrd_kafka_event_type_t rd_kafka_event_type(const rd_kafka_event_t *rkev);\nconst char *rd_kafka_event_name(const rd_kafka_event_t *rkev);\nvoid rd_kafka_event_destroy(rd_kafka_event_t *rkev);\nconst rd_kafka_message_t *rd_kafka_event_message_next(rd_kafka_event_t *rkev);\nsize_t rd_kafka_event_message_array(rd_kafka_event_t *rkev, const rd_kafka_message_t **rkmessages, size_t size);\nsize_t rd_kafka_event_message_count(rd_kafka_event_t *rkev);\nconst char *rd_kafka_event_config_string(rd_kafka_event_t *rkev);\nrd_kafka_resp_err_t rd_kafka_event_error(rd_kafka_event_t *rkev);\nconst char *rd_kafka_event_error_string(rd_kafka_event_t *rkev);\nint rd_kafka_event_error_is_fatal(rd_kafka_event_t *rkev);\nvoid *rd_kafka_event_opaque(rd_kafka_event_t *rkev);\nint rd_kafka_event_log(rd_kafka_event_t *rkev, const char **fac, const char **str, int *level);\nint rd_kafka_event_debug_contexts(rd_kafka_event_t *rkev, char *dst, size_t dstsize);\nconst char *rd_kafka_event_stats(rd_kafka_event_t *rkev);\nrd_kafka_topic_partition_list_t *rd_kafka_event_topic_partition_list(rd_kafka_event_t *rkev);\nrd_kafka_topic_partition_t *rd_kafka_event_topic_partition(rd_kafka_event_t *rkev);\ntypedef rd_kafka_event_t rd_kafka_CreateTopics_result_t;\ntypedef rd_kafka_event_t rd_kafka_DeleteTopics_result_t;\ntypedef rd_kafka_event_t rd_kafka_CreateAcls_result_t;\ntypedef rd_kafka_event_t rd_kafka_DescribeAcls_result_t;\ntypedef rd_kafka_event_t rd_kafka_DeleteAcls_result_t;\ntypedef rd_kafka_event_t rd_kafka_CreatePartitions_result_t;\ntypedef rd_kafka_event_t rd_kafka_AlterConfigs_result_t;\ntypedef rd_kafka_event_t rd_kafka_DescribeConfigs_result_t;\ntypedef rd_kafka_event_t rd_kafka_DeleteRecords_result_t;\ntypedef rd_kafka_event_t rd_kafka_DeleteGroups_result_t;\ntypedef rd_kafka_event_t rd_kafka_DeleteConsumerGroupOffsets_result_t;\nconst rd_kafka_CreateTopics_result_t *rd_kafka_event_CreateTopics_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DeleteTopics_result_t *rd_kafka_event_DeleteTopics_result(rd_kafka_event_t *rkev);\nconst rd_kafka_CreatePartitions_result_t *rd_kafka_event_CreatePartitions_result(rd_kafka_event_t *rkev);\nconst rd_kafka_AlterConfigs_result_t *rd_kafka_event_AlterConfigs_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DescribeConfigs_result_t *rd_kafka_event_DescribeConfigs_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DeleteRecords_result_t *rd_kafka_event_DeleteRecords_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DeleteGroups_result_t *rd_kafka_event_DeleteGroups_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DeleteConsumerGroupOffsets_result_t *rd_kafka_event_DeleteConsumerGroupOffsets_result(rd_kafka_event_t *rkev);\nconst rd_kafka_CreateAcls_result_t *rd_kafka_event_CreateAcls_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DescribeAcls_result_t *rd_kafka_event_DescribeAcls_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DeleteAcls_result_t *rd_kafka_event_DeleteAcls_result(rd_kafka_event_t *rkev);\nrd_kafka_event_t *rd_kafka_queue_poll(rd_kafka_queue_t *rkqu, int timeout_ms);\nint rd_kafka_queue_poll_callback(rd_kafka_queue_t *rkqu, int timeout_ms);\ntypedef rd_kafka_resp_err_t (rd_kafka_plugin_f_conf_init_t)(rd_kafka_conf_t *conf, void **plug_opaquep, char *errstr, size_t errstr_size);\ntypedef rd_kafka_conf_res_t (rd_kafka_interceptor_f_on_conf_set_t)(rd_kafka_conf_t *conf, const char *name, const char *val, char *errstr, size_t errstr_size, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_dup_t)(rd_kafka_conf_t *new_conf, const rd_kafka_conf_t *old_conf, size_t filter_cnt, const char **filter, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_destroy_t)(void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_new_t)(rd_kafka_t *rk, const rd_kafka_conf_t *conf, void *ic_opaque, char *errstr, size_t errstr_size);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_destroy_t)(rd_kafka_t *rk, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_send_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_acknowledgement_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_consume_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_commit_t)(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_resp_err_t err, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_request_sent_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_response_received_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, int64_t rtt, rd_kafka_resp_err_t err, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_start_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_exit_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_set(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_set_t *on_conf_set, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_dup(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_dup_t *on_conf_dup, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_destroy(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_destroy_t *on_conf_destroy, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_new(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_new_t *on_new, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_destroy(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_destroy_t *on_destroy, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_send(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_send_t *on_send, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_acknowledgement(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_acknowledgement_t *on_acknowledgement, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_consume(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_consume_t *on_consume, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_commit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_commit_t *on_commit, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_request_sent(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_request_sent_t *on_request_sent, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_response_received(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_response_received_t *on_response_received, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_start(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_start_t *on_thread_start, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_exit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_exit_t *on_thread_exit, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_topic_result_error(const rd_kafka_topic_result_t *topicres);\nconst char *rd_kafka_topic_result_error_string(const rd_kafka_topic_result_t *topicres);\nconst char *rd_kafka_topic_result_name(const rd_kafka_topic_result_t *topicres);\nconst rd_kafka_error_t *rd_kafka_group_result_error(const rd_kafka_group_result_t *groupres);\nconst char *rd_kafka_group_result_name(const rd_kafka_group_result_t *groupres);\nconst rd_kafka_topic_partition_list_t *rd_kafka_group_result_partitions(const rd_kafka_group_result_t *groupres);\ntypedef enum rd_kafka_admin_op_t {\n  RD_KAFKA_ADMIN_OP_ANY = 0,\n  RD_KAFKA_ADMIN_OP_CREATETOPICS,\n  RD_KAFKA_ADMIN_OP_DELETETOPICS,\n  RD_KAFKA_ADMIN_OP_CREATEPARTITIONS,\n  RD_KAFKA_ADMIN_OP_ALTERCONFIGS,\n  RD_KAFKA_ADMIN_OP_DESCRIBECONFIGS,\n  RD_KAFKA_ADMIN_OP_DELETERECORDS,\n  RD_KAFKA_ADMIN_OP_DELETEGROUPS,\n  RD_KAFKA_ADMIN_OP_DELETECONSUMERGROUPOFFSETS,\n  RD_KAFKA_ADMIN_OP_CREATEACLS,\n  RD_KAFKA_ADMIN_OP_DESCRIBEACLS,\n  RD_KAFKA_ADMIN_OP_DELETEACLS,\n  RD_KAFKA_ADMIN_OP__CNT,\n} rd_kafka_admin_op_t;\ntypedef struct rd_kafka_AdminOptions_s rd_kafka_AdminOptions_t;\nrd_kafka_AdminOptions_t *rd_kafka_AdminOptions_new(rd_kafka_t *rk, rd_kafka_admin_op_t for_api);\nvoid rd_kafka_AdminOptions_destroy(rd_kafka_AdminOptions_t *options);\nrd_kafka_resp_err_t rd_kafka_AdminOptions_set_request_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_AdminOptions_set_operation_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_AdminOptions_set_validate_only(rd_kafka_AdminOptions_t *options, int true_or_false, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_AdminOptions_set_broker(rd_kafka_AdminOptions_t *options, int32_t broker_id, char *errstr, size_t errstr_size);\nvoid rd_kafka_AdminOptions_set_opaque(rd_kafka_AdminOptions_t *options, void *ev_opaque);\ntypedef struct rd_kafka_NewTopic_s rd_kafka_NewTopic_t;\nrd_kafka_NewTopic_t *rd_kafka_NewTopic_new(const char *topic, int num_partitions, int replication_factor, char *errstr, size_t errstr_size);\nvoid rd_kafka_NewTopic_destroy(rd_kafka_NewTopic_t *new_topic);\nvoid rd_kafka_NewTopic_destroy_array(rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt);\nrd_kafka_resp_err_t rd_kafka_NewTopic_set_replica_assignment(rd_kafka_NewTopic_t *new_topic, int32_t partition, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_NewTopic_set_config(rd_kafka_NewTopic_t *new_topic, const char *name, const char *value);\nvoid rd_kafka_CreateTopics(rd_kafka_t *rk, rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_topic_result_t **rd_kafka_CreateTopics_result_topics(const rd_kafka_CreateTopics_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_DeleteTopic_s rd_kafka_DeleteTopic_t;\nrd_kafka_DeleteTopic_t *rd_kafka_DeleteTopic_new(const char *topic);\nvoid rd_kafka_DeleteTopic_destroy(rd_kafka_DeleteTopic_t *del_topic);\nvoid rd_kafka_DeleteTopic_destroy_array(rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt);\nvoid rd_kafka_DeleteTopics(rd_kafka_t *rk, rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_topic_result_t **rd_kafka_DeleteTopics_result_topics(const rd_kafka_DeleteTopics_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_NewPartitions_s rd_kafka_NewPartitions_t;\nrd_kafka_NewPartitions_t *rd_kafka_NewPartitions_new(const char *topic, size_t new_total_cnt, char *errstr, size_t errstr_size);\nvoid rd_kafka_NewPartitions_destroy(rd_kafka_NewPartitions_t *new_parts);\nvoid rd_kafka_NewPartitions_destroy_array(rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt);\nrd_kafka_resp_err_t rd_kafka_NewPartitions_set_replica_assignment(rd_kafka_NewPartitions_t *new_parts, int32_t new_partition_idx, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);\nvoid rd_kafka_CreatePartitions(rd_kafka_t *rk, rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_topic_result_t **rd_kafka_CreatePartitions_result_topics(const rd_kafka_CreatePartitions_result_t *result, size_t *cntp);\ntypedef enum rd_kafka_ConfigSource_t {\n  RD_KAFKA_CONFIG_SOURCE_UNKNOWN_CONFIG = 0,\n  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_TOPIC_CONFIG = 1,\n  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_BROKER_CONFIG = 2,\n  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_DEFAULT_BROKER_CONFIG = 3,\n  RD_KAFKA_CONFIG_SOURCE_STATIC_BROKER_CONFIG = 4,\n  RD_KAFKA_CONFIG_SOURCE_DEFAULT_CONFIG = 5,\n  RD_KAFKA_CONFIG_SOURCE__CNT,\n} rd_kafka_ConfigSource_t;\nconst char *rd_kafka_ConfigSource_name(rd_kafka_ConfigSource_t confsource);\ntypedef struct rd_kafka_ConfigEntry_s rd_kafka_ConfigEntry_t;\nconst char *rd_kafka_ConfigEntry_name(const rd_kafka_ConfigEntry_t *entry);\nconst char *rd_kafka_ConfigEntry_value(const rd_kafka_ConfigEntry_t *entry);\nrd_kafka_ConfigSource_t rd_kafka_ConfigEntry_source(const rd_kafka_ConfigEntry_t *entry);\nint rd_kafka_ConfigEntry_is_read_only(const rd_kafka_ConfigEntry_t *entry);\nint rd_kafka_ConfigEntry_is_default(const rd_kafka_ConfigEntry_t *entry);\nint rd_kafka_ConfigEntry_is_sensitive(const rd_kafka_ConfigEntry_t *entry);\nint rd_kafka_ConfigEntry_is_synonym(const rd_kafka_ConfigEntry_t *entry);\nconst rd_kafka_ConfigEntry_t **rd_kafka_ConfigEntry_synonyms(const rd_kafka_ConfigEntry_t *entry, size_t *cntp);\ntypedef enum rd_kafka_ResourceType_t {\n  RD_KAFKA_RESOURCE_UNKNOWN = 0,\n  RD_KAFKA_RESOURCE_ANY = 1,\n  RD_KAFKA_RESOURCE_TOPIC = 2,\n  RD_KAFKA_RESOURCE_GROUP = 3,\n  RD_KAFKA_RESOURCE_BROKER = 4,\n  RD_KAFKA_RESOURCE__CNT,\n} rd_kafka_ResourceType_t;\ntypedef enum rd_kafka_ResourcePatternType_t {\n  RD_KAFKA_RESOURCE_PATTERN_UNKNOWN = 0,\n  RD_KAFKA_RESOURCE_PATTERN_ANY = 1,\n  RD_KAFKA_RESOURCE_PATTERN_MATCH = 2,\n  RD_KAFKA_RESOURCE_PATTERN_LITERAL = 3,\n  RD_KAFKA_RESOURCE_PATTERN_PREFIXED = 4,\n  RD_KAFKA_RESOURCE_PATTERN_TYPE__CNT,\n} rd_kafka_ResourcePatternType_t;\nconst char *rd_kafka_ResourcePatternType_name(rd_kafka_ResourcePatternType_t resource_pattern_type);\nconst char *rd_kafka_ResourceType_name(rd_kafka_ResourceType_t restype);\ntypedef struct rd_kafka_ConfigResource_s rd_kafka_ConfigResource_t;\nrd_kafka_ConfigResource_t *rd_kafka_ConfigResource_new(rd_kafka_ResourceType_t restype, const char *resname);\nvoid rd_kafka_ConfigResource_destroy(rd_kafka_ConfigResource_t *config);\nvoid rd_kafka_ConfigResource_destroy_array(rd_kafka_ConfigResource_t **config, size_t config_cnt);\nrd_kafka_resp_err_t rd_kafka_ConfigResource_set_config(rd_kafka_ConfigResource_t *config, const char *name, const char *value);\nconst rd_kafka_ConfigEntry_t **rd_kafka_ConfigResource_configs(const rd_kafka_ConfigResource_t *config, size_t *cntp);\nrd_kafka_ResourceType_t rd_kafka_ConfigResource_type(const rd_kafka_ConfigResource_t *config);\nconst char *rd_kafka_ConfigResource_name(const rd_kafka_ConfigResource_t *config);\nrd_kafka_resp_err_t rd_kafka_ConfigResource_error(const rd_kafka_ConfigResource_t *config);\nconst char *rd_kafka_ConfigResource_error_string(const rd_kafka_ConfigResource_t *config);\nvoid rd_kafka_AlterConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_ConfigResource_t **rd_kafka_AlterConfigs_result_resources(const rd_kafka_AlterConfigs_result_t *result, size_t *cntp);\nvoid rd_kafka_DescribeConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_ConfigResource_t **rd_kafka_DescribeConfigs_result_resources(const rd_kafka_DescribeConfigs_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_DeleteRecords_s rd_kafka_DeleteRecords_t;\nrd_kafka_DeleteRecords_t *rd_kafka_DeleteRecords_new(const rd_kafka_topic_partition_list_t *before_offsets);\nvoid rd_kafka_DeleteRecords_destroy(rd_kafka_DeleteRecords_t *del_records);\nvoid rd_kafka_DeleteRecords_destroy_array(rd_kafka_DeleteRecords_t **del_records, size_t del_record_cnt);\nvoid rd_kafka_DeleteRecords(rd_kafka_t *rk, rd_kafka_DeleteRecords_t **del_records, size_t del_record_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_topic_partition_list_t *rd_kafka_DeleteRecords_result_offsets(const rd_kafka_DeleteRecords_result_t *result);\ntypedef struct rd_kafka_DeleteGroup_s rd_kafka_DeleteGroup_t;\nrd_kafka_DeleteGroup_t *rd_kafka_DeleteGroup_new(const char *group);\nvoid rd_kafka_DeleteGroup_destroy(rd_kafka_DeleteGroup_t *del_group);\nvoid rd_kafka_DeleteGroup_destroy_array(rd_kafka_DeleteGroup_t **del_groups, size_t del_group_cnt);\nvoid rd_kafka_DeleteGroups(rd_kafka_t *rk, rd_kafka_DeleteGroup_t **del_groups, size_t del_group_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_group_result_t **rd_kafka_DeleteGroups_result_groups(const rd_kafka_DeleteGroups_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_DeleteConsumerGroupOffsets_s rd_kafka_DeleteConsumerGroupOffsets_t;\nrd_kafka_DeleteConsumerGroupOffsets_t *rd_kafka_DeleteConsumerGroupOffsets_new(const char *group, const rd_kafka_topic_partition_list_t *partitions);\nvoid rd_kafka_DeleteConsumerGroupOffsets_destroy(rd_kafka_DeleteConsumerGroupOffsets_t *del_grpoffsets);\nvoid rd_kafka_DeleteConsumerGroupOffsets_destroy_array(rd_kafka_DeleteConsumerGroupOffsets_t **del_grpoffsets, size_t del_grpoffset_cnt);\nvoid rd_kafka_DeleteConsumerGroupOffsets(rd_kafka_t *rk, rd_kafka_DeleteConsumerGroupOffsets_t **del_grpoffsets, size_t del_grpoffsets_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_group_result_t **rd_kafka_DeleteConsumerGroupOffsets_result_groups(const rd_kafka_DeleteConsumerGroupOffsets_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_AclBinding_s rd_kafka_AclBinding_t;\ntypedef rd_kafka_AclBinding_t rd_kafka_AclBindingFilter_t;\nconst rd_kafka_error_t *rd_kafka_acl_result_error(const rd_kafka_acl_result_t *aclres);\ntypedef enum rd_kafka_AclOperation_t {\n  RD_KAFKA_ACL_OPERATION_UNKNOWN = 0,\n  RD_KAFKA_ACL_OPERATION_ANY = 1,\n  RD_KAFKA_ACL_OPERATION_ALL = 2,\n  RD_KAFKA_ACL_OPERATION_READ = 3,\n  RD_KAFKA_ACL_OPERATION_WRITE = 4,\n  RD_KAFKA_ACL_OPERATION_CREATE = 5,\n  RD_KAFKA_ACL_OPERATION_DELETE = 6,\n  RD_KAFKA_ACL_OPERATION_ALTER = 7,\n  RD_KAFKA_ACL_OPERATION_DESCRIBE = 8,\n  RD_KAFKA_ACL_OPERATION_CLUSTER_ACTION = 9,\n  RD_KAFKA_ACL_OPERATION_DESCRIBE_CONFIGS = 10,\n  RD_KAFKA_ACL_OPERATION_ALTER_CONFIGS = 11,\n  RD_KAFKA_ACL_OPERATION_IDEMPOTENT_WRITE = 12,\n  RD_KAFKA_ACL_OPERATION__CNT,\n} rd_kafka_AclOperation_t;\nconst char *rd_kafka_AclOperation_name(rd_kafka_AclOperation_t acl_operation);\ntypedef enum rd_kafka_AclPermissionType_t {\n  RD_KAFKA_ACL_PERMISSION_TYPE_UNKNOWN = 0,\n  RD_KAFKA_ACL_PERMISSION_TYPE_ANY = 1,\n  RD_KAFKA_ACL_PERMISSION_TYPE_DENY = 2,\n  RD_KAFKA_ACL_PERMISSION_TYPE_ALLOW = 3,\n  RD_KAFKA_ACL_PERMISSION_TYPE__CNT,\n} rd_kafka_AclPermissionType_t;\nconst char *rd_kafka_AclPermissionType_name(rd_kafka_AclPermissionType_t acl_permission_type);\nrd_kafka_AclBinding_t *rd_kafka_AclBinding_new(rd_kafka_ResourceType_t restype, const char *name, rd_kafka_ResourcePatternType_t resource_pattern_type, const char *principal, const char *host, rd_kafka_AclOperation_t operation, rd_kafka_AclPermissionType_t permission_type, char *errstr, size_t errstr_size);\nrd_kafka_AclBindingFilter_t *rd_kafka_AclBindingFilter_new(rd_kafka_ResourceType_t restype, const char *name, rd_kafka_ResourcePatternType_t resource_pattern_type, const char *principal, const char *host, rd_kafka_AclOperation_t operation, rd_kafka_AclPermissionType_t permission_type, char *errstr, size_t errstr_size);\nrd_kafka_ResourceType_t rd_kafka_AclBinding_restype(const rd_kafka_AclBinding_t *acl);\nconst char *rd_kafka_AclBinding_name(const rd_kafka_AclBinding_t *acl);\nconst char *rd_kafka_AclBinding_principal(const rd_kafka_AclBinding_t *acl);\nconst char *rd_kafka_AclBinding_host(const rd_kafka_AclBinding_t *acl);\nrd_kafka_AclOperation_t rd_kafka_AclBinding_operation(const rd_kafka_AclBinding_t *acl);\nrd_kafka_AclPermissionType_t rd_kafka_AclBinding_permission_type(const rd_kafka_AclBinding_t *acl);\nrd_kafka_ResourcePatternType_t rd_kafka_AclBinding_resource_pattern_type(const rd_kafka_AclBinding_t *acl);\nconst rd_kafka_error_t *rd_kafka_AclBinding_error(const rd_kafka_AclBinding_t *acl);\nvoid rd_kafka_AclBinding_destroy(rd_kafka_AclBinding_t *acl_binding);\nvoid rd_kafka_AclBinding_destroy_array(rd_kafka_AclBinding_t **acl_bindings, size_t acl_bindings_cnt);\nconst rd_kafka_acl_result_t **rd_kafka_CreateAcls_result_acls(const rd_kafka_CreateAcls_result_t *result, size_t *cntp);\nvoid rd_kafka_CreateAcls(rd_kafka_t *rk, rd_kafka_AclBinding_t **new_acls, size_t new_acls_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_AclBinding_t **rd_kafka_DescribeAcls_result_acls(const rd_kafka_DescribeAcls_result_t *result, size_t *cntp);\nvoid rd_kafka_DescribeAcls(rd_kafka_t *rk, rd_kafka_AclBindingFilter_t *acl_filter, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\ntypedef struct rd_kafka_DeleteAcls_result_response_s rd_kafka_DeleteAcls_result_response_t;\nconst rd_kafka_DeleteAcls_result_response_t **rd_kafka_DeleteAcls_result_responses(const rd_kafka_DeleteAcls_result_t *result, size_t *cntp);\nconst rd_kafka_error_t *rd_kafka_DeleteAcls_result_response_error(const rd_kafka_DeleteAcls_result_response_t *result_response);\nconst rd_kafka_AclBinding_t **rd_kafka_DeleteAcls_result_response_matching_acls(const rd_kafka_DeleteAcls_result_response_t *result_response, size_t *matching_acls_cntp);\nvoid rd_kafka_DeleteAcls(rd_kafka_t *rk, rd_kafka_AclBindingFilter_t **del_acls, size_t del_acls_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nrd_kafka_resp_err_t rd_kafka_oauthbearer_set_token(rd_kafka_t *rk, const char *token_value, int64_t md_lifetime_ms, const char *md_principal_name, const char **extensions, size_t extension_size, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_oauthbearer_set_token_failure(rd_kafka_t *rk, const char *errstr);\nrd_kafka_error_t *rd_kafka_init_transactions(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_error_t *rd_kafka_begin_transaction(rd_kafka_t *rk);\nrd_kafka_error_t *rd_kafka_send_offsets_to_transaction(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, const rd_kafka_consumer_group_metadata_t *cgmetadata, int timeout_ms);\nrd_kafka_error_t *rd_kafka_commit_transaction(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_error_t *rd_kafka_abort_transaction(rd_kafka_t *rk, int timeout_ms);\ntypedef struct rd_kafka_mock_cluster_s rd_kafka_mock_cluster_t;\nrd_kafka_mock_cluster_t *rd_kafka_mock_cluster_new(rd_kafka_t *rk, int broker_cnt);\nvoid rd_kafka_mock_cluster_destroy(rd_kafka_mock_cluster_t *mcluster);\nrd_kafka_t *rd_kafka_mock_cluster_handle(const rd_kafka_mock_cluster_t *mcluster);\nrd_kafka_mock_cluster_t *rd_kafka_handle_mock_cluster(const rd_kafka_t *rk);\nconst char *rd_kafka_mock_cluster_bootstraps(const rd_kafka_mock_cluster_t *mcluster);\nvoid rd_kafka_mock_clear_request_errors(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey);\nvoid rd_kafka_mock_push_request_errors(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, size_t cnt, ...);\nvoid rd_kafka_mock_push_request_errors_array(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, size_t cnt, const rd_kafka_resp_err_t *errors);\nrd_kafka_resp_err_t rd_kafka_mock_broker_push_request_error_rtts(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int16_t ApiKey, size_t cnt, ...);\nvoid rd_kafka_mock_topic_set_error(rd_kafka_mock_cluster_t *mcluster, const char *topic, rd_kafka_resp_err_t err);\nrd_kafka_resp_err_t rd_kafka_mock_topic_create(rd_kafka_mock_cluster_t *mcluster, const char *topic, int partition_cnt, int replication_factor);\nrd_kafka_resp_err_t rd_kafka_mock_partition_set_leader(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id);\nrd_kafka_resp_err_t rd_kafka_mock_partition_set_follower(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id);\nrd_kafka_resp_err_t rd_kafka_mock_partition_set_follower_wmarks(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int64_t lo, int64_t hi);\nrd_kafka_resp_err_t rd_kafka_mock_broker_set_down(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id);\nrd_kafka_resp_err_t rd_kafka_mock_broker_set_up(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id);\nrd_kafka_resp_err_t rd_kafka_mock_broker_set_rtt(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int rtt_ms);\nrd_kafka_resp_err_t rd_kafka_mock_broker_set_rack(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, const char *rack);\nrd_kafka_resp_err_t rd_kafka_mock_coordinator_set(rd_kafka_mock_cluster_t *mcluster, const char *key_type, const char *key, int32_t broker_id);\nrd_kafka_resp_err_t rd_kafka_mock_set_apiversion(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, int16_t MinVersion, int16_t MaxVersion);\n'\n</code></pre> rdkafka.h, rdkafka_mock.h</p>"},{"location":"api/constants/#rd_kafka_version_20","title":"RD_KAFKA_VERSION","text":"<pre><code>public RD_KAFKA_VERSION = 17367551\n</code></pre> <p>librdkafka version </p> <p>Interpreted as hex <code>MM.mm.rr.xx</code>:</p> <ul> <li>MM = Major</li> <li>mm = minor</li> <li>rr = revision</li> <li>xx = pre-release id (0xff is the final release)</li> </ul> <p>E.g.: <code>0x000801ff</code> = 0.8.1</p> RemarksThis value should only be used during compile time, for runtime checks of version use rd_kafka_version()  <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_unsupported_compression_type_20","title":"RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE","text":"<pre><code>public RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76\n</code></pre> <p>Unsupported compression type </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_end_all_20","title":"RD_KAFKA_RESP_ERR_END_ALL","text":"<p><pre><code>public RD_KAFKA_RESP_ERR_END_ALL = 98\n</code></pre> enum rd_kafka_resp_err_t</p>"},{"location":"api/constants/#rd_kafka_admin_op__cnt_20","title":"RD_KAFKA_ADMIN_OP__CNT","text":"<pre><code>public RD_KAFKA_ADMIN_OP__CNT = 12\n</code></pre> <p>Number of ops defined </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe </li> </ul>"},{"location":"api/constants/#rd_kafka_resource__cnt_20","title":"RD_KAFKA_RESOURCE__CNT","text":"<pre><code>public RD_KAFKA_RESOURCE__CNT = 5\n</code></pre> <p>Number of resource types defined </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#acca83a66d7783ff7683ed2691cc907c9 </li> </ul>"},{"location":"api/constants/#rd_kafka_cdef_20","title":"RD_KAFKA_CDEF","text":"<p><pre><code>public RD_KAFKA_CDEF = 'typedef long int ssize_t;\ntypedef struct _IO_FILE FILE;\ntypedef long int mode_t;\ntypedef signed int int16_t;\ntypedef unsigned int uint16_t;\ntypedef signed int int32_t;\ntypedef signed long int int64_t;\nint rd_kafka_version(void);\nconst char *rd_kafka_version_str(void);\ntypedef enum rd_kafka_type_t {\n  RD_KAFKA_PRODUCER,\n  RD_KAFKA_CONSUMER,\n} rd_kafka_type_t;\ntypedef enum rd_kafka_timestamp_type_t {\n  RD_KAFKA_TIMESTAMP_NOT_AVAILABLE,\n  RD_KAFKA_TIMESTAMP_CREATE_TIME,\n  RD_KAFKA_TIMESTAMP_LOG_APPEND_TIME,\n} rd_kafka_timestamp_type_t;\nconst char *rd_kafka_get_debug_contexts(void);\ntypedef struct rd_kafka_s rd_kafka_t;\ntypedef struct rd_kafka_topic_s rd_kafka_topic_t;\ntypedef struct rd_kafka_conf_s rd_kafka_conf_t;\ntypedef struct rd_kafka_topic_conf_s rd_kafka_topic_conf_t;\ntypedef struct rd_kafka_queue_s rd_kafka_queue_t;\ntypedef struct rd_kafka_op_s rd_kafka_event_t;\ntypedef struct rd_kafka_topic_result_s rd_kafka_topic_result_t;\ntypedef struct rd_kafka_consumer_group_metadata_s rd_kafka_consumer_group_metadata_t;\ntypedef struct rd_kafka_error_s {\n  unsigned int code;\n  char *errstr;\n  unsigned char fatal;\n  unsigned char retriable;\n  unsigned char txn_requires_abort;\n} rd_kafka_error_t;\ntypedef struct rd_kafka_headers_s rd_kafka_headers_t;\ntypedef struct rd_kafka_group_result_s rd_kafka_group_result_t;\ntypedef struct rd_kafka_acl_result_s rd_kafka_acl_result_t;\ntypedef enum {\n  RD_KAFKA_RESP_ERR__BEGIN = (- 200),\n  RD_KAFKA_RESP_ERR__BAD_MSG = (- 199),\n  RD_KAFKA_RESP_ERR__BAD_COMPRESSION = (- 198),\n  RD_KAFKA_RESP_ERR__DESTROY = (- 197),\n  RD_KAFKA_RESP_ERR__FAIL = (- 196),\n  RD_KAFKA_RESP_ERR__TRANSPORT = (- 195),\n  RD_KAFKA_RESP_ERR__CRIT_SYS_RESOURCE = (- 194),\n  RD_KAFKA_RESP_ERR__RESOLVE = (- 193),\n  RD_KAFKA_RESP_ERR__MSG_TIMED_OUT = (- 192),\n  RD_KAFKA_RESP_ERR__PARTITION_EOF = (- 191),\n  RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION = (- 190),\n  RD_KAFKA_RESP_ERR__FS = (- 189),\n  RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC = (- 188),\n  RD_KAFKA_RESP_ERR__ALL_BROKERS_DOWN = (- 187),\n  RD_KAFKA_RESP_ERR__INVALID_ARG = (- 186),\n  RD_KAFKA_RESP_ERR__TIMED_OUT = (- 185),\n  RD_KAFKA_RESP_ERR__QUEUE_FULL = (- 184),\n  RD_KAFKA_RESP_ERR__ISR_INSUFF = (- 183),\n  RD_KAFKA_RESP_ERR__NODE_UPDATE = (- 182),\n  RD_KAFKA_RESP_ERR__SSL = (- 181),\n  RD_KAFKA_RESP_ERR__WAIT_COORD = (- 180),\n  RD_KAFKA_RESP_ERR__UNKNOWN_GROUP = (- 179),\n  RD_KAFKA_RESP_ERR__IN_PROGRESS = (- 178),\n  RD_KAFKA_RESP_ERR__PREV_IN_PROGRESS = (- 177),\n  RD_KAFKA_RESP_ERR__EXISTING_SUBSCRIPTION = (- 176),\n  RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS = (- 175),\n  RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS = (- 174),\n  RD_KAFKA_RESP_ERR__CONFLICT = (- 173),\n  RD_KAFKA_RESP_ERR__STATE = (- 172),\n  RD_KAFKA_RESP_ERR__UNKNOWN_PROTOCOL = (- 171),\n  RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED = (- 170),\n  RD_KAFKA_RESP_ERR__AUTHENTICATION = (- 169),\n  RD_KAFKA_RESP_ERR__NO_OFFSET = (- 168),\n  RD_KAFKA_RESP_ERR__OUTDATED = (- 167),\n  RD_KAFKA_RESP_ERR__TIMED_OUT_QUEUE = (- 166),\n  RD_KAFKA_RESP_ERR__UNSUPPORTED_FEATURE = (- 165),\n  RD_KAFKA_RESP_ERR__WAIT_CACHE = (- 164),\n  RD_KAFKA_RESP_ERR__INTR = (- 163),\n  RD_KAFKA_RESP_ERR__KEY_SERIALIZATION = (- 162),\n  RD_KAFKA_RESP_ERR__VALUE_SERIALIZATION = (- 161),\n  RD_KAFKA_RESP_ERR__KEY_DESERIALIZATION = (- 160),\n  RD_KAFKA_RESP_ERR__VALUE_DESERIALIZATION = (- 159),\n  RD_KAFKA_RESP_ERR__PARTIAL = (- 158),\n  RD_KAFKA_RESP_ERR__READ_ONLY = (- 157),\n  RD_KAFKA_RESP_ERR__NOENT = (- 156),\n  RD_KAFKA_RESP_ERR__UNDERFLOW = (- 155),\n  RD_KAFKA_RESP_ERR__INVALID_TYPE = (- 154),\n  RD_KAFKA_RESP_ERR__RETRY = (- 153),\n  RD_KAFKA_RESP_ERR__PURGE_QUEUE = (- 152),\n  RD_KAFKA_RESP_ERR__PURGE_INFLIGHT = (- 151),\n  RD_KAFKA_RESP_ERR__FATAL = (- 150),\n  RD_KAFKA_RESP_ERR__INCONSISTENT = (- 149),\n  RD_KAFKA_RESP_ERR__GAPLESS_GUARANTEE = (- 148),\n  RD_KAFKA_RESP_ERR__MAX_POLL_EXCEEDED = (- 147),\n  RD_KAFKA_RESP_ERR__UNKNOWN_BROKER = (- 146),\n  RD_KAFKA_RESP_ERR__NOT_CONFIGURED = (- 145),\n  RD_KAFKA_RESP_ERR__FENCED = (- 144),\n  RD_KAFKA_RESP_ERR__APPLICATION = (- 143),\n  RD_KAFKA_RESP_ERR__ASSIGNMENT_LOST = (- 142),\n  RD_KAFKA_RESP_ERR__NOOP = (- 141),\n  RD_KAFKA_RESP_ERR__AUTO_OFFSET_RESET = (- 140),\n  RD_KAFKA_RESP_ERR__END = (- 100),\n  RD_KAFKA_RESP_ERR_UNKNOWN = (- 1),\n  RD_KAFKA_RESP_ERR_NO_ERROR = 0,\n  RD_KAFKA_RESP_ERR_OFFSET_OUT_OF_RANGE = 1,\n  RD_KAFKA_RESP_ERR_INVALID_MSG = 2,\n  RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART = 3,\n  RD_KAFKA_RESP_ERR_INVALID_MSG_SIZE = 4,\n  RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE = 5,\n  RD_KAFKA_RESP_ERR_NOT_LEADER_FOR_PARTITION = 6,\n  RD_KAFKA_RESP_ERR_REQUEST_TIMED_OUT = 7,\n  RD_KAFKA_RESP_ERR_BROKER_NOT_AVAILABLE = 8,\n  RD_KAFKA_RESP_ERR_REPLICA_NOT_AVAILABLE = 9,\n  RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE = 10,\n  RD_KAFKA_RESP_ERR_STALE_CTRL_EPOCH = 11,\n  RD_KAFKA_RESP_ERR_OFFSET_METADATA_TOO_LARGE = 12,\n  RD_KAFKA_RESP_ERR_NETWORK_EXCEPTION = 13,\n  RD_KAFKA_RESP_ERR_COORDINATOR_LOAD_IN_PROGRESS = 14,\n  RD_KAFKA_RESP_ERR_COORDINATOR_NOT_AVAILABLE = 15,\n  RD_KAFKA_RESP_ERR_NOT_COORDINATOR = 16,\n  RD_KAFKA_RESP_ERR_TOPIC_EXCEPTION = 17,\n  RD_KAFKA_RESP_ERR_RECORD_LIST_TOO_LARGE = 18,\n  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS = 19,\n  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS_AFTER_APPEND = 20,\n  RD_KAFKA_RESP_ERR_INVALID_REQUIRED_ACKS = 21,\n  RD_KAFKA_RESP_ERR_ILLEGAL_GENERATION = 22,\n  RD_KAFKA_RESP_ERR_INCONSISTENT_GROUP_PROTOCOL = 23,\n  RD_KAFKA_RESP_ERR_INVALID_GROUP_ID = 24,\n  RD_KAFKA_RESP_ERR_UNKNOWN_MEMBER_ID = 25,\n  RD_KAFKA_RESP_ERR_INVALID_SESSION_TIMEOUT = 26,\n  RD_KAFKA_RESP_ERR_REBALANCE_IN_PROGRESS = 27,\n  RD_KAFKA_RESP_ERR_INVALID_COMMIT_OFFSET_SIZE = 28,\n  RD_KAFKA_RESP_ERR_TOPIC_AUTHORIZATION_FAILED = 29,\n  RD_KAFKA_RESP_ERR_GROUP_AUTHORIZATION_FAILED = 30,\n  RD_KAFKA_RESP_ERR_CLUSTER_AUTHORIZATION_FAILED = 31,\n  RD_KAFKA_RESP_ERR_INVALID_TIMESTAMP = 32,\n  RD_KAFKA_RESP_ERR_UNSUPPORTED_SASL_MECHANISM = 33,\n  RD_KAFKA_RESP_ERR_ILLEGAL_SASL_STATE = 34,\n  RD_KAFKA_RESP_ERR_UNSUPPORTED_VERSION = 35,\n  RD_KAFKA_RESP_ERR_TOPIC_ALREADY_EXISTS = 36,\n  RD_KAFKA_RESP_ERR_INVALID_PARTITIONS = 37,\n  RD_KAFKA_RESP_ERR_INVALID_REPLICATION_FACTOR = 38,\n  RD_KAFKA_RESP_ERR_INVALID_REPLICA_ASSIGNMENT = 39,\n  RD_KAFKA_RESP_ERR_INVALID_CONFIG = 40,\n  RD_KAFKA_RESP_ERR_NOT_CONTROLLER = 41,\n  RD_KAFKA_RESP_ERR_INVALID_REQUEST = 42,\n  RD_KAFKA_RESP_ERR_UNSUPPORTED_FOR_MESSAGE_FORMAT = 43,\n  RD_KAFKA_RESP_ERR_POLICY_VIOLATION = 44,\n  RD_KAFKA_RESP_ERR_OUT_OF_ORDER_SEQUENCE_NUMBER = 45,\n  RD_KAFKA_RESP_ERR_DUPLICATE_SEQUENCE_NUMBER = 46,\n  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_EPOCH = 47,\n  RD_KAFKA_RESP_ERR_INVALID_TXN_STATE = 48,\n  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_ID_MAPPING = 49,\n  RD_KAFKA_RESP_ERR_INVALID_TRANSACTION_TIMEOUT = 50,\n  RD_KAFKA_RESP_ERR_CONCURRENT_TRANSACTIONS = 51,\n  RD_KAFKA_RESP_ERR_TRANSACTION_COORDINATOR_FENCED = 52,\n  RD_KAFKA_RESP_ERR_TRANSACTIONAL_ID_AUTHORIZATION_FAILED = 53,\n  RD_KAFKA_RESP_ERR_SECURITY_DISABLED = 54,\n  RD_KAFKA_RESP_ERR_OPERATION_NOT_ATTEMPTED = 55,\n  RD_KAFKA_RESP_ERR_KAFKA_STORAGE_ERROR = 56,\n  RD_KAFKA_RESP_ERR_LOG_DIR_NOT_FOUND = 57,\n  RD_KAFKA_RESP_ERR_SASL_AUTHENTICATION_FAILED = 58,\n  RD_KAFKA_RESP_ERR_UNKNOWN_PRODUCER_ID = 59,\n  RD_KAFKA_RESP_ERR_REASSIGNMENT_IN_PROGRESS = 60,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTH_DISABLED = 61,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_NOT_FOUND = 62,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_OWNER_MISMATCH = 63,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_REQUEST_NOT_ALLOWED = 64,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTHORIZATION_FAILED = 65,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_EXPIRED = 66,\n  RD_KAFKA_RESP_ERR_INVALID_PRINCIPAL_TYPE = 67,\n  RD_KAFKA_RESP_ERR_NON_EMPTY_GROUP = 68,\n  RD_KAFKA_RESP_ERR_GROUP_ID_NOT_FOUND = 69,\n  RD_KAFKA_RESP_ERR_FETCH_SESSION_ID_NOT_FOUND = 70,\n  RD_KAFKA_RESP_ERR_INVALID_FETCH_SESSION_EPOCH = 71,\n  RD_KAFKA_RESP_ERR_LISTENER_NOT_FOUND = 72,\n  RD_KAFKA_RESP_ERR_TOPIC_DELETION_DISABLED = 73,\n  RD_KAFKA_RESP_ERR_FENCED_LEADER_EPOCH = 74,\n  RD_KAFKA_RESP_ERR_UNKNOWN_LEADER_EPOCH = 75,\n  RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76,\n  RD_KAFKA_RESP_ERR_STALE_BROKER_EPOCH = 77,\n  RD_KAFKA_RESP_ERR_OFFSET_NOT_AVAILABLE = 78,\n  RD_KAFKA_RESP_ERR_MEMBER_ID_REQUIRED = 79,\n  RD_KAFKA_RESP_ERR_PREFERRED_LEADER_NOT_AVAILABLE = 80,\n  RD_KAFKA_RESP_ERR_GROUP_MAX_SIZE_REACHED = 81,\n  RD_KAFKA_RESP_ERR_FENCED_INSTANCE_ID = 82,\n  RD_KAFKA_RESP_ERR_ELIGIBLE_LEADERS_NOT_AVAILABLE = 83,\n  RD_KAFKA_RESP_ERR_ELECTION_NOT_NEEDED = 84,\n  RD_KAFKA_RESP_ERR_NO_REASSIGNMENT_IN_PROGRESS = 85,\n  RD_KAFKA_RESP_ERR_GROUP_SUBSCRIBED_TO_TOPIC = 86,\n  RD_KAFKA_RESP_ERR_INVALID_RECORD = 87,\n  RD_KAFKA_RESP_ERR_UNSTABLE_OFFSET_COMMIT = 88,\n  RD_KAFKA_RESP_ERR_THROTTLING_QUOTA_EXCEEDED = 89,\n  RD_KAFKA_RESP_ERR_PRODUCER_FENCED = 90,\n  RD_KAFKA_RESP_ERR_RESOURCE_NOT_FOUND = 91,\n  RD_KAFKA_RESP_ERR_DUPLICATE_RESOURCE = 92,\n  RD_KAFKA_RESP_ERR_UNACCEPTABLE_CREDENTIAL = 93,\n  RD_KAFKA_RESP_ERR_INCONSISTENT_VOTER_SET = 94,\n  RD_KAFKA_RESP_ERR_INVALID_UPDATE_VERSION = 95,\n  RD_KAFKA_RESP_ERR_FEATURE_UPDATE_FAILED = 96,\n  RD_KAFKA_RESP_ERR_PRINCIPAL_DESERIALIZATION_FAILURE = 97,\n  RD_KAFKA_RESP_ERR_END_ALL,\n} rd_kafka_resp_err_t;\nstruct rd_kafka_err_desc {\n  rd_kafka_resp_err_t code;\n  char *name;\n  char *desc;\n};\nvoid rd_kafka_get_err_descs(const struct rd_kafka_err_desc **errdescs, size_t *cntp);\nconst char *rd_kafka_err2str(rd_kafka_resp_err_t err);\nconst char *rd_kafka_err2name(rd_kafka_resp_err_t err);\nrd_kafka_resp_err_t rd_kafka_last_error(void);\nrd_kafka_resp_err_t rd_kafka_errno2err(int errnox);\nint rd_kafka_errno(void);\nrd_kafka_resp_err_t rd_kafka_fatal_error(rd_kafka_t *rk, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_test_fatal_error(rd_kafka_t *rk, rd_kafka_resp_err_t err, const char *reason);\nrd_kafka_resp_err_t rd_kafka_error_code(const rd_kafka_error_t *error);\nconst char *rd_kafka_error_name(const rd_kafka_error_t *error);\nconst char *rd_kafka_error_string(const rd_kafka_error_t *error);\nint rd_kafka_error_is_fatal(const rd_kafka_error_t *error);\nint rd_kafka_error_is_retriable(const rd_kafka_error_t *error);\nint rd_kafka_error_txn_requires_abort(const rd_kafka_error_t *error);\nvoid rd_kafka_error_destroy(rd_kafka_error_t *error);\nrd_kafka_error_t *rd_kafka_error_new(rd_kafka_resp_err_t code, const char *fmt, ...);\ntypedef struct rd_kafka_topic_partition_s {\n  char *topic;\n  int32_t partition;\n  int64_t offset;\n  void *metadata;\n  size_t metadata_size;\n  void *opaque;\n  rd_kafka_resp_err_t err;\n  void *_private;\n} rd_kafka_topic_partition_t;\nvoid rd_kafka_topic_partition_destroy(rd_kafka_topic_partition_t *rktpar);\ntypedef struct rd_kafka_topic_partition_list_s {\n  int cnt;\n  int size;\n  rd_kafka_topic_partition_t *elems;\n} rd_kafka_topic_partition_list_t;\nrd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_new(int size);\nvoid rd_kafka_topic_partition_list_destroy(rd_kafka_topic_partition_list_t *rkparlist);\nrd_kafka_topic_partition_t *rd_kafka_topic_partition_list_add(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);\nvoid rd_kafka_topic_partition_list_add_range(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t start, int32_t stop);\nint rd_kafka_topic_partition_list_del(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);\nint rd_kafka_topic_partition_list_del_by_idx(rd_kafka_topic_partition_list_t *rktparlist, int idx);\nrd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_copy(const rd_kafka_topic_partition_list_t *src);\nrd_kafka_resp_err_t rd_kafka_topic_partition_list_set_offset(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition, int64_t offset);\nrd_kafka_topic_partition_t *rd_kafka_topic_partition_list_find(const rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);\nvoid rd_kafka_topic_partition_list_sort(rd_kafka_topic_partition_list_t *rktparlist, int (*cmp)(const void *a, const void *b, void *cmp_opaque), void *cmp_opaque);\ntypedef enum rd_kafka_vtype_t {\n  RD_KAFKA_VTYPE_END,\n  RD_KAFKA_VTYPE_TOPIC,\n  RD_KAFKA_VTYPE_RKT,\n  RD_KAFKA_VTYPE_PARTITION,\n  RD_KAFKA_VTYPE_VALUE,\n  RD_KAFKA_VTYPE_KEY,\n  RD_KAFKA_VTYPE_OPAQUE,\n  RD_KAFKA_VTYPE_MSGFLAGS,\n  RD_KAFKA_VTYPE_TIMESTAMP,\n  RD_KAFKA_VTYPE_HEADER,\n  RD_KAFKA_VTYPE_HEADERS,\n} rd_kafka_vtype_t;\ntypedef struct rd_kafka_vu_s {\n  rd_kafka_vtype_t vtype;\n  union {\n    char *cstr;\n    rd_kafka_topic_t *rkt;\n    int i;\n    int32_t i32;\n    int64_t i64;\n    struct {\n      void *ptr;\n      size_t size;\n    } mem;\n    struct {\n      char *name;\n      void *val;\n      ssize_t size;\n    } header;\n    rd_kafka_headers_t *headers;\n    void *ptr;\n    char _pad[64];\n  } u;\n} rd_kafka_vu_t;\nrd_kafka_headers_t *rd_kafka_headers_new(size_t initial_count);\nvoid rd_kafka_headers_destroy(rd_kafka_headers_t *hdrs);\nrd_kafka_headers_t *rd_kafka_headers_copy(const rd_kafka_headers_t *src);\nrd_kafka_resp_err_t rd_kafka_header_add(rd_kafka_headers_t *hdrs, const char *name, ssize_t name_size, const void *value, ssize_t value_size);\nrd_kafka_resp_err_t rd_kafka_header_remove(rd_kafka_headers_t *hdrs, const char *name);\nrd_kafka_resp_err_t rd_kafka_header_get_last(const rd_kafka_headers_t *hdrs, const char *name, const void **valuep, size_t *sizep);\nrd_kafka_resp_err_t rd_kafka_header_get(const rd_kafka_headers_t *hdrs, size_t idx, const char *name, const void **valuep, size_t *sizep);\nrd_kafka_resp_err_t rd_kafka_header_get_all(const rd_kafka_headers_t *hdrs, size_t idx, const char **namep, const void **valuep, size_t *sizep);\ntypedef struct rd_kafka_message_s {\n  rd_kafka_resp_err_t err;\n  rd_kafka_topic_t *rkt;\n  int32_t partition;\n  void *payload;\n  size_t len;\n  void *key;\n  size_t key_len;\n  int64_t offset;\n  void *_private;\n} rd_kafka_message_t;\nvoid rd_kafka_message_destroy(rd_kafka_message_t *rkmessage);\nconst char *rd_kafka_message_errstr(const rd_kafka_message_t *rkmessage);\nint64_t rd_kafka_message_timestamp(const rd_kafka_message_t *rkmessage, rd_kafka_timestamp_type_t *tstype);\nint64_t rd_kafka_message_latency(const rd_kafka_message_t *rkmessage);\nint32_t rd_kafka_message_broker_id(const rd_kafka_message_t *rkmessage);\nrd_kafka_resp_err_t rd_kafka_message_headers(const rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);\nrd_kafka_resp_err_t rd_kafka_message_detach_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);\nvoid rd_kafka_message_set_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t *hdrs);\nsize_t rd_kafka_header_cnt(const rd_kafka_headers_t *hdrs);\ntypedef enum {\n  RD_KAFKA_MSG_STATUS_NOT_PERSISTED = 0,\n  RD_KAFKA_MSG_STATUS_POSSIBLY_PERSISTED = 1,\n  RD_KAFKA_MSG_STATUS_PERSISTED = 2,\n} rd_kafka_msg_status_t;\nrd_kafka_msg_status_t rd_kafka_message_status(const rd_kafka_message_t *rkmessage);\ntypedef enum {\n  RD_KAFKA_CONF_UNKNOWN = (- 2),\n  RD_KAFKA_CONF_INVALID = (- 1),\n  RD_KAFKA_CONF_OK = 0,\n} rd_kafka_conf_res_t;\nrd_kafka_conf_t *rd_kafka_conf_new(void);\nvoid rd_kafka_conf_destroy(rd_kafka_conf_t *conf);\nrd_kafka_conf_t *rd_kafka_conf_dup(const rd_kafka_conf_t *conf);\nrd_kafka_conf_t *rd_kafka_conf_dup_filter(const rd_kafka_conf_t *conf, size_t filter_cnt, const char **filter);\nconst rd_kafka_conf_t *rd_kafka_conf(rd_kafka_t *rk);\nrd_kafka_conf_res_t rd_kafka_conf_set(rd_kafka_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);\nvoid rd_kafka_conf_set_events(rd_kafka_conf_t *conf, int events);\nvoid rd_kafka_conf_set_background_event_cb(rd_kafka_conf_t *conf, void (*event_cb)(rd_kafka_t *rk, rd_kafka_event_t *rkev, void *opaque));\nvoid rd_kafka_conf_set_dr_cb(rd_kafka_conf_t *conf, void (*dr_cb)(rd_kafka_t *rk, void *payload, size_t len, rd_kafka_resp_err_t err, void *opaque, void *msg_opaque));\nvoid rd_kafka_conf_set_dr_msg_cb(rd_kafka_conf_t *conf, void (*dr_msg_cb)(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, void *opaque));\nvoid rd_kafka_conf_set_consume_cb(rd_kafka_conf_t *conf, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *opaque));\nvoid rd_kafka_conf_set_rebalance_cb(rd_kafka_conf_t *conf, void (*rebalance_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *partitions, void *opaque));\nvoid rd_kafka_conf_set_offset_commit_cb(rd_kafka_conf_t *conf, void (*offset_commit_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *opaque));\nvoid rd_kafka_conf_set_error_cb(rd_kafka_conf_t *conf, void (*error_cb)(rd_kafka_t *rk, int err, const char *reason, void *opaque));\nvoid rd_kafka_conf_set_throttle_cb(rd_kafka_conf_t *conf, void (*throttle_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int throttle_time_ms, void *opaque));\nvoid rd_kafka_conf_set_log_cb(rd_kafka_conf_t *conf, void (*log_cb)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));\nvoid rd_kafka_conf_set_stats_cb(rd_kafka_conf_t *conf, int (*stats_cb)(rd_kafka_t *rk, char *json, size_t json_len, void *opaque));\nvoid rd_kafka_conf_set_oauthbearer_token_refresh_cb(rd_kafka_conf_t *conf, void (*oauthbearer_token_refresh_cb)(rd_kafka_t *rk, const char *oauthbearer_config, void *opaque));\nvoid rd_kafka_conf_enable_sasl_queue(rd_kafka_conf_t *conf, int enable);\nvoid rd_kafka_conf_set_socket_cb(rd_kafka_conf_t *conf, int (*socket_cb)(int domain, int type, int protocol, void *opaque));\nvoid rd_kafka_conf_set_connect_cb(rd_kafka_conf_t *conf, int (*connect_cb)(int sockfd, const struct sockaddr *addr, int addrlen, const char *id, void *opaque));\nvoid rd_kafka_conf_set_closesocket_cb(rd_kafka_conf_t *conf, int (*closesocket_cb)(int sockfd, void *opaque));\nrd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert_verify_cb(rd_kafka_conf_t *conf, int (*ssl_cert_verify_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int *x509_error, int depth, const char *buf, size_t size, char *errstr, size_t errstr_size, void *opaque));\ntypedef enum rd_kafka_cert_type_t {\n  RD_KAFKA_CERT_PUBLIC_KEY,\n  RD_KAFKA_CERT_PRIVATE_KEY,\n  RD_KAFKA_CERT_CA,\n  RD_KAFKA_CERT__CNT,\n} rd_kafka_cert_type_t;\ntypedef enum rd_kafka_cert_enc_t {\n  RD_KAFKA_CERT_ENC_PKCS12,\n  RD_KAFKA_CERT_ENC_DER,\n  RD_KAFKA_CERT_ENC_PEM,\n  RD_KAFKA_CERT_ENC__CNT,\n} rd_kafka_cert_enc_t;\nrd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert(rd_kafka_conf_t *conf, rd_kafka_cert_type_t cert_type, rd_kafka_cert_enc_t cert_enc, const void *buffer, size_t size, char *errstr, size_t errstr_size);\nvoid rd_kafka_conf_set_engine_callback_data(rd_kafka_conf_t *conf, void *callback_data);\nvoid rd_kafka_conf_set_opaque(rd_kafka_conf_t *conf, void *opaque);\nvoid *rd_kafka_opaque(const rd_kafka_t *rk);\nvoid rd_kafka_conf_set_default_topic_conf(rd_kafka_conf_t *conf, rd_kafka_topic_conf_t *tconf);\nrd_kafka_topic_conf_t *rd_kafka_conf_get_default_topic_conf(rd_kafka_conf_t *conf);\nrd_kafka_conf_res_t rd_kafka_conf_get(const rd_kafka_conf_t *conf, const char *name, char *dest, size_t *dest_size);\nrd_kafka_conf_res_t rd_kafka_topic_conf_get(const rd_kafka_topic_conf_t *conf, const char *name, char *dest, size_t *dest_size);\nconst char **rd_kafka_conf_dump(rd_kafka_conf_t *conf, size_t *cntp);\nconst char **rd_kafka_topic_conf_dump(rd_kafka_topic_conf_t *conf, size_t *cntp);\nvoid rd_kafka_conf_dump_free(const char **arr, size_t cnt);\nvoid rd_kafka_conf_properties_show(FILE *fp);\nrd_kafka_topic_conf_t *rd_kafka_topic_conf_new(void);\nrd_kafka_topic_conf_t *rd_kafka_topic_conf_dup(const rd_kafka_topic_conf_t *conf);\nrd_kafka_topic_conf_t *rd_kafka_default_topic_conf_dup(rd_kafka_t *rk);\nvoid rd_kafka_topic_conf_destroy(rd_kafka_topic_conf_t *topic_conf);\nrd_kafka_conf_res_t rd_kafka_topic_conf_set(rd_kafka_topic_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);\nvoid rd_kafka_topic_conf_set_opaque(rd_kafka_topic_conf_t *conf, void *rkt_opaque);\nvoid rd_kafka_topic_conf_set_partitioner_cb(rd_kafka_topic_conf_t *topic_conf, int32_t (*partitioner)(const rd_kafka_topic_t *rkt, const void *keydata, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque));\nvoid rd_kafka_topic_conf_set_msg_order_cmp(rd_kafka_topic_conf_t *topic_conf, int (*msg_order_cmp)(const rd_kafka_message_t *a, const rd_kafka_message_t *b));\nint rd_kafka_topic_partition_available(const rd_kafka_topic_t *rkt, int32_t partition);\nint32_t rd_kafka_msg_partitioner_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_consistent(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_consistent_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_murmur2(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_murmur2_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_fnv1a(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_fnv1a_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nrd_kafka_t *rd_kafka_new(rd_kafka_type_t type, rd_kafka_conf_t *conf, char *errstr, size_t errstr_size);\nvoid rd_kafka_destroy(rd_kafka_t *rk);\nvoid rd_kafka_destroy_flags(rd_kafka_t *rk, int flags);\nconst char *rd_kafka_name(const rd_kafka_t *rk);\nrd_kafka_type_t rd_kafka_type(const rd_kafka_t *rk);\nchar *rd_kafka_memberid(const rd_kafka_t *rk);\nchar *rd_kafka_clusterid(rd_kafka_t *rk, int timeout_ms);\nint32_t rd_kafka_controllerid(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_topic_t *rd_kafka_topic_new(rd_kafka_t *rk, const char *topic, rd_kafka_topic_conf_t *conf);\nvoid rd_kafka_topic_destroy(rd_kafka_topic_t *rkt);\nconst char *rd_kafka_topic_name(const rd_kafka_topic_t *rkt);\nvoid *rd_kafka_topic_opaque(const rd_kafka_topic_t *rkt);\nint rd_kafka_poll(rd_kafka_t *rk, int timeout_ms);\nvoid rd_kafka_yield(rd_kafka_t *rk);\nrd_kafka_resp_err_t rd_kafka_pause_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_resp_err_t rd_kafka_resume_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_resp_err_t rd_kafka_query_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high, int timeout_ms);\nrd_kafka_resp_err_t rd_kafka_get_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high);\nrd_kafka_resp_err_t rd_kafka_offsets_for_times(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets, int timeout_ms);\nvoid *rd_kafka_mem_calloc(rd_kafka_t *rk, size_t num, size_t size);\nvoid *rd_kafka_mem_malloc(rd_kafka_t *rk, size_t size);\nvoid rd_kafka_mem_free(rd_kafka_t *rk, void *ptr);\nrd_kafka_queue_t *rd_kafka_queue_new(rd_kafka_t *rk);\nvoid rd_kafka_queue_destroy(rd_kafka_queue_t *rkqu);\nrd_kafka_queue_t *rd_kafka_queue_get_main(rd_kafka_t *rk);\nrd_kafka_queue_t *rd_kafka_queue_get_sasl(rd_kafka_t *rk);\nrd_kafka_error_t *rd_kafka_sasl_background_callbacks_enable(rd_kafka_t *rk);\nrd_kafka_queue_t *rd_kafka_queue_get_consumer(rd_kafka_t *rk);\nrd_kafka_queue_t *rd_kafka_queue_get_partition(rd_kafka_t *rk, const char *topic, int32_t partition);\nrd_kafka_queue_t *rd_kafka_queue_get_background(rd_kafka_t *rk);\nvoid rd_kafka_queue_forward(rd_kafka_queue_t *src, rd_kafka_queue_t *dst);\nrd_kafka_resp_err_t rd_kafka_set_log_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu);\nsize_t rd_kafka_queue_length(rd_kafka_queue_t *rkqu);\nvoid rd_kafka_queue_io_event_enable(rd_kafka_queue_t *rkqu, int fd, const void *payload, size_t size);\nvoid rd_kafka_queue_cb_event_enable(rd_kafka_queue_t *rkqu, void (*event_cb)(rd_kafka_t *rk, void *qev_opaque), void *qev_opaque);\nvoid rd_kafka_queue_yield(rd_kafka_queue_t *rkqu);\nint rd_kafka_consume_start(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);\nint rd_kafka_consume_start_queue(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, rd_kafka_queue_t *rkqu);\nint rd_kafka_consume_stop(rd_kafka_topic_t *rkt, int32_t partition);\nrd_kafka_resp_err_t rd_kafka_seek(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, int timeout_ms);\nrd_kafka_error_t *rd_kafka_seek_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms);\nrd_kafka_message_t *rd_kafka_consume(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms);\nssize_t rd_kafka_consume_batch(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);\nint rd_kafka_consume_callback(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);\nrd_kafka_message_t *rd_kafka_consume_queue(rd_kafka_queue_t *rkqu, int timeout_ms);\nssize_t rd_kafka_consume_batch_queue(rd_kafka_queue_t *rkqu, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);\nint rd_kafka_consume_callback_queue(rd_kafka_queue_t *rkqu, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);\nrd_kafka_resp_err_t rd_kafka_offset_store(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);\nrd_kafka_resp_err_t rd_kafka_offsets_store(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets);\nrd_kafka_resp_err_t rd_kafka_subscribe(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *topics);\nrd_kafka_resp_err_t rd_kafka_unsubscribe(rd_kafka_t *rk);\nrd_kafka_resp_err_t rd_kafka_subscription(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **topics);\nrd_kafka_message_t *rd_kafka_consumer_poll(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_resp_err_t rd_kafka_consumer_close(rd_kafka_t *rk);\nrd_kafka_error_t *rd_kafka_consumer_close_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu);\nint rd_kafka_consumer_closed(rd_kafka_t *rk);\nrd_kafka_error_t *rd_kafka_incremental_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_error_t *rd_kafka_incremental_unassign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);\nconst char *rd_kafka_rebalance_protocol(rd_kafka_t *rk);\nrd_kafka_resp_err_t rd_kafka_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_resp_err_t rd_kafka_assignment(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **partitions);\nint rd_kafka_assignment_lost(rd_kafka_t *rk);\nrd_kafka_resp_err_t rd_kafka_commit(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, int async);\nrd_kafka_resp_err_t rd_kafka_commit_message(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, int async);\nrd_kafka_resp_err_t rd_kafka_commit_queue(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_queue_t *rkqu, void (*cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *commit_opaque), void *commit_opaque);\nrd_kafka_resp_err_t rd_kafka_committed(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms);\nrd_kafka_resp_err_t rd_kafka_position(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata(rd_kafka_t *rk);\nrd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata_new(const char *group_id);\nrd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata_new_with_genid(const char *group_id, int32_t generation_id, const char *member_id, const char *group_instance_id);\nvoid rd_kafka_consumer_group_metadata_destroy(rd_kafka_consumer_group_metadata_t *);\nrd_kafka_error_t *rd_kafka_consumer_group_metadata_write(const rd_kafka_consumer_group_metadata_t *cgmd, void **bufferp, size_t *sizep);\nrd_kafka_error_t *rd_kafka_consumer_group_metadata_read(rd_kafka_consumer_group_metadata_t **cgmdp, const void *buffer, size_t size);\nint rd_kafka_produce(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, void *payload, size_t len, const void *key, size_t keylen, void *msg_opaque);\nrd_kafka_resp_err_t rd_kafka_producev(rd_kafka_t *rk, ...);\nrd_kafka_error_t *rd_kafka_produceva(rd_kafka_t *rk, const rd_kafka_vu_t *vus, size_t cnt);\nint rd_kafka_produce_batch(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, rd_kafka_message_t *rkmessages, int message_cnt);\nrd_kafka_resp_err_t rd_kafka_flush(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_resp_err_t rd_kafka_purge(rd_kafka_t *rk, int purge_flags);\ntypedef struct rd_kafka_metadata_broker {\n  int32_t id;\n  char *host;\n  int port;\n} rd_kafka_metadata_broker_t;\ntypedef struct rd_kafka_metadata_partition {\n  int32_t id;\n  rd_kafka_resp_err_t err;\n  int32_t leader;\n  int replica_cnt;\n  int32_t *replicas;\n  int isr_cnt;\n  int32_t *isrs;\n} rd_kafka_metadata_partition_t;\ntypedef struct rd_kafka_metadata_topic {\n  char *topic;\n  int partition_cnt;\n  struct rd_kafka_metadata_partition *partitions;\n  rd_kafka_resp_err_t err;\n} rd_kafka_metadata_topic_t;\ntypedef struct rd_kafka_metadata {\n  int broker_cnt;\n  struct rd_kafka_metadata_broker *brokers;\n  int topic_cnt;\n  struct rd_kafka_metadata_topic *topics;\n  int32_t orig_broker_id;\n  char *orig_broker_name;\n} rd_kafka_metadata_t;\nrd_kafka_resp_err_t rd_kafka_metadata(rd_kafka_t *rk, int all_topics, rd_kafka_topic_t *only_rkt, const struct rd_kafka_metadata **metadatap, int timeout_ms);\nvoid rd_kafka_metadata_destroy(const struct rd_kafka_metadata *metadata);\nstruct rd_kafka_group_member_info {\n  char *member_id;\n  char *client_id;\n  char *client_host;\n  void *member_metadata;\n  int member_metadata_size;\n  void *member_assignment;\n  int member_assignment_size;\n};\nstruct rd_kafka_group_info {\n  struct rd_kafka_metadata_broker broker;\n  char *group;\n  rd_kafka_resp_err_t err;\n  char *state;\n  char *protocol_type;\n  char *protocol;\n  struct rd_kafka_group_member_info *members;\n  int member_cnt;\n};\nstruct rd_kafka_group_list {\n  struct rd_kafka_group_info *groups;\n  int group_cnt;\n};\nrd_kafka_resp_err_t rd_kafka_list_groups(rd_kafka_t *rk, const char *group, const struct rd_kafka_group_list **grplistp, int timeout_ms);\nvoid rd_kafka_group_list_destroy(const struct rd_kafka_group_list *grplist);\nint rd_kafka_brokers_add(rd_kafka_t *rk, const char *brokerlist);\nvoid rd_kafka_set_logger(rd_kafka_t *rk, void (*func)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));\nvoid rd_kafka_set_log_level(rd_kafka_t *rk, int level);\nvoid rd_kafka_log_print(const rd_kafka_t *rk, int level, const char *fac, const char *buf);\nvoid rd_kafka_log_syslog(const rd_kafka_t *rk, int level, const char *fac, const char *buf);\nint rd_kafka_outq_len(rd_kafka_t *rk);\nvoid rd_kafka_dump(FILE *fp, rd_kafka_t *rk);\nint rd_kafka_thread_cnt(void);\ntypedef enum rd_kafka_thread_type_t {\n  RD_KAFKA_THREAD_MAIN,\n  RD_KAFKA_THREAD_BACKGROUND,\n  RD_KAFKA_THREAD_BROKER,\n} rd_kafka_thread_type_t;\nint rd_kafka_wait_destroyed(int timeout_ms);\nint rd_kafka_unittest(void);\nrd_kafka_resp_err_t rd_kafka_poll_set_consumer(rd_kafka_t *rk);\ntypedef int rd_kafka_event_type_t;\nrd_kafka_event_type_t rd_kafka_event_type(const rd_kafka_event_t *rkev);\nconst char *rd_kafka_event_name(const rd_kafka_event_t *rkev);\nvoid rd_kafka_event_destroy(rd_kafka_event_t *rkev);\nconst rd_kafka_message_t *rd_kafka_event_message_next(rd_kafka_event_t *rkev);\nsize_t rd_kafka_event_message_array(rd_kafka_event_t *rkev, const rd_kafka_message_t **rkmessages, size_t size);\nsize_t rd_kafka_event_message_count(rd_kafka_event_t *rkev);\nconst char *rd_kafka_event_config_string(rd_kafka_event_t *rkev);\nrd_kafka_resp_err_t rd_kafka_event_error(rd_kafka_event_t *rkev);\nconst char *rd_kafka_event_error_string(rd_kafka_event_t *rkev);\nint rd_kafka_event_error_is_fatal(rd_kafka_event_t *rkev);\nvoid *rd_kafka_event_opaque(rd_kafka_event_t *rkev);\nint rd_kafka_event_log(rd_kafka_event_t *rkev, const char **fac, const char **str, int *level);\nint rd_kafka_event_debug_contexts(rd_kafka_event_t *rkev, char *dst, size_t dstsize);\nconst char *rd_kafka_event_stats(rd_kafka_event_t *rkev);\nrd_kafka_topic_partition_list_t *rd_kafka_event_topic_partition_list(rd_kafka_event_t *rkev);\nrd_kafka_topic_partition_t *rd_kafka_event_topic_partition(rd_kafka_event_t *rkev);\ntypedef rd_kafka_event_t rd_kafka_CreateTopics_result_t;\ntypedef rd_kafka_event_t rd_kafka_DeleteTopics_result_t;\ntypedef rd_kafka_event_t rd_kafka_CreateAcls_result_t;\ntypedef rd_kafka_event_t rd_kafka_DescribeAcls_result_t;\ntypedef rd_kafka_event_t rd_kafka_DeleteAcls_result_t;\ntypedef rd_kafka_event_t rd_kafka_CreatePartitions_result_t;\ntypedef rd_kafka_event_t rd_kafka_AlterConfigs_result_t;\ntypedef rd_kafka_event_t rd_kafka_DescribeConfigs_result_t;\ntypedef rd_kafka_event_t rd_kafka_DeleteRecords_result_t;\ntypedef rd_kafka_event_t rd_kafka_DeleteGroups_result_t;\ntypedef rd_kafka_event_t rd_kafka_DeleteConsumerGroupOffsets_result_t;\nconst rd_kafka_CreateTopics_result_t *rd_kafka_event_CreateTopics_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DeleteTopics_result_t *rd_kafka_event_DeleteTopics_result(rd_kafka_event_t *rkev);\nconst rd_kafka_CreatePartitions_result_t *rd_kafka_event_CreatePartitions_result(rd_kafka_event_t *rkev);\nconst rd_kafka_AlterConfigs_result_t *rd_kafka_event_AlterConfigs_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DescribeConfigs_result_t *rd_kafka_event_DescribeConfigs_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DeleteRecords_result_t *rd_kafka_event_DeleteRecords_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DeleteGroups_result_t *rd_kafka_event_DeleteGroups_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DeleteConsumerGroupOffsets_result_t *rd_kafka_event_DeleteConsumerGroupOffsets_result(rd_kafka_event_t *rkev);\nconst rd_kafka_CreateAcls_result_t *rd_kafka_event_CreateAcls_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DescribeAcls_result_t *rd_kafka_event_DescribeAcls_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DeleteAcls_result_t *rd_kafka_event_DeleteAcls_result(rd_kafka_event_t *rkev);\nrd_kafka_event_t *rd_kafka_queue_poll(rd_kafka_queue_t *rkqu, int timeout_ms);\nint rd_kafka_queue_poll_callback(rd_kafka_queue_t *rkqu, int timeout_ms);\ntypedef rd_kafka_resp_err_t (rd_kafka_plugin_f_conf_init_t)(rd_kafka_conf_t *conf, void **plug_opaquep, char *errstr, size_t errstr_size);\ntypedef rd_kafka_conf_res_t (rd_kafka_interceptor_f_on_conf_set_t)(rd_kafka_conf_t *conf, const char *name, const char *val, char *errstr, size_t errstr_size, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_dup_t)(rd_kafka_conf_t *new_conf, const rd_kafka_conf_t *old_conf, size_t filter_cnt, const char **filter, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_destroy_t)(void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_new_t)(rd_kafka_t *rk, const rd_kafka_conf_t *conf, void *ic_opaque, char *errstr, size_t errstr_size);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_destroy_t)(rd_kafka_t *rk, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_send_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_acknowledgement_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_consume_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_commit_t)(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_resp_err_t err, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_request_sent_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_response_received_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, int64_t rtt, rd_kafka_resp_err_t err, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_start_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_exit_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_set(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_set_t *on_conf_set, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_dup(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_dup_t *on_conf_dup, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_destroy(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_destroy_t *on_conf_destroy, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_new(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_new_t *on_new, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_destroy(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_destroy_t *on_destroy, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_send(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_send_t *on_send, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_acknowledgement(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_acknowledgement_t *on_acknowledgement, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_consume(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_consume_t *on_consume, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_commit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_commit_t *on_commit, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_request_sent(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_request_sent_t *on_request_sent, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_response_received(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_response_received_t *on_response_received, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_start(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_start_t *on_thread_start, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_exit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_exit_t *on_thread_exit, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_topic_result_error(const rd_kafka_topic_result_t *topicres);\nconst char *rd_kafka_topic_result_error_string(const rd_kafka_topic_result_t *topicres);\nconst char *rd_kafka_topic_result_name(const rd_kafka_topic_result_t *topicres);\nconst rd_kafka_error_t *rd_kafka_group_result_error(const rd_kafka_group_result_t *groupres);\nconst char *rd_kafka_group_result_name(const rd_kafka_group_result_t *groupres);\nconst rd_kafka_topic_partition_list_t *rd_kafka_group_result_partitions(const rd_kafka_group_result_t *groupres);\ntypedef enum rd_kafka_admin_op_t {\n  RD_KAFKA_ADMIN_OP_ANY = 0,\n  RD_KAFKA_ADMIN_OP_CREATETOPICS,\n  RD_KAFKA_ADMIN_OP_DELETETOPICS,\n  RD_KAFKA_ADMIN_OP_CREATEPARTITIONS,\n  RD_KAFKA_ADMIN_OP_ALTERCONFIGS,\n  RD_KAFKA_ADMIN_OP_DESCRIBECONFIGS,\n  RD_KAFKA_ADMIN_OP_DELETERECORDS,\n  RD_KAFKA_ADMIN_OP_DELETEGROUPS,\n  RD_KAFKA_ADMIN_OP_DELETECONSUMERGROUPOFFSETS,\n  RD_KAFKA_ADMIN_OP_CREATEACLS,\n  RD_KAFKA_ADMIN_OP_DESCRIBEACLS,\n  RD_KAFKA_ADMIN_OP_DELETEACLS,\n  RD_KAFKA_ADMIN_OP__CNT,\n} rd_kafka_admin_op_t;\ntypedef struct rd_kafka_AdminOptions_s rd_kafka_AdminOptions_t;\nrd_kafka_AdminOptions_t *rd_kafka_AdminOptions_new(rd_kafka_t *rk, rd_kafka_admin_op_t for_api);\nvoid rd_kafka_AdminOptions_destroy(rd_kafka_AdminOptions_t *options);\nrd_kafka_resp_err_t rd_kafka_AdminOptions_set_request_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_AdminOptions_set_operation_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_AdminOptions_set_validate_only(rd_kafka_AdminOptions_t *options, int true_or_false, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_AdminOptions_set_broker(rd_kafka_AdminOptions_t *options, int32_t broker_id, char *errstr, size_t errstr_size);\nvoid rd_kafka_AdminOptions_set_opaque(rd_kafka_AdminOptions_t *options, void *ev_opaque);\ntypedef struct rd_kafka_NewTopic_s rd_kafka_NewTopic_t;\nrd_kafka_NewTopic_t *rd_kafka_NewTopic_new(const char *topic, int num_partitions, int replication_factor, char *errstr, size_t errstr_size);\nvoid rd_kafka_NewTopic_destroy(rd_kafka_NewTopic_t *new_topic);\nvoid rd_kafka_NewTopic_destroy_array(rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt);\nrd_kafka_resp_err_t rd_kafka_NewTopic_set_replica_assignment(rd_kafka_NewTopic_t *new_topic, int32_t partition, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_NewTopic_set_config(rd_kafka_NewTopic_t *new_topic, const char *name, const char *value);\nvoid rd_kafka_CreateTopics(rd_kafka_t *rk, rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_topic_result_t **rd_kafka_CreateTopics_result_topics(const rd_kafka_CreateTopics_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_DeleteTopic_s rd_kafka_DeleteTopic_t;\nrd_kafka_DeleteTopic_t *rd_kafka_DeleteTopic_new(const char *topic);\nvoid rd_kafka_DeleteTopic_destroy(rd_kafka_DeleteTopic_t *del_topic);\nvoid rd_kafka_DeleteTopic_destroy_array(rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt);\nvoid rd_kafka_DeleteTopics(rd_kafka_t *rk, rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_topic_result_t **rd_kafka_DeleteTopics_result_topics(const rd_kafka_DeleteTopics_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_NewPartitions_s rd_kafka_NewPartitions_t;\nrd_kafka_NewPartitions_t *rd_kafka_NewPartitions_new(const char *topic, size_t new_total_cnt, char *errstr, size_t errstr_size);\nvoid rd_kafka_NewPartitions_destroy(rd_kafka_NewPartitions_t *new_parts);\nvoid rd_kafka_NewPartitions_destroy_array(rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt);\nrd_kafka_resp_err_t rd_kafka_NewPartitions_set_replica_assignment(rd_kafka_NewPartitions_t *new_parts, int32_t new_partition_idx, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);\nvoid rd_kafka_CreatePartitions(rd_kafka_t *rk, rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_topic_result_t **rd_kafka_CreatePartitions_result_topics(const rd_kafka_CreatePartitions_result_t *result, size_t *cntp);\ntypedef enum rd_kafka_ConfigSource_t {\n  RD_KAFKA_CONFIG_SOURCE_UNKNOWN_CONFIG = 0,\n  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_TOPIC_CONFIG = 1,\n  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_BROKER_CONFIG = 2,\n  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_DEFAULT_BROKER_CONFIG = 3,\n  RD_KAFKA_CONFIG_SOURCE_STATIC_BROKER_CONFIG = 4,\n  RD_KAFKA_CONFIG_SOURCE_DEFAULT_CONFIG = 5,\n  RD_KAFKA_CONFIG_SOURCE__CNT,\n} rd_kafka_ConfigSource_t;\nconst char *rd_kafka_ConfigSource_name(rd_kafka_ConfigSource_t confsource);\ntypedef struct rd_kafka_ConfigEntry_s rd_kafka_ConfigEntry_t;\nconst char *rd_kafka_ConfigEntry_name(const rd_kafka_ConfigEntry_t *entry);\nconst char *rd_kafka_ConfigEntry_value(const rd_kafka_ConfigEntry_t *entry);\nrd_kafka_ConfigSource_t rd_kafka_ConfigEntry_source(const rd_kafka_ConfigEntry_t *entry);\nint rd_kafka_ConfigEntry_is_read_only(const rd_kafka_ConfigEntry_t *entry);\nint rd_kafka_ConfigEntry_is_default(const rd_kafka_ConfigEntry_t *entry);\nint rd_kafka_ConfigEntry_is_sensitive(const rd_kafka_ConfigEntry_t *entry);\nint rd_kafka_ConfigEntry_is_synonym(const rd_kafka_ConfigEntry_t *entry);\nconst rd_kafka_ConfigEntry_t **rd_kafka_ConfigEntry_synonyms(const rd_kafka_ConfigEntry_t *entry, size_t *cntp);\ntypedef enum rd_kafka_ResourceType_t {\n  RD_KAFKA_RESOURCE_UNKNOWN = 0,\n  RD_KAFKA_RESOURCE_ANY = 1,\n  RD_KAFKA_RESOURCE_TOPIC = 2,\n  RD_KAFKA_RESOURCE_GROUP = 3,\n  RD_KAFKA_RESOURCE_BROKER = 4,\n  RD_KAFKA_RESOURCE__CNT,\n} rd_kafka_ResourceType_t;\ntypedef enum rd_kafka_ResourcePatternType_t {\n  RD_KAFKA_RESOURCE_PATTERN_UNKNOWN = 0,\n  RD_KAFKA_RESOURCE_PATTERN_ANY = 1,\n  RD_KAFKA_RESOURCE_PATTERN_MATCH = 2,\n  RD_KAFKA_RESOURCE_PATTERN_LITERAL = 3,\n  RD_KAFKA_RESOURCE_PATTERN_PREFIXED = 4,\n  RD_KAFKA_RESOURCE_PATTERN_TYPE__CNT,\n} rd_kafka_ResourcePatternType_t;\nconst char *rd_kafka_ResourcePatternType_name(rd_kafka_ResourcePatternType_t resource_pattern_type);\nconst char *rd_kafka_ResourceType_name(rd_kafka_ResourceType_t restype);\ntypedef struct rd_kafka_ConfigResource_s rd_kafka_ConfigResource_t;\nrd_kafka_ConfigResource_t *rd_kafka_ConfigResource_new(rd_kafka_ResourceType_t restype, const char *resname);\nvoid rd_kafka_ConfigResource_destroy(rd_kafka_ConfigResource_t *config);\nvoid rd_kafka_ConfigResource_destroy_array(rd_kafka_ConfigResource_t **config, size_t config_cnt);\nrd_kafka_resp_err_t rd_kafka_ConfigResource_set_config(rd_kafka_ConfigResource_t *config, const char *name, const char *value);\nconst rd_kafka_ConfigEntry_t **rd_kafka_ConfigResource_configs(const rd_kafka_ConfigResource_t *config, size_t *cntp);\nrd_kafka_ResourceType_t rd_kafka_ConfigResource_type(const rd_kafka_ConfigResource_t *config);\nconst char *rd_kafka_ConfigResource_name(const rd_kafka_ConfigResource_t *config);\nrd_kafka_resp_err_t rd_kafka_ConfigResource_error(const rd_kafka_ConfigResource_t *config);\nconst char *rd_kafka_ConfigResource_error_string(const rd_kafka_ConfigResource_t *config);\nvoid rd_kafka_AlterConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_ConfigResource_t **rd_kafka_AlterConfigs_result_resources(const rd_kafka_AlterConfigs_result_t *result, size_t *cntp);\nvoid rd_kafka_DescribeConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_ConfigResource_t **rd_kafka_DescribeConfigs_result_resources(const rd_kafka_DescribeConfigs_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_DeleteRecords_s rd_kafka_DeleteRecords_t;\nrd_kafka_DeleteRecords_t *rd_kafka_DeleteRecords_new(const rd_kafka_topic_partition_list_t *before_offsets);\nvoid rd_kafka_DeleteRecords_destroy(rd_kafka_DeleteRecords_t *del_records);\nvoid rd_kafka_DeleteRecords_destroy_array(rd_kafka_DeleteRecords_t **del_records, size_t del_record_cnt);\nvoid rd_kafka_DeleteRecords(rd_kafka_t *rk, rd_kafka_DeleteRecords_t **del_records, size_t del_record_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_topic_partition_list_t *rd_kafka_DeleteRecords_result_offsets(const rd_kafka_DeleteRecords_result_t *result);\ntypedef struct rd_kafka_DeleteGroup_s rd_kafka_DeleteGroup_t;\nrd_kafka_DeleteGroup_t *rd_kafka_DeleteGroup_new(const char *group);\nvoid rd_kafka_DeleteGroup_destroy(rd_kafka_DeleteGroup_t *del_group);\nvoid rd_kafka_DeleteGroup_destroy_array(rd_kafka_DeleteGroup_t **del_groups, size_t del_group_cnt);\nvoid rd_kafka_DeleteGroups(rd_kafka_t *rk, rd_kafka_DeleteGroup_t **del_groups, size_t del_group_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_group_result_t **rd_kafka_DeleteGroups_result_groups(const rd_kafka_DeleteGroups_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_DeleteConsumerGroupOffsets_s rd_kafka_DeleteConsumerGroupOffsets_t;\nrd_kafka_DeleteConsumerGroupOffsets_t *rd_kafka_DeleteConsumerGroupOffsets_new(const char *group, const rd_kafka_topic_partition_list_t *partitions);\nvoid rd_kafka_DeleteConsumerGroupOffsets_destroy(rd_kafka_DeleteConsumerGroupOffsets_t *del_grpoffsets);\nvoid rd_kafka_DeleteConsumerGroupOffsets_destroy_array(rd_kafka_DeleteConsumerGroupOffsets_t **del_grpoffsets, size_t del_grpoffset_cnt);\nvoid rd_kafka_DeleteConsumerGroupOffsets(rd_kafka_t *rk, rd_kafka_DeleteConsumerGroupOffsets_t **del_grpoffsets, size_t del_grpoffsets_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_group_result_t **rd_kafka_DeleteConsumerGroupOffsets_result_groups(const rd_kafka_DeleteConsumerGroupOffsets_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_AclBinding_s rd_kafka_AclBinding_t;\ntypedef rd_kafka_AclBinding_t rd_kafka_AclBindingFilter_t;\nconst rd_kafka_error_t *rd_kafka_acl_result_error(const rd_kafka_acl_result_t *aclres);\ntypedef enum rd_kafka_AclOperation_t {\n  RD_KAFKA_ACL_OPERATION_UNKNOWN = 0,\n  RD_KAFKA_ACL_OPERATION_ANY = 1,\n  RD_KAFKA_ACL_OPERATION_ALL = 2,\n  RD_KAFKA_ACL_OPERATION_READ = 3,\n  RD_KAFKA_ACL_OPERATION_WRITE = 4,\n  RD_KAFKA_ACL_OPERATION_CREATE = 5,\n  RD_KAFKA_ACL_OPERATION_DELETE = 6,\n  RD_KAFKA_ACL_OPERATION_ALTER = 7,\n  RD_KAFKA_ACL_OPERATION_DESCRIBE = 8,\n  RD_KAFKA_ACL_OPERATION_CLUSTER_ACTION = 9,\n  RD_KAFKA_ACL_OPERATION_DESCRIBE_CONFIGS = 10,\n  RD_KAFKA_ACL_OPERATION_ALTER_CONFIGS = 11,\n  RD_KAFKA_ACL_OPERATION_IDEMPOTENT_WRITE = 12,\n  RD_KAFKA_ACL_OPERATION__CNT,\n} rd_kafka_AclOperation_t;\nconst char *rd_kafka_AclOperation_name(rd_kafka_AclOperation_t acl_operation);\ntypedef enum rd_kafka_AclPermissionType_t {\n  RD_KAFKA_ACL_PERMISSION_TYPE_UNKNOWN = 0,\n  RD_KAFKA_ACL_PERMISSION_TYPE_ANY = 1,\n  RD_KAFKA_ACL_PERMISSION_TYPE_DENY = 2,\n  RD_KAFKA_ACL_PERMISSION_TYPE_ALLOW = 3,\n  RD_KAFKA_ACL_PERMISSION_TYPE__CNT,\n} rd_kafka_AclPermissionType_t;\nconst char *rd_kafka_AclPermissionType_name(rd_kafka_AclPermissionType_t acl_permission_type);\nrd_kafka_AclBinding_t *rd_kafka_AclBinding_new(rd_kafka_ResourceType_t restype, const char *name, rd_kafka_ResourcePatternType_t resource_pattern_type, const char *principal, const char *host, rd_kafka_AclOperation_t operation, rd_kafka_AclPermissionType_t permission_type, char *errstr, size_t errstr_size);\nrd_kafka_AclBindingFilter_t *rd_kafka_AclBindingFilter_new(rd_kafka_ResourceType_t restype, const char *name, rd_kafka_ResourcePatternType_t resource_pattern_type, const char *principal, const char *host, rd_kafka_AclOperation_t operation, rd_kafka_AclPermissionType_t permission_type, char *errstr, size_t errstr_size);\nrd_kafka_ResourceType_t rd_kafka_AclBinding_restype(const rd_kafka_AclBinding_t *acl);\nconst char *rd_kafka_AclBinding_name(const rd_kafka_AclBinding_t *acl);\nconst char *rd_kafka_AclBinding_principal(const rd_kafka_AclBinding_t *acl);\nconst char *rd_kafka_AclBinding_host(const rd_kafka_AclBinding_t *acl);\nrd_kafka_AclOperation_t rd_kafka_AclBinding_operation(const rd_kafka_AclBinding_t *acl);\nrd_kafka_AclPermissionType_t rd_kafka_AclBinding_permission_type(const rd_kafka_AclBinding_t *acl);\nrd_kafka_ResourcePatternType_t rd_kafka_AclBinding_resource_pattern_type(const rd_kafka_AclBinding_t *acl);\nconst rd_kafka_error_t *rd_kafka_AclBinding_error(const rd_kafka_AclBinding_t *acl);\nvoid rd_kafka_AclBinding_destroy(rd_kafka_AclBinding_t *acl_binding);\nvoid rd_kafka_AclBinding_destroy_array(rd_kafka_AclBinding_t **acl_bindings, size_t acl_bindings_cnt);\nconst rd_kafka_acl_result_t **rd_kafka_CreateAcls_result_acls(const rd_kafka_CreateAcls_result_t *result, size_t *cntp);\nvoid rd_kafka_CreateAcls(rd_kafka_t *rk, rd_kafka_AclBinding_t **new_acls, size_t new_acls_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_AclBinding_t **rd_kafka_DescribeAcls_result_acls(const rd_kafka_DescribeAcls_result_t *result, size_t *cntp);\nvoid rd_kafka_DescribeAcls(rd_kafka_t *rk, rd_kafka_AclBindingFilter_t *acl_filter, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\ntypedef struct rd_kafka_DeleteAcls_result_response_s rd_kafka_DeleteAcls_result_response_t;\nconst rd_kafka_DeleteAcls_result_response_t **rd_kafka_DeleteAcls_result_responses(const rd_kafka_DeleteAcls_result_t *result, size_t *cntp);\nconst rd_kafka_error_t *rd_kafka_DeleteAcls_result_response_error(const rd_kafka_DeleteAcls_result_response_t *result_response);\nconst rd_kafka_AclBinding_t **rd_kafka_DeleteAcls_result_response_matching_acls(const rd_kafka_DeleteAcls_result_response_t *result_response, size_t *matching_acls_cntp);\nvoid rd_kafka_DeleteAcls(rd_kafka_t *rk, rd_kafka_AclBindingFilter_t **del_acls, size_t del_acls_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nrd_kafka_resp_err_t rd_kafka_oauthbearer_set_token(rd_kafka_t *rk, const char *token_value, int64_t md_lifetime_ms, const char *md_principal_name, const char **extensions, size_t extension_size, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_oauthbearer_set_token_failure(rd_kafka_t *rk, const char *errstr);\nrd_kafka_error_t *rd_kafka_init_transactions(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_error_t *rd_kafka_begin_transaction(rd_kafka_t *rk);\nrd_kafka_error_t *rd_kafka_send_offsets_to_transaction(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, const rd_kafka_consumer_group_metadata_t *cgmetadata, int timeout_ms);\nrd_kafka_error_t *rd_kafka_commit_transaction(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_error_t *rd_kafka_abort_transaction(rd_kafka_t *rk, int timeout_ms);\ntypedef struct rd_kafka_mock_cluster_s rd_kafka_mock_cluster_t;\nrd_kafka_mock_cluster_t *rd_kafka_mock_cluster_new(rd_kafka_t *rk, int broker_cnt);\nvoid rd_kafka_mock_cluster_destroy(rd_kafka_mock_cluster_t *mcluster);\nrd_kafka_t *rd_kafka_mock_cluster_handle(const rd_kafka_mock_cluster_t *mcluster);\nrd_kafka_mock_cluster_t *rd_kafka_handle_mock_cluster(const rd_kafka_t *rk);\nconst char *rd_kafka_mock_cluster_bootstraps(const rd_kafka_mock_cluster_t *mcluster);\nvoid rd_kafka_mock_clear_request_errors(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey);\nvoid rd_kafka_mock_push_request_errors(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, size_t cnt, ...);\nvoid rd_kafka_mock_push_request_errors_array(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, size_t cnt, const rd_kafka_resp_err_t *errors);\nrd_kafka_resp_err_t rd_kafka_mock_broker_push_request_error_rtts(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int16_t ApiKey, size_t cnt, ...);\nvoid rd_kafka_mock_topic_set_error(rd_kafka_mock_cluster_t *mcluster, const char *topic, rd_kafka_resp_err_t err);\nrd_kafka_resp_err_t rd_kafka_mock_topic_create(rd_kafka_mock_cluster_t *mcluster, const char *topic, int partition_cnt, int replication_factor);\nrd_kafka_resp_err_t rd_kafka_mock_partition_set_leader(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id);\nrd_kafka_resp_err_t rd_kafka_mock_partition_set_follower(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id);\nrd_kafka_resp_err_t rd_kafka_mock_partition_set_follower_wmarks(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int64_t lo, int64_t hi);\nrd_kafka_resp_err_t rd_kafka_mock_broker_set_down(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id);\nrd_kafka_resp_err_t rd_kafka_mock_broker_set_up(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id);\nrd_kafka_resp_err_t rd_kafka_mock_broker_set_rtt(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int rtt_ms);\nrd_kafka_resp_err_t rd_kafka_mock_broker_set_rack(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, const char *rack);\nrd_kafka_resp_err_t rd_kafka_mock_coordinator_set(rd_kafka_mock_cluster_t *mcluster, const char *key_type, const char *key, int32_t broker_id);\nrd_kafka_resp_err_t rd_kafka_mock_set_apiversion(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, int16_t MinVersion, int16_t MaxVersion);\n'\n</code></pre> rdkafka.h, rdkafka_mock.h</p>"},{"location":"api/constants/#rd_kafka_version_21","title":"RD_KAFKA_VERSION","text":"<pre><code>public RD_KAFKA_VERSION = 17367807\n</code></pre> <p>librdkafka version </p> <p>Interpreted as hex <code>MM.mm.rr.xx</code>:</p> <ul> <li>MM = Major</li> <li>mm = minor</li> <li>rr = revision</li> <li>xx = pre-release id (0xff is the final release)</li> </ul> <p>E.g.: <code>0x000801ff</code> = 0.8.1</p> RemarksThis value should only be used during compile time, for runtime checks of version use rd_kafka_version()  <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_unsupported_compression_type_21","title":"RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE","text":"<pre><code>public RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76\n</code></pre> <p>Unsupported compression type </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_end_all_21","title":"RD_KAFKA_RESP_ERR_END_ALL","text":"<p><pre><code>public RD_KAFKA_RESP_ERR_END_ALL = 98\n</code></pre> enum rd_kafka_resp_err_t</p>"},{"location":"api/constants/#rd_kafka_admin_op__cnt_21","title":"RD_KAFKA_ADMIN_OP__CNT","text":"<pre><code>public RD_KAFKA_ADMIN_OP__CNT = 12\n</code></pre> <p>Number of ops defined </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe </li> </ul>"},{"location":"api/constants/#rd_kafka_resource__cnt_21","title":"RD_KAFKA_RESOURCE__CNT","text":"<pre><code>public RD_KAFKA_RESOURCE__CNT = 5\n</code></pre> <p>Number of resource types defined </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#acca83a66d7783ff7683ed2691cc907c9 </li> </ul>"},{"location":"api/constants/#rd_kafka_cdef_21","title":"RD_KAFKA_CDEF","text":"<p><pre><code>public RD_KAFKA_CDEF = 'typedef long int ssize_t;\ntypedef struct _IO_FILE FILE;\ntypedef long int mode_t;\ntypedef signed int int16_t;\ntypedef unsigned int uint16_t;\ntypedef signed int int32_t;\ntypedef signed long int int64_t;\nint rd_kafka_version(void);\nconst char *rd_kafka_version_str(void);\ntypedef enum rd_kafka_type_t {\n  RD_KAFKA_PRODUCER,\n  RD_KAFKA_CONSUMER,\n} rd_kafka_type_t;\ntypedef enum rd_kafka_timestamp_type_t {\n  RD_KAFKA_TIMESTAMP_NOT_AVAILABLE,\n  RD_KAFKA_TIMESTAMP_CREATE_TIME,\n  RD_KAFKA_TIMESTAMP_LOG_APPEND_TIME,\n} rd_kafka_timestamp_type_t;\nconst char *rd_kafka_get_debug_contexts(void);\ntypedef struct rd_kafka_s rd_kafka_t;\ntypedef struct rd_kafka_topic_s rd_kafka_topic_t;\ntypedef struct rd_kafka_conf_s rd_kafka_conf_t;\ntypedef struct rd_kafka_topic_conf_s rd_kafka_topic_conf_t;\ntypedef struct rd_kafka_queue_s rd_kafka_queue_t;\ntypedef struct rd_kafka_op_s rd_kafka_event_t;\ntypedef struct rd_kafka_topic_result_s rd_kafka_topic_result_t;\ntypedef struct rd_kafka_consumer_group_metadata_s rd_kafka_consumer_group_metadata_t;\ntypedef struct rd_kafka_error_s {\n  unsigned int code;\n  char *errstr;\n  unsigned char fatal;\n  unsigned char retriable;\n  unsigned char txn_requires_abort;\n} rd_kafka_error_t;\ntypedef struct rd_kafka_headers_s rd_kafka_headers_t;\ntypedef struct rd_kafka_group_result_s rd_kafka_group_result_t;\ntypedef struct rd_kafka_acl_result_s rd_kafka_acl_result_t;\ntypedef enum {\n  RD_KAFKA_RESP_ERR__BEGIN = (- 200),\n  RD_KAFKA_RESP_ERR__BAD_MSG = (- 199),\n  RD_KAFKA_RESP_ERR__BAD_COMPRESSION = (- 198),\n  RD_KAFKA_RESP_ERR__DESTROY = (- 197),\n  RD_KAFKA_RESP_ERR__FAIL = (- 196),\n  RD_KAFKA_RESP_ERR__TRANSPORT = (- 195),\n  RD_KAFKA_RESP_ERR__CRIT_SYS_RESOURCE = (- 194),\n  RD_KAFKA_RESP_ERR__RESOLVE = (- 193),\n  RD_KAFKA_RESP_ERR__MSG_TIMED_OUT = (- 192),\n  RD_KAFKA_RESP_ERR__PARTITION_EOF = (- 191),\n  RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION = (- 190),\n  RD_KAFKA_RESP_ERR__FS = (- 189),\n  RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC = (- 188),\n  RD_KAFKA_RESP_ERR__ALL_BROKERS_DOWN = (- 187),\n  RD_KAFKA_RESP_ERR__INVALID_ARG = (- 186),\n  RD_KAFKA_RESP_ERR__TIMED_OUT = (- 185),\n  RD_KAFKA_RESP_ERR__QUEUE_FULL = (- 184),\n  RD_KAFKA_RESP_ERR__ISR_INSUFF = (- 183),\n  RD_KAFKA_RESP_ERR__NODE_UPDATE = (- 182),\n  RD_KAFKA_RESP_ERR__SSL = (- 181),\n  RD_KAFKA_RESP_ERR__WAIT_COORD = (- 180),\n  RD_KAFKA_RESP_ERR__UNKNOWN_GROUP = (- 179),\n  RD_KAFKA_RESP_ERR__IN_PROGRESS = (- 178),\n  RD_KAFKA_RESP_ERR__PREV_IN_PROGRESS = (- 177),\n  RD_KAFKA_RESP_ERR__EXISTING_SUBSCRIPTION = (- 176),\n  RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS = (- 175),\n  RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS = (- 174),\n  RD_KAFKA_RESP_ERR__CONFLICT = (- 173),\n  RD_KAFKA_RESP_ERR__STATE = (- 172),\n  RD_KAFKA_RESP_ERR__UNKNOWN_PROTOCOL = (- 171),\n  RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED = (- 170),\n  RD_KAFKA_RESP_ERR__AUTHENTICATION = (- 169),\n  RD_KAFKA_RESP_ERR__NO_OFFSET = (- 168),\n  RD_KAFKA_RESP_ERR__OUTDATED = (- 167),\n  RD_KAFKA_RESP_ERR__TIMED_OUT_QUEUE = (- 166),\n  RD_KAFKA_RESP_ERR__UNSUPPORTED_FEATURE = (- 165),\n  RD_KAFKA_RESP_ERR__WAIT_CACHE = (- 164),\n  RD_KAFKA_RESP_ERR__INTR = (- 163),\n  RD_KAFKA_RESP_ERR__KEY_SERIALIZATION = (- 162),\n  RD_KAFKA_RESP_ERR__VALUE_SERIALIZATION = (- 161),\n  RD_KAFKA_RESP_ERR__KEY_DESERIALIZATION = (- 160),\n  RD_KAFKA_RESP_ERR__VALUE_DESERIALIZATION = (- 159),\n  RD_KAFKA_RESP_ERR__PARTIAL = (- 158),\n  RD_KAFKA_RESP_ERR__READ_ONLY = (- 157),\n  RD_KAFKA_RESP_ERR__NOENT = (- 156),\n  RD_KAFKA_RESP_ERR__UNDERFLOW = (- 155),\n  RD_KAFKA_RESP_ERR__INVALID_TYPE = (- 154),\n  RD_KAFKA_RESP_ERR__RETRY = (- 153),\n  RD_KAFKA_RESP_ERR__PURGE_QUEUE = (- 152),\n  RD_KAFKA_RESP_ERR__PURGE_INFLIGHT = (- 151),\n  RD_KAFKA_RESP_ERR__FATAL = (- 150),\n  RD_KAFKA_RESP_ERR__INCONSISTENT = (- 149),\n  RD_KAFKA_RESP_ERR__GAPLESS_GUARANTEE = (- 148),\n  RD_KAFKA_RESP_ERR__MAX_POLL_EXCEEDED = (- 147),\n  RD_KAFKA_RESP_ERR__UNKNOWN_BROKER = (- 146),\n  RD_KAFKA_RESP_ERR__NOT_CONFIGURED = (- 145),\n  RD_KAFKA_RESP_ERR__FENCED = (- 144),\n  RD_KAFKA_RESP_ERR__APPLICATION = (- 143),\n  RD_KAFKA_RESP_ERR__ASSIGNMENT_LOST = (- 142),\n  RD_KAFKA_RESP_ERR__NOOP = (- 141),\n  RD_KAFKA_RESP_ERR__AUTO_OFFSET_RESET = (- 140),\n  RD_KAFKA_RESP_ERR__END = (- 100),\n  RD_KAFKA_RESP_ERR_UNKNOWN = (- 1),\n  RD_KAFKA_RESP_ERR_NO_ERROR = 0,\n  RD_KAFKA_RESP_ERR_OFFSET_OUT_OF_RANGE = 1,\n  RD_KAFKA_RESP_ERR_INVALID_MSG = 2,\n  RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART = 3,\n  RD_KAFKA_RESP_ERR_INVALID_MSG_SIZE = 4,\n  RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE = 5,\n  RD_KAFKA_RESP_ERR_NOT_LEADER_FOR_PARTITION = 6,\n  RD_KAFKA_RESP_ERR_REQUEST_TIMED_OUT = 7,\n  RD_KAFKA_RESP_ERR_BROKER_NOT_AVAILABLE = 8,\n  RD_KAFKA_RESP_ERR_REPLICA_NOT_AVAILABLE = 9,\n  RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE = 10,\n  RD_KAFKA_RESP_ERR_STALE_CTRL_EPOCH = 11,\n  RD_KAFKA_RESP_ERR_OFFSET_METADATA_TOO_LARGE = 12,\n  RD_KAFKA_RESP_ERR_NETWORK_EXCEPTION = 13,\n  RD_KAFKA_RESP_ERR_COORDINATOR_LOAD_IN_PROGRESS = 14,\n  RD_KAFKA_RESP_ERR_COORDINATOR_NOT_AVAILABLE = 15,\n  RD_KAFKA_RESP_ERR_NOT_COORDINATOR = 16,\n  RD_KAFKA_RESP_ERR_TOPIC_EXCEPTION = 17,\n  RD_KAFKA_RESP_ERR_RECORD_LIST_TOO_LARGE = 18,\n  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS = 19,\n  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS_AFTER_APPEND = 20,\n  RD_KAFKA_RESP_ERR_INVALID_REQUIRED_ACKS = 21,\n  RD_KAFKA_RESP_ERR_ILLEGAL_GENERATION = 22,\n  RD_KAFKA_RESP_ERR_INCONSISTENT_GROUP_PROTOCOL = 23,\n  RD_KAFKA_RESP_ERR_INVALID_GROUP_ID = 24,\n  RD_KAFKA_RESP_ERR_UNKNOWN_MEMBER_ID = 25,\n  RD_KAFKA_RESP_ERR_INVALID_SESSION_TIMEOUT = 26,\n  RD_KAFKA_RESP_ERR_REBALANCE_IN_PROGRESS = 27,\n  RD_KAFKA_RESP_ERR_INVALID_COMMIT_OFFSET_SIZE = 28,\n  RD_KAFKA_RESP_ERR_TOPIC_AUTHORIZATION_FAILED = 29,\n  RD_KAFKA_RESP_ERR_GROUP_AUTHORIZATION_FAILED = 30,\n  RD_KAFKA_RESP_ERR_CLUSTER_AUTHORIZATION_FAILED = 31,\n  RD_KAFKA_RESP_ERR_INVALID_TIMESTAMP = 32,\n  RD_KAFKA_RESP_ERR_UNSUPPORTED_SASL_MECHANISM = 33,\n  RD_KAFKA_RESP_ERR_ILLEGAL_SASL_STATE = 34,\n  RD_KAFKA_RESP_ERR_UNSUPPORTED_VERSION = 35,\n  RD_KAFKA_RESP_ERR_TOPIC_ALREADY_EXISTS = 36,\n  RD_KAFKA_RESP_ERR_INVALID_PARTITIONS = 37,\n  RD_KAFKA_RESP_ERR_INVALID_REPLICATION_FACTOR = 38,\n  RD_KAFKA_RESP_ERR_INVALID_REPLICA_ASSIGNMENT = 39,\n  RD_KAFKA_RESP_ERR_INVALID_CONFIG = 40,\n  RD_KAFKA_RESP_ERR_NOT_CONTROLLER = 41,\n  RD_KAFKA_RESP_ERR_INVALID_REQUEST = 42,\n  RD_KAFKA_RESP_ERR_UNSUPPORTED_FOR_MESSAGE_FORMAT = 43,\n  RD_KAFKA_RESP_ERR_POLICY_VIOLATION = 44,\n  RD_KAFKA_RESP_ERR_OUT_OF_ORDER_SEQUENCE_NUMBER = 45,\n  RD_KAFKA_RESP_ERR_DUPLICATE_SEQUENCE_NUMBER = 46,\n  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_EPOCH = 47,\n  RD_KAFKA_RESP_ERR_INVALID_TXN_STATE = 48,\n  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_ID_MAPPING = 49,\n  RD_KAFKA_RESP_ERR_INVALID_TRANSACTION_TIMEOUT = 50,\n  RD_KAFKA_RESP_ERR_CONCURRENT_TRANSACTIONS = 51,\n  RD_KAFKA_RESP_ERR_TRANSACTION_COORDINATOR_FENCED = 52,\n  RD_KAFKA_RESP_ERR_TRANSACTIONAL_ID_AUTHORIZATION_FAILED = 53,\n  RD_KAFKA_RESP_ERR_SECURITY_DISABLED = 54,\n  RD_KAFKA_RESP_ERR_OPERATION_NOT_ATTEMPTED = 55,\n  RD_KAFKA_RESP_ERR_KAFKA_STORAGE_ERROR = 56,\n  RD_KAFKA_RESP_ERR_LOG_DIR_NOT_FOUND = 57,\n  RD_KAFKA_RESP_ERR_SASL_AUTHENTICATION_FAILED = 58,\n  RD_KAFKA_RESP_ERR_UNKNOWN_PRODUCER_ID = 59,\n  RD_KAFKA_RESP_ERR_REASSIGNMENT_IN_PROGRESS = 60,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTH_DISABLED = 61,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_NOT_FOUND = 62,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_OWNER_MISMATCH = 63,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_REQUEST_NOT_ALLOWED = 64,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTHORIZATION_FAILED = 65,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_EXPIRED = 66,\n  RD_KAFKA_RESP_ERR_INVALID_PRINCIPAL_TYPE = 67,\n  RD_KAFKA_RESP_ERR_NON_EMPTY_GROUP = 68,\n  RD_KAFKA_RESP_ERR_GROUP_ID_NOT_FOUND = 69,\n  RD_KAFKA_RESP_ERR_FETCH_SESSION_ID_NOT_FOUND = 70,\n  RD_KAFKA_RESP_ERR_INVALID_FETCH_SESSION_EPOCH = 71,\n  RD_KAFKA_RESP_ERR_LISTENER_NOT_FOUND = 72,\n  RD_KAFKA_RESP_ERR_TOPIC_DELETION_DISABLED = 73,\n  RD_KAFKA_RESP_ERR_FENCED_LEADER_EPOCH = 74,\n  RD_KAFKA_RESP_ERR_UNKNOWN_LEADER_EPOCH = 75,\n  RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76,\n  RD_KAFKA_RESP_ERR_STALE_BROKER_EPOCH = 77,\n  RD_KAFKA_RESP_ERR_OFFSET_NOT_AVAILABLE = 78,\n  RD_KAFKA_RESP_ERR_MEMBER_ID_REQUIRED = 79,\n  RD_KAFKA_RESP_ERR_PREFERRED_LEADER_NOT_AVAILABLE = 80,\n  RD_KAFKA_RESP_ERR_GROUP_MAX_SIZE_REACHED = 81,\n  RD_KAFKA_RESP_ERR_FENCED_INSTANCE_ID = 82,\n  RD_KAFKA_RESP_ERR_ELIGIBLE_LEADERS_NOT_AVAILABLE = 83,\n  RD_KAFKA_RESP_ERR_ELECTION_NOT_NEEDED = 84,\n  RD_KAFKA_RESP_ERR_NO_REASSIGNMENT_IN_PROGRESS = 85,\n  RD_KAFKA_RESP_ERR_GROUP_SUBSCRIBED_TO_TOPIC = 86,\n  RD_KAFKA_RESP_ERR_INVALID_RECORD = 87,\n  RD_KAFKA_RESP_ERR_UNSTABLE_OFFSET_COMMIT = 88,\n  RD_KAFKA_RESP_ERR_THROTTLING_QUOTA_EXCEEDED = 89,\n  RD_KAFKA_RESP_ERR_PRODUCER_FENCED = 90,\n  RD_KAFKA_RESP_ERR_RESOURCE_NOT_FOUND = 91,\n  RD_KAFKA_RESP_ERR_DUPLICATE_RESOURCE = 92,\n  RD_KAFKA_RESP_ERR_UNACCEPTABLE_CREDENTIAL = 93,\n  RD_KAFKA_RESP_ERR_INCONSISTENT_VOTER_SET = 94,\n  RD_KAFKA_RESP_ERR_INVALID_UPDATE_VERSION = 95,\n  RD_KAFKA_RESP_ERR_FEATURE_UPDATE_FAILED = 96,\n  RD_KAFKA_RESP_ERR_PRINCIPAL_DESERIALIZATION_FAILURE = 97,\n  RD_KAFKA_RESP_ERR_END_ALL,\n} rd_kafka_resp_err_t;\nstruct rd_kafka_err_desc {\n  rd_kafka_resp_err_t code;\n  char *name;\n  char *desc;\n};\nvoid rd_kafka_get_err_descs(const struct rd_kafka_err_desc **errdescs, size_t *cntp);\nconst char *rd_kafka_err2str(rd_kafka_resp_err_t err);\nconst char *rd_kafka_err2name(rd_kafka_resp_err_t err);\nrd_kafka_resp_err_t rd_kafka_last_error(void);\nrd_kafka_resp_err_t rd_kafka_errno2err(int errnox);\nint rd_kafka_errno(void);\nrd_kafka_resp_err_t rd_kafka_fatal_error(rd_kafka_t *rk, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_test_fatal_error(rd_kafka_t *rk, rd_kafka_resp_err_t err, const char *reason);\nrd_kafka_resp_err_t rd_kafka_error_code(const rd_kafka_error_t *error);\nconst char *rd_kafka_error_name(const rd_kafka_error_t *error);\nconst char *rd_kafka_error_string(const rd_kafka_error_t *error);\nint rd_kafka_error_is_fatal(const rd_kafka_error_t *error);\nint rd_kafka_error_is_retriable(const rd_kafka_error_t *error);\nint rd_kafka_error_txn_requires_abort(const rd_kafka_error_t *error);\nvoid rd_kafka_error_destroy(rd_kafka_error_t *error);\nrd_kafka_error_t *rd_kafka_error_new(rd_kafka_resp_err_t code, const char *fmt, ...);\ntypedef struct rd_kafka_topic_partition_s {\n  char *topic;\n  int32_t partition;\n  int64_t offset;\n  void *metadata;\n  size_t metadata_size;\n  void *opaque;\n  rd_kafka_resp_err_t err;\n  void *_private;\n} rd_kafka_topic_partition_t;\nvoid rd_kafka_topic_partition_destroy(rd_kafka_topic_partition_t *rktpar);\ntypedef struct rd_kafka_topic_partition_list_s {\n  int cnt;\n  int size;\n  rd_kafka_topic_partition_t *elems;\n} rd_kafka_topic_partition_list_t;\nrd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_new(int size);\nvoid rd_kafka_topic_partition_list_destroy(rd_kafka_topic_partition_list_t *rkparlist);\nrd_kafka_topic_partition_t *rd_kafka_topic_partition_list_add(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);\nvoid rd_kafka_topic_partition_list_add_range(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t start, int32_t stop);\nint rd_kafka_topic_partition_list_del(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);\nint rd_kafka_topic_partition_list_del_by_idx(rd_kafka_topic_partition_list_t *rktparlist, int idx);\nrd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_copy(const rd_kafka_topic_partition_list_t *src);\nrd_kafka_resp_err_t rd_kafka_topic_partition_list_set_offset(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition, int64_t offset);\nrd_kafka_topic_partition_t *rd_kafka_topic_partition_list_find(const rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);\nvoid rd_kafka_topic_partition_list_sort(rd_kafka_topic_partition_list_t *rktparlist, int (*cmp)(const void *a, const void *b, void *cmp_opaque), void *cmp_opaque);\ntypedef enum rd_kafka_vtype_t {\n  RD_KAFKA_VTYPE_END,\n  RD_KAFKA_VTYPE_TOPIC,\n  RD_KAFKA_VTYPE_RKT,\n  RD_KAFKA_VTYPE_PARTITION,\n  RD_KAFKA_VTYPE_VALUE,\n  RD_KAFKA_VTYPE_KEY,\n  RD_KAFKA_VTYPE_OPAQUE,\n  RD_KAFKA_VTYPE_MSGFLAGS,\n  RD_KAFKA_VTYPE_TIMESTAMP,\n  RD_KAFKA_VTYPE_HEADER,\n  RD_KAFKA_VTYPE_HEADERS,\n} rd_kafka_vtype_t;\ntypedef struct rd_kafka_vu_s {\n  rd_kafka_vtype_t vtype;\n  union {\n    char *cstr;\n    rd_kafka_topic_t *rkt;\n    int i;\n    int32_t i32;\n    int64_t i64;\n    struct {\n      void *ptr;\n      size_t size;\n    } mem;\n    struct {\n      char *name;\n      void *val;\n      ssize_t size;\n    } header;\n    rd_kafka_headers_t *headers;\n    void *ptr;\n    char _pad[64];\n  } u;\n} rd_kafka_vu_t;\nrd_kafka_headers_t *rd_kafka_headers_new(size_t initial_count);\nvoid rd_kafka_headers_destroy(rd_kafka_headers_t *hdrs);\nrd_kafka_headers_t *rd_kafka_headers_copy(const rd_kafka_headers_t *src);\nrd_kafka_resp_err_t rd_kafka_header_add(rd_kafka_headers_t *hdrs, const char *name, ssize_t name_size, const void *value, ssize_t value_size);\nrd_kafka_resp_err_t rd_kafka_header_remove(rd_kafka_headers_t *hdrs, const char *name);\nrd_kafka_resp_err_t rd_kafka_header_get_last(const rd_kafka_headers_t *hdrs, const char *name, const void **valuep, size_t *sizep);\nrd_kafka_resp_err_t rd_kafka_header_get(const rd_kafka_headers_t *hdrs, size_t idx, const char *name, const void **valuep, size_t *sizep);\nrd_kafka_resp_err_t rd_kafka_header_get_all(const rd_kafka_headers_t *hdrs, size_t idx, const char **namep, const void **valuep, size_t *sizep);\ntypedef struct rd_kafka_message_s {\n  rd_kafka_resp_err_t err;\n  rd_kafka_topic_t *rkt;\n  int32_t partition;\n  void *payload;\n  size_t len;\n  void *key;\n  size_t key_len;\n  int64_t offset;\n  void *_private;\n} rd_kafka_message_t;\nvoid rd_kafka_message_destroy(rd_kafka_message_t *rkmessage);\nconst char *rd_kafka_message_errstr(const rd_kafka_message_t *rkmessage);\nint64_t rd_kafka_message_timestamp(const rd_kafka_message_t *rkmessage, rd_kafka_timestamp_type_t *tstype);\nint64_t rd_kafka_message_latency(const rd_kafka_message_t *rkmessage);\nint32_t rd_kafka_message_broker_id(const rd_kafka_message_t *rkmessage);\nrd_kafka_resp_err_t rd_kafka_message_headers(const rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);\nrd_kafka_resp_err_t rd_kafka_message_detach_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);\nvoid rd_kafka_message_set_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t *hdrs);\nsize_t rd_kafka_header_cnt(const rd_kafka_headers_t *hdrs);\ntypedef enum {\n  RD_KAFKA_MSG_STATUS_NOT_PERSISTED = 0,\n  RD_KAFKA_MSG_STATUS_POSSIBLY_PERSISTED = 1,\n  RD_KAFKA_MSG_STATUS_PERSISTED = 2,\n} rd_kafka_msg_status_t;\nrd_kafka_msg_status_t rd_kafka_message_status(const rd_kafka_message_t *rkmessage);\ntypedef enum {\n  RD_KAFKA_CONF_UNKNOWN = (- 2),\n  RD_KAFKA_CONF_INVALID = (- 1),\n  RD_KAFKA_CONF_OK = 0,\n} rd_kafka_conf_res_t;\nrd_kafka_conf_t *rd_kafka_conf_new(void);\nvoid rd_kafka_conf_destroy(rd_kafka_conf_t *conf);\nrd_kafka_conf_t *rd_kafka_conf_dup(const rd_kafka_conf_t *conf);\nrd_kafka_conf_t *rd_kafka_conf_dup_filter(const rd_kafka_conf_t *conf, size_t filter_cnt, const char **filter);\nconst rd_kafka_conf_t *rd_kafka_conf(rd_kafka_t *rk);\nrd_kafka_conf_res_t rd_kafka_conf_set(rd_kafka_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);\nvoid rd_kafka_conf_set_events(rd_kafka_conf_t *conf, int events);\nvoid rd_kafka_conf_set_background_event_cb(rd_kafka_conf_t *conf, void (*event_cb)(rd_kafka_t *rk, rd_kafka_event_t *rkev, void *opaque));\nvoid rd_kafka_conf_set_dr_cb(rd_kafka_conf_t *conf, void (*dr_cb)(rd_kafka_t *rk, void *payload, size_t len, rd_kafka_resp_err_t err, void *opaque, void *msg_opaque));\nvoid rd_kafka_conf_set_dr_msg_cb(rd_kafka_conf_t *conf, void (*dr_msg_cb)(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, void *opaque));\nvoid rd_kafka_conf_set_consume_cb(rd_kafka_conf_t *conf, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *opaque));\nvoid rd_kafka_conf_set_rebalance_cb(rd_kafka_conf_t *conf, void (*rebalance_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *partitions, void *opaque));\nvoid rd_kafka_conf_set_offset_commit_cb(rd_kafka_conf_t *conf, void (*offset_commit_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *opaque));\nvoid rd_kafka_conf_set_error_cb(rd_kafka_conf_t *conf, void (*error_cb)(rd_kafka_t *rk, int err, const char *reason, void *opaque));\nvoid rd_kafka_conf_set_throttle_cb(rd_kafka_conf_t *conf, void (*throttle_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int throttle_time_ms, void *opaque));\nvoid rd_kafka_conf_set_log_cb(rd_kafka_conf_t *conf, void (*log_cb)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));\nvoid rd_kafka_conf_set_stats_cb(rd_kafka_conf_t *conf, int (*stats_cb)(rd_kafka_t *rk, char *json, size_t json_len, void *opaque));\nvoid rd_kafka_conf_set_oauthbearer_token_refresh_cb(rd_kafka_conf_t *conf, void (*oauthbearer_token_refresh_cb)(rd_kafka_t *rk, const char *oauthbearer_config, void *opaque));\nvoid rd_kafka_conf_enable_sasl_queue(rd_kafka_conf_t *conf, int enable);\nvoid rd_kafka_conf_set_socket_cb(rd_kafka_conf_t *conf, int (*socket_cb)(int domain, int type, int protocol, void *opaque));\nvoid rd_kafka_conf_set_connect_cb(rd_kafka_conf_t *conf, int (*connect_cb)(int sockfd, const struct sockaddr *addr, int addrlen, const char *id, void *opaque));\nvoid rd_kafka_conf_set_closesocket_cb(rd_kafka_conf_t *conf, int (*closesocket_cb)(int sockfd, void *opaque));\nrd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert_verify_cb(rd_kafka_conf_t *conf, int (*ssl_cert_verify_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int *x509_error, int depth, const char *buf, size_t size, char *errstr, size_t errstr_size, void *opaque));\ntypedef enum rd_kafka_cert_type_t {\n  RD_KAFKA_CERT_PUBLIC_KEY,\n  RD_KAFKA_CERT_PRIVATE_KEY,\n  RD_KAFKA_CERT_CA,\n  RD_KAFKA_CERT__CNT,\n} rd_kafka_cert_type_t;\ntypedef enum rd_kafka_cert_enc_t {\n  RD_KAFKA_CERT_ENC_PKCS12,\n  RD_KAFKA_CERT_ENC_DER,\n  RD_KAFKA_CERT_ENC_PEM,\n  RD_KAFKA_CERT_ENC__CNT,\n} rd_kafka_cert_enc_t;\nrd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert(rd_kafka_conf_t *conf, rd_kafka_cert_type_t cert_type, rd_kafka_cert_enc_t cert_enc, const void *buffer, size_t size, char *errstr, size_t errstr_size);\nvoid rd_kafka_conf_set_engine_callback_data(rd_kafka_conf_t *conf, void *callback_data);\nvoid rd_kafka_conf_set_opaque(rd_kafka_conf_t *conf, void *opaque);\nvoid *rd_kafka_opaque(const rd_kafka_t *rk);\nvoid rd_kafka_conf_set_default_topic_conf(rd_kafka_conf_t *conf, rd_kafka_topic_conf_t *tconf);\nrd_kafka_topic_conf_t *rd_kafka_conf_get_default_topic_conf(rd_kafka_conf_t *conf);\nrd_kafka_conf_res_t rd_kafka_conf_get(const rd_kafka_conf_t *conf, const char *name, char *dest, size_t *dest_size);\nrd_kafka_conf_res_t rd_kafka_topic_conf_get(const rd_kafka_topic_conf_t *conf, const char *name, char *dest, size_t *dest_size);\nconst char **rd_kafka_conf_dump(rd_kafka_conf_t *conf, size_t *cntp);\nconst char **rd_kafka_topic_conf_dump(rd_kafka_topic_conf_t *conf, size_t *cntp);\nvoid rd_kafka_conf_dump_free(const char **arr, size_t cnt);\nvoid rd_kafka_conf_properties_show(FILE *fp);\nrd_kafka_topic_conf_t *rd_kafka_topic_conf_new(void);\nrd_kafka_topic_conf_t *rd_kafka_topic_conf_dup(const rd_kafka_topic_conf_t *conf);\nrd_kafka_topic_conf_t *rd_kafka_default_topic_conf_dup(rd_kafka_t *rk);\nvoid rd_kafka_topic_conf_destroy(rd_kafka_topic_conf_t *topic_conf);\nrd_kafka_conf_res_t rd_kafka_topic_conf_set(rd_kafka_topic_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);\nvoid rd_kafka_topic_conf_set_opaque(rd_kafka_topic_conf_t *conf, void *rkt_opaque);\nvoid rd_kafka_topic_conf_set_partitioner_cb(rd_kafka_topic_conf_t *topic_conf, int32_t (*partitioner)(const rd_kafka_topic_t *rkt, const void *keydata, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque));\nvoid rd_kafka_topic_conf_set_msg_order_cmp(rd_kafka_topic_conf_t *topic_conf, int (*msg_order_cmp)(const rd_kafka_message_t *a, const rd_kafka_message_t *b));\nint rd_kafka_topic_partition_available(const rd_kafka_topic_t *rkt, int32_t partition);\nint32_t rd_kafka_msg_partitioner_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_consistent(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_consistent_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_murmur2(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_murmur2_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_fnv1a(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_fnv1a_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nrd_kafka_t *rd_kafka_new(rd_kafka_type_t type, rd_kafka_conf_t *conf, char *errstr, size_t errstr_size);\nvoid rd_kafka_destroy(rd_kafka_t *rk);\nvoid rd_kafka_destroy_flags(rd_kafka_t *rk, int flags);\nconst char *rd_kafka_name(const rd_kafka_t *rk);\nrd_kafka_type_t rd_kafka_type(const rd_kafka_t *rk);\nchar *rd_kafka_memberid(const rd_kafka_t *rk);\nchar *rd_kafka_clusterid(rd_kafka_t *rk, int timeout_ms);\nint32_t rd_kafka_controllerid(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_topic_t *rd_kafka_topic_new(rd_kafka_t *rk, const char *topic, rd_kafka_topic_conf_t *conf);\nvoid rd_kafka_topic_destroy(rd_kafka_topic_t *rkt);\nconst char *rd_kafka_topic_name(const rd_kafka_topic_t *rkt);\nvoid *rd_kafka_topic_opaque(const rd_kafka_topic_t *rkt);\nint rd_kafka_poll(rd_kafka_t *rk, int timeout_ms);\nvoid rd_kafka_yield(rd_kafka_t *rk);\nrd_kafka_resp_err_t rd_kafka_pause_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_resp_err_t rd_kafka_resume_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_resp_err_t rd_kafka_query_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high, int timeout_ms);\nrd_kafka_resp_err_t rd_kafka_get_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high);\nrd_kafka_resp_err_t rd_kafka_offsets_for_times(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets, int timeout_ms);\nvoid *rd_kafka_mem_calloc(rd_kafka_t *rk, size_t num, size_t size);\nvoid *rd_kafka_mem_malloc(rd_kafka_t *rk, size_t size);\nvoid rd_kafka_mem_free(rd_kafka_t *rk, void *ptr);\nrd_kafka_queue_t *rd_kafka_queue_new(rd_kafka_t *rk);\nvoid rd_kafka_queue_destroy(rd_kafka_queue_t *rkqu);\nrd_kafka_queue_t *rd_kafka_queue_get_main(rd_kafka_t *rk);\nrd_kafka_queue_t *rd_kafka_queue_get_sasl(rd_kafka_t *rk);\nrd_kafka_error_t *rd_kafka_sasl_background_callbacks_enable(rd_kafka_t *rk);\nrd_kafka_queue_t *rd_kafka_queue_get_consumer(rd_kafka_t *rk);\nrd_kafka_queue_t *rd_kafka_queue_get_partition(rd_kafka_t *rk, const char *topic, int32_t partition);\nrd_kafka_queue_t *rd_kafka_queue_get_background(rd_kafka_t *rk);\nvoid rd_kafka_queue_forward(rd_kafka_queue_t *src, rd_kafka_queue_t *dst);\nrd_kafka_resp_err_t rd_kafka_set_log_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu);\nsize_t rd_kafka_queue_length(rd_kafka_queue_t *rkqu);\nvoid rd_kafka_queue_io_event_enable(rd_kafka_queue_t *rkqu, int fd, const void *payload, size_t size);\nvoid rd_kafka_queue_cb_event_enable(rd_kafka_queue_t *rkqu, void (*event_cb)(rd_kafka_t *rk, void *qev_opaque), void *qev_opaque);\nvoid rd_kafka_queue_yield(rd_kafka_queue_t *rkqu);\nint rd_kafka_consume_start(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);\nint rd_kafka_consume_start_queue(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, rd_kafka_queue_t *rkqu);\nint rd_kafka_consume_stop(rd_kafka_topic_t *rkt, int32_t partition);\nrd_kafka_resp_err_t rd_kafka_seek(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, int timeout_ms);\nrd_kafka_error_t *rd_kafka_seek_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms);\nrd_kafka_message_t *rd_kafka_consume(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms);\nssize_t rd_kafka_consume_batch(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);\nint rd_kafka_consume_callback(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);\nrd_kafka_message_t *rd_kafka_consume_queue(rd_kafka_queue_t *rkqu, int timeout_ms);\nssize_t rd_kafka_consume_batch_queue(rd_kafka_queue_t *rkqu, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);\nint rd_kafka_consume_callback_queue(rd_kafka_queue_t *rkqu, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);\nrd_kafka_resp_err_t rd_kafka_offset_store(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);\nrd_kafka_resp_err_t rd_kafka_offsets_store(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets);\nrd_kafka_resp_err_t rd_kafka_subscribe(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *topics);\nrd_kafka_resp_err_t rd_kafka_unsubscribe(rd_kafka_t *rk);\nrd_kafka_resp_err_t rd_kafka_subscription(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **topics);\nrd_kafka_message_t *rd_kafka_consumer_poll(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_resp_err_t rd_kafka_consumer_close(rd_kafka_t *rk);\nrd_kafka_error_t *rd_kafka_consumer_close_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu);\nint rd_kafka_consumer_closed(rd_kafka_t *rk);\nrd_kafka_error_t *rd_kafka_incremental_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_error_t *rd_kafka_incremental_unassign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);\nconst char *rd_kafka_rebalance_protocol(rd_kafka_t *rk);\nrd_kafka_resp_err_t rd_kafka_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_resp_err_t rd_kafka_assignment(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **partitions);\nint rd_kafka_assignment_lost(rd_kafka_t *rk);\nrd_kafka_resp_err_t rd_kafka_commit(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, int async);\nrd_kafka_resp_err_t rd_kafka_commit_message(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, int async);\nrd_kafka_resp_err_t rd_kafka_commit_queue(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_queue_t *rkqu, void (*cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *commit_opaque), void *commit_opaque);\nrd_kafka_resp_err_t rd_kafka_committed(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms);\nrd_kafka_resp_err_t rd_kafka_position(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata(rd_kafka_t *rk);\nrd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata_new(const char *group_id);\nrd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata_new_with_genid(const char *group_id, int32_t generation_id, const char *member_id, const char *group_instance_id);\nvoid rd_kafka_consumer_group_metadata_destroy(rd_kafka_consumer_group_metadata_t *);\nrd_kafka_error_t *rd_kafka_consumer_group_metadata_write(const rd_kafka_consumer_group_metadata_t *cgmd, void **bufferp, size_t *sizep);\nrd_kafka_error_t *rd_kafka_consumer_group_metadata_read(rd_kafka_consumer_group_metadata_t **cgmdp, const void *buffer, size_t size);\nint rd_kafka_produce(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, void *payload, size_t len, const void *key, size_t keylen, void *msg_opaque);\nrd_kafka_resp_err_t rd_kafka_producev(rd_kafka_t *rk, ...);\nrd_kafka_error_t *rd_kafka_produceva(rd_kafka_t *rk, const rd_kafka_vu_t *vus, size_t cnt);\nint rd_kafka_produce_batch(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, rd_kafka_message_t *rkmessages, int message_cnt);\nrd_kafka_resp_err_t rd_kafka_flush(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_resp_err_t rd_kafka_purge(rd_kafka_t *rk, int purge_flags);\ntypedef struct rd_kafka_metadata_broker {\n  int32_t id;\n  char *host;\n  int port;\n} rd_kafka_metadata_broker_t;\ntypedef struct rd_kafka_metadata_partition {\n  int32_t id;\n  rd_kafka_resp_err_t err;\n  int32_t leader;\n  int replica_cnt;\n  int32_t *replicas;\n  int isr_cnt;\n  int32_t *isrs;\n} rd_kafka_metadata_partition_t;\ntypedef struct rd_kafka_metadata_topic {\n  char *topic;\n  int partition_cnt;\n  struct rd_kafka_metadata_partition *partitions;\n  rd_kafka_resp_err_t err;\n} rd_kafka_metadata_topic_t;\ntypedef struct rd_kafka_metadata {\n  int broker_cnt;\n  struct rd_kafka_metadata_broker *brokers;\n  int topic_cnt;\n  struct rd_kafka_metadata_topic *topics;\n  int32_t orig_broker_id;\n  char *orig_broker_name;\n} rd_kafka_metadata_t;\nrd_kafka_resp_err_t rd_kafka_metadata(rd_kafka_t *rk, int all_topics, rd_kafka_topic_t *only_rkt, const struct rd_kafka_metadata **metadatap, int timeout_ms);\nvoid rd_kafka_metadata_destroy(const struct rd_kafka_metadata *metadata);\nstruct rd_kafka_group_member_info {\n  char *member_id;\n  char *client_id;\n  char *client_host;\n  void *member_metadata;\n  int member_metadata_size;\n  void *member_assignment;\n  int member_assignment_size;\n};\nstruct rd_kafka_group_info {\n  struct rd_kafka_metadata_broker broker;\n  char *group;\n  rd_kafka_resp_err_t err;\n  char *state;\n  char *protocol_type;\n  char *protocol;\n  struct rd_kafka_group_member_info *members;\n  int member_cnt;\n};\nstruct rd_kafka_group_list {\n  struct rd_kafka_group_info *groups;\n  int group_cnt;\n};\nrd_kafka_resp_err_t rd_kafka_list_groups(rd_kafka_t *rk, const char *group, const struct rd_kafka_group_list **grplistp, int timeout_ms);\nvoid rd_kafka_group_list_destroy(const struct rd_kafka_group_list *grplist);\nint rd_kafka_brokers_add(rd_kafka_t *rk, const char *brokerlist);\nvoid rd_kafka_set_logger(rd_kafka_t *rk, void (*func)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));\nvoid rd_kafka_set_log_level(rd_kafka_t *rk, int level);\nvoid rd_kafka_log_print(const rd_kafka_t *rk, int level, const char *fac, const char *buf);\nvoid rd_kafka_log_syslog(const rd_kafka_t *rk, int level, const char *fac, const char *buf);\nint rd_kafka_outq_len(rd_kafka_t *rk);\nvoid rd_kafka_dump(FILE *fp, rd_kafka_t *rk);\nint rd_kafka_thread_cnt(void);\ntypedef enum rd_kafka_thread_type_t {\n  RD_KAFKA_THREAD_MAIN,\n  RD_KAFKA_THREAD_BACKGROUND,\n  RD_KAFKA_THREAD_BROKER,\n} rd_kafka_thread_type_t;\nint rd_kafka_wait_destroyed(int timeout_ms);\nint rd_kafka_unittest(void);\nrd_kafka_resp_err_t rd_kafka_poll_set_consumer(rd_kafka_t *rk);\ntypedef int rd_kafka_event_type_t;\nrd_kafka_event_type_t rd_kafka_event_type(const rd_kafka_event_t *rkev);\nconst char *rd_kafka_event_name(const rd_kafka_event_t *rkev);\nvoid rd_kafka_event_destroy(rd_kafka_event_t *rkev);\nconst rd_kafka_message_t *rd_kafka_event_message_next(rd_kafka_event_t *rkev);\nsize_t rd_kafka_event_message_array(rd_kafka_event_t *rkev, const rd_kafka_message_t **rkmessages, size_t size);\nsize_t rd_kafka_event_message_count(rd_kafka_event_t *rkev);\nconst char *rd_kafka_event_config_string(rd_kafka_event_t *rkev);\nrd_kafka_resp_err_t rd_kafka_event_error(rd_kafka_event_t *rkev);\nconst char *rd_kafka_event_error_string(rd_kafka_event_t *rkev);\nint rd_kafka_event_error_is_fatal(rd_kafka_event_t *rkev);\nvoid *rd_kafka_event_opaque(rd_kafka_event_t *rkev);\nint rd_kafka_event_log(rd_kafka_event_t *rkev, const char **fac, const char **str, int *level);\nint rd_kafka_event_debug_contexts(rd_kafka_event_t *rkev, char *dst, size_t dstsize);\nconst char *rd_kafka_event_stats(rd_kafka_event_t *rkev);\nrd_kafka_topic_partition_list_t *rd_kafka_event_topic_partition_list(rd_kafka_event_t *rkev);\nrd_kafka_topic_partition_t *rd_kafka_event_topic_partition(rd_kafka_event_t *rkev);\ntypedef rd_kafka_event_t rd_kafka_CreateTopics_result_t;\ntypedef rd_kafka_event_t rd_kafka_DeleteTopics_result_t;\ntypedef rd_kafka_event_t rd_kafka_CreateAcls_result_t;\ntypedef rd_kafka_event_t rd_kafka_DescribeAcls_result_t;\ntypedef rd_kafka_event_t rd_kafka_DeleteAcls_result_t;\ntypedef rd_kafka_event_t rd_kafka_CreatePartitions_result_t;\ntypedef rd_kafka_event_t rd_kafka_AlterConfigs_result_t;\ntypedef rd_kafka_event_t rd_kafka_DescribeConfigs_result_t;\ntypedef rd_kafka_event_t rd_kafka_DeleteRecords_result_t;\ntypedef rd_kafka_event_t rd_kafka_DeleteGroups_result_t;\ntypedef rd_kafka_event_t rd_kafka_DeleteConsumerGroupOffsets_result_t;\nconst rd_kafka_CreateTopics_result_t *rd_kafka_event_CreateTopics_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DeleteTopics_result_t *rd_kafka_event_DeleteTopics_result(rd_kafka_event_t *rkev);\nconst rd_kafka_CreatePartitions_result_t *rd_kafka_event_CreatePartitions_result(rd_kafka_event_t *rkev);\nconst rd_kafka_AlterConfigs_result_t *rd_kafka_event_AlterConfigs_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DescribeConfigs_result_t *rd_kafka_event_DescribeConfigs_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DeleteRecords_result_t *rd_kafka_event_DeleteRecords_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DeleteGroups_result_t *rd_kafka_event_DeleteGroups_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DeleteConsumerGroupOffsets_result_t *rd_kafka_event_DeleteConsumerGroupOffsets_result(rd_kafka_event_t *rkev);\nconst rd_kafka_CreateAcls_result_t *rd_kafka_event_CreateAcls_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DescribeAcls_result_t *rd_kafka_event_DescribeAcls_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DeleteAcls_result_t *rd_kafka_event_DeleteAcls_result(rd_kafka_event_t *rkev);\nrd_kafka_event_t *rd_kafka_queue_poll(rd_kafka_queue_t *rkqu, int timeout_ms);\nint rd_kafka_queue_poll_callback(rd_kafka_queue_t *rkqu, int timeout_ms);\ntypedef rd_kafka_resp_err_t (rd_kafka_plugin_f_conf_init_t)(rd_kafka_conf_t *conf, void **plug_opaquep, char *errstr, size_t errstr_size);\ntypedef rd_kafka_conf_res_t (rd_kafka_interceptor_f_on_conf_set_t)(rd_kafka_conf_t *conf, const char *name, const char *val, char *errstr, size_t errstr_size, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_dup_t)(rd_kafka_conf_t *new_conf, const rd_kafka_conf_t *old_conf, size_t filter_cnt, const char **filter, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_destroy_t)(void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_new_t)(rd_kafka_t *rk, const rd_kafka_conf_t *conf, void *ic_opaque, char *errstr, size_t errstr_size);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_destroy_t)(rd_kafka_t *rk, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_send_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_acknowledgement_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_consume_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_commit_t)(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_resp_err_t err, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_request_sent_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_response_received_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, int64_t rtt, rd_kafka_resp_err_t err, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_start_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_exit_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_set(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_set_t *on_conf_set, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_dup(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_dup_t *on_conf_dup, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_destroy(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_destroy_t *on_conf_destroy, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_new(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_new_t *on_new, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_destroy(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_destroy_t *on_destroy, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_send(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_send_t *on_send, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_acknowledgement(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_acknowledgement_t *on_acknowledgement, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_consume(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_consume_t *on_consume, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_commit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_commit_t *on_commit, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_request_sent(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_request_sent_t *on_request_sent, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_response_received(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_response_received_t *on_response_received, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_start(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_start_t *on_thread_start, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_exit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_exit_t *on_thread_exit, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_topic_result_error(const rd_kafka_topic_result_t *topicres);\nconst char *rd_kafka_topic_result_error_string(const rd_kafka_topic_result_t *topicres);\nconst char *rd_kafka_topic_result_name(const rd_kafka_topic_result_t *topicres);\nconst rd_kafka_error_t *rd_kafka_group_result_error(const rd_kafka_group_result_t *groupres);\nconst char *rd_kafka_group_result_name(const rd_kafka_group_result_t *groupres);\nconst rd_kafka_topic_partition_list_t *rd_kafka_group_result_partitions(const rd_kafka_group_result_t *groupres);\ntypedef enum rd_kafka_admin_op_t {\n  RD_KAFKA_ADMIN_OP_ANY = 0,\n  RD_KAFKA_ADMIN_OP_CREATETOPICS,\n  RD_KAFKA_ADMIN_OP_DELETETOPICS,\n  RD_KAFKA_ADMIN_OP_CREATEPARTITIONS,\n  RD_KAFKA_ADMIN_OP_ALTERCONFIGS,\n  RD_KAFKA_ADMIN_OP_DESCRIBECONFIGS,\n  RD_KAFKA_ADMIN_OP_DELETERECORDS,\n  RD_KAFKA_ADMIN_OP_DELETEGROUPS,\n  RD_KAFKA_ADMIN_OP_DELETECONSUMERGROUPOFFSETS,\n  RD_KAFKA_ADMIN_OP_CREATEACLS,\n  RD_KAFKA_ADMIN_OP_DESCRIBEACLS,\n  RD_KAFKA_ADMIN_OP_DELETEACLS,\n  RD_KAFKA_ADMIN_OP__CNT,\n} rd_kafka_admin_op_t;\ntypedef struct rd_kafka_AdminOptions_s rd_kafka_AdminOptions_t;\nrd_kafka_AdminOptions_t *rd_kafka_AdminOptions_new(rd_kafka_t *rk, rd_kafka_admin_op_t for_api);\nvoid rd_kafka_AdminOptions_destroy(rd_kafka_AdminOptions_t *options);\nrd_kafka_resp_err_t rd_kafka_AdminOptions_set_request_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_AdminOptions_set_operation_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_AdminOptions_set_validate_only(rd_kafka_AdminOptions_t *options, int true_or_false, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_AdminOptions_set_broker(rd_kafka_AdminOptions_t *options, int32_t broker_id, char *errstr, size_t errstr_size);\nvoid rd_kafka_AdminOptions_set_opaque(rd_kafka_AdminOptions_t *options, void *ev_opaque);\ntypedef struct rd_kafka_NewTopic_s rd_kafka_NewTopic_t;\nrd_kafka_NewTopic_t *rd_kafka_NewTopic_new(const char *topic, int num_partitions, int replication_factor, char *errstr, size_t errstr_size);\nvoid rd_kafka_NewTopic_destroy(rd_kafka_NewTopic_t *new_topic);\nvoid rd_kafka_NewTopic_destroy_array(rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt);\nrd_kafka_resp_err_t rd_kafka_NewTopic_set_replica_assignment(rd_kafka_NewTopic_t *new_topic, int32_t partition, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_NewTopic_set_config(rd_kafka_NewTopic_t *new_topic, const char *name, const char *value);\nvoid rd_kafka_CreateTopics(rd_kafka_t *rk, rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_topic_result_t **rd_kafka_CreateTopics_result_topics(const rd_kafka_CreateTopics_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_DeleteTopic_s rd_kafka_DeleteTopic_t;\nrd_kafka_DeleteTopic_t *rd_kafka_DeleteTopic_new(const char *topic);\nvoid rd_kafka_DeleteTopic_destroy(rd_kafka_DeleteTopic_t *del_topic);\nvoid rd_kafka_DeleteTopic_destroy_array(rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt);\nvoid rd_kafka_DeleteTopics(rd_kafka_t *rk, rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_topic_result_t **rd_kafka_DeleteTopics_result_topics(const rd_kafka_DeleteTopics_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_NewPartitions_s rd_kafka_NewPartitions_t;\nrd_kafka_NewPartitions_t *rd_kafka_NewPartitions_new(const char *topic, size_t new_total_cnt, char *errstr, size_t errstr_size);\nvoid rd_kafka_NewPartitions_destroy(rd_kafka_NewPartitions_t *new_parts);\nvoid rd_kafka_NewPartitions_destroy_array(rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt);\nrd_kafka_resp_err_t rd_kafka_NewPartitions_set_replica_assignment(rd_kafka_NewPartitions_t *new_parts, int32_t new_partition_idx, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);\nvoid rd_kafka_CreatePartitions(rd_kafka_t *rk, rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_topic_result_t **rd_kafka_CreatePartitions_result_topics(const rd_kafka_CreatePartitions_result_t *result, size_t *cntp);\ntypedef enum rd_kafka_ConfigSource_t {\n  RD_KAFKA_CONFIG_SOURCE_UNKNOWN_CONFIG = 0,\n  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_TOPIC_CONFIG = 1,\n  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_BROKER_CONFIG = 2,\n  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_DEFAULT_BROKER_CONFIG = 3,\n  RD_KAFKA_CONFIG_SOURCE_STATIC_BROKER_CONFIG = 4,\n  RD_KAFKA_CONFIG_SOURCE_DEFAULT_CONFIG = 5,\n  RD_KAFKA_CONFIG_SOURCE__CNT,\n} rd_kafka_ConfigSource_t;\nconst char *rd_kafka_ConfigSource_name(rd_kafka_ConfigSource_t confsource);\ntypedef struct rd_kafka_ConfigEntry_s rd_kafka_ConfigEntry_t;\nconst char *rd_kafka_ConfigEntry_name(const rd_kafka_ConfigEntry_t *entry);\nconst char *rd_kafka_ConfigEntry_value(const rd_kafka_ConfigEntry_t *entry);\nrd_kafka_ConfigSource_t rd_kafka_ConfigEntry_source(const rd_kafka_ConfigEntry_t *entry);\nint rd_kafka_ConfigEntry_is_read_only(const rd_kafka_ConfigEntry_t *entry);\nint rd_kafka_ConfigEntry_is_default(const rd_kafka_ConfigEntry_t *entry);\nint rd_kafka_ConfigEntry_is_sensitive(const rd_kafka_ConfigEntry_t *entry);\nint rd_kafka_ConfigEntry_is_synonym(const rd_kafka_ConfigEntry_t *entry);\nconst rd_kafka_ConfigEntry_t **rd_kafka_ConfigEntry_synonyms(const rd_kafka_ConfigEntry_t *entry, size_t *cntp);\ntypedef enum rd_kafka_ResourceType_t {\n  RD_KAFKA_RESOURCE_UNKNOWN = 0,\n  RD_KAFKA_RESOURCE_ANY = 1,\n  RD_KAFKA_RESOURCE_TOPIC = 2,\n  RD_KAFKA_RESOURCE_GROUP = 3,\n  RD_KAFKA_RESOURCE_BROKER = 4,\n  RD_KAFKA_RESOURCE__CNT,\n} rd_kafka_ResourceType_t;\ntypedef enum rd_kafka_ResourcePatternType_t {\n  RD_KAFKA_RESOURCE_PATTERN_UNKNOWN = 0,\n  RD_KAFKA_RESOURCE_PATTERN_ANY = 1,\n  RD_KAFKA_RESOURCE_PATTERN_MATCH = 2,\n  RD_KAFKA_RESOURCE_PATTERN_LITERAL = 3,\n  RD_KAFKA_RESOURCE_PATTERN_PREFIXED = 4,\n  RD_KAFKA_RESOURCE_PATTERN_TYPE__CNT,\n} rd_kafka_ResourcePatternType_t;\nconst char *rd_kafka_ResourcePatternType_name(rd_kafka_ResourcePatternType_t resource_pattern_type);\nconst char *rd_kafka_ResourceType_name(rd_kafka_ResourceType_t restype);\ntypedef struct rd_kafka_ConfigResource_s rd_kafka_ConfigResource_t;\nrd_kafka_ConfigResource_t *rd_kafka_ConfigResource_new(rd_kafka_ResourceType_t restype, const char *resname);\nvoid rd_kafka_ConfigResource_destroy(rd_kafka_ConfigResource_t *config);\nvoid rd_kafka_ConfigResource_destroy_array(rd_kafka_ConfigResource_t **config, size_t config_cnt);\nrd_kafka_resp_err_t rd_kafka_ConfigResource_set_config(rd_kafka_ConfigResource_t *config, const char *name, const char *value);\nconst rd_kafka_ConfigEntry_t **rd_kafka_ConfigResource_configs(const rd_kafka_ConfigResource_t *config, size_t *cntp);\nrd_kafka_ResourceType_t rd_kafka_ConfigResource_type(const rd_kafka_ConfigResource_t *config);\nconst char *rd_kafka_ConfigResource_name(const rd_kafka_ConfigResource_t *config);\nrd_kafka_resp_err_t rd_kafka_ConfigResource_error(const rd_kafka_ConfigResource_t *config);\nconst char *rd_kafka_ConfigResource_error_string(const rd_kafka_ConfigResource_t *config);\nvoid rd_kafka_AlterConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_ConfigResource_t **rd_kafka_AlterConfigs_result_resources(const rd_kafka_AlterConfigs_result_t *result, size_t *cntp);\nvoid rd_kafka_DescribeConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_ConfigResource_t **rd_kafka_DescribeConfigs_result_resources(const rd_kafka_DescribeConfigs_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_DeleteRecords_s rd_kafka_DeleteRecords_t;\nrd_kafka_DeleteRecords_t *rd_kafka_DeleteRecords_new(const rd_kafka_topic_partition_list_t *before_offsets);\nvoid rd_kafka_DeleteRecords_destroy(rd_kafka_DeleteRecords_t *del_records);\nvoid rd_kafka_DeleteRecords_destroy_array(rd_kafka_DeleteRecords_t **del_records, size_t del_record_cnt);\nvoid rd_kafka_DeleteRecords(rd_kafka_t *rk, rd_kafka_DeleteRecords_t **del_records, size_t del_record_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_topic_partition_list_t *rd_kafka_DeleteRecords_result_offsets(const rd_kafka_DeleteRecords_result_t *result);\ntypedef struct rd_kafka_DeleteGroup_s rd_kafka_DeleteGroup_t;\nrd_kafka_DeleteGroup_t *rd_kafka_DeleteGroup_new(const char *group);\nvoid rd_kafka_DeleteGroup_destroy(rd_kafka_DeleteGroup_t *del_group);\nvoid rd_kafka_DeleteGroup_destroy_array(rd_kafka_DeleteGroup_t **del_groups, size_t del_group_cnt);\nvoid rd_kafka_DeleteGroups(rd_kafka_t *rk, rd_kafka_DeleteGroup_t **del_groups, size_t del_group_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_group_result_t **rd_kafka_DeleteGroups_result_groups(const rd_kafka_DeleteGroups_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_DeleteConsumerGroupOffsets_s rd_kafka_DeleteConsumerGroupOffsets_t;\nrd_kafka_DeleteConsumerGroupOffsets_t *rd_kafka_DeleteConsumerGroupOffsets_new(const char *group, const rd_kafka_topic_partition_list_t *partitions);\nvoid rd_kafka_DeleteConsumerGroupOffsets_destroy(rd_kafka_DeleteConsumerGroupOffsets_t *del_grpoffsets);\nvoid rd_kafka_DeleteConsumerGroupOffsets_destroy_array(rd_kafka_DeleteConsumerGroupOffsets_t **del_grpoffsets, size_t del_grpoffset_cnt);\nvoid rd_kafka_DeleteConsumerGroupOffsets(rd_kafka_t *rk, rd_kafka_DeleteConsumerGroupOffsets_t **del_grpoffsets, size_t del_grpoffsets_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_group_result_t **rd_kafka_DeleteConsumerGroupOffsets_result_groups(const rd_kafka_DeleteConsumerGroupOffsets_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_AclBinding_s rd_kafka_AclBinding_t;\ntypedef rd_kafka_AclBinding_t rd_kafka_AclBindingFilter_t;\nconst rd_kafka_error_t *rd_kafka_acl_result_error(const rd_kafka_acl_result_t *aclres);\ntypedef enum rd_kafka_AclOperation_t {\n  RD_KAFKA_ACL_OPERATION_UNKNOWN = 0,\n  RD_KAFKA_ACL_OPERATION_ANY = 1,\n  RD_KAFKA_ACL_OPERATION_ALL = 2,\n  RD_KAFKA_ACL_OPERATION_READ = 3,\n  RD_KAFKA_ACL_OPERATION_WRITE = 4,\n  RD_KAFKA_ACL_OPERATION_CREATE = 5,\n  RD_KAFKA_ACL_OPERATION_DELETE = 6,\n  RD_KAFKA_ACL_OPERATION_ALTER = 7,\n  RD_KAFKA_ACL_OPERATION_DESCRIBE = 8,\n  RD_KAFKA_ACL_OPERATION_CLUSTER_ACTION = 9,\n  RD_KAFKA_ACL_OPERATION_DESCRIBE_CONFIGS = 10,\n  RD_KAFKA_ACL_OPERATION_ALTER_CONFIGS = 11,\n  RD_KAFKA_ACL_OPERATION_IDEMPOTENT_WRITE = 12,\n  RD_KAFKA_ACL_OPERATION__CNT,\n} rd_kafka_AclOperation_t;\nconst char *rd_kafka_AclOperation_name(rd_kafka_AclOperation_t acl_operation);\ntypedef enum rd_kafka_AclPermissionType_t {\n  RD_KAFKA_ACL_PERMISSION_TYPE_UNKNOWN = 0,\n  RD_KAFKA_ACL_PERMISSION_TYPE_ANY = 1,\n  RD_KAFKA_ACL_PERMISSION_TYPE_DENY = 2,\n  RD_KAFKA_ACL_PERMISSION_TYPE_ALLOW = 3,\n  RD_KAFKA_ACL_PERMISSION_TYPE__CNT,\n} rd_kafka_AclPermissionType_t;\nconst char *rd_kafka_AclPermissionType_name(rd_kafka_AclPermissionType_t acl_permission_type);\nrd_kafka_AclBinding_t *rd_kafka_AclBinding_new(rd_kafka_ResourceType_t restype, const char *name, rd_kafka_ResourcePatternType_t resource_pattern_type, const char *principal, const char *host, rd_kafka_AclOperation_t operation, rd_kafka_AclPermissionType_t permission_type, char *errstr, size_t errstr_size);\nrd_kafka_AclBindingFilter_t *rd_kafka_AclBindingFilter_new(rd_kafka_ResourceType_t restype, const char *name, rd_kafka_ResourcePatternType_t resource_pattern_type, const char *principal, const char *host, rd_kafka_AclOperation_t operation, rd_kafka_AclPermissionType_t permission_type, char *errstr, size_t errstr_size);\nrd_kafka_ResourceType_t rd_kafka_AclBinding_restype(const rd_kafka_AclBinding_t *acl);\nconst char *rd_kafka_AclBinding_name(const rd_kafka_AclBinding_t *acl);\nconst char *rd_kafka_AclBinding_principal(const rd_kafka_AclBinding_t *acl);\nconst char *rd_kafka_AclBinding_host(const rd_kafka_AclBinding_t *acl);\nrd_kafka_AclOperation_t rd_kafka_AclBinding_operation(const rd_kafka_AclBinding_t *acl);\nrd_kafka_AclPermissionType_t rd_kafka_AclBinding_permission_type(const rd_kafka_AclBinding_t *acl);\nrd_kafka_ResourcePatternType_t rd_kafka_AclBinding_resource_pattern_type(const rd_kafka_AclBinding_t *acl);\nconst rd_kafka_error_t *rd_kafka_AclBinding_error(const rd_kafka_AclBinding_t *acl);\nvoid rd_kafka_AclBinding_destroy(rd_kafka_AclBinding_t *acl_binding);\nvoid rd_kafka_AclBinding_destroy_array(rd_kafka_AclBinding_t **acl_bindings, size_t acl_bindings_cnt);\nconst rd_kafka_acl_result_t **rd_kafka_CreateAcls_result_acls(const rd_kafka_CreateAcls_result_t *result, size_t *cntp);\nvoid rd_kafka_CreateAcls(rd_kafka_t *rk, rd_kafka_AclBinding_t **new_acls, size_t new_acls_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_AclBinding_t **rd_kafka_DescribeAcls_result_acls(const rd_kafka_DescribeAcls_result_t *result, size_t *cntp);\nvoid rd_kafka_DescribeAcls(rd_kafka_t *rk, rd_kafka_AclBindingFilter_t *acl_filter, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\ntypedef struct rd_kafka_DeleteAcls_result_response_s rd_kafka_DeleteAcls_result_response_t;\nconst rd_kafka_DeleteAcls_result_response_t **rd_kafka_DeleteAcls_result_responses(const rd_kafka_DeleteAcls_result_t *result, size_t *cntp);\nconst rd_kafka_error_t *rd_kafka_DeleteAcls_result_response_error(const rd_kafka_DeleteAcls_result_response_t *result_response);\nconst rd_kafka_AclBinding_t **rd_kafka_DeleteAcls_result_response_matching_acls(const rd_kafka_DeleteAcls_result_response_t *result_response, size_t *matching_acls_cntp);\nvoid rd_kafka_DeleteAcls(rd_kafka_t *rk, rd_kafka_AclBindingFilter_t **del_acls, size_t del_acls_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nrd_kafka_resp_err_t rd_kafka_oauthbearer_set_token(rd_kafka_t *rk, const char *token_value, int64_t md_lifetime_ms, const char *md_principal_name, const char **extensions, size_t extension_size, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_oauthbearer_set_token_failure(rd_kafka_t *rk, const char *errstr);\nrd_kafka_error_t *rd_kafka_init_transactions(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_error_t *rd_kafka_begin_transaction(rd_kafka_t *rk);\nrd_kafka_error_t *rd_kafka_send_offsets_to_transaction(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, const rd_kafka_consumer_group_metadata_t *cgmetadata, int timeout_ms);\nrd_kafka_error_t *rd_kafka_commit_transaction(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_error_t *rd_kafka_abort_transaction(rd_kafka_t *rk, int timeout_ms);\ntypedef struct rd_kafka_mock_cluster_s rd_kafka_mock_cluster_t;\nrd_kafka_mock_cluster_t *rd_kafka_mock_cluster_new(rd_kafka_t *rk, int broker_cnt);\nvoid rd_kafka_mock_cluster_destroy(rd_kafka_mock_cluster_t *mcluster);\nrd_kafka_t *rd_kafka_mock_cluster_handle(const rd_kafka_mock_cluster_t *mcluster);\nrd_kafka_mock_cluster_t *rd_kafka_handle_mock_cluster(const rd_kafka_t *rk);\nconst char *rd_kafka_mock_cluster_bootstraps(const rd_kafka_mock_cluster_t *mcluster);\nvoid rd_kafka_mock_clear_request_errors(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey);\nvoid rd_kafka_mock_push_request_errors(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, size_t cnt, ...);\nvoid rd_kafka_mock_push_request_errors_array(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, size_t cnt, const rd_kafka_resp_err_t *errors);\nrd_kafka_resp_err_t rd_kafka_mock_broker_push_request_error_rtts(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int16_t ApiKey, size_t cnt, ...);\nvoid rd_kafka_mock_topic_set_error(rd_kafka_mock_cluster_t *mcluster, const char *topic, rd_kafka_resp_err_t err);\nrd_kafka_resp_err_t rd_kafka_mock_topic_create(rd_kafka_mock_cluster_t *mcluster, const char *topic, int partition_cnt, int replication_factor);\nrd_kafka_resp_err_t rd_kafka_mock_partition_set_leader(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id);\nrd_kafka_resp_err_t rd_kafka_mock_partition_set_follower(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id);\nrd_kafka_resp_err_t rd_kafka_mock_partition_set_follower_wmarks(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int64_t lo, int64_t hi);\nrd_kafka_resp_err_t rd_kafka_mock_broker_set_down(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id);\nrd_kafka_resp_err_t rd_kafka_mock_broker_set_up(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id);\nrd_kafka_resp_err_t rd_kafka_mock_broker_set_rtt(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int rtt_ms);\nrd_kafka_resp_err_t rd_kafka_mock_broker_set_rack(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, const char *rack);\nrd_kafka_resp_err_t rd_kafka_mock_coordinator_set(rd_kafka_mock_cluster_t *mcluster, const char *key_type, const char *key, int32_t broker_id);\nrd_kafka_resp_err_t rd_kafka_mock_set_apiversion(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, int16_t MinVersion, int16_t MaxVersion);\n'\n</code></pre> rdkafka.h, rdkafka_mock.h</p>"},{"location":"api/constants/#rd_kafka_version_22","title":"RD_KAFKA_VERSION","text":"<pre><code>public RD_KAFKA_VERSION = 33554687\n</code></pre> <p>librdkafka version </p> <p>Interpreted as hex <code>MM.mm.rr.xx</code>:</p> <ul> <li>MM = Major</li> <li>mm = minor</li> <li>rr = revision</li> <li>xx = pre-release id (0xff is the final release)</li> </ul> <p>E.g.: <code>0x000801ff</code> = 0.8.1</p> RemarksThis value should only be used during compile time, for runtime checks of version use rd_kafka_version()  <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_unsupported_compression_type_22","title":"RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE","text":"<pre><code>public RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76\n</code></pre> <p>Unsupported compression type </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_end_all_22","title":"RD_KAFKA_RESP_ERR_END_ALL","text":"<p><pre><code>public RD_KAFKA_RESP_ERR_END_ALL = 98\n</code></pre> enum rd_kafka_resp_err_t</p>"},{"location":"api/constants/#rd_kafka_admin_op__cnt_22","title":"RD_KAFKA_ADMIN_OP__CNT","text":"<pre><code>public RD_KAFKA_ADMIN_OP__CNT = 16\n</code></pre> <p>Number of ops defined </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe </li> </ul>"},{"location":"api/constants/#rd_kafka_resource__cnt_22","title":"RD_KAFKA_RESOURCE__CNT","text":"<pre><code>public RD_KAFKA_RESOURCE__CNT = 5\n</code></pre> <p>Number of resource types defined </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#acca83a66d7783ff7683ed2691cc907c9 </li> </ul>"},{"location":"api/constants/#rd_kafka_cdef_22","title":"RD_KAFKA_CDEF","text":"<p><pre><code>public RD_KAFKA_CDEF = 'typedef long int ssize_t;\ntypedef struct _IO_FILE FILE;\ntypedef long int mode_t;\ntypedef signed int int16_t;\ntypedef unsigned int uint16_t;\ntypedef signed int int32_t;\ntypedef signed long int int64_t;\nint rd_kafka_version(void);\nconst char *rd_kafka_version_str(void);\ntypedef enum rd_kafka_type_t {\n  RD_KAFKA_PRODUCER,\n  RD_KAFKA_CONSUMER,\n} rd_kafka_type_t;\ntypedef enum rd_kafka_timestamp_type_t {\n  RD_KAFKA_TIMESTAMP_NOT_AVAILABLE,\n  RD_KAFKA_TIMESTAMP_CREATE_TIME,\n  RD_KAFKA_TIMESTAMP_LOG_APPEND_TIME,\n} rd_kafka_timestamp_type_t;\nconst char *rd_kafka_get_debug_contexts(void);\ntypedef struct rd_kafka_s rd_kafka_t;\ntypedef struct rd_kafka_topic_s rd_kafka_topic_t;\ntypedef struct rd_kafka_conf_s rd_kafka_conf_t;\ntypedef struct rd_kafka_topic_conf_s rd_kafka_topic_conf_t;\ntypedef struct rd_kafka_queue_s rd_kafka_queue_t;\ntypedef struct rd_kafka_op_s rd_kafka_event_t;\ntypedef struct rd_kafka_topic_result_s rd_kafka_topic_result_t;\ntypedef struct rd_kafka_consumer_group_metadata_s rd_kafka_consumer_group_metadata_t;\ntypedef struct rd_kafka_error_s {\n  unsigned int code;\n  char *errstr;\n  unsigned char fatal;\n  unsigned char retriable;\n  unsigned char txn_requires_abort;\n} rd_kafka_error_t;\ntypedef struct rd_kafka_headers_s rd_kafka_headers_t;\ntypedef struct rd_kafka_group_result_s rd_kafka_group_result_t;\ntypedef struct rd_kafka_acl_result_s rd_kafka_acl_result_t;\ntypedef enum {\n  RD_KAFKA_RESP_ERR__BEGIN = (- 200),\n  RD_KAFKA_RESP_ERR__BAD_MSG = (- 199),\n  RD_KAFKA_RESP_ERR__BAD_COMPRESSION = (- 198),\n  RD_KAFKA_RESP_ERR__DESTROY = (- 197),\n  RD_KAFKA_RESP_ERR__FAIL = (- 196),\n  RD_KAFKA_RESP_ERR__TRANSPORT = (- 195),\n  RD_KAFKA_RESP_ERR__CRIT_SYS_RESOURCE = (- 194),\n  RD_KAFKA_RESP_ERR__RESOLVE = (- 193),\n  RD_KAFKA_RESP_ERR__MSG_TIMED_OUT = (- 192),\n  RD_KAFKA_RESP_ERR__PARTITION_EOF = (- 191),\n  RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION = (- 190),\n  RD_KAFKA_RESP_ERR__FS = (- 189),\n  RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC = (- 188),\n  RD_KAFKA_RESP_ERR__ALL_BROKERS_DOWN = (- 187),\n  RD_KAFKA_RESP_ERR__INVALID_ARG = (- 186),\n  RD_KAFKA_RESP_ERR__TIMED_OUT = (- 185),\n  RD_KAFKA_RESP_ERR__QUEUE_FULL = (- 184),\n  RD_KAFKA_RESP_ERR__ISR_INSUFF = (- 183),\n  RD_KAFKA_RESP_ERR__NODE_UPDATE = (- 182),\n  RD_KAFKA_RESP_ERR__SSL = (- 181),\n  RD_KAFKA_RESP_ERR__WAIT_COORD = (- 180),\n  RD_KAFKA_RESP_ERR__UNKNOWN_GROUP = (- 179),\n  RD_KAFKA_RESP_ERR__IN_PROGRESS = (- 178),\n  RD_KAFKA_RESP_ERR__PREV_IN_PROGRESS = (- 177),\n  RD_KAFKA_RESP_ERR__EXISTING_SUBSCRIPTION = (- 176),\n  RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS = (- 175),\n  RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS = (- 174),\n  RD_KAFKA_RESP_ERR__CONFLICT = (- 173),\n  RD_KAFKA_RESP_ERR__STATE = (- 172),\n  RD_KAFKA_RESP_ERR__UNKNOWN_PROTOCOL = (- 171),\n  RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED = (- 170),\n  RD_KAFKA_RESP_ERR__AUTHENTICATION = (- 169),\n  RD_KAFKA_RESP_ERR__NO_OFFSET = (- 168),\n  RD_KAFKA_RESP_ERR__OUTDATED = (- 167),\n  RD_KAFKA_RESP_ERR__TIMED_OUT_QUEUE = (- 166),\n  RD_KAFKA_RESP_ERR__UNSUPPORTED_FEATURE = (- 165),\n  RD_KAFKA_RESP_ERR__WAIT_CACHE = (- 164),\n  RD_KAFKA_RESP_ERR__INTR = (- 163),\n  RD_KAFKA_RESP_ERR__KEY_SERIALIZATION = (- 162),\n  RD_KAFKA_RESP_ERR__VALUE_SERIALIZATION = (- 161),\n  RD_KAFKA_RESP_ERR__KEY_DESERIALIZATION = (- 160),\n  RD_KAFKA_RESP_ERR__VALUE_DESERIALIZATION = (- 159),\n  RD_KAFKA_RESP_ERR__PARTIAL = (- 158),\n  RD_KAFKA_RESP_ERR__READ_ONLY = (- 157),\n  RD_KAFKA_RESP_ERR__NOENT = (- 156),\n  RD_KAFKA_RESP_ERR__UNDERFLOW = (- 155),\n  RD_KAFKA_RESP_ERR__INVALID_TYPE = (- 154),\n  RD_KAFKA_RESP_ERR__RETRY = (- 153),\n  RD_KAFKA_RESP_ERR__PURGE_QUEUE = (- 152),\n  RD_KAFKA_RESP_ERR__PURGE_INFLIGHT = (- 151),\n  RD_KAFKA_RESP_ERR__FATAL = (- 150),\n  RD_KAFKA_RESP_ERR__INCONSISTENT = (- 149),\n  RD_KAFKA_RESP_ERR__GAPLESS_GUARANTEE = (- 148),\n  RD_KAFKA_RESP_ERR__MAX_POLL_EXCEEDED = (- 147),\n  RD_KAFKA_RESP_ERR__UNKNOWN_BROKER = (- 146),\n  RD_KAFKA_RESP_ERR__NOT_CONFIGURED = (- 145),\n  RD_KAFKA_RESP_ERR__FENCED = (- 144),\n  RD_KAFKA_RESP_ERR__APPLICATION = (- 143),\n  RD_KAFKA_RESP_ERR__ASSIGNMENT_LOST = (- 142),\n  RD_KAFKA_RESP_ERR__NOOP = (- 141),\n  RD_KAFKA_RESP_ERR__AUTO_OFFSET_RESET = (- 140),\n  RD_KAFKA_RESP_ERR__END = (- 100),\n  RD_KAFKA_RESP_ERR_UNKNOWN = (- 1),\n  RD_KAFKA_RESP_ERR_NO_ERROR = 0,\n  RD_KAFKA_RESP_ERR_OFFSET_OUT_OF_RANGE = 1,\n  RD_KAFKA_RESP_ERR_INVALID_MSG = 2,\n  RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART = 3,\n  RD_KAFKA_RESP_ERR_INVALID_MSG_SIZE = 4,\n  RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE = 5,\n  RD_KAFKA_RESP_ERR_NOT_LEADER_FOR_PARTITION = 6,\n  RD_KAFKA_RESP_ERR_REQUEST_TIMED_OUT = 7,\n  RD_KAFKA_RESP_ERR_BROKER_NOT_AVAILABLE = 8,\n  RD_KAFKA_RESP_ERR_REPLICA_NOT_AVAILABLE = 9,\n  RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE = 10,\n  RD_KAFKA_RESP_ERR_STALE_CTRL_EPOCH = 11,\n  RD_KAFKA_RESP_ERR_OFFSET_METADATA_TOO_LARGE = 12,\n  RD_KAFKA_RESP_ERR_NETWORK_EXCEPTION = 13,\n  RD_KAFKA_RESP_ERR_COORDINATOR_LOAD_IN_PROGRESS = 14,\n  RD_KAFKA_RESP_ERR_COORDINATOR_NOT_AVAILABLE = 15,\n  RD_KAFKA_RESP_ERR_NOT_COORDINATOR = 16,\n  RD_KAFKA_RESP_ERR_TOPIC_EXCEPTION = 17,\n  RD_KAFKA_RESP_ERR_RECORD_LIST_TOO_LARGE = 18,\n  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS = 19,\n  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS_AFTER_APPEND = 20,\n  RD_KAFKA_RESP_ERR_INVALID_REQUIRED_ACKS = 21,\n  RD_KAFKA_RESP_ERR_ILLEGAL_GENERATION = 22,\n  RD_KAFKA_RESP_ERR_INCONSISTENT_GROUP_PROTOCOL = 23,\n  RD_KAFKA_RESP_ERR_INVALID_GROUP_ID = 24,\n  RD_KAFKA_RESP_ERR_UNKNOWN_MEMBER_ID = 25,\n  RD_KAFKA_RESP_ERR_INVALID_SESSION_TIMEOUT = 26,\n  RD_KAFKA_RESP_ERR_REBALANCE_IN_PROGRESS = 27,\n  RD_KAFKA_RESP_ERR_INVALID_COMMIT_OFFSET_SIZE = 28,\n  RD_KAFKA_RESP_ERR_TOPIC_AUTHORIZATION_FAILED = 29,\n  RD_KAFKA_RESP_ERR_GROUP_AUTHORIZATION_FAILED = 30,\n  RD_KAFKA_RESP_ERR_CLUSTER_AUTHORIZATION_FAILED = 31,\n  RD_KAFKA_RESP_ERR_INVALID_TIMESTAMP = 32,\n  RD_KAFKA_RESP_ERR_UNSUPPORTED_SASL_MECHANISM = 33,\n  RD_KAFKA_RESP_ERR_ILLEGAL_SASL_STATE = 34,\n  RD_KAFKA_RESP_ERR_UNSUPPORTED_VERSION = 35,\n  RD_KAFKA_RESP_ERR_TOPIC_ALREADY_EXISTS = 36,\n  RD_KAFKA_RESP_ERR_INVALID_PARTITIONS = 37,\n  RD_KAFKA_RESP_ERR_INVALID_REPLICATION_FACTOR = 38,\n  RD_KAFKA_RESP_ERR_INVALID_REPLICA_ASSIGNMENT = 39,\n  RD_KAFKA_RESP_ERR_INVALID_CONFIG = 40,\n  RD_KAFKA_RESP_ERR_NOT_CONTROLLER = 41,\n  RD_KAFKA_RESP_ERR_INVALID_REQUEST = 42,\n  RD_KAFKA_RESP_ERR_UNSUPPORTED_FOR_MESSAGE_FORMAT = 43,\n  RD_KAFKA_RESP_ERR_POLICY_VIOLATION = 44,\n  RD_KAFKA_RESP_ERR_OUT_OF_ORDER_SEQUENCE_NUMBER = 45,\n  RD_KAFKA_RESP_ERR_DUPLICATE_SEQUENCE_NUMBER = 46,\n  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_EPOCH = 47,\n  RD_KAFKA_RESP_ERR_INVALID_TXN_STATE = 48,\n  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_ID_MAPPING = 49,\n  RD_KAFKA_RESP_ERR_INVALID_TRANSACTION_TIMEOUT = 50,\n  RD_KAFKA_RESP_ERR_CONCURRENT_TRANSACTIONS = 51,\n  RD_KAFKA_RESP_ERR_TRANSACTION_COORDINATOR_FENCED = 52,\n  RD_KAFKA_RESP_ERR_TRANSACTIONAL_ID_AUTHORIZATION_FAILED = 53,\n  RD_KAFKA_RESP_ERR_SECURITY_DISABLED = 54,\n  RD_KAFKA_RESP_ERR_OPERATION_NOT_ATTEMPTED = 55,\n  RD_KAFKA_RESP_ERR_KAFKA_STORAGE_ERROR = 56,\n  RD_KAFKA_RESP_ERR_LOG_DIR_NOT_FOUND = 57,\n  RD_KAFKA_RESP_ERR_SASL_AUTHENTICATION_FAILED = 58,\n  RD_KAFKA_RESP_ERR_UNKNOWN_PRODUCER_ID = 59,\n  RD_KAFKA_RESP_ERR_REASSIGNMENT_IN_PROGRESS = 60,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTH_DISABLED = 61,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_NOT_FOUND = 62,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_OWNER_MISMATCH = 63,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_REQUEST_NOT_ALLOWED = 64,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTHORIZATION_FAILED = 65,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_EXPIRED = 66,\n  RD_KAFKA_RESP_ERR_INVALID_PRINCIPAL_TYPE = 67,\n  RD_KAFKA_RESP_ERR_NON_EMPTY_GROUP = 68,\n  RD_KAFKA_RESP_ERR_GROUP_ID_NOT_FOUND = 69,\n  RD_KAFKA_RESP_ERR_FETCH_SESSION_ID_NOT_FOUND = 70,\n  RD_KAFKA_RESP_ERR_INVALID_FETCH_SESSION_EPOCH = 71,\n  RD_KAFKA_RESP_ERR_LISTENER_NOT_FOUND = 72,\n  RD_KAFKA_RESP_ERR_TOPIC_DELETION_DISABLED = 73,\n  RD_KAFKA_RESP_ERR_FENCED_LEADER_EPOCH = 74,\n  RD_KAFKA_RESP_ERR_UNKNOWN_LEADER_EPOCH = 75,\n  RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76,\n  RD_KAFKA_RESP_ERR_STALE_BROKER_EPOCH = 77,\n  RD_KAFKA_RESP_ERR_OFFSET_NOT_AVAILABLE = 78,\n  RD_KAFKA_RESP_ERR_MEMBER_ID_REQUIRED = 79,\n  RD_KAFKA_RESP_ERR_PREFERRED_LEADER_NOT_AVAILABLE = 80,\n  RD_KAFKA_RESP_ERR_GROUP_MAX_SIZE_REACHED = 81,\n  RD_KAFKA_RESP_ERR_FENCED_INSTANCE_ID = 82,\n  RD_KAFKA_RESP_ERR_ELIGIBLE_LEADERS_NOT_AVAILABLE = 83,\n  RD_KAFKA_RESP_ERR_ELECTION_NOT_NEEDED = 84,\n  RD_KAFKA_RESP_ERR_NO_REASSIGNMENT_IN_PROGRESS = 85,\n  RD_KAFKA_RESP_ERR_GROUP_SUBSCRIBED_TO_TOPIC = 86,\n  RD_KAFKA_RESP_ERR_INVALID_RECORD = 87,\n  RD_KAFKA_RESP_ERR_UNSTABLE_OFFSET_COMMIT = 88,\n  RD_KAFKA_RESP_ERR_THROTTLING_QUOTA_EXCEEDED = 89,\n  RD_KAFKA_RESP_ERR_PRODUCER_FENCED = 90,\n  RD_KAFKA_RESP_ERR_RESOURCE_NOT_FOUND = 91,\n  RD_KAFKA_RESP_ERR_DUPLICATE_RESOURCE = 92,\n  RD_KAFKA_RESP_ERR_UNACCEPTABLE_CREDENTIAL = 93,\n  RD_KAFKA_RESP_ERR_INCONSISTENT_VOTER_SET = 94,\n  RD_KAFKA_RESP_ERR_INVALID_UPDATE_VERSION = 95,\n  RD_KAFKA_RESP_ERR_FEATURE_UPDATE_FAILED = 96,\n  RD_KAFKA_RESP_ERR_PRINCIPAL_DESERIALIZATION_FAILURE = 97,\n  RD_KAFKA_RESP_ERR_END_ALL,\n} rd_kafka_resp_err_t;\nstruct rd_kafka_err_desc {\n  rd_kafka_resp_err_t code;\n  char *name;\n  char *desc;\n};\nvoid rd_kafka_get_err_descs(const struct rd_kafka_err_desc **errdescs, size_t *cntp);\nconst char *rd_kafka_err2str(rd_kafka_resp_err_t err);\nconst char *rd_kafka_err2name(rd_kafka_resp_err_t err);\nrd_kafka_resp_err_t rd_kafka_last_error(void);\nrd_kafka_resp_err_t rd_kafka_errno2err(int errnox);\nint rd_kafka_errno(void);\nrd_kafka_resp_err_t rd_kafka_fatal_error(rd_kafka_t *rk, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_test_fatal_error(rd_kafka_t *rk, rd_kafka_resp_err_t err, const char *reason);\nrd_kafka_resp_err_t rd_kafka_error_code(const rd_kafka_error_t *error);\nconst char *rd_kafka_error_name(const rd_kafka_error_t *error);\nconst char *rd_kafka_error_string(const rd_kafka_error_t *error);\nint rd_kafka_error_is_fatal(const rd_kafka_error_t *error);\nint rd_kafka_error_is_retriable(const rd_kafka_error_t *error);\nint rd_kafka_error_txn_requires_abort(const rd_kafka_error_t *error);\nvoid rd_kafka_error_destroy(rd_kafka_error_t *error);\nrd_kafka_error_t *rd_kafka_error_new(rd_kafka_resp_err_t code, const char *fmt, ...);\ntypedef struct rd_kafka_topic_partition_s {\n  char *topic;\n  int32_t partition;\n  int64_t offset;\n  void *metadata;\n  size_t metadata_size;\n  void *opaque;\n  rd_kafka_resp_err_t err;\n  void *_private;\n} rd_kafka_topic_partition_t;\nvoid rd_kafka_topic_partition_destroy(rd_kafka_topic_partition_t *rktpar);\ntypedef struct rd_kafka_topic_partition_list_s {\n  int cnt;\n  int size;\n  rd_kafka_topic_partition_t *elems;\n} rd_kafka_topic_partition_list_t;\nrd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_new(int size);\nvoid rd_kafka_topic_partition_list_destroy(rd_kafka_topic_partition_list_t *rkparlist);\nrd_kafka_topic_partition_t *rd_kafka_topic_partition_list_add(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);\nvoid rd_kafka_topic_partition_list_add_range(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t start, int32_t stop);\nint rd_kafka_topic_partition_list_del(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);\nint rd_kafka_topic_partition_list_del_by_idx(rd_kafka_topic_partition_list_t *rktparlist, int idx);\nrd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_copy(const rd_kafka_topic_partition_list_t *src);\nrd_kafka_resp_err_t rd_kafka_topic_partition_list_set_offset(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition, int64_t offset);\nrd_kafka_topic_partition_t *rd_kafka_topic_partition_list_find(const rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);\nvoid rd_kafka_topic_partition_list_sort(rd_kafka_topic_partition_list_t *rktparlist, int (*cmp)(const void *a, const void *b, void *cmp_opaque), void *cmp_opaque);\ntypedef enum rd_kafka_vtype_t {\n  RD_KAFKA_VTYPE_END,\n  RD_KAFKA_VTYPE_TOPIC,\n  RD_KAFKA_VTYPE_RKT,\n  RD_KAFKA_VTYPE_PARTITION,\n  RD_KAFKA_VTYPE_VALUE,\n  RD_KAFKA_VTYPE_KEY,\n  RD_KAFKA_VTYPE_OPAQUE,\n  RD_KAFKA_VTYPE_MSGFLAGS,\n  RD_KAFKA_VTYPE_TIMESTAMP,\n  RD_KAFKA_VTYPE_HEADER,\n  RD_KAFKA_VTYPE_HEADERS,\n} rd_kafka_vtype_t;\ntypedef struct rd_kafka_vu_s {\n  rd_kafka_vtype_t vtype;\n  union {\n    char *cstr;\n    rd_kafka_topic_t *rkt;\n    int i;\n    int32_t i32;\n    int64_t i64;\n    struct {\n      void *ptr;\n      size_t size;\n    } mem;\n    struct {\n      char *name;\n      void *val;\n      ssize_t size;\n    } header;\n    rd_kafka_headers_t *headers;\n    void *ptr;\n    char _pad[64];\n  } u;\n} rd_kafka_vu_t;\nrd_kafka_headers_t *rd_kafka_headers_new(size_t initial_count);\nvoid rd_kafka_headers_destroy(rd_kafka_headers_t *hdrs);\nrd_kafka_headers_t *rd_kafka_headers_copy(const rd_kafka_headers_t *src);\nrd_kafka_resp_err_t rd_kafka_header_add(rd_kafka_headers_t *hdrs, const char *name, ssize_t name_size, const void *value, ssize_t value_size);\nrd_kafka_resp_err_t rd_kafka_header_remove(rd_kafka_headers_t *hdrs, const char *name);\nrd_kafka_resp_err_t rd_kafka_header_get_last(const rd_kafka_headers_t *hdrs, const char *name, const void **valuep, size_t *sizep);\nrd_kafka_resp_err_t rd_kafka_header_get(const rd_kafka_headers_t *hdrs, size_t idx, const char *name, const void **valuep, size_t *sizep);\nrd_kafka_resp_err_t rd_kafka_header_get_all(const rd_kafka_headers_t *hdrs, size_t idx, const char **namep, const void **valuep, size_t *sizep);\ntypedef struct rd_kafka_message_s {\n  rd_kafka_resp_err_t err;\n  rd_kafka_topic_t *rkt;\n  int32_t partition;\n  void *payload;\n  size_t len;\n  void *key;\n  size_t key_len;\n  int64_t offset;\n  void *_private;\n} rd_kafka_message_t;\nvoid rd_kafka_message_destroy(rd_kafka_message_t *rkmessage);\nconst char *rd_kafka_message_errstr(const rd_kafka_message_t *rkmessage);\nint64_t rd_kafka_message_timestamp(const rd_kafka_message_t *rkmessage, rd_kafka_timestamp_type_t *tstype);\nint64_t rd_kafka_message_latency(const rd_kafka_message_t *rkmessage);\nint32_t rd_kafka_message_broker_id(const rd_kafka_message_t *rkmessage);\nrd_kafka_resp_err_t rd_kafka_message_headers(const rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);\nrd_kafka_resp_err_t rd_kafka_message_detach_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);\nvoid rd_kafka_message_set_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t *hdrs);\nsize_t rd_kafka_header_cnt(const rd_kafka_headers_t *hdrs);\ntypedef enum {\n  RD_KAFKA_MSG_STATUS_NOT_PERSISTED = 0,\n  RD_KAFKA_MSG_STATUS_POSSIBLY_PERSISTED = 1,\n  RD_KAFKA_MSG_STATUS_PERSISTED = 2,\n} rd_kafka_msg_status_t;\nrd_kafka_msg_status_t rd_kafka_message_status(const rd_kafka_message_t *rkmessage);\ntypedef enum {\n  RD_KAFKA_CONF_UNKNOWN = (- 2),\n  RD_KAFKA_CONF_INVALID = (- 1),\n  RD_KAFKA_CONF_OK = 0,\n} rd_kafka_conf_res_t;\nrd_kafka_conf_t *rd_kafka_conf_new(void);\nvoid rd_kafka_conf_destroy(rd_kafka_conf_t *conf);\nrd_kafka_conf_t *rd_kafka_conf_dup(const rd_kafka_conf_t *conf);\nrd_kafka_conf_t *rd_kafka_conf_dup_filter(const rd_kafka_conf_t *conf, size_t filter_cnt, const char **filter);\nconst rd_kafka_conf_t *rd_kafka_conf(rd_kafka_t *rk);\nrd_kafka_conf_res_t rd_kafka_conf_set(rd_kafka_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);\nvoid rd_kafka_conf_set_events(rd_kafka_conf_t *conf, int events);\nvoid rd_kafka_conf_set_background_event_cb(rd_kafka_conf_t *conf, void (*event_cb)(rd_kafka_t *rk, rd_kafka_event_t *rkev, void *opaque));\nvoid rd_kafka_conf_set_dr_cb(rd_kafka_conf_t *conf, void (*dr_cb)(rd_kafka_t *rk, void *payload, size_t len, rd_kafka_resp_err_t err, void *opaque, void *msg_opaque));\nvoid rd_kafka_conf_set_dr_msg_cb(rd_kafka_conf_t *conf, void (*dr_msg_cb)(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, void *opaque));\nvoid rd_kafka_conf_set_consume_cb(rd_kafka_conf_t *conf, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *opaque));\nvoid rd_kafka_conf_set_rebalance_cb(rd_kafka_conf_t *conf, void (*rebalance_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *partitions, void *opaque));\nvoid rd_kafka_conf_set_offset_commit_cb(rd_kafka_conf_t *conf, void (*offset_commit_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *opaque));\nvoid rd_kafka_conf_set_error_cb(rd_kafka_conf_t *conf, void (*error_cb)(rd_kafka_t *rk, int err, const char *reason, void *opaque));\nvoid rd_kafka_conf_set_throttle_cb(rd_kafka_conf_t *conf, void (*throttle_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int throttle_time_ms, void *opaque));\nvoid rd_kafka_conf_set_log_cb(rd_kafka_conf_t *conf, void (*log_cb)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));\nvoid rd_kafka_conf_set_stats_cb(rd_kafka_conf_t *conf, int (*stats_cb)(rd_kafka_t *rk, char *json, size_t json_len, void *opaque));\nvoid rd_kafka_conf_set_oauthbearer_token_refresh_cb(rd_kafka_conf_t *conf, void (*oauthbearer_token_refresh_cb)(rd_kafka_t *rk, const char *oauthbearer_config, void *opaque));\nvoid rd_kafka_conf_enable_sasl_queue(rd_kafka_conf_t *conf, int enable);\nvoid rd_kafka_conf_set_socket_cb(rd_kafka_conf_t *conf, int (*socket_cb)(int domain, int type, int protocol, void *opaque));\nvoid rd_kafka_conf_set_connect_cb(rd_kafka_conf_t *conf, int (*connect_cb)(int sockfd, const struct sockaddr *addr, int addrlen, const char *id, void *opaque));\nvoid rd_kafka_conf_set_closesocket_cb(rd_kafka_conf_t *conf, int (*closesocket_cb)(int sockfd, void *opaque));\nstruct addrinfo;\nvoid rd_kafka_conf_set_resolve_cb(rd_kafka_conf_t *conf, int (*resolve_cb)(const char *node, const char *service, const struct addrinfo *hints, struct addrinfo **res, void *opaque));\nrd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert_verify_cb(rd_kafka_conf_t *conf, int (*ssl_cert_verify_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int *x509_error, int depth, const char *buf, size_t size, char *errstr, size_t errstr_size, void *opaque));\ntypedef enum rd_kafka_cert_type_t {\n  RD_KAFKA_CERT_PUBLIC_KEY,\n  RD_KAFKA_CERT_PRIVATE_KEY,\n  RD_KAFKA_CERT_CA,\n  RD_KAFKA_CERT__CNT,\n} rd_kafka_cert_type_t;\ntypedef enum rd_kafka_cert_enc_t {\n  RD_KAFKA_CERT_ENC_PKCS12,\n  RD_KAFKA_CERT_ENC_DER,\n  RD_KAFKA_CERT_ENC_PEM,\n  RD_KAFKA_CERT_ENC__CNT,\n} rd_kafka_cert_enc_t;\nrd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert(rd_kafka_conf_t *conf, rd_kafka_cert_type_t cert_type, rd_kafka_cert_enc_t cert_enc, const void *buffer, size_t size, char *errstr, size_t errstr_size);\nvoid rd_kafka_conf_set_engine_callback_data(rd_kafka_conf_t *conf, void *callback_data);\nvoid rd_kafka_conf_set_opaque(rd_kafka_conf_t *conf, void *opaque);\nvoid *rd_kafka_opaque(const rd_kafka_t *rk);\nvoid rd_kafka_conf_set_default_topic_conf(rd_kafka_conf_t *conf, rd_kafka_topic_conf_t *tconf);\nrd_kafka_topic_conf_t *rd_kafka_conf_get_default_topic_conf(rd_kafka_conf_t *conf);\nrd_kafka_conf_res_t rd_kafka_conf_get(const rd_kafka_conf_t *conf, const char *name, char *dest, size_t *dest_size);\nrd_kafka_conf_res_t rd_kafka_topic_conf_get(const rd_kafka_topic_conf_t *conf, const char *name, char *dest, size_t *dest_size);\nconst char **rd_kafka_conf_dump(rd_kafka_conf_t *conf, size_t *cntp);\nconst char **rd_kafka_topic_conf_dump(rd_kafka_topic_conf_t *conf, size_t *cntp);\nvoid rd_kafka_conf_dump_free(const char **arr, size_t cnt);\nvoid rd_kafka_conf_properties_show(FILE *fp);\nrd_kafka_topic_conf_t *rd_kafka_topic_conf_new(void);\nrd_kafka_topic_conf_t *rd_kafka_topic_conf_dup(const rd_kafka_topic_conf_t *conf);\nrd_kafka_topic_conf_t *rd_kafka_default_topic_conf_dup(rd_kafka_t *rk);\nvoid rd_kafka_topic_conf_destroy(rd_kafka_topic_conf_t *topic_conf);\nrd_kafka_conf_res_t rd_kafka_topic_conf_set(rd_kafka_topic_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);\nvoid rd_kafka_topic_conf_set_opaque(rd_kafka_topic_conf_t *conf, void *rkt_opaque);\nvoid rd_kafka_topic_conf_set_partitioner_cb(rd_kafka_topic_conf_t *topic_conf, int32_t (*partitioner)(const rd_kafka_topic_t *rkt, const void *keydata, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque));\nvoid rd_kafka_topic_conf_set_msg_order_cmp(rd_kafka_topic_conf_t *topic_conf, int (*msg_order_cmp)(const rd_kafka_message_t *a, const rd_kafka_message_t *b));\nint rd_kafka_topic_partition_available(const rd_kafka_topic_t *rkt, int32_t partition);\nint32_t rd_kafka_msg_partitioner_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_consistent(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_consistent_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_murmur2(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_murmur2_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_fnv1a(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_fnv1a_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nrd_kafka_t *rd_kafka_new(rd_kafka_type_t type, rd_kafka_conf_t *conf, char *errstr, size_t errstr_size);\nvoid rd_kafka_destroy(rd_kafka_t *rk);\nvoid rd_kafka_destroy_flags(rd_kafka_t *rk, int flags);\nconst char *rd_kafka_name(const rd_kafka_t *rk);\nrd_kafka_type_t rd_kafka_type(const rd_kafka_t *rk);\nchar *rd_kafka_memberid(const rd_kafka_t *rk);\nchar *rd_kafka_clusterid(rd_kafka_t *rk, int timeout_ms);\nint32_t rd_kafka_controllerid(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_topic_t *rd_kafka_topic_new(rd_kafka_t *rk, const char *topic, rd_kafka_topic_conf_t *conf);\nvoid rd_kafka_topic_destroy(rd_kafka_topic_t *rkt);\nconst char *rd_kafka_topic_name(const rd_kafka_topic_t *rkt);\nvoid *rd_kafka_topic_opaque(const rd_kafka_topic_t *rkt);\nint rd_kafka_poll(rd_kafka_t *rk, int timeout_ms);\nvoid rd_kafka_yield(rd_kafka_t *rk);\nrd_kafka_resp_err_t rd_kafka_pause_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_resp_err_t rd_kafka_resume_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_resp_err_t rd_kafka_query_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high, int timeout_ms);\nrd_kafka_resp_err_t rd_kafka_get_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high);\nrd_kafka_resp_err_t rd_kafka_offsets_for_times(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets, int timeout_ms);\nvoid *rd_kafka_mem_calloc(rd_kafka_t *rk, size_t num, size_t size);\nvoid *rd_kafka_mem_malloc(rd_kafka_t *rk, size_t size);\nvoid rd_kafka_mem_free(rd_kafka_t *rk, void *ptr);\nrd_kafka_queue_t *rd_kafka_queue_new(rd_kafka_t *rk);\nvoid rd_kafka_queue_destroy(rd_kafka_queue_t *rkqu);\nrd_kafka_queue_t *rd_kafka_queue_get_main(rd_kafka_t *rk);\nrd_kafka_queue_t *rd_kafka_queue_get_sasl(rd_kafka_t *rk);\nrd_kafka_error_t *rd_kafka_sasl_background_callbacks_enable(rd_kafka_t *rk);\nrd_kafka_error_t *rd_kafka_sasl_set_credentials(rd_kafka_t *rk, const char *username, const char *password);\nrd_kafka_queue_t *rd_kafka_queue_get_consumer(rd_kafka_t *rk);\nrd_kafka_queue_t *rd_kafka_queue_get_partition(rd_kafka_t *rk, const char *topic, int32_t partition);\nrd_kafka_queue_t *rd_kafka_queue_get_background(rd_kafka_t *rk);\nvoid rd_kafka_queue_forward(rd_kafka_queue_t *src, rd_kafka_queue_t *dst);\nrd_kafka_resp_err_t rd_kafka_set_log_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu);\nsize_t rd_kafka_queue_length(rd_kafka_queue_t *rkqu);\nvoid rd_kafka_queue_io_event_enable(rd_kafka_queue_t *rkqu, int fd, const void *payload, size_t size);\nvoid rd_kafka_queue_cb_event_enable(rd_kafka_queue_t *rkqu, void (*event_cb)(rd_kafka_t *rk, void *qev_opaque), void *qev_opaque);\nvoid rd_kafka_queue_yield(rd_kafka_queue_t *rkqu);\nint rd_kafka_consume_start(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);\nint rd_kafka_consume_start_queue(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, rd_kafka_queue_t *rkqu);\nint rd_kafka_consume_stop(rd_kafka_topic_t *rkt, int32_t partition);\nrd_kafka_resp_err_t rd_kafka_seek(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, int timeout_ms);\nrd_kafka_error_t *rd_kafka_seek_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms);\nrd_kafka_message_t *rd_kafka_consume(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms);\nssize_t rd_kafka_consume_batch(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);\nint rd_kafka_consume_callback(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);\nrd_kafka_message_t *rd_kafka_consume_queue(rd_kafka_queue_t *rkqu, int timeout_ms);\nssize_t rd_kafka_consume_batch_queue(rd_kafka_queue_t *rkqu, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);\nint rd_kafka_consume_callback_queue(rd_kafka_queue_t *rkqu, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);\nrd_kafka_resp_err_t rd_kafka_offset_store(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);\nrd_kafka_resp_err_t rd_kafka_offsets_store(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets);\nrd_kafka_resp_err_t rd_kafka_subscribe(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *topics);\nrd_kafka_resp_err_t rd_kafka_unsubscribe(rd_kafka_t *rk);\nrd_kafka_resp_err_t rd_kafka_subscription(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **topics);\nrd_kafka_message_t *rd_kafka_consumer_poll(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_resp_err_t rd_kafka_consumer_close(rd_kafka_t *rk);\nrd_kafka_error_t *rd_kafka_consumer_close_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu);\nint rd_kafka_consumer_closed(rd_kafka_t *rk);\nrd_kafka_error_t *rd_kafka_incremental_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_error_t *rd_kafka_incremental_unassign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);\nconst char *rd_kafka_rebalance_protocol(rd_kafka_t *rk);\nrd_kafka_resp_err_t rd_kafka_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_resp_err_t rd_kafka_assignment(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **partitions);\nint rd_kafka_assignment_lost(rd_kafka_t *rk);\nrd_kafka_resp_err_t rd_kafka_commit(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, int async);\nrd_kafka_resp_err_t rd_kafka_commit_message(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, int async);\nrd_kafka_resp_err_t rd_kafka_commit_queue(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_queue_t *rkqu, void (*cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *commit_opaque), void *commit_opaque);\nrd_kafka_resp_err_t rd_kafka_committed(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms);\nrd_kafka_resp_err_t rd_kafka_position(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata(rd_kafka_t *rk);\nrd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata_new(const char *group_id);\nrd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata_new_with_genid(const char *group_id, int32_t generation_id, const char *member_id, const char *group_instance_id);\nvoid rd_kafka_consumer_group_metadata_destroy(rd_kafka_consumer_group_metadata_t *);\nrd_kafka_error_t *rd_kafka_consumer_group_metadata_write(const rd_kafka_consumer_group_metadata_t *cgmd, void **bufferp, size_t *sizep);\nrd_kafka_error_t *rd_kafka_consumer_group_metadata_read(rd_kafka_consumer_group_metadata_t **cgmdp, const void *buffer, size_t size);\nint rd_kafka_produce(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, void *payload, size_t len, const void *key, size_t keylen, void *msg_opaque);\nrd_kafka_resp_err_t rd_kafka_producev(rd_kafka_t *rk, ...);\nrd_kafka_error_t *rd_kafka_produceva(rd_kafka_t *rk, const rd_kafka_vu_t *vus, size_t cnt);\nint rd_kafka_produce_batch(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, rd_kafka_message_t *rkmessages, int message_cnt);\nrd_kafka_resp_err_t rd_kafka_flush(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_resp_err_t rd_kafka_purge(rd_kafka_t *rk, int purge_flags);\ntypedef struct rd_kafka_metadata_broker {\n  int32_t id;\n  char *host;\n  int port;\n} rd_kafka_metadata_broker_t;\ntypedef struct rd_kafka_metadata_partition {\n  int32_t id;\n  rd_kafka_resp_err_t err;\n  int32_t leader;\n  int replica_cnt;\n  int32_t *replicas;\n  int isr_cnt;\n  int32_t *isrs;\n} rd_kafka_metadata_partition_t;\ntypedef struct rd_kafka_metadata_topic {\n  char *topic;\n  int partition_cnt;\n  struct rd_kafka_metadata_partition *partitions;\n  rd_kafka_resp_err_t err;\n} rd_kafka_metadata_topic_t;\ntypedef struct rd_kafka_metadata {\n  int broker_cnt;\n  struct rd_kafka_metadata_broker *brokers;\n  int topic_cnt;\n  struct rd_kafka_metadata_topic *topics;\n  int32_t orig_broker_id;\n  char *orig_broker_name;\n} rd_kafka_metadata_t;\nrd_kafka_resp_err_t rd_kafka_metadata(rd_kafka_t *rk, int all_topics, rd_kafka_topic_t *only_rkt, const struct rd_kafka_metadata **metadatap, int timeout_ms);\nvoid rd_kafka_metadata_destroy(const struct rd_kafka_metadata *metadata);\ntypedef struct rd_kafka_Node_s rd_kafka_Node_t;\nint rd_kafka_Node_id(const rd_kafka_Node_t *node);\nconst char *rd_kafka_Node_host(const rd_kafka_Node_t *node);\nuint16_t rd_kafka_Node_port(const rd_kafka_Node_t *node);\nstruct rd_kafka_group_member_info {\n  char *member_id;\n  char *client_id;\n  char *client_host;\n  void *member_metadata;\n  int member_metadata_size;\n  void *member_assignment;\n  int member_assignment_size;\n};\ntypedef enum {\n  RD_KAFKA_CONSUMER_GROUP_STATE_UNKNOWN = 0,\n  RD_KAFKA_CONSUMER_GROUP_STATE_PREPARING_REBALANCE = 1,\n  RD_KAFKA_CONSUMER_GROUP_STATE_COMPLETING_REBALANCE = 2,\n  RD_KAFKA_CONSUMER_GROUP_STATE_STABLE = 3,\n  RD_KAFKA_CONSUMER_GROUP_STATE_DEAD = 4,\n  RD_KAFKA_CONSUMER_GROUP_STATE_EMPTY = 5,\n  RD_KAFKA_CONSUMER_GROUP_STATE__CNT,\n} rd_kafka_consumer_group_state_t;\nstruct rd_kafka_group_info {\n  struct rd_kafka_metadata_broker broker;\n  char *group;\n  rd_kafka_resp_err_t err;\n  char *state;\n  char *protocol_type;\n  char *protocol;\n  struct rd_kafka_group_member_info *members;\n  int member_cnt;\n};\nstruct rd_kafka_group_list {\n  struct rd_kafka_group_info *groups;\n  int group_cnt;\n};\nrd_kafka_resp_err_t rd_kafka_list_groups(rd_kafka_t *rk, const char *group, const struct rd_kafka_group_list **grplistp, int timeout_ms);\nconst char *rd_kafka_consumer_group_state_name(rd_kafka_consumer_group_state_t state);\nrd_kafka_consumer_group_state_t rd_kafka_consumer_group_state_code(const char *name);\nvoid rd_kafka_group_list_destroy(const struct rd_kafka_group_list *grplist);\nint rd_kafka_brokers_add(rd_kafka_t *rk, const char *brokerlist);\nvoid rd_kafka_set_logger(rd_kafka_t *rk, void (*func)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));\nvoid rd_kafka_set_log_level(rd_kafka_t *rk, int level);\nvoid rd_kafka_log_print(const rd_kafka_t *rk, int level, const char *fac, const char *buf);\nvoid rd_kafka_log_syslog(const rd_kafka_t *rk, int level, const char *fac, const char *buf);\nint rd_kafka_outq_len(rd_kafka_t *rk);\nvoid rd_kafka_dump(FILE *fp, rd_kafka_t *rk);\nint rd_kafka_thread_cnt(void);\ntypedef enum rd_kafka_thread_type_t {\n  RD_KAFKA_THREAD_MAIN,\n  RD_KAFKA_THREAD_BACKGROUND,\n  RD_KAFKA_THREAD_BROKER,\n} rd_kafka_thread_type_t;\nint rd_kafka_wait_destroyed(int timeout_ms);\nint rd_kafka_unittest(void);\nrd_kafka_resp_err_t rd_kafka_poll_set_consumer(rd_kafka_t *rk);\ntypedef int rd_kafka_event_type_t;\nrd_kafka_event_type_t rd_kafka_event_type(const rd_kafka_event_t *rkev);\nconst char *rd_kafka_event_name(const rd_kafka_event_t *rkev);\nvoid rd_kafka_event_destroy(rd_kafka_event_t *rkev);\nconst rd_kafka_message_t *rd_kafka_event_message_next(rd_kafka_event_t *rkev);\nsize_t rd_kafka_event_message_array(rd_kafka_event_t *rkev, const rd_kafka_message_t **rkmessages, size_t size);\nsize_t rd_kafka_event_message_count(rd_kafka_event_t *rkev);\nconst char *rd_kafka_event_config_string(rd_kafka_event_t *rkev);\nrd_kafka_resp_err_t rd_kafka_event_error(rd_kafka_event_t *rkev);\nconst char *rd_kafka_event_error_string(rd_kafka_event_t *rkev);\nint rd_kafka_event_error_is_fatal(rd_kafka_event_t *rkev);\nvoid *rd_kafka_event_opaque(rd_kafka_event_t *rkev);\nint rd_kafka_event_log(rd_kafka_event_t *rkev, const char **fac, const char **str, int *level);\nint rd_kafka_event_debug_contexts(rd_kafka_event_t *rkev, char *dst, size_t dstsize);\nconst char *rd_kafka_event_stats(rd_kafka_event_t *rkev);\nrd_kafka_topic_partition_list_t *rd_kafka_event_topic_partition_list(rd_kafka_event_t *rkev);\nrd_kafka_topic_partition_t *rd_kafka_event_topic_partition(rd_kafka_event_t *rkev);\ntypedef rd_kafka_event_t rd_kafka_CreateTopics_result_t;\ntypedef rd_kafka_event_t rd_kafka_DeleteTopics_result_t;\ntypedef rd_kafka_event_t rd_kafka_CreateAcls_result_t;\ntypedef rd_kafka_event_t rd_kafka_DescribeAcls_result_t;\ntypedef rd_kafka_event_t rd_kafka_DeleteAcls_result_t;\ntypedef rd_kafka_event_t rd_kafka_CreatePartitions_result_t;\ntypedef rd_kafka_event_t rd_kafka_AlterConfigs_result_t;\ntypedef rd_kafka_event_t rd_kafka_DescribeConfigs_result_t;\ntypedef rd_kafka_event_t rd_kafka_DeleteRecords_result_t;\ntypedef rd_kafka_event_t rd_kafka_ListConsumerGroups_result_t;\ntypedef rd_kafka_event_t rd_kafka_DescribeConsumerGroups_result_t;\ntypedef rd_kafka_event_t rd_kafka_DeleteGroups_result_t;\ntypedef rd_kafka_event_t rd_kafka_DeleteConsumerGroupOffsets_result_t;\ntypedef rd_kafka_event_t rd_kafka_AlterConsumerGroupOffsets_result_t;\ntypedef rd_kafka_event_t rd_kafka_ListConsumerGroupOffsets_result_t;\nconst rd_kafka_CreateTopics_result_t *rd_kafka_event_CreateTopics_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DeleteTopics_result_t *rd_kafka_event_DeleteTopics_result(rd_kafka_event_t *rkev);\nconst rd_kafka_CreatePartitions_result_t *rd_kafka_event_CreatePartitions_result(rd_kafka_event_t *rkev);\nconst rd_kafka_AlterConfigs_result_t *rd_kafka_event_AlterConfigs_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DescribeConfigs_result_t *rd_kafka_event_DescribeConfigs_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DeleteRecords_result_t *rd_kafka_event_DeleteRecords_result(rd_kafka_event_t *rkev);\nconst rd_kafka_ListConsumerGroups_result_t *rd_kafka_event_ListConsumerGroups_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DescribeConsumerGroups_result_t *rd_kafka_event_DescribeConsumerGroups_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DeleteGroups_result_t *rd_kafka_event_DeleteGroups_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DeleteConsumerGroupOffsets_result_t *rd_kafka_event_DeleteConsumerGroupOffsets_result(rd_kafka_event_t *rkev);\nconst rd_kafka_CreateAcls_result_t *rd_kafka_event_CreateAcls_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DescribeAcls_result_t *rd_kafka_event_DescribeAcls_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DeleteAcls_result_t *rd_kafka_event_DeleteAcls_result(rd_kafka_event_t *rkev);\nconst rd_kafka_AlterConsumerGroupOffsets_result_t *rd_kafka_event_AlterConsumerGroupOffsets_result(rd_kafka_event_t *rkev);\nconst rd_kafka_ListConsumerGroupOffsets_result_t *rd_kafka_event_ListConsumerGroupOffsets_result(rd_kafka_event_t *rkev);\nrd_kafka_event_t *rd_kafka_queue_poll(rd_kafka_queue_t *rkqu, int timeout_ms);\nint rd_kafka_queue_poll_callback(rd_kafka_queue_t *rkqu, int timeout_ms);\ntypedef rd_kafka_resp_err_t (rd_kafka_plugin_f_conf_init_t)(rd_kafka_conf_t *conf, void **plug_opaquep, char *errstr, size_t errstr_size);\ntypedef rd_kafka_conf_res_t (rd_kafka_interceptor_f_on_conf_set_t)(rd_kafka_conf_t *conf, const char *name, const char *val, char *errstr, size_t errstr_size, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_dup_t)(rd_kafka_conf_t *new_conf, const rd_kafka_conf_t *old_conf, size_t filter_cnt, const char **filter, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_destroy_t)(void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_new_t)(rd_kafka_t *rk, const rd_kafka_conf_t *conf, void *ic_opaque, char *errstr, size_t errstr_size);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_destroy_t)(rd_kafka_t *rk, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_send_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_acknowledgement_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_consume_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_commit_t)(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_resp_err_t err, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_request_sent_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_response_received_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, int64_t rtt, rd_kafka_resp_err_t err, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_start_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_exit_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_broker_state_change_t)(rd_kafka_t *rk, int32_t broker_id, const char *secproto, const char *name, int port, const char *state, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_set(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_set_t *on_conf_set, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_dup(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_dup_t *on_conf_dup, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_destroy(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_destroy_t *on_conf_destroy, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_new(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_new_t *on_new, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_destroy(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_destroy_t *on_destroy, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_send(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_send_t *on_send, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_acknowledgement(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_acknowledgement_t *on_acknowledgement, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_consume(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_consume_t *on_consume, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_commit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_commit_t *on_commit, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_request_sent(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_request_sent_t *on_request_sent, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_response_received(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_response_received_t *on_response_received, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_start(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_start_t *on_thread_start, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_exit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_exit_t *on_thread_exit, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_broker_state_change(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_broker_state_change_t *on_broker_state_change, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_topic_result_error(const rd_kafka_topic_result_t *topicres);\nconst char *rd_kafka_topic_result_error_string(const rd_kafka_topic_result_t *topicres);\nconst char *rd_kafka_topic_result_name(const rd_kafka_topic_result_t *topicres);\nconst rd_kafka_error_t *rd_kafka_group_result_error(const rd_kafka_group_result_t *groupres);\nconst char *rd_kafka_group_result_name(const rd_kafka_group_result_t *groupres);\nconst rd_kafka_topic_partition_list_t *rd_kafka_group_result_partitions(const rd_kafka_group_result_t *groupres);\ntypedef enum rd_kafka_admin_op_t {\n  RD_KAFKA_ADMIN_OP_ANY = 0,\n  RD_KAFKA_ADMIN_OP_CREATETOPICS,\n  RD_KAFKA_ADMIN_OP_DELETETOPICS,\n  RD_KAFKA_ADMIN_OP_CREATEPARTITIONS,\n  RD_KAFKA_ADMIN_OP_ALTERCONFIGS,\n  RD_KAFKA_ADMIN_OP_DESCRIBECONFIGS,\n  RD_KAFKA_ADMIN_OP_DELETERECORDS,\n  RD_KAFKA_ADMIN_OP_DELETEGROUPS,\n  RD_KAFKA_ADMIN_OP_DELETECONSUMERGROUPOFFSETS,\n  RD_KAFKA_ADMIN_OP_CREATEACLS,\n  RD_KAFKA_ADMIN_OP_DESCRIBEACLS,\n  RD_KAFKA_ADMIN_OP_DELETEACLS,\n  RD_KAFKA_ADMIN_OP_LISTCONSUMERGROUPS,\n  RD_KAFKA_ADMIN_OP_DESCRIBECONSUMERGROUPS,\n  RD_KAFKA_ADMIN_OP_LISTCONSUMERGROUPOFFSETS,\n  RD_KAFKA_ADMIN_OP_ALTERCONSUMERGROUPOFFSETS,\n  RD_KAFKA_ADMIN_OP__CNT,\n} rd_kafka_admin_op_t;\ntypedef struct rd_kafka_AdminOptions_s rd_kafka_AdminOptions_t;\nrd_kafka_AdminOptions_t *rd_kafka_AdminOptions_new(rd_kafka_t *rk, rd_kafka_admin_op_t for_api);\nvoid rd_kafka_AdminOptions_destroy(rd_kafka_AdminOptions_t *options);\nrd_kafka_resp_err_t rd_kafka_AdminOptions_set_request_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_AdminOptions_set_operation_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_AdminOptions_set_validate_only(rd_kafka_AdminOptions_t *options, int true_or_false, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_AdminOptions_set_broker(rd_kafka_AdminOptions_t *options, int32_t broker_id, char *errstr, size_t errstr_size);\nrd_kafka_error_t *rd_kafka_AdminOptions_set_require_stable_offsets(rd_kafka_AdminOptions_t *options, int true_or_false);\nrd_kafka_error_t *rd_kafka_AdminOptions_set_match_consumer_group_states(rd_kafka_AdminOptions_t *options, const rd_kafka_consumer_group_state_t *consumer_group_states, size_t consumer_group_states_cnt);\nvoid rd_kafka_AdminOptions_set_opaque(rd_kafka_AdminOptions_t *options, void *ev_opaque);\ntypedef struct rd_kafka_NewTopic_s rd_kafka_NewTopic_t;\nrd_kafka_NewTopic_t *rd_kafka_NewTopic_new(const char *topic, int num_partitions, int replication_factor, char *errstr, size_t errstr_size);\nvoid rd_kafka_NewTopic_destroy(rd_kafka_NewTopic_t *new_topic);\nvoid rd_kafka_NewTopic_destroy_array(rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt);\nrd_kafka_resp_err_t rd_kafka_NewTopic_set_replica_assignment(rd_kafka_NewTopic_t *new_topic, int32_t partition, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_NewTopic_set_config(rd_kafka_NewTopic_t *new_topic, const char *name, const char *value);\nvoid rd_kafka_CreateTopics(rd_kafka_t *rk, rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_topic_result_t **rd_kafka_CreateTopics_result_topics(const rd_kafka_CreateTopics_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_DeleteTopic_s rd_kafka_DeleteTopic_t;\nrd_kafka_DeleteTopic_t *rd_kafka_DeleteTopic_new(const char *topic);\nvoid rd_kafka_DeleteTopic_destroy(rd_kafka_DeleteTopic_t *del_topic);\nvoid rd_kafka_DeleteTopic_destroy_array(rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt);\nvoid rd_kafka_DeleteTopics(rd_kafka_t *rk, rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_topic_result_t **rd_kafka_DeleteTopics_result_topics(const rd_kafka_DeleteTopics_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_NewPartitions_s rd_kafka_NewPartitions_t;\nrd_kafka_NewPartitions_t *rd_kafka_NewPartitions_new(const char *topic, size_t new_total_cnt, char *errstr, size_t errstr_size);\nvoid rd_kafka_NewPartitions_destroy(rd_kafka_NewPartitions_t *new_parts);\nvoid rd_kafka_NewPartitions_destroy_array(rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt);\nrd_kafka_resp_err_t rd_kafka_NewPartitions_set_replica_assignment(rd_kafka_NewPartitions_t *new_parts, int32_t new_partition_idx, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);\nvoid rd_kafka_CreatePartitions(rd_kafka_t *rk, rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_topic_result_t **rd_kafka_CreatePartitions_result_topics(const rd_kafka_CreatePartitions_result_t *result, size_t *cntp);\ntypedef enum rd_kafka_ConfigSource_t {\n  RD_KAFKA_CONFIG_SOURCE_UNKNOWN_CONFIG = 0,\n  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_TOPIC_CONFIG = 1,\n  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_BROKER_CONFIG = 2,\n  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_DEFAULT_BROKER_CONFIG = 3,\n  RD_KAFKA_CONFIG_SOURCE_STATIC_BROKER_CONFIG = 4,\n  RD_KAFKA_CONFIG_SOURCE_DEFAULT_CONFIG = 5,\n  RD_KAFKA_CONFIG_SOURCE__CNT,\n} rd_kafka_ConfigSource_t;\nconst char *rd_kafka_ConfigSource_name(rd_kafka_ConfigSource_t confsource);\ntypedef struct rd_kafka_ConfigEntry_s rd_kafka_ConfigEntry_t;\nconst char *rd_kafka_ConfigEntry_name(const rd_kafka_ConfigEntry_t *entry);\nconst char *rd_kafka_ConfigEntry_value(const rd_kafka_ConfigEntry_t *entry);\nrd_kafka_ConfigSource_t rd_kafka_ConfigEntry_source(const rd_kafka_ConfigEntry_t *entry);\nint rd_kafka_ConfigEntry_is_read_only(const rd_kafka_ConfigEntry_t *entry);\nint rd_kafka_ConfigEntry_is_default(const rd_kafka_ConfigEntry_t *entry);\nint rd_kafka_ConfigEntry_is_sensitive(const rd_kafka_ConfigEntry_t *entry);\nint rd_kafka_ConfigEntry_is_synonym(const rd_kafka_ConfigEntry_t *entry);\nconst rd_kafka_ConfigEntry_t **rd_kafka_ConfigEntry_synonyms(const rd_kafka_ConfigEntry_t *entry, size_t *cntp);\ntypedef enum rd_kafka_ResourceType_t {\n  RD_KAFKA_RESOURCE_UNKNOWN = 0,\n  RD_KAFKA_RESOURCE_ANY = 1,\n  RD_KAFKA_RESOURCE_TOPIC = 2,\n  RD_KAFKA_RESOURCE_GROUP = 3,\n  RD_KAFKA_RESOURCE_BROKER = 4,\n  RD_KAFKA_RESOURCE__CNT,\n} rd_kafka_ResourceType_t;\ntypedef enum rd_kafka_ResourcePatternType_t {\n  RD_KAFKA_RESOURCE_PATTERN_UNKNOWN = 0,\n  RD_KAFKA_RESOURCE_PATTERN_ANY = 1,\n  RD_KAFKA_RESOURCE_PATTERN_MATCH = 2,\n  RD_KAFKA_RESOURCE_PATTERN_LITERAL = 3,\n  RD_KAFKA_RESOURCE_PATTERN_PREFIXED = 4,\n  RD_KAFKA_RESOURCE_PATTERN_TYPE__CNT,\n} rd_kafka_ResourcePatternType_t;\nconst char *rd_kafka_ResourcePatternType_name(rd_kafka_ResourcePatternType_t resource_pattern_type);\nconst char *rd_kafka_ResourceType_name(rd_kafka_ResourceType_t restype);\ntypedef struct rd_kafka_ConfigResource_s rd_kafka_ConfigResource_t;\nrd_kafka_ConfigResource_t *rd_kafka_ConfigResource_new(rd_kafka_ResourceType_t restype, const char *resname);\nvoid rd_kafka_ConfigResource_destroy(rd_kafka_ConfigResource_t *config);\nvoid rd_kafka_ConfigResource_destroy_array(rd_kafka_ConfigResource_t **config, size_t config_cnt);\nrd_kafka_resp_err_t rd_kafka_ConfigResource_set_config(rd_kafka_ConfigResource_t *config, const char *name, const char *value);\nconst rd_kafka_ConfigEntry_t **rd_kafka_ConfigResource_configs(const rd_kafka_ConfigResource_t *config, size_t *cntp);\nrd_kafka_ResourceType_t rd_kafka_ConfigResource_type(const rd_kafka_ConfigResource_t *config);\nconst char *rd_kafka_ConfigResource_name(const rd_kafka_ConfigResource_t *config);\nrd_kafka_resp_err_t rd_kafka_ConfigResource_error(const rd_kafka_ConfigResource_t *config);\nconst char *rd_kafka_ConfigResource_error_string(const rd_kafka_ConfigResource_t *config);\nvoid rd_kafka_AlterConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_ConfigResource_t **rd_kafka_AlterConfigs_result_resources(const rd_kafka_AlterConfigs_result_t *result, size_t *cntp);\nvoid rd_kafka_DescribeConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_ConfigResource_t **rd_kafka_DescribeConfigs_result_resources(const rd_kafka_DescribeConfigs_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_DeleteRecords_s rd_kafka_DeleteRecords_t;\nrd_kafka_DeleteRecords_t *rd_kafka_DeleteRecords_new(const rd_kafka_topic_partition_list_t *before_offsets);\nvoid rd_kafka_DeleteRecords_destroy(rd_kafka_DeleteRecords_t *del_records);\nvoid rd_kafka_DeleteRecords_destroy_array(rd_kafka_DeleteRecords_t **del_records, size_t del_record_cnt);\nvoid rd_kafka_DeleteRecords(rd_kafka_t *rk, rd_kafka_DeleteRecords_t **del_records, size_t del_record_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_topic_partition_list_t *rd_kafka_DeleteRecords_result_offsets(const rd_kafka_DeleteRecords_result_t *result);\ntypedef struct rd_kafka_ConsumerGroupListing_s rd_kafka_ConsumerGroupListing_t;\ntypedef struct rd_kafka_ListConsumerGroupsResult_s rd_kafka_ListConsumerGroupsResult_t;\nvoid rd_kafka_ListConsumerGroups(rd_kafka_t *rk, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst char *rd_kafka_ConsumerGroupListing_group_id(const rd_kafka_ConsumerGroupListing_t *grplist);\nint rd_kafka_ConsumerGroupListing_is_simple_consumer_group(const rd_kafka_ConsumerGroupListing_t *grplist);\nrd_kafka_consumer_group_state_t rd_kafka_ConsumerGroupListing_state(const rd_kafka_ConsumerGroupListing_t *grplist);\nconst rd_kafka_ConsumerGroupListing_t **rd_kafka_ListConsumerGroups_result_valid(const rd_kafka_ListConsumerGroups_result_t *result, size_t *cntp);\nconst rd_kafka_error_t **rd_kafka_ListConsumerGroups_result_errors(const rd_kafka_ListConsumerGroups_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_ConsumerGroupDescription_s rd_kafka_ConsumerGroupDescription_t;\ntypedef struct rd_kafka_MemberDescription_s rd_kafka_MemberDescription_t;\ntypedef struct rd_kafka_MemberAssignment_s rd_kafka_MemberAssignment_t;\nvoid rd_kafka_DescribeConsumerGroups(rd_kafka_t *rk, const char **groups, size_t groups_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_ConsumerGroupDescription_t **rd_kafka_DescribeConsumerGroups_result_groups(const rd_kafka_DescribeConsumerGroups_result_t *result, size_t *cntp);\nconst char *rd_kafka_ConsumerGroupDescription_group_id(const rd_kafka_ConsumerGroupDescription_t *grpdesc);\nconst rd_kafka_error_t *rd_kafka_ConsumerGroupDescription_error(const rd_kafka_ConsumerGroupDescription_t *grpdesc);\nint rd_kafka_ConsumerGroupDescription_is_simple_consumer_group(const rd_kafka_ConsumerGroupDescription_t *grpdesc);\nconst char *rd_kafka_ConsumerGroupDescription_partition_assignor(const rd_kafka_ConsumerGroupDescription_t *grpdesc);\nrd_kafka_consumer_group_state_t rd_kafka_ConsumerGroupDescription_state(const rd_kafka_ConsumerGroupDescription_t *grpdesc);\nconst rd_kafka_Node_t *rd_kafka_ConsumerGroupDescription_coordinator(const rd_kafka_ConsumerGroupDescription_t *grpdesc);\nsize_t rd_kafka_ConsumerGroupDescription_member_count(const rd_kafka_ConsumerGroupDescription_t *grpdesc);\nconst rd_kafka_MemberDescription_t *rd_kafka_ConsumerGroupDescription_member(const rd_kafka_ConsumerGroupDescription_t *grpdesc, size_t idx);\nconst char *rd_kafka_MemberDescription_client_id(const rd_kafka_MemberDescription_t *member);\nconst char *rd_kafka_MemberDescription_group_instance_id(const rd_kafka_MemberDescription_t *member);\nconst char *rd_kafka_MemberDescription_consumer_id(const rd_kafka_MemberDescription_t *member);\nconst char *rd_kafka_MemberDescription_host(const rd_kafka_MemberDescription_t *member);\nconst rd_kafka_MemberAssignment_t *rd_kafka_MemberDescription_assignment(const rd_kafka_MemberDescription_t *member);\nconst rd_kafka_topic_partition_list_t *rd_kafka_MemberAssignment_partitions(const rd_kafka_MemberAssignment_t *assignment);\ntypedef struct rd_kafka_DeleteGroup_s rd_kafka_DeleteGroup_t;\nrd_kafka_DeleteGroup_t *rd_kafka_DeleteGroup_new(const char *group);\nvoid rd_kafka_DeleteGroup_destroy(rd_kafka_DeleteGroup_t *del_group);\nvoid rd_kafka_DeleteGroup_destroy_array(rd_kafka_DeleteGroup_t **del_groups, size_t del_group_cnt);\nvoid rd_kafka_DeleteGroups(rd_kafka_t *rk, rd_kafka_DeleteGroup_t **del_groups, size_t del_group_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_group_result_t **rd_kafka_DeleteGroups_result_groups(const rd_kafka_DeleteGroups_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_ListConsumerGroupOffsets_s rd_kafka_ListConsumerGroupOffsets_t;\nrd_kafka_ListConsumerGroupOffsets_t *rd_kafka_ListConsumerGroupOffsets_new(const char *group_id, const rd_kafka_topic_partition_list_t *partitions);\nvoid rd_kafka_ListConsumerGroupOffsets_destroy(rd_kafka_ListConsumerGroupOffsets_t *list_grpoffsets);\nvoid rd_kafka_ListConsumerGroupOffsets_destroy_array(rd_kafka_ListConsumerGroupOffsets_t **list_grpoffsets, size_t list_grpoffset_cnt);\nvoid rd_kafka_ListConsumerGroupOffsets(rd_kafka_t *rk, rd_kafka_ListConsumerGroupOffsets_t **list_grpoffsets, size_t list_grpoffsets_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_group_result_t **rd_kafka_ListConsumerGroupOffsets_result_groups(const rd_kafka_ListConsumerGroupOffsets_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_AlterConsumerGroupOffsets_s rd_kafka_AlterConsumerGroupOffsets_t;\nrd_kafka_AlterConsumerGroupOffsets_t *rd_kafka_AlterConsumerGroupOffsets_new(const char *group_id, const rd_kafka_topic_partition_list_t *partitions);\nvoid rd_kafka_AlterConsumerGroupOffsets_destroy(rd_kafka_AlterConsumerGroupOffsets_t *alter_grpoffsets);\nvoid rd_kafka_AlterConsumerGroupOffsets_destroy_array(rd_kafka_AlterConsumerGroupOffsets_t **alter_grpoffsets, size_t alter_grpoffset_cnt);\nvoid rd_kafka_AlterConsumerGroupOffsets(rd_kafka_t *rk, rd_kafka_AlterConsumerGroupOffsets_t **alter_grpoffsets, size_t alter_grpoffsets_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_group_result_t **rd_kafka_AlterConsumerGroupOffsets_result_groups(const rd_kafka_AlterConsumerGroupOffsets_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_DeleteConsumerGroupOffsets_s rd_kafka_DeleteConsumerGroupOffsets_t;\nrd_kafka_DeleteConsumerGroupOffsets_t *rd_kafka_DeleteConsumerGroupOffsets_new(const char *group, const rd_kafka_topic_partition_list_t *partitions);\nvoid rd_kafka_DeleteConsumerGroupOffsets_destroy(rd_kafka_DeleteConsumerGroupOffsets_t *del_grpoffsets);\nvoid rd_kafka_DeleteConsumerGroupOffsets_destroy_array(rd_kafka_DeleteConsumerGroupOffsets_t **del_grpoffsets, size_t del_grpoffset_cnt);\nvoid rd_kafka_DeleteConsumerGroupOffsets(rd_kafka_t *rk, rd_kafka_DeleteConsumerGroupOffsets_t **del_grpoffsets, size_t del_grpoffsets_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_group_result_t **rd_kafka_DeleteConsumerGroupOffsets_result_groups(const rd_kafka_DeleteConsumerGroupOffsets_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_AclBinding_s rd_kafka_AclBinding_t;\ntypedef rd_kafka_AclBinding_t rd_kafka_AclBindingFilter_t;\nconst rd_kafka_error_t *rd_kafka_acl_result_error(const rd_kafka_acl_result_t *aclres);\ntypedef enum rd_kafka_AclOperation_t {\n  RD_KAFKA_ACL_OPERATION_UNKNOWN = 0,\n  RD_KAFKA_ACL_OPERATION_ANY = 1,\n  RD_KAFKA_ACL_OPERATION_ALL = 2,\n  RD_KAFKA_ACL_OPERATION_READ = 3,\n  RD_KAFKA_ACL_OPERATION_WRITE = 4,\n  RD_KAFKA_ACL_OPERATION_CREATE = 5,\n  RD_KAFKA_ACL_OPERATION_DELETE = 6,\n  RD_KAFKA_ACL_OPERATION_ALTER = 7,\n  RD_KAFKA_ACL_OPERATION_DESCRIBE = 8,\n  RD_KAFKA_ACL_OPERATION_CLUSTER_ACTION = 9,\n  RD_KAFKA_ACL_OPERATION_DESCRIBE_CONFIGS = 10,\n  RD_KAFKA_ACL_OPERATION_ALTER_CONFIGS = 11,\n  RD_KAFKA_ACL_OPERATION_IDEMPOTENT_WRITE = 12,\n  RD_KAFKA_ACL_OPERATION__CNT,\n} rd_kafka_AclOperation_t;\nconst char *rd_kafka_AclOperation_name(rd_kafka_AclOperation_t acl_operation);\ntypedef enum rd_kafka_AclPermissionType_t {\n  RD_KAFKA_ACL_PERMISSION_TYPE_UNKNOWN = 0,\n  RD_KAFKA_ACL_PERMISSION_TYPE_ANY = 1,\n  RD_KAFKA_ACL_PERMISSION_TYPE_DENY = 2,\n  RD_KAFKA_ACL_PERMISSION_TYPE_ALLOW = 3,\n  RD_KAFKA_ACL_PERMISSION_TYPE__CNT,\n} rd_kafka_AclPermissionType_t;\nconst char *rd_kafka_AclPermissionType_name(rd_kafka_AclPermissionType_t acl_permission_type);\nrd_kafka_AclBinding_t *rd_kafka_AclBinding_new(rd_kafka_ResourceType_t restype, const char *name, rd_kafka_ResourcePatternType_t resource_pattern_type, const char *principal, const char *host, rd_kafka_AclOperation_t operation, rd_kafka_AclPermissionType_t permission_type, char *errstr, size_t errstr_size);\nrd_kafka_AclBindingFilter_t *rd_kafka_AclBindingFilter_new(rd_kafka_ResourceType_t restype, const char *name, rd_kafka_ResourcePatternType_t resource_pattern_type, const char *principal, const char *host, rd_kafka_AclOperation_t operation, rd_kafka_AclPermissionType_t permission_type, char *errstr, size_t errstr_size);\nrd_kafka_ResourceType_t rd_kafka_AclBinding_restype(const rd_kafka_AclBinding_t *acl);\nconst char *rd_kafka_AclBinding_name(const rd_kafka_AclBinding_t *acl);\nconst char *rd_kafka_AclBinding_principal(const rd_kafka_AclBinding_t *acl);\nconst char *rd_kafka_AclBinding_host(const rd_kafka_AclBinding_t *acl);\nrd_kafka_AclOperation_t rd_kafka_AclBinding_operation(const rd_kafka_AclBinding_t *acl);\nrd_kafka_AclPermissionType_t rd_kafka_AclBinding_permission_type(const rd_kafka_AclBinding_t *acl);\nrd_kafka_ResourcePatternType_t rd_kafka_AclBinding_resource_pattern_type(const rd_kafka_AclBinding_t *acl);\nconst rd_kafka_error_t *rd_kafka_AclBinding_error(const rd_kafka_AclBinding_t *acl);\nvoid rd_kafka_AclBinding_destroy(rd_kafka_AclBinding_t *acl_binding);\nvoid rd_kafka_AclBinding_destroy_array(rd_kafka_AclBinding_t **acl_bindings, size_t acl_bindings_cnt);\nconst rd_kafka_acl_result_t **rd_kafka_CreateAcls_result_acls(const rd_kafka_CreateAcls_result_t *result, size_t *cntp);\nvoid rd_kafka_CreateAcls(rd_kafka_t *rk, rd_kafka_AclBinding_t **new_acls, size_t new_acls_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_AclBinding_t **rd_kafka_DescribeAcls_result_acls(const rd_kafka_DescribeAcls_result_t *result, size_t *cntp);\nvoid rd_kafka_DescribeAcls(rd_kafka_t *rk, rd_kafka_AclBindingFilter_t *acl_filter, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\ntypedef struct rd_kafka_DeleteAcls_result_response_s rd_kafka_DeleteAcls_result_response_t;\nconst rd_kafka_DeleteAcls_result_response_t **rd_kafka_DeleteAcls_result_responses(const rd_kafka_DeleteAcls_result_t *result, size_t *cntp);\nconst rd_kafka_error_t *rd_kafka_DeleteAcls_result_response_error(const rd_kafka_DeleteAcls_result_response_t *result_response);\nconst rd_kafka_AclBinding_t **rd_kafka_DeleteAcls_result_response_matching_acls(const rd_kafka_DeleteAcls_result_response_t *result_response, size_t *matching_acls_cntp);\nvoid rd_kafka_DeleteAcls(rd_kafka_t *rk, rd_kafka_AclBindingFilter_t **del_acls, size_t del_acls_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nrd_kafka_resp_err_t rd_kafka_oauthbearer_set_token(rd_kafka_t *rk, const char *token_value, int64_t md_lifetime_ms, const char *md_principal_name, const char **extensions, size_t extension_size, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_oauthbearer_set_token_failure(rd_kafka_t *rk, const char *errstr);\nrd_kafka_error_t *rd_kafka_init_transactions(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_error_t *rd_kafka_begin_transaction(rd_kafka_t *rk);\nrd_kafka_error_t *rd_kafka_send_offsets_to_transaction(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, const rd_kafka_consumer_group_metadata_t *cgmetadata, int timeout_ms);\nrd_kafka_error_t *rd_kafka_commit_transaction(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_error_t *rd_kafka_abort_transaction(rd_kafka_t *rk, int timeout_ms);\ntypedef struct rd_kafka_mock_cluster_s rd_kafka_mock_cluster_t;\nrd_kafka_mock_cluster_t *rd_kafka_mock_cluster_new(rd_kafka_t *rk, int broker_cnt);\nvoid rd_kafka_mock_cluster_destroy(rd_kafka_mock_cluster_t *mcluster);\nrd_kafka_t *rd_kafka_mock_cluster_handle(const rd_kafka_mock_cluster_t *mcluster);\nrd_kafka_mock_cluster_t *rd_kafka_handle_mock_cluster(const rd_kafka_t *rk);\nconst char *rd_kafka_mock_cluster_bootstraps(const rd_kafka_mock_cluster_t *mcluster);\nvoid rd_kafka_mock_clear_request_errors(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey);\nvoid rd_kafka_mock_push_request_errors(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, size_t cnt, ...);\nvoid rd_kafka_mock_push_request_errors_array(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, size_t cnt, const rd_kafka_resp_err_t *errors);\nrd_kafka_resp_err_t rd_kafka_mock_broker_push_request_error_rtts(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int16_t ApiKey, size_t cnt, ...);\nrd_kafka_resp_err_t rd_kafka_mock_broker_error_stack_cnt(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int16_t ApiKey, size_t *cntp);\nvoid rd_kafka_mock_topic_set_error(rd_kafka_mock_cluster_t *mcluster, const char *topic, rd_kafka_resp_err_t err);\nrd_kafka_resp_err_t rd_kafka_mock_topic_create(rd_kafka_mock_cluster_t *mcluster, const char *topic, int partition_cnt, int replication_factor);\nrd_kafka_resp_err_t rd_kafka_mock_partition_set_leader(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id);\nrd_kafka_resp_err_t rd_kafka_mock_partition_set_follower(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id);\nrd_kafka_resp_err_t rd_kafka_mock_partition_set_follower_wmarks(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int64_t lo, int64_t hi);\nrd_kafka_resp_err_t rd_kafka_mock_broker_set_down(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id);\nrd_kafka_resp_err_t rd_kafka_mock_broker_set_up(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id);\nrd_kafka_resp_err_t rd_kafka_mock_broker_set_rtt(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int rtt_ms);\nrd_kafka_resp_err_t rd_kafka_mock_broker_set_rack(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, const char *rack);\nrd_kafka_resp_err_t rd_kafka_mock_coordinator_set(rd_kafka_mock_cluster_t *mcluster, const char *key_type, const char *key, int32_t broker_id);\nrd_kafka_resp_err_t rd_kafka_mock_set_apiversion(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, int16_t MinVersion, int16_t MaxVersion);\n'\n</code></pre> rdkafka.h, rdkafka_mock.h</p>"},{"location":"api/constants/#rd_kafka_version_23","title":"RD_KAFKA_VERSION","text":"<pre><code>public RD_KAFKA_VERSION = 33554687\n</code></pre> <p>librdkafka version </p> <p>Interpreted as hex <code>MM.mm.rr.xx</code>:</p> <ul> <li>MM = Major</li> <li>mm = minor</li> <li>rr = revision</li> <li>xx = pre-release id (0xff is the final release)</li> </ul> <p>E.g.: <code>0x000801ff</code> = 0.8.1</p> RemarksThis value should only be used during compile time, for runtime checks of version use rd_kafka_version()  <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_unsupported_compression_type_23","title":"RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE","text":"<pre><code>public RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76\n</code></pre> <p>Unsupported compression type </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_end_all_23","title":"RD_KAFKA_RESP_ERR_END_ALL","text":"<p><pre><code>public RD_KAFKA_RESP_ERR_END_ALL = 98\n</code></pre> enum rd_kafka_resp_err_t</p>"},{"location":"api/constants/#rd_kafka_admin_op__cnt_23","title":"RD_KAFKA_ADMIN_OP__CNT","text":"<pre><code>public RD_KAFKA_ADMIN_OP__CNT = 16\n</code></pre> <p>Number of ops defined </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe </li> </ul>"},{"location":"api/constants/#rd_kafka_resource__cnt_23","title":"RD_KAFKA_RESOURCE__CNT","text":"<pre><code>public RD_KAFKA_RESOURCE__CNT = 5\n</code></pre> <p>Number of resource types defined </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#acca83a66d7783ff7683ed2691cc907c9 </li> </ul>"},{"location":"api/constants/#rd_kafka_cdef_23","title":"RD_KAFKA_CDEF","text":"<p><pre><code>public RD_KAFKA_CDEF = 'typedef long int ssize_t;\ntypedef struct _IO_FILE FILE;\ntypedef long int mode_t;\ntypedef signed int int16_t;\ntypedef unsigned int uint16_t;\ntypedef signed int int32_t;\ntypedef signed long int int64_t;\nint rd_kafka_version(void);\nconst char *rd_kafka_version_str(void);\ntypedef enum rd_kafka_type_t {\n  RD_KAFKA_PRODUCER,\n  RD_KAFKA_CONSUMER,\n} rd_kafka_type_t;\ntypedef enum rd_kafka_timestamp_type_t {\n  RD_KAFKA_TIMESTAMP_NOT_AVAILABLE,\n  RD_KAFKA_TIMESTAMP_CREATE_TIME,\n  RD_KAFKA_TIMESTAMP_LOG_APPEND_TIME,\n} rd_kafka_timestamp_type_t;\nconst char *rd_kafka_get_debug_contexts(void);\ntypedef struct rd_kafka_s rd_kafka_t;\ntypedef struct rd_kafka_topic_s rd_kafka_topic_t;\ntypedef struct rd_kafka_conf_s rd_kafka_conf_t;\ntypedef struct rd_kafka_topic_conf_s rd_kafka_topic_conf_t;\ntypedef struct rd_kafka_queue_s rd_kafka_queue_t;\ntypedef struct rd_kafka_op_s rd_kafka_event_t;\ntypedef struct rd_kafka_topic_result_s rd_kafka_topic_result_t;\ntypedef struct rd_kafka_consumer_group_metadata_s rd_kafka_consumer_group_metadata_t;\ntypedef struct rd_kafka_error_s {\n  unsigned int code;\n  char *errstr;\n  unsigned char fatal;\n  unsigned char retriable;\n  unsigned char txn_requires_abort;\n} rd_kafka_error_t;\ntypedef struct rd_kafka_headers_s rd_kafka_headers_t;\ntypedef struct rd_kafka_group_result_s rd_kafka_group_result_t;\ntypedef struct rd_kafka_acl_result_s rd_kafka_acl_result_t;\ntypedef enum {\n  RD_KAFKA_RESP_ERR__BEGIN = (- 200),\n  RD_KAFKA_RESP_ERR__BAD_MSG = (- 199),\n  RD_KAFKA_RESP_ERR__BAD_COMPRESSION = (- 198),\n  RD_KAFKA_RESP_ERR__DESTROY = (- 197),\n  RD_KAFKA_RESP_ERR__FAIL = (- 196),\n  RD_KAFKA_RESP_ERR__TRANSPORT = (- 195),\n  RD_KAFKA_RESP_ERR__CRIT_SYS_RESOURCE = (- 194),\n  RD_KAFKA_RESP_ERR__RESOLVE = (- 193),\n  RD_KAFKA_RESP_ERR__MSG_TIMED_OUT = (- 192),\n  RD_KAFKA_RESP_ERR__PARTITION_EOF = (- 191),\n  RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION = (- 190),\n  RD_KAFKA_RESP_ERR__FS = (- 189),\n  RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC = (- 188),\n  RD_KAFKA_RESP_ERR__ALL_BROKERS_DOWN = (- 187),\n  RD_KAFKA_RESP_ERR__INVALID_ARG = (- 186),\n  RD_KAFKA_RESP_ERR__TIMED_OUT = (- 185),\n  RD_KAFKA_RESP_ERR__QUEUE_FULL = (- 184),\n  RD_KAFKA_RESP_ERR__ISR_INSUFF = (- 183),\n  RD_KAFKA_RESP_ERR__NODE_UPDATE = (- 182),\n  RD_KAFKA_RESP_ERR__SSL = (- 181),\n  RD_KAFKA_RESP_ERR__WAIT_COORD = (- 180),\n  RD_KAFKA_RESP_ERR__UNKNOWN_GROUP = (- 179),\n  RD_KAFKA_RESP_ERR__IN_PROGRESS = (- 178),\n  RD_KAFKA_RESP_ERR__PREV_IN_PROGRESS = (- 177),\n  RD_KAFKA_RESP_ERR__EXISTING_SUBSCRIPTION = (- 176),\n  RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS = (- 175),\n  RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS = (- 174),\n  RD_KAFKA_RESP_ERR__CONFLICT = (- 173),\n  RD_KAFKA_RESP_ERR__STATE = (- 172),\n  RD_KAFKA_RESP_ERR__UNKNOWN_PROTOCOL = (- 171),\n  RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED = (- 170),\n  RD_KAFKA_RESP_ERR__AUTHENTICATION = (- 169),\n  RD_KAFKA_RESP_ERR__NO_OFFSET = (- 168),\n  RD_KAFKA_RESP_ERR__OUTDATED = (- 167),\n  RD_KAFKA_RESP_ERR__TIMED_OUT_QUEUE = (- 166),\n  RD_KAFKA_RESP_ERR__UNSUPPORTED_FEATURE = (- 165),\n  RD_KAFKA_RESP_ERR__WAIT_CACHE = (- 164),\n  RD_KAFKA_RESP_ERR__INTR = (- 163),\n  RD_KAFKA_RESP_ERR__KEY_SERIALIZATION = (- 162),\n  RD_KAFKA_RESP_ERR__VALUE_SERIALIZATION = (- 161),\n  RD_KAFKA_RESP_ERR__KEY_DESERIALIZATION = (- 160),\n  RD_KAFKA_RESP_ERR__VALUE_DESERIALIZATION = (- 159),\n  RD_KAFKA_RESP_ERR__PARTIAL = (- 158),\n  RD_KAFKA_RESP_ERR__READ_ONLY = (- 157),\n  RD_KAFKA_RESP_ERR__NOENT = (- 156),\n  RD_KAFKA_RESP_ERR__UNDERFLOW = (- 155),\n  RD_KAFKA_RESP_ERR__INVALID_TYPE = (- 154),\n  RD_KAFKA_RESP_ERR__RETRY = (- 153),\n  RD_KAFKA_RESP_ERR__PURGE_QUEUE = (- 152),\n  RD_KAFKA_RESP_ERR__PURGE_INFLIGHT = (- 151),\n  RD_KAFKA_RESP_ERR__FATAL = (- 150),\n  RD_KAFKA_RESP_ERR__INCONSISTENT = (- 149),\n  RD_KAFKA_RESP_ERR__GAPLESS_GUARANTEE = (- 148),\n  RD_KAFKA_RESP_ERR__MAX_POLL_EXCEEDED = (- 147),\n  RD_KAFKA_RESP_ERR__UNKNOWN_BROKER = (- 146),\n  RD_KAFKA_RESP_ERR__NOT_CONFIGURED = (- 145),\n  RD_KAFKA_RESP_ERR__FENCED = (- 144),\n  RD_KAFKA_RESP_ERR__APPLICATION = (- 143),\n  RD_KAFKA_RESP_ERR__ASSIGNMENT_LOST = (- 142),\n  RD_KAFKA_RESP_ERR__NOOP = (- 141),\n  RD_KAFKA_RESP_ERR__AUTO_OFFSET_RESET = (- 140),\n  RD_KAFKA_RESP_ERR__END = (- 100),\n  RD_KAFKA_RESP_ERR_UNKNOWN = (- 1),\n  RD_KAFKA_RESP_ERR_NO_ERROR = 0,\n  RD_KAFKA_RESP_ERR_OFFSET_OUT_OF_RANGE = 1,\n  RD_KAFKA_RESP_ERR_INVALID_MSG = 2,\n  RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART = 3,\n  RD_KAFKA_RESP_ERR_INVALID_MSG_SIZE = 4,\n  RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE = 5,\n  RD_KAFKA_RESP_ERR_NOT_LEADER_FOR_PARTITION = 6,\n  RD_KAFKA_RESP_ERR_REQUEST_TIMED_OUT = 7,\n  RD_KAFKA_RESP_ERR_BROKER_NOT_AVAILABLE = 8,\n  RD_KAFKA_RESP_ERR_REPLICA_NOT_AVAILABLE = 9,\n  RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE = 10,\n  RD_KAFKA_RESP_ERR_STALE_CTRL_EPOCH = 11,\n  RD_KAFKA_RESP_ERR_OFFSET_METADATA_TOO_LARGE = 12,\n  RD_KAFKA_RESP_ERR_NETWORK_EXCEPTION = 13,\n  RD_KAFKA_RESP_ERR_COORDINATOR_LOAD_IN_PROGRESS = 14,\n  RD_KAFKA_RESP_ERR_COORDINATOR_NOT_AVAILABLE = 15,\n  RD_KAFKA_RESP_ERR_NOT_COORDINATOR = 16,\n  RD_KAFKA_RESP_ERR_TOPIC_EXCEPTION = 17,\n  RD_KAFKA_RESP_ERR_RECORD_LIST_TOO_LARGE = 18,\n  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS = 19,\n  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS_AFTER_APPEND = 20,\n  RD_KAFKA_RESP_ERR_INVALID_REQUIRED_ACKS = 21,\n  RD_KAFKA_RESP_ERR_ILLEGAL_GENERATION = 22,\n  RD_KAFKA_RESP_ERR_INCONSISTENT_GROUP_PROTOCOL = 23,\n  RD_KAFKA_RESP_ERR_INVALID_GROUP_ID = 24,\n  RD_KAFKA_RESP_ERR_UNKNOWN_MEMBER_ID = 25,\n  RD_KAFKA_RESP_ERR_INVALID_SESSION_TIMEOUT = 26,\n  RD_KAFKA_RESP_ERR_REBALANCE_IN_PROGRESS = 27,\n  RD_KAFKA_RESP_ERR_INVALID_COMMIT_OFFSET_SIZE = 28,\n  RD_KAFKA_RESP_ERR_TOPIC_AUTHORIZATION_FAILED = 29,\n  RD_KAFKA_RESP_ERR_GROUP_AUTHORIZATION_FAILED = 30,\n  RD_KAFKA_RESP_ERR_CLUSTER_AUTHORIZATION_FAILED = 31,\n  RD_KAFKA_RESP_ERR_INVALID_TIMESTAMP = 32,\n  RD_KAFKA_RESP_ERR_UNSUPPORTED_SASL_MECHANISM = 33,\n  RD_KAFKA_RESP_ERR_ILLEGAL_SASL_STATE = 34,\n  RD_KAFKA_RESP_ERR_UNSUPPORTED_VERSION = 35,\n  RD_KAFKA_RESP_ERR_TOPIC_ALREADY_EXISTS = 36,\n  RD_KAFKA_RESP_ERR_INVALID_PARTITIONS = 37,\n  RD_KAFKA_RESP_ERR_INVALID_REPLICATION_FACTOR = 38,\n  RD_KAFKA_RESP_ERR_INVALID_REPLICA_ASSIGNMENT = 39,\n  RD_KAFKA_RESP_ERR_INVALID_CONFIG = 40,\n  RD_KAFKA_RESP_ERR_NOT_CONTROLLER = 41,\n  RD_KAFKA_RESP_ERR_INVALID_REQUEST = 42,\n  RD_KAFKA_RESP_ERR_UNSUPPORTED_FOR_MESSAGE_FORMAT = 43,\n  RD_KAFKA_RESP_ERR_POLICY_VIOLATION = 44,\n  RD_KAFKA_RESP_ERR_OUT_OF_ORDER_SEQUENCE_NUMBER = 45,\n  RD_KAFKA_RESP_ERR_DUPLICATE_SEQUENCE_NUMBER = 46,\n  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_EPOCH = 47,\n  RD_KAFKA_RESP_ERR_INVALID_TXN_STATE = 48,\n  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_ID_MAPPING = 49,\n  RD_KAFKA_RESP_ERR_INVALID_TRANSACTION_TIMEOUT = 50,\n  RD_KAFKA_RESP_ERR_CONCURRENT_TRANSACTIONS = 51,\n  RD_KAFKA_RESP_ERR_TRANSACTION_COORDINATOR_FENCED = 52,\n  RD_KAFKA_RESP_ERR_TRANSACTIONAL_ID_AUTHORIZATION_FAILED = 53,\n  RD_KAFKA_RESP_ERR_SECURITY_DISABLED = 54,\n  RD_KAFKA_RESP_ERR_OPERATION_NOT_ATTEMPTED = 55,\n  RD_KAFKA_RESP_ERR_KAFKA_STORAGE_ERROR = 56,\n  RD_KAFKA_RESP_ERR_LOG_DIR_NOT_FOUND = 57,\n  RD_KAFKA_RESP_ERR_SASL_AUTHENTICATION_FAILED = 58,\n  RD_KAFKA_RESP_ERR_UNKNOWN_PRODUCER_ID = 59,\n  RD_KAFKA_RESP_ERR_REASSIGNMENT_IN_PROGRESS = 60,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTH_DISABLED = 61,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_NOT_FOUND = 62,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_OWNER_MISMATCH = 63,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_REQUEST_NOT_ALLOWED = 64,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTHORIZATION_FAILED = 65,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_EXPIRED = 66,\n  RD_KAFKA_RESP_ERR_INVALID_PRINCIPAL_TYPE = 67,\n  RD_KAFKA_RESP_ERR_NON_EMPTY_GROUP = 68,\n  RD_KAFKA_RESP_ERR_GROUP_ID_NOT_FOUND = 69,\n  RD_KAFKA_RESP_ERR_FETCH_SESSION_ID_NOT_FOUND = 70,\n  RD_KAFKA_RESP_ERR_INVALID_FETCH_SESSION_EPOCH = 71,\n  RD_KAFKA_RESP_ERR_LISTENER_NOT_FOUND = 72,\n  RD_KAFKA_RESP_ERR_TOPIC_DELETION_DISABLED = 73,\n  RD_KAFKA_RESP_ERR_FENCED_LEADER_EPOCH = 74,\n  RD_KAFKA_RESP_ERR_UNKNOWN_LEADER_EPOCH = 75,\n  RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76,\n  RD_KAFKA_RESP_ERR_STALE_BROKER_EPOCH = 77,\n  RD_KAFKA_RESP_ERR_OFFSET_NOT_AVAILABLE = 78,\n  RD_KAFKA_RESP_ERR_MEMBER_ID_REQUIRED = 79,\n  RD_KAFKA_RESP_ERR_PREFERRED_LEADER_NOT_AVAILABLE = 80,\n  RD_KAFKA_RESP_ERR_GROUP_MAX_SIZE_REACHED = 81,\n  RD_KAFKA_RESP_ERR_FENCED_INSTANCE_ID = 82,\n  RD_KAFKA_RESP_ERR_ELIGIBLE_LEADERS_NOT_AVAILABLE = 83,\n  RD_KAFKA_RESP_ERR_ELECTION_NOT_NEEDED = 84,\n  RD_KAFKA_RESP_ERR_NO_REASSIGNMENT_IN_PROGRESS = 85,\n  RD_KAFKA_RESP_ERR_GROUP_SUBSCRIBED_TO_TOPIC = 86,\n  RD_KAFKA_RESP_ERR_INVALID_RECORD = 87,\n  RD_KAFKA_RESP_ERR_UNSTABLE_OFFSET_COMMIT = 88,\n  RD_KAFKA_RESP_ERR_THROTTLING_QUOTA_EXCEEDED = 89,\n  RD_KAFKA_RESP_ERR_PRODUCER_FENCED = 90,\n  RD_KAFKA_RESP_ERR_RESOURCE_NOT_FOUND = 91,\n  RD_KAFKA_RESP_ERR_DUPLICATE_RESOURCE = 92,\n  RD_KAFKA_RESP_ERR_UNACCEPTABLE_CREDENTIAL = 93,\n  RD_KAFKA_RESP_ERR_INCONSISTENT_VOTER_SET = 94,\n  RD_KAFKA_RESP_ERR_INVALID_UPDATE_VERSION = 95,\n  RD_KAFKA_RESP_ERR_FEATURE_UPDATE_FAILED = 96,\n  RD_KAFKA_RESP_ERR_PRINCIPAL_DESERIALIZATION_FAILURE = 97,\n  RD_KAFKA_RESP_ERR_END_ALL,\n} rd_kafka_resp_err_t;\nstruct rd_kafka_err_desc {\n  rd_kafka_resp_err_t code;\n  char *name;\n  char *desc;\n};\nvoid rd_kafka_get_err_descs(const struct rd_kafka_err_desc **errdescs, size_t *cntp);\nconst char *rd_kafka_err2str(rd_kafka_resp_err_t err);\nconst char *rd_kafka_err2name(rd_kafka_resp_err_t err);\nrd_kafka_resp_err_t rd_kafka_last_error(void);\nrd_kafka_resp_err_t rd_kafka_errno2err(int errnox);\nint rd_kafka_errno(void);\nrd_kafka_resp_err_t rd_kafka_fatal_error(rd_kafka_t *rk, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_test_fatal_error(rd_kafka_t *rk, rd_kafka_resp_err_t err, const char *reason);\nrd_kafka_resp_err_t rd_kafka_error_code(const rd_kafka_error_t *error);\nconst char *rd_kafka_error_name(const rd_kafka_error_t *error);\nconst char *rd_kafka_error_string(const rd_kafka_error_t *error);\nint rd_kafka_error_is_fatal(const rd_kafka_error_t *error);\nint rd_kafka_error_is_retriable(const rd_kafka_error_t *error);\nint rd_kafka_error_txn_requires_abort(const rd_kafka_error_t *error);\nvoid rd_kafka_error_destroy(rd_kafka_error_t *error);\nrd_kafka_error_t *rd_kafka_error_new(rd_kafka_resp_err_t code, const char *fmt, ...);\ntypedef struct rd_kafka_topic_partition_s {\n  char *topic;\n  int32_t partition;\n  int64_t offset;\n  void *metadata;\n  size_t metadata_size;\n  void *opaque;\n  rd_kafka_resp_err_t err;\n  void *_private;\n} rd_kafka_topic_partition_t;\nvoid rd_kafka_topic_partition_destroy(rd_kafka_topic_partition_t *rktpar);\ntypedef struct rd_kafka_topic_partition_list_s {\n  int cnt;\n  int size;\n  rd_kafka_topic_partition_t *elems;\n} rd_kafka_topic_partition_list_t;\nrd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_new(int size);\nvoid rd_kafka_topic_partition_list_destroy(rd_kafka_topic_partition_list_t *rkparlist);\nrd_kafka_topic_partition_t *rd_kafka_topic_partition_list_add(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);\nvoid rd_kafka_topic_partition_list_add_range(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t start, int32_t stop);\nint rd_kafka_topic_partition_list_del(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);\nint rd_kafka_topic_partition_list_del_by_idx(rd_kafka_topic_partition_list_t *rktparlist, int idx);\nrd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_copy(const rd_kafka_topic_partition_list_t *src);\nrd_kafka_resp_err_t rd_kafka_topic_partition_list_set_offset(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition, int64_t offset);\nrd_kafka_topic_partition_t *rd_kafka_topic_partition_list_find(const rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);\nvoid rd_kafka_topic_partition_list_sort(rd_kafka_topic_partition_list_t *rktparlist, int (*cmp)(const void *a, const void *b, void *cmp_opaque), void *cmp_opaque);\ntypedef enum rd_kafka_vtype_t {\n  RD_KAFKA_VTYPE_END,\n  RD_KAFKA_VTYPE_TOPIC,\n  RD_KAFKA_VTYPE_RKT,\n  RD_KAFKA_VTYPE_PARTITION,\n  RD_KAFKA_VTYPE_VALUE,\n  RD_KAFKA_VTYPE_KEY,\n  RD_KAFKA_VTYPE_OPAQUE,\n  RD_KAFKA_VTYPE_MSGFLAGS,\n  RD_KAFKA_VTYPE_TIMESTAMP,\n  RD_KAFKA_VTYPE_HEADER,\n  RD_KAFKA_VTYPE_HEADERS,\n} rd_kafka_vtype_t;\ntypedef struct rd_kafka_vu_s {\n  rd_kafka_vtype_t vtype;\n  union {\n    char *cstr;\n    rd_kafka_topic_t *rkt;\n    int i;\n    int32_t i32;\n    int64_t i64;\n    struct {\n      void *ptr;\n      size_t size;\n    } mem;\n    struct {\n      char *name;\n      void *val;\n      ssize_t size;\n    } header;\n    rd_kafka_headers_t *headers;\n    void *ptr;\n    char _pad[64];\n  } u;\n} rd_kafka_vu_t;\nrd_kafka_headers_t *rd_kafka_headers_new(size_t initial_count);\nvoid rd_kafka_headers_destroy(rd_kafka_headers_t *hdrs);\nrd_kafka_headers_t *rd_kafka_headers_copy(const rd_kafka_headers_t *src);\nrd_kafka_resp_err_t rd_kafka_header_add(rd_kafka_headers_t *hdrs, const char *name, ssize_t name_size, const void *value, ssize_t value_size);\nrd_kafka_resp_err_t rd_kafka_header_remove(rd_kafka_headers_t *hdrs, const char *name);\nrd_kafka_resp_err_t rd_kafka_header_get_last(const rd_kafka_headers_t *hdrs, const char *name, const void **valuep, size_t *sizep);\nrd_kafka_resp_err_t rd_kafka_header_get(const rd_kafka_headers_t *hdrs, size_t idx, const char *name, const void **valuep, size_t *sizep);\nrd_kafka_resp_err_t rd_kafka_header_get_all(const rd_kafka_headers_t *hdrs, size_t idx, const char **namep, const void **valuep, size_t *sizep);\ntypedef struct rd_kafka_message_s {\n  rd_kafka_resp_err_t err;\n  rd_kafka_topic_t *rkt;\n  int32_t partition;\n  void *payload;\n  size_t len;\n  void *key;\n  size_t key_len;\n  int64_t offset;\n  void *_private;\n} rd_kafka_message_t;\nvoid rd_kafka_message_destroy(rd_kafka_message_t *rkmessage);\nconst char *rd_kafka_message_errstr(const rd_kafka_message_t *rkmessage);\nint64_t rd_kafka_message_timestamp(const rd_kafka_message_t *rkmessage, rd_kafka_timestamp_type_t *tstype);\nint64_t rd_kafka_message_latency(const rd_kafka_message_t *rkmessage);\nint32_t rd_kafka_message_broker_id(const rd_kafka_message_t *rkmessage);\nrd_kafka_resp_err_t rd_kafka_message_headers(const rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);\nrd_kafka_resp_err_t rd_kafka_message_detach_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);\nvoid rd_kafka_message_set_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t *hdrs);\nsize_t rd_kafka_header_cnt(const rd_kafka_headers_t *hdrs);\ntypedef enum {\n  RD_KAFKA_MSG_STATUS_NOT_PERSISTED = 0,\n  RD_KAFKA_MSG_STATUS_POSSIBLY_PERSISTED = 1,\n  RD_KAFKA_MSG_STATUS_PERSISTED = 2,\n} rd_kafka_msg_status_t;\nrd_kafka_msg_status_t rd_kafka_message_status(const rd_kafka_message_t *rkmessage);\ntypedef enum {\n  RD_KAFKA_CONF_UNKNOWN = (- 2),\n  RD_KAFKA_CONF_INVALID = (- 1),\n  RD_KAFKA_CONF_OK = 0,\n} rd_kafka_conf_res_t;\nrd_kafka_conf_t *rd_kafka_conf_new(void);\nvoid rd_kafka_conf_destroy(rd_kafka_conf_t *conf);\nrd_kafka_conf_t *rd_kafka_conf_dup(const rd_kafka_conf_t *conf);\nrd_kafka_conf_t *rd_kafka_conf_dup_filter(const rd_kafka_conf_t *conf, size_t filter_cnt, const char **filter);\nconst rd_kafka_conf_t *rd_kafka_conf(rd_kafka_t *rk);\nrd_kafka_conf_res_t rd_kafka_conf_set(rd_kafka_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);\nvoid rd_kafka_conf_set_events(rd_kafka_conf_t *conf, int events);\nvoid rd_kafka_conf_set_background_event_cb(rd_kafka_conf_t *conf, void (*event_cb)(rd_kafka_t *rk, rd_kafka_event_t *rkev, void *opaque));\nvoid rd_kafka_conf_set_dr_cb(rd_kafka_conf_t *conf, void (*dr_cb)(rd_kafka_t *rk, void *payload, size_t len, rd_kafka_resp_err_t err, void *opaque, void *msg_opaque));\nvoid rd_kafka_conf_set_dr_msg_cb(rd_kafka_conf_t *conf, void (*dr_msg_cb)(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, void *opaque));\nvoid rd_kafka_conf_set_consume_cb(rd_kafka_conf_t *conf, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *opaque));\nvoid rd_kafka_conf_set_rebalance_cb(rd_kafka_conf_t *conf, void (*rebalance_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *partitions, void *opaque));\nvoid rd_kafka_conf_set_offset_commit_cb(rd_kafka_conf_t *conf, void (*offset_commit_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *opaque));\nvoid rd_kafka_conf_set_error_cb(rd_kafka_conf_t *conf, void (*error_cb)(rd_kafka_t *rk, int err, const char *reason, void *opaque));\nvoid rd_kafka_conf_set_throttle_cb(rd_kafka_conf_t *conf, void (*throttle_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int throttle_time_ms, void *opaque));\nvoid rd_kafka_conf_set_log_cb(rd_kafka_conf_t *conf, void (*log_cb)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));\nvoid rd_kafka_conf_set_stats_cb(rd_kafka_conf_t *conf, int (*stats_cb)(rd_kafka_t *rk, char *json, size_t json_len, void *opaque));\nvoid rd_kafka_conf_set_oauthbearer_token_refresh_cb(rd_kafka_conf_t *conf, void (*oauthbearer_token_refresh_cb)(rd_kafka_t *rk, const char *oauthbearer_config, void *opaque));\nvoid rd_kafka_conf_enable_sasl_queue(rd_kafka_conf_t *conf, int enable);\nvoid rd_kafka_conf_set_socket_cb(rd_kafka_conf_t *conf, int (*socket_cb)(int domain, int type, int protocol, void *opaque));\nvoid rd_kafka_conf_set_connect_cb(rd_kafka_conf_t *conf, int (*connect_cb)(int sockfd, const struct sockaddr *addr, int addrlen, const char *id, void *opaque));\nvoid rd_kafka_conf_set_closesocket_cb(rd_kafka_conf_t *conf, int (*closesocket_cb)(int sockfd, void *opaque));\nstruct addrinfo;\nvoid rd_kafka_conf_set_resolve_cb(rd_kafka_conf_t *conf, int (*resolve_cb)(const char *node, const char *service, const struct addrinfo *hints, struct addrinfo **res, void *opaque));\nrd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert_verify_cb(rd_kafka_conf_t *conf, int (*ssl_cert_verify_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int *x509_error, int depth, const char *buf, size_t size, char *errstr, size_t errstr_size, void *opaque));\ntypedef enum rd_kafka_cert_type_t {\n  RD_KAFKA_CERT_PUBLIC_KEY,\n  RD_KAFKA_CERT_PRIVATE_KEY,\n  RD_KAFKA_CERT_CA,\n  RD_KAFKA_CERT__CNT,\n} rd_kafka_cert_type_t;\ntypedef enum rd_kafka_cert_enc_t {\n  RD_KAFKA_CERT_ENC_PKCS12,\n  RD_KAFKA_CERT_ENC_DER,\n  RD_KAFKA_CERT_ENC_PEM,\n  RD_KAFKA_CERT_ENC__CNT,\n} rd_kafka_cert_enc_t;\nrd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert(rd_kafka_conf_t *conf, rd_kafka_cert_type_t cert_type, rd_kafka_cert_enc_t cert_enc, const void *buffer, size_t size, char *errstr, size_t errstr_size);\nvoid rd_kafka_conf_set_engine_callback_data(rd_kafka_conf_t *conf, void *callback_data);\nvoid rd_kafka_conf_set_opaque(rd_kafka_conf_t *conf, void *opaque);\nvoid *rd_kafka_opaque(const rd_kafka_t *rk);\nvoid rd_kafka_conf_set_default_topic_conf(rd_kafka_conf_t *conf, rd_kafka_topic_conf_t *tconf);\nrd_kafka_topic_conf_t *rd_kafka_conf_get_default_topic_conf(rd_kafka_conf_t *conf);\nrd_kafka_conf_res_t rd_kafka_conf_get(const rd_kafka_conf_t *conf, const char *name, char *dest, size_t *dest_size);\nrd_kafka_conf_res_t rd_kafka_topic_conf_get(const rd_kafka_topic_conf_t *conf, const char *name, char *dest, size_t *dest_size);\nconst char **rd_kafka_conf_dump(rd_kafka_conf_t *conf, size_t *cntp);\nconst char **rd_kafka_topic_conf_dump(rd_kafka_topic_conf_t *conf, size_t *cntp);\nvoid rd_kafka_conf_dump_free(const char **arr, size_t cnt);\nvoid rd_kafka_conf_properties_show(FILE *fp);\nrd_kafka_topic_conf_t *rd_kafka_topic_conf_new(void);\nrd_kafka_topic_conf_t *rd_kafka_topic_conf_dup(const rd_kafka_topic_conf_t *conf);\nrd_kafka_topic_conf_t *rd_kafka_default_topic_conf_dup(rd_kafka_t *rk);\nvoid rd_kafka_topic_conf_destroy(rd_kafka_topic_conf_t *topic_conf);\nrd_kafka_conf_res_t rd_kafka_topic_conf_set(rd_kafka_topic_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);\nvoid rd_kafka_topic_conf_set_opaque(rd_kafka_topic_conf_t *conf, void *rkt_opaque);\nvoid rd_kafka_topic_conf_set_partitioner_cb(rd_kafka_topic_conf_t *topic_conf, int32_t (*partitioner)(const rd_kafka_topic_t *rkt, const void *keydata, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque));\nvoid rd_kafka_topic_conf_set_msg_order_cmp(rd_kafka_topic_conf_t *topic_conf, int (*msg_order_cmp)(const rd_kafka_message_t *a, const rd_kafka_message_t *b));\nint rd_kafka_topic_partition_available(const rd_kafka_topic_t *rkt, int32_t partition);\nint32_t rd_kafka_msg_partitioner_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_consistent(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_consistent_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_murmur2(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_murmur2_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_fnv1a(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_fnv1a_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nrd_kafka_t *rd_kafka_new(rd_kafka_type_t type, rd_kafka_conf_t *conf, char *errstr, size_t errstr_size);\nvoid rd_kafka_destroy(rd_kafka_t *rk);\nvoid rd_kafka_destroy_flags(rd_kafka_t *rk, int flags);\nconst char *rd_kafka_name(const rd_kafka_t *rk);\nrd_kafka_type_t rd_kafka_type(const rd_kafka_t *rk);\nchar *rd_kafka_memberid(const rd_kafka_t *rk);\nchar *rd_kafka_clusterid(rd_kafka_t *rk, int timeout_ms);\nint32_t rd_kafka_controllerid(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_topic_t *rd_kafka_topic_new(rd_kafka_t *rk, const char *topic, rd_kafka_topic_conf_t *conf);\nvoid rd_kafka_topic_destroy(rd_kafka_topic_t *rkt);\nconst char *rd_kafka_topic_name(const rd_kafka_topic_t *rkt);\nvoid *rd_kafka_topic_opaque(const rd_kafka_topic_t *rkt);\nint rd_kafka_poll(rd_kafka_t *rk, int timeout_ms);\nvoid rd_kafka_yield(rd_kafka_t *rk);\nrd_kafka_resp_err_t rd_kafka_pause_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_resp_err_t rd_kafka_resume_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_resp_err_t rd_kafka_query_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high, int timeout_ms);\nrd_kafka_resp_err_t rd_kafka_get_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high);\nrd_kafka_resp_err_t rd_kafka_offsets_for_times(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets, int timeout_ms);\nvoid *rd_kafka_mem_calloc(rd_kafka_t *rk, size_t num, size_t size);\nvoid *rd_kafka_mem_malloc(rd_kafka_t *rk, size_t size);\nvoid rd_kafka_mem_free(rd_kafka_t *rk, void *ptr);\nrd_kafka_queue_t *rd_kafka_queue_new(rd_kafka_t *rk);\nvoid rd_kafka_queue_destroy(rd_kafka_queue_t *rkqu);\nrd_kafka_queue_t *rd_kafka_queue_get_main(rd_kafka_t *rk);\nrd_kafka_queue_t *rd_kafka_queue_get_sasl(rd_kafka_t *rk);\nrd_kafka_error_t *rd_kafka_sasl_background_callbacks_enable(rd_kafka_t *rk);\nrd_kafka_error_t *rd_kafka_sasl_set_credentials(rd_kafka_t *rk, const char *username, const char *password);\nrd_kafka_queue_t *rd_kafka_queue_get_consumer(rd_kafka_t *rk);\nrd_kafka_queue_t *rd_kafka_queue_get_partition(rd_kafka_t *rk, const char *topic, int32_t partition);\nrd_kafka_queue_t *rd_kafka_queue_get_background(rd_kafka_t *rk);\nvoid rd_kafka_queue_forward(rd_kafka_queue_t *src, rd_kafka_queue_t *dst);\nrd_kafka_resp_err_t rd_kafka_set_log_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu);\nsize_t rd_kafka_queue_length(rd_kafka_queue_t *rkqu);\nvoid rd_kafka_queue_io_event_enable(rd_kafka_queue_t *rkqu, int fd, const void *payload, size_t size);\nvoid rd_kafka_queue_cb_event_enable(rd_kafka_queue_t *rkqu, void (*event_cb)(rd_kafka_t *rk, void *qev_opaque), void *qev_opaque);\nvoid rd_kafka_queue_yield(rd_kafka_queue_t *rkqu);\nint rd_kafka_consume_start(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);\nint rd_kafka_consume_start_queue(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, rd_kafka_queue_t *rkqu);\nint rd_kafka_consume_stop(rd_kafka_topic_t *rkt, int32_t partition);\nrd_kafka_resp_err_t rd_kafka_seek(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, int timeout_ms);\nrd_kafka_error_t *rd_kafka_seek_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms);\nrd_kafka_message_t *rd_kafka_consume(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms);\nssize_t rd_kafka_consume_batch(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);\nint rd_kafka_consume_callback(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);\nrd_kafka_message_t *rd_kafka_consume_queue(rd_kafka_queue_t *rkqu, int timeout_ms);\nssize_t rd_kafka_consume_batch_queue(rd_kafka_queue_t *rkqu, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);\nint rd_kafka_consume_callback_queue(rd_kafka_queue_t *rkqu, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);\nrd_kafka_resp_err_t rd_kafka_offset_store(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);\nrd_kafka_resp_err_t rd_kafka_offsets_store(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets);\nrd_kafka_resp_err_t rd_kafka_subscribe(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *topics);\nrd_kafka_resp_err_t rd_kafka_unsubscribe(rd_kafka_t *rk);\nrd_kafka_resp_err_t rd_kafka_subscription(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **topics);\nrd_kafka_message_t *rd_kafka_consumer_poll(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_resp_err_t rd_kafka_consumer_close(rd_kafka_t *rk);\nrd_kafka_error_t *rd_kafka_consumer_close_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu);\nint rd_kafka_consumer_closed(rd_kafka_t *rk);\nrd_kafka_error_t *rd_kafka_incremental_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_error_t *rd_kafka_incremental_unassign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);\nconst char *rd_kafka_rebalance_protocol(rd_kafka_t *rk);\nrd_kafka_resp_err_t rd_kafka_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_resp_err_t rd_kafka_assignment(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **partitions);\nint rd_kafka_assignment_lost(rd_kafka_t *rk);\nrd_kafka_resp_err_t rd_kafka_commit(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, int async);\nrd_kafka_resp_err_t rd_kafka_commit_message(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, int async);\nrd_kafka_resp_err_t rd_kafka_commit_queue(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_queue_t *rkqu, void (*cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *commit_opaque), void *commit_opaque);\nrd_kafka_resp_err_t rd_kafka_committed(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms);\nrd_kafka_resp_err_t rd_kafka_position(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata(rd_kafka_t *rk);\nrd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata_new(const char *group_id);\nrd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata_new_with_genid(const char *group_id, int32_t generation_id, const char *member_id, const char *group_instance_id);\nvoid rd_kafka_consumer_group_metadata_destroy(rd_kafka_consumer_group_metadata_t *);\nrd_kafka_error_t *rd_kafka_consumer_group_metadata_write(const rd_kafka_consumer_group_metadata_t *cgmd, void **bufferp, size_t *sizep);\nrd_kafka_error_t *rd_kafka_consumer_group_metadata_read(rd_kafka_consumer_group_metadata_t **cgmdp, const void *buffer, size_t size);\nint rd_kafka_produce(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, void *payload, size_t len, const void *key, size_t keylen, void *msg_opaque);\nrd_kafka_resp_err_t rd_kafka_producev(rd_kafka_t *rk, ...);\nrd_kafka_error_t *rd_kafka_produceva(rd_kafka_t *rk, const rd_kafka_vu_t *vus, size_t cnt);\nint rd_kafka_produce_batch(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, rd_kafka_message_t *rkmessages, int message_cnt);\nrd_kafka_resp_err_t rd_kafka_flush(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_resp_err_t rd_kafka_purge(rd_kafka_t *rk, int purge_flags);\ntypedef struct rd_kafka_metadata_broker {\n  int32_t id;\n  char *host;\n  int port;\n} rd_kafka_metadata_broker_t;\ntypedef struct rd_kafka_metadata_partition {\n  int32_t id;\n  rd_kafka_resp_err_t err;\n  int32_t leader;\n  int replica_cnt;\n  int32_t *replicas;\n  int isr_cnt;\n  int32_t *isrs;\n} rd_kafka_metadata_partition_t;\ntypedef struct rd_kafka_metadata_topic {\n  char *topic;\n  int partition_cnt;\n  struct rd_kafka_metadata_partition *partitions;\n  rd_kafka_resp_err_t err;\n} rd_kafka_metadata_topic_t;\ntypedef struct rd_kafka_metadata {\n  int broker_cnt;\n  struct rd_kafka_metadata_broker *brokers;\n  int topic_cnt;\n  struct rd_kafka_metadata_topic *topics;\n  int32_t orig_broker_id;\n  char *orig_broker_name;\n} rd_kafka_metadata_t;\nrd_kafka_resp_err_t rd_kafka_metadata(rd_kafka_t *rk, int all_topics, rd_kafka_topic_t *only_rkt, const struct rd_kafka_metadata **metadatap, int timeout_ms);\nvoid rd_kafka_metadata_destroy(const struct rd_kafka_metadata *metadata);\ntypedef struct rd_kafka_Node_s rd_kafka_Node_t;\nint rd_kafka_Node_id(const rd_kafka_Node_t *node);\nconst char *rd_kafka_Node_host(const rd_kafka_Node_t *node);\nuint16_t rd_kafka_Node_port(const rd_kafka_Node_t *node);\nstruct rd_kafka_group_member_info {\n  char *member_id;\n  char *client_id;\n  char *client_host;\n  void *member_metadata;\n  int member_metadata_size;\n  void *member_assignment;\n  int member_assignment_size;\n};\ntypedef enum {\n  RD_KAFKA_CONSUMER_GROUP_STATE_UNKNOWN = 0,\n  RD_KAFKA_CONSUMER_GROUP_STATE_PREPARING_REBALANCE = 1,\n  RD_KAFKA_CONSUMER_GROUP_STATE_COMPLETING_REBALANCE = 2,\n  RD_KAFKA_CONSUMER_GROUP_STATE_STABLE = 3,\n  RD_KAFKA_CONSUMER_GROUP_STATE_DEAD = 4,\n  RD_KAFKA_CONSUMER_GROUP_STATE_EMPTY = 5,\n  RD_KAFKA_CONSUMER_GROUP_STATE__CNT,\n} rd_kafka_consumer_group_state_t;\nstruct rd_kafka_group_info {\n  struct rd_kafka_metadata_broker broker;\n  char *group;\n  rd_kafka_resp_err_t err;\n  char *state;\n  char *protocol_type;\n  char *protocol;\n  struct rd_kafka_group_member_info *members;\n  int member_cnt;\n};\nstruct rd_kafka_group_list {\n  struct rd_kafka_group_info *groups;\n  int group_cnt;\n};\nrd_kafka_resp_err_t rd_kafka_list_groups(rd_kafka_t *rk, const char *group, const struct rd_kafka_group_list **grplistp, int timeout_ms);\nconst char *rd_kafka_consumer_group_state_name(rd_kafka_consumer_group_state_t state);\nrd_kafka_consumer_group_state_t rd_kafka_consumer_group_state_code(const char *name);\nvoid rd_kafka_group_list_destroy(const struct rd_kafka_group_list *grplist);\nint rd_kafka_brokers_add(rd_kafka_t *rk, const char *brokerlist);\nvoid rd_kafka_set_logger(rd_kafka_t *rk, void (*func)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));\nvoid rd_kafka_set_log_level(rd_kafka_t *rk, int level);\nvoid rd_kafka_log_print(const rd_kafka_t *rk, int level, const char *fac, const char *buf);\nvoid rd_kafka_log_syslog(const rd_kafka_t *rk, int level, const char *fac, const char *buf);\nint rd_kafka_outq_len(rd_kafka_t *rk);\nvoid rd_kafka_dump(FILE *fp, rd_kafka_t *rk);\nint rd_kafka_thread_cnt(void);\ntypedef enum rd_kafka_thread_type_t {\n  RD_KAFKA_THREAD_MAIN,\n  RD_KAFKA_THREAD_BACKGROUND,\n  RD_KAFKA_THREAD_BROKER,\n} rd_kafka_thread_type_t;\nint rd_kafka_wait_destroyed(int timeout_ms);\nint rd_kafka_unittest(void);\nrd_kafka_resp_err_t rd_kafka_poll_set_consumer(rd_kafka_t *rk);\ntypedef int rd_kafka_event_type_t;\nrd_kafka_event_type_t rd_kafka_event_type(const rd_kafka_event_t *rkev);\nconst char *rd_kafka_event_name(const rd_kafka_event_t *rkev);\nvoid rd_kafka_event_destroy(rd_kafka_event_t *rkev);\nconst rd_kafka_message_t *rd_kafka_event_message_next(rd_kafka_event_t *rkev);\nsize_t rd_kafka_event_message_array(rd_kafka_event_t *rkev, const rd_kafka_message_t **rkmessages, size_t size);\nsize_t rd_kafka_event_message_count(rd_kafka_event_t *rkev);\nconst char *rd_kafka_event_config_string(rd_kafka_event_t *rkev);\nrd_kafka_resp_err_t rd_kafka_event_error(rd_kafka_event_t *rkev);\nconst char *rd_kafka_event_error_string(rd_kafka_event_t *rkev);\nint rd_kafka_event_error_is_fatal(rd_kafka_event_t *rkev);\nvoid *rd_kafka_event_opaque(rd_kafka_event_t *rkev);\nint rd_kafka_event_log(rd_kafka_event_t *rkev, const char **fac, const char **str, int *level);\nint rd_kafka_event_debug_contexts(rd_kafka_event_t *rkev, char *dst, size_t dstsize);\nconst char *rd_kafka_event_stats(rd_kafka_event_t *rkev);\nrd_kafka_topic_partition_list_t *rd_kafka_event_topic_partition_list(rd_kafka_event_t *rkev);\nrd_kafka_topic_partition_t *rd_kafka_event_topic_partition(rd_kafka_event_t *rkev);\ntypedef rd_kafka_event_t rd_kafka_CreateTopics_result_t;\ntypedef rd_kafka_event_t rd_kafka_DeleteTopics_result_t;\ntypedef rd_kafka_event_t rd_kafka_CreateAcls_result_t;\ntypedef rd_kafka_event_t rd_kafka_DescribeAcls_result_t;\ntypedef rd_kafka_event_t rd_kafka_DeleteAcls_result_t;\ntypedef rd_kafka_event_t rd_kafka_CreatePartitions_result_t;\ntypedef rd_kafka_event_t rd_kafka_AlterConfigs_result_t;\ntypedef rd_kafka_event_t rd_kafka_DescribeConfigs_result_t;\ntypedef rd_kafka_event_t rd_kafka_DeleteRecords_result_t;\ntypedef rd_kafka_event_t rd_kafka_ListConsumerGroups_result_t;\ntypedef rd_kafka_event_t rd_kafka_DescribeConsumerGroups_result_t;\ntypedef rd_kafka_event_t rd_kafka_DeleteGroups_result_t;\ntypedef rd_kafka_event_t rd_kafka_DeleteConsumerGroupOffsets_result_t;\ntypedef rd_kafka_event_t rd_kafka_AlterConsumerGroupOffsets_result_t;\ntypedef rd_kafka_event_t rd_kafka_ListConsumerGroupOffsets_result_t;\nconst rd_kafka_CreateTopics_result_t *rd_kafka_event_CreateTopics_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DeleteTopics_result_t *rd_kafka_event_DeleteTopics_result(rd_kafka_event_t *rkev);\nconst rd_kafka_CreatePartitions_result_t *rd_kafka_event_CreatePartitions_result(rd_kafka_event_t *rkev);\nconst rd_kafka_AlterConfigs_result_t *rd_kafka_event_AlterConfigs_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DescribeConfigs_result_t *rd_kafka_event_DescribeConfigs_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DeleteRecords_result_t *rd_kafka_event_DeleteRecords_result(rd_kafka_event_t *rkev);\nconst rd_kafka_ListConsumerGroups_result_t *rd_kafka_event_ListConsumerGroups_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DescribeConsumerGroups_result_t *rd_kafka_event_DescribeConsumerGroups_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DeleteGroups_result_t *rd_kafka_event_DeleteGroups_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DeleteConsumerGroupOffsets_result_t *rd_kafka_event_DeleteConsumerGroupOffsets_result(rd_kafka_event_t *rkev);\nconst rd_kafka_CreateAcls_result_t *rd_kafka_event_CreateAcls_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DescribeAcls_result_t *rd_kafka_event_DescribeAcls_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DeleteAcls_result_t *rd_kafka_event_DeleteAcls_result(rd_kafka_event_t *rkev);\nconst rd_kafka_AlterConsumerGroupOffsets_result_t *rd_kafka_event_AlterConsumerGroupOffsets_result(rd_kafka_event_t *rkev);\nconst rd_kafka_ListConsumerGroupOffsets_result_t *rd_kafka_event_ListConsumerGroupOffsets_result(rd_kafka_event_t *rkev);\nrd_kafka_event_t *rd_kafka_queue_poll(rd_kafka_queue_t *rkqu, int timeout_ms);\nint rd_kafka_queue_poll_callback(rd_kafka_queue_t *rkqu, int timeout_ms);\ntypedef rd_kafka_resp_err_t (rd_kafka_plugin_f_conf_init_t)(rd_kafka_conf_t *conf, void **plug_opaquep, char *errstr, size_t errstr_size);\ntypedef rd_kafka_conf_res_t (rd_kafka_interceptor_f_on_conf_set_t)(rd_kafka_conf_t *conf, const char *name, const char *val, char *errstr, size_t errstr_size, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_dup_t)(rd_kafka_conf_t *new_conf, const rd_kafka_conf_t *old_conf, size_t filter_cnt, const char **filter, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_destroy_t)(void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_new_t)(rd_kafka_t *rk, const rd_kafka_conf_t *conf, void *ic_opaque, char *errstr, size_t errstr_size);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_destroy_t)(rd_kafka_t *rk, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_send_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_acknowledgement_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_consume_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_commit_t)(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_resp_err_t err, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_request_sent_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_response_received_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, int64_t rtt, rd_kafka_resp_err_t err, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_start_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_exit_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_broker_state_change_t)(rd_kafka_t *rk, int32_t broker_id, const char *secproto, const char *name, int port, const char *state, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_set(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_set_t *on_conf_set, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_dup(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_dup_t *on_conf_dup, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_destroy(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_destroy_t *on_conf_destroy, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_new(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_new_t *on_new, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_destroy(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_destroy_t *on_destroy, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_send(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_send_t *on_send, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_acknowledgement(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_acknowledgement_t *on_acknowledgement, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_consume(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_consume_t *on_consume, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_commit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_commit_t *on_commit, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_request_sent(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_request_sent_t *on_request_sent, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_response_received(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_response_received_t *on_response_received, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_start(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_start_t *on_thread_start, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_exit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_exit_t *on_thread_exit, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_broker_state_change(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_broker_state_change_t *on_broker_state_change, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_topic_result_error(const rd_kafka_topic_result_t *topicres);\nconst char *rd_kafka_topic_result_error_string(const rd_kafka_topic_result_t *topicres);\nconst char *rd_kafka_topic_result_name(const rd_kafka_topic_result_t *topicres);\nconst rd_kafka_error_t *rd_kafka_group_result_error(const rd_kafka_group_result_t *groupres);\nconst char *rd_kafka_group_result_name(const rd_kafka_group_result_t *groupres);\nconst rd_kafka_topic_partition_list_t *rd_kafka_group_result_partitions(const rd_kafka_group_result_t *groupres);\ntypedef enum rd_kafka_admin_op_t {\n  RD_KAFKA_ADMIN_OP_ANY = 0,\n  RD_KAFKA_ADMIN_OP_CREATETOPICS,\n  RD_KAFKA_ADMIN_OP_DELETETOPICS,\n  RD_KAFKA_ADMIN_OP_CREATEPARTITIONS,\n  RD_KAFKA_ADMIN_OP_ALTERCONFIGS,\n  RD_KAFKA_ADMIN_OP_DESCRIBECONFIGS,\n  RD_KAFKA_ADMIN_OP_DELETERECORDS,\n  RD_KAFKA_ADMIN_OP_DELETEGROUPS,\n  RD_KAFKA_ADMIN_OP_DELETECONSUMERGROUPOFFSETS,\n  RD_KAFKA_ADMIN_OP_CREATEACLS,\n  RD_KAFKA_ADMIN_OP_DESCRIBEACLS,\n  RD_KAFKA_ADMIN_OP_DELETEACLS,\n  RD_KAFKA_ADMIN_OP_LISTCONSUMERGROUPS,\n  RD_KAFKA_ADMIN_OP_DESCRIBECONSUMERGROUPS,\n  RD_KAFKA_ADMIN_OP_LISTCONSUMERGROUPOFFSETS,\n  RD_KAFKA_ADMIN_OP_ALTERCONSUMERGROUPOFFSETS,\n  RD_KAFKA_ADMIN_OP__CNT,\n} rd_kafka_admin_op_t;\ntypedef struct rd_kafka_AdminOptions_s rd_kafka_AdminOptions_t;\nrd_kafka_AdminOptions_t *rd_kafka_AdminOptions_new(rd_kafka_t *rk, rd_kafka_admin_op_t for_api);\nvoid rd_kafka_AdminOptions_destroy(rd_kafka_AdminOptions_t *options);\nrd_kafka_resp_err_t rd_kafka_AdminOptions_set_request_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_AdminOptions_set_operation_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_AdminOptions_set_validate_only(rd_kafka_AdminOptions_t *options, int true_or_false, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_AdminOptions_set_broker(rd_kafka_AdminOptions_t *options, int32_t broker_id, char *errstr, size_t errstr_size);\nrd_kafka_error_t *rd_kafka_AdminOptions_set_require_stable_offsets(rd_kafka_AdminOptions_t *options, int true_or_false);\nrd_kafka_error_t *rd_kafka_AdminOptions_set_match_consumer_group_states(rd_kafka_AdminOptions_t *options, const rd_kafka_consumer_group_state_t *consumer_group_states, size_t consumer_group_states_cnt);\nvoid rd_kafka_AdminOptions_set_opaque(rd_kafka_AdminOptions_t *options, void *ev_opaque);\ntypedef struct rd_kafka_NewTopic_s rd_kafka_NewTopic_t;\nrd_kafka_NewTopic_t *rd_kafka_NewTopic_new(const char *topic, int num_partitions, int replication_factor, char *errstr, size_t errstr_size);\nvoid rd_kafka_NewTopic_destroy(rd_kafka_NewTopic_t *new_topic);\nvoid rd_kafka_NewTopic_destroy_array(rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt);\nrd_kafka_resp_err_t rd_kafka_NewTopic_set_replica_assignment(rd_kafka_NewTopic_t *new_topic, int32_t partition, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_NewTopic_set_config(rd_kafka_NewTopic_t *new_topic, const char *name, const char *value);\nvoid rd_kafka_CreateTopics(rd_kafka_t *rk, rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_topic_result_t **rd_kafka_CreateTopics_result_topics(const rd_kafka_CreateTopics_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_DeleteTopic_s rd_kafka_DeleteTopic_t;\nrd_kafka_DeleteTopic_t *rd_kafka_DeleteTopic_new(const char *topic);\nvoid rd_kafka_DeleteTopic_destroy(rd_kafka_DeleteTopic_t *del_topic);\nvoid rd_kafka_DeleteTopic_destroy_array(rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt);\nvoid rd_kafka_DeleteTopics(rd_kafka_t *rk, rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_topic_result_t **rd_kafka_DeleteTopics_result_topics(const rd_kafka_DeleteTopics_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_NewPartitions_s rd_kafka_NewPartitions_t;\nrd_kafka_NewPartitions_t *rd_kafka_NewPartitions_new(const char *topic, size_t new_total_cnt, char *errstr, size_t errstr_size);\nvoid rd_kafka_NewPartitions_destroy(rd_kafka_NewPartitions_t *new_parts);\nvoid rd_kafka_NewPartitions_destroy_array(rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt);\nrd_kafka_resp_err_t rd_kafka_NewPartitions_set_replica_assignment(rd_kafka_NewPartitions_t *new_parts, int32_t new_partition_idx, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);\nvoid rd_kafka_CreatePartitions(rd_kafka_t *rk, rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_topic_result_t **rd_kafka_CreatePartitions_result_topics(const rd_kafka_CreatePartitions_result_t *result, size_t *cntp);\ntypedef enum rd_kafka_ConfigSource_t {\n  RD_KAFKA_CONFIG_SOURCE_UNKNOWN_CONFIG = 0,\n  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_TOPIC_CONFIG = 1,\n  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_BROKER_CONFIG = 2,\n  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_DEFAULT_BROKER_CONFIG = 3,\n  RD_KAFKA_CONFIG_SOURCE_STATIC_BROKER_CONFIG = 4,\n  RD_KAFKA_CONFIG_SOURCE_DEFAULT_CONFIG = 5,\n  RD_KAFKA_CONFIG_SOURCE__CNT,\n} rd_kafka_ConfigSource_t;\nconst char *rd_kafka_ConfigSource_name(rd_kafka_ConfigSource_t confsource);\ntypedef struct rd_kafka_ConfigEntry_s rd_kafka_ConfigEntry_t;\nconst char *rd_kafka_ConfigEntry_name(const rd_kafka_ConfigEntry_t *entry);\nconst char *rd_kafka_ConfigEntry_value(const rd_kafka_ConfigEntry_t *entry);\nrd_kafka_ConfigSource_t rd_kafka_ConfigEntry_source(const rd_kafka_ConfigEntry_t *entry);\nint rd_kafka_ConfigEntry_is_read_only(const rd_kafka_ConfigEntry_t *entry);\nint rd_kafka_ConfigEntry_is_default(const rd_kafka_ConfigEntry_t *entry);\nint rd_kafka_ConfigEntry_is_sensitive(const rd_kafka_ConfigEntry_t *entry);\nint rd_kafka_ConfigEntry_is_synonym(const rd_kafka_ConfigEntry_t *entry);\nconst rd_kafka_ConfigEntry_t **rd_kafka_ConfigEntry_synonyms(const rd_kafka_ConfigEntry_t *entry, size_t *cntp);\ntypedef enum rd_kafka_ResourceType_t {\n  RD_KAFKA_RESOURCE_UNKNOWN = 0,\n  RD_KAFKA_RESOURCE_ANY = 1,\n  RD_KAFKA_RESOURCE_TOPIC = 2,\n  RD_KAFKA_RESOURCE_GROUP = 3,\n  RD_KAFKA_RESOURCE_BROKER = 4,\n  RD_KAFKA_RESOURCE__CNT,\n} rd_kafka_ResourceType_t;\ntypedef enum rd_kafka_ResourcePatternType_t {\n  RD_KAFKA_RESOURCE_PATTERN_UNKNOWN = 0,\n  RD_KAFKA_RESOURCE_PATTERN_ANY = 1,\n  RD_KAFKA_RESOURCE_PATTERN_MATCH = 2,\n  RD_KAFKA_RESOURCE_PATTERN_LITERAL = 3,\n  RD_KAFKA_RESOURCE_PATTERN_PREFIXED = 4,\n  RD_KAFKA_RESOURCE_PATTERN_TYPE__CNT,\n} rd_kafka_ResourcePatternType_t;\nconst char *rd_kafka_ResourcePatternType_name(rd_kafka_ResourcePatternType_t resource_pattern_type);\nconst char *rd_kafka_ResourceType_name(rd_kafka_ResourceType_t restype);\ntypedef struct rd_kafka_ConfigResource_s rd_kafka_ConfigResource_t;\nrd_kafka_ConfigResource_t *rd_kafka_ConfigResource_new(rd_kafka_ResourceType_t restype, const char *resname);\nvoid rd_kafka_ConfigResource_destroy(rd_kafka_ConfigResource_t *config);\nvoid rd_kafka_ConfigResource_destroy_array(rd_kafka_ConfigResource_t **config, size_t config_cnt);\nrd_kafka_resp_err_t rd_kafka_ConfigResource_set_config(rd_kafka_ConfigResource_t *config, const char *name, const char *value);\nconst rd_kafka_ConfigEntry_t **rd_kafka_ConfigResource_configs(const rd_kafka_ConfigResource_t *config, size_t *cntp);\nrd_kafka_ResourceType_t rd_kafka_ConfigResource_type(const rd_kafka_ConfigResource_t *config);\nconst char *rd_kafka_ConfigResource_name(const rd_kafka_ConfigResource_t *config);\nrd_kafka_resp_err_t rd_kafka_ConfigResource_error(const rd_kafka_ConfigResource_t *config);\nconst char *rd_kafka_ConfigResource_error_string(const rd_kafka_ConfigResource_t *config);\nvoid rd_kafka_AlterConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_ConfigResource_t **rd_kafka_AlterConfigs_result_resources(const rd_kafka_AlterConfigs_result_t *result, size_t *cntp);\nvoid rd_kafka_DescribeConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_ConfigResource_t **rd_kafka_DescribeConfigs_result_resources(const rd_kafka_DescribeConfigs_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_DeleteRecords_s rd_kafka_DeleteRecords_t;\nrd_kafka_DeleteRecords_t *rd_kafka_DeleteRecords_new(const rd_kafka_topic_partition_list_t *before_offsets);\nvoid rd_kafka_DeleteRecords_destroy(rd_kafka_DeleteRecords_t *del_records);\nvoid rd_kafka_DeleteRecords_destroy_array(rd_kafka_DeleteRecords_t **del_records, size_t del_record_cnt);\nvoid rd_kafka_DeleteRecords(rd_kafka_t *rk, rd_kafka_DeleteRecords_t **del_records, size_t del_record_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_topic_partition_list_t *rd_kafka_DeleteRecords_result_offsets(const rd_kafka_DeleteRecords_result_t *result);\ntypedef struct rd_kafka_ConsumerGroupListing_s rd_kafka_ConsumerGroupListing_t;\ntypedef struct rd_kafka_ListConsumerGroupsResult_s rd_kafka_ListConsumerGroupsResult_t;\nvoid rd_kafka_ListConsumerGroups(rd_kafka_t *rk, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst char *rd_kafka_ConsumerGroupListing_group_id(const rd_kafka_ConsumerGroupListing_t *grplist);\nint rd_kafka_ConsumerGroupListing_is_simple_consumer_group(const rd_kafka_ConsumerGroupListing_t *grplist);\nrd_kafka_consumer_group_state_t rd_kafka_ConsumerGroupListing_state(const rd_kafka_ConsumerGroupListing_t *grplist);\nconst rd_kafka_ConsumerGroupListing_t **rd_kafka_ListConsumerGroups_result_valid(const rd_kafka_ListConsumerGroups_result_t *result, size_t *cntp);\nconst rd_kafka_error_t **rd_kafka_ListConsumerGroups_result_errors(const rd_kafka_ListConsumerGroups_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_ConsumerGroupDescription_s rd_kafka_ConsumerGroupDescription_t;\ntypedef struct rd_kafka_MemberDescription_s rd_kafka_MemberDescription_t;\ntypedef struct rd_kafka_MemberAssignment_s rd_kafka_MemberAssignment_t;\nvoid rd_kafka_DescribeConsumerGroups(rd_kafka_t *rk, const char **groups, size_t groups_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_ConsumerGroupDescription_t **rd_kafka_DescribeConsumerGroups_result_groups(const rd_kafka_DescribeConsumerGroups_result_t *result, size_t *cntp);\nconst char *rd_kafka_ConsumerGroupDescription_group_id(const rd_kafka_ConsumerGroupDescription_t *grpdesc);\nconst rd_kafka_error_t *rd_kafka_ConsumerGroupDescription_error(const rd_kafka_ConsumerGroupDescription_t *grpdesc);\nint rd_kafka_ConsumerGroupDescription_is_simple_consumer_group(const rd_kafka_ConsumerGroupDescription_t *grpdesc);\nconst char *rd_kafka_ConsumerGroupDescription_partition_assignor(const rd_kafka_ConsumerGroupDescription_t *grpdesc);\nrd_kafka_consumer_group_state_t rd_kafka_ConsumerGroupDescription_state(const rd_kafka_ConsumerGroupDescription_t *grpdesc);\nconst rd_kafka_Node_t *rd_kafka_ConsumerGroupDescription_coordinator(const rd_kafka_ConsumerGroupDescription_t *grpdesc);\nsize_t rd_kafka_ConsumerGroupDescription_member_count(const rd_kafka_ConsumerGroupDescription_t *grpdesc);\nconst rd_kafka_MemberDescription_t *rd_kafka_ConsumerGroupDescription_member(const rd_kafka_ConsumerGroupDescription_t *grpdesc, size_t idx);\nconst char *rd_kafka_MemberDescription_client_id(const rd_kafka_MemberDescription_t *member);\nconst char *rd_kafka_MemberDescription_group_instance_id(const rd_kafka_MemberDescription_t *member);\nconst char *rd_kafka_MemberDescription_consumer_id(const rd_kafka_MemberDescription_t *member);\nconst char *rd_kafka_MemberDescription_host(const rd_kafka_MemberDescription_t *member);\nconst rd_kafka_MemberAssignment_t *rd_kafka_MemberDescription_assignment(const rd_kafka_MemberDescription_t *member);\nconst rd_kafka_topic_partition_list_t *rd_kafka_MemberAssignment_partitions(const rd_kafka_MemberAssignment_t *assignment);\ntypedef struct rd_kafka_DeleteGroup_s rd_kafka_DeleteGroup_t;\nrd_kafka_DeleteGroup_t *rd_kafka_DeleteGroup_new(const char *group);\nvoid rd_kafka_DeleteGroup_destroy(rd_kafka_DeleteGroup_t *del_group);\nvoid rd_kafka_DeleteGroup_destroy_array(rd_kafka_DeleteGroup_t **del_groups, size_t del_group_cnt);\nvoid rd_kafka_DeleteGroups(rd_kafka_t *rk, rd_kafka_DeleteGroup_t **del_groups, size_t del_group_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_group_result_t **rd_kafka_DeleteGroups_result_groups(const rd_kafka_DeleteGroups_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_ListConsumerGroupOffsets_s rd_kafka_ListConsumerGroupOffsets_t;\nrd_kafka_ListConsumerGroupOffsets_t *rd_kafka_ListConsumerGroupOffsets_new(const char *group_id, const rd_kafka_topic_partition_list_t *partitions);\nvoid rd_kafka_ListConsumerGroupOffsets_destroy(rd_kafka_ListConsumerGroupOffsets_t *list_grpoffsets);\nvoid rd_kafka_ListConsumerGroupOffsets_destroy_array(rd_kafka_ListConsumerGroupOffsets_t **list_grpoffsets, size_t list_grpoffset_cnt);\nvoid rd_kafka_ListConsumerGroupOffsets(rd_kafka_t *rk, rd_kafka_ListConsumerGroupOffsets_t **list_grpoffsets, size_t list_grpoffsets_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_group_result_t **rd_kafka_ListConsumerGroupOffsets_result_groups(const rd_kafka_ListConsumerGroupOffsets_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_AlterConsumerGroupOffsets_s rd_kafka_AlterConsumerGroupOffsets_t;\nrd_kafka_AlterConsumerGroupOffsets_t *rd_kafka_AlterConsumerGroupOffsets_new(const char *group_id, const rd_kafka_topic_partition_list_t *partitions);\nvoid rd_kafka_AlterConsumerGroupOffsets_destroy(rd_kafka_AlterConsumerGroupOffsets_t *alter_grpoffsets);\nvoid rd_kafka_AlterConsumerGroupOffsets_destroy_array(rd_kafka_AlterConsumerGroupOffsets_t **alter_grpoffsets, size_t alter_grpoffset_cnt);\nvoid rd_kafka_AlterConsumerGroupOffsets(rd_kafka_t *rk, rd_kafka_AlterConsumerGroupOffsets_t **alter_grpoffsets, size_t alter_grpoffsets_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_group_result_t **rd_kafka_AlterConsumerGroupOffsets_result_groups(const rd_kafka_AlterConsumerGroupOffsets_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_DeleteConsumerGroupOffsets_s rd_kafka_DeleteConsumerGroupOffsets_t;\nrd_kafka_DeleteConsumerGroupOffsets_t *rd_kafka_DeleteConsumerGroupOffsets_new(const char *group, const rd_kafka_topic_partition_list_t *partitions);\nvoid rd_kafka_DeleteConsumerGroupOffsets_destroy(rd_kafka_DeleteConsumerGroupOffsets_t *del_grpoffsets);\nvoid rd_kafka_DeleteConsumerGroupOffsets_destroy_array(rd_kafka_DeleteConsumerGroupOffsets_t **del_grpoffsets, size_t del_grpoffset_cnt);\nvoid rd_kafka_DeleteConsumerGroupOffsets(rd_kafka_t *rk, rd_kafka_DeleteConsumerGroupOffsets_t **del_grpoffsets, size_t del_grpoffsets_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_group_result_t **rd_kafka_DeleteConsumerGroupOffsets_result_groups(const rd_kafka_DeleteConsumerGroupOffsets_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_AclBinding_s rd_kafka_AclBinding_t;\ntypedef rd_kafka_AclBinding_t rd_kafka_AclBindingFilter_t;\nconst rd_kafka_error_t *rd_kafka_acl_result_error(const rd_kafka_acl_result_t *aclres);\ntypedef enum rd_kafka_AclOperation_t {\n  RD_KAFKA_ACL_OPERATION_UNKNOWN = 0,\n  RD_KAFKA_ACL_OPERATION_ANY = 1,\n  RD_KAFKA_ACL_OPERATION_ALL = 2,\n  RD_KAFKA_ACL_OPERATION_READ = 3,\n  RD_KAFKA_ACL_OPERATION_WRITE = 4,\n  RD_KAFKA_ACL_OPERATION_CREATE = 5,\n  RD_KAFKA_ACL_OPERATION_DELETE = 6,\n  RD_KAFKA_ACL_OPERATION_ALTER = 7,\n  RD_KAFKA_ACL_OPERATION_DESCRIBE = 8,\n  RD_KAFKA_ACL_OPERATION_CLUSTER_ACTION = 9,\n  RD_KAFKA_ACL_OPERATION_DESCRIBE_CONFIGS = 10,\n  RD_KAFKA_ACL_OPERATION_ALTER_CONFIGS = 11,\n  RD_KAFKA_ACL_OPERATION_IDEMPOTENT_WRITE = 12,\n  RD_KAFKA_ACL_OPERATION__CNT,\n} rd_kafka_AclOperation_t;\nconst char *rd_kafka_AclOperation_name(rd_kafka_AclOperation_t acl_operation);\ntypedef enum rd_kafka_AclPermissionType_t {\n  RD_KAFKA_ACL_PERMISSION_TYPE_UNKNOWN = 0,\n  RD_KAFKA_ACL_PERMISSION_TYPE_ANY = 1,\n  RD_KAFKA_ACL_PERMISSION_TYPE_DENY = 2,\n  RD_KAFKA_ACL_PERMISSION_TYPE_ALLOW = 3,\n  RD_KAFKA_ACL_PERMISSION_TYPE__CNT,\n} rd_kafka_AclPermissionType_t;\nconst char *rd_kafka_AclPermissionType_name(rd_kafka_AclPermissionType_t acl_permission_type);\nrd_kafka_AclBinding_t *rd_kafka_AclBinding_new(rd_kafka_ResourceType_t restype, const char *name, rd_kafka_ResourcePatternType_t resource_pattern_type, const char *principal, const char *host, rd_kafka_AclOperation_t operation, rd_kafka_AclPermissionType_t permission_type, char *errstr, size_t errstr_size);\nrd_kafka_AclBindingFilter_t *rd_kafka_AclBindingFilter_new(rd_kafka_ResourceType_t restype, const char *name, rd_kafka_ResourcePatternType_t resource_pattern_type, const char *principal, const char *host, rd_kafka_AclOperation_t operation, rd_kafka_AclPermissionType_t permission_type, char *errstr, size_t errstr_size);\nrd_kafka_ResourceType_t rd_kafka_AclBinding_restype(const rd_kafka_AclBinding_t *acl);\nconst char *rd_kafka_AclBinding_name(const rd_kafka_AclBinding_t *acl);\nconst char *rd_kafka_AclBinding_principal(const rd_kafka_AclBinding_t *acl);\nconst char *rd_kafka_AclBinding_host(const rd_kafka_AclBinding_t *acl);\nrd_kafka_AclOperation_t rd_kafka_AclBinding_operation(const rd_kafka_AclBinding_t *acl);\nrd_kafka_AclPermissionType_t rd_kafka_AclBinding_permission_type(const rd_kafka_AclBinding_t *acl);\nrd_kafka_ResourcePatternType_t rd_kafka_AclBinding_resource_pattern_type(const rd_kafka_AclBinding_t *acl);\nconst rd_kafka_error_t *rd_kafka_AclBinding_error(const rd_kafka_AclBinding_t *acl);\nvoid rd_kafka_AclBinding_destroy(rd_kafka_AclBinding_t *acl_binding);\nvoid rd_kafka_AclBinding_destroy_array(rd_kafka_AclBinding_t **acl_bindings, size_t acl_bindings_cnt);\nconst rd_kafka_acl_result_t **rd_kafka_CreateAcls_result_acls(const rd_kafka_CreateAcls_result_t *result, size_t *cntp);\nvoid rd_kafka_CreateAcls(rd_kafka_t *rk, rd_kafka_AclBinding_t **new_acls, size_t new_acls_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_AclBinding_t **rd_kafka_DescribeAcls_result_acls(const rd_kafka_DescribeAcls_result_t *result, size_t *cntp);\nvoid rd_kafka_DescribeAcls(rd_kafka_t *rk, rd_kafka_AclBindingFilter_t *acl_filter, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\ntypedef struct rd_kafka_DeleteAcls_result_response_s rd_kafka_DeleteAcls_result_response_t;\nconst rd_kafka_DeleteAcls_result_response_t **rd_kafka_DeleteAcls_result_responses(const rd_kafka_DeleteAcls_result_t *result, size_t *cntp);\nconst rd_kafka_error_t *rd_kafka_DeleteAcls_result_response_error(const rd_kafka_DeleteAcls_result_response_t *result_response);\nconst rd_kafka_AclBinding_t **rd_kafka_DeleteAcls_result_response_matching_acls(const rd_kafka_DeleteAcls_result_response_t *result_response, size_t *matching_acls_cntp);\nvoid rd_kafka_DeleteAcls(rd_kafka_t *rk, rd_kafka_AclBindingFilter_t **del_acls, size_t del_acls_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nrd_kafka_resp_err_t rd_kafka_oauthbearer_set_token(rd_kafka_t *rk, const char *token_value, int64_t md_lifetime_ms, const char *md_principal_name, const char **extensions, size_t extension_size, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_oauthbearer_set_token_failure(rd_kafka_t *rk, const char *errstr);\nrd_kafka_error_t *rd_kafka_init_transactions(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_error_t *rd_kafka_begin_transaction(rd_kafka_t *rk);\nrd_kafka_error_t *rd_kafka_send_offsets_to_transaction(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, const rd_kafka_consumer_group_metadata_t *cgmetadata, int timeout_ms);\nrd_kafka_error_t *rd_kafka_commit_transaction(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_error_t *rd_kafka_abort_transaction(rd_kafka_t *rk, int timeout_ms);\ntypedef struct rd_kafka_mock_cluster_s rd_kafka_mock_cluster_t;\nrd_kafka_mock_cluster_t *rd_kafka_mock_cluster_new(rd_kafka_t *rk, int broker_cnt);\nvoid rd_kafka_mock_cluster_destroy(rd_kafka_mock_cluster_t *mcluster);\nrd_kafka_t *rd_kafka_mock_cluster_handle(const rd_kafka_mock_cluster_t *mcluster);\nrd_kafka_mock_cluster_t *rd_kafka_handle_mock_cluster(const rd_kafka_t *rk);\nconst char *rd_kafka_mock_cluster_bootstraps(const rd_kafka_mock_cluster_t *mcluster);\nvoid rd_kafka_mock_clear_request_errors(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey);\nvoid rd_kafka_mock_push_request_errors(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, size_t cnt, ...);\nvoid rd_kafka_mock_push_request_errors_array(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, size_t cnt, const rd_kafka_resp_err_t *errors);\nrd_kafka_resp_err_t rd_kafka_mock_broker_push_request_error_rtts(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int16_t ApiKey, size_t cnt, ...);\nrd_kafka_resp_err_t rd_kafka_mock_broker_error_stack_cnt(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int16_t ApiKey, size_t *cntp);\nvoid rd_kafka_mock_topic_set_error(rd_kafka_mock_cluster_t *mcluster, const char *topic, rd_kafka_resp_err_t err);\nrd_kafka_resp_err_t rd_kafka_mock_topic_create(rd_kafka_mock_cluster_t *mcluster, const char *topic, int partition_cnt, int replication_factor);\nrd_kafka_resp_err_t rd_kafka_mock_partition_set_leader(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id);\nrd_kafka_resp_err_t rd_kafka_mock_partition_set_follower(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id);\nrd_kafka_resp_err_t rd_kafka_mock_partition_set_follower_wmarks(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int64_t lo, int64_t hi);\nrd_kafka_resp_err_t rd_kafka_mock_broker_set_down(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id);\nrd_kafka_resp_err_t rd_kafka_mock_broker_set_up(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id);\nrd_kafka_resp_err_t rd_kafka_mock_broker_set_rtt(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int rtt_ms);\nrd_kafka_resp_err_t rd_kafka_mock_broker_set_rack(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, const char *rack);\nrd_kafka_resp_err_t rd_kafka_mock_coordinator_set(rd_kafka_mock_cluster_t *mcluster, const char *key_type, const char *key, int32_t broker_id);\nrd_kafka_resp_err_t rd_kafka_mock_set_apiversion(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, int16_t MinVersion, int16_t MaxVersion);\n'\n</code></pre> rdkafka.h, rdkafka_mock.h</p>"},{"location":"api/constants/#rd_kafka_version_24","title":"RD_KAFKA_VERSION","text":"<pre><code>public RD_KAFKA_VERSION = 33555199\n</code></pre> <p>librdkafka version </p> <p>Interpreted as hex <code>MM.mm.rr.xx</code>:</p> <ul> <li>MM = Major</li> <li>mm = minor</li> <li>rr = revision</li> <li>xx = pre-release id (0xff is the final release)</li> </ul> <p>E.g.: <code>0x000801ff</code> = 0.8.1</p> RemarksThis value should only be used during compile time, for runtime checks of version use rd_kafka_version()  <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_unsupported_compression_type_24","title":"RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE","text":"<pre><code>public RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76\n</code></pre> <p>Unsupported compression type </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_end_all_24","title":"RD_KAFKA_RESP_ERR_END_ALL","text":"<p><pre><code>public RD_KAFKA_RESP_ERR_END_ALL = 98\n</code></pre> enum rd_kafka_resp_err_t</p>"},{"location":"api/constants/#rd_kafka_admin_op__cnt_24","title":"RD_KAFKA_ADMIN_OP__CNT","text":"<pre><code>public RD_KAFKA_ADMIN_OP__CNT = 16\n</code></pre> <p>Number of ops defined </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe </li> </ul>"},{"location":"api/constants/#rd_kafka_resource__cnt_24","title":"RD_KAFKA_RESOURCE__CNT","text":"<pre><code>public RD_KAFKA_RESOURCE__CNT = 5\n</code></pre> <p>Number of resource types defined </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#acca83a66d7783ff7683ed2691cc907c9 </li> </ul>"},{"location":"api/constants/#rd_kafka_cdef_24","title":"RD_KAFKA_CDEF","text":"<p><pre><code>public RD_KAFKA_CDEF = 'typedef long int ssize_t;\ntypedef struct _IO_FILE FILE;\ntypedef long int mode_t;\ntypedef signed int int16_t;\ntypedef unsigned int uint16_t;\ntypedef signed int int32_t;\ntypedef signed long int int64_t;\nint rd_kafka_version(void);\nconst char *rd_kafka_version_str(void);\ntypedef enum rd_kafka_type_t {\n  RD_KAFKA_PRODUCER,\n  RD_KAFKA_CONSUMER,\n} rd_kafka_type_t;\ntypedef enum rd_kafka_timestamp_type_t {\n  RD_KAFKA_TIMESTAMP_NOT_AVAILABLE,\n  RD_KAFKA_TIMESTAMP_CREATE_TIME,\n  RD_KAFKA_TIMESTAMP_LOG_APPEND_TIME,\n} rd_kafka_timestamp_type_t;\nconst char *rd_kafka_get_debug_contexts(void);\ntypedef struct rd_kafka_s rd_kafka_t;\ntypedef struct rd_kafka_topic_s rd_kafka_topic_t;\ntypedef struct rd_kafka_conf_s rd_kafka_conf_t;\ntypedef struct rd_kafka_topic_conf_s rd_kafka_topic_conf_t;\ntypedef struct rd_kafka_queue_s rd_kafka_queue_t;\ntypedef struct rd_kafka_op_s rd_kafka_event_t;\ntypedef struct rd_kafka_topic_result_s rd_kafka_topic_result_t;\ntypedef struct rd_kafka_consumer_group_metadata_s rd_kafka_consumer_group_metadata_t;\ntypedef struct rd_kafka_error_s {\n  unsigned int code;\n  char *errstr;\n  unsigned char fatal;\n  unsigned char retriable;\n  unsigned char txn_requires_abort;\n} rd_kafka_error_t;\ntypedef struct rd_kafka_headers_s rd_kafka_headers_t;\ntypedef struct rd_kafka_group_result_s rd_kafka_group_result_t;\ntypedef struct rd_kafka_acl_result_s rd_kafka_acl_result_t;\ntypedef enum {\n  RD_KAFKA_RESP_ERR__BEGIN = (- 200),\n  RD_KAFKA_RESP_ERR__BAD_MSG = (- 199),\n  RD_KAFKA_RESP_ERR__BAD_COMPRESSION = (- 198),\n  RD_KAFKA_RESP_ERR__DESTROY = (- 197),\n  RD_KAFKA_RESP_ERR__FAIL = (- 196),\n  RD_KAFKA_RESP_ERR__TRANSPORT = (- 195),\n  RD_KAFKA_RESP_ERR__CRIT_SYS_RESOURCE = (- 194),\n  RD_KAFKA_RESP_ERR__RESOLVE = (- 193),\n  RD_KAFKA_RESP_ERR__MSG_TIMED_OUT = (- 192),\n  RD_KAFKA_RESP_ERR__PARTITION_EOF = (- 191),\n  RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION = (- 190),\n  RD_KAFKA_RESP_ERR__FS = (- 189),\n  RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC = (- 188),\n  RD_KAFKA_RESP_ERR__ALL_BROKERS_DOWN = (- 187),\n  RD_KAFKA_RESP_ERR__INVALID_ARG = (- 186),\n  RD_KAFKA_RESP_ERR__TIMED_OUT = (- 185),\n  RD_KAFKA_RESP_ERR__QUEUE_FULL = (- 184),\n  RD_KAFKA_RESP_ERR__ISR_INSUFF = (- 183),\n  RD_KAFKA_RESP_ERR__NODE_UPDATE = (- 182),\n  RD_KAFKA_RESP_ERR__SSL = (- 181),\n  RD_KAFKA_RESP_ERR__WAIT_COORD = (- 180),\n  RD_KAFKA_RESP_ERR__UNKNOWN_GROUP = (- 179),\n  RD_KAFKA_RESP_ERR__IN_PROGRESS = (- 178),\n  RD_KAFKA_RESP_ERR__PREV_IN_PROGRESS = (- 177),\n  RD_KAFKA_RESP_ERR__EXISTING_SUBSCRIPTION = (- 176),\n  RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS = (- 175),\n  RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS = (- 174),\n  RD_KAFKA_RESP_ERR__CONFLICT = (- 173),\n  RD_KAFKA_RESP_ERR__STATE = (- 172),\n  RD_KAFKA_RESP_ERR__UNKNOWN_PROTOCOL = (- 171),\n  RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED = (- 170),\n  RD_KAFKA_RESP_ERR__AUTHENTICATION = (- 169),\n  RD_KAFKA_RESP_ERR__NO_OFFSET = (- 168),\n  RD_KAFKA_RESP_ERR__OUTDATED = (- 167),\n  RD_KAFKA_RESP_ERR__TIMED_OUT_QUEUE = (- 166),\n  RD_KAFKA_RESP_ERR__UNSUPPORTED_FEATURE = (- 165),\n  RD_KAFKA_RESP_ERR__WAIT_CACHE = (- 164),\n  RD_KAFKA_RESP_ERR__INTR = (- 163),\n  RD_KAFKA_RESP_ERR__KEY_SERIALIZATION = (- 162),\n  RD_KAFKA_RESP_ERR__VALUE_SERIALIZATION = (- 161),\n  RD_KAFKA_RESP_ERR__KEY_DESERIALIZATION = (- 160),\n  RD_KAFKA_RESP_ERR__VALUE_DESERIALIZATION = (- 159),\n  RD_KAFKA_RESP_ERR__PARTIAL = (- 158),\n  RD_KAFKA_RESP_ERR__READ_ONLY = (- 157),\n  RD_KAFKA_RESP_ERR__NOENT = (- 156),\n  RD_KAFKA_RESP_ERR__UNDERFLOW = (- 155),\n  RD_KAFKA_RESP_ERR__INVALID_TYPE = (- 154),\n  RD_KAFKA_RESP_ERR__RETRY = (- 153),\n  RD_KAFKA_RESP_ERR__PURGE_QUEUE = (- 152),\n  RD_KAFKA_RESP_ERR__PURGE_INFLIGHT = (- 151),\n  RD_KAFKA_RESP_ERR__FATAL = (- 150),\n  RD_KAFKA_RESP_ERR__INCONSISTENT = (- 149),\n  RD_KAFKA_RESP_ERR__GAPLESS_GUARANTEE = (- 148),\n  RD_KAFKA_RESP_ERR__MAX_POLL_EXCEEDED = (- 147),\n  RD_KAFKA_RESP_ERR__UNKNOWN_BROKER = (- 146),\n  RD_KAFKA_RESP_ERR__NOT_CONFIGURED = (- 145),\n  RD_KAFKA_RESP_ERR__FENCED = (- 144),\n  RD_KAFKA_RESP_ERR__APPLICATION = (- 143),\n  RD_KAFKA_RESP_ERR__ASSIGNMENT_LOST = (- 142),\n  RD_KAFKA_RESP_ERR__NOOP = (- 141),\n  RD_KAFKA_RESP_ERR__AUTO_OFFSET_RESET = (- 140),\n  RD_KAFKA_RESP_ERR__END = (- 100),\n  RD_KAFKA_RESP_ERR_UNKNOWN = (- 1),\n  RD_KAFKA_RESP_ERR_NO_ERROR = 0,\n  RD_KAFKA_RESP_ERR_OFFSET_OUT_OF_RANGE = 1,\n  RD_KAFKA_RESP_ERR_INVALID_MSG = 2,\n  RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART = 3,\n  RD_KAFKA_RESP_ERR_INVALID_MSG_SIZE = 4,\n  RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE = 5,\n  RD_KAFKA_RESP_ERR_NOT_LEADER_FOR_PARTITION = 6,\n  RD_KAFKA_RESP_ERR_REQUEST_TIMED_OUT = 7,\n  RD_KAFKA_RESP_ERR_BROKER_NOT_AVAILABLE = 8,\n  RD_KAFKA_RESP_ERR_REPLICA_NOT_AVAILABLE = 9,\n  RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE = 10,\n  RD_KAFKA_RESP_ERR_STALE_CTRL_EPOCH = 11,\n  RD_KAFKA_RESP_ERR_OFFSET_METADATA_TOO_LARGE = 12,\n  RD_KAFKA_RESP_ERR_NETWORK_EXCEPTION = 13,\n  RD_KAFKA_RESP_ERR_COORDINATOR_LOAD_IN_PROGRESS = 14,\n  RD_KAFKA_RESP_ERR_COORDINATOR_NOT_AVAILABLE = 15,\n  RD_KAFKA_RESP_ERR_NOT_COORDINATOR = 16,\n  RD_KAFKA_RESP_ERR_TOPIC_EXCEPTION = 17,\n  RD_KAFKA_RESP_ERR_RECORD_LIST_TOO_LARGE = 18,\n  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS = 19,\n  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS_AFTER_APPEND = 20,\n  RD_KAFKA_RESP_ERR_INVALID_REQUIRED_ACKS = 21,\n  RD_KAFKA_RESP_ERR_ILLEGAL_GENERATION = 22,\n  RD_KAFKA_RESP_ERR_INCONSISTENT_GROUP_PROTOCOL = 23,\n  RD_KAFKA_RESP_ERR_INVALID_GROUP_ID = 24,\n  RD_KAFKA_RESP_ERR_UNKNOWN_MEMBER_ID = 25,\n  RD_KAFKA_RESP_ERR_INVALID_SESSION_TIMEOUT = 26,\n  RD_KAFKA_RESP_ERR_REBALANCE_IN_PROGRESS = 27,\n  RD_KAFKA_RESP_ERR_INVALID_COMMIT_OFFSET_SIZE = 28,\n  RD_KAFKA_RESP_ERR_TOPIC_AUTHORIZATION_FAILED = 29,\n  RD_KAFKA_RESP_ERR_GROUP_AUTHORIZATION_FAILED = 30,\n  RD_KAFKA_RESP_ERR_CLUSTER_AUTHORIZATION_FAILED = 31,\n  RD_KAFKA_RESP_ERR_INVALID_TIMESTAMP = 32,\n  RD_KAFKA_RESP_ERR_UNSUPPORTED_SASL_MECHANISM = 33,\n  RD_KAFKA_RESP_ERR_ILLEGAL_SASL_STATE = 34,\n  RD_KAFKA_RESP_ERR_UNSUPPORTED_VERSION = 35,\n  RD_KAFKA_RESP_ERR_TOPIC_ALREADY_EXISTS = 36,\n  RD_KAFKA_RESP_ERR_INVALID_PARTITIONS = 37,\n  RD_KAFKA_RESP_ERR_INVALID_REPLICATION_FACTOR = 38,\n  RD_KAFKA_RESP_ERR_INVALID_REPLICA_ASSIGNMENT = 39,\n  RD_KAFKA_RESP_ERR_INVALID_CONFIG = 40,\n  RD_KAFKA_RESP_ERR_NOT_CONTROLLER = 41,\n  RD_KAFKA_RESP_ERR_INVALID_REQUEST = 42,\n  RD_KAFKA_RESP_ERR_UNSUPPORTED_FOR_MESSAGE_FORMAT = 43,\n  RD_KAFKA_RESP_ERR_POLICY_VIOLATION = 44,\n  RD_KAFKA_RESP_ERR_OUT_OF_ORDER_SEQUENCE_NUMBER = 45,\n  RD_KAFKA_RESP_ERR_DUPLICATE_SEQUENCE_NUMBER = 46,\n  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_EPOCH = 47,\n  RD_KAFKA_RESP_ERR_INVALID_TXN_STATE = 48,\n  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_ID_MAPPING = 49,\n  RD_KAFKA_RESP_ERR_INVALID_TRANSACTION_TIMEOUT = 50,\n  RD_KAFKA_RESP_ERR_CONCURRENT_TRANSACTIONS = 51,\n  RD_KAFKA_RESP_ERR_TRANSACTION_COORDINATOR_FENCED = 52,\n  RD_KAFKA_RESP_ERR_TRANSACTIONAL_ID_AUTHORIZATION_FAILED = 53,\n  RD_KAFKA_RESP_ERR_SECURITY_DISABLED = 54,\n  RD_KAFKA_RESP_ERR_OPERATION_NOT_ATTEMPTED = 55,\n  RD_KAFKA_RESP_ERR_KAFKA_STORAGE_ERROR = 56,\n  RD_KAFKA_RESP_ERR_LOG_DIR_NOT_FOUND = 57,\n  RD_KAFKA_RESP_ERR_SASL_AUTHENTICATION_FAILED = 58,\n  RD_KAFKA_RESP_ERR_UNKNOWN_PRODUCER_ID = 59,\n  RD_KAFKA_RESP_ERR_REASSIGNMENT_IN_PROGRESS = 60,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTH_DISABLED = 61,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_NOT_FOUND = 62,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_OWNER_MISMATCH = 63,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_REQUEST_NOT_ALLOWED = 64,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTHORIZATION_FAILED = 65,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_EXPIRED = 66,\n  RD_KAFKA_RESP_ERR_INVALID_PRINCIPAL_TYPE = 67,\n  RD_KAFKA_RESP_ERR_NON_EMPTY_GROUP = 68,\n  RD_KAFKA_RESP_ERR_GROUP_ID_NOT_FOUND = 69,\n  RD_KAFKA_RESP_ERR_FETCH_SESSION_ID_NOT_FOUND = 70,\n  RD_KAFKA_RESP_ERR_INVALID_FETCH_SESSION_EPOCH = 71,\n  RD_KAFKA_RESP_ERR_LISTENER_NOT_FOUND = 72,\n  RD_KAFKA_RESP_ERR_TOPIC_DELETION_DISABLED = 73,\n  RD_KAFKA_RESP_ERR_FENCED_LEADER_EPOCH = 74,\n  RD_KAFKA_RESP_ERR_UNKNOWN_LEADER_EPOCH = 75,\n  RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76,\n  RD_KAFKA_RESP_ERR_STALE_BROKER_EPOCH = 77,\n  RD_KAFKA_RESP_ERR_OFFSET_NOT_AVAILABLE = 78,\n  RD_KAFKA_RESP_ERR_MEMBER_ID_REQUIRED = 79,\n  RD_KAFKA_RESP_ERR_PREFERRED_LEADER_NOT_AVAILABLE = 80,\n  RD_KAFKA_RESP_ERR_GROUP_MAX_SIZE_REACHED = 81,\n  RD_KAFKA_RESP_ERR_FENCED_INSTANCE_ID = 82,\n  RD_KAFKA_RESP_ERR_ELIGIBLE_LEADERS_NOT_AVAILABLE = 83,\n  RD_KAFKA_RESP_ERR_ELECTION_NOT_NEEDED = 84,\n  RD_KAFKA_RESP_ERR_NO_REASSIGNMENT_IN_PROGRESS = 85,\n  RD_KAFKA_RESP_ERR_GROUP_SUBSCRIBED_TO_TOPIC = 86,\n  RD_KAFKA_RESP_ERR_INVALID_RECORD = 87,\n  RD_KAFKA_RESP_ERR_UNSTABLE_OFFSET_COMMIT = 88,\n  RD_KAFKA_RESP_ERR_THROTTLING_QUOTA_EXCEEDED = 89,\n  RD_KAFKA_RESP_ERR_PRODUCER_FENCED = 90,\n  RD_KAFKA_RESP_ERR_RESOURCE_NOT_FOUND = 91,\n  RD_KAFKA_RESP_ERR_DUPLICATE_RESOURCE = 92,\n  RD_KAFKA_RESP_ERR_UNACCEPTABLE_CREDENTIAL = 93,\n  RD_KAFKA_RESP_ERR_INCONSISTENT_VOTER_SET = 94,\n  RD_KAFKA_RESP_ERR_INVALID_UPDATE_VERSION = 95,\n  RD_KAFKA_RESP_ERR_FEATURE_UPDATE_FAILED = 96,\n  RD_KAFKA_RESP_ERR_PRINCIPAL_DESERIALIZATION_FAILURE = 97,\n  RD_KAFKA_RESP_ERR_END_ALL,\n} rd_kafka_resp_err_t;\nstruct rd_kafka_err_desc {\n  rd_kafka_resp_err_t code;\n  char *name;\n  char *desc;\n};\nvoid rd_kafka_get_err_descs(const struct rd_kafka_err_desc **errdescs, size_t *cntp);\nconst char *rd_kafka_err2str(rd_kafka_resp_err_t err);\nconst char *rd_kafka_err2name(rd_kafka_resp_err_t err);\nrd_kafka_resp_err_t rd_kafka_last_error(void);\nrd_kafka_resp_err_t rd_kafka_errno2err(int errnox);\nint rd_kafka_errno(void);\nrd_kafka_resp_err_t rd_kafka_fatal_error(rd_kafka_t *rk, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_test_fatal_error(rd_kafka_t *rk, rd_kafka_resp_err_t err, const char *reason);\nrd_kafka_resp_err_t rd_kafka_error_code(const rd_kafka_error_t *error);\nconst char *rd_kafka_error_name(const rd_kafka_error_t *error);\nconst char *rd_kafka_error_string(const rd_kafka_error_t *error);\nint rd_kafka_error_is_fatal(const rd_kafka_error_t *error);\nint rd_kafka_error_is_retriable(const rd_kafka_error_t *error);\nint rd_kafka_error_txn_requires_abort(const rd_kafka_error_t *error);\nvoid rd_kafka_error_destroy(rd_kafka_error_t *error);\nrd_kafka_error_t *rd_kafka_error_new(rd_kafka_resp_err_t code, const char *fmt, ...);\ntypedef struct rd_kafka_topic_partition_s {\n  char *topic;\n  int32_t partition;\n  int64_t offset;\n  void *metadata;\n  size_t metadata_size;\n  void *opaque;\n  rd_kafka_resp_err_t err;\n  void *_private;\n} rd_kafka_topic_partition_t;\nvoid rd_kafka_topic_partition_destroy(rd_kafka_topic_partition_t *rktpar);\ntypedef struct rd_kafka_topic_partition_list_s {\n  int cnt;\n  int size;\n  rd_kafka_topic_partition_t *elems;\n} rd_kafka_topic_partition_list_t;\nrd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_new(int size);\nvoid rd_kafka_topic_partition_list_destroy(rd_kafka_topic_partition_list_t *rkparlist);\nrd_kafka_topic_partition_t *rd_kafka_topic_partition_list_add(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);\nvoid rd_kafka_topic_partition_list_add_range(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t start, int32_t stop);\nint rd_kafka_topic_partition_list_del(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);\nint rd_kafka_topic_partition_list_del_by_idx(rd_kafka_topic_partition_list_t *rktparlist, int idx);\nrd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_copy(const rd_kafka_topic_partition_list_t *src);\nrd_kafka_resp_err_t rd_kafka_topic_partition_list_set_offset(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition, int64_t offset);\nrd_kafka_topic_partition_t *rd_kafka_topic_partition_list_find(const rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);\nvoid rd_kafka_topic_partition_list_sort(rd_kafka_topic_partition_list_t *rktparlist, int (*cmp)(const void *a, const void *b, void *cmp_opaque), void *cmp_opaque);\ntypedef enum rd_kafka_vtype_t {\n  RD_KAFKA_VTYPE_END,\n  RD_KAFKA_VTYPE_TOPIC,\n  RD_KAFKA_VTYPE_RKT,\n  RD_KAFKA_VTYPE_PARTITION,\n  RD_KAFKA_VTYPE_VALUE,\n  RD_KAFKA_VTYPE_KEY,\n  RD_KAFKA_VTYPE_OPAQUE,\n  RD_KAFKA_VTYPE_MSGFLAGS,\n  RD_KAFKA_VTYPE_TIMESTAMP,\n  RD_KAFKA_VTYPE_HEADER,\n  RD_KAFKA_VTYPE_HEADERS,\n} rd_kafka_vtype_t;\ntypedef struct rd_kafka_vu_s {\n  rd_kafka_vtype_t vtype;\n  union {\n    char *cstr;\n    rd_kafka_topic_t *rkt;\n    int i;\n    int32_t i32;\n    int64_t i64;\n    struct {\n      void *ptr;\n      size_t size;\n    } mem;\n    struct {\n      char *name;\n      void *val;\n      ssize_t size;\n    } header;\n    rd_kafka_headers_t *headers;\n    void *ptr;\n    char _pad[64];\n  } u;\n} rd_kafka_vu_t;\nrd_kafka_headers_t *rd_kafka_headers_new(size_t initial_count);\nvoid rd_kafka_headers_destroy(rd_kafka_headers_t *hdrs);\nrd_kafka_headers_t *rd_kafka_headers_copy(const rd_kafka_headers_t *src);\nrd_kafka_resp_err_t rd_kafka_header_add(rd_kafka_headers_t *hdrs, const char *name, ssize_t name_size, const void *value, ssize_t value_size);\nrd_kafka_resp_err_t rd_kafka_header_remove(rd_kafka_headers_t *hdrs, const char *name);\nrd_kafka_resp_err_t rd_kafka_header_get_last(const rd_kafka_headers_t *hdrs, const char *name, const void **valuep, size_t *sizep);\nrd_kafka_resp_err_t rd_kafka_header_get(const rd_kafka_headers_t *hdrs, size_t idx, const char *name, const void **valuep, size_t *sizep);\nrd_kafka_resp_err_t rd_kafka_header_get_all(const rd_kafka_headers_t *hdrs, size_t idx, const char **namep, const void **valuep, size_t *sizep);\ntypedef struct rd_kafka_message_s {\n  rd_kafka_resp_err_t err;\n  rd_kafka_topic_t *rkt;\n  int32_t partition;\n  void *payload;\n  size_t len;\n  void *key;\n  size_t key_len;\n  int64_t offset;\n  void *_private;\n} rd_kafka_message_t;\nvoid rd_kafka_message_destroy(rd_kafka_message_t *rkmessage);\nconst char *rd_kafka_message_errstr(const rd_kafka_message_t *rkmessage);\nint64_t rd_kafka_message_timestamp(const rd_kafka_message_t *rkmessage, rd_kafka_timestamp_type_t *tstype);\nint64_t rd_kafka_message_latency(const rd_kafka_message_t *rkmessage);\nint32_t rd_kafka_message_broker_id(const rd_kafka_message_t *rkmessage);\nrd_kafka_resp_err_t rd_kafka_message_headers(const rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);\nrd_kafka_resp_err_t rd_kafka_message_detach_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);\nvoid rd_kafka_message_set_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t *hdrs);\nsize_t rd_kafka_header_cnt(const rd_kafka_headers_t *hdrs);\ntypedef enum {\n  RD_KAFKA_MSG_STATUS_NOT_PERSISTED = 0,\n  RD_KAFKA_MSG_STATUS_POSSIBLY_PERSISTED = 1,\n  RD_KAFKA_MSG_STATUS_PERSISTED = 2,\n} rd_kafka_msg_status_t;\nrd_kafka_msg_status_t rd_kafka_message_status(const rd_kafka_message_t *rkmessage);\ntypedef enum {\n  RD_KAFKA_CONF_UNKNOWN = (- 2),\n  RD_KAFKA_CONF_INVALID = (- 1),\n  RD_KAFKA_CONF_OK = 0,\n} rd_kafka_conf_res_t;\nrd_kafka_conf_t *rd_kafka_conf_new(void);\nvoid rd_kafka_conf_destroy(rd_kafka_conf_t *conf);\nrd_kafka_conf_t *rd_kafka_conf_dup(const rd_kafka_conf_t *conf);\nrd_kafka_conf_t *rd_kafka_conf_dup_filter(const rd_kafka_conf_t *conf, size_t filter_cnt, const char **filter);\nconst rd_kafka_conf_t *rd_kafka_conf(rd_kafka_t *rk);\nrd_kafka_conf_res_t rd_kafka_conf_set(rd_kafka_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);\nvoid rd_kafka_conf_set_events(rd_kafka_conf_t *conf, int events);\nvoid rd_kafka_conf_set_background_event_cb(rd_kafka_conf_t *conf, void (*event_cb)(rd_kafka_t *rk, rd_kafka_event_t *rkev, void *opaque));\nvoid rd_kafka_conf_set_dr_cb(rd_kafka_conf_t *conf, void (*dr_cb)(rd_kafka_t *rk, void *payload, size_t len, rd_kafka_resp_err_t err, void *opaque, void *msg_opaque));\nvoid rd_kafka_conf_set_dr_msg_cb(rd_kafka_conf_t *conf, void (*dr_msg_cb)(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, void *opaque));\nvoid rd_kafka_conf_set_consume_cb(rd_kafka_conf_t *conf, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *opaque));\nvoid rd_kafka_conf_set_rebalance_cb(rd_kafka_conf_t *conf, void (*rebalance_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *partitions, void *opaque));\nvoid rd_kafka_conf_set_offset_commit_cb(rd_kafka_conf_t *conf, void (*offset_commit_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *opaque));\nvoid rd_kafka_conf_set_error_cb(rd_kafka_conf_t *conf, void (*error_cb)(rd_kafka_t *rk, int err, const char *reason, void *opaque));\nvoid rd_kafka_conf_set_throttle_cb(rd_kafka_conf_t *conf, void (*throttle_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int throttle_time_ms, void *opaque));\nvoid rd_kafka_conf_set_log_cb(rd_kafka_conf_t *conf, void (*log_cb)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));\nvoid rd_kafka_conf_set_stats_cb(rd_kafka_conf_t *conf, int (*stats_cb)(rd_kafka_t *rk, char *json, size_t json_len, void *opaque));\nvoid rd_kafka_conf_set_oauthbearer_token_refresh_cb(rd_kafka_conf_t *conf, void (*oauthbearer_token_refresh_cb)(rd_kafka_t *rk, const char *oauthbearer_config, void *opaque));\nvoid rd_kafka_conf_enable_sasl_queue(rd_kafka_conf_t *conf, int enable);\nvoid rd_kafka_conf_set_socket_cb(rd_kafka_conf_t *conf, int (*socket_cb)(int domain, int type, int protocol, void *opaque));\nvoid rd_kafka_conf_set_connect_cb(rd_kafka_conf_t *conf, int (*connect_cb)(int sockfd, const struct sockaddr *addr, int addrlen, const char *id, void *opaque));\nvoid rd_kafka_conf_set_closesocket_cb(rd_kafka_conf_t *conf, int (*closesocket_cb)(int sockfd, void *opaque));\nstruct addrinfo;\nvoid rd_kafka_conf_set_resolve_cb(rd_kafka_conf_t *conf, int (*resolve_cb)(const char *node, const char *service, const struct addrinfo *hints, struct addrinfo **res, void *opaque));\nrd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert_verify_cb(rd_kafka_conf_t *conf, int (*ssl_cert_verify_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int *x509_error, int depth, const char *buf, size_t size, char *errstr, size_t errstr_size, void *opaque));\ntypedef enum rd_kafka_cert_type_t {\n  RD_KAFKA_CERT_PUBLIC_KEY,\n  RD_KAFKA_CERT_PRIVATE_KEY,\n  RD_KAFKA_CERT_CA,\n  RD_KAFKA_CERT__CNT,\n} rd_kafka_cert_type_t;\ntypedef enum rd_kafka_cert_enc_t {\n  RD_KAFKA_CERT_ENC_PKCS12,\n  RD_KAFKA_CERT_ENC_DER,\n  RD_KAFKA_CERT_ENC_PEM,\n  RD_KAFKA_CERT_ENC__CNT,\n} rd_kafka_cert_enc_t;\nrd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert(rd_kafka_conf_t *conf, rd_kafka_cert_type_t cert_type, rd_kafka_cert_enc_t cert_enc, const void *buffer, size_t size, char *errstr, size_t errstr_size);\nvoid rd_kafka_conf_set_engine_callback_data(rd_kafka_conf_t *conf, void *callback_data);\nvoid rd_kafka_conf_set_opaque(rd_kafka_conf_t *conf, void *opaque);\nvoid *rd_kafka_opaque(const rd_kafka_t *rk);\nvoid rd_kafka_conf_set_default_topic_conf(rd_kafka_conf_t *conf, rd_kafka_topic_conf_t *tconf);\nrd_kafka_topic_conf_t *rd_kafka_conf_get_default_topic_conf(rd_kafka_conf_t *conf);\nrd_kafka_conf_res_t rd_kafka_conf_get(const rd_kafka_conf_t *conf, const char *name, char *dest, size_t *dest_size);\nrd_kafka_conf_res_t rd_kafka_topic_conf_get(const rd_kafka_topic_conf_t *conf, const char *name, char *dest, size_t *dest_size);\nconst char **rd_kafka_conf_dump(rd_kafka_conf_t *conf, size_t *cntp);\nconst char **rd_kafka_topic_conf_dump(rd_kafka_topic_conf_t *conf, size_t *cntp);\nvoid rd_kafka_conf_dump_free(const char **arr, size_t cnt);\nvoid rd_kafka_conf_properties_show(FILE *fp);\nrd_kafka_topic_conf_t *rd_kafka_topic_conf_new(void);\nrd_kafka_topic_conf_t *rd_kafka_topic_conf_dup(const rd_kafka_topic_conf_t *conf);\nrd_kafka_topic_conf_t *rd_kafka_default_topic_conf_dup(rd_kafka_t *rk);\nvoid rd_kafka_topic_conf_destroy(rd_kafka_topic_conf_t *topic_conf);\nrd_kafka_conf_res_t rd_kafka_topic_conf_set(rd_kafka_topic_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);\nvoid rd_kafka_topic_conf_set_opaque(rd_kafka_topic_conf_t *conf, void *rkt_opaque);\nvoid rd_kafka_topic_conf_set_partitioner_cb(rd_kafka_topic_conf_t *topic_conf, int32_t (*partitioner)(const rd_kafka_topic_t *rkt, const void *keydata, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque));\nvoid rd_kafka_topic_conf_set_msg_order_cmp(rd_kafka_topic_conf_t *topic_conf, int (*msg_order_cmp)(const rd_kafka_message_t *a, const rd_kafka_message_t *b));\nint rd_kafka_topic_partition_available(const rd_kafka_topic_t *rkt, int32_t partition);\nint32_t rd_kafka_msg_partitioner_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_consistent(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_consistent_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_murmur2(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_murmur2_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_fnv1a(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_fnv1a_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nrd_kafka_t *rd_kafka_new(rd_kafka_type_t type, rd_kafka_conf_t *conf, char *errstr, size_t errstr_size);\nvoid rd_kafka_destroy(rd_kafka_t *rk);\nvoid rd_kafka_destroy_flags(rd_kafka_t *rk, int flags);\nconst char *rd_kafka_name(const rd_kafka_t *rk);\nrd_kafka_type_t rd_kafka_type(const rd_kafka_t *rk);\nchar *rd_kafka_memberid(const rd_kafka_t *rk);\nchar *rd_kafka_clusterid(rd_kafka_t *rk, int timeout_ms);\nint32_t rd_kafka_controllerid(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_topic_t *rd_kafka_topic_new(rd_kafka_t *rk, const char *topic, rd_kafka_topic_conf_t *conf);\nvoid rd_kafka_topic_destroy(rd_kafka_topic_t *rkt);\nconst char *rd_kafka_topic_name(const rd_kafka_topic_t *rkt);\nvoid *rd_kafka_topic_opaque(const rd_kafka_topic_t *rkt);\nint rd_kafka_poll(rd_kafka_t *rk, int timeout_ms);\nvoid rd_kafka_yield(rd_kafka_t *rk);\nrd_kafka_resp_err_t rd_kafka_pause_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_resp_err_t rd_kafka_resume_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_resp_err_t rd_kafka_query_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high, int timeout_ms);\nrd_kafka_resp_err_t rd_kafka_get_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high);\nrd_kafka_resp_err_t rd_kafka_offsets_for_times(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets, int timeout_ms);\nvoid *rd_kafka_mem_calloc(rd_kafka_t *rk, size_t num, size_t size);\nvoid *rd_kafka_mem_malloc(rd_kafka_t *rk, size_t size);\nvoid rd_kafka_mem_free(rd_kafka_t *rk, void *ptr);\nrd_kafka_queue_t *rd_kafka_queue_new(rd_kafka_t *rk);\nvoid rd_kafka_queue_destroy(rd_kafka_queue_t *rkqu);\nrd_kafka_queue_t *rd_kafka_queue_get_main(rd_kafka_t *rk);\nrd_kafka_queue_t *rd_kafka_queue_get_sasl(rd_kafka_t *rk);\nrd_kafka_error_t *rd_kafka_sasl_background_callbacks_enable(rd_kafka_t *rk);\nrd_kafka_error_t *rd_kafka_sasl_set_credentials(rd_kafka_t *rk, const char *username, const char *password);\nrd_kafka_queue_t *rd_kafka_queue_get_consumer(rd_kafka_t *rk);\nrd_kafka_queue_t *rd_kafka_queue_get_partition(rd_kafka_t *rk, const char *topic, int32_t partition);\nrd_kafka_queue_t *rd_kafka_queue_get_background(rd_kafka_t *rk);\nvoid rd_kafka_queue_forward(rd_kafka_queue_t *src, rd_kafka_queue_t *dst);\nrd_kafka_resp_err_t rd_kafka_set_log_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu);\nsize_t rd_kafka_queue_length(rd_kafka_queue_t *rkqu);\nvoid rd_kafka_queue_io_event_enable(rd_kafka_queue_t *rkqu, int fd, const void *payload, size_t size);\nvoid rd_kafka_queue_cb_event_enable(rd_kafka_queue_t *rkqu, void (*event_cb)(rd_kafka_t *rk, void *qev_opaque), void *qev_opaque);\nvoid rd_kafka_queue_yield(rd_kafka_queue_t *rkqu);\nint rd_kafka_consume_start(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);\nint rd_kafka_consume_start_queue(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, rd_kafka_queue_t *rkqu);\nint rd_kafka_consume_stop(rd_kafka_topic_t *rkt, int32_t partition);\nrd_kafka_resp_err_t rd_kafka_seek(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, int timeout_ms);\nrd_kafka_error_t *rd_kafka_seek_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms);\nrd_kafka_message_t *rd_kafka_consume(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms);\nssize_t rd_kafka_consume_batch(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);\nint rd_kafka_consume_callback(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);\nrd_kafka_message_t *rd_kafka_consume_queue(rd_kafka_queue_t *rkqu, int timeout_ms);\nssize_t rd_kafka_consume_batch_queue(rd_kafka_queue_t *rkqu, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);\nint rd_kafka_consume_callback_queue(rd_kafka_queue_t *rkqu, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);\nrd_kafka_resp_err_t rd_kafka_offset_store(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);\nrd_kafka_resp_err_t rd_kafka_offsets_store(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets);\nrd_kafka_resp_err_t rd_kafka_subscribe(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *topics);\nrd_kafka_resp_err_t rd_kafka_unsubscribe(rd_kafka_t *rk);\nrd_kafka_resp_err_t rd_kafka_subscription(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **topics);\nrd_kafka_message_t *rd_kafka_consumer_poll(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_resp_err_t rd_kafka_consumer_close(rd_kafka_t *rk);\nrd_kafka_error_t *rd_kafka_consumer_close_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu);\nint rd_kafka_consumer_closed(rd_kafka_t *rk);\nrd_kafka_error_t *rd_kafka_incremental_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_error_t *rd_kafka_incremental_unassign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);\nconst char *rd_kafka_rebalance_protocol(rd_kafka_t *rk);\nrd_kafka_resp_err_t rd_kafka_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_resp_err_t rd_kafka_assignment(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **partitions);\nint rd_kafka_assignment_lost(rd_kafka_t *rk);\nrd_kafka_resp_err_t rd_kafka_commit(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, int async);\nrd_kafka_resp_err_t rd_kafka_commit_message(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, int async);\nrd_kafka_resp_err_t rd_kafka_commit_queue(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_queue_t *rkqu, void (*cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *commit_opaque), void *commit_opaque);\nrd_kafka_resp_err_t rd_kafka_committed(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms);\nrd_kafka_resp_err_t rd_kafka_position(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata(rd_kafka_t *rk);\nrd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata_new(const char *group_id);\nrd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata_new_with_genid(const char *group_id, int32_t generation_id, const char *member_id, const char *group_instance_id);\nvoid rd_kafka_consumer_group_metadata_destroy(rd_kafka_consumer_group_metadata_t *);\nrd_kafka_error_t *rd_kafka_consumer_group_metadata_write(const rd_kafka_consumer_group_metadata_t *cgmd, void **bufferp, size_t *sizep);\nrd_kafka_error_t *rd_kafka_consumer_group_metadata_read(rd_kafka_consumer_group_metadata_t **cgmdp, const void *buffer, size_t size);\nint rd_kafka_produce(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, void *payload, size_t len, const void *key, size_t keylen, void *msg_opaque);\nrd_kafka_resp_err_t rd_kafka_producev(rd_kafka_t *rk, ...);\nrd_kafka_error_t *rd_kafka_produceva(rd_kafka_t *rk, const rd_kafka_vu_t *vus, size_t cnt);\nint rd_kafka_produce_batch(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, rd_kafka_message_t *rkmessages, int message_cnt);\nrd_kafka_resp_err_t rd_kafka_flush(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_resp_err_t rd_kafka_purge(rd_kafka_t *rk, int purge_flags);\ntypedef struct rd_kafka_metadata_broker {\n  int32_t id;\n  char *host;\n  int port;\n} rd_kafka_metadata_broker_t;\ntypedef struct rd_kafka_metadata_partition {\n  int32_t id;\n  rd_kafka_resp_err_t err;\n  int32_t leader;\n  int replica_cnt;\n  int32_t *replicas;\n  int isr_cnt;\n  int32_t *isrs;\n} rd_kafka_metadata_partition_t;\ntypedef struct rd_kafka_metadata_topic {\n  char *topic;\n  int partition_cnt;\n  struct rd_kafka_metadata_partition *partitions;\n  rd_kafka_resp_err_t err;\n} rd_kafka_metadata_topic_t;\ntypedef struct rd_kafka_metadata {\n  int broker_cnt;\n  struct rd_kafka_metadata_broker *brokers;\n  int topic_cnt;\n  struct rd_kafka_metadata_topic *topics;\n  int32_t orig_broker_id;\n  char *orig_broker_name;\n} rd_kafka_metadata_t;\nrd_kafka_resp_err_t rd_kafka_metadata(rd_kafka_t *rk, int all_topics, rd_kafka_topic_t *only_rkt, const struct rd_kafka_metadata **metadatap, int timeout_ms);\nvoid rd_kafka_metadata_destroy(const struct rd_kafka_metadata *metadata);\ntypedef struct rd_kafka_Node_s rd_kafka_Node_t;\nint rd_kafka_Node_id(const rd_kafka_Node_t *node);\nconst char *rd_kafka_Node_host(const rd_kafka_Node_t *node);\nuint16_t rd_kafka_Node_port(const rd_kafka_Node_t *node);\nstruct rd_kafka_group_member_info {\n  char *member_id;\n  char *client_id;\n  char *client_host;\n  void *member_metadata;\n  int member_metadata_size;\n  void *member_assignment;\n  int member_assignment_size;\n};\ntypedef enum {\n  RD_KAFKA_CONSUMER_GROUP_STATE_UNKNOWN = 0,\n  RD_KAFKA_CONSUMER_GROUP_STATE_PREPARING_REBALANCE = 1,\n  RD_KAFKA_CONSUMER_GROUP_STATE_COMPLETING_REBALANCE = 2,\n  RD_KAFKA_CONSUMER_GROUP_STATE_STABLE = 3,\n  RD_KAFKA_CONSUMER_GROUP_STATE_DEAD = 4,\n  RD_KAFKA_CONSUMER_GROUP_STATE_EMPTY = 5,\n  RD_KAFKA_CONSUMER_GROUP_STATE__CNT,\n} rd_kafka_consumer_group_state_t;\nstruct rd_kafka_group_info {\n  struct rd_kafka_metadata_broker broker;\n  char *group;\n  rd_kafka_resp_err_t err;\n  char *state;\n  char *protocol_type;\n  char *protocol;\n  struct rd_kafka_group_member_info *members;\n  int member_cnt;\n};\nstruct rd_kafka_group_list {\n  struct rd_kafka_group_info *groups;\n  int group_cnt;\n};\nrd_kafka_resp_err_t rd_kafka_list_groups(rd_kafka_t *rk, const char *group, const struct rd_kafka_group_list **grplistp, int timeout_ms);\nconst char *rd_kafka_consumer_group_state_name(rd_kafka_consumer_group_state_t state);\nrd_kafka_consumer_group_state_t rd_kafka_consumer_group_state_code(const char *name);\nvoid rd_kafka_group_list_destroy(const struct rd_kafka_group_list *grplist);\nint rd_kafka_brokers_add(rd_kafka_t *rk, const char *brokerlist);\nvoid rd_kafka_set_logger(rd_kafka_t *rk, void (*func)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));\nvoid rd_kafka_set_log_level(rd_kafka_t *rk, int level);\nvoid rd_kafka_log_print(const rd_kafka_t *rk, int level, const char *fac, const char *buf);\nvoid rd_kafka_log_syslog(const rd_kafka_t *rk, int level, const char *fac, const char *buf);\nint rd_kafka_outq_len(rd_kafka_t *rk);\nvoid rd_kafka_dump(FILE *fp, rd_kafka_t *rk);\nint rd_kafka_thread_cnt(void);\ntypedef enum rd_kafka_thread_type_t {\n  RD_KAFKA_THREAD_MAIN,\n  RD_KAFKA_THREAD_BACKGROUND,\n  RD_KAFKA_THREAD_BROKER,\n} rd_kafka_thread_type_t;\nint rd_kafka_wait_destroyed(int timeout_ms);\nint rd_kafka_unittest(void);\nrd_kafka_resp_err_t rd_kafka_poll_set_consumer(rd_kafka_t *rk);\ntypedef int rd_kafka_event_type_t;\nrd_kafka_event_type_t rd_kafka_event_type(const rd_kafka_event_t *rkev);\nconst char *rd_kafka_event_name(const rd_kafka_event_t *rkev);\nvoid rd_kafka_event_destroy(rd_kafka_event_t *rkev);\nconst rd_kafka_message_t *rd_kafka_event_message_next(rd_kafka_event_t *rkev);\nsize_t rd_kafka_event_message_array(rd_kafka_event_t *rkev, const rd_kafka_message_t **rkmessages, size_t size);\nsize_t rd_kafka_event_message_count(rd_kafka_event_t *rkev);\nconst char *rd_kafka_event_config_string(rd_kafka_event_t *rkev);\nrd_kafka_resp_err_t rd_kafka_event_error(rd_kafka_event_t *rkev);\nconst char *rd_kafka_event_error_string(rd_kafka_event_t *rkev);\nint rd_kafka_event_error_is_fatal(rd_kafka_event_t *rkev);\nvoid *rd_kafka_event_opaque(rd_kafka_event_t *rkev);\nint rd_kafka_event_log(rd_kafka_event_t *rkev, const char **fac, const char **str, int *level);\nint rd_kafka_event_debug_contexts(rd_kafka_event_t *rkev, char *dst, size_t dstsize);\nconst char *rd_kafka_event_stats(rd_kafka_event_t *rkev);\nrd_kafka_topic_partition_list_t *rd_kafka_event_topic_partition_list(rd_kafka_event_t *rkev);\nrd_kafka_topic_partition_t *rd_kafka_event_topic_partition(rd_kafka_event_t *rkev);\ntypedef rd_kafka_event_t rd_kafka_CreateTopics_result_t;\ntypedef rd_kafka_event_t rd_kafka_DeleteTopics_result_t;\ntypedef rd_kafka_event_t rd_kafka_CreateAcls_result_t;\ntypedef rd_kafka_event_t rd_kafka_DescribeAcls_result_t;\ntypedef rd_kafka_event_t rd_kafka_DeleteAcls_result_t;\ntypedef rd_kafka_event_t rd_kafka_CreatePartitions_result_t;\ntypedef rd_kafka_event_t rd_kafka_AlterConfigs_result_t;\ntypedef rd_kafka_event_t rd_kafka_DescribeConfigs_result_t;\ntypedef rd_kafka_event_t rd_kafka_DeleteRecords_result_t;\ntypedef rd_kafka_event_t rd_kafka_ListConsumerGroups_result_t;\ntypedef rd_kafka_event_t rd_kafka_DescribeConsumerGroups_result_t;\ntypedef rd_kafka_event_t rd_kafka_DeleteGroups_result_t;\ntypedef rd_kafka_event_t rd_kafka_DeleteConsumerGroupOffsets_result_t;\ntypedef rd_kafka_event_t rd_kafka_AlterConsumerGroupOffsets_result_t;\ntypedef rd_kafka_event_t rd_kafka_ListConsumerGroupOffsets_result_t;\nconst rd_kafka_CreateTopics_result_t *rd_kafka_event_CreateTopics_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DeleteTopics_result_t *rd_kafka_event_DeleteTopics_result(rd_kafka_event_t *rkev);\nconst rd_kafka_CreatePartitions_result_t *rd_kafka_event_CreatePartitions_result(rd_kafka_event_t *rkev);\nconst rd_kafka_AlterConfigs_result_t *rd_kafka_event_AlterConfigs_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DescribeConfigs_result_t *rd_kafka_event_DescribeConfigs_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DeleteRecords_result_t *rd_kafka_event_DeleteRecords_result(rd_kafka_event_t *rkev);\nconst rd_kafka_ListConsumerGroups_result_t *rd_kafka_event_ListConsumerGroups_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DescribeConsumerGroups_result_t *rd_kafka_event_DescribeConsumerGroups_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DeleteGroups_result_t *rd_kafka_event_DeleteGroups_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DeleteConsumerGroupOffsets_result_t *rd_kafka_event_DeleteConsumerGroupOffsets_result(rd_kafka_event_t *rkev);\nconst rd_kafka_CreateAcls_result_t *rd_kafka_event_CreateAcls_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DescribeAcls_result_t *rd_kafka_event_DescribeAcls_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DeleteAcls_result_t *rd_kafka_event_DeleteAcls_result(rd_kafka_event_t *rkev);\nconst rd_kafka_AlterConsumerGroupOffsets_result_t *rd_kafka_event_AlterConsumerGroupOffsets_result(rd_kafka_event_t *rkev);\nconst rd_kafka_ListConsumerGroupOffsets_result_t *rd_kafka_event_ListConsumerGroupOffsets_result(rd_kafka_event_t *rkev);\nrd_kafka_event_t *rd_kafka_queue_poll(rd_kafka_queue_t *rkqu, int timeout_ms);\nint rd_kafka_queue_poll_callback(rd_kafka_queue_t *rkqu, int timeout_ms);\ntypedef rd_kafka_resp_err_t (rd_kafka_plugin_f_conf_init_t)(rd_kafka_conf_t *conf, void **plug_opaquep, char *errstr, size_t errstr_size);\ntypedef rd_kafka_conf_res_t (rd_kafka_interceptor_f_on_conf_set_t)(rd_kafka_conf_t *conf, const char *name, const char *val, char *errstr, size_t errstr_size, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_dup_t)(rd_kafka_conf_t *new_conf, const rd_kafka_conf_t *old_conf, size_t filter_cnt, const char **filter, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_destroy_t)(void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_new_t)(rd_kafka_t *rk, const rd_kafka_conf_t *conf, void *ic_opaque, char *errstr, size_t errstr_size);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_destroy_t)(rd_kafka_t *rk, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_send_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_acknowledgement_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_consume_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_commit_t)(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_resp_err_t err, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_request_sent_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_response_received_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, int64_t rtt, rd_kafka_resp_err_t err, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_start_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_exit_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_broker_state_change_t)(rd_kafka_t *rk, int32_t broker_id, const char *secproto, const char *name, int port, const char *state, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_set(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_set_t *on_conf_set, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_dup(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_dup_t *on_conf_dup, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_destroy(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_destroy_t *on_conf_destroy, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_new(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_new_t *on_new, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_destroy(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_destroy_t *on_destroy, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_send(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_send_t *on_send, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_acknowledgement(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_acknowledgement_t *on_acknowledgement, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_consume(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_consume_t *on_consume, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_commit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_commit_t *on_commit, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_request_sent(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_request_sent_t *on_request_sent, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_response_received(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_response_received_t *on_response_received, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_start(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_start_t *on_thread_start, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_exit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_exit_t *on_thread_exit, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_broker_state_change(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_broker_state_change_t *on_broker_state_change, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_topic_result_error(const rd_kafka_topic_result_t *topicres);\nconst char *rd_kafka_topic_result_error_string(const rd_kafka_topic_result_t *topicres);\nconst char *rd_kafka_topic_result_name(const rd_kafka_topic_result_t *topicres);\nconst rd_kafka_error_t *rd_kafka_group_result_error(const rd_kafka_group_result_t *groupres);\nconst char *rd_kafka_group_result_name(const rd_kafka_group_result_t *groupres);\nconst rd_kafka_topic_partition_list_t *rd_kafka_group_result_partitions(const rd_kafka_group_result_t *groupres);\ntypedef enum rd_kafka_admin_op_t {\n  RD_KAFKA_ADMIN_OP_ANY = 0,\n  RD_KAFKA_ADMIN_OP_CREATETOPICS,\n  RD_KAFKA_ADMIN_OP_DELETETOPICS,\n  RD_KAFKA_ADMIN_OP_CREATEPARTITIONS,\n  RD_KAFKA_ADMIN_OP_ALTERCONFIGS,\n  RD_KAFKA_ADMIN_OP_DESCRIBECONFIGS,\n  RD_KAFKA_ADMIN_OP_DELETERECORDS,\n  RD_KAFKA_ADMIN_OP_DELETEGROUPS,\n  RD_KAFKA_ADMIN_OP_DELETECONSUMERGROUPOFFSETS,\n  RD_KAFKA_ADMIN_OP_CREATEACLS,\n  RD_KAFKA_ADMIN_OP_DESCRIBEACLS,\n  RD_KAFKA_ADMIN_OP_DELETEACLS,\n  RD_KAFKA_ADMIN_OP_LISTCONSUMERGROUPS,\n  RD_KAFKA_ADMIN_OP_DESCRIBECONSUMERGROUPS,\n  RD_KAFKA_ADMIN_OP_LISTCONSUMERGROUPOFFSETS,\n  RD_KAFKA_ADMIN_OP_ALTERCONSUMERGROUPOFFSETS,\n  RD_KAFKA_ADMIN_OP__CNT,\n} rd_kafka_admin_op_t;\ntypedef struct rd_kafka_AdminOptions_s rd_kafka_AdminOptions_t;\nrd_kafka_AdminOptions_t *rd_kafka_AdminOptions_new(rd_kafka_t *rk, rd_kafka_admin_op_t for_api);\nvoid rd_kafka_AdminOptions_destroy(rd_kafka_AdminOptions_t *options);\nrd_kafka_resp_err_t rd_kafka_AdminOptions_set_request_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_AdminOptions_set_operation_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_AdminOptions_set_validate_only(rd_kafka_AdminOptions_t *options, int true_or_false, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_AdminOptions_set_broker(rd_kafka_AdminOptions_t *options, int32_t broker_id, char *errstr, size_t errstr_size);\nrd_kafka_error_t *rd_kafka_AdminOptions_set_require_stable_offsets(rd_kafka_AdminOptions_t *options, int true_or_false);\nrd_kafka_error_t *rd_kafka_AdminOptions_set_match_consumer_group_states(rd_kafka_AdminOptions_t *options, const rd_kafka_consumer_group_state_t *consumer_group_states, size_t consumer_group_states_cnt);\nvoid rd_kafka_AdminOptions_set_opaque(rd_kafka_AdminOptions_t *options, void *ev_opaque);\ntypedef struct rd_kafka_NewTopic_s rd_kafka_NewTopic_t;\nrd_kafka_NewTopic_t *rd_kafka_NewTopic_new(const char *topic, int num_partitions, int replication_factor, char *errstr, size_t errstr_size);\nvoid rd_kafka_NewTopic_destroy(rd_kafka_NewTopic_t *new_topic);\nvoid rd_kafka_NewTopic_destroy_array(rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt);\nrd_kafka_resp_err_t rd_kafka_NewTopic_set_replica_assignment(rd_kafka_NewTopic_t *new_topic, int32_t partition, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_NewTopic_set_config(rd_kafka_NewTopic_t *new_topic, const char *name, const char *value);\nvoid rd_kafka_CreateTopics(rd_kafka_t *rk, rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_topic_result_t **rd_kafka_CreateTopics_result_topics(const rd_kafka_CreateTopics_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_DeleteTopic_s rd_kafka_DeleteTopic_t;\nrd_kafka_DeleteTopic_t *rd_kafka_DeleteTopic_new(const char *topic);\nvoid rd_kafka_DeleteTopic_destroy(rd_kafka_DeleteTopic_t *del_topic);\nvoid rd_kafka_DeleteTopic_destroy_array(rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt);\nvoid rd_kafka_DeleteTopics(rd_kafka_t *rk, rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_topic_result_t **rd_kafka_DeleteTopics_result_topics(const rd_kafka_DeleteTopics_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_NewPartitions_s rd_kafka_NewPartitions_t;\nrd_kafka_NewPartitions_t *rd_kafka_NewPartitions_new(const char *topic, size_t new_total_cnt, char *errstr, size_t errstr_size);\nvoid rd_kafka_NewPartitions_destroy(rd_kafka_NewPartitions_t *new_parts);\nvoid rd_kafka_NewPartitions_destroy_array(rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt);\nrd_kafka_resp_err_t rd_kafka_NewPartitions_set_replica_assignment(rd_kafka_NewPartitions_t *new_parts, int32_t new_partition_idx, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);\nvoid rd_kafka_CreatePartitions(rd_kafka_t *rk, rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_topic_result_t **rd_kafka_CreatePartitions_result_topics(const rd_kafka_CreatePartitions_result_t *result, size_t *cntp);\ntypedef enum rd_kafka_ConfigSource_t {\n  RD_KAFKA_CONFIG_SOURCE_UNKNOWN_CONFIG = 0,\n  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_TOPIC_CONFIG = 1,\n  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_BROKER_CONFIG = 2,\n  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_DEFAULT_BROKER_CONFIG = 3,\n  RD_KAFKA_CONFIG_SOURCE_STATIC_BROKER_CONFIG = 4,\n  RD_KAFKA_CONFIG_SOURCE_DEFAULT_CONFIG = 5,\n  RD_KAFKA_CONFIG_SOURCE__CNT,\n} rd_kafka_ConfigSource_t;\nconst char *rd_kafka_ConfigSource_name(rd_kafka_ConfigSource_t confsource);\ntypedef struct rd_kafka_ConfigEntry_s rd_kafka_ConfigEntry_t;\nconst char *rd_kafka_ConfigEntry_name(const rd_kafka_ConfigEntry_t *entry);\nconst char *rd_kafka_ConfigEntry_value(const rd_kafka_ConfigEntry_t *entry);\nrd_kafka_ConfigSource_t rd_kafka_ConfigEntry_source(const rd_kafka_ConfigEntry_t *entry);\nint rd_kafka_ConfigEntry_is_read_only(const rd_kafka_ConfigEntry_t *entry);\nint rd_kafka_ConfigEntry_is_default(const rd_kafka_ConfigEntry_t *entry);\nint rd_kafka_ConfigEntry_is_sensitive(const rd_kafka_ConfigEntry_t *entry);\nint rd_kafka_ConfigEntry_is_synonym(const rd_kafka_ConfigEntry_t *entry);\nconst rd_kafka_ConfigEntry_t **rd_kafka_ConfigEntry_synonyms(const rd_kafka_ConfigEntry_t *entry, size_t *cntp);\ntypedef enum rd_kafka_ResourceType_t {\n  RD_KAFKA_RESOURCE_UNKNOWN = 0,\n  RD_KAFKA_RESOURCE_ANY = 1,\n  RD_KAFKA_RESOURCE_TOPIC = 2,\n  RD_KAFKA_RESOURCE_GROUP = 3,\n  RD_KAFKA_RESOURCE_BROKER = 4,\n  RD_KAFKA_RESOURCE__CNT,\n} rd_kafka_ResourceType_t;\ntypedef enum rd_kafka_ResourcePatternType_t {\n  RD_KAFKA_RESOURCE_PATTERN_UNKNOWN = 0,\n  RD_KAFKA_RESOURCE_PATTERN_ANY = 1,\n  RD_KAFKA_RESOURCE_PATTERN_MATCH = 2,\n  RD_KAFKA_RESOURCE_PATTERN_LITERAL = 3,\n  RD_KAFKA_RESOURCE_PATTERN_PREFIXED = 4,\n  RD_KAFKA_RESOURCE_PATTERN_TYPE__CNT,\n} rd_kafka_ResourcePatternType_t;\nconst char *rd_kafka_ResourcePatternType_name(rd_kafka_ResourcePatternType_t resource_pattern_type);\nconst char *rd_kafka_ResourceType_name(rd_kafka_ResourceType_t restype);\ntypedef struct rd_kafka_ConfigResource_s rd_kafka_ConfigResource_t;\nrd_kafka_ConfigResource_t *rd_kafka_ConfigResource_new(rd_kafka_ResourceType_t restype, const char *resname);\nvoid rd_kafka_ConfigResource_destroy(rd_kafka_ConfigResource_t *config);\nvoid rd_kafka_ConfigResource_destroy_array(rd_kafka_ConfigResource_t **config, size_t config_cnt);\nrd_kafka_resp_err_t rd_kafka_ConfigResource_set_config(rd_kafka_ConfigResource_t *config, const char *name, const char *value);\nconst rd_kafka_ConfigEntry_t **rd_kafka_ConfigResource_configs(const rd_kafka_ConfigResource_t *config, size_t *cntp);\nrd_kafka_ResourceType_t rd_kafka_ConfigResource_type(const rd_kafka_ConfigResource_t *config);\nconst char *rd_kafka_ConfigResource_name(const rd_kafka_ConfigResource_t *config);\nrd_kafka_resp_err_t rd_kafka_ConfigResource_error(const rd_kafka_ConfigResource_t *config);\nconst char *rd_kafka_ConfigResource_error_string(const rd_kafka_ConfigResource_t *config);\nvoid rd_kafka_AlterConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_ConfigResource_t **rd_kafka_AlterConfigs_result_resources(const rd_kafka_AlterConfigs_result_t *result, size_t *cntp);\nvoid rd_kafka_DescribeConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_ConfigResource_t **rd_kafka_DescribeConfigs_result_resources(const rd_kafka_DescribeConfigs_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_DeleteRecords_s rd_kafka_DeleteRecords_t;\nrd_kafka_DeleteRecords_t *rd_kafka_DeleteRecords_new(const rd_kafka_topic_partition_list_t *before_offsets);\nvoid rd_kafka_DeleteRecords_destroy(rd_kafka_DeleteRecords_t *del_records);\nvoid rd_kafka_DeleteRecords_destroy_array(rd_kafka_DeleteRecords_t **del_records, size_t del_record_cnt);\nvoid rd_kafka_DeleteRecords(rd_kafka_t *rk, rd_kafka_DeleteRecords_t **del_records, size_t del_record_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_topic_partition_list_t *rd_kafka_DeleteRecords_result_offsets(const rd_kafka_DeleteRecords_result_t *result);\ntypedef struct rd_kafka_ConsumerGroupListing_s rd_kafka_ConsumerGroupListing_t;\ntypedef struct rd_kafka_ListConsumerGroupsResult_s rd_kafka_ListConsumerGroupsResult_t;\nvoid rd_kafka_ListConsumerGroups(rd_kafka_t *rk, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst char *rd_kafka_ConsumerGroupListing_group_id(const rd_kafka_ConsumerGroupListing_t *grplist);\nint rd_kafka_ConsumerGroupListing_is_simple_consumer_group(const rd_kafka_ConsumerGroupListing_t *grplist);\nrd_kafka_consumer_group_state_t rd_kafka_ConsumerGroupListing_state(const rd_kafka_ConsumerGroupListing_t *grplist);\nconst rd_kafka_ConsumerGroupListing_t **rd_kafka_ListConsumerGroups_result_valid(const rd_kafka_ListConsumerGroups_result_t *result, size_t *cntp);\nconst rd_kafka_error_t **rd_kafka_ListConsumerGroups_result_errors(const rd_kafka_ListConsumerGroups_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_ConsumerGroupDescription_s rd_kafka_ConsumerGroupDescription_t;\ntypedef struct rd_kafka_MemberDescription_s rd_kafka_MemberDescription_t;\ntypedef struct rd_kafka_MemberAssignment_s rd_kafka_MemberAssignment_t;\nvoid rd_kafka_DescribeConsumerGroups(rd_kafka_t *rk, const char **groups, size_t groups_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_ConsumerGroupDescription_t **rd_kafka_DescribeConsumerGroups_result_groups(const rd_kafka_DescribeConsumerGroups_result_t *result, size_t *cntp);\nconst char *rd_kafka_ConsumerGroupDescription_group_id(const rd_kafka_ConsumerGroupDescription_t *grpdesc);\nconst rd_kafka_error_t *rd_kafka_ConsumerGroupDescription_error(const rd_kafka_ConsumerGroupDescription_t *grpdesc);\nint rd_kafka_ConsumerGroupDescription_is_simple_consumer_group(const rd_kafka_ConsumerGroupDescription_t *grpdesc);\nconst char *rd_kafka_ConsumerGroupDescription_partition_assignor(const rd_kafka_ConsumerGroupDescription_t *grpdesc);\nrd_kafka_consumer_group_state_t rd_kafka_ConsumerGroupDescription_state(const rd_kafka_ConsumerGroupDescription_t *grpdesc);\nconst rd_kafka_Node_t *rd_kafka_ConsumerGroupDescription_coordinator(const rd_kafka_ConsumerGroupDescription_t *grpdesc);\nsize_t rd_kafka_ConsumerGroupDescription_member_count(const rd_kafka_ConsumerGroupDescription_t *grpdesc);\nconst rd_kafka_MemberDescription_t *rd_kafka_ConsumerGroupDescription_member(const rd_kafka_ConsumerGroupDescription_t *grpdesc, size_t idx);\nconst char *rd_kafka_MemberDescription_client_id(const rd_kafka_MemberDescription_t *member);\nconst char *rd_kafka_MemberDescription_group_instance_id(const rd_kafka_MemberDescription_t *member);\nconst char *rd_kafka_MemberDescription_consumer_id(const rd_kafka_MemberDescription_t *member);\nconst char *rd_kafka_MemberDescription_host(const rd_kafka_MemberDescription_t *member);\nconst rd_kafka_MemberAssignment_t *rd_kafka_MemberDescription_assignment(const rd_kafka_MemberDescription_t *member);\nconst rd_kafka_topic_partition_list_t *rd_kafka_MemberAssignment_partitions(const rd_kafka_MemberAssignment_t *assignment);\ntypedef struct rd_kafka_DeleteGroup_s rd_kafka_DeleteGroup_t;\nrd_kafka_DeleteGroup_t *rd_kafka_DeleteGroup_new(const char *group);\nvoid rd_kafka_DeleteGroup_destroy(rd_kafka_DeleteGroup_t *del_group);\nvoid rd_kafka_DeleteGroup_destroy_array(rd_kafka_DeleteGroup_t **del_groups, size_t del_group_cnt);\nvoid rd_kafka_DeleteGroups(rd_kafka_t *rk, rd_kafka_DeleteGroup_t **del_groups, size_t del_group_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_group_result_t **rd_kafka_DeleteGroups_result_groups(const rd_kafka_DeleteGroups_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_ListConsumerGroupOffsets_s rd_kafka_ListConsumerGroupOffsets_t;\nrd_kafka_ListConsumerGroupOffsets_t *rd_kafka_ListConsumerGroupOffsets_new(const char *group_id, const rd_kafka_topic_partition_list_t *partitions);\nvoid rd_kafka_ListConsumerGroupOffsets_destroy(rd_kafka_ListConsumerGroupOffsets_t *list_grpoffsets);\nvoid rd_kafka_ListConsumerGroupOffsets_destroy_array(rd_kafka_ListConsumerGroupOffsets_t **list_grpoffsets, size_t list_grpoffset_cnt);\nvoid rd_kafka_ListConsumerGroupOffsets(rd_kafka_t *rk, rd_kafka_ListConsumerGroupOffsets_t **list_grpoffsets, size_t list_grpoffsets_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_group_result_t **rd_kafka_ListConsumerGroupOffsets_result_groups(const rd_kafka_ListConsumerGroupOffsets_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_AlterConsumerGroupOffsets_s rd_kafka_AlterConsumerGroupOffsets_t;\nrd_kafka_AlterConsumerGroupOffsets_t *rd_kafka_AlterConsumerGroupOffsets_new(const char *group_id, const rd_kafka_topic_partition_list_t *partitions);\nvoid rd_kafka_AlterConsumerGroupOffsets_destroy(rd_kafka_AlterConsumerGroupOffsets_t *alter_grpoffsets);\nvoid rd_kafka_AlterConsumerGroupOffsets_destroy_array(rd_kafka_AlterConsumerGroupOffsets_t **alter_grpoffsets, size_t alter_grpoffset_cnt);\nvoid rd_kafka_AlterConsumerGroupOffsets(rd_kafka_t *rk, rd_kafka_AlterConsumerGroupOffsets_t **alter_grpoffsets, size_t alter_grpoffsets_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_group_result_t **rd_kafka_AlterConsumerGroupOffsets_result_groups(const rd_kafka_AlterConsumerGroupOffsets_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_DeleteConsumerGroupOffsets_s rd_kafka_DeleteConsumerGroupOffsets_t;\nrd_kafka_DeleteConsumerGroupOffsets_t *rd_kafka_DeleteConsumerGroupOffsets_new(const char *group, const rd_kafka_topic_partition_list_t *partitions);\nvoid rd_kafka_DeleteConsumerGroupOffsets_destroy(rd_kafka_DeleteConsumerGroupOffsets_t *del_grpoffsets);\nvoid rd_kafka_DeleteConsumerGroupOffsets_destroy_array(rd_kafka_DeleteConsumerGroupOffsets_t **del_grpoffsets, size_t del_grpoffset_cnt);\nvoid rd_kafka_DeleteConsumerGroupOffsets(rd_kafka_t *rk, rd_kafka_DeleteConsumerGroupOffsets_t **del_grpoffsets, size_t del_grpoffsets_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_group_result_t **rd_kafka_DeleteConsumerGroupOffsets_result_groups(const rd_kafka_DeleteConsumerGroupOffsets_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_AclBinding_s rd_kafka_AclBinding_t;\ntypedef rd_kafka_AclBinding_t rd_kafka_AclBindingFilter_t;\nconst rd_kafka_error_t *rd_kafka_acl_result_error(const rd_kafka_acl_result_t *aclres);\ntypedef enum rd_kafka_AclOperation_t {\n  RD_KAFKA_ACL_OPERATION_UNKNOWN = 0,\n  RD_KAFKA_ACL_OPERATION_ANY = 1,\n  RD_KAFKA_ACL_OPERATION_ALL = 2,\n  RD_KAFKA_ACL_OPERATION_READ = 3,\n  RD_KAFKA_ACL_OPERATION_WRITE = 4,\n  RD_KAFKA_ACL_OPERATION_CREATE = 5,\n  RD_KAFKA_ACL_OPERATION_DELETE = 6,\n  RD_KAFKA_ACL_OPERATION_ALTER = 7,\n  RD_KAFKA_ACL_OPERATION_DESCRIBE = 8,\n  RD_KAFKA_ACL_OPERATION_CLUSTER_ACTION = 9,\n  RD_KAFKA_ACL_OPERATION_DESCRIBE_CONFIGS = 10,\n  RD_KAFKA_ACL_OPERATION_ALTER_CONFIGS = 11,\n  RD_KAFKA_ACL_OPERATION_IDEMPOTENT_WRITE = 12,\n  RD_KAFKA_ACL_OPERATION__CNT,\n} rd_kafka_AclOperation_t;\nconst char *rd_kafka_AclOperation_name(rd_kafka_AclOperation_t acl_operation);\ntypedef enum rd_kafka_AclPermissionType_t {\n  RD_KAFKA_ACL_PERMISSION_TYPE_UNKNOWN = 0,\n  RD_KAFKA_ACL_PERMISSION_TYPE_ANY = 1,\n  RD_KAFKA_ACL_PERMISSION_TYPE_DENY = 2,\n  RD_KAFKA_ACL_PERMISSION_TYPE_ALLOW = 3,\n  RD_KAFKA_ACL_PERMISSION_TYPE__CNT,\n} rd_kafka_AclPermissionType_t;\nconst char *rd_kafka_AclPermissionType_name(rd_kafka_AclPermissionType_t acl_permission_type);\nrd_kafka_AclBinding_t *rd_kafka_AclBinding_new(rd_kafka_ResourceType_t restype, const char *name, rd_kafka_ResourcePatternType_t resource_pattern_type, const char *principal, const char *host, rd_kafka_AclOperation_t operation, rd_kafka_AclPermissionType_t permission_type, char *errstr, size_t errstr_size);\nrd_kafka_AclBindingFilter_t *rd_kafka_AclBindingFilter_new(rd_kafka_ResourceType_t restype, const char *name, rd_kafka_ResourcePatternType_t resource_pattern_type, const char *principal, const char *host, rd_kafka_AclOperation_t operation, rd_kafka_AclPermissionType_t permission_type, char *errstr, size_t errstr_size);\nrd_kafka_ResourceType_t rd_kafka_AclBinding_restype(const rd_kafka_AclBinding_t *acl);\nconst char *rd_kafka_AclBinding_name(const rd_kafka_AclBinding_t *acl);\nconst char *rd_kafka_AclBinding_principal(const rd_kafka_AclBinding_t *acl);\nconst char *rd_kafka_AclBinding_host(const rd_kafka_AclBinding_t *acl);\nrd_kafka_AclOperation_t rd_kafka_AclBinding_operation(const rd_kafka_AclBinding_t *acl);\nrd_kafka_AclPermissionType_t rd_kafka_AclBinding_permission_type(const rd_kafka_AclBinding_t *acl);\nrd_kafka_ResourcePatternType_t rd_kafka_AclBinding_resource_pattern_type(const rd_kafka_AclBinding_t *acl);\nconst rd_kafka_error_t *rd_kafka_AclBinding_error(const rd_kafka_AclBinding_t *acl);\nvoid rd_kafka_AclBinding_destroy(rd_kafka_AclBinding_t *acl_binding);\nvoid rd_kafka_AclBinding_destroy_array(rd_kafka_AclBinding_t **acl_bindings, size_t acl_bindings_cnt);\nconst rd_kafka_acl_result_t **rd_kafka_CreateAcls_result_acls(const rd_kafka_CreateAcls_result_t *result, size_t *cntp);\nvoid rd_kafka_CreateAcls(rd_kafka_t *rk, rd_kafka_AclBinding_t **new_acls, size_t new_acls_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_AclBinding_t **rd_kafka_DescribeAcls_result_acls(const rd_kafka_DescribeAcls_result_t *result, size_t *cntp);\nvoid rd_kafka_DescribeAcls(rd_kafka_t *rk, rd_kafka_AclBindingFilter_t *acl_filter, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\ntypedef struct rd_kafka_DeleteAcls_result_response_s rd_kafka_DeleteAcls_result_response_t;\nconst rd_kafka_DeleteAcls_result_response_t **rd_kafka_DeleteAcls_result_responses(const rd_kafka_DeleteAcls_result_t *result, size_t *cntp);\nconst rd_kafka_error_t *rd_kafka_DeleteAcls_result_response_error(const rd_kafka_DeleteAcls_result_response_t *result_response);\nconst rd_kafka_AclBinding_t **rd_kafka_DeleteAcls_result_response_matching_acls(const rd_kafka_DeleteAcls_result_response_t *result_response, size_t *matching_acls_cntp);\nvoid rd_kafka_DeleteAcls(rd_kafka_t *rk, rd_kafka_AclBindingFilter_t **del_acls, size_t del_acls_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nrd_kafka_resp_err_t rd_kafka_oauthbearer_set_token(rd_kafka_t *rk, const char *token_value, int64_t md_lifetime_ms, const char *md_principal_name, const char **extensions, size_t extension_size, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_oauthbearer_set_token_failure(rd_kafka_t *rk, const char *errstr);\nrd_kafka_error_t *rd_kafka_init_transactions(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_error_t *rd_kafka_begin_transaction(rd_kafka_t *rk);\nrd_kafka_error_t *rd_kafka_send_offsets_to_transaction(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, const rd_kafka_consumer_group_metadata_t *cgmetadata, int timeout_ms);\nrd_kafka_error_t *rd_kafka_commit_transaction(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_error_t *rd_kafka_abort_transaction(rd_kafka_t *rk, int timeout_ms);\ntypedef struct rd_kafka_mock_cluster_s rd_kafka_mock_cluster_t;\nrd_kafka_mock_cluster_t *rd_kafka_mock_cluster_new(rd_kafka_t *rk, int broker_cnt);\nvoid rd_kafka_mock_cluster_destroy(rd_kafka_mock_cluster_t *mcluster);\nrd_kafka_t *rd_kafka_mock_cluster_handle(const rd_kafka_mock_cluster_t *mcluster);\nrd_kafka_mock_cluster_t *rd_kafka_handle_mock_cluster(const rd_kafka_t *rk);\nconst char *rd_kafka_mock_cluster_bootstraps(const rd_kafka_mock_cluster_t *mcluster);\nvoid rd_kafka_mock_clear_request_errors(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey);\nvoid rd_kafka_mock_push_request_errors(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, size_t cnt, ...);\nvoid rd_kafka_mock_push_request_errors_array(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, size_t cnt, const rd_kafka_resp_err_t *errors);\nrd_kafka_resp_err_t rd_kafka_mock_broker_push_request_error_rtts(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int16_t ApiKey, size_t cnt, ...);\nrd_kafka_resp_err_t rd_kafka_mock_broker_error_stack_cnt(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int16_t ApiKey, size_t *cntp);\nvoid rd_kafka_mock_topic_set_error(rd_kafka_mock_cluster_t *mcluster, const char *topic, rd_kafka_resp_err_t err);\nrd_kafka_resp_err_t rd_kafka_mock_topic_create(rd_kafka_mock_cluster_t *mcluster, const char *topic, int partition_cnt, int replication_factor);\nrd_kafka_resp_err_t rd_kafka_mock_partition_set_leader(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id);\nrd_kafka_resp_err_t rd_kafka_mock_partition_set_follower(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id);\nrd_kafka_resp_err_t rd_kafka_mock_partition_set_follower_wmarks(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int64_t lo, int64_t hi);\nrd_kafka_resp_err_t rd_kafka_mock_broker_set_down(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id);\nrd_kafka_resp_err_t rd_kafka_mock_broker_set_up(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id);\nrd_kafka_resp_err_t rd_kafka_mock_broker_set_rtt(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int rtt_ms);\nrd_kafka_resp_err_t rd_kafka_mock_broker_set_rack(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, const char *rack);\nrd_kafka_resp_err_t rd_kafka_mock_coordinator_set(rd_kafka_mock_cluster_t *mcluster, const char *key_type, const char *key, int32_t broker_id);\nrd_kafka_resp_err_t rd_kafka_mock_set_apiversion(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, int16_t MinVersion, int16_t MaxVersion);\n'\n</code></pre> rdkafka.h, rdkafka_mock.h</p>"},{"location":"api/constants/#rd_kafka_version_25","title":"RD_KAFKA_VERSION","text":"<pre><code>public RD_KAFKA_VERSION = 33620223\n</code></pre> <p>librdkafka version </p> <p>Interpreted as hex <code>MM.mm.rr.xx</code>:</p> <ul> <li>MM = Major</li> <li>mm = minor</li> <li>rr = revision</li> <li>xx = pre-release id (0xff is the final release)</li> </ul> <p>E.g.: <code>0x000801ff</code> = 0.8.1</p> RemarksThis value should only be used during compile time, for runtime checks of version use rd_kafka_version()  <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_unsupported_compression_type_25","title":"RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE","text":"<pre><code>public RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76\n</code></pre> <p>Unsupported compression type </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_end_all_25","title":"RD_KAFKA_RESP_ERR_END_ALL","text":"<p><pre><code>public RD_KAFKA_RESP_ERR_END_ALL = 98\n</code></pre> enum rd_kafka_resp_err_t</p>"},{"location":"api/constants/#rd_kafka_admin_op__cnt_25","title":"RD_KAFKA_ADMIN_OP__CNT","text":"<pre><code>public RD_KAFKA_ADMIN_OP__CNT = 16\n</code></pre> <p>Number of ops defined </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe </li> </ul>"},{"location":"api/constants/#rd_kafka_resource__cnt_25","title":"RD_KAFKA_RESOURCE__CNT","text":"<pre><code>public RD_KAFKA_RESOURCE__CNT = 5\n</code></pre> <p>Number of resource types defined </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#acca83a66d7783ff7683ed2691cc907c9 </li> </ul>"},{"location":"api/constants/#rd_kafka_cdef_25","title":"RD_KAFKA_CDEF","text":"<p><pre><code>public RD_KAFKA_CDEF = 'typedef long int ssize_t;\ntypedef struct _IO_FILE FILE;\ntypedef long int mode_t;\ntypedef signed int int16_t;\ntypedef unsigned int uint16_t;\ntypedef signed int int32_t;\ntypedef signed long int int64_t;\nint rd_kafka_version(void);\nconst char *rd_kafka_version_str(void);\ntypedef enum rd_kafka_type_t {\n  RD_KAFKA_PRODUCER,\n  RD_KAFKA_CONSUMER,\n} rd_kafka_type_t;\ntypedef enum rd_kafka_timestamp_type_t {\n  RD_KAFKA_TIMESTAMP_NOT_AVAILABLE,\n  RD_KAFKA_TIMESTAMP_CREATE_TIME,\n  RD_KAFKA_TIMESTAMP_LOG_APPEND_TIME,\n} rd_kafka_timestamp_type_t;\nconst char *rd_kafka_get_debug_contexts(void);\ntypedef struct rd_kafka_s rd_kafka_t;\ntypedef struct rd_kafka_topic_s rd_kafka_topic_t;\ntypedef struct rd_kafka_conf_s rd_kafka_conf_t;\ntypedef struct rd_kafka_topic_conf_s rd_kafka_topic_conf_t;\ntypedef struct rd_kafka_queue_s rd_kafka_queue_t;\ntypedef struct rd_kafka_op_s rd_kafka_event_t;\ntypedef struct rd_kafka_topic_result_s rd_kafka_topic_result_t;\ntypedef struct rd_kafka_consumer_group_metadata_s rd_kafka_consumer_group_metadata_t;\ntypedef struct rd_kafka_error_s {\n  unsigned int code;\n  char *errstr;\n  unsigned char fatal;\n  unsigned char retriable;\n  unsigned char txn_requires_abort;\n} rd_kafka_error_t;\ntypedef struct rd_kafka_headers_s rd_kafka_headers_t;\ntypedef struct rd_kafka_group_result_s rd_kafka_group_result_t;\ntypedef struct rd_kafka_acl_result_s rd_kafka_acl_result_t;\ntypedef enum {\n  RD_KAFKA_RESP_ERR__BEGIN = (- 200),\n  RD_KAFKA_RESP_ERR__BAD_MSG = (- 199),\n  RD_KAFKA_RESP_ERR__BAD_COMPRESSION = (- 198),\n  RD_KAFKA_RESP_ERR__DESTROY = (- 197),\n  RD_KAFKA_RESP_ERR__FAIL = (- 196),\n  RD_KAFKA_RESP_ERR__TRANSPORT = (- 195),\n  RD_KAFKA_RESP_ERR__CRIT_SYS_RESOURCE = (- 194),\n  RD_KAFKA_RESP_ERR__RESOLVE = (- 193),\n  RD_KAFKA_RESP_ERR__MSG_TIMED_OUT = (- 192),\n  RD_KAFKA_RESP_ERR__PARTITION_EOF = (- 191),\n  RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION = (- 190),\n  RD_KAFKA_RESP_ERR__FS = (- 189),\n  RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC = (- 188),\n  RD_KAFKA_RESP_ERR__ALL_BROKERS_DOWN = (- 187),\n  RD_KAFKA_RESP_ERR__INVALID_ARG = (- 186),\n  RD_KAFKA_RESP_ERR__TIMED_OUT = (- 185),\n  RD_KAFKA_RESP_ERR__QUEUE_FULL = (- 184),\n  RD_KAFKA_RESP_ERR__ISR_INSUFF = (- 183),\n  RD_KAFKA_RESP_ERR__NODE_UPDATE = (- 182),\n  RD_KAFKA_RESP_ERR__SSL = (- 181),\n  RD_KAFKA_RESP_ERR__WAIT_COORD = (- 180),\n  RD_KAFKA_RESP_ERR__UNKNOWN_GROUP = (- 179),\n  RD_KAFKA_RESP_ERR__IN_PROGRESS = (- 178),\n  RD_KAFKA_RESP_ERR__PREV_IN_PROGRESS = (- 177),\n  RD_KAFKA_RESP_ERR__EXISTING_SUBSCRIPTION = (- 176),\n  RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS = (- 175),\n  RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS = (- 174),\n  RD_KAFKA_RESP_ERR__CONFLICT = (- 173),\n  RD_KAFKA_RESP_ERR__STATE = (- 172),\n  RD_KAFKA_RESP_ERR__UNKNOWN_PROTOCOL = (- 171),\n  RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED = (- 170),\n  RD_KAFKA_RESP_ERR__AUTHENTICATION = (- 169),\n  RD_KAFKA_RESP_ERR__NO_OFFSET = (- 168),\n  RD_KAFKA_RESP_ERR__OUTDATED = (- 167),\n  RD_KAFKA_RESP_ERR__TIMED_OUT_QUEUE = (- 166),\n  RD_KAFKA_RESP_ERR__UNSUPPORTED_FEATURE = (- 165),\n  RD_KAFKA_RESP_ERR__WAIT_CACHE = (- 164),\n  RD_KAFKA_RESP_ERR__INTR = (- 163),\n  RD_KAFKA_RESP_ERR__KEY_SERIALIZATION = (- 162),\n  RD_KAFKA_RESP_ERR__VALUE_SERIALIZATION = (- 161),\n  RD_KAFKA_RESP_ERR__KEY_DESERIALIZATION = (- 160),\n  RD_KAFKA_RESP_ERR__VALUE_DESERIALIZATION = (- 159),\n  RD_KAFKA_RESP_ERR__PARTIAL = (- 158),\n  RD_KAFKA_RESP_ERR__READ_ONLY = (- 157),\n  RD_KAFKA_RESP_ERR__NOENT = (- 156),\n  RD_KAFKA_RESP_ERR__UNDERFLOW = (- 155),\n  RD_KAFKA_RESP_ERR__INVALID_TYPE = (- 154),\n  RD_KAFKA_RESP_ERR__RETRY = (- 153),\n  RD_KAFKA_RESP_ERR__PURGE_QUEUE = (- 152),\n  RD_KAFKA_RESP_ERR__PURGE_INFLIGHT = (- 151),\n  RD_KAFKA_RESP_ERR__FATAL = (- 150),\n  RD_KAFKA_RESP_ERR__INCONSISTENT = (- 149),\n  RD_KAFKA_RESP_ERR__GAPLESS_GUARANTEE = (- 148),\n  RD_KAFKA_RESP_ERR__MAX_POLL_EXCEEDED = (- 147),\n  RD_KAFKA_RESP_ERR__UNKNOWN_BROKER = (- 146),\n  RD_KAFKA_RESP_ERR__NOT_CONFIGURED = (- 145),\n  RD_KAFKA_RESP_ERR__FENCED = (- 144),\n  RD_KAFKA_RESP_ERR__APPLICATION = (- 143),\n  RD_KAFKA_RESP_ERR__ASSIGNMENT_LOST = (- 142),\n  RD_KAFKA_RESP_ERR__NOOP = (- 141),\n  RD_KAFKA_RESP_ERR__AUTO_OFFSET_RESET = (- 140),\n  RD_KAFKA_RESP_ERR__LOG_TRUNCATION = (- 139),\n  RD_KAFKA_RESP_ERR__END = (- 100),\n  RD_KAFKA_RESP_ERR_UNKNOWN = (- 1),\n  RD_KAFKA_RESP_ERR_NO_ERROR = 0,\n  RD_KAFKA_RESP_ERR_OFFSET_OUT_OF_RANGE = 1,\n  RD_KAFKA_RESP_ERR_INVALID_MSG = 2,\n  RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART = 3,\n  RD_KAFKA_RESP_ERR_INVALID_MSG_SIZE = 4,\n  RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE = 5,\n  RD_KAFKA_RESP_ERR_NOT_LEADER_FOR_PARTITION = 6,\n  RD_KAFKA_RESP_ERR_REQUEST_TIMED_OUT = 7,\n  RD_KAFKA_RESP_ERR_BROKER_NOT_AVAILABLE = 8,\n  RD_KAFKA_RESP_ERR_REPLICA_NOT_AVAILABLE = 9,\n  RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE = 10,\n  RD_KAFKA_RESP_ERR_STALE_CTRL_EPOCH = 11,\n  RD_KAFKA_RESP_ERR_OFFSET_METADATA_TOO_LARGE = 12,\n  RD_KAFKA_RESP_ERR_NETWORK_EXCEPTION = 13,\n  RD_KAFKA_RESP_ERR_COORDINATOR_LOAD_IN_PROGRESS = 14,\n  RD_KAFKA_RESP_ERR_COORDINATOR_NOT_AVAILABLE = 15,\n  RD_KAFKA_RESP_ERR_NOT_COORDINATOR = 16,\n  RD_KAFKA_RESP_ERR_TOPIC_EXCEPTION = 17,\n  RD_KAFKA_RESP_ERR_RECORD_LIST_TOO_LARGE = 18,\n  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS = 19,\n  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS_AFTER_APPEND = 20,\n  RD_KAFKA_RESP_ERR_INVALID_REQUIRED_ACKS = 21,\n  RD_KAFKA_RESP_ERR_ILLEGAL_GENERATION = 22,\n  RD_KAFKA_RESP_ERR_INCONSISTENT_GROUP_PROTOCOL = 23,\n  RD_KAFKA_RESP_ERR_INVALID_GROUP_ID = 24,\n  RD_KAFKA_RESP_ERR_UNKNOWN_MEMBER_ID = 25,\n  RD_KAFKA_RESP_ERR_INVALID_SESSION_TIMEOUT = 26,\n  RD_KAFKA_RESP_ERR_REBALANCE_IN_PROGRESS = 27,\n  RD_KAFKA_RESP_ERR_INVALID_COMMIT_OFFSET_SIZE = 28,\n  RD_KAFKA_RESP_ERR_TOPIC_AUTHORIZATION_FAILED = 29,\n  RD_KAFKA_RESP_ERR_GROUP_AUTHORIZATION_FAILED = 30,\n  RD_KAFKA_RESP_ERR_CLUSTER_AUTHORIZATION_FAILED = 31,\n  RD_KAFKA_RESP_ERR_INVALID_TIMESTAMP = 32,\n  RD_KAFKA_RESP_ERR_UNSUPPORTED_SASL_MECHANISM = 33,\n  RD_KAFKA_RESP_ERR_ILLEGAL_SASL_STATE = 34,\n  RD_KAFKA_RESP_ERR_UNSUPPORTED_VERSION = 35,\n  RD_KAFKA_RESP_ERR_TOPIC_ALREADY_EXISTS = 36,\n  RD_KAFKA_RESP_ERR_INVALID_PARTITIONS = 37,\n  RD_KAFKA_RESP_ERR_INVALID_REPLICATION_FACTOR = 38,\n  RD_KAFKA_RESP_ERR_INVALID_REPLICA_ASSIGNMENT = 39,\n  RD_KAFKA_RESP_ERR_INVALID_CONFIG = 40,\n  RD_KAFKA_RESP_ERR_NOT_CONTROLLER = 41,\n  RD_KAFKA_RESP_ERR_INVALID_REQUEST = 42,\n  RD_KAFKA_RESP_ERR_UNSUPPORTED_FOR_MESSAGE_FORMAT = 43,\n  RD_KAFKA_RESP_ERR_POLICY_VIOLATION = 44,\n  RD_KAFKA_RESP_ERR_OUT_OF_ORDER_SEQUENCE_NUMBER = 45,\n  RD_KAFKA_RESP_ERR_DUPLICATE_SEQUENCE_NUMBER = 46,\n  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_EPOCH = 47,\n  RD_KAFKA_RESP_ERR_INVALID_TXN_STATE = 48,\n  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_ID_MAPPING = 49,\n  RD_KAFKA_RESP_ERR_INVALID_TRANSACTION_TIMEOUT = 50,\n  RD_KAFKA_RESP_ERR_CONCURRENT_TRANSACTIONS = 51,\n  RD_KAFKA_RESP_ERR_TRANSACTION_COORDINATOR_FENCED = 52,\n  RD_KAFKA_RESP_ERR_TRANSACTIONAL_ID_AUTHORIZATION_FAILED = 53,\n  RD_KAFKA_RESP_ERR_SECURITY_DISABLED = 54,\n  RD_KAFKA_RESP_ERR_OPERATION_NOT_ATTEMPTED = 55,\n  RD_KAFKA_RESP_ERR_KAFKA_STORAGE_ERROR = 56,\n  RD_KAFKA_RESP_ERR_LOG_DIR_NOT_FOUND = 57,\n  RD_KAFKA_RESP_ERR_SASL_AUTHENTICATION_FAILED = 58,\n  RD_KAFKA_RESP_ERR_UNKNOWN_PRODUCER_ID = 59,\n  RD_KAFKA_RESP_ERR_REASSIGNMENT_IN_PROGRESS = 60,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTH_DISABLED = 61,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_NOT_FOUND = 62,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_OWNER_MISMATCH = 63,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_REQUEST_NOT_ALLOWED = 64,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTHORIZATION_FAILED = 65,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_EXPIRED = 66,\n  RD_KAFKA_RESP_ERR_INVALID_PRINCIPAL_TYPE = 67,\n  RD_KAFKA_RESP_ERR_NON_EMPTY_GROUP = 68,\n  RD_KAFKA_RESP_ERR_GROUP_ID_NOT_FOUND = 69,\n  RD_KAFKA_RESP_ERR_FETCH_SESSION_ID_NOT_FOUND = 70,\n  RD_KAFKA_RESP_ERR_INVALID_FETCH_SESSION_EPOCH = 71,\n  RD_KAFKA_RESP_ERR_LISTENER_NOT_FOUND = 72,\n  RD_KAFKA_RESP_ERR_TOPIC_DELETION_DISABLED = 73,\n  RD_KAFKA_RESP_ERR_FENCED_LEADER_EPOCH = 74,\n  RD_KAFKA_RESP_ERR_UNKNOWN_LEADER_EPOCH = 75,\n  RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76,\n  RD_KAFKA_RESP_ERR_STALE_BROKER_EPOCH = 77,\n  RD_KAFKA_RESP_ERR_OFFSET_NOT_AVAILABLE = 78,\n  RD_KAFKA_RESP_ERR_MEMBER_ID_REQUIRED = 79,\n  RD_KAFKA_RESP_ERR_PREFERRED_LEADER_NOT_AVAILABLE = 80,\n  RD_KAFKA_RESP_ERR_GROUP_MAX_SIZE_REACHED = 81,\n  RD_KAFKA_RESP_ERR_FENCED_INSTANCE_ID = 82,\n  RD_KAFKA_RESP_ERR_ELIGIBLE_LEADERS_NOT_AVAILABLE = 83,\n  RD_KAFKA_RESP_ERR_ELECTION_NOT_NEEDED = 84,\n  RD_KAFKA_RESP_ERR_NO_REASSIGNMENT_IN_PROGRESS = 85,\n  RD_KAFKA_RESP_ERR_GROUP_SUBSCRIBED_TO_TOPIC = 86,\n  RD_KAFKA_RESP_ERR_INVALID_RECORD = 87,\n  RD_KAFKA_RESP_ERR_UNSTABLE_OFFSET_COMMIT = 88,\n  RD_KAFKA_RESP_ERR_THROTTLING_QUOTA_EXCEEDED = 89,\n  RD_KAFKA_RESP_ERR_PRODUCER_FENCED = 90,\n  RD_KAFKA_RESP_ERR_RESOURCE_NOT_FOUND = 91,\n  RD_KAFKA_RESP_ERR_DUPLICATE_RESOURCE = 92,\n  RD_KAFKA_RESP_ERR_UNACCEPTABLE_CREDENTIAL = 93,\n  RD_KAFKA_RESP_ERR_INCONSISTENT_VOTER_SET = 94,\n  RD_KAFKA_RESP_ERR_INVALID_UPDATE_VERSION = 95,\n  RD_KAFKA_RESP_ERR_FEATURE_UPDATE_FAILED = 96,\n  RD_KAFKA_RESP_ERR_PRINCIPAL_DESERIALIZATION_FAILURE = 97,\n  RD_KAFKA_RESP_ERR_END_ALL,\n} rd_kafka_resp_err_t;\nstruct rd_kafka_err_desc {\n  rd_kafka_resp_err_t code;\n  char *name;\n  char *desc;\n};\nvoid rd_kafka_get_err_descs(const struct rd_kafka_err_desc **errdescs, size_t *cntp);\nconst char *rd_kafka_err2str(rd_kafka_resp_err_t err);\nconst char *rd_kafka_err2name(rd_kafka_resp_err_t err);\nrd_kafka_resp_err_t rd_kafka_last_error(void);\nrd_kafka_resp_err_t rd_kafka_errno2err(int errnox);\nint rd_kafka_errno(void);\nrd_kafka_resp_err_t rd_kafka_fatal_error(rd_kafka_t *rk, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_test_fatal_error(rd_kafka_t *rk, rd_kafka_resp_err_t err, const char *reason);\nrd_kafka_resp_err_t rd_kafka_error_code(const rd_kafka_error_t *error);\nconst char *rd_kafka_error_name(const rd_kafka_error_t *error);\nconst char *rd_kafka_error_string(const rd_kafka_error_t *error);\nint rd_kafka_error_is_fatal(const rd_kafka_error_t *error);\nint rd_kafka_error_is_retriable(const rd_kafka_error_t *error);\nint rd_kafka_error_txn_requires_abort(const rd_kafka_error_t *error);\nvoid rd_kafka_error_destroy(rd_kafka_error_t *error);\nrd_kafka_error_t *rd_kafka_error_new(rd_kafka_resp_err_t code, const char *fmt, ...);\ntypedef struct rd_kafka_topic_partition_s {\n  char *topic;\n  int32_t partition;\n  int64_t offset;\n  void *metadata;\n  size_t metadata_size;\n  void *opaque;\n  rd_kafka_resp_err_t err;\n  void *_private;\n} rd_kafka_topic_partition_t;\nvoid rd_kafka_topic_partition_destroy(rd_kafka_topic_partition_t *rktpar);\nvoid rd_kafka_topic_partition_set_leader_epoch(rd_kafka_topic_partition_t *rktpar, int32_t leader_epoch);\nint32_t rd_kafka_topic_partition_get_leader_epoch(const rd_kafka_topic_partition_t *rktpar);\ntypedef struct rd_kafka_topic_partition_list_s {\n  int cnt;\n  int size;\n  rd_kafka_topic_partition_t *elems;\n} rd_kafka_topic_partition_list_t;\nrd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_new(int size);\nvoid rd_kafka_topic_partition_list_destroy(rd_kafka_topic_partition_list_t *rkparlist);\nrd_kafka_topic_partition_t *rd_kafka_topic_partition_list_add(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);\nvoid rd_kafka_topic_partition_list_add_range(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t start, int32_t stop);\nint rd_kafka_topic_partition_list_del(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);\nint rd_kafka_topic_partition_list_del_by_idx(rd_kafka_topic_partition_list_t *rktparlist, int idx);\nrd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_copy(const rd_kafka_topic_partition_list_t *src);\nrd_kafka_resp_err_t rd_kafka_topic_partition_list_set_offset(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition, int64_t offset);\nrd_kafka_topic_partition_t *rd_kafka_topic_partition_list_find(const rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);\nvoid rd_kafka_topic_partition_list_sort(rd_kafka_topic_partition_list_t *rktparlist, int (*cmp)(const void *a, const void *b, void *cmp_opaque), void *cmp_opaque);\ntypedef enum rd_kafka_vtype_t {\n  RD_KAFKA_VTYPE_END,\n  RD_KAFKA_VTYPE_TOPIC,\n  RD_KAFKA_VTYPE_RKT,\n  RD_KAFKA_VTYPE_PARTITION,\n  RD_KAFKA_VTYPE_VALUE,\n  RD_KAFKA_VTYPE_KEY,\n  RD_KAFKA_VTYPE_OPAQUE,\n  RD_KAFKA_VTYPE_MSGFLAGS,\n  RD_KAFKA_VTYPE_TIMESTAMP,\n  RD_KAFKA_VTYPE_HEADER,\n  RD_KAFKA_VTYPE_HEADERS,\n} rd_kafka_vtype_t;\ntypedef struct rd_kafka_vu_s {\n  rd_kafka_vtype_t vtype;\n  union {\n    char *cstr;\n    rd_kafka_topic_t *rkt;\n    int i;\n    int32_t i32;\n    int64_t i64;\n    struct {\n      void *ptr;\n      size_t size;\n    } mem;\n    struct {\n      char *name;\n      void *val;\n      ssize_t size;\n    } header;\n    rd_kafka_headers_t *headers;\n    void *ptr;\n    char _pad[64];\n  } u;\n} rd_kafka_vu_t;\nrd_kafka_headers_t *rd_kafka_headers_new(size_t initial_count);\nvoid rd_kafka_headers_destroy(rd_kafka_headers_t *hdrs);\nrd_kafka_headers_t *rd_kafka_headers_copy(const rd_kafka_headers_t *src);\nrd_kafka_resp_err_t rd_kafka_header_add(rd_kafka_headers_t *hdrs, const char *name, ssize_t name_size, const void *value, ssize_t value_size);\nrd_kafka_resp_err_t rd_kafka_header_remove(rd_kafka_headers_t *hdrs, const char *name);\nrd_kafka_resp_err_t rd_kafka_header_get_last(const rd_kafka_headers_t *hdrs, const char *name, const void **valuep, size_t *sizep);\nrd_kafka_resp_err_t rd_kafka_header_get(const rd_kafka_headers_t *hdrs, size_t idx, const char *name, const void **valuep, size_t *sizep);\nrd_kafka_resp_err_t rd_kafka_header_get_all(const rd_kafka_headers_t *hdrs, size_t idx, const char **namep, const void **valuep, size_t *sizep);\ntypedef struct rd_kafka_message_s {\n  rd_kafka_resp_err_t err;\n  rd_kafka_topic_t *rkt;\n  int32_t partition;\n  void *payload;\n  size_t len;\n  void *key;\n  size_t key_len;\n  int64_t offset;\n  void *_private;\n} rd_kafka_message_t;\nvoid rd_kafka_message_destroy(rd_kafka_message_t *rkmessage);\nconst char *rd_kafka_message_errstr(const rd_kafka_message_t *rkmessage);\nint64_t rd_kafka_message_timestamp(const rd_kafka_message_t *rkmessage, rd_kafka_timestamp_type_t *tstype);\nint64_t rd_kafka_message_latency(const rd_kafka_message_t *rkmessage);\nint32_t rd_kafka_message_broker_id(const rd_kafka_message_t *rkmessage);\nrd_kafka_resp_err_t rd_kafka_message_headers(const rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);\nrd_kafka_resp_err_t rd_kafka_message_detach_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);\nvoid rd_kafka_message_set_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t *hdrs);\nsize_t rd_kafka_header_cnt(const rd_kafka_headers_t *hdrs);\ntypedef enum {\n  RD_KAFKA_MSG_STATUS_NOT_PERSISTED = 0,\n  RD_KAFKA_MSG_STATUS_POSSIBLY_PERSISTED = 1,\n  RD_KAFKA_MSG_STATUS_PERSISTED = 2,\n} rd_kafka_msg_status_t;\nrd_kafka_msg_status_t rd_kafka_message_status(const rd_kafka_message_t *rkmessage);\nint32_t rd_kafka_message_leader_epoch(const rd_kafka_message_t *rkmessage);\ntypedef enum {\n  RD_KAFKA_CONF_UNKNOWN = (- 2),\n  RD_KAFKA_CONF_INVALID = (- 1),\n  RD_KAFKA_CONF_OK = 0,\n} rd_kafka_conf_res_t;\nrd_kafka_conf_t *rd_kafka_conf_new(void);\nvoid rd_kafka_conf_destroy(rd_kafka_conf_t *conf);\nrd_kafka_conf_t *rd_kafka_conf_dup(const rd_kafka_conf_t *conf);\nrd_kafka_conf_t *rd_kafka_conf_dup_filter(const rd_kafka_conf_t *conf, size_t filter_cnt, const char **filter);\nconst rd_kafka_conf_t *rd_kafka_conf(rd_kafka_t *rk);\nrd_kafka_conf_res_t rd_kafka_conf_set(rd_kafka_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);\nvoid rd_kafka_conf_set_events(rd_kafka_conf_t *conf, int events);\nvoid rd_kafka_conf_set_background_event_cb(rd_kafka_conf_t *conf, void (*event_cb)(rd_kafka_t *rk, rd_kafka_event_t *rkev, void *opaque));\nvoid rd_kafka_conf_set_dr_cb(rd_kafka_conf_t *conf, void (*dr_cb)(rd_kafka_t *rk, void *payload, size_t len, rd_kafka_resp_err_t err, void *opaque, void *msg_opaque));\nvoid rd_kafka_conf_set_dr_msg_cb(rd_kafka_conf_t *conf, void (*dr_msg_cb)(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, void *opaque));\nvoid rd_kafka_conf_set_consume_cb(rd_kafka_conf_t *conf, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *opaque));\nvoid rd_kafka_conf_set_rebalance_cb(rd_kafka_conf_t *conf, void (*rebalance_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *partitions, void *opaque));\nvoid rd_kafka_conf_set_offset_commit_cb(rd_kafka_conf_t *conf, void (*offset_commit_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *opaque));\nvoid rd_kafka_conf_set_error_cb(rd_kafka_conf_t *conf, void (*error_cb)(rd_kafka_t *rk, int err, const char *reason, void *opaque));\nvoid rd_kafka_conf_set_throttle_cb(rd_kafka_conf_t *conf, void (*throttle_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int throttle_time_ms, void *opaque));\nvoid rd_kafka_conf_set_log_cb(rd_kafka_conf_t *conf, void (*log_cb)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));\nvoid rd_kafka_conf_set_stats_cb(rd_kafka_conf_t *conf, int (*stats_cb)(rd_kafka_t *rk, char *json, size_t json_len, void *opaque));\nvoid rd_kafka_conf_set_oauthbearer_token_refresh_cb(rd_kafka_conf_t *conf, void (*oauthbearer_token_refresh_cb)(rd_kafka_t *rk, const char *oauthbearer_config, void *opaque));\nvoid rd_kafka_conf_enable_sasl_queue(rd_kafka_conf_t *conf, int enable);\nvoid rd_kafka_conf_set_socket_cb(rd_kafka_conf_t *conf, int (*socket_cb)(int domain, int type, int protocol, void *opaque));\nvoid rd_kafka_conf_set_connect_cb(rd_kafka_conf_t *conf, int (*connect_cb)(int sockfd, const struct sockaddr *addr, int addrlen, const char *id, void *opaque));\nvoid rd_kafka_conf_set_closesocket_cb(rd_kafka_conf_t *conf, int (*closesocket_cb)(int sockfd, void *opaque));\nstruct addrinfo;\nvoid rd_kafka_conf_set_resolve_cb(rd_kafka_conf_t *conf, int (*resolve_cb)(const char *node, const char *service, const struct addrinfo *hints, struct addrinfo **res, void *opaque));\nrd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert_verify_cb(rd_kafka_conf_t *conf, int (*ssl_cert_verify_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int *x509_error, int depth, const char *buf, size_t size, char *errstr, size_t errstr_size, void *opaque));\ntypedef enum rd_kafka_cert_type_t {\n  RD_KAFKA_CERT_PUBLIC_KEY,\n  RD_KAFKA_CERT_PRIVATE_KEY,\n  RD_KAFKA_CERT_CA,\n  RD_KAFKA_CERT__CNT,\n} rd_kafka_cert_type_t;\ntypedef enum rd_kafka_cert_enc_t {\n  RD_KAFKA_CERT_ENC_PKCS12,\n  RD_KAFKA_CERT_ENC_DER,\n  RD_KAFKA_CERT_ENC_PEM,\n  RD_KAFKA_CERT_ENC__CNT,\n} rd_kafka_cert_enc_t;\nrd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert(rd_kafka_conf_t *conf, rd_kafka_cert_type_t cert_type, rd_kafka_cert_enc_t cert_enc, const void *buffer, size_t size, char *errstr, size_t errstr_size);\nvoid rd_kafka_conf_set_engine_callback_data(rd_kafka_conf_t *conf, void *callback_data);\nvoid rd_kafka_conf_set_opaque(rd_kafka_conf_t *conf, void *opaque);\nvoid *rd_kafka_opaque(const rd_kafka_t *rk);\nvoid rd_kafka_conf_set_default_topic_conf(rd_kafka_conf_t *conf, rd_kafka_topic_conf_t *tconf);\nrd_kafka_topic_conf_t *rd_kafka_conf_get_default_topic_conf(rd_kafka_conf_t *conf);\nrd_kafka_conf_res_t rd_kafka_conf_get(const rd_kafka_conf_t *conf, const char *name, char *dest, size_t *dest_size);\nrd_kafka_conf_res_t rd_kafka_topic_conf_get(const rd_kafka_topic_conf_t *conf, const char *name, char *dest, size_t *dest_size);\nconst char **rd_kafka_conf_dump(rd_kafka_conf_t *conf, size_t *cntp);\nconst char **rd_kafka_topic_conf_dump(rd_kafka_topic_conf_t *conf, size_t *cntp);\nvoid rd_kafka_conf_dump_free(const char **arr, size_t cnt);\nvoid rd_kafka_conf_properties_show(FILE *fp);\nrd_kafka_topic_conf_t *rd_kafka_topic_conf_new(void);\nrd_kafka_topic_conf_t *rd_kafka_topic_conf_dup(const rd_kafka_topic_conf_t *conf);\nrd_kafka_topic_conf_t *rd_kafka_default_topic_conf_dup(rd_kafka_t *rk);\nvoid rd_kafka_topic_conf_destroy(rd_kafka_topic_conf_t *topic_conf);\nrd_kafka_conf_res_t rd_kafka_topic_conf_set(rd_kafka_topic_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);\nvoid rd_kafka_topic_conf_set_opaque(rd_kafka_topic_conf_t *conf, void *rkt_opaque);\nvoid rd_kafka_topic_conf_set_partitioner_cb(rd_kafka_topic_conf_t *topic_conf, int32_t (*partitioner)(const rd_kafka_topic_t *rkt, const void *keydata, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque));\nvoid rd_kafka_topic_conf_set_msg_order_cmp(rd_kafka_topic_conf_t *topic_conf, int (*msg_order_cmp)(const rd_kafka_message_t *a, const rd_kafka_message_t *b));\nint rd_kafka_topic_partition_available(const rd_kafka_topic_t *rkt, int32_t partition);\nint32_t rd_kafka_msg_partitioner_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_consistent(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_consistent_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_murmur2(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_murmur2_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_fnv1a(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_fnv1a_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nrd_kafka_t *rd_kafka_new(rd_kafka_type_t type, rd_kafka_conf_t *conf, char *errstr, size_t errstr_size);\nvoid rd_kafka_destroy(rd_kafka_t *rk);\nvoid rd_kafka_destroy_flags(rd_kafka_t *rk, int flags);\nconst char *rd_kafka_name(const rd_kafka_t *rk);\nrd_kafka_type_t rd_kafka_type(const rd_kafka_t *rk);\nchar *rd_kafka_memberid(const rd_kafka_t *rk);\nchar *rd_kafka_clusterid(rd_kafka_t *rk, int timeout_ms);\nint32_t rd_kafka_controllerid(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_topic_t *rd_kafka_topic_new(rd_kafka_t *rk, const char *topic, rd_kafka_topic_conf_t *conf);\nvoid rd_kafka_topic_destroy(rd_kafka_topic_t *rkt);\nconst char *rd_kafka_topic_name(const rd_kafka_topic_t *rkt);\nvoid *rd_kafka_topic_opaque(const rd_kafka_topic_t *rkt);\nint rd_kafka_poll(rd_kafka_t *rk, int timeout_ms);\nvoid rd_kafka_yield(rd_kafka_t *rk);\nrd_kafka_resp_err_t rd_kafka_pause_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_resp_err_t rd_kafka_resume_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_resp_err_t rd_kafka_query_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high, int timeout_ms);\nrd_kafka_resp_err_t rd_kafka_get_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high);\nrd_kafka_resp_err_t rd_kafka_offsets_for_times(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets, int timeout_ms);\nvoid *rd_kafka_mem_calloc(rd_kafka_t *rk, size_t num, size_t size);\nvoid *rd_kafka_mem_malloc(rd_kafka_t *rk, size_t size);\nvoid rd_kafka_mem_free(rd_kafka_t *rk, void *ptr);\nrd_kafka_queue_t *rd_kafka_queue_new(rd_kafka_t *rk);\nvoid rd_kafka_queue_destroy(rd_kafka_queue_t *rkqu);\nrd_kafka_queue_t *rd_kafka_queue_get_main(rd_kafka_t *rk);\nrd_kafka_queue_t *rd_kafka_queue_get_sasl(rd_kafka_t *rk);\nrd_kafka_error_t *rd_kafka_sasl_background_callbacks_enable(rd_kafka_t *rk);\nrd_kafka_error_t *rd_kafka_sasl_set_credentials(rd_kafka_t *rk, const char *username, const char *password);\nrd_kafka_queue_t *rd_kafka_queue_get_consumer(rd_kafka_t *rk);\nrd_kafka_queue_t *rd_kafka_queue_get_partition(rd_kafka_t *rk, const char *topic, int32_t partition);\nrd_kafka_queue_t *rd_kafka_queue_get_background(rd_kafka_t *rk);\nvoid rd_kafka_queue_forward(rd_kafka_queue_t *src, rd_kafka_queue_t *dst);\nrd_kafka_resp_err_t rd_kafka_set_log_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu);\nsize_t rd_kafka_queue_length(rd_kafka_queue_t *rkqu);\nvoid rd_kafka_queue_io_event_enable(rd_kafka_queue_t *rkqu, int fd, const void *payload, size_t size);\nvoid rd_kafka_queue_cb_event_enable(rd_kafka_queue_t *rkqu, void (*event_cb)(rd_kafka_t *rk, void *qev_opaque), void *qev_opaque);\nvoid rd_kafka_queue_yield(rd_kafka_queue_t *rkqu);\nint rd_kafka_consume_start(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);\nint rd_kafka_consume_start_queue(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, rd_kafka_queue_t *rkqu);\nint rd_kafka_consume_stop(rd_kafka_topic_t *rkt, int32_t partition);\nrd_kafka_resp_err_t rd_kafka_seek(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, int timeout_ms);\nrd_kafka_error_t *rd_kafka_seek_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms);\nrd_kafka_message_t *rd_kafka_consume(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms);\nssize_t rd_kafka_consume_batch(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);\nint rd_kafka_consume_callback(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);\nrd_kafka_message_t *rd_kafka_consume_queue(rd_kafka_queue_t *rkqu, int timeout_ms);\nssize_t rd_kafka_consume_batch_queue(rd_kafka_queue_t *rkqu, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);\nint rd_kafka_consume_callback_queue(rd_kafka_queue_t *rkqu, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);\nrd_kafka_resp_err_t rd_kafka_offset_store(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);\nrd_kafka_resp_err_t rd_kafka_offsets_store(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets);\nrd_kafka_error_t *rd_kafka_offset_store_message(rd_kafka_message_t *rkmessage);\nrd_kafka_resp_err_t rd_kafka_subscribe(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *topics);\nrd_kafka_resp_err_t rd_kafka_unsubscribe(rd_kafka_t *rk);\nrd_kafka_resp_err_t rd_kafka_subscription(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **topics);\nrd_kafka_message_t *rd_kafka_consumer_poll(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_resp_err_t rd_kafka_consumer_close(rd_kafka_t *rk);\nrd_kafka_error_t *rd_kafka_consumer_close_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu);\nint rd_kafka_consumer_closed(rd_kafka_t *rk);\nrd_kafka_error_t *rd_kafka_incremental_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_error_t *rd_kafka_incremental_unassign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);\nconst char *rd_kafka_rebalance_protocol(rd_kafka_t *rk);\nrd_kafka_resp_err_t rd_kafka_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_resp_err_t rd_kafka_assignment(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **partitions);\nint rd_kafka_assignment_lost(rd_kafka_t *rk);\nrd_kafka_resp_err_t rd_kafka_commit(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, int async);\nrd_kafka_resp_err_t rd_kafka_commit_message(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, int async);\nrd_kafka_resp_err_t rd_kafka_commit_queue(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_queue_t *rkqu, void (*cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *commit_opaque), void *commit_opaque);\nrd_kafka_resp_err_t rd_kafka_committed(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms);\nrd_kafka_resp_err_t rd_kafka_position(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata(rd_kafka_t *rk);\nrd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata_new(const char *group_id);\nrd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata_new_with_genid(const char *group_id, int32_t generation_id, const char *member_id, const char *group_instance_id);\nvoid rd_kafka_consumer_group_metadata_destroy(rd_kafka_consumer_group_metadata_t *);\nrd_kafka_error_t *rd_kafka_consumer_group_metadata_write(const rd_kafka_consumer_group_metadata_t *cgmd, void **bufferp, size_t *sizep);\nrd_kafka_error_t *rd_kafka_consumer_group_metadata_read(rd_kafka_consumer_group_metadata_t **cgmdp, const void *buffer, size_t size);\nint rd_kafka_produce(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, void *payload, size_t len, const void *key, size_t keylen, void *msg_opaque);\nrd_kafka_resp_err_t rd_kafka_producev(rd_kafka_t *rk, ...);\nrd_kafka_error_t *rd_kafka_produceva(rd_kafka_t *rk, const rd_kafka_vu_t *vus, size_t cnt);\nint rd_kafka_produce_batch(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, rd_kafka_message_t *rkmessages, int message_cnt);\nrd_kafka_resp_err_t rd_kafka_flush(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_resp_err_t rd_kafka_purge(rd_kafka_t *rk, int purge_flags);\ntypedef struct rd_kafka_metadata_broker {\n  int32_t id;\n  char *host;\n  int port;\n} rd_kafka_metadata_broker_t;\ntypedef struct rd_kafka_metadata_partition {\n  int32_t id;\n  rd_kafka_resp_err_t err;\n  int32_t leader;\n  int replica_cnt;\n  int32_t *replicas;\n  int isr_cnt;\n  int32_t *isrs;\n} rd_kafka_metadata_partition_t;\ntypedef struct rd_kafka_metadata_topic {\n  char *topic;\n  int partition_cnt;\n  struct rd_kafka_metadata_partition *partitions;\n  rd_kafka_resp_err_t err;\n} rd_kafka_metadata_topic_t;\ntypedef struct rd_kafka_metadata {\n  int broker_cnt;\n  struct rd_kafka_metadata_broker *brokers;\n  int topic_cnt;\n  struct rd_kafka_metadata_topic *topics;\n  int32_t orig_broker_id;\n  char *orig_broker_name;\n} rd_kafka_metadata_t;\nrd_kafka_resp_err_t rd_kafka_metadata(rd_kafka_t *rk, int all_topics, rd_kafka_topic_t *only_rkt, const struct rd_kafka_metadata **metadatap, int timeout_ms);\nvoid rd_kafka_metadata_destroy(const struct rd_kafka_metadata *metadata);\ntypedef struct rd_kafka_Node_s rd_kafka_Node_t;\nint rd_kafka_Node_id(const rd_kafka_Node_t *node);\nconst char *rd_kafka_Node_host(const rd_kafka_Node_t *node);\nuint16_t rd_kafka_Node_port(const rd_kafka_Node_t *node);\nstruct rd_kafka_group_member_info {\n  char *member_id;\n  char *client_id;\n  char *client_host;\n  void *member_metadata;\n  int member_metadata_size;\n  void *member_assignment;\n  int member_assignment_size;\n};\ntypedef enum {\n  RD_KAFKA_CONSUMER_GROUP_STATE_UNKNOWN = 0,\n  RD_KAFKA_CONSUMER_GROUP_STATE_PREPARING_REBALANCE = 1,\n  RD_KAFKA_CONSUMER_GROUP_STATE_COMPLETING_REBALANCE = 2,\n  RD_KAFKA_CONSUMER_GROUP_STATE_STABLE = 3,\n  RD_KAFKA_CONSUMER_GROUP_STATE_DEAD = 4,\n  RD_KAFKA_CONSUMER_GROUP_STATE_EMPTY = 5,\n  RD_KAFKA_CONSUMER_GROUP_STATE__CNT,\n} rd_kafka_consumer_group_state_t;\nstruct rd_kafka_group_info {\n  struct rd_kafka_metadata_broker broker;\n  char *group;\n  rd_kafka_resp_err_t err;\n  char *state;\n  char *protocol_type;\n  char *protocol;\n  struct rd_kafka_group_member_info *members;\n  int member_cnt;\n};\nstruct rd_kafka_group_list {\n  struct rd_kafka_group_info *groups;\n  int group_cnt;\n};\nrd_kafka_resp_err_t rd_kafka_list_groups(rd_kafka_t *rk, const char *group, const struct rd_kafka_group_list **grplistp, int timeout_ms);\nconst char *rd_kafka_consumer_group_state_name(rd_kafka_consumer_group_state_t state);\nrd_kafka_consumer_group_state_t rd_kafka_consumer_group_state_code(const char *name);\nvoid rd_kafka_group_list_destroy(const struct rd_kafka_group_list *grplist);\nint rd_kafka_brokers_add(rd_kafka_t *rk, const char *brokerlist);\nvoid rd_kafka_set_logger(rd_kafka_t *rk, void (*func)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));\nvoid rd_kafka_set_log_level(rd_kafka_t *rk, int level);\nvoid rd_kafka_log_print(const rd_kafka_t *rk, int level, const char *fac, const char *buf);\nvoid rd_kafka_log_syslog(const rd_kafka_t *rk, int level, const char *fac, const char *buf);\nint rd_kafka_outq_len(rd_kafka_t *rk);\nvoid rd_kafka_dump(FILE *fp, rd_kafka_t *rk);\nint rd_kafka_thread_cnt(void);\ntypedef enum rd_kafka_thread_type_t {\n  RD_KAFKA_THREAD_MAIN,\n  RD_KAFKA_THREAD_BACKGROUND,\n  RD_KAFKA_THREAD_BROKER,\n} rd_kafka_thread_type_t;\nint rd_kafka_wait_destroyed(int timeout_ms);\nint rd_kafka_unittest(void);\nrd_kafka_resp_err_t rd_kafka_poll_set_consumer(rd_kafka_t *rk);\ntypedef int rd_kafka_event_type_t;\nrd_kafka_event_type_t rd_kafka_event_type(const rd_kafka_event_t *rkev);\nconst char *rd_kafka_event_name(const rd_kafka_event_t *rkev);\nvoid rd_kafka_event_destroy(rd_kafka_event_t *rkev);\nconst rd_kafka_message_t *rd_kafka_event_message_next(rd_kafka_event_t *rkev);\nsize_t rd_kafka_event_message_array(rd_kafka_event_t *rkev, const rd_kafka_message_t **rkmessages, size_t size);\nsize_t rd_kafka_event_message_count(rd_kafka_event_t *rkev);\nconst char *rd_kafka_event_config_string(rd_kafka_event_t *rkev);\nrd_kafka_resp_err_t rd_kafka_event_error(rd_kafka_event_t *rkev);\nconst char *rd_kafka_event_error_string(rd_kafka_event_t *rkev);\nint rd_kafka_event_error_is_fatal(rd_kafka_event_t *rkev);\nvoid *rd_kafka_event_opaque(rd_kafka_event_t *rkev);\nint rd_kafka_event_log(rd_kafka_event_t *rkev, const char **fac, const char **str, int *level);\nint rd_kafka_event_debug_contexts(rd_kafka_event_t *rkev, char *dst, size_t dstsize);\nconst char *rd_kafka_event_stats(rd_kafka_event_t *rkev);\nrd_kafka_topic_partition_list_t *rd_kafka_event_topic_partition_list(rd_kafka_event_t *rkev);\nrd_kafka_topic_partition_t *rd_kafka_event_topic_partition(rd_kafka_event_t *rkev);\ntypedef rd_kafka_event_t rd_kafka_CreateTopics_result_t;\ntypedef rd_kafka_event_t rd_kafka_DeleteTopics_result_t;\ntypedef rd_kafka_event_t rd_kafka_CreateAcls_result_t;\ntypedef rd_kafka_event_t rd_kafka_DescribeAcls_result_t;\ntypedef rd_kafka_event_t rd_kafka_DeleteAcls_result_t;\ntypedef rd_kafka_event_t rd_kafka_CreatePartitions_result_t;\ntypedef rd_kafka_event_t rd_kafka_AlterConfigs_result_t;\ntypedef rd_kafka_event_t rd_kafka_DescribeConfigs_result_t;\ntypedef rd_kafka_event_t rd_kafka_DeleteRecords_result_t;\ntypedef rd_kafka_event_t rd_kafka_ListConsumerGroups_result_t;\ntypedef rd_kafka_event_t rd_kafka_DescribeConsumerGroups_result_t;\ntypedef rd_kafka_event_t rd_kafka_DeleteGroups_result_t;\ntypedef rd_kafka_event_t rd_kafka_DeleteConsumerGroupOffsets_result_t;\ntypedef rd_kafka_event_t rd_kafka_AlterConsumerGroupOffsets_result_t;\ntypedef rd_kafka_event_t rd_kafka_ListConsumerGroupOffsets_result_t;\nconst rd_kafka_CreateTopics_result_t *rd_kafka_event_CreateTopics_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DeleteTopics_result_t *rd_kafka_event_DeleteTopics_result(rd_kafka_event_t *rkev);\nconst rd_kafka_CreatePartitions_result_t *rd_kafka_event_CreatePartitions_result(rd_kafka_event_t *rkev);\nconst rd_kafka_AlterConfigs_result_t *rd_kafka_event_AlterConfigs_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DescribeConfigs_result_t *rd_kafka_event_DescribeConfigs_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DeleteRecords_result_t *rd_kafka_event_DeleteRecords_result(rd_kafka_event_t *rkev);\nconst rd_kafka_ListConsumerGroups_result_t *rd_kafka_event_ListConsumerGroups_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DescribeConsumerGroups_result_t *rd_kafka_event_DescribeConsumerGroups_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DeleteGroups_result_t *rd_kafka_event_DeleteGroups_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DeleteConsumerGroupOffsets_result_t *rd_kafka_event_DeleteConsumerGroupOffsets_result(rd_kafka_event_t *rkev);\nconst rd_kafka_CreateAcls_result_t *rd_kafka_event_CreateAcls_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DescribeAcls_result_t *rd_kafka_event_DescribeAcls_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DeleteAcls_result_t *rd_kafka_event_DeleteAcls_result(rd_kafka_event_t *rkev);\nconst rd_kafka_AlterConsumerGroupOffsets_result_t *rd_kafka_event_AlterConsumerGroupOffsets_result(rd_kafka_event_t *rkev);\nconst rd_kafka_ListConsumerGroupOffsets_result_t *rd_kafka_event_ListConsumerGroupOffsets_result(rd_kafka_event_t *rkev);\nrd_kafka_event_t *rd_kafka_queue_poll(rd_kafka_queue_t *rkqu, int timeout_ms);\nint rd_kafka_queue_poll_callback(rd_kafka_queue_t *rkqu, int timeout_ms);\ntypedef rd_kafka_resp_err_t (rd_kafka_plugin_f_conf_init_t)(rd_kafka_conf_t *conf, void **plug_opaquep, char *errstr, size_t errstr_size);\ntypedef rd_kafka_conf_res_t (rd_kafka_interceptor_f_on_conf_set_t)(rd_kafka_conf_t *conf, const char *name, const char *val, char *errstr, size_t errstr_size, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_dup_t)(rd_kafka_conf_t *new_conf, const rd_kafka_conf_t *old_conf, size_t filter_cnt, const char **filter, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_destroy_t)(void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_new_t)(rd_kafka_t *rk, const rd_kafka_conf_t *conf, void *ic_opaque, char *errstr, size_t errstr_size);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_destroy_t)(rd_kafka_t *rk, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_send_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_acknowledgement_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_consume_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_commit_t)(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_resp_err_t err, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_request_sent_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_response_received_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, int64_t rtt, rd_kafka_resp_err_t err, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_start_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_exit_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_broker_state_change_t)(rd_kafka_t *rk, int32_t broker_id, const char *secproto, const char *name, int port, const char *state, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_set(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_set_t *on_conf_set, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_dup(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_dup_t *on_conf_dup, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_destroy(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_destroy_t *on_conf_destroy, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_new(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_new_t *on_new, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_destroy(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_destroy_t *on_destroy, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_send(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_send_t *on_send, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_acknowledgement(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_acknowledgement_t *on_acknowledgement, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_consume(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_consume_t *on_consume, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_commit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_commit_t *on_commit, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_request_sent(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_request_sent_t *on_request_sent, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_response_received(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_response_received_t *on_response_received, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_start(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_start_t *on_thread_start, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_exit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_exit_t *on_thread_exit, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_broker_state_change(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_broker_state_change_t *on_broker_state_change, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_topic_result_error(const rd_kafka_topic_result_t *topicres);\nconst char *rd_kafka_topic_result_error_string(const rd_kafka_topic_result_t *topicres);\nconst char *rd_kafka_topic_result_name(const rd_kafka_topic_result_t *topicres);\nconst rd_kafka_error_t *rd_kafka_group_result_error(const rd_kafka_group_result_t *groupres);\nconst char *rd_kafka_group_result_name(const rd_kafka_group_result_t *groupres);\nconst rd_kafka_topic_partition_list_t *rd_kafka_group_result_partitions(const rd_kafka_group_result_t *groupres);\ntypedef enum rd_kafka_admin_op_t {\n  RD_KAFKA_ADMIN_OP_ANY = 0,\n  RD_KAFKA_ADMIN_OP_CREATETOPICS,\n  RD_KAFKA_ADMIN_OP_DELETETOPICS,\n  RD_KAFKA_ADMIN_OP_CREATEPARTITIONS,\n  RD_KAFKA_ADMIN_OP_ALTERCONFIGS,\n  RD_KAFKA_ADMIN_OP_DESCRIBECONFIGS,\n  RD_KAFKA_ADMIN_OP_DELETERECORDS,\n  RD_KAFKA_ADMIN_OP_DELETEGROUPS,\n  RD_KAFKA_ADMIN_OP_DELETECONSUMERGROUPOFFSETS,\n  RD_KAFKA_ADMIN_OP_CREATEACLS,\n  RD_KAFKA_ADMIN_OP_DESCRIBEACLS,\n  RD_KAFKA_ADMIN_OP_DELETEACLS,\n  RD_KAFKA_ADMIN_OP_LISTCONSUMERGROUPS,\n  RD_KAFKA_ADMIN_OP_DESCRIBECONSUMERGROUPS,\n  RD_KAFKA_ADMIN_OP_LISTCONSUMERGROUPOFFSETS,\n  RD_KAFKA_ADMIN_OP_ALTERCONSUMERGROUPOFFSETS,\n  RD_KAFKA_ADMIN_OP__CNT,\n} rd_kafka_admin_op_t;\ntypedef struct rd_kafka_AdminOptions_s rd_kafka_AdminOptions_t;\nrd_kafka_AdminOptions_t *rd_kafka_AdminOptions_new(rd_kafka_t *rk, rd_kafka_admin_op_t for_api);\nvoid rd_kafka_AdminOptions_destroy(rd_kafka_AdminOptions_t *options);\nrd_kafka_resp_err_t rd_kafka_AdminOptions_set_request_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_AdminOptions_set_operation_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_AdminOptions_set_validate_only(rd_kafka_AdminOptions_t *options, int true_or_false, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_AdminOptions_set_broker(rd_kafka_AdminOptions_t *options, int32_t broker_id, char *errstr, size_t errstr_size);\nrd_kafka_error_t *rd_kafka_AdminOptions_set_require_stable_offsets(rd_kafka_AdminOptions_t *options, int true_or_false);\nrd_kafka_error_t *rd_kafka_AdminOptions_set_match_consumer_group_states(rd_kafka_AdminOptions_t *options, const rd_kafka_consumer_group_state_t *consumer_group_states, size_t consumer_group_states_cnt);\nvoid rd_kafka_AdminOptions_set_opaque(rd_kafka_AdminOptions_t *options, void *ev_opaque);\ntypedef struct rd_kafka_NewTopic_s rd_kafka_NewTopic_t;\nrd_kafka_NewTopic_t *rd_kafka_NewTopic_new(const char *topic, int num_partitions, int replication_factor, char *errstr, size_t errstr_size);\nvoid rd_kafka_NewTopic_destroy(rd_kafka_NewTopic_t *new_topic);\nvoid rd_kafka_NewTopic_destroy_array(rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt);\nrd_kafka_resp_err_t rd_kafka_NewTopic_set_replica_assignment(rd_kafka_NewTopic_t *new_topic, int32_t partition, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_NewTopic_set_config(rd_kafka_NewTopic_t *new_topic, const char *name, const char *value);\nvoid rd_kafka_CreateTopics(rd_kafka_t *rk, rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_topic_result_t **rd_kafka_CreateTopics_result_topics(const rd_kafka_CreateTopics_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_DeleteTopic_s rd_kafka_DeleteTopic_t;\nrd_kafka_DeleteTopic_t *rd_kafka_DeleteTopic_new(const char *topic);\nvoid rd_kafka_DeleteTopic_destroy(rd_kafka_DeleteTopic_t *del_topic);\nvoid rd_kafka_DeleteTopic_destroy_array(rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt);\nvoid rd_kafka_DeleteTopics(rd_kafka_t *rk, rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_topic_result_t **rd_kafka_DeleteTopics_result_topics(const rd_kafka_DeleteTopics_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_NewPartitions_s rd_kafka_NewPartitions_t;\nrd_kafka_NewPartitions_t *rd_kafka_NewPartitions_new(const char *topic, size_t new_total_cnt, char *errstr, size_t errstr_size);\nvoid rd_kafka_NewPartitions_destroy(rd_kafka_NewPartitions_t *new_parts);\nvoid rd_kafka_NewPartitions_destroy_array(rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt);\nrd_kafka_resp_err_t rd_kafka_NewPartitions_set_replica_assignment(rd_kafka_NewPartitions_t *new_parts, int32_t new_partition_idx, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);\nvoid rd_kafka_CreatePartitions(rd_kafka_t *rk, rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_topic_result_t **rd_kafka_CreatePartitions_result_topics(const rd_kafka_CreatePartitions_result_t *result, size_t *cntp);\ntypedef enum rd_kafka_ConfigSource_t {\n  RD_KAFKA_CONFIG_SOURCE_UNKNOWN_CONFIG = 0,\n  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_TOPIC_CONFIG = 1,\n  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_BROKER_CONFIG = 2,\n  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_DEFAULT_BROKER_CONFIG = 3,\n  RD_KAFKA_CONFIG_SOURCE_STATIC_BROKER_CONFIG = 4,\n  RD_KAFKA_CONFIG_SOURCE_DEFAULT_CONFIG = 5,\n  RD_KAFKA_CONFIG_SOURCE__CNT,\n} rd_kafka_ConfigSource_t;\nconst char *rd_kafka_ConfigSource_name(rd_kafka_ConfigSource_t confsource);\ntypedef struct rd_kafka_ConfigEntry_s rd_kafka_ConfigEntry_t;\nconst char *rd_kafka_ConfigEntry_name(const rd_kafka_ConfigEntry_t *entry);\nconst char *rd_kafka_ConfigEntry_value(const rd_kafka_ConfigEntry_t *entry);\nrd_kafka_ConfigSource_t rd_kafka_ConfigEntry_source(const rd_kafka_ConfigEntry_t *entry);\nint rd_kafka_ConfigEntry_is_read_only(const rd_kafka_ConfigEntry_t *entry);\nint rd_kafka_ConfigEntry_is_default(const rd_kafka_ConfigEntry_t *entry);\nint rd_kafka_ConfigEntry_is_sensitive(const rd_kafka_ConfigEntry_t *entry);\nint rd_kafka_ConfigEntry_is_synonym(const rd_kafka_ConfigEntry_t *entry);\nconst rd_kafka_ConfigEntry_t **rd_kafka_ConfigEntry_synonyms(const rd_kafka_ConfigEntry_t *entry, size_t *cntp);\ntypedef enum rd_kafka_ResourceType_t {\n  RD_KAFKA_RESOURCE_UNKNOWN = 0,\n  RD_KAFKA_RESOURCE_ANY = 1,\n  RD_KAFKA_RESOURCE_TOPIC = 2,\n  RD_KAFKA_RESOURCE_GROUP = 3,\n  RD_KAFKA_RESOURCE_BROKER = 4,\n  RD_KAFKA_RESOURCE__CNT,\n} rd_kafka_ResourceType_t;\ntypedef enum rd_kafka_ResourcePatternType_t {\n  RD_KAFKA_RESOURCE_PATTERN_UNKNOWN = 0,\n  RD_KAFKA_RESOURCE_PATTERN_ANY = 1,\n  RD_KAFKA_RESOURCE_PATTERN_MATCH = 2,\n  RD_KAFKA_RESOURCE_PATTERN_LITERAL = 3,\n  RD_KAFKA_RESOURCE_PATTERN_PREFIXED = 4,\n  RD_KAFKA_RESOURCE_PATTERN_TYPE__CNT,\n} rd_kafka_ResourcePatternType_t;\nconst char *rd_kafka_ResourcePatternType_name(rd_kafka_ResourcePatternType_t resource_pattern_type);\nconst char *rd_kafka_ResourceType_name(rd_kafka_ResourceType_t restype);\ntypedef struct rd_kafka_ConfigResource_s rd_kafka_ConfigResource_t;\nrd_kafka_ConfigResource_t *rd_kafka_ConfigResource_new(rd_kafka_ResourceType_t restype, const char *resname);\nvoid rd_kafka_ConfigResource_destroy(rd_kafka_ConfigResource_t *config);\nvoid rd_kafka_ConfigResource_destroy_array(rd_kafka_ConfigResource_t **config, size_t config_cnt);\nrd_kafka_resp_err_t rd_kafka_ConfigResource_set_config(rd_kafka_ConfigResource_t *config, const char *name, const char *value);\nconst rd_kafka_ConfigEntry_t **rd_kafka_ConfigResource_configs(const rd_kafka_ConfigResource_t *config, size_t *cntp);\nrd_kafka_ResourceType_t rd_kafka_ConfigResource_type(const rd_kafka_ConfigResource_t *config);\nconst char *rd_kafka_ConfigResource_name(const rd_kafka_ConfigResource_t *config);\nrd_kafka_resp_err_t rd_kafka_ConfigResource_error(const rd_kafka_ConfigResource_t *config);\nconst char *rd_kafka_ConfigResource_error_string(const rd_kafka_ConfigResource_t *config);\nvoid rd_kafka_AlterConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_ConfigResource_t **rd_kafka_AlterConfigs_result_resources(const rd_kafka_AlterConfigs_result_t *result, size_t *cntp);\nvoid rd_kafka_DescribeConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_ConfigResource_t **rd_kafka_DescribeConfigs_result_resources(const rd_kafka_DescribeConfigs_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_DeleteRecords_s rd_kafka_DeleteRecords_t;\nrd_kafka_DeleteRecords_t *rd_kafka_DeleteRecords_new(const rd_kafka_topic_partition_list_t *before_offsets);\nvoid rd_kafka_DeleteRecords_destroy(rd_kafka_DeleteRecords_t *del_records);\nvoid rd_kafka_DeleteRecords_destroy_array(rd_kafka_DeleteRecords_t **del_records, size_t del_record_cnt);\nvoid rd_kafka_DeleteRecords(rd_kafka_t *rk, rd_kafka_DeleteRecords_t **del_records, size_t del_record_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_topic_partition_list_t *rd_kafka_DeleteRecords_result_offsets(const rd_kafka_DeleteRecords_result_t *result);\ntypedef struct rd_kafka_ConsumerGroupListing_s rd_kafka_ConsumerGroupListing_t;\ntypedef struct rd_kafka_ListConsumerGroupsResult_s rd_kafka_ListConsumerGroupsResult_t;\nvoid rd_kafka_ListConsumerGroups(rd_kafka_t *rk, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst char *rd_kafka_ConsumerGroupListing_group_id(const rd_kafka_ConsumerGroupListing_t *grplist);\nint rd_kafka_ConsumerGroupListing_is_simple_consumer_group(const rd_kafka_ConsumerGroupListing_t *grplist);\nrd_kafka_consumer_group_state_t rd_kafka_ConsumerGroupListing_state(const rd_kafka_ConsumerGroupListing_t *grplist);\nconst rd_kafka_ConsumerGroupListing_t **rd_kafka_ListConsumerGroups_result_valid(const rd_kafka_ListConsumerGroups_result_t *result, size_t *cntp);\nconst rd_kafka_error_t **rd_kafka_ListConsumerGroups_result_errors(const rd_kafka_ListConsumerGroups_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_ConsumerGroupDescription_s rd_kafka_ConsumerGroupDescription_t;\ntypedef struct rd_kafka_MemberDescription_s rd_kafka_MemberDescription_t;\ntypedef struct rd_kafka_MemberAssignment_s rd_kafka_MemberAssignment_t;\nvoid rd_kafka_DescribeConsumerGroups(rd_kafka_t *rk, const char **groups, size_t groups_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_ConsumerGroupDescription_t **rd_kafka_DescribeConsumerGroups_result_groups(const rd_kafka_DescribeConsumerGroups_result_t *result, size_t *cntp);\nconst char *rd_kafka_ConsumerGroupDescription_group_id(const rd_kafka_ConsumerGroupDescription_t *grpdesc);\nconst rd_kafka_error_t *rd_kafka_ConsumerGroupDescription_error(const rd_kafka_ConsumerGroupDescription_t *grpdesc);\nint rd_kafka_ConsumerGroupDescription_is_simple_consumer_group(const rd_kafka_ConsumerGroupDescription_t *grpdesc);\nconst char *rd_kafka_ConsumerGroupDescription_partition_assignor(const rd_kafka_ConsumerGroupDescription_t *grpdesc);\nrd_kafka_consumer_group_state_t rd_kafka_ConsumerGroupDescription_state(const rd_kafka_ConsumerGroupDescription_t *grpdesc);\nconst rd_kafka_Node_t *rd_kafka_ConsumerGroupDescription_coordinator(const rd_kafka_ConsumerGroupDescription_t *grpdesc);\nsize_t rd_kafka_ConsumerGroupDescription_member_count(const rd_kafka_ConsumerGroupDescription_t *grpdesc);\nconst rd_kafka_MemberDescription_t *rd_kafka_ConsumerGroupDescription_member(const rd_kafka_ConsumerGroupDescription_t *grpdesc, size_t idx);\nconst char *rd_kafka_MemberDescription_client_id(const rd_kafka_MemberDescription_t *member);\nconst char *rd_kafka_MemberDescription_group_instance_id(const rd_kafka_MemberDescription_t *member);\nconst char *rd_kafka_MemberDescription_consumer_id(const rd_kafka_MemberDescription_t *member);\nconst char *rd_kafka_MemberDescription_host(const rd_kafka_MemberDescription_t *member);\nconst rd_kafka_MemberAssignment_t *rd_kafka_MemberDescription_assignment(const rd_kafka_MemberDescription_t *member);\nconst rd_kafka_topic_partition_list_t *rd_kafka_MemberAssignment_partitions(const rd_kafka_MemberAssignment_t *assignment);\ntypedef struct rd_kafka_DeleteGroup_s rd_kafka_DeleteGroup_t;\nrd_kafka_DeleteGroup_t *rd_kafka_DeleteGroup_new(const char *group);\nvoid rd_kafka_DeleteGroup_destroy(rd_kafka_DeleteGroup_t *del_group);\nvoid rd_kafka_DeleteGroup_destroy_array(rd_kafka_DeleteGroup_t **del_groups, size_t del_group_cnt);\nvoid rd_kafka_DeleteGroups(rd_kafka_t *rk, rd_kafka_DeleteGroup_t **del_groups, size_t del_group_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_group_result_t **rd_kafka_DeleteGroups_result_groups(const rd_kafka_DeleteGroups_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_ListConsumerGroupOffsets_s rd_kafka_ListConsumerGroupOffsets_t;\nrd_kafka_ListConsumerGroupOffsets_t *rd_kafka_ListConsumerGroupOffsets_new(const char *group_id, const rd_kafka_topic_partition_list_t *partitions);\nvoid rd_kafka_ListConsumerGroupOffsets_destroy(rd_kafka_ListConsumerGroupOffsets_t *list_grpoffsets);\nvoid rd_kafka_ListConsumerGroupOffsets_destroy_array(rd_kafka_ListConsumerGroupOffsets_t **list_grpoffsets, size_t list_grpoffset_cnt);\nvoid rd_kafka_ListConsumerGroupOffsets(rd_kafka_t *rk, rd_kafka_ListConsumerGroupOffsets_t **list_grpoffsets, size_t list_grpoffsets_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_group_result_t **rd_kafka_ListConsumerGroupOffsets_result_groups(const rd_kafka_ListConsumerGroupOffsets_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_AlterConsumerGroupOffsets_s rd_kafka_AlterConsumerGroupOffsets_t;\nrd_kafka_AlterConsumerGroupOffsets_t *rd_kafka_AlterConsumerGroupOffsets_new(const char *group_id, const rd_kafka_topic_partition_list_t *partitions);\nvoid rd_kafka_AlterConsumerGroupOffsets_destroy(rd_kafka_AlterConsumerGroupOffsets_t *alter_grpoffsets);\nvoid rd_kafka_AlterConsumerGroupOffsets_destroy_array(rd_kafka_AlterConsumerGroupOffsets_t **alter_grpoffsets, size_t alter_grpoffset_cnt);\nvoid rd_kafka_AlterConsumerGroupOffsets(rd_kafka_t *rk, rd_kafka_AlterConsumerGroupOffsets_t **alter_grpoffsets, size_t alter_grpoffsets_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_group_result_t **rd_kafka_AlterConsumerGroupOffsets_result_groups(const rd_kafka_AlterConsumerGroupOffsets_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_DeleteConsumerGroupOffsets_s rd_kafka_DeleteConsumerGroupOffsets_t;\nrd_kafka_DeleteConsumerGroupOffsets_t *rd_kafka_DeleteConsumerGroupOffsets_new(const char *group, const rd_kafka_topic_partition_list_t *partitions);\nvoid rd_kafka_DeleteConsumerGroupOffsets_destroy(rd_kafka_DeleteConsumerGroupOffsets_t *del_grpoffsets);\nvoid rd_kafka_DeleteConsumerGroupOffsets_destroy_array(rd_kafka_DeleteConsumerGroupOffsets_t **del_grpoffsets, size_t del_grpoffset_cnt);\nvoid rd_kafka_DeleteConsumerGroupOffsets(rd_kafka_t *rk, rd_kafka_DeleteConsumerGroupOffsets_t **del_grpoffsets, size_t del_grpoffsets_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_group_result_t **rd_kafka_DeleteConsumerGroupOffsets_result_groups(const rd_kafka_DeleteConsumerGroupOffsets_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_AclBinding_s rd_kafka_AclBinding_t;\ntypedef rd_kafka_AclBinding_t rd_kafka_AclBindingFilter_t;\nconst rd_kafka_error_t *rd_kafka_acl_result_error(const rd_kafka_acl_result_t *aclres);\ntypedef enum rd_kafka_AclOperation_t {\n  RD_KAFKA_ACL_OPERATION_UNKNOWN = 0,\n  RD_KAFKA_ACL_OPERATION_ANY = 1,\n  RD_KAFKA_ACL_OPERATION_ALL = 2,\n  RD_KAFKA_ACL_OPERATION_READ = 3,\n  RD_KAFKA_ACL_OPERATION_WRITE = 4,\n  RD_KAFKA_ACL_OPERATION_CREATE = 5,\n  RD_KAFKA_ACL_OPERATION_DELETE = 6,\n  RD_KAFKA_ACL_OPERATION_ALTER = 7,\n  RD_KAFKA_ACL_OPERATION_DESCRIBE = 8,\n  RD_KAFKA_ACL_OPERATION_CLUSTER_ACTION = 9,\n  RD_KAFKA_ACL_OPERATION_DESCRIBE_CONFIGS = 10,\n  RD_KAFKA_ACL_OPERATION_ALTER_CONFIGS = 11,\n  RD_KAFKA_ACL_OPERATION_IDEMPOTENT_WRITE = 12,\n  RD_KAFKA_ACL_OPERATION__CNT,\n} rd_kafka_AclOperation_t;\nconst char *rd_kafka_AclOperation_name(rd_kafka_AclOperation_t acl_operation);\ntypedef enum rd_kafka_AclPermissionType_t {\n  RD_KAFKA_ACL_PERMISSION_TYPE_UNKNOWN = 0,\n  RD_KAFKA_ACL_PERMISSION_TYPE_ANY = 1,\n  RD_KAFKA_ACL_PERMISSION_TYPE_DENY = 2,\n  RD_KAFKA_ACL_PERMISSION_TYPE_ALLOW = 3,\n  RD_KAFKA_ACL_PERMISSION_TYPE__CNT,\n} rd_kafka_AclPermissionType_t;\nconst char *rd_kafka_AclPermissionType_name(rd_kafka_AclPermissionType_t acl_permission_type);\nrd_kafka_AclBinding_t *rd_kafka_AclBinding_new(rd_kafka_ResourceType_t restype, const char *name, rd_kafka_ResourcePatternType_t resource_pattern_type, const char *principal, const char *host, rd_kafka_AclOperation_t operation, rd_kafka_AclPermissionType_t permission_type, char *errstr, size_t errstr_size);\nrd_kafka_AclBindingFilter_t *rd_kafka_AclBindingFilter_new(rd_kafka_ResourceType_t restype, const char *name, rd_kafka_ResourcePatternType_t resource_pattern_type, const char *principal, const char *host, rd_kafka_AclOperation_t operation, rd_kafka_AclPermissionType_t permission_type, char *errstr, size_t errstr_size);\nrd_kafka_ResourceType_t rd_kafka_AclBinding_restype(const rd_kafka_AclBinding_t *acl);\nconst char *rd_kafka_AclBinding_name(const rd_kafka_AclBinding_t *acl);\nconst char *rd_kafka_AclBinding_principal(const rd_kafka_AclBinding_t *acl);\nconst char *rd_kafka_AclBinding_host(const rd_kafka_AclBinding_t *acl);\nrd_kafka_AclOperation_t rd_kafka_AclBinding_operation(const rd_kafka_AclBinding_t *acl);\nrd_kafka_AclPermissionType_t rd_kafka_AclBinding_permission_type(const rd_kafka_AclBinding_t *acl);\nrd_kafka_ResourcePatternType_t rd_kafka_AclBinding_resource_pattern_type(const rd_kafka_AclBinding_t *acl);\nconst rd_kafka_error_t *rd_kafka_AclBinding_error(const rd_kafka_AclBinding_t *acl);\nvoid rd_kafka_AclBinding_destroy(rd_kafka_AclBinding_t *acl_binding);\nvoid rd_kafka_AclBinding_destroy_array(rd_kafka_AclBinding_t **acl_bindings, size_t acl_bindings_cnt);\nconst rd_kafka_acl_result_t **rd_kafka_CreateAcls_result_acls(const rd_kafka_CreateAcls_result_t *result, size_t *cntp);\nvoid rd_kafka_CreateAcls(rd_kafka_t *rk, rd_kafka_AclBinding_t **new_acls, size_t new_acls_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_AclBinding_t **rd_kafka_DescribeAcls_result_acls(const rd_kafka_DescribeAcls_result_t *result, size_t *cntp);\nvoid rd_kafka_DescribeAcls(rd_kafka_t *rk, rd_kafka_AclBindingFilter_t *acl_filter, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\ntypedef struct rd_kafka_DeleteAcls_result_response_s rd_kafka_DeleteAcls_result_response_t;\nconst rd_kafka_DeleteAcls_result_response_t **rd_kafka_DeleteAcls_result_responses(const rd_kafka_DeleteAcls_result_t *result, size_t *cntp);\nconst rd_kafka_error_t *rd_kafka_DeleteAcls_result_response_error(const rd_kafka_DeleteAcls_result_response_t *result_response);\nconst rd_kafka_AclBinding_t **rd_kafka_DeleteAcls_result_response_matching_acls(const rd_kafka_DeleteAcls_result_response_t *result_response, size_t *matching_acls_cntp);\nvoid rd_kafka_DeleteAcls(rd_kafka_t *rk, rd_kafka_AclBindingFilter_t **del_acls, size_t del_acls_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nrd_kafka_resp_err_t rd_kafka_oauthbearer_set_token(rd_kafka_t *rk, const char *token_value, int64_t md_lifetime_ms, const char *md_principal_name, const char **extensions, size_t extension_size, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_oauthbearer_set_token_failure(rd_kafka_t *rk, const char *errstr);\nrd_kafka_error_t *rd_kafka_init_transactions(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_error_t *rd_kafka_begin_transaction(rd_kafka_t *rk);\nrd_kafka_error_t *rd_kafka_send_offsets_to_transaction(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, const rd_kafka_consumer_group_metadata_t *cgmetadata, int timeout_ms);\nrd_kafka_error_t *rd_kafka_commit_transaction(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_error_t *rd_kafka_abort_transaction(rd_kafka_t *rk, int timeout_ms);\ntypedef struct rd_kafka_mock_cluster_s rd_kafka_mock_cluster_t;\nrd_kafka_mock_cluster_t *rd_kafka_mock_cluster_new(rd_kafka_t *rk, int broker_cnt);\nvoid rd_kafka_mock_cluster_destroy(rd_kafka_mock_cluster_t *mcluster);\nrd_kafka_t *rd_kafka_mock_cluster_handle(const rd_kafka_mock_cluster_t *mcluster);\nrd_kafka_mock_cluster_t *rd_kafka_handle_mock_cluster(const rd_kafka_t *rk);\nconst char *rd_kafka_mock_cluster_bootstraps(const rd_kafka_mock_cluster_t *mcluster);\nvoid rd_kafka_mock_clear_request_errors(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey);\nvoid rd_kafka_mock_push_request_errors(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, size_t cnt, ...);\nvoid rd_kafka_mock_push_request_errors_array(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, size_t cnt, const rd_kafka_resp_err_t *errors);\nrd_kafka_resp_err_t rd_kafka_mock_broker_push_request_error_rtts(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int16_t ApiKey, size_t cnt, ...);\nrd_kafka_resp_err_t rd_kafka_mock_broker_error_stack_cnt(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int16_t ApiKey, size_t *cntp);\nvoid rd_kafka_mock_topic_set_error(rd_kafka_mock_cluster_t *mcluster, const char *topic, rd_kafka_resp_err_t err);\nrd_kafka_resp_err_t rd_kafka_mock_topic_create(rd_kafka_mock_cluster_t *mcluster, const char *topic, int partition_cnt, int replication_factor);\nrd_kafka_resp_err_t rd_kafka_mock_partition_set_leader(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id);\nrd_kafka_resp_err_t rd_kafka_mock_partition_set_follower(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id);\nrd_kafka_resp_err_t rd_kafka_mock_partition_set_follower_wmarks(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int64_t lo, int64_t hi);\nrd_kafka_resp_err_t rd_kafka_mock_broker_set_down(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id);\nrd_kafka_resp_err_t rd_kafka_mock_broker_set_up(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id);\nrd_kafka_resp_err_t rd_kafka_mock_broker_set_rtt(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int rtt_ms);\nrd_kafka_resp_err_t rd_kafka_mock_broker_set_rack(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, const char *rack);\nrd_kafka_resp_err_t rd_kafka_mock_coordinator_set(rd_kafka_mock_cluster_t *mcluster, const char *key_type, const char *key, int32_t broker_id);\nrd_kafka_resp_err_t rd_kafka_mock_set_apiversion(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, int16_t MinVersion, int16_t MaxVersion);\n'\n</code></pre> rdkafka.h, rdkafka_mock.h</p>"},{"location":"api/constants/#rd_kafka_version_26","title":"RD_KAFKA_VERSION","text":"<pre><code>public RD_KAFKA_VERSION = 33620479\n</code></pre> <p>librdkafka version </p> <p>Interpreted as hex <code>MM.mm.rr.xx</code>:</p> <ul> <li>MM = Major</li> <li>mm = minor</li> <li>rr = revision</li> <li>xx = pre-release id (0xff is the final release)</li> </ul> <p>E.g.: <code>0x000801ff</code> = 0.8.1</p> RemarksThis value should only be used during compile time, for runtime checks of version use rd_kafka_version()  <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_unsupported_compression_type_26","title":"RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE","text":"<pre><code>public RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76\n</code></pre> <p>Unsupported compression type </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_end_all_26","title":"RD_KAFKA_RESP_ERR_END_ALL","text":"<p><pre><code>public RD_KAFKA_RESP_ERR_END_ALL = 98\n</code></pre> enum rd_kafka_resp_err_t</p>"},{"location":"api/constants/#rd_kafka_admin_op__cnt_26","title":"RD_KAFKA_ADMIN_OP__CNT","text":"<pre><code>public RD_KAFKA_ADMIN_OP__CNT = 16\n</code></pre> <p>Number of ops defined </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe </li> </ul>"},{"location":"api/constants/#rd_kafka_resource__cnt_26","title":"RD_KAFKA_RESOURCE__CNT","text":"<pre><code>public RD_KAFKA_RESOURCE__CNT = 5\n</code></pre> <p>Number of resource types defined </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#acca83a66d7783ff7683ed2691cc907c9 </li> </ul>"},{"location":"api/constants/#rd_kafka_cdef_26","title":"RD_KAFKA_CDEF","text":"<p><pre><code>public RD_KAFKA_CDEF = 'typedef long int ssize_t;\ntypedef struct _IO_FILE FILE;\ntypedef long int mode_t;\ntypedef signed int int16_t;\ntypedef unsigned int uint16_t;\ntypedef signed int int32_t;\ntypedef signed long int int64_t;\nint rd_kafka_version(void);\nconst char *rd_kafka_version_str(void);\ntypedef enum rd_kafka_type_t {\n  RD_KAFKA_PRODUCER,\n  RD_KAFKA_CONSUMER,\n} rd_kafka_type_t;\ntypedef enum rd_kafka_timestamp_type_t {\n  RD_KAFKA_TIMESTAMP_NOT_AVAILABLE,\n  RD_KAFKA_TIMESTAMP_CREATE_TIME,\n  RD_KAFKA_TIMESTAMP_LOG_APPEND_TIME,\n} rd_kafka_timestamp_type_t;\nconst char *rd_kafka_get_debug_contexts(void);\ntypedef struct rd_kafka_s rd_kafka_t;\ntypedef struct rd_kafka_topic_s rd_kafka_topic_t;\ntypedef struct rd_kafka_conf_s rd_kafka_conf_t;\ntypedef struct rd_kafka_topic_conf_s rd_kafka_topic_conf_t;\ntypedef struct rd_kafka_queue_s rd_kafka_queue_t;\ntypedef struct rd_kafka_op_s rd_kafka_event_t;\ntypedef struct rd_kafka_topic_result_s rd_kafka_topic_result_t;\ntypedef struct rd_kafka_consumer_group_metadata_s rd_kafka_consumer_group_metadata_t;\ntypedef struct rd_kafka_error_s {\n  unsigned int code;\n  char *errstr;\n  unsigned char fatal;\n  unsigned char retriable;\n  unsigned char txn_requires_abort;\n} rd_kafka_error_t;\ntypedef struct rd_kafka_headers_s rd_kafka_headers_t;\ntypedef struct rd_kafka_group_result_s rd_kafka_group_result_t;\ntypedef struct rd_kafka_acl_result_s rd_kafka_acl_result_t;\ntypedef enum {\n  RD_KAFKA_RESP_ERR__BEGIN = (- 200),\n  RD_KAFKA_RESP_ERR__BAD_MSG = (- 199),\n  RD_KAFKA_RESP_ERR__BAD_COMPRESSION = (- 198),\n  RD_KAFKA_RESP_ERR__DESTROY = (- 197),\n  RD_KAFKA_RESP_ERR__FAIL = (- 196),\n  RD_KAFKA_RESP_ERR__TRANSPORT = (- 195),\n  RD_KAFKA_RESP_ERR__CRIT_SYS_RESOURCE = (- 194),\n  RD_KAFKA_RESP_ERR__RESOLVE = (- 193),\n  RD_KAFKA_RESP_ERR__MSG_TIMED_OUT = (- 192),\n  RD_KAFKA_RESP_ERR__PARTITION_EOF = (- 191),\n  RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION = (- 190),\n  RD_KAFKA_RESP_ERR__FS = (- 189),\n  RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC = (- 188),\n  RD_KAFKA_RESP_ERR__ALL_BROKERS_DOWN = (- 187),\n  RD_KAFKA_RESP_ERR__INVALID_ARG = (- 186),\n  RD_KAFKA_RESP_ERR__TIMED_OUT = (- 185),\n  RD_KAFKA_RESP_ERR__QUEUE_FULL = (- 184),\n  RD_KAFKA_RESP_ERR__ISR_INSUFF = (- 183),\n  RD_KAFKA_RESP_ERR__NODE_UPDATE = (- 182),\n  RD_KAFKA_RESP_ERR__SSL = (- 181),\n  RD_KAFKA_RESP_ERR__WAIT_COORD = (- 180),\n  RD_KAFKA_RESP_ERR__UNKNOWN_GROUP = (- 179),\n  RD_KAFKA_RESP_ERR__IN_PROGRESS = (- 178),\n  RD_KAFKA_RESP_ERR__PREV_IN_PROGRESS = (- 177),\n  RD_KAFKA_RESP_ERR__EXISTING_SUBSCRIPTION = (- 176),\n  RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS = (- 175),\n  RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS = (- 174),\n  RD_KAFKA_RESP_ERR__CONFLICT = (- 173),\n  RD_KAFKA_RESP_ERR__STATE = (- 172),\n  RD_KAFKA_RESP_ERR__UNKNOWN_PROTOCOL = (- 171),\n  RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED = (- 170),\n  RD_KAFKA_RESP_ERR__AUTHENTICATION = (- 169),\n  RD_KAFKA_RESP_ERR__NO_OFFSET = (- 168),\n  RD_KAFKA_RESP_ERR__OUTDATED = (- 167),\n  RD_KAFKA_RESP_ERR__TIMED_OUT_QUEUE = (- 166),\n  RD_KAFKA_RESP_ERR__UNSUPPORTED_FEATURE = (- 165),\n  RD_KAFKA_RESP_ERR__WAIT_CACHE = (- 164),\n  RD_KAFKA_RESP_ERR__INTR = (- 163),\n  RD_KAFKA_RESP_ERR__KEY_SERIALIZATION = (- 162),\n  RD_KAFKA_RESP_ERR__VALUE_SERIALIZATION = (- 161),\n  RD_KAFKA_RESP_ERR__KEY_DESERIALIZATION = (- 160),\n  RD_KAFKA_RESP_ERR__VALUE_DESERIALIZATION = (- 159),\n  RD_KAFKA_RESP_ERR__PARTIAL = (- 158),\n  RD_KAFKA_RESP_ERR__READ_ONLY = (- 157),\n  RD_KAFKA_RESP_ERR__NOENT = (- 156),\n  RD_KAFKA_RESP_ERR__UNDERFLOW = (- 155),\n  RD_KAFKA_RESP_ERR__INVALID_TYPE = (- 154),\n  RD_KAFKA_RESP_ERR__RETRY = (- 153),\n  RD_KAFKA_RESP_ERR__PURGE_QUEUE = (- 152),\n  RD_KAFKA_RESP_ERR__PURGE_INFLIGHT = (- 151),\n  RD_KAFKA_RESP_ERR__FATAL = (- 150),\n  RD_KAFKA_RESP_ERR__INCONSISTENT = (- 149),\n  RD_KAFKA_RESP_ERR__GAPLESS_GUARANTEE = (- 148),\n  RD_KAFKA_RESP_ERR__MAX_POLL_EXCEEDED = (- 147),\n  RD_KAFKA_RESP_ERR__UNKNOWN_BROKER = (- 146),\n  RD_KAFKA_RESP_ERR__NOT_CONFIGURED = (- 145),\n  RD_KAFKA_RESP_ERR__FENCED = (- 144),\n  RD_KAFKA_RESP_ERR__APPLICATION = (- 143),\n  RD_KAFKA_RESP_ERR__ASSIGNMENT_LOST = (- 142),\n  RD_KAFKA_RESP_ERR__NOOP = (- 141),\n  RD_KAFKA_RESP_ERR__AUTO_OFFSET_RESET = (- 140),\n  RD_KAFKA_RESP_ERR__LOG_TRUNCATION = (- 139),\n  RD_KAFKA_RESP_ERR__END = (- 100),\n  RD_KAFKA_RESP_ERR_UNKNOWN = (- 1),\n  RD_KAFKA_RESP_ERR_NO_ERROR = 0,\n  RD_KAFKA_RESP_ERR_OFFSET_OUT_OF_RANGE = 1,\n  RD_KAFKA_RESP_ERR_INVALID_MSG = 2,\n  RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART = 3,\n  RD_KAFKA_RESP_ERR_INVALID_MSG_SIZE = 4,\n  RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE = 5,\n  RD_KAFKA_RESP_ERR_NOT_LEADER_FOR_PARTITION = 6,\n  RD_KAFKA_RESP_ERR_REQUEST_TIMED_OUT = 7,\n  RD_KAFKA_RESP_ERR_BROKER_NOT_AVAILABLE = 8,\n  RD_KAFKA_RESP_ERR_REPLICA_NOT_AVAILABLE = 9,\n  RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE = 10,\n  RD_KAFKA_RESP_ERR_STALE_CTRL_EPOCH = 11,\n  RD_KAFKA_RESP_ERR_OFFSET_METADATA_TOO_LARGE = 12,\n  RD_KAFKA_RESP_ERR_NETWORK_EXCEPTION = 13,\n  RD_KAFKA_RESP_ERR_COORDINATOR_LOAD_IN_PROGRESS = 14,\n  RD_KAFKA_RESP_ERR_COORDINATOR_NOT_AVAILABLE = 15,\n  RD_KAFKA_RESP_ERR_NOT_COORDINATOR = 16,\n  RD_KAFKA_RESP_ERR_TOPIC_EXCEPTION = 17,\n  RD_KAFKA_RESP_ERR_RECORD_LIST_TOO_LARGE = 18,\n  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS = 19,\n  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS_AFTER_APPEND = 20,\n  RD_KAFKA_RESP_ERR_INVALID_REQUIRED_ACKS = 21,\n  RD_KAFKA_RESP_ERR_ILLEGAL_GENERATION = 22,\n  RD_KAFKA_RESP_ERR_INCONSISTENT_GROUP_PROTOCOL = 23,\n  RD_KAFKA_RESP_ERR_INVALID_GROUP_ID = 24,\n  RD_KAFKA_RESP_ERR_UNKNOWN_MEMBER_ID = 25,\n  RD_KAFKA_RESP_ERR_INVALID_SESSION_TIMEOUT = 26,\n  RD_KAFKA_RESP_ERR_REBALANCE_IN_PROGRESS = 27,\n  RD_KAFKA_RESP_ERR_INVALID_COMMIT_OFFSET_SIZE = 28,\n  RD_KAFKA_RESP_ERR_TOPIC_AUTHORIZATION_FAILED = 29,\n  RD_KAFKA_RESP_ERR_GROUP_AUTHORIZATION_FAILED = 30,\n  RD_KAFKA_RESP_ERR_CLUSTER_AUTHORIZATION_FAILED = 31,\n  RD_KAFKA_RESP_ERR_INVALID_TIMESTAMP = 32,\n  RD_KAFKA_RESP_ERR_UNSUPPORTED_SASL_MECHANISM = 33,\n  RD_KAFKA_RESP_ERR_ILLEGAL_SASL_STATE = 34,\n  RD_KAFKA_RESP_ERR_UNSUPPORTED_VERSION = 35,\n  RD_KAFKA_RESP_ERR_TOPIC_ALREADY_EXISTS = 36,\n  RD_KAFKA_RESP_ERR_INVALID_PARTITIONS = 37,\n  RD_KAFKA_RESP_ERR_INVALID_REPLICATION_FACTOR = 38,\n  RD_KAFKA_RESP_ERR_INVALID_REPLICA_ASSIGNMENT = 39,\n  RD_KAFKA_RESP_ERR_INVALID_CONFIG = 40,\n  RD_KAFKA_RESP_ERR_NOT_CONTROLLER = 41,\n  RD_KAFKA_RESP_ERR_INVALID_REQUEST = 42,\n  RD_KAFKA_RESP_ERR_UNSUPPORTED_FOR_MESSAGE_FORMAT = 43,\n  RD_KAFKA_RESP_ERR_POLICY_VIOLATION = 44,\n  RD_KAFKA_RESP_ERR_OUT_OF_ORDER_SEQUENCE_NUMBER = 45,\n  RD_KAFKA_RESP_ERR_DUPLICATE_SEQUENCE_NUMBER = 46,\n  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_EPOCH = 47,\n  RD_KAFKA_RESP_ERR_INVALID_TXN_STATE = 48,\n  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_ID_MAPPING = 49,\n  RD_KAFKA_RESP_ERR_INVALID_TRANSACTION_TIMEOUT = 50,\n  RD_KAFKA_RESP_ERR_CONCURRENT_TRANSACTIONS = 51,\n  RD_KAFKA_RESP_ERR_TRANSACTION_COORDINATOR_FENCED = 52,\n  RD_KAFKA_RESP_ERR_TRANSACTIONAL_ID_AUTHORIZATION_FAILED = 53,\n  RD_KAFKA_RESP_ERR_SECURITY_DISABLED = 54,\n  RD_KAFKA_RESP_ERR_OPERATION_NOT_ATTEMPTED = 55,\n  RD_KAFKA_RESP_ERR_KAFKA_STORAGE_ERROR = 56,\n  RD_KAFKA_RESP_ERR_LOG_DIR_NOT_FOUND = 57,\n  RD_KAFKA_RESP_ERR_SASL_AUTHENTICATION_FAILED = 58,\n  RD_KAFKA_RESP_ERR_UNKNOWN_PRODUCER_ID = 59,\n  RD_KAFKA_RESP_ERR_REASSIGNMENT_IN_PROGRESS = 60,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTH_DISABLED = 61,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_NOT_FOUND = 62,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_OWNER_MISMATCH = 63,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_REQUEST_NOT_ALLOWED = 64,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTHORIZATION_FAILED = 65,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_EXPIRED = 66,\n  RD_KAFKA_RESP_ERR_INVALID_PRINCIPAL_TYPE = 67,\n  RD_KAFKA_RESP_ERR_NON_EMPTY_GROUP = 68,\n  RD_KAFKA_RESP_ERR_GROUP_ID_NOT_FOUND = 69,\n  RD_KAFKA_RESP_ERR_FETCH_SESSION_ID_NOT_FOUND = 70,\n  RD_KAFKA_RESP_ERR_INVALID_FETCH_SESSION_EPOCH = 71,\n  RD_KAFKA_RESP_ERR_LISTENER_NOT_FOUND = 72,\n  RD_KAFKA_RESP_ERR_TOPIC_DELETION_DISABLED = 73,\n  RD_KAFKA_RESP_ERR_FENCED_LEADER_EPOCH = 74,\n  RD_KAFKA_RESP_ERR_UNKNOWN_LEADER_EPOCH = 75,\n  RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76,\n  RD_KAFKA_RESP_ERR_STALE_BROKER_EPOCH = 77,\n  RD_KAFKA_RESP_ERR_OFFSET_NOT_AVAILABLE = 78,\n  RD_KAFKA_RESP_ERR_MEMBER_ID_REQUIRED = 79,\n  RD_KAFKA_RESP_ERR_PREFERRED_LEADER_NOT_AVAILABLE = 80,\n  RD_KAFKA_RESP_ERR_GROUP_MAX_SIZE_REACHED = 81,\n  RD_KAFKA_RESP_ERR_FENCED_INSTANCE_ID = 82,\n  RD_KAFKA_RESP_ERR_ELIGIBLE_LEADERS_NOT_AVAILABLE = 83,\n  RD_KAFKA_RESP_ERR_ELECTION_NOT_NEEDED = 84,\n  RD_KAFKA_RESP_ERR_NO_REASSIGNMENT_IN_PROGRESS = 85,\n  RD_KAFKA_RESP_ERR_GROUP_SUBSCRIBED_TO_TOPIC = 86,\n  RD_KAFKA_RESP_ERR_INVALID_RECORD = 87,\n  RD_KAFKA_RESP_ERR_UNSTABLE_OFFSET_COMMIT = 88,\n  RD_KAFKA_RESP_ERR_THROTTLING_QUOTA_EXCEEDED = 89,\n  RD_KAFKA_RESP_ERR_PRODUCER_FENCED = 90,\n  RD_KAFKA_RESP_ERR_RESOURCE_NOT_FOUND = 91,\n  RD_KAFKA_RESP_ERR_DUPLICATE_RESOURCE = 92,\n  RD_KAFKA_RESP_ERR_UNACCEPTABLE_CREDENTIAL = 93,\n  RD_KAFKA_RESP_ERR_INCONSISTENT_VOTER_SET = 94,\n  RD_KAFKA_RESP_ERR_INVALID_UPDATE_VERSION = 95,\n  RD_KAFKA_RESP_ERR_FEATURE_UPDATE_FAILED = 96,\n  RD_KAFKA_RESP_ERR_PRINCIPAL_DESERIALIZATION_FAILURE = 97,\n  RD_KAFKA_RESP_ERR_END_ALL,\n} rd_kafka_resp_err_t;\nstruct rd_kafka_err_desc {\n  rd_kafka_resp_err_t code;\n  char *name;\n  char *desc;\n};\nvoid rd_kafka_get_err_descs(const struct rd_kafka_err_desc **errdescs, size_t *cntp);\nconst char *rd_kafka_err2str(rd_kafka_resp_err_t err);\nconst char *rd_kafka_err2name(rd_kafka_resp_err_t err);\nrd_kafka_resp_err_t rd_kafka_last_error(void);\nrd_kafka_resp_err_t rd_kafka_errno2err(int errnox);\nint rd_kafka_errno(void);\nrd_kafka_resp_err_t rd_kafka_fatal_error(rd_kafka_t *rk, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_test_fatal_error(rd_kafka_t *rk, rd_kafka_resp_err_t err, const char *reason);\nrd_kafka_resp_err_t rd_kafka_error_code(const rd_kafka_error_t *error);\nconst char *rd_kafka_error_name(const rd_kafka_error_t *error);\nconst char *rd_kafka_error_string(const rd_kafka_error_t *error);\nint rd_kafka_error_is_fatal(const rd_kafka_error_t *error);\nint rd_kafka_error_is_retriable(const rd_kafka_error_t *error);\nint rd_kafka_error_txn_requires_abort(const rd_kafka_error_t *error);\nvoid rd_kafka_error_destroy(rd_kafka_error_t *error);\nrd_kafka_error_t *rd_kafka_error_new(rd_kafka_resp_err_t code, const char *fmt, ...);\ntypedef struct rd_kafka_topic_partition_s {\n  char *topic;\n  int32_t partition;\n  int64_t offset;\n  void *metadata;\n  size_t metadata_size;\n  void *opaque;\n  rd_kafka_resp_err_t err;\n  void *_private;\n} rd_kafka_topic_partition_t;\nvoid rd_kafka_topic_partition_destroy(rd_kafka_topic_partition_t *rktpar);\nvoid rd_kafka_topic_partition_set_leader_epoch(rd_kafka_topic_partition_t *rktpar, int32_t leader_epoch);\nint32_t rd_kafka_topic_partition_get_leader_epoch(const rd_kafka_topic_partition_t *rktpar);\ntypedef struct rd_kafka_topic_partition_list_s {\n  int cnt;\n  int size;\n  rd_kafka_topic_partition_t *elems;\n} rd_kafka_topic_partition_list_t;\nrd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_new(int size);\nvoid rd_kafka_topic_partition_list_destroy(rd_kafka_topic_partition_list_t *rkparlist);\nrd_kafka_topic_partition_t *rd_kafka_topic_partition_list_add(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);\nvoid rd_kafka_topic_partition_list_add_range(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t start, int32_t stop);\nint rd_kafka_topic_partition_list_del(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);\nint rd_kafka_topic_partition_list_del_by_idx(rd_kafka_topic_partition_list_t *rktparlist, int idx);\nrd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_copy(const rd_kafka_topic_partition_list_t *src);\nrd_kafka_resp_err_t rd_kafka_topic_partition_list_set_offset(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition, int64_t offset);\nrd_kafka_topic_partition_t *rd_kafka_topic_partition_list_find(const rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);\nvoid rd_kafka_topic_partition_list_sort(rd_kafka_topic_partition_list_t *rktparlist, int (*cmp)(const void *a, const void *b, void *cmp_opaque), void *cmp_opaque);\ntypedef enum rd_kafka_vtype_t {\n  RD_KAFKA_VTYPE_END,\n  RD_KAFKA_VTYPE_TOPIC,\n  RD_KAFKA_VTYPE_RKT,\n  RD_KAFKA_VTYPE_PARTITION,\n  RD_KAFKA_VTYPE_VALUE,\n  RD_KAFKA_VTYPE_KEY,\n  RD_KAFKA_VTYPE_OPAQUE,\n  RD_KAFKA_VTYPE_MSGFLAGS,\n  RD_KAFKA_VTYPE_TIMESTAMP,\n  RD_KAFKA_VTYPE_HEADER,\n  RD_KAFKA_VTYPE_HEADERS,\n} rd_kafka_vtype_t;\ntypedef struct rd_kafka_vu_s {\n  rd_kafka_vtype_t vtype;\n  union {\n    char *cstr;\n    rd_kafka_topic_t *rkt;\n    int i;\n    int32_t i32;\n    int64_t i64;\n    struct {\n      void *ptr;\n      size_t size;\n    } mem;\n    struct {\n      char *name;\n      void *val;\n      ssize_t size;\n    } header;\n    rd_kafka_headers_t *headers;\n    void *ptr;\n    char _pad[64];\n  } u;\n} rd_kafka_vu_t;\nrd_kafka_headers_t *rd_kafka_headers_new(size_t initial_count);\nvoid rd_kafka_headers_destroy(rd_kafka_headers_t *hdrs);\nrd_kafka_headers_t *rd_kafka_headers_copy(const rd_kafka_headers_t *src);\nrd_kafka_resp_err_t rd_kafka_header_add(rd_kafka_headers_t *hdrs, const char *name, ssize_t name_size, const void *value, ssize_t value_size);\nrd_kafka_resp_err_t rd_kafka_header_remove(rd_kafka_headers_t *hdrs, const char *name);\nrd_kafka_resp_err_t rd_kafka_header_get_last(const rd_kafka_headers_t *hdrs, const char *name, const void **valuep, size_t *sizep);\nrd_kafka_resp_err_t rd_kafka_header_get(const rd_kafka_headers_t *hdrs, size_t idx, const char *name, const void **valuep, size_t *sizep);\nrd_kafka_resp_err_t rd_kafka_header_get_all(const rd_kafka_headers_t *hdrs, size_t idx, const char **namep, const void **valuep, size_t *sizep);\ntypedef struct rd_kafka_message_s {\n  rd_kafka_resp_err_t err;\n  rd_kafka_topic_t *rkt;\n  int32_t partition;\n  void *payload;\n  size_t len;\n  void *key;\n  size_t key_len;\n  int64_t offset;\n  void *_private;\n} rd_kafka_message_t;\nvoid rd_kafka_message_destroy(rd_kafka_message_t *rkmessage);\nconst char *rd_kafka_message_errstr(const rd_kafka_message_t *rkmessage);\nint64_t rd_kafka_message_timestamp(const rd_kafka_message_t *rkmessage, rd_kafka_timestamp_type_t *tstype);\nint64_t rd_kafka_message_latency(const rd_kafka_message_t *rkmessage);\nint32_t rd_kafka_message_broker_id(const rd_kafka_message_t *rkmessage);\nrd_kafka_resp_err_t rd_kafka_message_headers(const rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);\nrd_kafka_resp_err_t rd_kafka_message_detach_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);\nvoid rd_kafka_message_set_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t *hdrs);\nsize_t rd_kafka_header_cnt(const rd_kafka_headers_t *hdrs);\ntypedef enum {\n  RD_KAFKA_MSG_STATUS_NOT_PERSISTED = 0,\n  RD_KAFKA_MSG_STATUS_POSSIBLY_PERSISTED = 1,\n  RD_KAFKA_MSG_STATUS_PERSISTED = 2,\n} rd_kafka_msg_status_t;\nrd_kafka_msg_status_t rd_kafka_message_status(const rd_kafka_message_t *rkmessage);\nint32_t rd_kafka_message_leader_epoch(const rd_kafka_message_t *rkmessage);\ntypedef enum {\n  RD_KAFKA_CONF_UNKNOWN = (- 2),\n  RD_KAFKA_CONF_INVALID = (- 1),\n  RD_KAFKA_CONF_OK = 0,\n} rd_kafka_conf_res_t;\nrd_kafka_conf_t *rd_kafka_conf_new(void);\nvoid rd_kafka_conf_destroy(rd_kafka_conf_t *conf);\nrd_kafka_conf_t *rd_kafka_conf_dup(const rd_kafka_conf_t *conf);\nrd_kafka_conf_t *rd_kafka_conf_dup_filter(const rd_kafka_conf_t *conf, size_t filter_cnt, const char **filter);\nconst rd_kafka_conf_t *rd_kafka_conf(rd_kafka_t *rk);\nrd_kafka_conf_res_t rd_kafka_conf_set(rd_kafka_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);\nvoid rd_kafka_conf_set_events(rd_kafka_conf_t *conf, int events);\nvoid rd_kafka_conf_set_background_event_cb(rd_kafka_conf_t *conf, void (*event_cb)(rd_kafka_t *rk, rd_kafka_event_t *rkev, void *opaque));\nvoid rd_kafka_conf_set_dr_cb(rd_kafka_conf_t *conf, void (*dr_cb)(rd_kafka_t *rk, void *payload, size_t len, rd_kafka_resp_err_t err, void *opaque, void *msg_opaque));\nvoid rd_kafka_conf_set_dr_msg_cb(rd_kafka_conf_t *conf, void (*dr_msg_cb)(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, void *opaque));\nvoid rd_kafka_conf_set_consume_cb(rd_kafka_conf_t *conf, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *opaque));\nvoid rd_kafka_conf_set_rebalance_cb(rd_kafka_conf_t *conf, void (*rebalance_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *partitions, void *opaque));\nvoid rd_kafka_conf_set_offset_commit_cb(rd_kafka_conf_t *conf, void (*offset_commit_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *opaque));\nvoid rd_kafka_conf_set_error_cb(rd_kafka_conf_t *conf, void (*error_cb)(rd_kafka_t *rk, int err, const char *reason, void *opaque));\nvoid rd_kafka_conf_set_throttle_cb(rd_kafka_conf_t *conf, void (*throttle_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int throttle_time_ms, void *opaque));\nvoid rd_kafka_conf_set_log_cb(rd_kafka_conf_t *conf, void (*log_cb)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));\nvoid rd_kafka_conf_set_stats_cb(rd_kafka_conf_t *conf, int (*stats_cb)(rd_kafka_t *rk, char *json, size_t json_len, void *opaque));\nvoid rd_kafka_conf_set_oauthbearer_token_refresh_cb(rd_kafka_conf_t *conf, void (*oauthbearer_token_refresh_cb)(rd_kafka_t *rk, const char *oauthbearer_config, void *opaque));\nvoid rd_kafka_conf_enable_sasl_queue(rd_kafka_conf_t *conf, int enable);\nvoid rd_kafka_conf_set_socket_cb(rd_kafka_conf_t *conf, int (*socket_cb)(int domain, int type, int protocol, void *opaque));\nvoid rd_kafka_conf_set_connect_cb(rd_kafka_conf_t *conf, int (*connect_cb)(int sockfd, const struct sockaddr *addr, int addrlen, const char *id, void *opaque));\nvoid rd_kafka_conf_set_closesocket_cb(rd_kafka_conf_t *conf, int (*closesocket_cb)(int sockfd, void *opaque));\nstruct addrinfo;\nvoid rd_kafka_conf_set_resolve_cb(rd_kafka_conf_t *conf, int (*resolve_cb)(const char *node, const char *service, const struct addrinfo *hints, struct addrinfo **res, void *opaque));\nrd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert_verify_cb(rd_kafka_conf_t *conf, int (*ssl_cert_verify_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int *x509_error, int depth, const char *buf, size_t size, char *errstr, size_t errstr_size, void *opaque));\ntypedef enum rd_kafka_cert_type_t {\n  RD_KAFKA_CERT_PUBLIC_KEY,\n  RD_KAFKA_CERT_PRIVATE_KEY,\n  RD_KAFKA_CERT_CA,\n  RD_KAFKA_CERT__CNT,\n} rd_kafka_cert_type_t;\ntypedef enum rd_kafka_cert_enc_t {\n  RD_KAFKA_CERT_ENC_PKCS12,\n  RD_KAFKA_CERT_ENC_DER,\n  RD_KAFKA_CERT_ENC_PEM,\n  RD_KAFKA_CERT_ENC__CNT,\n} rd_kafka_cert_enc_t;\nrd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert(rd_kafka_conf_t *conf, rd_kafka_cert_type_t cert_type, rd_kafka_cert_enc_t cert_enc, const void *buffer, size_t size, char *errstr, size_t errstr_size);\nvoid rd_kafka_conf_set_engine_callback_data(rd_kafka_conf_t *conf, void *callback_data);\nvoid rd_kafka_conf_set_opaque(rd_kafka_conf_t *conf, void *opaque);\nvoid *rd_kafka_opaque(const rd_kafka_t *rk);\nvoid rd_kafka_conf_set_default_topic_conf(rd_kafka_conf_t *conf, rd_kafka_topic_conf_t *tconf);\nrd_kafka_topic_conf_t *rd_kafka_conf_get_default_topic_conf(rd_kafka_conf_t *conf);\nrd_kafka_conf_res_t rd_kafka_conf_get(const rd_kafka_conf_t *conf, const char *name, char *dest, size_t *dest_size);\nrd_kafka_conf_res_t rd_kafka_topic_conf_get(const rd_kafka_topic_conf_t *conf, const char *name, char *dest, size_t *dest_size);\nconst char **rd_kafka_conf_dump(rd_kafka_conf_t *conf, size_t *cntp);\nconst char **rd_kafka_topic_conf_dump(rd_kafka_topic_conf_t *conf, size_t *cntp);\nvoid rd_kafka_conf_dump_free(const char **arr, size_t cnt);\nvoid rd_kafka_conf_properties_show(FILE *fp);\nrd_kafka_topic_conf_t *rd_kafka_topic_conf_new(void);\nrd_kafka_topic_conf_t *rd_kafka_topic_conf_dup(const rd_kafka_topic_conf_t *conf);\nrd_kafka_topic_conf_t *rd_kafka_default_topic_conf_dup(rd_kafka_t *rk);\nvoid rd_kafka_topic_conf_destroy(rd_kafka_topic_conf_t *topic_conf);\nrd_kafka_conf_res_t rd_kafka_topic_conf_set(rd_kafka_topic_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);\nvoid rd_kafka_topic_conf_set_opaque(rd_kafka_topic_conf_t *conf, void *rkt_opaque);\nvoid rd_kafka_topic_conf_set_partitioner_cb(rd_kafka_topic_conf_t *topic_conf, int32_t (*partitioner)(const rd_kafka_topic_t *rkt, const void *keydata, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque));\nvoid rd_kafka_topic_conf_set_msg_order_cmp(rd_kafka_topic_conf_t *topic_conf, int (*msg_order_cmp)(const rd_kafka_message_t *a, const rd_kafka_message_t *b));\nint rd_kafka_topic_partition_available(const rd_kafka_topic_t *rkt, int32_t partition);\nint32_t rd_kafka_msg_partitioner_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_consistent(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_consistent_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_murmur2(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_murmur2_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_fnv1a(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_fnv1a_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nrd_kafka_t *rd_kafka_new(rd_kafka_type_t type, rd_kafka_conf_t *conf, char *errstr, size_t errstr_size);\nvoid rd_kafka_destroy(rd_kafka_t *rk);\nvoid rd_kafka_destroy_flags(rd_kafka_t *rk, int flags);\nconst char *rd_kafka_name(const rd_kafka_t *rk);\nrd_kafka_type_t rd_kafka_type(const rd_kafka_t *rk);\nchar *rd_kafka_memberid(const rd_kafka_t *rk);\nchar *rd_kafka_clusterid(rd_kafka_t *rk, int timeout_ms);\nint32_t rd_kafka_controllerid(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_topic_t *rd_kafka_topic_new(rd_kafka_t *rk, const char *topic, rd_kafka_topic_conf_t *conf);\nvoid rd_kafka_topic_destroy(rd_kafka_topic_t *rkt);\nconst char *rd_kafka_topic_name(const rd_kafka_topic_t *rkt);\nvoid *rd_kafka_topic_opaque(const rd_kafka_topic_t *rkt);\nint rd_kafka_poll(rd_kafka_t *rk, int timeout_ms);\nvoid rd_kafka_yield(rd_kafka_t *rk);\nrd_kafka_resp_err_t rd_kafka_pause_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_resp_err_t rd_kafka_resume_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_resp_err_t rd_kafka_query_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high, int timeout_ms);\nrd_kafka_resp_err_t rd_kafka_get_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high);\nrd_kafka_resp_err_t rd_kafka_offsets_for_times(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets, int timeout_ms);\nvoid *rd_kafka_mem_calloc(rd_kafka_t *rk, size_t num, size_t size);\nvoid *rd_kafka_mem_malloc(rd_kafka_t *rk, size_t size);\nvoid rd_kafka_mem_free(rd_kafka_t *rk, void *ptr);\nrd_kafka_queue_t *rd_kafka_queue_new(rd_kafka_t *rk);\nvoid rd_kafka_queue_destroy(rd_kafka_queue_t *rkqu);\nrd_kafka_queue_t *rd_kafka_queue_get_main(rd_kafka_t *rk);\nrd_kafka_queue_t *rd_kafka_queue_get_sasl(rd_kafka_t *rk);\nrd_kafka_error_t *rd_kafka_sasl_background_callbacks_enable(rd_kafka_t *rk);\nrd_kafka_error_t *rd_kafka_sasl_set_credentials(rd_kafka_t *rk, const char *username, const char *password);\nrd_kafka_queue_t *rd_kafka_queue_get_consumer(rd_kafka_t *rk);\nrd_kafka_queue_t *rd_kafka_queue_get_partition(rd_kafka_t *rk, const char *topic, int32_t partition);\nrd_kafka_queue_t *rd_kafka_queue_get_background(rd_kafka_t *rk);\nvoid rd_kafka_queue_forward(rd_kafka_queue_t *src, rd_kafka_queue_t *dst);\nrd_kafka_resp_err_t rd_kafka_set_log_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu);\nsize_t rd_kafka_queue_length(rd_kafka_queue_t *rkqu);\nvoid rd_kafka_queue_io_event_enable(rd_kafka_queue_t *rkqu, int fd, const void *payload, size_t size);\nvoid rd_kafka_queue_cb_event_enable(rd_kafka_queue_t *rkqu, void (*event_cb)(rd_kafka_t *rk, void *qev_opaque), void *qev_opaque);\nvoid rd_kafka_queue_yield(rd_kafka_queue_t *rkqu);\nint rd_kafka_consume_start(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);\nint rd_kafka_consume_start_queue(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, rd_kafka_queue_t *rkqu);\nint rd_kafka_consume_stop(rd_kafka_topic_t *rkt, int32_t partition);\nrd_kafka_resp_err_t rd_kafka_seek(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, int timeout_ms);\nrd_kafka_error_t *rd_kafka_seek_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms);\nrd_kafka_message_t *rd_kafka_consume(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms);\nssize_t rd_kafka_consume_batch(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);\nint rd_kafka_consume_callback(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);\nrd_kafka_message_t *rd_kafka_consume_queue(rd_kafka_queue_t *rkqu, int timeout_ms);\nssize_t rd_kafka_consume_batch_queue(rd_kafka_queue_t *rkqu, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);\nint rd_kafka_consume_callback_queue(rd_kafka_queue_t *rkqu, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);\nrd_kafka_resp_err_t rd_kafka_offset_store(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);\nrd_kafka_resp_err_t rd_kafka_offsets_store(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets);\nrd_kafka_error_t *rd_kafka_offset_store_message(rd_kafka_message_t *rkmessage);\nrd_kafka_resp_err_t rd_kafka_subscribe(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *topics);\nrd_kafka_resp_err_t rd_kafka_unsubscribe(rd_kafka_t *rk);\nrd_kafka_resp_err_t rd_kafka_subscription(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **topics);\nrd_kafka_message_t *rd_kafka_consumer_poll(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_resp_err_t rd_kafka_consumer_close(rd_kafka_t *rk);\nrd_kafka_error_t *rd_kafka_consumer_close_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu);\nint rd_kafka_consumer_closed(rd_kafka_t *rk);\nrd_kafka_error_t *rd_kafka_incremental_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_error_t *rd_kafka_incremental_unassign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);\nconst char *rd_kafka_rebalance_protocol(rd_kafka_t *rk);\nrd_kafka_resp_err_t rd_kafka_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_resp_err_t rd_kafka_assignment(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **partitions);\nint rd_kafka_assignment_lost(rd_kafka_t *rk);\nrd_kafka_resp_err_t rd_kafka_commit(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, int async);\nrd_kafka_resp_err_t rd_kafka_commit_message(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, int async);\nrd_kafka_resp_err_t rd_kafka_commit_queue(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_queue_t *rkqu, void (*cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *commit_opaque), void *commit_opaque);\nrd_kafka_resp_err_t rd_kafka_committed(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms);\nrd_kafka_resp_err_t rd_kafka_position(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata(rd_kafka_t *rk);\nrd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata_new(const char *group_id);\nrd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata_new_with_genid(const char *group_id, int32_t generation_id, const char *member_id, const char *group_instance_id);\nvoid rd_kafka_consumer_group_metadata_destroy(rd_kafka_consumer_group_metadata_t *);\nrd_kafka_error_t *rd_kafka_consumer_group_metadata_write(const rd_kafka_consumer_group_metadata_t *cgmd, void **bufferp, size_t *sizep);\nrd_kafka_error_t *rd_kafka_consumer_group_metadata_read(rd_kafka_consumer_group_metadata_t **cgmdp, const void *buffer, size_t size);\nint rd_kafka_produce(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, void *payload, size_t len, const void *key, size_t keylen, void *msg_opaque);\nrd_kafka_resp_err_t rd_kafka_producev(rd_kafka_t *rk, ...);\nrd_kafka_error_t *rd_kafka_produceva(rd_kafka_t *rk, const rd_kafka_vu_t *vus, size_t cnt);\nint rd_kafka_produce_batch(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, rd_kafka_message_t *rkmessages, int message_cnt);\nrd_kafka_resp_err_t rd_kafka_flush(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_resp_err_t rd_kafka_purge(rd_kafka_t *rk, int purge_flags);\ntypedef struct rd_kafka_metadata_broker {\n  int32_t id;\n  char *host;\n  int port;\n} rd_kafka_metadata_broker_t;\ntypedef struct rd_kafka_metadata_partition {\n  int32_t id;\n  rd_kafka_resp_err_t err;\n  int32_t leader;\n  int replica_cnt;\n  int32_t *replicas;\n  int isr_cnt;\n  int32_t *isrs;\n} rd_kafka_metadata_partition_t;\ntypedef struct rd_kafka_metadata_topic {\n  char *topic;\n  int partition_cnt;\n  struct rd_kafka_metadata_partition *partitions;\n  rd_kafka_resp_err_t err;\n} rd_kafka_metadata_topic_t;\ntypedef struct rd_kafka_metadata {\n  int broker_cnt;\n  struct rd_kafka_metadata_broker *brokers;\n  int topic_cnt;\n  struct rd_kafka_metadata_topic *topics;\n  int32_t orig_broker_id;\n  char *orig_broker_name;\n} rd_kafka_metadata_t;\nrd_kafka_resp_err_t rd_kafka_metadata(rd_kafka_t *rk, int all_topics, rd_kafka_topic_t *only_rkt, const struct rd_kafka_metadata **metadatap, int timeout_ms);\nvoid rd_kafka_metadata_destroy(const struct rd_kafka_metadata *metadata);\ntypedef struct rd_kafka_Node_s rd_kafka_Node_t;\nint rd_kafka_Node_id(const rd_kafka_Node_t *node);\nconst char *rd_kafka_Node_host(const rd_kafka_Node_t *node);\nuint16_t rd_kafka_Node_port(const rd_kafka_Node_t *node);\nstruct rd_kafka_group_member_info {\n  char *member_id;\n  char *client_id;\n  char *client_host;\n  void *member_metadata;\n  int member_metadata_size;\n  void *member_assignment;\n  int member_assignment_size;\n};\ntypedef enum {\n  RD_KAFKA_CONSUMER_GROUP_STATE_UNKNOWN = 0,\n  RD_KAFKA_CONSUMER_GROUP_STATE_PREPARING_REBALANCE = 1,\n  RD_KAFKA_CONSUMER_GROUP_STATE_COMPLETING_REBALANCE = 2,\n  RD_KAFKA_CONSUMER_GROUP_STATE_STABLE = 3,\n  RD_KAFKA_CONSUMER_GROUP_STATE_DEAD = 4,\n  RD_KAFKA_CONSUMER_GROUP_STATE_EMPTY = 5,\n  RD_KAFKA_CONSUMER_GROUP_STATE__CNT,\n} rd_kafka_consumer_group_state_t;\nstruct rd_kafka_group_info {\n  struct rd_kafka_metadata_broker broker;\n  char *group;\n  rd_kafka_resp_err_t err;\n  char *state;\n  char *protocol_type;\n  char *protocol;\n  struct rd_kafka_group_member_info *members;\n  int member_cnt;\n};\nstruct rd_kafka_group_list {\n  struct rd_kafka_group_info *groups;\n  int group_cnt;\n};\nrd_kafka_resp_err_t rd_kafka_list_groups(rd_kafka_t *rk, const char *group, const struct rd_kafka_group_list **grplistp, int timeout_ms);\nconst char *rd_kafka_consumer_group_state_name(rd_kafka_consumer_group_state_t state);\nrd_kafka_consumer_group_state_t rd_kafka_consumer_group_state_code(const char *name);\nvoid rd_kafka_group_list_destroy(const struct rd_kafka_group_list *grplist);\nint rd_kafka_brokers_add(rd_kafka_t *rk, const char *brokerlist);\nvoid rd_kafka_set_logger(rd_kafka_t *rk, void (*func)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));\nvoid rd_kafka_set_log_level(rd_kafka_t *rk, int level);\nvoid rd_kafka_log_print(const rd_kafka_t *rk, int level, const char *fac, const char *buf);\nvoid rd_kafka_log_syslog(const rd_kafka_t *rk, int level, const char *fac, const char *buf);\nint rd_kafka_outq_len(rd_kafka_t *rk);\nvoid rd_kafka_dump(FILE *fp, rd_kafka_t *rk);\nint rd_kafka_thread_cnt(void);\ntypedef enum rd_kafka_thread_type_t {\n  RD_KAFKA_THREAD_MAIN,\n  RD_KAFKA_THREAD_BACKGROUND,\n  RD_KAFKA_THREAD_BROKER,\n} rd_kafka_thread_type_t;\nint rd_kafka_wait_destroyed(int timeout_ms);\nint rd_kafka_unittest(void);\nrd_kafka_resp_err_t rd_kafka_poll_set_consumer(rd_kafka_t *rk);\ntypedef int rd_kafka_event_type_t;\nrd_kafka_event_type_t rd_kafka_event_type(const rd_kafka_event_t *rkev);\nconst char *rd_kafka_event_name(const rd_kafka_event_t *rkev);\nvoid rd_kafka_event_destroy(rd_kafka_event_t *rkev);\nconst rd_kafka_message_t *rd_kafka_event_message_next(rd_kafka_event_t *rkev);\nsize_t rd_kafka_event_message_array(rd_kafka_event_t *rkev, const rd_kafka_message_t **rkmessages, size_t size);\nsize_t rd_kafka_event_message_count(rd_kafka_event_t *rkev);\nconst char *rd_kafka_event_config_string(rd_kafka_event_t *rkev);\nrd_kafka_resp_err_t rd_kafka_event_error(rd_kafka_event_t *rkev);\nconst char *rd_kafka_event_error_string(rd_kafka_event_t *rkev);\nint rd_kafka_event_error_is_fatal(rd_kafka_event_t *rkev);\nvoid *rd_kafka_event_opaque(rd_kafka_event_t *rkev);\nint rd_kafka_event_log(rd_kafka_event_t *rkev, const char **fac, const char **str, int *level);\nint rd_kafka_event_debug_contexts(rd_kafka_event_t *rkev, char *dst, size_t dstsize);\nconst char *rd_kafka_event_stats(rd_kafka_event_t *rkev);\nrd_kafka_topic_partition_list_t *rd_kafka_event_topic_partition_list(rd_kafka_event_t *rkev);\nrd_kafka_topic_partition_t *rd_kafka_event_topic_partition(rd_kafka_event_t *rkev);\ntypedef rd_kafka_event_t rd_kafka_CreateTopics_result_t;\ntypedef rd_kafka_event_t rd_kafka_DeleteTopics_result_t;\ntypedef rd_kafka_event_t rd_kafka_CreateAcls_result_t;\ntypedef rd_kafka_event_t rd_kafka_DescribeAcls_result_t;\ntypedef rd_kafka_event_t rd_kafka_DeleteAcls_result_t;\ntypedef rd_kafka_event_t rd_kafka_CreatePartitions_result_t;\ntypedef rd_kafka_event_t rd_kafka_AlterConfigs_result_t;\ntypedef rd_kafka_event_t rd_kafka_DescribeConfigs_result_t;\ntypedef rd_kafka_event_t rd_kafka_DeleteRecords_result_t;\ntypedef rd_kafka_event_t rd_kafka_ListConsumerGroups_result_t;\ntypedef rd_kafka_event_t rd_kafka_DescribeConsumerGroups_result_t;\ntypedef rd_kafka_event_t rd_kafka_DeleteGroups_result_t;\ntypedef rd_kafka_event_t rd_kafka_DeleteConsumerGroupOffsets_result_t;\ntypedef rd_kafka_event_t rd_kafka_AlterConsumerGroupOffsets_result_t;\ntypedef rd_kafka_event_t rd_kafka_ListConsumerGroupOffsets_result_t;\nconst rd_kafka_CreateTopics_result_t *rd_kafka_event_CreateTopics_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DeleteTopics_result_t *rd_kafka_event_DeleteTopics_result(rd_kafka_event_t *rkev);\nconst rd_kafka_CreatePartitions_result_t *rd_kafka_event_CreatePartitions_result(rd_kafka_event_t *rkev);\nconst rd_kafka_AlterConfigs_result_t *rd_kafka_event_AlterConfigs_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DescribeConfigs_result_t *rd_kafka_event_DescribeConfigs_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DeleteRecords_result_t *rd_kafka_event_DeleteRecords_result(rd_kafka_event_t *rkev);\nconst rd_kafka_ListConsumerGroups_result_t *rd_kafka_event_ListConsumerGroups_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DescribeConsumerGroups_result_t *rd_kafka_event_DescribeConsumerGroups_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DeleteGroups_result_t *rd_kafka_event_DeleteGroups_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DeleteConsumerGroupOffsets_result_t *rd_kafka_event_DeleteConsumerGroupOffsets_result(rd_kafka_event_t *rkev);\nconst rd_kafka_CreateAcls_result_t *rd_kafka_event_CreateAcls_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DescribeAcls_result_t *rd_kafka_event_DescribeAcls_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DeleteAcls_result_t *rd_kafka_event_DeleteAcls_result(rd_kafka_event_t *rkev);\nconst rd_kafka_AlterConsumerGroupOffsets_result_t *rd_kafka_event_AlterConsumerGroupOffsets_result(rd_kafka_event_t *rkev);\nconst rd_kafka_ListConsumerGroupOffsets_result_t *rd_kafka_event_ListConsumerGroupOffsets_result(rd_kafka_event_t *rkev);\nrd_kafka_event_t *rd_kafka_queue_poll(rd_kafka_queue_t *rkqu, int timeout_ms);\nint rd_kafka_queue_poll_callback(rd_kafka_queue_t *rkqu, int timeout_ms);\ntypedef rd_kafka_resp_err_t (rd_kafka_plugin_f_conf_init_t)(rd_kafka_conf_t *conf, void **plug_opaquep, char *errstr, size_t errstr_size);\ntypedef rd_kafka_conf_res_t (rd_kafka_interceptor_f_on_conf_set_t)(rd_kafka_conf_t *conf, const char *name, const char *val, char *errstr, size_t errstr_size, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_dup_t)(rd_kafka_conf_t *new_conf, const rd_kafka_conf_t *old_conf, size_t filter_cnt, const char **filter, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_destroy_t)(void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_new_t)(rd_kafka_t *rk, const rd_kafka_conf_t *conf, void *ic_opaque, char *errstr, size_t errstr_size);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_destroy_t)(rd_kafka_t *rk, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_send_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_acknowledgement_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_consume_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_commit_t)(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_resp_err_t err, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_request_sent_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_response_received_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, int64_t rtt, rd_kafka_resp_err_t err, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_start_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_exit_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_broker_state_change_t)(rd_kafka_t *rk, int32_t broker_id, const char *secproto, const char *name, int port, const char *state, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_set(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_set_t *on_conf_set, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_dup(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_dup_t *on_conf_dup, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_destroy(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_destroy_t *on_conf_destroy, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_new(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_new_t *on_new, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_destroy(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_destroy_t *on_destroy, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_send(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_send_t *on_send, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_acknowledgement(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_acknowledgement_t *on_acknowledgement, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_consume(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_consume_t *on_consume, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_commit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_commit_t *on_commit, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_request_sent(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_request_sent_t *on_request_sent, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_response_received(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_response_received_t *on_response_received, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_start(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_start_t *on_thread_start, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_exit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_exit_t *on_thread_exit, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_broker_state_change(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_broker_state_change_t *on_broker_state_change, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_topic_result_error(const rd_kafka_topic_result_t *topicres);\nconst char *rd_kafka_topic_result_error_string(const rd_kafka_topic_result_t *topicres);\nconst char *rd_kafka_topic_result_name(const rd_kafka_topic_result_t *topicres);\nconst rd_kafka_error_t *rd_kafka_group_result_error(const rd_kafka_group_result_t *groupres);\nconst char *rd_kafka_group_result_name(const rd_kafka_group_result_t *groupres);\nconst rd_kafka_topic_partition_list_t *rd_kafka_group_result_partitions(const rd_kafka_group_result_t *groupres);\ntypedef enum rd_kafka_admin_op_t {\n  RD_KAFKA_ADMIN_OP_ANY = 0,\n  RD_KAFKA_ADMIN_OP_CREATETOPICS,\n  RD_KAFKA_ADMIN_OP_DELETETOPICS,\n  RD_KAFKA_ADMIN_OP_CREATEPARTITIONS,\n  RD_KAFKA_ADMIN_OP_ALTERCONFIGS,\n  RD_KAFKA_ADMIN_OP_DESCRIBECONFIGS,\n  RD_KAFKA_ADMIN_OP_DELETERECORDS,\n  RD_KAFKA_ADMIN_OP_DELETEGROUPS,\n  RD_KAFKA_ADMIN_OP_DELETECONSUMERGROUPOFFSETS,\n  RD_KAFKA_ADMIN_OP_CREATEACLS,\n  RD_KAFKA_ADMIN_OP_DESCRIBEACLS,\n  RD_KAFKA_ADMIN_OP_DELETEACLS,\n  RD_KAFKA_ADMIN_OP_LISTCONSUMERGROUPS,\n  RD_KAFKA_ADMIN_OP_DESCRIBECONSUMERGROUPS,\n  RD_KAFKA_ADMIN_OP_LISTCONSUMERGROUPOFFSETS,\n  RD_KAFKA_ADMIN_OP_ALTERCONSUMERGROUPOFFSETS,\n  RD_KAFKA_ADMIN_OP__CNT,\n} rd_kafka_admin_op_t;\ntypedef struct rd_kafka_AdminOptions_s rd_kafka_AdminOptions_t;\nrd_kafka_AdminOptions_t *rd_kafka_AdminOptions_new(rd_kafka_t *rk, rd_kafka_admin_op_t for_api);\nvoid rd_kafka_AdminOptions_destroy(rd_kafka_AdminOptions_t *options);\nrd_kafka_resp_err_t rd_kafka_AdminOptions_set_request_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_AdminOptions_set_operation_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_AdminOptions_set_validate_only(rd_kafka_AdminOptions_t *options, int true_or_false, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_AdminOptions_set_broker(rd_kafka_AdminOptions_t *options, int32_t broker_id, char *errstr, size_t errstr_size);\nrd_kafka_error_t *rd_kafka_AdminOptions_set_require_stable_offsets(rd_kafka_AdminOptions_t *options, int true_or_false);\nrd_kafka_error_t *rd_kafka_AdminOptions_set_match_consumer_group_states(rd_kafka_AdminOptions_t *options, const rd_kafka_consumer_group_state_t *consumer_group_states, size_t consumer_group_states_cnt);\nvoid rd_kafka_AdminOptions_set_opaque(rd_kafka_AdminOptions_t *options, void *ev_opaque);\ntypedef struct rd_kafka_NewTopic_s rd_kafka_NewTopic_t;\nrd_kafka_NewTopic_t *rd_kafka_NewTopic_new(const char *topic, int num_partitions, int replication_factor, char *errstr, size_t errstr_size);\nvoid rd_kafka_NewTopic_destroy(rd_kafka_NewTopic_t *new_topic);\nvoid rd_kafka_NewTopic_destroy_array(rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt);\nrd_kafka_resp_err_t rd_kafka_NewTopic_set_replica_assignment(rd_kafka_NewTopic_t *new_topic, int32_t partition, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_NewTopic_set_config(rd_kafka_NewTopic_t *new_topic, const char *name, const char *value);\nvoid rd_kafka_CreateTopics(rd_kafka_t *rk, rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_topic_result_t **rd_kafka_CreateTopics_result_topics(const rd_kafka_CreateTopics_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_DeleteTopic_s rd_kafka_DeleteTopic_t;\nrd_kafka_DeleteTopic_t *rd_kafka_DeleteTopic_new(const char *topic);\nvoid rd_kafka_DeleteTopic_destroy(rd_kafka_DeleteTopic_t *del_topic);\nvoid rd_kafka_DeleteTopic_destroy_array(rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt);\nvoid rd_kafka_DeleteTopics(rd_kafka_t *rk, rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_topic_result_t **rd_kafka_DeleteTopics_result_topics(const rd_kafka_DeleteTopics_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_NewPartitions_s rd_kafka_NewPartitions_t;\nrd_kafka_NewPartitions_t *rd_kafka_NewPartitions_new(const char *topic, size_t new_total_cnt, char *errstr, size_t errstr_size);\nvoid rd_kafka_NewPartitions_destroy(rd_kafka_NewPartitions_t *new_parts);\nvoid rd_kafka_NewPartitions_destroy_array(rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt);\nrd_kafka_resp_err_t rd_kafka_NewPartitions_set_replica_assignment(rd_kafka_NewPartitions_t *new_parts, int32_t new_partition_idx, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);\nvoid rd_kafka_CreatePartitions(rd_kafka_t *rk, rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_topic_result_t **rd_kafka_CreatePartitions_result_topics(const rd_kafka_CreatePartitions_result_t *result, size_t *cntp);\ntypedef enum rd_kafka_ConfigSource_t {\n  RD_KAFKA_CONFIG_SOURCE_UNKNOWN_CONFIG = 0,\n  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_TOPIC_CONFIG = 1,\n  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_BROKER_CONFIG = 2,\n  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_DEFAULT_BROKER_CONFIG = 3,\n  RD_KAFKA_CONFIG_SOURCE_STATIC_BROKER_CONFIG = 4,\n  RD_KAFKA_CONFIG_SOURCE_DEFAULT_CONFIG = 5,\n  RD_KAFKA_CONFIG_SOURCE__CNT,\n} rd_kafka_ConfigSource_t;\nconst char *rd_kafka_ConfigSource_name(rd_kafka_ConfigSource_t confsource);\ntypedef struct rd_kafka_ConfigEntry_s rd_kafka_ConfigEntry_t;\nconst char *rd_kafka_ConfigEntry_name(const rd_kafka_ConfigEntry_t *entry);\nconst char *rd_kafka_ConfigEntry_value(const rd_kafka_ConfigEntry_t *entry);\nrd_kafka_ConfigSource_t rd_kafka_ConfigEntry_source(const rd_kafka_ConfigEntry_t *entry);\nint rd_kafka_ConfigEntry_is_read_only(const rd_kafka_ConfigEntry_t *entry);\nint rd_kafka_ConfigEntry_is_default(const rd_kafka_ConfigEntry_t *entry);\nint rd_kafka_ConfigEntry_is_sensitive(const rd_kafka_ConfigEntry_t *entry);\nint rd_kafka_ConfigEntry_is_synonym(const rd_kafka_ConfigEntry_t *entry);\nconst rd_kafka_ConfigEntry_t **rd_kafka_ConfigEntry_synonyms(const rd_kafka_ConfigEntry_t *entry, size_t *cntp);\ntypedef enum rd_kafka_ResourceType_t {\n  RD_KAFKA_RESOURCE_UNKNOWN = 0,\n  RD_KAFKA_RESOURCE_ANY = 1,\n  RD_KAFKA_RESOURCE_TOPIC = 2,\n  RD_KAFKA_RESOURCE_GROUP = 3,\n  RD_KAFKA_RESOURCE_BROKER = 4,\n  RD_KAFKA_RESOURCE__CNT,\n} rd_kafka_ResourceType_t;\ntypedef enum rd_kafka_ResourcePatternType_t {\n  RD_KAFKA_RESOURCE_PATTERN_UNKNOWN = 0,\n  RD_KAFKA_RESOURCE_PATTERN_ANY = 1,\n  RD_KAFKA_RESOURCE_PATTERN_MATCH = 2,\n  RD_KAFKA_RESOURCE_PATTERN_LITERAL = 3,\n  RD_KAFKA_RESOURCE_PATTERN_PREFIXED = 4,\n  RD_KAFKA_RESOURCE_PATTERN_TYPE__CNT,\n} rd_kafka_ResourcePatternType_t;\nconst char *rd_kafka_ResourcePatternType_name(rd_kafka_ResourcePatternType_t resource_pattern_type);\nconst char *rd_kafka_ResourceType_name(rd_kafka_ResourceType_t restype);\ntypedef struct rd_kafka_ConfigResource_s rd_kafka_ConfigResource_t;\nrd_kafka_ConfigResource_t *rd_kafka_ConfigResource_new(rd_kafka_ResourceType_t restype, const char *resname);\nvoid rd_kafka_ConfigResource_destroy(rd_kafka_ConfigResource_t *config);\nvoid rd_kafka_ConfigResource_destroy_array(rd_kafka_ConfigResource_t **config, size_t config_cnt);\nrd_kafka_resp_err_t rd_kafka_ConfigResource_set_config(rd_kafka_ConfigResource_t *config, const char *name, const char *value);\nconst rd_kafka_ConfigEntry_t **rd_kafka_ConfigResource_configs(const rd_kafka_ConfigResource_t *config, size_t *cntp);\nrd_kafka_ResourceType_t rd_kafka_ConfigResource_type(const rd_kafka_ConfigResource_t *config);\nconst char *rd_kafka_ConfigResource_name(const rd_kafka_ConfigResource_t *config);\nrd_kafka_resp_err_t rd_kafka_ConfigResource_error(const rd_kafka_ConfigResource_t *config);\nconst char *rd_kafka_ConfigResource_error_string(const rd_kafka_ConfigResource_t *config);\nvoid rd_kafka_AlterConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_ConfigResource_t **rd_kafka_AlterConfigs_result_resources(const rd_kafka_AlterConfigs_result_t *result, size_t *cntp);\nvoid rd_kafka_DescribeConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_ConfigResource_t **rd_kafka_DescribeConfigs_result_resources(const rd_kafka_DescribeConfigs_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_DeleteRecords_s rd_kafka_DeleteRecords_t;\nrd_kafka_DeleteRecords_t *rd_kafka_DeleteRecords_new(const rd_kafka_topic_partition_list_t *before_offsets);\nvoid rd_kafka_DeleteRecords_destroy(rd_kafka_DeleteRecords_t *del_records);\nvoid rd_kafka_DeleteRecords_destroy_array(rd_kafka_DeleteRecords_t **del_records, size_t del_record_cnt);\nvoid rd_kafka_DeleteRecords(rd_kafka_t *rk, rd_kafka_DeleteRecords_t **del_records, size_t del_record_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_topic_partition_list_t *rd_kafka_DeleteRecords_result_offsets(const rd_kafka_DeleteRecords_result_t *result);\ntypedef struct rd_kafka_ConsumerGroupListing_s rd_kafka_ConsumerGroupListing_t;\ntypedef struct rd_kafka_ListConsumerGroupsResult_s rd_kafka_ListConsumerGroupsResult_t;\nvoid rd_kafka_ListConsumerGroups(rd_kafka_t *rk, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst char *rd_kafka_ConsumerGroupListing_group_id(const rd_kafka_ConsumerGroupListing_t *grplist);\nint rd_kafka_ConsumerGroupListing_is_simple_consumer_group(const rd_kafka_ConsumerGroupListing_t *grplist);\nrd_kafka_consumer_group_state_t rd_kafka_ConsumerGroupListing_state(const rd_kafka_ConsumerGroupListing_t *grplist);\nconst rd_kafka_ConsumerGroupListing_t **rd_kafka_ListConsumerGroups_result_valid(const rd_kafka_ListConsumerGroups_result_t *result, size_t *cntp);\nconst rd_kafka_error_t **rd_kafka_ListConsumerGroups_result_errors(const rd_kafka_ListConsumerGroups_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_ConsumerGroupDescription_s rd_kafka_ConsumerGroupDescription_t;\ntypedef struct rd_kafka_MemberDescription_s rd_kafka_MemberDescription_t;\ntypedef struct rd_kafka_MemberAssignment_s rd_kafka_MemberAssignment_t;\nvoid rd_kafka_DescribeConsumerGroups(rd_kafka_t *rk, const char **groups, size_t groups_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_ConsumerGroupDescription_t **rd_kafka_DescribeConsumerGroups_result_groups(const rd_kafka_DescribeConsumerGroups_result_t *result, size_t *cntp);\nconst char *rd_kafka_ConsumerGroupDescription_group_id(const rd_kafka_ConsumerGroupDescription_t *grpdesc);\nconst rd_kafka_error_t *rd_kafka_ConsumerGroupDescription_error(const rd_kafka_ConsumerGroupDescription_t *grpdesc);\nint rd_kafka_ConsumerGroupDescription_is_simple_consumer_group(const rd_kafka_ConsumerGroupDescription_t *grpdesc);\nconst char *rd_kafka_ConsumerGroupDescription_partition_assignor(const rd_kafka_ConsumerGroupDescription_t *grpdesc);\nrd_kafka_consumer_group_state_t rd_kafka_ConsumerGroupDescription_state(const rd_kafka_ConsumerGroupDescription_t *grpdesc);\nconst rd_kafka_Node_t *rd_kafka_ConsumerGroupDescription_coordinator(const rd_kafka_ConsumerGroupDescription_t *grpdesc);\nsize_t rd_kafka_ConsumerGroupDescription_member_count(const rd_kafka_ConsumerGroupDescription_t *grpdesc);\nconst rd_kafka_MemberDescription_t *rd_kafka_ConsumerGroupDescription_member(const rd_kafka_ConsumerGroupDescription_t *grpdesc, size_t idx);\nconst char *rd_kafka_MemberDescription_client_id(const rd_kafka_MemberDescription_t *member);\nconst char *rd_kafka_MemberDescription_group_instance_id(const rd_kafka_MemberDescription_t *member);\nconst char *rd_kafka_MemberDescription_consumer_id(const rd_kafka_MemberDescription_t *member);\nconst char *rd_kafka_MemberDescription_host(const rd_kafka_MemberDescription_t *member);\nconst rd_kafka_MemberAssignment_t *rd_kafka_MemberDescription_assignment(const rd_kafka_MemberDescription_t *member);\nconst rd_kafka_topic_partition_list_t *rd_kafka_MemberAssignment_partitions(const rd_kafka_MemberAssignment_t *assignment);\ntypedef struct rd_kafka_DeleteGroup_s rd_kafka_DeleteGroup_t;\nrd_kafka_DeleteGroup_t *rd_kafka_DeleteGroup_new(const char *group);\nvoid rd_kafka_DeleteGroup_destroy(rd_kafka_DeleteGroup_t *del_group);\nvoid rd_kafka_DeleteGroup_destroy_array(rd_kafka_DeleteGroup_t **del_groups, size_t del_group_cnt);\nvoid rd_kafka_DeleteGroups(rd_kafka_t *rk, rd_kafka_DeleteGroup_t **del_groups, size_t del_group_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_group_result_t **rd_kafka_DeleteGroups_result_groups(const rd_kafka_DeleteGroups_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_ListConsumerGroupOffsets_s rd_kafka_ListConsumerGroupOffsets_t;\nrd_kafka_ListConsumerGroupOffsets_t *rd_kafka_ListConsumerGroupOffsets_new(const char *group_id, const rd_kafka_topic_partition_list_t *partitions);\nvoid rd_kafka_ListConsumerGroupOffsets_destroy(rd_kafka_ListConsumerGroupOffsets_t *list_grpoffsets);\nvoid rd_kafka_ListConsumerGroupOffsets_destroy_array(rd_kafka_ListConsumerGroupOffsets_t **list_grpoffsets, size_t list_grpoffset_cnt);\nvoid rd_kafka_ListConsumerGroupOffsets(rd_kafka_t *rk, rd_kafka_ListConsumerGroupOffsets_t **list_grpoffsets, size_t list_grpoffsets_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_group_result_t **rd_kafka_ListConsumerGroupOffsets_result_groups(const rd_kafka_ListConsumerGroupOffsets_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_AlterConsumerGroupOffsets_s rd_kafka_AlterConsumerGroupOffsets_t;\nrd_kafka_AlterConsumerGroupOffsets_t *rd_kafka_AlterConsumerGroupOffsets_new(const char *group_id, const rd_kafka_topic_partition_list_t *partitions);\nvoid rd_kafka_AlterConsumerGroupOffsets_destroy(rd_kafka_AlterConsumerGroupOffsets_t *alter_grpoffsets);\nvoid rd_kafka_AlterConsumerGroupOffsets_destroy_array(rd_kafka_AlterConsumerGroupOffsets_t **alter_grpoffsets, size_t alter_grpoffset_cnt);\nvoid rd_kafka_AlterConsumerGroupOffsets(rd_kafka_t *rk, rd_kafka_AlterConsumerGroupOffsets_t **alter_grpoffsets, size_t alter_grpoffsets_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_group_result_t **rd_kafka_AlterConsumerGroupOffsets_result_groups(const rd_kafka_AlterConsumerGroupOffsets_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_DeleteConsumerGroupOffsets_s rd_kafka_DeleteConsumerGroupOffsets_t;\nrd_kafka_DeleteConsumerGroupOffsets_t *rd_kafka_DeleteConsumerGroupOffsets_new(const char *group, const rd_kafka_topic_partition_list_t *partitions);\nvoid rd_kafka_DeleteConsumerGroupOffsets_destroy(rd_kafka_DeleteConsumerGroupOffsets_t *del_grpoffsets);\nvoid rd_kafka_DeleteConsumerGroupOffsets_destroy_array(rd_kafka_DeleteConsumerGroupOffsets_t **del_grpoffsets, size_t del_grpoffset_cnt);\nvoid rd_kafka_DeleteConsumerGroupOffsets(rd_kafka_t *rk, rd_kafka_DeleteConsumerGroupOffsets_t **del_grpoffsets, size_t del_grpoffsets_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_group_result_t **rd_kafka_DeleteConsumerGroupOffsets_result_groups(const rd_kafka_DeleteConsumerGroupOffsets_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_AclBinding_s rd_kafka_AclBinding_t;\ntypedef rd_kafka_AclBinding_t rd_kafka_AclBindingFilter_t;\nconst rd_kafka_error_t *rd_kafka_acl_result_error(const rd_kafka_acl_result_t *aclres);\ntypedef enum rd_kafka_AclOperation_t {\n  RD_KAFKA_ACL_OPERATION_UNKNOWN = 0,\n  RD_KAFKA_ACL_OPERATION_ANY = 1,\n  RD_KAFKA_ACL_OPERATION_ALL = 2,\n  RD_KAFKA_ACL_OPERATION_READ = 3,\n  RD_KAFKA_ACL_OPERATION_WRITE = 4,\n  RD_KAFKA_ACL_OPERATION_CREATE = 5,\n  RD_KAFKA_ACL_OPERATION_DELETE = 6,\n  RD_KAFKA_ACL_OPERATION_ALTER = 7,\n  RD_KAFKA_ACL_OPERATION_DESCRIBE = 8,\n  RD_KAFKA_ACL_OPERATION_CLUSTER_ACTION = 9,\n  RD_KAFKA_ACL_OPERATION_DESCRIBE_CONFIGS = 10,\n  RD_KAFKA_ACL_OPERATION_ALTER_CONFIGS = 11,\n  RD_KAFKA_ACL_OPERATION_IDEMPOTENT_WRITE = 12,\n  RD_KAFKA_ACL_OPERATION__CNT,\n} rd_kafka_AclOperation_t;\nconst char *rd_kafka_AclOperation_name(rd_kafka_AclOperation_t acl_operation);\ntypedef enum rd_kafka_AclPermissionType_t {\n  RD_KAFKA_ACL_PERMISSION_TYPE_UNKNOWN = 0,\n  RD_KAFKA_ACL_PERMISSION_TYPE_ANY = 1,\n  RD_KAFKA_ACL_PERMISSION_TYPE_DENY = 2,\n  RD_KAFKA_ACL_PERMISSION_TYPE_ALLOW = 3,\n  RD_KAFKA_ACL_PERMISSION_TYPE__CNT,\n} rd_kafka_AclPermissionType_t;\nconst char *rd_kafka_AclPermissionType_name(rd_kafka_AclPermissionType_t acl_permission_type);\nrd_kafka_AclBinding_t *rd_kafka_AclBinding_new(rd_kafka_ResourceType_t restype, const char *name, rd_kafka_ResourcePatternType_t resource_pattern_type, const char *principal, const char *host, rd_kafka_AclOperation_t operation, rd_kafka_AclPermissionType_t permission_type, char *errstr, size_t errstr_size);\nrd_kafka_AclBindingFilter_t *rd_kafka_AclBindingFilter_new(rd_kafka_ResourceType_t restype, const char *name, rd_kafka_ResourcePatternType_t resource_pattern_type, const char *principal, const char *host, rd_kafka_AclOperation_t operation, rd_kafka_AclPermissionType_t permission_type, char *errstr, size_t errstr_size);\nrd_kafka_ResourceType_t rd_kafka_AclBinding_restype(const rd_kafka_AclBinding_t *acl);\nconst char *rd_kafka_AclBinding_name(const rd_kafka_AclBinding_t *acl);\nconst char *rd_kafka_AclBinding_principal(const rd_kafka_AclBinding_t *acl);\nconst char *rd_kafka_AclBinding_host(const rd_kafka_AclBinding_t *acl);\nrd_kafka_AclOperation_t rd_kafka_AclBinding_operation(const rd_kafka_AclBinding_t *acl);\nrd_kafka_AclPermissionType_t rd_kafka_AclBinding_permission_type(const rd_kafka_AclBinding_t *acl);\nrd_kafka_ResourcePatternType_t rd_kafka_AclBinding_resource_pattern_type(const rd_kafka_AclBinding_t *acl);\nconst rd_kafka_error_t *rd_kafka_AclBinding_error(const rd_kafka_AclBinding_t *acl);\nvoid rd_kafka_AclBinding_destroy(rd_kafka_AclBinding_t *acl_binding);\nvoid rd_kafka_AclBinding_destroy_array(rd_kafka_AclBinding_t **acl_bindings, size_t acl_bindings_cnt);\nconst rd_kafka_acl_result_t **rd_kafka_CreateAcls_result_acls(const rd_kafka_CreateAcls_result_t *result, size_t *cntp);\nvoid rd_kafka_CreateAcls(rd_kafka_t *rk, rd_kafka_AclBinding_t **new_acls, size_t new_acls_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_AclBinding_t **rd_kafka_DescribeAcls_result_acls(const rd_kafka_DescribeAcls_result_t *result, size_t *cntp);\nvoid rd_kafka_DescribeAcls(rd_kafka_t *rk, rd_kafka_AclBindingFilter_t *acl_filter, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\ntypedef struct rd_kafka_DeleteAcls_result_response_s rd_kafka_DeleteAcls_result_response_t;\nconst rd_kafka_DeleteAcls_result_response_t **rd_kafka_DeleteAcls_result_responses(const rd_kafka_DeleteAcls_result_t *result, size_t *cntp);\nconst rd_kafka_error_t *rd_kafka_DeleteAcls_result_response_error(const rd_kafka_DeleteAcls_result_response_t *result_response);\nconst rd_kafka_AclBinding_t **rd_kafka_DeleteAcls_result_response_matching_acls(const rd_kafka_DeleteAcls_result_response_t *result_response, size_t *matching_acls_cntp);\nvoid rd_kafka_DeleteAcls(rd_kafka_t *rk, rd_kafka_AclBindingFilter_t **del_acls, size_t del_acls_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nrd_kafka_resp_err_t rd_kafka_oauthbearer_set_token(rd_kafka_t *rk, const char *token_value, int64_t md_lifetime_ms, const char *md_principal_name, const char **extensions, size_t extension_size, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_oauthbearer_set_token_failure(rd_kafka_t *rk, const char *errstr);\nrd_kafka_error_t *rd_kafka_init_transactions(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_error_t *rd_kafka_begin_transaction(rd_kafka_t *rk);\nrd_kafka_error_t *rd_kafka_send_offsets_to_transaction(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, const rd_kafka_consumer_group_metadata_t *cgmetadata, int timeout_ms);\nrd_kafka_error_t *rd_kafka_commit_transaction(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_error_t *rd_kafka_abort_transaction(rd_kafka_t *rk, int timeout_ms);\ntypedef struct rd_kafka_mock_cluster_s rd_kafka_mock_cluster_t;\nrd_kafka_mock_cluster_t *rd_kafka_mock_cluster_new(rd_kafka_t *rk, int broker_cnt);\nvoid rd_kafka_mock_cluster_destroy(rd_kafka_mock_cluster_t *mcluster);\nrd_kafka_t *rd_kafka_mock_cluster_handle(const rd_kafka_mock_cluster_t *mcluster);\nrd_kafka_mock_cluster_t *rd_kafka_handle_mock_cluster(const rd_kafka_t *rk);\nconst char *rd_kafka_mock_cluster_bootstraps(const rd_kafka_mock_cluster_t *mcluster);\nvoid rd_kafka_mock_clear_request_errors(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey);\nvoid rd_kafka_mock_push_request_errors(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, size_t cnt, ...);\nvoid rd_kafka_mock_push_request_errors_array(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, size_t cnt, const rd_kafka_resp_err_t *errors);\nrd_kafka_resp_err_t rd_kafka_mock_broker_push_request_error_rtts(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int16_t ApiKey, size_t cnt, ...);\nrd_kafka_resp_err_t rd_kafka_mock_broker_error_stack_cnt(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int16_t ApiKey, size_t *cntp);\nvoid rd_kafka_mock_topic_set_error(rd_kafka_mock_cluster_t *mcluster, const char *topic, rd_kafka_resp_err_t err);\nrd_kafka_resp_err_t rd_kafka_mock_topic_create(rd_kafka_mock_cluster_t *mcluster, const char *topic, int partition_cnt, int replication_factor);\nrd_kafka_resp_err_t rd_kafka_mock_partition_set_leader(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id);\nrd_kafka_resp_err_t rd_kafka_mock_partition_set_follower(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id);\nrd_kafka_resp_err_t rd_kafka_mock_partition_set_follower_wmarks(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int64_t lo, int64_t hi);\nrd_kafka_resp_err_t rd_kafka_mock_broker_set_down(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id);\nrd_kafka_resp_err_t rd_kafka_mock_broker_set_up(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id);\nrd_kafka_resp_err_t rd_kafka_mock_broker_set_rtt(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int rtt_ms);\nrd_kafka_resp_err_t rd_kafka_mock_broker_set_rack(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, const char *rack);\nrd_kafka_resp_err_t rd_kafka_mock_coordinator_set(rd_kafka_mock_cluster_t *mcluster, const char *key_type, const char *key, int32_t broker_id);\nrd_kafka_resp_err_t rd_kafka_mock_set_apiversion(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, int16_t MinVersion, int16_t MaxVersion);\n'\n</code></pre> rdkafka.h, rdkafka_mock.h</p>"},{"location":"api/constants/#rd_kafka_version_27","title":"RD_KAFKA_VERSION","text":"<pre><code>public RD_KAFKA_VERSION = 33685759\n</code></pre> <p>librdkafka version </p> <p>Interpreted as hex <code>MM.mm.rr.xx</code>:</p> <ul> <li>MM = Major</li> <li>mm = minor</li> <li>rr = revision</li> <li>xx = pre-release id (0xff is the final release)</li> </ul> <p>E.g.: <code>0x000801ff</code> = 0.8.1</p> RemarksThis value should only be used during compile time, for runtime checks of version use rd_kafka_version()  <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_unsupported_compression_type_27","title":"RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE","text":"<pre><code>public RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76\n</code></pre> <p>Unsupported compression type </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_end_all_27","title":"RD_KAFKA_RESP_ERR_END_ALL","text":"<p><pre><code>public RD_KAFKA_RESP_ERR_END_ALL = 98\n</code></pre> enum rd_kafka_resp_err_t</p>"},{"location":"api/constants/#rd_kafka_admin_op__cnt_27","title":"RD_KAFKA_ADMIN_OP__CNT","text":"<pre><code>public RD_KAFKA_ADMIN_OP__CNT = 19\n</code></pre> <p>Number of ops defined </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe </li> </ul>"},{"location":"api/constants/#rd_kafka_resource__cnt_27","title":"RD_KAFKA_RESOURCE__CNT","text":"<pre><code>public RD_KAFKA_RESOURCE__CNT = 5\n</code></pre> <p>Number of resource types defined </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#acca83a66d7783ff7683ed2691cc907c9 </li> </ul>"},{"location":"api/constants/#rd_kafka_cdef_27","title":"RD_KAFKA_CDEF","text":"<p><pre><code>public RD_KAFKA_CDEF = 'typedef long int ssize_t;\ntypedef struct _IO_FILE FILE;\ntypedef long int mode_t;\ntypedef signed int int16_t;\ntypedef unsigned int uint16_t;\ntypedef signed int int32_t;\ntypedef signed long int int64_t;\nint rd_kafka_version(void);\nconst char *rd_kafka_version_str(void);\ntypedef enum rd_kafka_type_t {\n  RD_KAFKA_PRODUCER,\n  RD_KAFKA_CONSUMER,\n} rd_kafka_type_t;\ntypedef enum rd_kafka_timestamp_type_t {\n  RD_KAFKA_TIMESTAMP_NOT_AVAILABLE,\n  RD_KAFKA_TIMESTAMP_CREATE_TIME,\n  RD_KAFKA_TIMESTAMP_LOG_APPEND_TIME,\n} rd_kafka_timestamp_type_t;\nconst char *rd_kafka_get_debug_contexts(void);\ntypedef struct rd_kafka_s rd_kafka_t;\ntypedef struct rd_kafka_topic_s rd_kafka_topic_t;\ntypedef struct rd_kafka_conf_s rd_kafka_conf_t;\ntypedef struct rd_kafka_topic_conf_s rd_kafka_topic_conf_t;\ntypedef struct rd_kafka_queue_s rd_kafka_queue_t;\ntypedef struct rd_kafka_op_s rd_kafka_event_t;\ntypedef struct rd_kafka_topic_result_s rd_kafka_topic_result_t;\ntypedef struct rd_kafka_consumer_group_metadata_s rd_kafka_consumer_group_metadata_t;\ntypedef struct rd_kafka_error_s {\n  unsigned int code;\n  char *errstr;\n  unsigned char fatal;\n  unsigned char retriable;\n  unsigned char txn_requires_abort;\n} rd_kafka_error_t;\ntypedef struct rd_kafka_headers_s rd_kafka_headers_t;\ntypedef struct rd_kafka_group_result_s rd_kafka_group_result_t;\ntypedef struct rd_kafka_acl_result_s rd_kafka_acl_result_t;\ntypedef enum {\n  RD_KAFKA_RESP_ERR__BEGIN = (- 200),\n  RD_KAFKA_RESP_ERR__BAD_MSG = (- 199),\n  RD_KAFKA_RESP_ERR__BAD_COMPRESSION = (- 198),\n  RD_KAFKA_RESP_ERR__DESTROY = (- 197),\n  RD_KAFKA_RESP_ERR__FAIL = (- 196),\n  RD_KAFKA_RESP_ERR__TRANSPORT = (- 195),\n  RD_KAFKA_RESP_ERR__CRIT_SYS_RESOURCE = (- 194),\n  RD_KAFKA_RESP_ERR__RESOLVE = (- 193),\n  RD_KAFKA_RESP_ERR__MSG_TIMED_OUT = (- 192),\n  RD_KAFKA_RESP_ERR__PARTITION_EOF = (- 191),\n  RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION = (- 190),\n  RD_KAFKA_RESP_ERR__FS = (- 189),\n  RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC = (- 188),\n  RD_KAFKA_RESP_ERR__ALL_BROKERS_DOWN = (- 187),\n  RD_KAFKA_RESP_ERR__INVALID_ARG = (- 186),\n  RD_KAFKA_RESP_ERR__TIMED_OUT = (- 185),\n  RD_KAFKA_RESP_ERR__QUEUE_FULL = (- 184),\n  RD_KAFKA_RESP_ERR__ISR_INSUFF = (- 183),\n  RD_KAFKA_RESP_ERR__NODE_UPDATE = (- 182),\n  RD_KAFKA_RESP_ERR__SSL = (- 181),\n  RD_KAFKA_RESP_ERR__WAIT_COORD = (- 180),\n  RD_KAFKA_RESP_ERR__UNKNOWN_GROUP = (- 179),\n  RD_KAFKA_RESP_ERR__IN_PROGRESS = (- 178),\n  RD_KAFKA_RESP_ERR__PREV_IN_PROGRESS = (- 177),\n  RD_KAFKA_RESP_ERR__EXISTING_SUBSCRIPTION = (- 176),\n  RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS = (- 175),\n  RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS = (- 174),\n  RD_KAFKA_RESP_ERR__CONFLICT = (- 173),\n  RD_KAFKA_RESP_ERR__STATE = (- 172),\n  RD_KAFKA_RESP_ERR__UNKNOWN_PROTOCOL = (- 171),\n  RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED = (- 170),\n  RD_KAFKA_RESP_ERR__AUTHENTICATION = (- 169),\n  RD_KAFKA_RESP_ERR__NO_OFFSET = (- 168),\n  RD_KAFKA_RESP_ERR__OUTDATED = (- 167),\n  RD_KAFKA_RESP_ERR__TIMED_OUT_QUEUE = (- 166),\n  RD_KAFKA_RESP_ERR__UNSUPPORTED_FEATURE = (- 165),\n  RD_KAFKA_RESP_ERR__WAIT_CACHE = (- 164),\n  RD_KAFKA_RESP_ERR__INTR = (- 163),\n  RD_KAFKA_RESP_ERR__KEY_SERIALIZATION = (- 162),\n  RD_KAFKA_RESP_ERR__VALUE_SERIALIZATION = (- 161),\n  RD_KAFKA_RESP_ERR__KEY_DESERIALIZATION = (- 160),\n  RD_KAFKA_RESP_ERR__VALUE_DESERIALIZATION = (- 159),\n  RD_KAFKA_RESP_ERR__PARTIAL = (- 158),\n  RD_KAFKA_RESP_ERR__READ_ONLY = (- 157),\n  RD_KAFKA_RESP_ERR__NOENT = (- 156),\n  RD_KAFKA_RESP_ERR__UNDERFLOW = (- 155),\n  RD_KAFKA_RESP_ERR__INVALID_TYPE = (- 154),\n  RD_KAFKA_RESP_ERR__RETRY = (- 153),\n  RD_KAFKA_RESP_ERR__PURGE_QUEUE = (- 152),\n  RD_KAFKA_RESP_ERR__PURGE_INFLIGHT = (- 151),\n  RD_KAFKA_RESP_ERR__FATAL = (- 150),\n  RD_KAFKA_RESP_ERR__INCONSISTENT = (- 149),\n  RD_KAFKA_RESP_ERR__GAPLESS_GUARANTEE = (- 148),\n  RD_KAFKA_RESP_ERR__MAX_POLL_EXCEEDED = (- 147),\n  RD_KAFKA_RESP_ERR__UNKNOWN_BROKER = (- 146),\n  RD_KAFKA_RESP_ERR__NOT_CONFIGURED = (- 145),\n  RD_KAFKA_RESP_ERR__FENCED = (- 144),\n  RD_KAFKA_RESP_ERR__APPLICATION = (- 143),\n  RD_KAFKA_RESP_ERR__ASSIGNMENT_LOST = (- 142),\n  RD_KAFKA_RESP_ERR__NOOP = (- 141),\n  RD_KAFKA_RESP_ERR__AUTO_OFFSET_RESET = (- 140),\n  RD_KAFKA_RESP_ERR__LOG_TRUNCATION = (- 139),\n  RD_KAFKA_RESP_ERR__END = (- 100),\n  RD_KAFKA_RESP_ERR_UNKNOWN = (- 1),\n  RD_KAFKA_RESP_ERR_NO_ERROR = 0,\n  RD_KAFKA_RESP_ERR_OFFSET_OUT_OF_RANGE = 1,\n  RD_KAFKA_RESP_ERR_INVALID_MSG = 2,\n  RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART = 3,\n  RD_KAFKA_RESP_ERR_INVALID_MSG_SIZE = 4,\n  RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE = 5,\n  RD_KAFKA_RESP_ERR_NOT_LEADER_FOR_PARTITION = 6,\n  RD_KAFKA_RESP_ERR_REQUEST_TIMED_OUT = 7,\n  RD_KAFKA_RESP_ERR_BROKER_NOT_AVAILABLE = 8,\n  RD_KAFKA_RESP_ERR_REPLICA_NOT_AVAILABLE = 9,\n  RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE = 10,\n  RD_KAFKA_RESP_ERR_STALE_CTRL_EPOCH = 11,\n  RD_KAFKA_RESP_ERR_OFFSET_METADATA_TOO_LARGE = 12,\n  RD_KAFKA_RESP_ERR_NETWORK_EXCEPTION = 13,\n  RD_KAFKA_RESP_ERR_COORDINATOR_LOAD_IN_PROGRESS = 14,\n  RD_KAFKA_RESP_ERR_COORDINATOR_NOT_AVAILABLE = 15,\n  RD_KAFKA_RESP_ERR_NOT_COORDINATOR = 16,\n  RD_KAFKA_RESP_ERR_TOPIC_EXCEPTION = 17,\n  RD_KAFKA_RESP_ERR_RECORD_LIST_TOO_LARGE = 18,\n  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS = 19,\n  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS_AFTER_APPEND = 20,\n  RD_KAFKA_RESP_ERR_INVALID_REQUIRED_ACKS = 21,\n  RD_KAFKA_RESP_ERR_ILLEGAL_GENERATION = 22,\n  RD_KAFKA_RESP_ERR_INCONSISTENT_GROUP_PROTOCOL = 23,\n  RD_KAFKA_RESP_ERR_INVALID_GROUP_ID = 24,\n  RD_KAFKA_RESP_ERR_UNKNOWN_MEMBER_ID = 25,\n  RD_KAFKA_RESP_ERR_INVALID_SESSION_TIMEOUT = 26,\n  RD_KAFKA_RESP_ERR_REBALANCE_IN_PROGRESS = 27,\n  RD_KAFKA_RESP_ERR_INVALID_COMMIT_OFFSET_SIZE = 28,\n  RD_KAFKA_RESP_ERR_TOPIC_AUTHORIZATION_FAILED = 29,\n  RD_KAFKA_RESP_ERR_GROUP_AUTHORIZATION_FAILED = 30,\n  RD_KAFKA_RESP_ERR_CLUSTER_AUTHORIZATION_FAILED = 31,\n  RD_KAFKA_RESP_ERR_INVALID_TIMESTAMP = 32,\n  RD_KAFKA_RESP_ERR_UNSUPPORTED_SASL_MECHANISM = 33,\n  RD_KAFKA_RESP_ERR_ILLEGAL_SASL_STATE = 34,\n  RD_KAFKA_RESP_ERR_UNSUPPORTED_VERSION = 35,\n  RD_KAFKA_RESP_ERR_TOPIC_ALREADY_EXISTS = 36,\n  RD_KAFKA_RESP_ERR_INVALID_PARTITIONS = 37,\n  RD_KAFKA_RESP_ERR_INVALID_REPLICATION_FACTOR = 38,\n  RD_KAFKA_RESP_ERR_INVALID_REPLICA_ASSIGNMENT = 39,\n  RD_KAFKA_RESP_ERR_INVALID_CONFIG = 40,\n  RD_KAFKA_RESP_ERR_NOT_CONTROLLER = 41,\n  RD_KAFKA_RESP_ERR_INVALID_REQUEST = 42,\n  RD_KAFKA_RESP_ERR_UNSUPPORTED_FOR_MESSAGE_FORMAT = 43,\n  RD_KAFKA_RESP_ERR_POLICY_VIOLATION = 44,\n  RD_KAFKA_RESP_ERR_OUT_OF_ORDER_SEQUENCE_NUMBER = 45,\n  RD_KAFKA_RESP_ERR_DUPLICATE_SEQUENCE_NUMBER = 46,\n  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_EPOCH = 47,\n  RD_KAFKA_RESP_ERR_INVALID_TXN_STATE = 48,\n  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_ID_MAPPING = 49,\n  RD_KAFKA_RESP_ERR_INVALID_TRANSACTION_TIMEOUT = 50,\n  RD_KAFKA_RESP_ERR_CONCURRENT_TRANSACTIONS = 51,\n  RD_KAFKA_RESP_ERR_TRANSACTION_COORDINATOR_FENCED = 52,\n  RD_KAFKA_RESP_ERR_TRANSACTIONAL_ID_AUTHORIZATION_FAILED = 53,\n  RD_KAFKA_RESP_ERR_SECURITY_DISABLED = 54,\n  RD_KAFKA_RESP_ERR_OPERATION_NOT_ATTEMPTED = 55,\n  RD_KAFKA_RESP_ERR_KAFKA_STORAGE_ERROR = 56,\n  RD_KAFKA_RESP_ERR_LOG_DIR_NOT_FOUND = 57,\n  RD_KAFKA_RESP_ERR_SASL_AUTHENTICATION_FAILED = 58,\n  RD_KAFKA_RESP_ERR_UNKNOWN_PRODUCER_ID = 59,\n  RD_KAFKA_RESP_ERR_REASSIGNMENT_IN_PROGRESS = 60,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTH_DISABLED = 61,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_NOT_FOUND = 62,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_OWNER_MISMATCH = 63,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_REQUEST_NOT_ALLOWED = 64,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTHORIZATION_FAILED = 65,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_EXPIRED = 66,\n  RD_KAFKA_RESP_ERR_INVALID_PRINCIPAL_TYPE = 67,\n  RD_KAFKA_RESP_ERR_NON_EMPTY_GROUP = 68,\n  RD_KAFKA_RESP_ERR_GROUP_ID_NOT_FOUND = 69,\n  RD_KAFKA_RESP_ERR_FETCH_SESSION_ID_NOT_FOUND = 70,\n  RD_KAFKA_RESP_ERR_INVALID_FETCH_SESSION_EPOCH = 71,\n  RD_KAFKA_RESP_ERR_LISTENER_NOT_FOUND = 72,\n  RD_KAFKA_RESP_ERR_TOPIC_DELETION_DISABLED = 73,\n  RD_KAFKA_RESP_ERR_FENCED_LEADER_EPOCH = 74,\n  RD_KAFKA_RESP_ERR_UNKNOWN_LEADER_EPOCH = 75,\n  RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76,\n  RD_KAFKA_RESP_ERR_STALE_BROKER_EPOCH = 77,\n  RD_KAFKA_RESP_ERR_OFFSET_NOT_AVAILABLE = 78,\n  RD_KAFKA_RESP_ERR_MEMBER_ID_REQUIRED = 79,\n  RD_KAFKA_RESP_ERR_PREFERRED_LEADER_NOT_AVAILABLE = 80,\n  RD_KAFKA_RESP_ERR_GROUP_MAX_SIZE_REACHED = 81,\n  RD_KAFKA_RESP_ERR_FENCED_INSTANCE_ID = 82,\n  RD_KAFKA_RESP_ERR_ELIGIBLE_LEADERS_NOT_AVAILABLE = 83,\n  RD_KAFKA_RESP_ERR_ELECTION_NOT_NEEDED = 84,\n  RD_KAFKA_RESP_ERR_NO_REASSIGNMENT_IN_PROGRESS = 85,\n  RD_KAFKA_RESP_ERR_GROUP_SUBSCRIBED_TO_TOPIC = 86,\n  RD_KAFKA_RESP_ERR_INVALID_RECORD = 87,\n  RD_KAFKA_RESP_ERR_UNSTABLE_OFFSET_COMMIT = 88,\n  RD_KAFKA_RESP_ERR_THROTTLING_QUOTA_EXCEEDED = 89,\n  RD_KAFKA_RESP_ERR_PRODUCER_FENCED = 90,\n  RD_KAFKA_RESP_ERR_RESOURCE_NOT_FOUND = 91,\n  RD_KAFKA_RESP_ERR_DUPLICATE_RESOURCE = 92,\n  RD_KAFKA_RESP_ERR_UNACCEPTABLE_CREDENTIAL = 93,\n  RD_KAFKA_RESP_ERR_INCONSISTENT_VOTER_SET = 94,\n  RD_KAFKA_RESP_ERR_INVALID_UPDATE_VERSION = 95,\n  RD_KAFKA_RESP_ERR_FEATURE_UPDATE_FAILED = 96,\n  RD_KAFKA_RESP_ERR_PRINCIPAL_DESERIALIZATION_FAILURE = 97,\n  RD_KAFKA_RESP_ERR_END_ALL,\n} rd_kafka_resp_err_t;\nstruct rd_kafka_err_desc {\n  rd_kafka_resp_err_t code;\n  char *name;\n  char *desc;\n};\nvoid rd_kafka_get_err_descs(const struct rd_kafka_err_desc **errdescs, size_t *cntp);\nconst char *rd_kafka_err2str(rd_kafka_resp_err_t err);\nconst char *rd_kafka_err2name(rd_kafka_resp_err_t err);\nrd_kafka_resp_err_t rd_kafka_last_error(void);\nrd_kafka_resp_err_t rd_kafka_errno2err(int errnox);\nint rd_kafka_errno(void);\nrd_kafka_resp_err_t rd_kafka_fatal_error(rd_kafka_t *rk, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_test_fatal_error(rd_kafka_t *rk, rd_kafka_resp_err_t err, const char *reason);\nrd_kafka_resp_err_t rd_kafka_error_code(const rd_kafka_error_t *error);\nconst char *rd_kafka_error_name(const rd_kafka_error_t *error);\nconst char *rd_kafka_error_string(const rd_kafka_error_t *error);\nint rd_kafka_error_is_fatal(const rd_kafka_error_t *error);\nint rd_kafka_error_is_retriable(const rd_kafka_error_t *error);\nint rd_kafka_error_txn_requires_abort(const rd_kafka_error_t *error);\nvoid rd_kafka_error_destroy(rd_kafka_error_t *error);\nrd_kafka_error_t *rd_kafka_error_new(rd_kafka_resp_err_t code, const char *fmt, ...);\ntypedef struct rd_kafka_topic_partition_s {\n  char *topic;\n  int32_t partition;\n  int64_t offset;\n  void *metadata;\n  size_t metadata_size;\n  void *opaque;\n  rd_kafka_resp_err_t err;\n  void *_private;\n} rd_kafka_topic_partition_t;\nvoid rd_kafka_topic_partition_destroy(rd_kafka_topic_partition_t *rktpar);\nvoid rd_kafka_topic_partition_set_leader_epoch(rd_kafka_topic_partition_t *rktpar, int32_t leader_epoch);\nint32_t rd_kafka_topic_partition_get_leader_epoch(const rd_kafka_topic_partition_t *rktpar);\ntypedef struct rd_kafka_topic_partition_list_s {\n  int cnt;\n  int size;\n  rd_kafka_topic_partition_t *elems;\n} rd_kafka_topic_partition_list_t;\nrd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_new(int size);\nvoid rd_kafka_topic_partition_list_destroy(rd_kafka_topic_partition_list_t *rkparlist);\nrd_kafka_topic_partition_t *rd_kafka_topic_partition_list_add(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);\nvoid rd_kafka_topic_partition_list_add_range(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t start, int32_t stop);\nint rd_kafka_topic_partition_list_del(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);\nint rd_kafka_topic_partition_list_del_by_idx(rd_kafka_topic_partition_list_t *rktparlist, int idx);\nrd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_copy(const rd_kafka_topic_partition_list_t *src);\nrd_kafka_resp_err_t rd_kafka_topic_partition_list_set_offset(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition, int64_t offset);\nrd_kafka_topic_partition_t *rd_kafka_topic_partition_list_find(const rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);\nvoid rd_kafka_topic_partition_list_sort(rd_kafka_topic_partition_list_t *rktparlist, int (*cmp)(const void *a, const void *b, void *cmp_opaque), void *cmp_opaque);\ntypedef enum rd_kafka_vtype_t {\n  RD_KAFKA_VTYPE_END,\n  RD_KAFKA_VTYPE_TOPIC,\n  RD_KAFKA_VTYPE_RKT,\n  RD_KAFKA_VTYPE_PARTITION,\n  RD_KAFKA_VTYPE_VALUE,\n  RD_KAFKA_VTYPE_KEY,\n  RD_KAFKA_VTYPE_OPAQUE,\n  RD_KAFKA_VTYPE_MSGFLAGS,\n  RD_KAFKA_VTYPE_TIMESTAMP,\n  RD_KAFKA_VTYPE_HEADER,\n  RD_KAFKA_VTYPE_HEADERS,\n} rd_kafka_vtype_t;\ntypedef struct rd_kafka_vu_s {\n  rd_kafka_vtype_t vtype;\n  union {\n    char *cstr;\n    rd_kafka_topic_t *rkt;\n    int i;\n    int32_t i32;\n    int64_t i64;\n    struct {\n      void *ptr;\n      size_t size;\n    } mem;\n    struct {\n      char *name;\n      void *val;\n      ssize_t size;\n    } header;\n    rd_kafka_headers_t *headers;\n    void *ptr;\n    char _pad[64];\n  } u;\n} rd_kafka_vu_t;\nrd_kafka_headers_t *rd_kafka_headers_new(size_t initial_count);\nvoid rd_kafka_headers_destroy(rd_kafka_headers_t *hdrs);\nrd_kafka_headers_t *rd_kafka_headers_copy(const rd_kafka_headers_t *src);\nrd_kafka_resp_err_t rd_kafka_header_add(rd_kafka_headers_t *hdrs, const char *name, ssize_t name_size, const void *value, ssize_t value_size);\nrd_kafka_resp_err_t rd_kafka_header_remove(rd_kafka_headers_t *hdrs, const char *name);\nrd_kafka_resp_err_t rd_kafka_header_get_last(const rd_kafka_headers_t *hdrs, const char *name, const void **valuep, size_t *sizep);\nrd_kafka_resp_err_t rd_kafka_header_get(const rd_kafka_headers_t *hdrs, size_t idx, const char *name, const void **valuep, size_t *sizep);\nrd_kafka_resp_err_t rd_kafka_header_get_all(const rd_kafka_headers_t *hdrs, size_t idx, const char **namep, const void **valuep, size_t *sizep);\ntypedef struct rd_kafka_message_s {\n  rd_kafka_resp_err_t err;\n  rd_kafka_topic_t *rkt;\n  int32_t partition;\n  void *payload;\n  size_t len;\n  void *key;\n  size_t key_len;\n  int64_t offset;\n  void *_private;\n} rd_kafka_message_t;\nvoid rd_kafka_message_destroy(rd_kafka_message_t *rkmessage);\nconst char *rd_kafka_message_errstr(const rd_kafka_message_t *rkmessage);\nint64_t rd_kafka_message_timestamp(const rd_kafka_message_t *rkmessage, rd_kafka_timestamp_type_t *tstype);\nint64_t rd_kafka_message_latency(const rd_kafka_message_t *rkmessage);\nint32_t rd_kafka_message_broker_id(const rd_kafka_message_t *rkmessage);\nrd_kafka_resp_err_t rd_kafka_message_headers(const rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);\nrd_kafka_resp_err_t rd_kafka_message_detach_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);\nvoid rd_kafka_message_set_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t *hdrs);\nsize_t rd_kafka_header_cnt(const rd_kafka_headers_t *hdrs);\ntypedef enum {\n  RD_KAFKA_MSG_STATUS_NOT_PERSISTED = 0,\n  RD_KAFKA_MSG_STATUS_POSSIBLY_PERSISTED = 1,\n  RD_KAFKA_MSG_STATUS_PERSISTED = 2,\n} rd_kafka_msg_status_t;\nrd_kafka_msg_status_t rd_kafka_message_status(const rd_kafka_message_t *rkmessage);\nint32_t rd_kafka_message_leader_epoch(const rd_kafka_message_t *rkmessage);\ntypedef enum {\n  RD_KAFKA_CONF_UNKNOWN = (- 2),\n  RD_KAFKA_CONF_INVALID = (- 1),\n  RD_KAFKA_CONF_OK = 0,\n} rd_kafka_conf_res_t;\nrd_kafka_conf_t *rd_kafka_conf_new(void);\nvoid rd_kafka_conf_destroy(rd_kafka_conf_t *conf);\nrd_kafka_conf_t *rd_kafka_conf_dup(const rd_kafka_conf_t *conf);\nrd_kafka_conf_t *rd_kafka_conf_dup_filter(const rd_kafka_conf_t *conf, size_t filter_cnt, const char **filter);\nconst rd_kafka_conf_t *rd_kafka_conf(rd_kafka_t *rk);\nrd_kafka_conf_res_t rd_kafka_conf_set(rd_kafka_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);\nvoid rd_kafka_conf_set_events(rd_kafka_conf_t *conf, int events);\nvoid rd_kafka_conf_set_background_event_cb(rd_kafka_conf_t *conf, void (*event_cb)(rd_kafka_t *rk, rd_kafka_event_t *rkev, void *opaque));\nvoid rd_kafka_conf_set_dr_cb(rd_kafka_conf_t *conf, void (*dr_cb)(rd_kafka_t *rk, void *payload, size_t len, rd_kafka_resp_err_t err, void *opaque, void *msg_opaque));\nvoid rd_kafka_conf_set_dr_msg_cb(rd_kafka_conf_t *conf, void (*dr_msg_cb)(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, void *opaque));\nvoid rd_kafka_conf_set_consume_cb(rd_kafka_conf_t *conf, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *opaque));\nvoid rd_kafka_conf_set_rebalance_cb(rd_kafka_conf_t *conf, void (*rebalance_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *partitions, void *opaque));\nvoid rd_kafka_conf_set_offset_commit_cb(rd_kafka_conf_t *conf, void (*offset_commit_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *opaque));\nvoid rd_kafka_conf_set_error_cb(rd_kafka_conf_t *conf, void (*error_cb)(rd_kafka_t *rk, int err, const char *reason, void *opaque));\nvoid rd_kafka_conf_set_throttle_cb(rd_kafka_conf_t *conf, void (*throttle_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int throttle_time_ms, void *opaque));\nvoid rd_kafka_conf_set_log_cb(rd_kafka_conf_t *conf, void (*log_cb)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));\nvoid rd_kafka_conf_set_stats_cb(rd_kafka_conf_t *conf, int (*stats_cb)(rd_kafka_t *rk, char *json, size_t json_len, void *opaque));\nvoid rd_kafka_conf_set_oauthbearer_token_refresh_cb(rd_kafka_conf_t *conf, void (*oauthbearer_token_refresh_cb)(rd_kafka_t *rk, const char *oauthbearer_config, void *opaque));\nvoid rd_kafka_conf_enable_sasl_queue(rd_kafka_conf_t *conf, int enable);\nvoid rd_kafka_conf_set_socket_cb(rd_kafka_conf_t *conf, int (*socket_cb)(int domain, int type, int protocol, void *opaque));\nvoid rd_kafka_conf_set_connect_cb(rd_kafka_conf_t *conf, int (*connect_cb)(int sockfd, const struct sockaddr *addr, int addrlen, const char *id, void *opaque));\nvoid rd_kafka_conf_set_closesocket_cb(rd_kafka_conf_t *conf, int (*closesocket_cb)(int sockfd, void *opaque));\nstruct addrinfo;\nvoid rd_kafka_conf_set_resolve_cb(rd_kafka_conf_t *conf, int (*resolve_cb)(const char *node, const char *service, const struct addrinfo *hints, struct addrinfo **res, void *opaque));\nrd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert_verify_cb(rd_kafka_conf_t *conf, int (*ssl_cert_verify_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int *x509_error, int depth, const char *buf, size_t size, char *errstr, size_t errstr_size, void *opaque));\ntypedef enum rd_kafka_cert_type_t {\n  RD_KAFKA_CERT_PUBLIC_KEY,\n  RD_KAFKA_CERT_PRIVATE_KEY,\n  RD_KAFKA_CERT_CA,\n  RD_KAFKA_CERT__CNT,\n} rd_kafka_cert_type_t;\ntypedef enum rd_kafka_cert_enc_t {\n  RD_KAFKA_CERT_ENC_PKCS12,\n  RD_KAFKA_CERT_ENC_DER,\n  RD_KAFKA_CERT_ENC_PEM,\n  RD_KAFKA_CERT_ENC__CNT,\n} rd_kafka_cert_enc_t;\nrd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert(rd_kafka_conf_t *conf, rd_kafka_cert_type_t cert_type, rd_kafka_cert_enc_t cert_enc, const void *buffer, size_t size, char *errstr, size_t errstr_size);\nvoid rd_kafka_conf_set_engine_callback_data(rd_kafka_conf_t *conf, void *callback_data);\nvoid rd_kafka_conf_set_opaque(rd_kafka_conf_t *conf, void *opaque);\nvoid *rd_kafka_opaque(const rd_kafka_t *rk);\nvoid rd_kafka_conf_set_default_topic_conf(rd_kafka_conf_t *conf, rd_kafka_topic_conf_t *tconf);\nrd_kafka_topic_conf_t *rd_kafka_conf_get_default_topic_conf(rd_kafka_conf_t *conf);\nrd_kafka_conf_res_t rd_kafka_conf_get(const rd_kafka_conf_t *conf, const char *name, char *dest, size_t *dest_size);\nrd_kafka_conf_res_t rd_kafka_topic_conf_get(const rd_kafka_topic_conf_t *conf, const char *name, char *dest, size_t *dest_size);\nconst char **rd_kafka_conf_dump(rd_kafka_conf_t *conf, size_t *cntp);\nconst char **rd_kafka_topic_conf_dump(rd_kafka_topic_conf_t *conf, size_t *cntp);\nvoid rd_kafka_conf_dump_free(const char **arr, size_t cnt);\nvoid rd_kafka_conf_properties_show(FILE *fp);\nrd_kafka_topic_conf_t *rd_kafka_topic_conf_new(void);\nrd_kafka_topic_conf_t *rd_kafka_topic_conf_dup(const rd_kafka_topic_conf_t *conf);\nrd_kafka_topic_conf_t *rd_kafka_default_topic_conf_dup(rd_kafka_t *rk);\nvoid rd_kafka_topic_conf_destroy(rd_kafka_topic_conf_t *topic_conf);\nrd_kafka_conf_res_t rd_kafka_topic_conf_set(rd_kafka_topic_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);\nvoid rd_kafka_topic_conf_set_opaque(rd_kafka_topic_conf_t *conf, void *rkt_opaque);\nvoid rd_kafka_topic_conf_set_partitioner_cb(rd_kafka_topic_conf_t *topic_conf, int32_t (*partitioner)(const rd_kafka_topic_t *rkt, const void *keydata, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque));\nvoid rd_kafka_topic_conf_set_msg_order_cmp(rd_kafka_topic_conf_t *topic_conf, int (*msg_order_cmp)(const rd_kafka_message_t *a, const rd_kafka_message_t *b));\nint rd_kafka_topic_partition_available(const rd_kafka_topic_t *rkt, int32_t partition);\nint32_t rd_kafka_msg_partitioner_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_consistent(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_consistent_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_murmur2(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_murmur2_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_fnv1a(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_fnv1a_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nrd_kafka_t *rd_kafka_new(rd_kafka_type_t type, rd_kafka_conf_t *conf, char *errstr, size_t errstr_size);\nvoid rd_kafka_destroy(rd_kafka_t *rk);\nvoid rd_kafka_destroy_flags(rd_kafka_t *rk, int flags);\nconst char *rd_kafka_name(const rd_kafka_t *rk);\nrd_kafka_type_t rd_kafka_type(const rd_kafka_t *rk);\nchar *rd_kafka_memberid(const rd_kafka_t *rk);\nchar *rd_kafka_clusterid(rd_kafka_t *rk, int timeout_ms);\nint32_t rd_kafka_controllerid(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_topic_t *rd_kafka_topic_new(rd_kafka_t *rk, const char *topic, rd_kafka_topic_conf_t *conf);\nvoid rd_kafka_topic_destroy(rd_kafka_topic_t *rkt);\nconst char *rd_kafka_topic_name(const rd_kafka_topic_t *rkt);\nvoid *rd_kafka_topic_opaque(const rd_kafka_topic_t *rkt);\nint rd_kafka_poll(rd_kafka_t *rk, int timeout_ms);\nvoid rd_kafka_yield(rd_kafka_t *rk);\nrd_kafka_resp_err_t rd_kafka_pause_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_resp_err_t rd_kafka_resume_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_resp_err_t rd_kafka_query_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high, int timeout_ms);\nrd_kafka_resp_err_t rd_kafka_get_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high);\nrd_kafka_resp_err_t rd_kafka_offsets_for_times(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets, int timeout_ms);\nvoid *rd_kafka_mem_calloc(rd_kafka_t *rk, size_t num, size_t size);\nvoid *rd_kafka_mem_malloc(rd_kafka_t *rk, size_t size);\nvoid rd_kafka_mem_free(rd_kafka_t *rk, void *ptr);\nrd_kafka_queue_t *rd_kafka_queue_new(rd_kafka_t *rk);\nvoid rd_kafka_queue_destroy(rd_kafka_queue_t *rkqu);\nrd_kafka_queue_t *rd_kafka_queue_get_main(rd_kafka_t *rk);\nrd_kafka_queue_t *rd_kafka_queue_get_sasl(rd_kafka_t *rk);\nrd_kafka_error_t *rd_kafka_sasl_background_callbacks_enable(rd_kafka_t *rk);\nrd_kafka_error_t *rd_kafka_sasl_set_credentials(rd_kafka_t *rk, const char *username, const char *password);\nrd_kafka_queue_t *rd_kafka_queue_get_consumer(rd_kafka_t *rk);\nrd_kafka_queue_t *rd_kafka_queue_get_partition(rd_kafka_t *rk, const char *topic, int32_t partition);\nrd_kafka_queue_t *rd_kafka_queue_get_background(rd_kafka_t *rk);\nvoid rd_kafka_queue_forward(rd_kafka_queue_t *src, rd_kafka_queue_t *dst);\nrd_kafka_resp_err_t rd_kafka_set_log_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu);\nsize_t rd_kafka_queue_length(rd_kafka_queue_t *rkqu);\nvoid rd_kafka_queue_io_event_enable(rd_kafka_queue_t *rkqu, int fd, const void *payload, size_t size);\nvoid rd_kafka_queue_cb_event_enable(rd_kafka_queue_t *rkqu, void (*event_cb)(rd_kafka_t *rk, void *qev_opaque), void *qev_opaque);\nvoid rd_kafka_queue_yield(rd_kafka_queue_t *rkqu);\nint rd_kafka_consume_start(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);\nint rd_kafka_consume_start_queue(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, rd_kafka_queue_t *rkqu);\nint rd_kafka_consume_stop(rd_kafka_topic_t *rkt, int32_t partition);\nrd_kafka_resp_err_t rd_kafka_seek(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, int timeout_ms);\nrd_kafka_error_t *rd_kafka_seek_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms);\nrd_kafka_message_t *rd_kafka_consume(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms);\nssize_t rd_kafka_consume_batch(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);\nint rd_kafka_consume_callback(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);\nrd_kafka_message_t *rd_kafka_consume_queue(rd_kafka_queue_t *rkqu, int timeout_ms);\nssize_t rd_kafka_consume_batch_queue(rd_kafka_queue_t *rkqu, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);\nint rd_kafka_consume_callback_queue(rd_kafka_queue_t *rkqu, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);\nrd_kafka_resp_err_t rd_kafka_offset_store(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);\nrd_kafka_resp_err_t rd_kafka_offsets_store(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets);\nrd_kafka_error_t *rd_kafka_offset_store_message(rd_kafka_message_t *rkmessage);\nrd_kafka_resp_err_t rd_kafka_subscribe(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *topics);\nrd_kafka_resp_err_t rd_kafka_unsubscribe(rd_kafka_t *rk);\nrd_kafka_resp_err_t rd_kafka_subscription(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **topics);\nrd_kafka_message_t *rd_kafka_consumer_poll(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_resp_err_t rd_kafka_consumer_close(rd_kafka_t *rk);\nrd_kafka_error_t *rd_kafka_consumer_close_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu);\nint rd_kafka_consumer_closed(rd_kafka_t *rk);\nrd_kafka_error_t *rd_kafka_incremental_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_error_t *rd_kafka_incremental_unassign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);\nconst char *rd_kafka_rebalance_protocol(rd_kafka_t *rk);\nrd_kafka_resp_err_t rd_kafka_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_resp_err_t rd_kafka_assignment(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **partitions);\nint rd_kafka_assignment_lost(rd_kafka_t *rk);\nrd_kafka_resp_err_t rd_kafka_commit(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, int async);\nrd_kafka_resp_err_t rd_kafka_commit_message(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, int async);\nrd_kafka_resp_err_t rd_kafka_commit_queue(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_queue_t *rkqu, void (*cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *commit_opaque), void *commit_opaque);\nrd_kafka_resp_err_t rd_kafka_committed(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms);\nrd_kafka_resp_err_t rd_kafka_position(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata(rd_kafka_t *rk);\nrd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata_new(const char *group_id);\nrd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata_new_with_genid(const char *group_id, int32_t generation_id, const char *member_id, const char *group_instance_id);\nvoid rd_kafka_consumer_group_metadata_destroy(rd_kafka_consumer_group_metadata_t *);\nrd_kafka_error_t *rd_kafka_consumer_group_metadata_write(const rd_kafka_consumer_group_metadata_t *cgmd, void **bufferp, size_t *sizep);\nrd_kafka_error_t *rd_kafka_consumer_group_metadata_read(rd_kafka_consumer_group_metadata_t **cgmdp, const void *buffer, size_t size);\nint rd_kafka_produce(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, void *payload, size_t len, const void *key, size_t keylen, void *msg_opaque);\nrd_kafka_resp_err_t rd_kafka_producev(rd_kafka_t *rk, ...);\nrd_kafka_error_t *rd_kafka_produceva(rd_kafka_t *rk, const rd_kafka_vu_t *vus, size_t cnt);\nint rd_kafka_produce_batch(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, rd_kafka_message_t *rkmessages, int message_cnt);\nrd_kafka_resp_err_t rd_kafka_flush(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_resp_err_t rd_kafka_purge(rd_kafka_t *rk, int purge_flags);\ntypedef struct rd_kafka_metadata_broker {\n  int32_t id;\n  char *host;\n  int port;\n} rd_kafka_metadata_broker_t;\ntypedef struct rd_kafka_metadata_partition {\n  int32_t id;\n  rd_kafka_resp_err_t err;\n  int32_t leader;\n  int replica_cnt;\n  int32_t *replicas;\n  int isr_cnt;\n  int32_t *isrs;\n} rd_kafka_metadata_partition_t;\ntypedef struct rd_kafka_metadata_topic {\n  char *topic;\n  int partition_cnt;\n  struct rd_kafka_metadata_partition *partitions;\n  rd_kafka_resp_err_t err;\n} rd_kafka_metadata_topic_t;\ntypedef struct rd_kafka_metadata {\n  int broker_cnt;\n  struct rd_kafka_metadata_broker *brokers;\n  int topic_cnt;\n  struct rd_kafka_metadata_topic *topics;\n  int32_t orig_broker_id;\n  char *orig_broker_name;\n} rd_kafka_metadata_t;\nrd_kafka_resp_err_t rd_kafka_metadata(rd_kafka_t *rk, int all_topics, rd_kafka_topic_t *only_rkt, const struct rd_kafka_metadata **metadatap, int timeout_ms);\nvoid rd_kafka_metadata_destroy(const struct rd_kafka_metadata *metadata);\ntypedef struct rd_kafka_Node_s rd_kafka_Node_t;\nint rd_kafka_Node_id(const rd_kafka_Node_t *node);\nconst char *rd_kafka_Node_host(const rd_kafka_Node_t *node);\nuint16_t rd_kafka_Node_port(const rd_kafka_Node_t *node);\nstruct rd_kafka_group_member_info {\n  char *member_id;\n  char *client_id;\n  char *client_host;\n  void *member_metadata;\n  int member_metadata_size;\n  void *member_assignment;\n  int member_assignment_size;\n};\ntypedef enum {\n  RD_KAFKA_CONSUMER_GROUP_STATE_UNKNOWN = 0,\n  RD_KAFKA_CONSUMER_GROUP_STATE_PREPARING_REBALANCE = 1,\n  RD_KAFKA_CONSUMER_GROUP_STATE_COMPLETING_REBALANCE = 2,\n  RD_KAFKA_CONSUMER_GROUP_STATE_STABLE = 3,\n  RD_KAFKA_CONSUMER_GROUP_STATE_DEAD = 4,\n  RD_KAFKA_CONSUMER_GROUP_STATE_EMPTY = 5,\n  RD_KAFKA_CONSUMER_GROUP_STATE__CNT,\n} rd_kafka_consumer_group_state_t;\nstruct rd_kafka_group_info {\n  struct rd_kafka_metadata_broker broker;\n  char *group;\n  rd_kafka_resp_err_t err;\n  char *state;\n  char *protocol_type;\n  char *protocol;\n  struct rd_kafka_group_member_info *members;\n  int member_cnt;\n};\nstruct rd_kafka_group_list {\n  struct rd_kafka_group_info *groups;\n  int group_cnt;\n};\nrd_kafka_resp_err_t rd_kafka_list_groups(rd_kafka_t *rk, const char *group, const struct rd_kafka_group_list **grplistp, int timeout_ms);\nconst char *rd_kafka_consumer_group_state_name(rd_kafka_consumer_group_state_t state);\nrd_kafka_consumer_group_state_t rd_kafka_consumer_group_state_code(const char *name);\nvoid rd_kafka_group_list_destroy(const struct rd_kafka_group_list *grplist);\nint rd_kafka_brokers_add(rd_kafka_t *rk, const char *brokerlist);\nvoid rd_kafka_set_logger(rd_kafka_t *rk, void (*func)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));\nvoid rd_kafka_set_log_level(rd_kafka_t *rk, int level);\nvoid rd_kafka_log_print(const rd_kafka_t *rk, int level, const char *fac, const char *buf);\nvoid rd_kafka_log_syslog(const rd_kafka_t *rk, int level, const char *fac, const char *buf);\nint rd_kafka_outq_len(rd_kafka_t *rk);\nvoid rd_kafka_dump(FILE *fp, rd_kafka_t *rk);\nint rd_kafka_thread_cnt(void);\ntypedef enum rd_kafka_thread_type_t {\n  RD_KAFKA_THREAD_MAIN,\n  RD_KAFKA_THREAD_BACKGROUND,\n  RD_KAFKA_THREAD_BROKER,\n} rd_kafka_thread_type_t;\nint rd_kafka_wait_destroyed(int timeout_ms);\nint rd_kafka_unittest(void);\nrd_kafka_resp_err_t rd_kafka_poll_set_consumer(rd_kafka_t *rk);\ntypedef int rd_kafka_event_type_t;\nrd_kafka_event_type_t rd_kafka_event_type(const rd_kafka_event_t *rkev);\nconst char *rd_kafka_event_name(const rd_kafka_event_t *rkev);\nvoid rd_kafka_event_destroy(rd_kafka_event_t *rkev);\nconst rd_kafka_message_t *rd_kafka_event_message_next(rd_kafka_event_t *rkev);\nsize_t rd_kafka_event_message_array(rd_kafka_event_t *rkev, const rd_kafka_message_t **rkmessages, size_t size);\nsize_t rd_kafka_event_message_count(rd_kafka_event_t *rkev);\nconst char *rd_kafka_event_config_string(rd_kafka_event_t *rkev);\nrd_kafka_resp_err_t rd_kafka_event_error(rd_kafka_event_t *rkev);\nconst char *rd_kafka_event_error_string(rd_kafka_event_t *rkev);\nint rd_kafka_event_error_is_fatal(rd_kafka_event_t *rkev);\nvoid *rd_kafka_event_opaque(rd_kafka_event_t *rkev);\nint rd_kafka_event_log(rd_kafka_event_t *rkev, const char **fac, const char **str, int *level);\nint rd_kafka_event_debug_contexts(rd_kafka_event_t *rkev, char *dst, size_t dstsize);\nconst char *rd_kafka_event_stats(rd_kafka_event_t *rkev);\nrd_kafka_topic_partition_list_t *rd_kafka_event_topic_partition_list(rd_kafka_event_t *rkev);\nrd_kafka_topic_partition_t *rd_kafka_event_topic_partition(rd_kafka_event_t *rkev);\ntypedef rd_kafka_event_t rd_kafka_CreateTopics_result_t;\ntypedef rd_kafka_event_t rd_kafka_DeleteTopics_result_t;\ntypedef rd_kafka_event_t rd_kafka_CreateAcls_result_t;\ntypedef rd_kafka_event_t rd_kafka_DescribeAcls_result_t;\ntypedef rd_kafka_event_t rd_kafka_DeleteAcls_result_t;\ntypedef rd_kafka_event_t rd_kafka_CreatePartitions_result_t;\ntypedef rd_kafka_event_t rd_kafka_AlterConfigs_result_t;\ntypedef rd_kafka_event_t rd_kafka_IncrementalAlterConfigs_result_t;\ntypedef rd_kafka_event_t rd_kafka_DescribeConfigs_result_t;\ntypedef rd_kafka_event_t rd_kafka_DeleteRecords_result_t;\ntypedef rd_kafka_event_t rd_kafka_ListConsumerGroups_result_t;\ntypedef rd_kafka_event_t rd_kafka_DescribeConsumerGroups_result_t;\ntypedef rd_kafka_event_t rd_kafka_DeleteGroups_result_t;\ntypedef rd_kafka_event_t rd_kafka_DeleteConsumerGroupOffsets_result_t;\ntypedef rd_kafka_event_t rd_kafka_AlterConsumerGroupOffsets_result_t;\ntypedef rd_kafka_event_t rd_kafka_ListConsumerGroupOffsets_result_t;\ntypedef rd_kafka_event_t rd_kafka_DescribeUserScramCredentials_result_t;\ntypedef rd_kafka_event_t rd_kafka_AlterUserScramCredentials_result_t;\nconst rd_kafka_CreateTopics_result_t *rd_kafka_event_CreateTopics_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DeleteTopics_result_t *rd_kafka_event_DeleteTopics_result(rd_kafka_event_t *rkev);\nconst rd_kafka_CreatePartitions_result_t *rd_kafka_event_CreatePartitions_result(rd_kafka_event_t *rkev);\nconst rd_kafka_AlterConfigs_result_t *rd_kafka_event_AlterConfigs_result(rd_kafka_event_t *rkev);\nconst rd_kafka_IncrementalAlterConfigs_result_t *rd_kafka_event_IncrementalAlterConfigs_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DescribeConfigs_result_t *rd_kafka_event_DescribeConfigs_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DeleteRecords_result_t *rd_kafka_event_DeleteRecords_result(rd_kafka_event_t *rkev);\nconst rd_kafka_ListConsumerGroups_result_t *rd_kafka_event_ListConsumerGroups_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DescribeConsumerGroups_result_t *rd_kafka_event_DescribeConsumerGroups_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DeleteGroups_result_t *rd_kafka_event_DeleteGroups_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DeleteConsumerGroupOffsets_result_t *rd_kafka_event_DeleteConsumerGroupOffsets_result(rd_kafka_event_t *rkev);\nconst rd_kafka_CreateAcls_result_t *rd_kafka_event_CreateAcls_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DescribeAcls_result_t *rd_kafka_event_DescribeAcls_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DeleteAcls_result_t *rd_kafka_event_DeleteAcls_result(rd_kafka_event_t *rkev);\nconst rd_kafka_ListConsumerGroupOffsets_result_t *rd_kafka_event_ListConsumerGroupOffsets_result(rd_kafka_event_t *rkev);\nconst rd_kafka_AlterConsumerGroupOffsets_result_t *rd_kafka_event_AlterConsumerGroupOffsets_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DescribeUserScramCredentials_result_t *rd_kafka_event_DescribeUserScramCredentials_result(rd_kafka_event_t *rkev);\nconst rd_kafka_AlterUserScramCredentials_result_t *rd_kafka_event_AlterUserScramCredentials_result(rd_kafka_event_t *rkev);\nrd_kafka_event_t *rd_kafka_queue_poll(rd_kafka_queue_t *rkqu, int timeout_ms);\nint rd_kafka_queue_poll_callback(rd_kafka_queue_t *rkqu, int timeout_ms);\ntypedef rd_kafka_resp_err_t (rd_kafka_plugin_f_conf_init_t)(rd_kafka_conf_t *conf, void **plug_opaquep, char *errstr, size_t errstr_size);\ntypedef rd_kafka_conf_res_t (rd_kafka_interceptor_f_on_conf_set_t)(rd_kafka_conf_t *conf, const char *name, const char *val, char *errstr, size_t errstr_size, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_dup_t)(rd_kafka_conf_t *new_conf, const rd_kafka_conf_t *old_conf, size_t filter_cnt, const char **filter, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_destroy_t)(void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_new_t)(rd_kafka_t *rk, const rd_kafka_conf_t *conf, void *ic_opaque, char *errstr, size_t errstr_size);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_destroy_t)(rd_kafka_t *rk, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_send_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_acknowledgement_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_consume_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_commit_t)(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_resp_err_t err, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_request_sent_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_response_received_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, int64_t rtt, rd_kafka_resp_err_t err, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_start_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_exit_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_broker_state_change_t)(rd_kafka_t *rk, int32_t broker_id, const char *secproto, const char *name, int port, const char *state, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_set(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_set_t *on_conf_set, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_dup(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_dup_t *on_conf_dup, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_destroy(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_destroy_t *on_conf_destroy, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_new(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_new_t *on_new, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_destroy(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_destroy_t *on_destroy, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_send(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_send_t *on_send, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_acknowledgement(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_acknowledgement_t *on_acknowledgement, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_consume(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_consume_t *on_consume, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_commit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_commit_t *on_commit, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_request_sent(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_request_sent_t *on_request_sent, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_response_received(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_response_received_t *on_response_received, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_start(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_start_t *on_thread_start, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_exit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_exit_t *on_thread_exit, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_broker_state_change(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_broker_state_change_t *on_broker_state_change, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_topic_result_error(const rd_kafka_topic_result_t *topicres);\nconst char *rd_kafka_topic_result_error_string(const rd_kafka_topic_result_t *topicres);\nconst char *rd_kafka_topic_result_name(const rd_kafka_topic_result_t *topicres);\nconst rd_kafka_error_t *rd_kafka_group_result_error(const rd_kafka_group_result_t *groupres);\nconst char *rd_kafka_group_result_name(const rd_kafka_group_result_t *groupres);\nconst rd_kafka_topic_partition_list_t *rd_kafka_group_result_partitions(const rd_kafka_group_result_t *groupres);\ntypedef enum rd_kafka_admin_op_t {\n  RD_KAFKA_ADMIN_OP_ANY = 0,\n  RD_KAFKA_ADMIN_OP_CREATETOPICS,\n  RD_KAFKA_ADMIN_OP_DELETETOPICS,\n  RD_KAFKA_ADMIN_OP_CREATEPARTITIONS,\n  RD_KAFKA_ADMIN_OP_ALTERCONFIGS,\n  RD_KAFKA_ADMIN_OP_DESCRIBECONFIGS,\n  RD_KAFKA_ADMIN_OP_DELETERECORDS,\n  RD_KAFKA_ADMIN_OP_DELETEGROUPS,\n  RD_KAFKA_ADMIN_OP_DELETECONSUMERGROUPOFFSETS,\n  RD_KAFKA_ADMIN_OP_CREATEACLS,\n  RD_KAFKA_ADMIN_OP_DESCRIBEACLS,\n  RD_KAFKA_ADMIN_OP_DELETEACLS,\n  RD_KAFKA_ADMIN_OP_LISTCONSUMERGROUPS,\n  RD_KAFKA_ADMIN_OP_DESCRIBECONSUMERGROUPS,\n  RD_KAFKA_ADMIN_OP_LISTCONSUMERGROUPOFFSETS,\n  RD_KAFKA_ADMIN_OP_ALTERCONSUMERGROUPOFFSETS,\n  RD_KAFKA_ADMIN_OP_INCREMENTALALTERCONFIGS,\n  RD_KAFKA_ADMIN_OP_DESCRIBEUSERSCRAMCREDENTIALS,\n  RD_KAFKA_ADMIN_OP_ALTERUSERSCRAMCREDENTIALS,\n  RD_KAFKA_ADMIN_OP__CNT,\n} rd_kafka_admin_op_t;\ntypedef struct rd_kafka_AdminOptions_s rd_kafka_AdminOptions_t;\nrd_kafka_AdminOptions_t *rd_kafka_AdminOptions_new(rd_kafka_t *rk, rd_kafka_admin_op_t for_api);\nvoid rd_kafka_AdminOptions_destroy(rd_kafka_AdminOptions_t *options);\nrd_kafka_resp_err_t rd_kafka_AdminOptions_set_request_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_AdminOptions_set_operation_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_AdminOptions_set_validate_only(rd_kafka_AdminOptions_t *options, int true_or_false, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_AdminOptions_set_broker(rd_kafka_AdminOptions_t *options, int32_t broker_id, char *errstr, size_t errstr_size);\nrd_kafka_error_t *rd_kafka_AdminOptions_set_require_stable_offsets(rd_kafka_AdminOptions_t *options, int true_or_false);\nrd_kafka_error_t *rd_kafka_AdminOptions_set_match_consumer_group_states(rd_kafka_AdminOptions_t *options, const rd_kafka_consumer_group_state_t *consumer_group_states, size_t consumer_group_states_cnt);\nvoid rd_kafka_AdminOptions_set_opaque(rd_kafka_AdminOptions_t *options, void *ev_opaque);\ntypedef struct rd_kafka_NewTopic_s rd_kafka_NewTopic_t;\nrd_kafka_NewTopic_t *rd_kafka_NewTopic_new(const char *topic, int num_partitions, int replication_factor, char *errstr, size_t errstr_size);\nvoid rd_kafka_NewTopic_destroy(rd_kafka_NewTopic_t *new_topic);\nvoid rd_kafka_NewTopic_destroy_array(rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt);\nrd_kafka_resp_err_t rd_kafka_NewTopic_set_replica_assignment(rd_kafka_NewTopic_t *new_topic, int32_t partition, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_NewTopic_set_config(rd_kafka_NewTopic_t *new_topic, const char *name, const char *value);\nvoid rd_kafka_CreateTopics(rd_kafka_t *rk, rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_topic_result_t **rd_kafka_CreateTopics_result_topics(const rd_kafka_CreateTopics_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_DeleteTopic_s rd_kafka_DeleteTopic_t;\nrd_kafka_DeleteTopic_t *rd_kafka_DeleteTopic_new(const char *topic);\nvoid rd_kafka_DeleteTopic_destroy(rd_kafka_DeleteTopic_t *del_topic);\nvoid rd_kafka_DeleteTopic_destroy_array(rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt);\nvoid rd_kafka_DeleteTopics(rd_kafka_t *rk, rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_topic_result_t **rd_kafka_DeleteTopics_result_topics(const rd_kafka_DeleteTopics_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_NewPartitions_s rd_kafka_NewPartitions_t;\nrd_kafka_NewPartitions_t *rd_kafka_NewPartitions_new(const char *topic, size_t new_total_cnt, char *errstr, size_t errstr_size);\nvoid rd_kafka_NewPartitions_destroy(rd_kafka_NewPartitions_t *new_parts);\nvoid rd_kafka_NewPartitions_destroy_array(rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt);\nrd_kafka_resp_err_t rd_kafka_NewPartitions_set_replica_assignment(rd_kafka_NewPartitions_t *new_parts, int32_t new_partition_idx, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);\nvoid rd_kafka_CreatePartitions(rd_kafka_t *rk, rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_topic_result_t **rd_kafka_CreatePartitions_result_topics(const rd_kafka_CreatePartitions_result_t *result, size_t *cntp);\ntypedef enum rd_kafka_ConfigSource_t {\n  RD_KAFKA_CONFIG_SOURCE_UNKNOWN_CONFIG = 0,\n  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_TOPIC_CONFIG = 1,\n  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_BROKER_CONFIG = 2,\n  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_DEFAULT_BROKER_CONFIG = 3,\n  RD_KAFKA_CONFIG_SOURCE_STATIC_BROKER_CONFIG = 4,\n  RD_KAFKA_CONFIG_SOURCE_DEFAULT_CONFIG = 5,\n  RD_KAFKA_CONFIG_SOURCE__CNT,\n} rd_kafka_ConfigSource_t;\nconst char *rd_kafka_ConfigSource_name(rd_kafka_ConfigSource_t confsource);\ntypedef struct rd_kafka_ConfigEntry_s rd_kafka_ConfigEntry_t;\nconst char *rd_kafka_ConfigEntry_name(const rd_kafka_ConfigEntry_t *entry);\nconst char *rd_kafka_ConfigEntry_value(const rd_kafka_ConfigEntry_t *entry);\nrd_kafka_ConfigSource_t rd_kafka_ConfigEntry_source(const rd_kafka_ConfigEntry_t *entry);\nint rd_kafka_ConfigEntry_is_read_only(const rd_kafka_ConfigEntry_t *entry);\nint rd_kafka_ConfigEntry_is_default(const rd_kafka_ConfigEntry_t *entry);\nint rd_kafka_ConfigEntry_is_sensitive(const rd_kafka_ConfigEntry_t *entry);\nint rd_kafka_ConfigEntry_is_synonym(const rd_kafka_ConfigEntry_t *entry);\nconst rd_kafka_ConfigEntry_t **rd_kafka_ConfigEntry_synonyms(const rd_kafka_ConfigEntry_t *entry, size_t *cntp);\ntypedef enum rd_kafka_ResourceType_t {\n  RD_KAFKA_RESOURCE_UNKNOWN = 0,\n  RD_KAFKA_RESOURCE_ANY = 1,\n  RD_KAFKA_RESOURCE_TOPIC = 2,\n  RD_KAFKA_RESOURCE_GROUP = 3,\n  RD_KAFKA_RESOURCE_BROKER = 4,\n  RD_KAFKA_RESOURCE__CNT,\n} rd_kafka_ResourceType_t;\ntypedef enum rd_kafka_ResourcePatternType_t {\n  RD_KAFKA_RESOURCE_PATTERN_UNKNOWN = 0,\n  RD_KAFKA_RESOURCE_PATTERN_ANY = 1,\n  RD_KAFKA_RESOURCE_PATTERN_MATCH = 2,\n  RD_KAFKA_RESOURCE_PATTERN_LITERAL = 3,\n  RD_KAFKA_RESOURCE_PATTERN_PREFIXED = 4,\n  RD_KAFKA_RESOURCE_PATTERN_TYPE__CNT,\n} rd_kafka_ResourcePatternType_t;\ntypedef enum rd_kafka_AlterConfigOpType_t {\n  RD_KAFKA_ALTER_CONFIG_OP_TYPE_SET = 0,\n  RD_KAFKA_ALTER_CONFIG_OP_TYPE_DELETE = 1,\n  RD_KAFKA_ALTER_CONFIG_OP_TYPE_APPEND = 2,\n  RD_KAFKA_ALTER_CONFIG_OP_TYPE_SUBTRACT = 3,\n  RD_KAFKA_ALTER_CONFIG_OP_TYPE__CNT,\n} rd_kafka_AlterConfigOpType_t;\nconst char *rd_kafka_ResourcePatternType_name(rd_kafka_ResourcePatternType_t resource_pattern_type);\nconst char *rd_kafka_ResourceType_name(rd_kafka_ResourceType_t restype);\ntypedef struct rd_kafka_ConfigResource_s rd_kafka_ConfigResource_t;\nrd_kafka_ConfigResource_t *rd_kafka_ConfigResource_new(rd_kafka_ResourceType_t restype, const char *resname);\nvoid rd_kafka_ConfigResource_destroy(rd_kafka_ConfigResource_t *config);\nvoid rd_kafka_ConfigResource_destroy_array(rd_kafka_ConfigResource_t **config, size_t config_cnt);\nrd_kafka_resp_err_t rd_kafka_ConfigResource_set_config(rd_kafka_ConfigResource_t *config, const char *name, const char *value);\nrd_kafka_error_t *rd_kafka_ConfigResource_add_incremental_config(rd_kafka_ConfigResource_t *config, const char *name, rd_kafka_AlterConfigOpType_t op_type, const char *value);\nconst rd_kafka_ConfigEntry_t **rd_kafka_ConfigResource_configs(const rd_kafka_ConfigResource_t *config, size_t *cntp);\nrd_kafka_ResourceType_t rd_kafka_ConfigResource_type(const rd_kafka_ConfigResource_t *config);\nconst char *rd_kafka_ConfigResource_name(const rd_kafka_ConfigResource_t *config);\nrd_kafka_resp_err_t rd_kafka_ConfigResource_error(const rd_kafka_ConfigResource_t *config);\nconst char *rd_kafka_ConfigResource_error_string(const rd_kafka_ConfigResource_t *config);\nvoid rd_kafka_AlterConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_ConfigResource_t **rd_kafka_AlterConfigs_result_resources(const rd_kafka_AlterConfigs_result_t *result, size_t *cntp);\nvoid rd_kafka_IncrementalAlterConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_ConfigResource_t **rd_kafka_IncrementalAlterConfigs_result_resources(const rd_kafka_IncrementalAlterConfigs_result_t *result, size_t *cntp);\nvoid rd_kafka_DescribeConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_ConfigResource_t **rd_kafka_DescribeConfigs_result_resources(const rd_kafka_DescribeConfigs_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_DeleteRecords_s rd_kafka_DeleteRecords_t;\nrd_kafka_DeleteRecords_t *rd_kafka_DeleteRecords_new(const rd_kafka_topic_partition_list_t *before_offsets);\nvoid rd_kafka_DeleteRecords_destroy(rd_kafka_DeleteRecords_t *del_records);\nvoid rd_kafka_DeleteRecords_destroy_array(rd_kafka_DeleteRecords_t **del_records, size_t del_record_cnt);\nvoid rd_kafka_DeleteRecords(rd_kafka_t *rk, rd_kafka_DeleteRecords_t **del_records, size_t del_record_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_topic_partition_list_t *rd_kafka_DeleteRecords_result_offsets(const rd_kafka_DeleteRecords_result_t *result);\ntypedef struct rd_kafka_ConsumerGroupListing_s rd_kafka_ConsumerGroupListing_t;\ntypedef struct rd_kafka_ListConsumerGroupsResult_s rd_kafka_ListConsumerGroupsResult_t;\nvoid rd_kafka_ListConsumerGroups(rd_kafka_t *rk, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst char *rd_kafka_ConsumerGroupListing_group_id(const rd_kafka_ConsumerGroupListing_t *grplist);\nint rd_kafka_ConsumerGroupListing_is_simple_consumer_group(const rd_kafka_ConsumerGroupListing_t *grplist);\nrd_kafka_consumer_group_state_t rd_kafka_ConsumerGroupListing_state(const rd_kafka_ConsumerGroupListing_t *grplist);\nconst rd_kafka_ConsumerGroupListing_t **rd_kafka_ListConsumerGroups_result_valid(const rd_kafka_ListConsumerGroups_result_t *result, size_t *cntp);\nconst rd_kafka_error_t **rd_kafka_ListConsumerGroups_result_errors(const rd_kafka_ListConsumerGroups_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_ConsumerGroupDescription_s rd_kafka_ConsumerGroupDescription_t;\ntypedef struct rd_kafka_MemberDescription_s rd_kafka_MemberDescription_t;\ntypedef struct rd_kafka_MemberAssignment_s rd_kafka_MemberAssignment_t;\nvoid rd_kafka_DescribeConsumerGroups(rd_kafka_t *rk, const char **groups, size_t groups_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_ConsumerGroupDescription_t **rd_kafka_DescribeConsumerGroups_result_groups(const rd_kafka_DescribeConsumerGroups_result_t *result, size_t *cntp);\nconst char *rd_kafka_ConsumerGroupDescription_group_id(const rd_kafka_ConsumerGroupDescription_t *grpdesc);\nconst rd_kafka_error_t *rd_kafka_ConsumerGroupDescription_error(const rd_kafka_ConsumerGroupDescription_t *grpdesc);\nint rd_kafka_ConsumerGroupDescription_is_simple_consumer_group(const rd_kafka_ConsumerGroupDescription_t *grpdesc);\nconst char *rd_kafka_ConsumerGroupDescription_partition_assignor(const rd_kafka_ConsumerGroupDescription_t *grpdesc);\nrd_kafka_consumer_group_state_t rd_kafka_ConsumerGroupDescription_state(const rd_kafka_ConsumerGroupDescription_t *grpdesc);\nconst rd_kafka_Node_t *rd_kafka_ConsumerGroupDescription_coordinator(const rd_kafka_ConsumerGroupDescription_t *grpdesc);\nsize_t rd_kafka_ConsumerGroupDescription_member_count(const rd_kafka_ConsumerGroupDescription_t *grpdesc);\nconst rd_kafka_MemberDescription_t *rd_kafka_ConsumerGroupDescription_member(const rd_kafka_ConsumerGroupDescription_t *grpdesc, size_t idx);\nconst char *rd_kafka_MemberDescription_client_id(const rd_kafka_MemberDescription_t *member);\nconst char *rd_kafka_MemberDescription_group_instance_id(const rd_kafka_MemberDescription_t *member);\nconst char *rd_kafka_MemberDescription_consumer_id(const rd_kafka_MemberDescription_t *member);\nconst char *rd_kafka_MemberDescription_host(const rd_kafka_MemberDescription_t *member);\nconst rd_kafka_MemberAssignment_t *rd_kafka_MemberDescription_assignment(const rd_kafka_MemberDescription_t *member);\nconst rd_kafka_topic_partition_list_t *rd_kafka_MemberAssignment_partitions(const rd_kafka_MemberAssignment_t *assignment);\ntypedef struct rd_kafka_DeleteGroup_s rd_kafka_DeleteGroup_t;\nrd_kafka_DeleteGroup_t *rd_kafka_DeleteGroup_new(const char *group);\nvoid rd_kafka_DeleteGroup_destroy(rd_kafka_DeleteGroup_t *del_group);\nvoid rd_kafka_DeleteGroup_destroy_array(rd_kafka_DeleteGroup_t **del_groups, size_t del_group_cnt);\nvoid rd_kafka_DeleteGroups(rd_kafka_t *rk, rd_kafka_DeleteGroup_t **del_groups, size_t del_group_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_group_result_t **rd_kafka_DeleteGroups_result_groups(const rd_kafka_DeleteGroups_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_ListConsumerGroupOffsets_s rd_kafka_ListConsumerGroupOffsets_t;\nrd_kafka_ListConsumerGroupOffsets_t *rd_kafka_ListConsumerGroupOffsets_new(const char *group_id, const rd_kafka_topic_partition_list_t *partitions);\nvoid rd_kafka_ListConsumerGroupOffsets_destroy(rd_kafka_ListConsumerGroupOffsets_t *list_grpoffsets);\nvoid rd_kafka_ListConsumerGroupOffsets_destroy_array(rd_kafka_ListConsumerGroupOffsets_t **list_grpoffsets, size_t list_grpoffset_cnt);\nvoid rd_kafka_ListConsumerGroupOffsets(rd_kafka_t *rk, rd_kafka_ListConsumerGroupOffsets_t **list_grpoffsets, size_t list_grpoffsets_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_group_result_t **rd_kafka_ListConsumerGroupOffsets_result_groups(const rd_kafka_ListConsumerGroupOffsets_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_AlterConsumerGroupOffsets_s rd_kafka_AlterConsumerGroupOffsets_t;\nrd_kafka_AlterConsumerGroupOffsets_t *rd_kafka_AlterConsumerGroupOffsets_new(const char *group_id, const rd_kafka_topic_partition_list_t *partitions);\nvoid rd_kafka_AlterConsumerGroupOffsets_destroy(rd_kafka_AlterConsumerGroupOffsets_t *alter_grpoffsets);\nvoid rd_kafka_AlterConsumerGroupOffsets_destroy_array(rd_kafka_AlterConsumerGroupOffsets_t **alter_grpoffsets, size_t alter_grpoffset_cnt);\nvoid rd_kafka_AlterConsumerGroupOffsets(rd_kafka_t *rk, rd_kafka_AlterConsumerGroupOffsets_t **alter_grpoffsets, size_t alter_grpoffsets_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_group_result_t **rd_kafka_AlterConsumerGroupOffsets_result_groups(const rd_kafka_AlterConsumerGroupOffsets_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_DeleteConsumerGroupOffsets_s rd_kafka_DeleteConsumerGroupOffsets_t;\nrd_kafka_DeleteConsumerGroupOffsets_t *rd_kafka_DeleteConsumerGroupOffsets_new(const char *group, const rd_kafka_topic_partition_list_t *partitions);\nvoid rd_kafka_DeleteConsumerGroupOffsets_destroy(rd_kafka_DeleteConsumerGroupOffsets_t *del_grpoffsets);\nvoid rd_kafka_DeleteConsumerGroupOffsets_destroy_array(rd_kafka_DeleteConsumerGroupOffsets_t **del_grpoffsets, size_t del_grpoffset_cnt);\nvoid rd_kafka_DeleteConsumerGroupOffsets(rd_kafka_t *rk, rd_kafka_DeleteConsumerGroupOffsets_t **del_grpoffsets, size_t del_grpoffsets_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_group_result_t **rd_kafka_DeleteConsumerGroupOffsets_result_groups(const rd_kafka_DeleteConsumerGroupOffsets_result_t *result, size_t *cntp);\ntypedef enum rd_kafka_ScramMechanism_t {\n  RD_KAFKA_SCRAM_MECHANISM_UNKNOWN = 0,\n  RD_KAFKA_SCRAM_MECHANISM_SHA_256 = 1,\n  RD_KAFKA_SCRAM_MECHANISM_SHA_512 = 2,\n  RD_KAFKA_SCRAM_MECHANISM__CNT,\n} rd_kafka_ScramMechanism_t;\ntypedef struct rd_kafka_ScramCredentialInfo_s rd_kafka_ScramCredentialInfo_t;\nrd_kafka_ScramMechanism_t rd_kafka_ScramCredentialInfo_mechanism(const rd_kafka_ScramCredentialInfo_t *scram_credential_info);\nint32_t rd_kafka_ScramCredentialInfo_iterations(const rd_kafka_ScramCredentialInfo_t *scram_credential_info);\ntypedef struct rd_kafka_UserScramCredentialsDescription_s rd_kafka_UserScramCredentialsDescription_t;\nconst char *rd_kafka_UserScramCredentialsDescription_user(const rd_kafka_UserScramCredentialsDescription_t *description);\nconst rd_kafka_error_t *rd_kafka_UserScramCredentialsDescription_error(const rd_kafka_UserScramCredentialsDescription_t *description);\nsize_t rd_kafka_UserScramCredentialsDescription_scramcredentialinfo_count(const rd_kafka_UserScramCredentialsDescription_t *description);\nconst rd_kafka_ScramCredentialInfo_t *rd_kafka_UserScramCredentialsDescription_scramcredentialinfo(const rd_kafka_UserScramCredentialsDescription_t *description, size_t idx);\nconst rd_kafka_UserScramCredentialsDescription_t **rd_kafka_DescribeUserScramCredentials_result_descriptions(const rd_kafka_DescribeUserScramCredentials_result_t *result, size_t *cntp);\nvoid rd_kafka_DescribeUserScramCredentials(rd_kafka_t *rk, const char **users, size_t user_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\ntypedef struct rd_kafka_UserScramCredentialAlteration_s rd_kafka_UserScramCredentialAlteration_t;\nrd_kafka_UserScramCredentialAlteration_t *rd_kafka_UserScramCredentialUpsertion_new(const char *username, rd_kafka_ScramMechanism_t mechanism, int32_t iterations, const unsigned char *password, size_t password_size, const unsigned char *salt, size_t salt_size);\nrd_kafka_UserScramCredentialAlteration_t *rd_kafka_UserScramCredentialDeletion_new(const char *username, rd_kafka_ScramMechanism_t mechanism);\nvoid rd_kafka_UserScramCredentialAlteration_destroy(rd_kafka_UserScramCredentialAlteration_t *alteration);\nvoid rd_kafka_UserScramCredentialAlteration_destroy_array(rd_kafka_UserScramCredentialAlteration_t **alterations, size_t alteration_cnt);\ntypedef struct rd_kafka_AlterUserScramCredentials_result_response_s rd_kafka_AlterUserScramCredentials_result_response_t;\nconst char *rd_kafka_AlterUserScramCredentials_result_response_user(const rd_kafka_AlterUserScramCredentials_result_response_t *response);\nconst rd_kafka_error_t *rd_kafka_AlterUserScramCredentials_result_response_error(const rd_kafka_AlterUserScramCredentials_result_response_t *response);\nconst rd_kafka_AlterUserScramCredentials_result_response_t **rd_kafka_AlterUserScramCredentials_result_responses(const rd_kafka_AlterUserScramCredentials_result_t *result, size_t *cntp);\nvoid rd_kafka_AlterUserScramCredentials(rd_kafka_t *rk, rd_kafka_UserScramCredentialAlteration_t **alterations, size_t alteration_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\ntypedef struct rd_kafka_AclBinding_s rd_kafka_AclBinding_t;\ntypedef rd_kafka_AclBinding_t rd_kafka_AclBindingFilter_t;\nconst rd_kafka_error_t *rd_kafka_acl_result_error(const rd_kafka_acl_result_t *aclres);\ntypedef enum rd_kafka_AclOperation_t {\n  RD_KAFKA_ACL_OPERATION_UNKNOWN = 0,\n  RD_KAFKA_ACL_OPERATION_ANY = 1,\n  RD_KAFKA_ACL_OPERATION_ALL = 2,\n  RD_KAFKA_ACL_OPERATION_READ = 3,\n  RD_KAFKA_ACL_OPERATION_WRITE = 4,\n  RD_KAFKA_ACL_OPERATION_CREATE = 5,\n  RD_KAFKA_ACL_OPERATION_DELETE = 6,\n  RD_KAFKA_ACL_OPERATION_ALTER = 7,\n  RD_KAFKA_ACL_OPERATION_DESCRIBE = 8,\n  RD_KAFKA_ACL_OPERATION_CLUSTER_ACTION = 9,\n  RD_KAFKA_ACL_OPERATION_DESCRIBE_CONFIGS = 10,\n  RD_KAFKA_ACL_OPERATION_ALTER_CONFIGS = 11,\n  RD_KAFKA_ACL_OPERATION_IDEMPOTENT_WRITE = 12,\n  RD_KAFKA_ACL_OPERATION__CNT,\n} rd_kafka_AclOperation_t;\nconst char *rd_kafka_AclOperation_name(rd_kafka_AclOperation_t acl_operation);\ntypedef enum rd_kafka_AclPermissionType_t {\n  RD_KAFKA_ACL_PERMISSION_TYPE_UNKNOWN = 0,\n  RD_KAFKA_ACL_PERMISSION_TYPE_ANY = 1,\n  RD_KAFKA_ACL_PERMISSION_TYPE_DENY = 2,\n  RD_KAFKA_ACL_PERMISSION_TYPE_ALLOW = 3,\n  RD_KAFKA_ACL_PERMISSION_TYPE__CNT,\n} rd_kafka_AclPermissionType_t;\nconst char *rd_kafka_AclPermissionType_name(rd_kafka_AclPermissionType_t acl_permission_type);\nrd_kafka_AclBinding_t *rd_kafka_AclBinding_new(rd_kafka_ResourceType_t restype, const char *name, rd_kafka_ResourcePatternType_t resource_pattern_type, const char *principal, const char *host, rd_kafka_AclOperation_t operation, rd_kafka_AclPermissionType_t permission_type, char *errstr, size_t errstr_size);\nrd_kafka_AclBindingFilter_t *rd_kafka_AclBindingFilter_new(rd_kafka_ResourceType_t restype, const char *name, rd_kafka_ResourcePatternType_t resource_pattern_type, const char *principal, const char *host, rd_kafka_AclOperation_t operation, rd_kafka_AclPermissionType_t permission_type, char *errstr, size_t errstr_size);\nrd_kafka_ResourceType_t rd_kafka_AclBinding_restype(const rd_kafka_AclBinding_t *acl);\nconst char *rd_kafka_AclBinding_name(const rd_kafka_AclBinding_t *acl);\nconst char *rd_kafka_AclBinding_principal(const rd_kafka_AclBinding_t *acl);\nconst char *rd_kafka_AclBinding_host(const rd_kafka_AclBinding_t *acl);\nrd_kafka_AclOperation_t rd_kafka_AclBinding_operation(const rd_kafka_AclBinding_t *acl);\nrd_kafka_AclPermissionType_t rd_kafka_AclBinding_permission_type(const rd_kafka_AclBinding_t *acl);\nrd_kafka_ResourcePatternType_t rd_kafka_AclBinding_resource_pattern_type(const rd_kafka_AclBinding_t *acl);\nconst rd_kafka_error_t *rd_kafka_AclBinding_error(const rd_kafka_AclBinding_t *acl);\nvoid rd_kafka_AclBinding_destroy(rd_kafka_AclBinding_t *acl_binding);\nvoid rd_kafka_AclBinding_destroy_array(rd_kafka_AclBinding_t **acl_bindings, size_t acl_bindings_cnt);\nconst rd_kafka_acl_result_t **rd_kafka_CreateAcls_result_acls(const rd_kafka_CreateAcls_result_t *result, size_t *cntp);\nvoid rd_kafka_CreateAcls(rd_kafka_t *rk, rd_kafka_AclBinding_t **new_acls, size_t new_acls_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_AclBinding_t **rd_kafka_DescribeAcls_result_acls(const rd_kafka_DescribeAcls_result_t *result, size_t *cntp);\nvoid rd_kafka_DescribeAcls(rd_kafka_t *rk, rd_kafka_AclBindingFilter_t *acl_filter, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\ntypedef struct rd_kafka_DeleteAcls_result_response_s rd_kafka_DeleteAcls_result_response_t;\nconst rd_kafka_DeleteAcls_result_response_t **rd_kafka_DeleteAcls_result_responses(const rd_kafka_DeleteAcls_result_t *result, size_t *cntp);\nconst rd_kafka_error_t *rd_kafka_DeleteAcls_result_response_error(const rd_kafka_DeleteAcls_result_response_t *result_response);\nconst rd_kafka_AclBinding_t **rd_kafka_DeleteAcls_result_response_matching_acls(const rd_kafka_DeleteAcls_result_response_t *result_response, size_t *matching_acls_cntp);\nvoid rd_kafka_DeleteAcls(rd_kafka_t *rk, rd_kafka_AclBindingFilter_t **del_acls, size_t del_acls_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nrd_kafka_resp_err_t rd_kafka_oauthbearer_set_token(rd_kafka_t *rk, const char *token_value, int64_t md_lifetime_ms, const char *md_principal_name, const char **extensions, size_t extension_size, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_oauthbearer_set_token_failure(rd_kafka_t *rk, const char *errstr);\nrd_kafka_error_t *rd_kafka_init_transactions(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_error_t *rd_kafka_begin_transaction(rd_kafka_t *rk);\nrd_kafka_error_t *rd_kafka_send_offsets_to_transaction(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, const rd_kafka_consumer_group_metadata_t *cgmetadata, int timeout_ms);\nrd_kafka_error_t *rd_kafka_commit_transaction(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_error_t *rd_kafka_abort_transaction(rd_kafka_t *rk, int timeout_ms);\ntypedef struct rd_kafka_mock_cluster_s rd_kafka_mock_cluster_t;\nrd_kafka_mock_cluster_t *rd_kafka_mock_cluster_new(rd_kafka_t *rk, int broker_cnt);\nvoid rd_kafka_mock_cluster_destroy(rd_kafka_mock_cluster_t *mcluster);\nrd_kafka_t *rd_kafka_mock_cluster_handle(const rd_kafka_mock_cluster_t *mcluster);\nrd_kafka_mock_cluster_t *rd_kafka_handle_mock_cluster(const rd_kafka_t *rk);\nconst char *rd_kafka_mock_cluster_bootstraps(const rd_kafka_mock_cluster_t *mcluster);\nvoid rd_kafka_mock_clear_request_errors(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey);\nvoid rd_kafka_mock_push_request_errors(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, size_t cnt, ...);\nvoid rd_kafka_mock_push_request_errors_array(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, size_t cnt, const rd_kafka_resp_err_t *errors);\nrd_kafka_resp_err_t rd_kafka_mock_broker_push_request_error_rtts(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int16_t ApiKey, size_t cnt, ...);\nrd_kafka_resp_err_t rd_kafka_mock_broker_error_stack_cnt(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int16_t ApiKey, size_t *cntp);\nvoid rd_kafka_mock_topic_set_error(rd_kafka_mock_cluster_t *mcluster, const char *topic, rd_kafka_resp_err_t err);\nrd_kafka_resp_err_t rd_kafka_mock_topic_create(rd_kafka_mock_cluster_t *mcluster, const char *topic, int partition_cnt, int replication_factor);\nrd_kafka_resp_err_t rd_kafka_mock_partition_set_leader(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id);\nrd_kafka_resp_err_t rd_kafka_mock_partition_set_follower(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id);\nrd_kafka_resp_err_t rd_kafka_mock_partition_set_follower_wmarks(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int64_t lo, int64_t hi);\nrd_kafka_resp_err_t rd_kafka_mock_broker_set_down(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id);\nrd_kafka_resp_err_t rd_kafka_mock_broker_set_up(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id);\nrd_kafka_resp_err_t rd_kafka_mock_broker_set_rtt(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int rtt_ms);\nrd_kafka_resp_err_t rd_kafka_mock_broker_set_rack(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, const char *rack);\nrd_kafka_resp_err_t rd_kafka_mock_coordinator_set(rd_kafka_mock_cluster_t *mcluster, const char *key_type, const char *key, int32_t broker_id);\nrd_kafka_resp_err_t rd_kafka_mock_set_apiversion(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, int16_t MinVersion, int16_t MaxVersion);\n'\n</code></pre> rdkafka.h, rdkafka_mock.h</p>"},{"location":"api/constants/#rd_kafka_version_28","title":"RD_KAFKA_VERSION","text":"<pre><code>public RD_KAFKA_VERSION = 33686015\n</code></pre> <p>librdkafka version </p> <p>Interpreted as hex <code>MM.mm.rr.xx</code>:</p> <ul> <li>MM = Major</li> <li>mm = minor</li> <li>rr = revision</li> <li>xx = pre-release id (0xff is the final release)</li> </ul> <p>E.g.: <code>0x000801ff</code> = 0.8.1</p> RemarksThis value should only be used during compile time, for runtime checks of version use rd_kafka_version()  <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_unsupported_compression_type_28","title":"RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE","text":"<pre><code>public RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76\n</code></pre> <p>Unsupported compression type </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_end_all_28","title":"RD_KAFKA_RESP_ERR_END_ALL","text":"<p><pre><code>public RD_KAFKA_RESP_ERR_END_ALL = 98\n</code></pre> enum rd_kafka_resp_err_t</p>"},{"location":"api/constants/#rd_kafka_admin_op__cnt_28","title":"RD_KAFKA_ADMIN_OP__CNT","text":"<pre><code>public RD_KAFKA_ADMIN_OP__CNT = 19\n</code></pre> <p>Number of ops defined </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe </li> </ul>"},{"location":"api/constants/#rd_kafka_resource__cnt_28","title":"RD_KAFKA_RESOURCE__CNT","text":"<pre><code>public RD_KAFKA_RESOURCE__CNT = 5\n</code></pre> <p>Number of resource types defined </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#acca83a66d7783ff7683ed2691cc907c9 </li> </ul>"},{"location":"api/constants/#rd_kafka_cdef_28","title":"RD_KAFKA_CDEF","text":"<p><pre><code>public RD_KAFKA_CDEF = 'typedef long int ssize_t;\ntypedef struct _IO_FILE FILE;\ntypedef long int mode_t;\ntypedef signed int int16_t;\ntypedef unsigned int uint16_t;\ntypedef signed int int32_t;\ntypedef signed long int int64_t;\nint rd_kafka_version(void);\nconst char *rd_kafka_version_str(void);\ntypedef enum rd_kafka_type_t {\n  RD_KAFKA_PRODUCER,\n  RD_KAFKA_CONSUMER,\n} rd_kafka_type_t;\ntypedef enum rd_kafka_timestamp_type_t {\n  RD_KAFKA_TIMESTAMP_NOT_AVAILABLE,\n  RD_KAFKA_TIMESTAMP_CREATE_TIME,\n  RD_KAFKA_TIMESTAMP_LOG_APPEND_TIME,\n} rd_kafka_timestamp_type_t;\nconst char *rd_kafka_get_debug_contexts(void);\ntypedef struct rd_kafka_s rd_kafka_t;\ntypedef struct rd_kafka_topic_s rd_kafka_topic_t;\ntypedef struct rd_kafka_conf_s rd_kafka_conf_t;\ntypedef struct rd_kafka_topic_conf_s rd_kafka_topic_conf_t;\ntypedef struct rd_kafka_queue_s rd_kafka_queue_t;\ntypedef struct rd_kafka_op_s rd_kafka_event_t;\ntypedef struct rd_kafka_topic_result_s rd_kafka_topic_result_t;\ntypedef struct rd_kafka_consumer_group_metadata_s rd_kafka_consumer_group_metadata_t;\ntypedef struct rd_kafka_error_s {\n  unsigned int code;\n  char *errstr;\n  unsigned char fatal;\n  unsigned char retriable;\n  unsigned char txn_requires_abort;\n} rd_kafka_error_t;\ntypedef struct rd_kafka_headers_s rd_kafka_headers_t;\ntypedef struct rd_kafka_group_result_s rd_kafka_group_result_t;\ntypedef struct rd_kafka_acl_result_s rd_kafka_acl_result_t;\ntypedef enum {\n  RD_KAFKA_RESP_ERR__BEGIN = (- 200),\n  RD_KAFKA_RESP_ERR__BAD_MSG = (- 199),\n  RD_KAFKA_RESP_ERR__BAD_COMPRESSION = (- 198),\n  RD_KAFKA_RESP_ERR__DESTROY = (- 197),\n  RD_KAFKA_RESP_ERR__FAIL = (- 196),\n  RD_KAFKA_RESP_ERR__TRANSPORT = (- 195),\n  RD_KAFKA_RESP_ERR__CRIT_SYS_RESOURCE = (- 194),\n  RD_KAFKA_RESP_ERR__RESOLVE = (- 193),\n  RD_KAFKA_RESP_ERR__MSG_TIMED_OUT = (- 192),\n  RD_KAFKA_RESP_ERR__PARTITION_EOF = (- 191),\n  RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION = (- 190),\n  RD_KAFKA_RESP_ERR__FS = (- 189),\n  RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC = (- 188),\n  RD_KAFKA_RESP_ERR__ALL_BROKERS_DOWN = (- 187),\n  RD_KAFKA_RESP_ERR__INVALID_ARG = (- 186),\n  RD_KAFKA_RESP_ERR__TIMED_OUT = (- 185),\n  RD_KAFKA_RESP_ERR__QUEUE_FULL = (- 184),\n  RD_KAFKA_RESP_ERR__ISR_INSUFF = (- 183),\n  RD_KAFKA_RESP_ERR__NODE_UPDATE = (- 182),\n  RD_KAFKA_RESP_ERR__SSL = (- 181),\n  RD_KAFKA_RESP_ERR__WAIT_COORD = (- 180),\n  RD_KAFKA_RESP_ERR__UNKNOWN_GROUP = (- 179),\n  RD_KAFKA_RESP_ERR__IN_PROGRESS = (- 178),\n  RD_KAFKA_RESP_ERR__PREV_IN_PROGRESS = (- 177),\n  RD_KAFKA_RESP_ERR__EXISTING_SUBSCRIPTION = (- 176),\n  RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS = (- 175),\n  RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS = (- 174),\n  RD_KAFKA_RESP_ERR__CONFLICT = (- 173),\n  RD_KAFKA_RESP_ERR__STATE = (- 172),\n  RD_KAFKA_RESP_ERR__UNKNOWN_PROTOCOL = (- 171),\n  RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED = (- 170),\n  RD_KAFKA_RESP_ERR__AUTHENTICATION = (- 169),\n  RD_KAFKA_RESP_ERR__NO_OFFSET = (- 168),\n  RD_KAFKA_RESP_ERR__OUTDATED = (- 167),\n  RD_KAFKA_RESP_ERR__TIMED_OUT_QUEUE = (- 166),\n  RD_KAFKA_RESP_ERR__UNSUPPORTED_FEATURE = (- 165),\n  RD_KAFKA_RESP_ERR__WAIT_CACHE = (- 164),\n  RD_KAFKA_RESP_ERR__INTR = (- 163),\n  RD_KAFKA_RESP_ERR__KEY_SERIALIZATION = (- 162),\n  RD_KAFKA_RESP_ERR__VALUE_SERIALIZATION = (- 161),\n  RD_KAFKA_RESP_ERR__KEY_DESERIALIZATION = (- 160),\n  RD_KAFKA_RESP_ERR__VALUE_DESERIALIZATION = (- 159),\n  RD_KAFKA_RESP_ERR__PARTIAL = (- 158),\n  RD_KAFKA_RESP_ERR__READ_ONLY = (- 157),\n  RD_KAFKA_RESP_ERR__NOENT = (- 156),\n  RD_KAFKA_RESP_ERR__UNDERFLOW = (- 155),\n  RD_KAFKA_RESP_ERR__INVALID_TYPE = (- 154),\n  RD_KAFKA_RESP_ERR__RETRY = (- 153),\n  RD_KAFKA_RESP_ERR__PURGE_QUEUE = (- 152),\n  RD_KAFKA_RESP_ERR__PURGE_INFLIGHT = (- 151),\n  RD_KAFKA_RESP_ERR__FATAL = (- 150),\n  RD_KAFKA_RESP_ERR__INCONSISTENT = (- 149),\n  RD_KAFKA_RESP_ERR__GAPLESS_GUARANTEE = (- 148),\n  RD_KAFKA_RESP_ERR__MAX_POLL_EXCEEDED = (- 147),\n  RD_KAFKA_RESP_ERR__UNKNOWN_BROKER = (- 146),\n  RD_KAFKA_RESP_ERR__NOT_CONFIGURED = (- 145),\n  RD_KAFKA_RESP_ERR__FENCED = (- 144),\n  RD_KAFKA_RESP_ERR__APPLICATION = (- 143),\n  RD_KAFKA_RESP_ERR__ASSIGNMENT_LOST = (- 142),\n  RD_KAFKA_RESP_ERR__NOOP = (- 141),\n  RD_KAFKA_RESP_ERR__AUTO_OFFSET_RESET = (- 140),\n  RD_KAFKA_RESP_ERR__LOG_TRUNCATION = (- 139),\n  RD_KAFKA_RESP_ERR__END = (- 100),\n  RD_KAFKA_RESP_ERR_UNKNOWN = (- 1),\n  RD_KAFKA_RESP_ERR_NO_ERROR = 0,\n  RD_KAFKA_RESP_ERR_OFFSET_OUT_OF_RANGE = 1,\n  RD_KAFKA_RESP_ERR_INVALID_MSG = 2,\n  RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART = 3,\n  RD_KAFKA_RESP_ERR_INVALID_MSG_SIZE = 4,\n  RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE = 5,\n  RD_KAFKA_RESP_ERR_NOT_LEADER_FOR_PARTITION = 6,\n  RD_KAFKA_RESP_ERR_REQUEST_TIMED_OUT = 7,\n  RD_KAFKA_RESP_ERR_BROKER_NOT_AVAILABLE = 8,\n  RD_KAFKA_RESP_ERR_REPLICA_NOT_AVAILABLE = 9,\n  RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE = 10,\n  RD_KAFKA_RESP_ERR_STALE_CTRL_EPOCH = 11,\n  RD_KAFKA_RESP_ERR_OFFSET_METADATA_TOO_LARGE = 12,\n  RD_KAFKA_RESP_ERR_NETWORK_EXCEPTION = 13,\n  RD_KAFKA_RESP_ERR_COORDINATOR_LOAD_IN_PROGRESS = 14,\n  RD_KAFKA_RESP_ERR_COORDINATOR_NOT_AVAILABLE = 15,\n  RD_KAFKA_RESP_ERR_NOT_COORDINATOR = 16,\n  RD_KAFKA_RESP_ERR_TOPIC_EXCEPTION = 17,\n  RD_KAFKA_RESP_ERR_RECORD_LIST_TOO_LARGE = 18,\n  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS = 19,\n  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS_AFTER_APPEND = 20,\n  RD_KAFKA_RESP_ERR_INVALID_REQUIRED_ACKS = 21,\n  RD_KAFKA_RESP_ERR_ILLEGAL_GENERATION = 22,\n  RD_KAFKA_RESP_ERR_INCONSISTENT_GROUP_PROTOCOL = 23,\n  RD_KAFKA_RESP_ERR_INVALID_GROUP_ID = 24,\n  RD_KAFKA_RESP_ERR_UNKNOWN_MEMBER_ID = 25,\n  RD_KAFKA_RESP_ERR_INVALID_SESSION_TIMEOUT = 26,\n  RD_KAFKA_RESP_ERR_REBALANCE_IN_PROGRESS = 27,\n  RD_KAFKA_RESP_ERR_INVALID_COMMIT_OFFSET_SIZE = 28,\n  RD_KAFKA_RESP_ERR_TOPIC_AUTHORIZATION_FAILED = 29,\n  RD_KAFKA_RESP_ERR_GROUP_AUTHORIZATION_FAILED = 30,\n  RD_KAFKA_RESP_ERR_CLUSTER_AUTHORIZATION_FAILED = 31,\n  RD_KAFKA_RESP_ERR_INVALID_TIMESTAMP = 32,\n  RD_KAFKA_RESP_ERR_UNSUPPORTED_SASL_MECHANISM = 33,\n  RD_KAFKA_RESP_ERR_ILLEGAL_SASL_STATE = 34,\n  RD_KAFKA_RESP_ERR_UNSUPPORTED_VERSION = 35,\n  RD_KAFKA_RESP_ERR_TOPIC_ALREADY_EXISTS = 36,\n  RD_KAFKA_RESP_ERR_INVALID_PARTITIONS = 37,\n  RD_KAFKA_RESP_ERR_INVALID_REPLICATION_FACTOR = 38,\n  RD_KAFKA_RESP_ERR_INVALID_REPLICA_ASSIGNMENT = 39,\n  RD_KAFKA_RESP_ERR_INVALID_CONFIG = 40,\n  RD_KAFKA_RESP_ERR_NOT_CONTROLLER = 41,\n  RD_KAFKA_RESP_ERR_INVALID_REQUEST = 42,\n  RD_KAFKA_RESP_ERR_UNSUPPORTED_FOR_MESSAGE_FORMAT = 43,\n  RD_KAFKA_RESP_ERR_POLICY_VIOLATION = 44,\n  RD_KAFKA_RESP_ERR_OUT_OF_ORDER_SEQUENCE_NUMBER = 45,\n  RD_KAFKA_RESP_ERR_DUPLICATE_SEQUENCE_NUMBER = 46,\n  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_EPOCH = 47,\n  RD_KAFKA_RESP_ERR_INVALID_TXN_STATE = 48,\n  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_ID_MAPPING = 49,\n  RD_KAFKA_RESP_ERR_INVALID_TRANSACTION_TIMEOUT = 50,\n  RD_KAFKA_RESP_ERR_CONCURRENT_TRANSACTIONS = 51,\n  RD_KAFKA_RESP_ERR_TRANSACTION_COORDINATOR_FENCED = 52,\n  RD_KAFKA_RESP_ERR_TRANSACTIONAL_ID_AUTHORIZATION_FAILED = 53,\n  RD_KAFKA_RESP_ERR_SECURITY_DISABLED = 54,\n  RD_KAFKA_RESP_ERR_OPERATION_NOT_ATTEMPTED = 55,\n  RD_KAFKA_RESP_ERR_KAFKA_STORAGE_ERROR = 56,\n  RD_KAFKA_RESP_ERR_LOG_DIR_NOT_FOUND = 57,\n  RD_KAFKA_RESP_ERR_SASL_AUTHENTICATION_FAILED = 58,\n  RD_KAFKA_RESP_ERR_UNKNOWN_PRODUCER_ID = 59,\n  RD_KAFKA_RESP_ERR_REASSIGNMENT_IN_PROGRESS = 60,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTH_DISABLED = 61,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_NOT_FOUND = 62,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_OWNER_MISMATCH = 63,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_REQUEST_NOT_ALLOWED = 64,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTHORIZATION_FAILED = 65,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_EXPIRED = 66,\n  RD_KAFKA_RESP_ERR_INVALID_PRINCIPAL_TYPE = 67,\n  RD_KAFKA_RESP_ERR_NON_EMPTY_GROUP = 68,\n  RD_KAFKA_RESP_ERR_GROUP_ID_NOT_FOUND = 69,\n  RD_KAFKA_RESP_ERR_FETCH_SESSION_ID_NOT_FOUND = 70,\n  RD_KAFKA_RESP_ERR_INVALID_FETCH_SESSION_EPOCH = 71,\n  RD_KAFKA_RESP_ERR_LISTENER_NOT_FOUND = 72,\n  RD_KAFKA_RESP_ERR_TOPIC_DELETION_DISABLED = 73,\n  RD_KAFKA_RESP_ERR_FENCED_LEADER_EPOCH = 74,\n  RD_KAFKA_RESP_ERR_UNKNOWN_LEADER_EPOCH = 75,\n  RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76,\n  RD_KAFKA_RESP_ERR_STALE_BROKER_EPOCH = 77,\n  RD_KAFKA_RESP_ERR_OFFSET_NOT_AVAILABLE = 78,\n  RD_KAFKA_RESP_ERR_MEMBER_ID_REQUIRED = 79,\n  RD_KAFKA_RESP_ERR_PREFERRED_LEADER_NOT_AVAILABLE = 80,\n  RD_KAFKA_RESP_ERR_GROUP_MAX_SIZE_REACHED = 81,\n  RD_KAFKA_RESP_ERR_FENCED_INSTANCE_ID = 82,\n  RD_KAFKA_RESP_ERR_ELIGIBLE_LEADERS_NOT_AVAILABLE = 83,\n  RD_KAFKA_RESP_ERR_ELECTION_NOT_NEEDED = 84,\n  RD_KAFKA_RESP_ERR_NO_REASSIGNMENT_IN_PROGRESS = 85,\n  RD_KAFKA_RESP_ERR_GROUP_SUBSCRIBED_TO_TOPIC = 86,\n  RD_KAFKA_RESP_ERR_INVALID_RECORD = 87,\n  RD_KAFKA_RESP_ERR_UNSTABLE_OFFSET_COMMIT = 88,\n  RD_KAFKA_RESP_ERR_THROTTLING_QUOTA_EXCEEDED = 89,\n  RD_KAFKA_RESP_ERR_PRODUCER_FENCED = 90,\n  RD_KAFKA_RESP_ERR_RESOURCE_NOT_FOUND = 91,\n  RD_KAFKA_RESP_ERR_DUPLICATE_RESOURCE = 92,\n  RD_KAFKA_RESP_ERR_UNACCEPTABLE_CREDENTIAL = 93,\n  RD_KAFKA_RESP_ERR_INCONSISTENT_VOTER_SET = 94,\n  RD_KAFKA_RESP_ERR_INVALID_UPDATE_VERSION = 95,\n  RD_KAFKA_RESP_ERR_FEATURE_UPDATE_FAILED = 96,\n  RD_KAFKA_RESP_ERR_PRINCIPAL_DESERIALIZATION_FAILURE = 97,\n  RD_KAFKA_RESP_ERR_END_ALL,\n} rd_kafka_resp_err_t;\nstruct rd_kafka_err_desc {\n  rd_kafka_resp_err_t code;\n  char *name;\n  char *desc;\n};\nvoid rd_kafka_get_err_descs(const struct rd_kafka_err_desc **errdescs, size_t *cntp);\nconst char *rd_kafka_err2str(rd_kafka_resp_err_t err);\nconst char *rd_kafka_err2name(rd_kafka_resp_err_t err);\nrd_kafka_resp_err_t rd_kafka_last_error(void);\nrd_kafka_resp_err_t rd_kafka_errno2err(int errnox);\nint rd_kafka_errno(void);\nrd_kafka_resp_err_t rd_kafka_fatal_error(rd_kafka_t *rk, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_test_fatal_error(rd_kafka_t *rk, rd_kafka_resp_err_t err, const char *reason);\nrd_kafka_resp_err_t rd_kafka_error_code(const rd_kafka_error_t *error);\nconst char *rd_kafka_error_name(const rd_kafka_error_t *error);\nconst char *rd_kafka_error_string(const rd_kafka_error_t *error);\nint rd_kafka_error_is_fatal(const rd_kafka_error_t *error);\nint rd_kafka_error_is_retriable(const rd_kafka_error_t *error);\nint rd_kafka_error_txn_requires_abort(const rd_kafka_error_t *error);\nvoid rd_kafka_error_destroy(rd_kafka_error_t *error);\nrd_kafka_error_t *rd_kafka_error_new(rd_kafka_resp_err_t code, const char *fmt, ...);\ntypedef struct rd_kafka_topic_partition_s {\n  char *topic;\n  int32_t partition;\n  int64_t offset;\n  void *metadata;\n  size_t metadata_size;\n  void *opaque;\n  rd_kafka_resp_err_t err;\n  void *_private;\n} rd_kafka_topic_partition_t;\nvoid rd_kafka_topic_partition_destroy(rd_kafka_topic_partition_t *rktpar);\nvoid rd_kafka_topic_partition_set_leader_epoch(rd_kafka_topic_partition_t *rktpar, int32_t leader_epoch);\nint32_t rd_kafka_topic_partition_get_leader_epoch(const rd_kafka_topic_partition_t *rktpar);\ntypedef struct rd_kafka_topic_partition_list_s {\n  int cnt;\n  int size;\n  rd_kafka_topic_partition_t *elems;\n} rd_kafka_topic_partition_list_t;\nrd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_new(int size);\nvoid rd_kafka_topic_partition_list_destroy(rd_kafka_topic_partition_list_t *rkparlist);\nrd_kafka_topic_partition_t *rd_kafka_topic_partition_list_add(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);\nvoid rd_kafka_topic_partition_list_add_range(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t start, int32_t stop);\nint rd_kafka_topic_partition_list_del(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);\nint rd_kafka_topic_partition_list_del_by_idx(rd_kafka_topic_partition_list_t *rktparlist, int idx);\nrd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_copy(const rd_kafka_topic_partition_list_t *src);\nrd_kafka_resp_err_t rd_kafka_topic_partition_list_set_offset(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition, int64_t offset);\nrd_kafka_topic_partition_t *rd_kafka_topic_partition_list_find(const rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);\nvoid rd_kafka_topic_partition_list_sort(rd_kafka_topic_partition_list_t *rktparlist, int (*cmp)(const void *a, const void *b, void *cmp_opaque), void *cmp_opaque);\ntypedef enum rd_kafka_vtype_t {\n  RD_KAFKA_VTYPE_END,\n  RD_KAFKA_VTYPE_TOPIC,\n  RD_KAFKA_VTYPE_RKT,\n  RD_KAFKA_VTYPE_PARTITION,\n  RD_KAFKA_VTYPE_VALUE,\n  RD_KAFKA_VTYPE_KEY,\n  RD_KAFKA_VTYPE_OPAQUE,\n  RD_KAFKA_VTYPE_MSGFLAGS,\n  RD_KAFKA_VTYPE_TIMESTAMP,\n  RD_KAFKA_VTYPE_HEADER,\n  RD_KAFKA_VTYPE_HEADERS,\n} rd_kafka_vtype_t;\ntypedef struct rd_kafka_vu_s {\n  rd_kafka_vtype_t vtype;\n  union {\n    char *cstr;\n    rd_kafka_topic_t *rkt;\n    int i;\n    int32_t i32;\n    int64_t i64;\n    struct {\n      void *ptr;\n      size_t size;\n    } mem;\n    struct {\n      char *name;\n      void *val;\n      ssize_t size;\n    } header;\n    rd_kafka_headers_t *headers;\n    void *ptr;\n    char _pad[64];\n  } u;\n} rd_kafka_vu_t;\nrd_kafka_headers_t *rd_kafka_headers_new(size_t initial_count);\nvoid rd_kafka_headers_destroy(rd_kafka_headers_t *hdrs);\nrd_kafka_headers_t *rd_kafka_headers_copy(const rd_kafka_headers_t *src);\nrd_kafka_resp_err_t rd_kafka_header_add(rd_kafka_headers_t *hdrs, const char *name, ssize_t name_size, const void *value, ssize_t value_size);\nrd_kafka_resp_err_t rd_kafka_header_remove(rd_kafka_headers_t *hdrs, const char *name);\nrd_kafka_resp_err_t rd_kafka_header_get_last(const rd_kafka_headers_t *hdrs, const char *name, const void **valuep, size_t *sizep);\nrd_kafka_resp_err_t rd_kafka_header_get(const rd_kafka_headers_t *hdrs, size_t idx, const char *name, const void **valuep, size_t *sizep);\nrd_kafka_resp_err_t rd_kafka_header_get_all(const rd_kafka_headers_t *hdrs, size_t idx, const char **namep, const void **valuep, size_t *sizep);\ntypedef struct rd_kafka_message_s {\n  rd_kafka_resp_err_t err;\n  rd_kafka_topic_t *rkt;\n  int32_t partition;\n  void *payload;\n  size_t len;\n  void *key;\n  size_t key_len;\n  int64_t offset;\n  void *_private;\n} rd_kafka_message_t;\nvoid rd_kafka_message_destroy(rd_kafka_message_t *rkmessage);\nconst char *rd_kafka_message_errstr(const rd_kafka_message_t *rkmessage);\nint64_t rd_kafka_message_timestamp(const rd_kafka_message_t *rkmessage, rd_kafka_timestamp_type_t *tstype);\nint64_t rd_kafka_message_latency(const rd_kafka_message_t *rkmessage);\nint32_t rd_kafka_message_broker_id(const rd_kafka_message_t *rkmessage);\nrd_kafka_resp_err_t rd_kafka_message_headers(const rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);\nrd_kafka_resp_err_t rd_kafka_message_detach_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);\nvoid rd_kafka_message_set_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t *hdrs);\nsize_t rd_kafka_header_cnt(const rd_kafka_headers_t *hdrs);\ntypedef enum {\n  RD_KAFKA_MSG_STATUS_NOT_PERSISTED = 0,\n  RD_KAFKA_MSG_STATUS_POSSIBLY_PERSISTED = 1,\n  RD_KAFKA_MSG_STATUS_PERSISTED = 2,\n} rd_kafka_msg_status_t;\nrd_kafka_msg_status_t rd_kafka_message_status(const rd_kafka_message_t *rkmessage);\nint32_t rd_kafka_message_leader_epoch(const rd_kafka_message_t *rkmessage);\ntypedef enum {\n  RD_KAFKA_CONF_UNKNOWN = (- 2),\n  RD_KAFKA_CONF_INVALID = (- 1),\n  RD_KAFKA_CONF_OK = 0,\n} rd_kafka_conf_res_t;\nrd_kafka_conf_t *rd_kafka_conf_new(void);\nvoid rd_kafka_conf_destroy(rd_kafka_conf_t *conf);\nrd_kafka_conf_t *rd_kafka_conf_dup(const rd_kafka_conf_t *conf);\nrd_kafka_conf_t *rd_kafka_conf_dup_filter(const rd_kafka_conf_t *conf, size_t filter_cnt, const char **filter);\nconst rd_kafka_conf_t *rd_kafka_conf(rd_kafka_t *rk);\nrd_kafka_conf_res_t rd_kafka_conf_set(rd_kafka_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);\nvoid rd_kafka_conf_set_events(rd_kafka_conf_t *conf, int events);\nvoid rd_kafka_conf_set_background_event_cb(rd_kafka_conf_t *conf, void (*event_cb)(rd_kafka_t *rk, rd_kafka_event_t *rkev, void *opaque));\nvoid rd_kafka_conf_set_dr_cb(rd_kafka_conf_t *conf, void (*dr_cb)(rd_kafka_t *rk, void *payload, size_t len, rd_kafka_resp_err_t err, void *opaque, void *msg_opaque));\nvoid rd_kafka_conf_set_dr_msg_cb(rd_kafka_conf_t *conf, void (*dr_msg_cb)(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, void *opaque));\nvoid rd_kafka_conf_set_consume_cb(rd_kafka_conf_t *conf, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *opaque));\nvoid rd_kafka_conf_set_rebalance_cb(rd_kafka_conf_t *conf, void (*rebalance_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *partitions, void *opaque));\nvoid rd_kafka_conf_set_offset_commit_cb(rd_kafka_conf_t *conf, void (*offset_commit_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *opaque));\nvoid rd_kafka_conf_set_error_cb(rd_kafka_conf_t *conf, void (*error_cb)(rd_kafka_t *rk, int err, const char *reason, void *opaque));\nvoid rd_kafka_conf_set_throttle_cb(rd_kafka_conf_t *conf, void (*throttle_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int throttle_time_ms, void *opaque));\nvoid rd_kafka_conf_set_log_cb(rd_kafka_conf_t *conf, void (*log_cb)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));\nvoid rd_kafka_conf_set_stats_cb(rd_kafka_conf_t *conf, int (*stats_cb)(rd_kafka_t *rk, char *json, size_t json_len, void *opaque));\nvoid rd_kafka_conf_set_oauthbearer_token_refresh_cb(rd_kafka_conf_t *conf, void (*oauthbearer_token_refresh_cb)(rd_kafka_t *rk, const char *oauthbearer_config, void *opaque));\nvoid rd_kafka_conf_enable_sasl_queue(rd_kafka_conf_t *conf, int enable);\nvoid rd_kafka_conf_set_socket_cb(rd_kafka_conf_t *conf, int (*socket_cb)(int domain, int type, int protocol, void *opaque));\nvoid rd_kafka_conf_set_connect_cb(rd_kafka_conf_t *conf, int (*connect_cb)(int sockfd, const struct sockaddr *addr, int addrlen, const char *id, void *opaque));\nvoid rd_kafka_conf_set_closesocket_cb(rd_kafka_conf_t *conf, int (*closesocket_cb)(int sockfd, void *opaque));\nstruct addrinfo;\nvoid rd_kafka_conf_set_resolve_cb(rd_kafka_conf_t *conf, int (*resolve_cb)(const char *node, const char *service, const struct addrinfo *hints, struct addrinfo **res, void *opaque));\nrd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert_verify_cb(rd_kafka_conf_t *conf, int (*ssl_cert_verify_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int *x509_error, int depth, const char *buf, size_t size, char *errstr, size_t errstr_size, void *opaque));\ntypedef enum rd_kafka_cert_type_t {\n  RD_KAFKA_CERT_PUBLIC_KEY,\n  RD_KAFKA_CERT_PRIVATE_KEY,\n  RD_KAFKA_CERT_CA,\n  RD_KAFKA_CERT__CNT,\n} rd_kafka_cert_type_t;\ntypedef enum rd_kafka_cert_enc_t {\n  RD_KAFKA_CERT_ENC_PKCS12,\n  RD_KAFKA_CERT_ENC_DER,\n  RD_KAFKA_CERT_ENC_PEM,\n  RD_KAFKA_CERT_ENC__CNT,\n} rd_kafka_cert_enc_t;\nrd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert(rd_kafka_conf_t *conf, rd_kafka_cert_type_t cert_type, rd_kafka_cert_enc_t cert_enc, const void *buffer, size_t size, char *errstr, size_t errstr_size);\nvoid rd_kafka_conf_set_engine_callback_data(rd_kafka_conf_t *conf, void *callback_data);\nvoid rd_kafka_conf_set_opaque(rd_kafka_conf_t *conf, void *opaque);\nvoid *rd_kafka_opaque(const rd_kafka_t *rk);\nvoid rd_kafka_conf_set_default_topic_conf(rd_kafka_conf_t *conf, rd_kafka_topic_conf_t *tconf);\nrd_kafka_topic_conf_t *rd_kafka_conf_get_default_topic_conf(rd_kafka_conf_t *conf);\nrd_kafka_conf_res_t rd_kafka_conf_get(const rd_kafka_conf_t *conf, const char *name, char *dest, size_t *dest_size);\nrd_kafka_conf_res_t rd_kafka_topic_conf_get(const rd_kafka_topic_conf_t *conf, const char *name, char *dest, size_t *dest_size);\nconst char **rd_kafka_conf_dump(rd_kafka_conf_t *conf, size_t *cntp);\nconst char **rd_kafka_topic_conf_dump(rd_kafka_topic_conf_t *conf, size_t *cntp);\nvoid rd_kafka_conf_dump_free(const char **arr, size_t cnt);\nvoid rd_kafka_conf_properties_show(FILE *fp);\nrd_kafka_topic_conf_t *rd_kafka_topic_conf_new(void);\nrd_kafka_topic_conf_t *rd_kafka_topic_conf_dup(const rd_kafka_topic_conf_t *conf);\nrd_kafka_topic_conf_t *rd_kafka_default_topic_conf_dup(rd_kafka_t *rk);\nvoid rd_kafka_topic_conf_destroy(rd_kafka_topic_conf_t *topic_conf);\nrd_kafka_conf_res_t rd_kafka_topic_conf_set(rd_kafka_topic_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);\nvoid rd_kafka_topic_conf_set_opaque(rd_kafka_topic_conf_t *conf, void *rkt_opaque);\nvoid rd_kafka_topic_conf_set_partitioner_cb(rd_kafka_topic_conf_t *topic_conf, int32_t (*partitioner)(const rd_kafka_topic_t *rkt, const void *keydata, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque));\nvoid rd_kafka_topic_conf_set_msg_order_cmp(rd_kafka_topic_conf_t *topic_conf, int (*msg_order_cmp)(const rd_kafka_message_t *a, const rd_kafka_message_t *b));\nint rd_kafka_topic_partition_available(const rd_kafka_topic_t *rkt, int32_t partition);\nint32_t rd_kafka_msg_partitioner_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_consistent(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_consistent_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_murmur2(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_murmur2_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_fnv1a(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_fnv1a_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nrd_kafka_t *rd_kafka_new(rd_kafka_type_t type, rd_kafka_conf_t *conf, char *errstr, size_t errstr_size);\nvoid rd_kafka_destroy(rd_kafka_t *rk);\nvoid rd_kafka_destroy_flags(rd_kafka_t *rk, int flags);\nconst char *rd_kafka_name(const rd_kafka_t *rk);\nrd_kafka_type_t rd_kafka_type(const rd_kafka_t *rk);\nchar *rd_kafka_memberid(const rd_kafka_t *rk);\nchar *rd_kafka_clusterid(rd_kafka_t *rk, int timeout_ms);\nint32_t rd_kafka_controllerid(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_topic_t *rd_kafka_topic_new(rd_kafka_t *rk, const char *topic, rd_kafka_topic_conf_t *conf);\nvoid rd_kafka_topic_destroy(rd_kafka_topic_t *rkt);\nconst char *rd_kafka_topic_name(const rd_kafka_topic_t *rkt);\nvoid *rd_kafka_topic_opaque(const rd_kafka_topic_t *rkt);\nint rd_kafka_poll(rd_kafka_t *rk, int timeout_ms);\nvoid rd_kafka_yield(rd_kafka_t *rk);\nrd_kafka_resp_err_t rd_kafka_pause_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_resp_err_t rd_kafka_resume_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_resp_err_t rd_kafka_query_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high, int timeout_ms);\nrd_kafka_resp_err_t rd_kafka_get_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high);\nrd_kafka_resp_err_t rd_kafka_offsets_for_times(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets, int timeout_ms);\nvoid *rd_kafka_mem_calloc(rd_kafka_t *rk, size_t num, size_t size);\nvoid *rd_kafka_mem_malloc(rd_kafka_t *rk, size_t size);\nvoid rd_kafka_mem_free(rd_kafka_t *rk, void *ptr);\nrd_kafka_queue_t *rd_kafka_queue_new(rd_kafka_t *rk);\nvoid rd_kafka_queue_destroy(rd_kafka_queue_t *rkqu);\nrd_kafka_queue_t *rd_kafka_queue_get_main(rd_kafka_t *rk);\nrd_kafka_queue_t *rd_kafka_queue_get_sasl(rd_kafka_t *rk);\nrd_kafka_error_t *rd_kafka_sasl_background_callbacks_enable(rd_kafka_t *rk);\nrd_kafka_error_t *rd_kafka_sasl_set_credentials(rd_kafka_t *rk, const char *username, const char *password);\nrd_kafka_queue_t *rd_kafka_queue_get_consumer(rd_kafka_t *rk);\nrd_kafka_queue_t *rd_kafka_queue_get_partition(rd_kafka_t *rk, const char *topic, int32_t partition);\nrd_kafka_queue_t *rd_kafka_queue_get_background(rd_kafka_t *rk);\nvoid rd_kafka_queue_forward(rd_kafka_queue_t *src, rd_kafka_queue_t *dst);\nrd_kafka_resp_err_t rd_kafka_set_log_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu);\nsize_t rd_kafka_queue_length(rd_kafka_queue_t *rkqu);\nvoid rd_kafka_queue_io_event_enable(rd_kafka_queue_t *rkqu, int fd, const void *payload, size_t size);\nvoid rd_kafka_queue_cb_event_enable(rd_kafka_queue_t *rkqu, void (*event_cb)(rd_kafka_t *rk, void *qev_opaque), void *qev_opaque);\nvoid rd_kafka_queue_yield(rd_kafka_queue_t *rkqu);\nint rd_kafka_consume_start(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);\nint rd_kafka_consume_start_queue(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, rd_kafka_queue_t *rkqu);\nint rd_kafka_consume_stop(rd_kafka_topic_t *rkt, int32_t partition);\nrd_kafka_resp_err_t rd_kafka_seek(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, int timeout_ms);\nrd_kafka_error_t *rd_kafka_seek_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms);\nrd_kafka_message_t *rd_kafka_consume(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms);\nssize_t rd_kafka_consume_batch(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);\nint rd_kafka_consume_callback(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);\nrd_kafka_message_t *rd_kafka_consume_queue(rd_kafka_queue_t *rkqu, int timeout_ms);\nssize_t rd_kafka_consume_batch_queue(rd_kafka_queue_t *rkqu, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);\nint rd_kafka_consume_callback_queue(rd_kafka_queue_t *rkqu, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);\nrd_kafka_resp_err_t rd_kafka_offset_store(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);\nrd_kafka_resp_err_t rd_kafka_offsets_store(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets);\nrd_kafka_error_t *rd_kafka_offset_store_message(rd_kafka_message_t *rkmessage);\nrd_kafka_resp_err_t rd_kafka_subscribe(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *topics);\nrd_kafka_resp_err_t rd_kafka_unsubscribe(rd_kafka_t *rk);\nrd_kafka_resp_err_t rd_kafka_subscription(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **topics);\nrd_kafka_message_t *rd_kafka_consumer_poll(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_resp_err_t rd_kafka_consumer_close(rd_kafka_t *rk);\nrd_kafka_error_t *rd_kafka_consumer_close_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu);\nint rd_kafka_consumer_closed(rd_kafka_t *rk);\nrd_kafka_error_t *rd_kafka_incremental_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_error_t *rd_kafka_incremental_unassign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);\nconst char *rd_kafka_rebalance_protocol(rd_kafka_t *rk);\nrd_kafka_resp_err_t rd_kafka_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_resp_err_t rd_kafka_assignment(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **partitions);\nint rd_kafka_assignment_lost(rd_kafka_t *rk);\nrd_kafka_resp_err_t rd_kafka_commit(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, int async);\nrd_kafka_resp_err_t rd_kafka_commit_message(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, int async);\nrd_kafka_resp_err_t rd_kafka_commit_queue(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_queue_t *rkqu, void (*cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *commit_opaque), void *commit_opaque);\nrd_kafka_resp_err_t rd_kafka_committed(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms);\nrd_kafka_resp_err_t rd_kafka_position(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata(rd_kafka_t *rk);\nrd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata_new(const char *group_id);\nrd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata_new_with_genid(const char *group_id, int32_t generation_id, const char *member_id, const char *group_instance_id);\nvoid rd_kafka_consumer_group_metadata_destroy(rd_kafka_consumer_group_metadata_t *);\nrd_kafka_error_t *rd_kafka_consumer_group_metadata_write(const rd_kafka_consumer_group_metadata_t *cgmd, void **bufferp, size_t *sizep);\nrd_kafka_error_t *rd_kafka_consumer_group_metadata_read(rd_kafka_consumer_group_metadata_t **cgmdp, const void *buffer, size_t size);\nint rd_kafka_produce(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, void *payload, size_t len, const void *key, size_t keylen, void *msg_opaque);\nrd_kafka_resp_err_t rd_kafka_producev(rd_kafka_t *rk, ...);\nrd_kafka_error_t *rd_kafka_produceva(rd_kafka_t *rk, const rd_kafka_vu_t *vus, size_t cnt);\nint rd_kafka_produce_batch(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, rd_kafka_message_t *rkmessages, int message_cnt);\nrd_kafka_resp_err_t rd_kafka_flush(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_resp_err_t rd_kafka_purge(rd_kafka_t *rk, int purge_flags);\ntypedef struct rd_kafka_metadata_broker {\n  int32_t id;\n  char *host;\n  int port;\n} rd_kafka_metadata_broker_t;\ntypedef struct rd_kafka_metadata_partition {\n  int32_t id;\n  rd_kafka_resp_err_t err;\n  int32_t leader;\n  int replica_cnt;\n  int32_t *replicas;\n  int isr_cnt;\n  int32_t *isrs;\n} rd_kafka_metadata_partition_t;\ntypedef struct rd_kafka_metadata_topic {\n  char *topic;\n  int partition_cnt;\n  struct rd_kafka_metadata_partition *partitions;\n  rd_kafka_resp_err_t err;\n} rd_kafka_metadata_topic_t;\ntypedef struct rd_kafka_metadata {\n  int broker_cnt;\n  struct rd_kafka_metadata_broker *brokers;\n  int topic_cnt;\n  struct rd_kafka_metadata_topic *topics;\n  int32_t orig_broker_id;\n  char *orig_broker_name;\n} rd_kafka_metadata_t;\nrd_kafka_resp_err_t rd_kafka_metadata(rd_kafka_t *rk, int all_topics, rd_kafka_topic_t *only_rkt, const struct rd_kafka_metadata **metadatap, int timeout_ms);\nvoid rd_kafka_metadata_destroy(const struct rd_kafka_metadata *metadata);\ntypedef struct rd_kafka_Node_s rd_kafka_Node_t;\nint rd_kafka_Node_id(const rd_kafka_Node_t *node);\nconst char *rd_kafka_Node_host(const rd_kafka_Node_t *node);\nuint16_t rd_kafka_Node_port(const rd_kafka_Node_t *node);\nstruct rd_kafka_group_member_info {\n  char *member_id;\n  char *client_id;\n  char *client_host;\n  void *member_metadata;\n  int member_metadata_size;\n  void *member_assignment;\n  int member_assignment_size;\n};\ntypedef enum {\n  RD_KAFKA_CONSUMER_GROUP_STATE_UNKNOWN = 0,\n  RD_KAFKA_CONSUMER_GROUP_STATE_PREPARING_REBALANCE = 1,\n  RD_KAFKA_CONSUMER_GROUP_STATE_COMPLETING_REBALANCE = 2,\n  RD_KAFKA_CONSUMER_GROUP_STATE_STABLE = 3,\n  RD_KAFKA_CONSUMER_GROUP_STATE_DEAD = 4,\n  RD_KAFKA_CONSUMER_GROUP_STATE_EMPTY = 5,\n  RD_KAFKA_CONSUMER_GROUP_STATE__CNT,\n} rd_kafka_consumer_group_state_t;\nstruct rd_kafka_group_info {\n  struct rd_kafka_metadata_broker broker;\n  char *group;\n  rd_kafka_resp_err_t err;\n  char *state;\n  char *protocol_type;\n  char *protocol;\n  struct rd_kafka_group_member_info *members;\n  int member_cnt;\n};\nstruct rd_kafka_group_list {\n  struct rd_kafka_group_info *groups;\n  int group_cnt;\n};\nrd_kafka_resp_err_t rd_kafka_list_groups(rd_kafka_t *rk, const char *group, const struct rd_kafka_group_list **grplistp, int timeout_ms);\nconst char *rd_kafka_consumer_group_state_name(rd_kafka_consumer_group_state_t state);\nrd_kafka_consumer_group_state_t rd_kafka_consumer_group_state_code(const char *name);\nvoid rd_kafka_group_list_destroy(const struct rd_kafka_group_list *grplist);\nint rd_kafka_brokers_add(rd_kafka_t *rk, const char *brokerlist);\nvoid rd_kafka_set_logger(rd_kafka_t *rk, void (*func)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));\nvoid rd_kafka_set_log_level(rd_kafka_t *rk, int level);\nvoid rd_kafka_log_print(const rd_kafka_t *rk, int level, const char *fac, const char *buf);\nvoid rd_kafka_log_syslog(const rd_kafka_t *rk, int level, const char *fac, const char *buf);\nint rd_kafka_outq_len(rd_kafka_t *rk);\nvoid rd_kafka_dump(FILE *fp, rd_kafka_t *rk);\nint rd_kafka_thread_cnt(void);\ntypedef enum rd_kafka_thread_type_t {\n  RD_KAFKA_THREAD_MAIN,\n  RD_KAFKA_THREAD_BACKGROUND,\n  RD_KAFKA_THREAD_BROKER,\n} rd_kafka_thread_type_t;\nint rd_kafka_wait_destroyed(int timeout_ms);\nint rd_kafka_unittest(void);\nrd_kafka_resp_err_t rd_kafka_poll_set_consumer(rd_kafka_t *rk);\ntypedef int rd_kafka_event_type_t;\nrd_kafka_event_type_t rd_kafka_event_type(const rd_kafka_event_t *rkev);\nconst char *rd_kafka_event_name(const rd_kafka_event_t *rkev);\nvoid rd_kafka_event_destroy(rd_kafka_event_t *rkev);\nconst rd_kafka_message_t *rd_kafka_event_message_next(rd_kafka_event_t *rkev);\nsize_t rd_kafka_event_message_array(rd_kafka_event_t *rkev, const rd_kafka_message_t **rkmessages, size_t size);\nsize_t rd_kafka_event_message_count(rd_kafka_event_t *rkev);\nconst char *rd_kafka_event_config_string(rd_kafka_event_t *rkev);\nrd_kafka_resp_err_t rd_kafka_event_error(rd_kafka_event_t *rkev);\nconst char *rd_kafka_event_error_string(rd_kafka_event_t *rkev);\nint rd_kafka_event_error_is_fatal(rd_kafka_event_t *rkev);\nvoid *rd_kafka_event_opaque(rd_kafka_event_t *rkev);\nint rd_kafka_event_log(rd_kafka_event_t *rkev, const char **fac, const char **str, int *level);\nint rd_kafka_event_debug_contexts(rd_kafka_event_t *rkev, char *dst, size_t dstsize);\nconst char *rd_kafka_event_stats(rd_kafka_event_t *rkev);\nrd_kafka_topic_partition_list_t *rd_kafka_event_topic_partition_list(rd_kafka_event_t *rkev);\nrd_kafka_topic_partition_t *rd_kafka_event_topic_partition(rd_kafka_event_t *rkev);\ntypedef rd_kafka_event_t rd_kafka_CreateTopics_result_t;\ntypedef rd_kafka_event_t rd_kafka_DeleteTopics_result_t;\ntypedef rd_kafka_event_t rd_kafka_CreateAcls_result_t;\ntypedef rd_kafka_event_t rd_kafka_DescribeAcls_result_t;\ntypedef rd_kafka_event_t rd_kafka_DeleteAcls_result_t;\ntypedef rd_kafka_event_t rd_kafka_CreatePartitions_result_t;\ntypedef rd_kafka_event_t rd_kafka_AlterConfigs_result_t;\ntypedef rd_kafka_event_t rd_kafka_IncrementalAlterConfigs_result_t;\ntypedef rd_kafka_event_t rd_kafka_DescribeConfigs_result_t;\ntypedef rd_kafka_event_t rd_kafka_DeleteRecords_result_t;\ntypedef rd_kafka_event_t rd_kafka_ListConsumerGroups_result_t;\ntypedef rd_kafka_event_t rd_kafka_DescribeConsumerGroups_result_t;\ntypedef rd_kafka_event_t rd_kafka_DeleteGroups_result_t;\ntypedef rd_kafka_event_t rd_kafka_DeleteConsumerGroupOffsets_result_t;\ntypedef rd_kafka_event_t rd_kafka_AlterConsumerGroupOffsets_result_t;\ntypedef rd_kafka_event_t rd_kafka_ListConsumerGroupOffsets_result_t;\ntypedef rd_kafka_event_t rd_kafka_DescribeUserScramCredentials_result_t;\ntypedef rd_kafka_event_t rd_kafka_AlterUserScramCredentials_result_t;\nconst rd_kafka_CreateTopics_result_t *rd_kafka_event_CreateTopics_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DeleteTopics_result_t *rd_kafka_event_DeleteTopics_result(rd_kafka_event_t *rkev);\nconst rd_kafka_CreatePartitions_result_t *rd_kafka_event_CreatePartitions_result(rd_kafka_event_t *rkev);\nconst rd_kafka_AlterConfigs_result_t *rd_kafka_event_AlterConfigs_result(rd_kafka_event_t *rkev);\nconst rd_kafka_IncrementalAlterConfigs_result_t *rd_kafka_event_IncrementalAlterConfigs_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DescribeConfigs_result_t *rd_kafka_event_DescribeConfigs_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DeleteRecords_result_t *rd_kafka_event_DeleteRecords_result(rd_kafka_event_t *rkev);\nconst rd_kafka_ListConsumerGroups_result_t *rd_kafka_event_ListConsumerGroups_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DescribeConsumerGroups_result_t *rd_kafka_event_DescribeConsumerGroups_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DeleteGroups_result_t *rd_kafka_event_DeleteGroups_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DeleteConsumerGroupOffsets_result_t *rd_kafka_event_DeleteConsumerGroupOffsets_result(rd_kafka_event_t *rkev);\nconst rd_kafka_CreateAcls_result_t *rd_kafka_event_CreateAcls_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DescribeAcls_result_t *rd_kafka_event_DescribeAcls_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DeleteAcls_result_t *rd_kafka_event_DeleteAcls_result(rd_kafka_event_t *rkev);\nconst rd_kafka_ListConsumerGroupOffsets_result_t *rd_kafka_event_ListConsumerGroupOffsets_result(rd_kafka_event_t *rkev);\nconst rd_kafka_AlterConsumerGroupOffsets_result_t *rd_kafka_event_AlterConsumerGroupOffsets_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DescribeUserScramCredentials_result_t *rd_kafka_event_DescribeUserScramCredentials_result(rd_kafka_event_t *rkev);\nconst rd_kafka_AlterUserScramCredentials_result_t *rd_kafka_event_AlterUserScramCredentials_result(rd_kafka_event_t *rkev);\nrd_kafka_event_t *rd_kafka_queue_poll(rd_kafka_queue_t *rkqu, int timeout_ms);\nint rd_kafka_queue_poll_callback(rd_kafka_queue_t *rkqu, int timeout_ms);\ntypedef rd_kafka_resp_err_t (rd_kafka_plugin_f_conf_init_t)(rd_kafka_conf_t *conf, void **plug_opaquep, char *errstr, size_t errstr_size);\ntypedef rd_kafka_conf_res_t (rd_kafka_interceptor_f_on_conf_set_t)(rd_kafka_conf_t *conf, const char *name, const char *val, char *errstr, size_t errstr_size, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_dup_t)(rd_kafka_conf_t *new_conf, const rd_kafka_conf_t *old_conf, size_t filter_cnt, const char **filter, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_destroy_t)(void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_new_t)(rd_kafka_t *rk, const rd_kafka_conf_t *conf, void *ic_opaque, char *errstr, size_t errstr_size);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_destroy_t)(rd_kafka_t *rk, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_send_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_acknowledgement_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_consume_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_commit_t)(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_resp_err_t err, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_request_sent_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_response_received_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, int64_t rtt, rd_kafka_resp_err_t err, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_start_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_exit_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_broker_state_change_t)(rd_kafka_t *rk, int32_t broker_id, const char *secproto, const char *name, int port, const char *state, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_set(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_set_t *on_conf_set, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_dup(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_dup_t *on_conf_dup, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_destroy(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_destroy_t *on_conf_destroy, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_new(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_new_t *on_new, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_destroy(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_destroy_t *on_destroy, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_send(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_send_t *on_send, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_acknowledgement(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_acknowledgement_t *on_acknowledgement, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_consume(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_consume_t *on_consume, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_commit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_commit_t *on_commit, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_request_sent(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_request_sent_t *on_request_sent, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_response_received(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_response_received_t *on_response_received, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_start(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_start_t *on_thread_start, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_exit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_exit_t *on_thread_exit, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_broker_state_change(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_broker_state_change_t *on_broker_state_change, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_topic_result_error(const rd_kafka_topic_result_t *topicres);\nconst char *rd_kafka_topic_result_error_string(const rd_kafka_topic_result_t *topicres);\nconst char *rd_kafka_topic_result_name(const rd_kafka_topic_result_t *topicres);\nconst rd_kafka_error_t *rd_kafka_group_result_error(const rd_kafka_group_result_t *groupres);\nconst char *rd_kafka_group_result_name(const rd_kafka_group_result_t *groupres);\nconst rd_kafka_topic_partition_list_t *rd_kafka_group_result_partitions(const rd_kafka_group_result_t *groupres);\ntypedef enum rd_kafka_admin_op_t {\n  RD_KAFKA_ADMIN_OP_ANY = 0,\n  RD_KAFKA_ADMIN_OP_CREATETOPICS,\n  RD_KAFKA_ADMIN_OP_DELETETOPICS,\n  RD_KAFKA_ADMIN_OP_CREATEPARTITIONS,\n  RD_KAFKA_ADMIN_OP_ALTERCONFIGS,\n  RD_KAFKA_ADMIN_OP_DESCRIBECONFIGS,\n  RD_KAFKA_ADMIN_OP_DELETERECORDS,\n  RD_KAFKA_ADMIN_OP_DELETEGROUPS,\n  RD_KAFKA_ADMIN_OP_DELETECONSUMERGROUPOFFSETS,\n  RD_KAFKA_ADMIN_OP_CREATEACLS,\n  RD_KAFKA_ADMIN_OP_DESCRIBEACLS,\n  RD_KAFKA_ADMIN_OP_DELETEACLS,\n  RD_KAFKA_ADMIN_OP_LISTCONSUMERGROUPS,\n  RD_KAFKA_ADMIN_OP_DESCRIBECONSUMERGROUPS,\n  RD_KAFKA_ADMIN_OP_LISTCONSUMERGROUPOFFSETS,\n  RD_KAFKA_ADMIN_OP_ALTERCONSUMERGROUPOFFSETS,\n  RD_KAFKA_ADMIN_OP_INCREMENTALALTERCONFIGS,\n  RD_KAFKA_ADMIN_OP_DESCRIBEUSERSCRAMCREDENTIALS,\n  RD_KAFKA_ADMIN_OP_ALTERUSERSCRAMCREDENTIALS,\n  RD_KAFKA_ADMIN_OP__CNT,\n} rd_kafka_admin_op_t;\ntypedef struct rd_kafka_AdminOptions_s rd_kafka_AdminOptions_t;\nrd_kafka_AdminOptions_t *rd_kafka_AdminOptions_new(rd_kafka_t *rk, rd_kafka_admin_op_t for_api);\nvoid rd_kafka_AdminOptions_destroy(rd_kafka_AdminOptions_t *options);\nrd_kafka_resp_err_t rd_kafka_AdminOptions_set_request_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_AdminOptions_set_operation_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_AdminOptions_set_validate_only(rd_kafka_AdminOptions_t *options, int true_or_false, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_AdminOptions_set_broker(rd_kafka_AdminOptions_t *options, int32_t broker_id, char *errstr, size_t errstr_size);\nrd_kafka_error_t *rd_kafka_AdminOptions_set_require_stable_offsets(rd_kafka_AdminOptions_t *options, int true_or_false);\nrd_kafka_error_t *rd_kafka_AdminOptions_set_match_consumer_group_states(rd_kafka_AdminOptions_t *options, const rd_kafka_consumer_group_state_t *consumer_group_states, size_t consumer_group_states_cnt);\nvoid rd_kafka_AdminOptions_set_opaque(rd_kafka_AdminOptions_t *options, void *ev_opaque);\ntypedef struct rd_kafka_NewTopic_s rd_kafka_NewTopic_t;\nrd_kafka_NewTopic_t *rd_kafka_NewTopic_new(const char *topic, int num_partitions, int replication_factor, char *errstr, size_t errstr_size);\nvoid rd_kafka_NewTopic_destroy(rd_kafka_NewTopic_t *new_topic);\nvoid rd_kafka_NewTopic_destroy_array(rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt);\nrd_kafka_resp_err_t rd_kafka_NewTopic_set_replica_assignment(rd_kafka_NewTopic_t *new_topic, int32_t partition, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_NewTopic_set_config(rd_kafka_NewTopic_t *new_topic, const char *name, const char *value);\nvoid rd_kafka_CreateTopics(rd_kafka_t *rk, rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_topic_result_t **rd_kafka_CreateTopics_result_topics(const rd_kafka_CreateTopics_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_DeleteTopic_s rd_kafka_DeleteTopic_t;\nrd_kafka_DeleteTopic_t *rd_kafka_DeleteTopic_new(const char *topic);\nvoid rd_kafka_DeleteTopic_destroy(rd_kafka_DeleteTopic_t *del_topic);\nvoid rd_kafka_DeleteTopic_destroy_array(rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt);\nvoid rd_kafka_DeleteTopics(rd_kafka_t *rk, rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_topic_result_t **rd_kafka_DeleteTopics_result_topics(const rd_kafka_DeleteTopics_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_NewPartitions_s rd_kafka_NewPartitions_t;\nrd_kafka_NewPartitions_t *rd_kafka_NewPartitions_new(const char *topic, size_t new_total_cnt, char *errstr, size_t errstr_size);\nvoid rd_kafka_NewPartitions_destroy(rd_kafka_NewPartitions_t *new_parts);\nvoid rd_kafka_NewPartitions_destroy_array(rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt);\nrd_kafka_resp_err_t rd_kafka_NewPartitions_set_replica_assignment(rd_kafka_NewPartitions_t *new_parts, int32_t new_partition_idx, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);\nvoid rd_kafka_CreatePartitions(rd_kafka_t *rk, rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_topic_result_t **rd_kafka_CreatePartitions_result_topics(const rd_kafka_CreatePartitions_result_t *result, size_t *cntp);\ntypedef enum rd_kafka_ConfigSource_t {\n  RD_KAFKA_CONFIG_SOURCE_UNKNOWN_CONFIG = 0,\n  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_TOPIC_CONFIG = 1,\n  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_BROKER_CONFIG = 2,\n  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_DEFAULT_BROKER_CONFIG = 3,\n  RD_KAFKA_CONFIG_SOURCE_STATIC_BROKER_CONFIG = 4,\n  RD_KAFKA_CONFIG_SOURCE_DEFAULT_CONFIG = 5,\n  RD_KAFKA_CONFIG_SOURCE__CNT,\n} rd_kafka_ConfigSource_t;\nconst char *rd_kafka_ConfigSource_name(rd_kafka_ConfigSource_t confsource);\ntypedef struct rd_kafka_ConfigEntry_s rd_kafka_ConfigEntry_t;\nconst char *rd_kafka_ConfigEntry_name(const rd_kafka_ConfigEntry_t *entry);\nconst char *rd_kafka_ConfigEntry_value(const rd_kafka_ConfigEntry_t *entry);\nrd_kafka_ConfigSource_t rd_kafka_ConfigEntry_source(const rd_kafka_ConfigEntry_t *entry);\nint rd_kafka_ConfigEntry_is_read_only(const rd_kafka_ConfigEntry_t *entry);\nint rd_kafka_ConfigEntry_is_default(const rd_kafka_ConfigEntry_t *entry);\nint rd_kafka_ConfigEntry_is_sensitive(const rd_kafka_ConfigEntry_t *entry);\nint rd_kafka_ConfigEntry_is_synonym(const rd_kafka_ConfigEntry_t *entry);\nconst rd_kafka_ConfigEntry_t **rd_kafka_ConfigEntry_synonyms(const rd_kafka_ConfigEntry_t *entry, size_t *cntp);\ntypedef enum rd_kafka_ResourceType_t {\n  RD_KAFKA_RESOURCE_UNKNOWN = 0,\n  RD_KAFKA_RESOURCE_ANY = 1,\n  RD_KAFKA_RESOURCE_TOPIC = 2,\n  RD_KAFKA_RESOURCE_GROUP = 3,\n  RD_KAFKA_RESOURCE_BROKER = 4,\n  RD_KAFKA_RESOURCE__CNT,\n} rd_kafka_ResourceType_t;\ntypedef enum rd_kafka_ResourcePatternType_t {\n  RD_KAFKA_RESOURCE_PATTERN_UNKNOWN = 0,\n  RD_KAFKA_RESOURCE_PATTERN_ANY = 1,\n  RD_KAFKA_RESOURCE_PATTERN_MATCH = 2,\n  RD_KAFKA_RESOURCE_PATTERN_LITERAL = 3,\n  RD_KAFKA_RESOURCE_PATTERN_PREFIXED = 4,\n  RD_KAFKA_RESOURCE_PATTERN_TYPE__CNT,\n} rd_kafka_ResourcePatternType_t;\ntypedef enum rd_kafka_AlterConfigOpType_t {\n  RD_KAFKA_ALTER_CONFIG_OP_TYPE_SET = 0,\n  RD_KAFKA_ALTER_CONFIG_OP_TYPE_DELETE = 1,\n  RD_KAFKA_ALTER_CONFIG_OP_TYPE_APPEND = 2,\n  RD_KAFKA_ALTER_CONFIG_OP_TYPE_SUBTRACT = 3,\n  RD_KAFKA_ALTER_CONFIG_OP_TYPE__CNT,\n} rd_kafka_AlterConfigOpType_t;\nconst char *rd_kafka_ResourcePatternType_name(rd_kafka_ResourcePatternType_t resource_pattern_type);\nconst char *rd_kafka_ResourceType_name(rd_kafka_ResourceType_t restype);\ntypedef struct rd_kafka_ConfigResource_s rd_kafka_ConfigResource_t;\nrd_kafka_ConfigResource_t *rd_kafka_ConfigResource_new(rd_kafka_ResourceType_t restype, const char *resname);\nvoid rd_kafka_ConfigResource_destroy(rd_kafka_ConfigResource_t *config);\nvoid rd_kafka_ConfigResource_destroy_array(rd_kafka_ConfigResource_t **config, size_t config_cnt);\nrd_kafka_resp_err_t rd_kafka_ConfigResource_set_config(rd_kafka_ConfigResource_t *config, const char *name, const char *value);\nrd_kafka_error_t *rd_kafka_ConfigResource_add_incremental_config(rd_kafka_ConfigResource_t *config, const char *name, rd_kafka_AlterConfigOpType_t op_type, const char *value);\nconst rd_kafka_ConfigEntry_t **rd_kafka_ConfigResource_configs(const rd_kafka_ConfigResource_t *config, size_t *cntp);\nrd_kafka_ResourceType_t rd_kafka_ConfigResource_type(const rd_kafka_ConfigResource_t *config);\nconst char *rd_kafka_ConfigResource_name(const rd_kafka_ConfigResource_t *config);\nrd_kafka_resp_err_t rd_kafka_ConfigResource_error(const rd_kafka_ConfigResource_t *config);\nconst char *rd_kafka_ConfigResource_error_string(const rd_kafka_ConfigResource_t *config);\nvoid rd_kafka_AlterConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_ConfigResource_t **rd_kafka_AlterConfigs_result_resources(const rd_kafka_AlterConfigs_result_t *result, size_t *cntp);\nvoid rd_kafka_IncrementalAlterConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_ConfigResource_t **rd_kafka_IncrementalAlterConfigs_result_resources(const rd_kafka_IncrementalAlterConfigs_result_t *result, size_t *cntp);\nvoid rd_kafka_DescribeConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_ConfigResource_t **rd_kafka_DescribeConfigs_result_resources(const rd_kafka_DescribeConfigs_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_DeleteRecords_s rd_kafka_DeleteRecords_t;\nrd_kafka_DeleteRecords_t *rd_kafka_DeleteRecords_new(const rd_kafka_topic_partition_list_t *before_offsets);\nvoid rd_kafka_DeleteRecords_destroy(rd_kafka_DeleteRecords_t *del_records);\nvoid rd_kafka_DeleteRecords_destroy_array(rd_kafka_DeleteRecords_t **del_records, size_t del_record_cnt);\nvoid rd_kafka_DeleteRecords(rd_kafka_t *rk, rd_kafka_DeleteRecords_t **del_records, size_t del_record_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_topic_partition_list_t *rd_kafka_DeleteRecords_result_offsets(const rd_kafka_DeleteRecords_result_t *result);\ntypedef struct rd_kafka_ConsumerGroupListing_s rd_kafka_ConsumerGroupListing_t;\ntypedef struct rd_kafka_ListConsumerGroupsResult_s rd_kafka_ListConsumerGroupsResult_t;\nvoid rd_kafka_ListConsumerGroups(rd_kafka_t *rk, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst char *rd_kafka_ConsumerGroupListing_group_id(const rd_kafka_ConsumerGroupListing_t *grplist);\nint rd_kafka_ConsumerGroupListing_is_simple_consumer_group(const rd_kafka_ConsumerGroupListing_t *grplist);\nrd_kafka_consumer_group_state_t rd_kafka_ConsumerGroupListing_state(const rd_kafka_ConsumerGroupListing_t *grplist);\nconst rd_kafka_ConsumerGroupListing_t **rd_kafka_ListConsumerGroups_result_valid(const rd_kafka_ListConsumerGroups_result_t *result, size_t *cntp);\nconst rd_kafka_error_t **rd_kafka_ListConsumerGroups_result_errors(const rd_kafka_ListConsumerGroups_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_ConsumerGroupDescription_s rd_kafka_ConsumerGroupDescription_t;\ntypedef struct rd_kafka_MemberDescription_s rd_kafka_MemberDescription_t;\ntypedef struct rd_kafka_MemberAssignment_s rd_kafka_MemberAssignment_t;\nvoid rd_kafka_DescribeConsumerGroups(rd_kafka_t *rk, const char **groups, size_t groups_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_ConsumerGroupDescription_t **rd_kafka_DescribeConsumerGroups_result_groups(const rd_kafka_DescribeConsumerGroups_result_t *result, size_t *cntp);\nconst char *rd_kafka_ConsumerGroupDescription_group_id(const rd_kafka_ConsumerGroupDescription_t *grpdesc);\nconst rd_kafka_error_t *rd_kafka_ConsumerGroupDescription_error(const rd_kafka_ConsumerGroupDescription_t *grpdesc);\nint rd_kafka_ConsumerGroupDescription_is_simple_consumer_group(const rd_kafka_ConsumerGroupDescription_t *grpdesc);\nconst char *rd_kafka_ConsumerGroupDescription_partition_assignor(const rd_kafka_ConsumerGroupDescription_t *grpdesc);\nrd_kafka_consumer_group_state_t rd_kafka_ConsumerGroupDescription_state(const rd_kafka_ConsumerGroupDescription_t *grpdesc);\nconst rd_kafka_Node_t *rd_kafka_ConsumerGroupDescription_coordinator(const rd_kafka_ConsumerGroupDescription_t *grpdesc);\nsize_t rd_kafka_ConsumerGroupDescription_member_count(const rd_kafka_ConsumerGroupDescription_t *grpdesc);\nconst rd_kafka_MemberDescription_t *rd_kafka_ConsumerGroupDescription_member(const rd_kafka_ConsumerGroupDescription_t *grpdesc, size_t idx);\nconst char *rd_kafka_MemberDescription_client_id(const rd_kafka_MemberDescription_t *member);\nconst char *rd_kafka_MemberDescription_group_instance_id(const rd_kafka_MemberDescription_t *member);\nconst char *rd_kafka_MemberDescription_consumer_id(const rd_kafka_MemberDescription_t *member);\nconst char *rd_kafka_MemberDescription_host(const rd_kafka_MemberDescription_t *member);\nconst rd_kafka_MemberAssignment_t *rd_kafka_MemberDescription_assignment(const rd_kafka_MemberDescription_t *member);\nconst rd_kafka_topic_partition_list_t *rd_kafka_MemberAssignment_partitions(const rd_kafka_MemberAssignment_t *assignment);\ntypedef struct rd_kafka_DeleteGroup_s rd_kafka_DeleteGroup_t;\nrd_kafka_DeleteGroup_t *rd_kafka_DeleteGroup_new(const char *group);\nvoid rd_kafka_DeleteGroup_destroy(rd_kafka_DeleteGroup_t *del_group);\nvoid rd_kafka_DeleteGroup_destroy_array(rd_kafka_DeleteGroup_t **del_groups, size_t del_group_cnt);\nvoid rd_kafka_DeleteGroups(rd_kafka_t *rk, rd_kafka_DeleteGroup_t **del_groups, size_t del_group_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_group_result_t **rd_kafka_DeleteGroups_result_groups(const rd_kafka_DeleteGroups_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_ListConsumerGroupOffsets_s rd_kafka_ListConsumerGroupOffsets_t;\nrd_kafka_ListConsumerGroupOffsets_t *rd_kafka_ListConsumerGroupOffsets_new(const char *group_id, const rd_kafka_topic_partition_list_t *partitions);\nvoid rd_kafka_ListConsumerGroupOffsets_destroy(rd_kafka_ListConsumerGroupOffsets_t *list_grpoffsets);\nvoid rd_kafka_ListConsumerGroupOffsets_destroy_array(rd_kafka_ListConsumerGroupOffsets_t **list_grpoffsets, size_t list_grpoffset_cnt);\nvoid rd_kafka_ListConsumerGroupOffsets(rd_kafka_t *rk, rd_kafka_ListConsumerGroupOffsets_t **list_grpoffsets, size_t list_grpoffsets_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_group_result_t **rd_kafka_ListConsumerGroupOffsets_result_groups(const rd_kafka_ListConsumerGroupOffsets_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_AlterConsumerGroupOffsets_s rd_kafka_AlterConsumerGroupOffsets_t;\nrd_kafka_AlterConsumerGroupOffsets_t *rd_kafka_AlterConsumerGroupOffsets_new(const char *group_id, const rd_kafka_topic_partition_list_t *partitions);\nvoid rd_kafka_AlterConsumerGroupOffsets_destroy(rd_kafka_AlterConsumerGroupOffsets_t *alter_grpoffsets);\nvoid rd_kafka_AlterConsumerGroupOffsets_destroy_array(rd_kafka_AlterConsumerGroupOffsets_t **alter_grpoffsets, size_t alter_grpoffset_cnt);\nvoid rd_kafka_AlterConsumerGroupOffsets(rd_kafka_t *rk, rd_kafka_AlterConsumerGroupOffsets_t **alter_grpoffsets, size_t alter_grpoffsets_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_group_result_t **rd_kafka_AlterConsumerGroupOffsets_result_groups(const rd_kafka_AlterConsumerGroupOffsets_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_DeleteConsumerGroupOffsets_s rd_kafka_DeleteConsumerGroupOffsets_t;\nrd_kafka_DeleteConsumerGroupOffsets_t *rd_kafka_DeleteConsumerGroupOffsets_new(const char *group, const rd_kafka_topic_partition_list_t *partitions);\nvoid rd_kafka_DeleteConsumerGroupOffsets_destroy(rd_kafka_DeleteConsumerGroupOffsets_t *del_grpoffsets);\nvoid rd_kafka_DeleteConsumerGroupOffsets_destroy_array(rd_kafka_DeleteConsumerGroupOffsets_t **del_grpoffsets, size_t del_grpoffset_cnt);\nvoid rd_kafka_DeleteConsumerGroupOffsets(rd_kafka_t *rk, rd_kafka_DeleteConsumerGroupOffsets_t **del_grpoffsets, size_t del_grpoffsets_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_group_result_t **rd_kafka_DeleteConsumerGroupOffsets_result_groups(const rd_kafka_DeleteConsumerGroupOffsets_result_t *result, size_t *cntp);\ntypedef enum rd_kafka_ScramMechanism_t {\n  RD_KAFKA_SCRAM_MECHANISM_UNKNOWN = 0,\n  RD_KAFKA_SCRAM_MECHANISM_SHA_256 = 1,\n  RD_KAFKA_SCRAM_MECHANISM_SHA_512 = 2,\n  RD_KAFKA_SCRAM_MECHANISM__CNT,\n} rd_kafka_ScramMechanism_t;\ntypedef struct rd_kafka_ScramCredentialInfo_s rd_kafka_ScramCredentialInfo_t;\nrd_kafka_ScramMechanism_t rd_kafka_ScramCredentialInfo_mechanism(const rd_kafka_ScramCredentialInfo_t *scram_credential_info);\nint32_t rd_kafka_ScramCredentialInfo_iterations(const rd_kafka_ScramCredentialInfo_t *scram_credential_info);\ntypedef struct rd_kafka_UserScramCredentialsDescription_s rd_kafka_UserScramCredentialsDescription_t;\nconst char *rd_kafka_UserScramCredentialsDescription_user(const rd_kafka_UserScramCredentialsDescription_t *description);\nconst rd_kafka_error_t *rd_kafka_UserScramCredentialsDescription_error(const rd_kafka_UserScramCredentialsDescription_t *description);\nsize_t rd_kafka_UserScramCredentialsDescription_scramcredentialinfo_count(const rd_kafka_UserScramCredentialsDescription_t *description);\nconst rd_kafka_ScramCredentialInfo_t *rd_kafka_UserScramCredentialsDescription_scramcredentialinfo(const rd_kafka_UserScramCredentialsDescription_t *description, size_t idx);\nconst rd_kafka_UserScramCredentialsDescription_t **rd_kafka_DescribeUserScramCredentials_result_descriptions(const rd_kafka_DescribeUserScramCredentials_result_t *result, size_t *cntp);\nvoid rd_kafka_DescribeUserScramCredentials(rd_kafka_t *rk, const char **users, size_t user_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\ntypedef struct rd_kafka_UserScramCredentialAlteration_s rd_kafka_UserScramCredentialAlteration_t;\nrd_kafka_UserScramCredentialAlteration_t *rd_kafka_UserScramCredentialUpsertion_new(const char *username, rd_kafka_ScramMechanism_t mechanism, int32_t iterations, const unsigned char *password, size_t password_size, const unsigned char *salt, size_t salt_size);\nrd_kafka_UserScramCredentialAlteration_t *rd_kafka_UserScramCredentialDeletion_new(const char *username, rd_kafka_ScramMechanism_t mechanism);\nvoid rd_kafka_UserScramCredentialAlteration_destroy(rd_kafka_UserScramCredentialAlteration_t *alteration);\nvoid rd_kafka_UserScramCredentialAlteration_destroy_array(rd_kafka_UserScramCredentialAlteration_t **alterations, size_t alteration_cnt);\ntypedef struct rd_kafka_AlterUserScramCredentials_result_response_s rd_kafka_AlterUserScramCredentials_result_response_t;\nconst char *rd_kafka_AlterUserScramCredentials_result_response_user(const rd_kafka_AlterUserScramCredentials_result_response_t *response);\nconst rd_kafka_error_t *rd_kafka_AlterUserScramCredentials_result_response_error(const rd_kafka_AlterUserScramCredentials_result_response_t *response);\nconst rd_kafka_AlterUserScramCredentials_result_response_t **rd_kafka_AlterUserScramCredentials_result_responses(const rd_kafka_AlterUserScramCredentials_result_t *result, size_t *cntp);\nvoid rd_kafka_AlterUserScramCredentials(rd_kafka_t *rk, rd_kafka_UserScramCredentialAlteration_t **alterations, size_t alteration_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\ntypedef struct rd_kafka_AclBinding_s rd_kafka_AclBinding_t;\ntypedef rd_kafka_AclBinding_t rd_kafka_AclBindingFilter_t;\nconst rd_kafka_error_t *rd_kafka_acl_result_error(const rd_kafka_acl_result_t *aclres);\ntypedef enum rd_kafka_AclOperation_t {\n  RD_KAFKA_ACL_OPERATION_UNKNOWN = 0,\n  RD_KAFKA_ACL_OPERATION_ANY = 1,\n  RD_KAFKA_ACL_OPERATION_ALL = 2,\n  RD_KAFKA_ACL_OPERATION_READ = 3,\n  RD_KAFKA_ACL_OPERATION_WRITE = 4,\n  RD_KAFKA_ACL_OPERATION_CREATE = 5,\n  RD_KAFKA_ACL_OPERATION_DELETE = 6,\n  RD_KAFKA_ACL_OPERATION_ALTER = 7,\n  RD_KAFKA_ACL_OPERATION_DESCRIBE = 8,\n  RD_KAFKA_ACL_OPERATION_CLUSTER_ACTION = 9,\n  RD_KAFKA_ACL_OPERATION_DESCRIBE_CONFIGS = 10,\n  RD_KAFKA_ACL_OPERATION_ALTER_CONFIGS = 11,\n  RD_KAFKA_ACL_OPERATION_IDEMPOTENT_WRITE = 12,\n  RD_KAFKA_ACL_OPERATION__CNT,\n} rd_kafka_AclOperation_t;\nconst char *rd_kafka_AclOperation_name(rd_kafka_AclOperation_t acl_operation);\ntypedef enum rd_kafka_AclPermissionType_t {\n  RD_KAFKA_ACL_PERMISSION_TYPE_UNKNOWN = 0,\n  RD_KAFKA_ACL_PERMISSION_TYPE_ANY = 1,\n  RD_KAFKA_ACL_PERMISSION_TYPE_DENY = 2,\n  RD_KAFKA_ACL_PERMISSION_TYPE_ALLOW = 3,\n  RD_KAFKA_ACL_PERMISSION_TYPE__CNT,\n} rd_kafka_AclPermissionType_t;\nconst char *rd_kafka_AclPermissionType_name(rd_kafka_AclPermissionType_t acl_permission_type);\nrd_kafka_AclBinding_t *rd_kafka_AclBinding_new(rd_kafka_ResourceType_t restype, const char *name, rd_kafka_ResourcePatternType_t resource_pattern_type, const char *principal, const char *host, rd_kafka_AclOperation_t operation, rd_kafka_AclPermissionType_t permission_type, char *errstr, size_t errstr_size);\nrd_kafka_AclBindingFilter_t *rd_kafka_AclBindingFilter_new(rd_kafka_ResourceType_t restype, const char *name, rd_kafka_ResourcePatternType_t resource_pattern_type, const char *principal, const char *host, rd_kafka_AclOperation_t operation, rd_kafka_AclPermissionType_t permission_type, char *errstr, size_t errstr_size);\nrd_kafka_ResourceType_t rd_kafka_AclBinding_restype(const rd_kafka_AclBinding_t *acl);\nconst char *rd_kafka_AclBinding_name(const rd_kafka_AclBinding_t *acl);\nconst char *rd_kafka_AclBinding_principal(const rd_kafka_AclBinding_t *acl);\nconst char *rd_kafka_AclBinding_host(const rd_kafka_AclBinding_t *acl);\nrd_kafka_AclOperation_t rd_kafka_AclBinding_operation(const rd_kafka_AclBinding_t *acl);\nrd_kafka_AclPermissionType_t rd_kafka_AclBinding_permission_type(const rd_kafka_AclBinding_t *acl);\nrd_kafka_ResourcePatternType_t rd_kafka_AclBinding_resource_pattern_type(const rd_kafka_AclBinding_t *acl);\nconst rd_kafka_error_t *rd_kafka_AclBinding_error(const rd_kafka_AclBinding_t *acl);\nvoid rd_kafka_AclBinding_destroy(rd_kafka_AclBinding_t *acl_binding);\nvoid rd_kafka_AclBinding_destroy_array(rd_kafka_AclBinding_t **acl_bindings, size_t acl_bindings_cnt);\nconst rd_kafka_acl_result_t **rd_kafka_CreateAcls_result_acls(const rd_kafka_CreateAcls_result_t *result, size_t *cntp);\nvoid rd_kafka_CreateAcls(rd_kafka_t *rk, rd_kafka_AclBinding_t **new_acls, size_t new_acls_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_AclBinding_t **rd_kafka_DescribeAcls_result_acls(const rd_kafka_DescribeAcls_result_t *result, size_t *cntp);\nvoid rd_kafka_DescribeAcls(rd_kafka_t *rk, rd_kafka_AclBindingFilter_t *acl_filter, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\ntypedef struct rd_kafka_DeleteAcls_result_response_s rd_kafka_DeleteAcls_result_response_t;\nconst rd_kafka_DeleteAcls_result_response_t **rd_kafka_DeleteAcls_result_responses(const rd_kafka_DeleteAcls_result_t *result, size_t *cntp);\nconst rd_kafka_error_t *rd_kafka_DeleteAcls_result_response_error(const rd_kafka_DeleteAcls_result_response_t *result_response);\nconst rd_kafka_AclBinding_t **rd_kafka_DeleteAcls_result_response_matching_acls(const rd_kafka_DeleteAcls_result_response_t *result_response, size_t *matching_acls_cntp);\nvoid rd_kafka_DeleteAcls(rd_kafka_t *rk, rd_kafka_AclBindingFilter_t **del_acls, size_t del_acls_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nrd_kafka_resp_err_t rd_kafka_oauthbearer_set_token(rd_kafka_t *rk, const char *token_value, int64_t md_lifetime_ms, const char *md_principal_name, const char **extensions, size_t extension_size, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_oauthbearer_set_token_failure(rd_kafka_t *rk, const char *errstr);\nrd_kafka_error_t *rd_kafka_init_transactions(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_error_t *rd_kafka_begin_transaction(rd_kafka_t *rk);\nrd_kafka_error_t *rd_kafka_send_offsets_to_transaction(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, const rd_kafka_consumer_group_metadata_t *cgmetadata, int timeout_ms);\nrd_kafka_error_t *rd_kafka_commit_transaction(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_error_t *rd_kafka_abort_transaction(rd_kafka_t *rk, int timeout_ms);\ntypedef struct rd_kafka_mock_cluster_s rd_kafka_mock_cluster_t;\nrd_kafka_mock_cluster_t *rd_kafka_mock_cluster_new(rd_kafka_t *rk, int broker_cnt);\nvoid rd_kafka_mock_cluster_destroy(rd_kafka_mock_cluster_t *mcluster);\nrd_kafka_t *rd_kafka_mock_cluster_handle(const rd_kafka_mock_cluster_t *mcluster);\nrd_kafka_mock_cluster_t *rd_kafka_handle_mock_cluster(const rd_kafka_t *rk);\nconst char *rd_kafka_mock_cluster_bootstraps(const rd_kafka_mock_cluster_t *mcluster);\nvoid rd_kafka_mock_clear_request_errors(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey);\nvoid rd_kafka_mock_push_request_errors(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, size_t cnt, ...);\nvoid rd_kafka_mock_push_request_errors_array(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, size_t cnt, const rd_kafka_resp_err_t *errors);\nrd_kafka_resp_err_t rd_kafka_mock_broker_push_request_error_rtts(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int16_t ApiKey, size_t cnt, ...);\nrd_kafka_resp_err_t rd_kafka_mock_broker_error_stack_cnt(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int16_t ApiKey, size_t *cntp);\nvoid rd_kafka_mock_topic_set_error(rd_kafka_mock_cluster_t *mcluster, const char *topic, rd_kafka_resp_err_t err);\nrd_kafka_resp_err_t rd_kafka_mock_topic_create(rd_kafka_mock_cluster_t *mcluster, const char *topic, int partition_cnt, int replication_factor);\nrd_kafka_resp_err_t rd_kafka_mock_partition_set_leader(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id);\nrd_kafka_resp_err_t rd_kafka_mock_partition_set_follower(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id);\nrd_kafka_resp_err_t rd_kafka_mock_partition_set_follower_wmarks(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int64_t lo, int64_t hi);\nrd_kafka_resp_err_t rd_kafka_mock_broker_set_down(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id);\nrd_kafka_resp_err_t rd_kafka_mock_broker_set_up(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id);\nrd_kafka_resp_err_t rd_kafka_mock_broker_set_rtt(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int rtt_ms);\nrd_kafka_resp_err_t rd_kafka_mock_broker_set_rack(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, const char *rack);\nrd_kafka_resp_err_t rd_kafka_mock_coordinator_set(rd_kafka_mock_cluster_t *mcluster, const char *key_type, const char *key, int32_t broker_id);\nrd_kafka_resp_err_t rd_kafka_mock_set_apiversion(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, int16_t MinVersion, int16_t MaxVersion);\n'\n</code></pre> rdkafka.h, rdkafka_mock.h</p>"},{"location":"api/constants/#rd_kafka_version_29","title":"RD_KAFKA_VERSION","text":"<pre><code>public RD_KAFKA_VERSION = 33751295\n</code></pre> <p>librdkafka version </p> <p>Interpreted as hex <code>MM.mm.rr.xx</code>:</p> <ul> <li>MM = Major</li> <li>mm = minor</li> <li>rr = revision</li> <li>xx = pre-release id (0xff is the final release)</li> </ul> <p>E.g.: <code>0x000801ff</code> = 0.8.1</p> RemarksThis value should only be used during compile time, for runtime checks of version use rd_kafka_version()  <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_unsupported_compression_type_29","title":"RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE","text":"<pre><code>public RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76\n</code></pre> <p>Unsupported compression type </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_end_all_29","title":"RD_KAFKA_RESP_ERR_END_ALL","text":"<p><pre><code>public RD_KAFKA_RESP_ERR_END_ALL = 98\n</code></pre> enum rd_kafka_resp_err_t</p>"},{"location":"api/constants/#rd_kafka_admin_op__cnt_29","title":"RD_KAFKA_ADMIN_OP__CNT","text":"<pre><code>public RD_KAFKA_ADMIN_OP__CNT = 22\n</code></pre> <p>Number of ops defined </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe </li> </ul>"},{"location":"api/constants/#rd_kafka_resource__cnt_29","title":"RD_KAFKA_RESOURCE__CNT","text":"<pre><code>public RD_KAFKA_RESOURCE__CNT = 5\n</code></pre> <p>Number of resource types defined </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#acca83a66d7783ff7683ed2691cc907c9 </li> </ul>"},{"location":"api/constants/#rd_kafka_cdef_29","title":"RD_KAFKA_CDEF","text":"<p><pre><code>public RD_KAFKA_CDEF = 'typedef long int ssize_t;\ntypedef struct _IO_FILE FILE;\ntypedef long int mode_t;\ntypedef signed int int16_t;\ntypedef unsigned int uint16_t;\ntypedef signed int int32_t;\ntypedef signed long int int64_t;\nint rd_kafka_version(void);\nconst char *rd_kafka_version_str(void);\ntypedef enum rd_kafka_type_t {\n  RD_KAFKA_PRODUCER,\n  RD_KAFKA_CONSUMER,\n} rd_kafka_type_t;\ntypedef enum rd_kafka_timestamp_type_t {\n  RD_KAFKA_TIMESTAMP_NOT_AVAILABLE,\n  RD_KAFKA_TIMESTAMP_CREATE_TIME,\n  RD_KAFKA_TIMESTAMP_LOG_APPEND_TIME,\n} rd_kafka_timestamp_type_t;\nconst char *rd_kafka_get_debug_contexts(void);\ntypedef struct rd_kafka_s rd_kafka_t;\ntypedef struct rd_kafka_topic_s rd_kafka_topic_t;\ntypedef struct rd_kafka_conf_s rd_kafka_conf_t;\ntypedef struct rd_kafka_topic_conf_s rd_kafka_topic_conf_t;\ntypedef struct rd_kafka_queue_s rd_kafka_queue_t;\ntypedef struct rd_kafka_op_s rd_kafka_event_t;\ntypedef struct rd_kafka_topic_result_s rd_kafka_topic_result_t;\ntypedef struct rd_kafka_consumer_group_metadata_s rd_kafka_consumer_group_metadata_t;\ntypedef struct rd_kafka_error_s {\n  unsigned int code;\n  char *errstr;\n  unsigned char fatal;\n  unsigned char retriable;\n  unsigned char txn_requires_abort;\n} rd_kafka_error_t;\ntypedef struct rd_kafka_headers_s rd_kafka_headers_t;\ntypedef struct rd_kafka_group_result_s rd_kafka_group_result_t;\ntypedef struct rd_kafka_acl_result_s rd_kafka_acl_result_t;\ntypedef struct rd_kafka_Uuid_s rd_kafka_Uuid_t;\ntypedef enum {\n  RD_KAFKA_RESP_ERR__BEGIN = (- 200),\n  RD_KAFKA_RESP_ERR__BAD_MSG = (- 199),\n  RD_KAFKA_RESP_ERR__BAD_COMPRESSION = (- 198),\n  RD_KAFKA_RESP_ERR__DESTROY = (- 197),\n  RD_KAFKA_RESP_ERR__FAIL = (- 196),\n  RD_KAFKA_RESP_ERR__TRANSPORT = (- 195),\n  RD_KAFKA_RESP_ERR__CRIT_SYS_RESOURCE = (- 194),\n  RD_KAFKA_RESP_ERR__RESOLVE = (- 193),\n  RD_KAFKA_RESP_ERR__MSG_TIMED_OUT = (- 192),\n  RD_KAFKA_RESP_ERR__PARTITION_EOF = (- 191),\n  RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION = (- 190),\n  RD_KAFKA_RESP_ERR__FS = (- 189),\n  RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC = (- 188),\n  RD_KAFKA_RESP_ERR__ALL_BROKERS_DOWN = (- 187),\n  RD_KAFKA_RESP_ERR__INVALID_ARG = (- 186),\n  RD_KAFKA_RESP_ERR__TIMED_OUT = (- 185),\n  RD_KAFKA_RESP_ERR__QUEUE_FULL = (- 184),\n  RD_KAFKA_RESP_ERR__ISR_INSUFF = (- 183),\n  RD_KAFKA_RESP_ERR__NODE_UPDATE = (- 182),\n  RD_KAFKA_RESP_ERR__SSL = (- 181),\n  RD_KAFKA_RESP_ERR__WAIT_COORD = (- 180),\n  RD_KAFKA_RESP_ERR__UNKNOWN_GROUP = (- 179),\n  RD_KAFKA_RESP_ERR__IN_PROGRESS = (- 178),\n  RD_KAFKA_RESP_ERR__PREV_IN_PROGRESS = (- 177),\n  RD_KAFKA_RESP_ERR__EXISTING_SUBSCRIPTION = (- 176),\n  RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS = (- 175),\n  RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS = (- 174),\n  RD_KAFKA_RESP_ERR__CONFLICT = (- 173),\n  RD_KAFKA_RESP_ERR__STATE = (- 172),\n  RD_KAFKA_RESP_ERR__UNKNOWN_PROTOCOL = (- 171),\n  RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED = (- 170),\n  RD_KAFKA_RESP_ERR__AUTHENTICATION = (- 169),\n  RD_KAFKA_RESP_ERR__NO_OFFSET = (- 168),\n  RD_KAFKA_RESP_ERR__OUTDATED = (- 167),\n  RD_KAFKA_RESP_ERR__TIMED_OUT_QUEUE = (- 166),\n  RD_KAFKA_RESP_ERR__UNSUPPORTED_FEATURE = (- 165),\n  RD_KAFKA_RESP_ERR__WAIT_CACHE = (- 164),\n  RD_KAFKA_RESP_ERR__INTR = (- 163),\n  RD_KAFKA_RESP_ERR__KEY_SERIALIZATION = (- 162),\n  RD_KAFKA_RESP_ERR__VALUE_SERIALIZATION = (- 161),\n  RD_KAFKA_RESP_ERR__KEY_DESERIALIZATION = (- 160),\n  RD_KAFKA_RESP_ERR__VALUE_DESERIALIZATION = (- 159),\n  RD_KAFKA_RESP_ERR__PARTIAL = (- 158),\n  RD_KAFKA_RESP_ERR__READ_ONLY = (- 157),\n  RD_KAFKA_RESP_ERR__NOENT = (- 156),\n  RD_KAFKA_RESP_ERR__UNDERFLOW = (- 155),\n  RD_KAFKA_RESP_ERR__INVALID_TYPE = (- 154),\n  RD_KAFKA_RESP_ERR__RETRY = (- 153),\n  RD_KAFKA_RESP_ERR__PURGE_QUEUE = (- 152),\n  RD_KAFKA_RESP_ERR__PURGE_INFLIGHT = (- 151),\n  RD_KAFKA_RESP_ERR__FATAL = (- 150),\n  RD_KAFKA_RESP_ERR__INCONSISTENT = (- 149),\n  RD_KAFKA_RESP_ERR__GAPLESS_GUARANTEE = (- 148),\n  RD_KAFKA_RESP_ERR__MAX_POLL_EXCEEDED = (- 147),\n  RD_KAFKA_RESP_ERR__UNKNOWN_BROKER = (- 146),\n  RD_KAFKA_RESP_ERR__NOT_CONFIGURED = (- 145),\n  RD_KAFKA_RESP_ERR__FENCED = (- 144),\n  RD_KAFKA_RESP_ERR__APPLICATION = (- 143),\n  RD_KAFKA_RESP_ERR__ASSIGNMENT_LOST = (- 142),\n  RD_KAFKA_RESP_ERR__NOOP = (- 141),\n  RD_KAFKA_RESP_ERR__AUTO_OFFSET_RESET = (- 140),\n  RD_KAFKA_RESP_ERR__LOG_TRUNCATION = (- 139),\n  RD_KAFKA_RESP_ERR__END = (- 100),\n  RD_KAFKA_RESP_ERR_UNKNOWN = (- 1),\n  RD_KAFKA_RESP_ERR_NO_ERROR = 0,\n  RD_KAFKA_RESP_ERR_OFFSET_OUT_OF_RANGE = 1,\n  RD_KAFKA_RESP_ERR_INVALID_MSG = 2,\n  RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART = 3,\n  RD_KAFKA_RESP_ERR_INVALID_MSG_SIZE = 4,\n  RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE = 5,\n  RD_KAFKA_RESP_ERR_NOT_LEADER_FOR_PARTITION = 6,\n  RD_KAFKA_RESP_ERR_REQUEST_TIMED_OUT = 7,\n  RD_KAFKA_RESP_ERR_BROKER_NOT_AVAILABLE = 8,\n  RD_KAFKA_RESP_ERR_REPLICA_NOT_AVAILABLE = 9,\n  RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE = 10,\n  RD_KAFKA_RESP_ERR_STALE_CTRL_EPOCH = 11,\n  RD_KAFKA_RESP_ERR_OFFSET_METADATA_TOO_LARGE = 12,\n  RD_KAFKA_RESP_ERR_NETWORK_EXCEPTION = 13,\n  RD_KAFKA_RESP_ERR_COORDINATOR_LOAD_IN_PROGRESS = 14,\n  RD_KAFKA_RESP_ERR_COORDINATOR_NOT_AVAILABLE = 15,\n  RD_KAFKA_RESP_ERR_NOT_COORDINATOR = 16,\n  RD_KAFKA_RESP_ERR_TOPIC_EXCEPTION = 17,\n  RD_KAFKA_RESP_ERR_RECORD_LIST_TOO_LARGE = 18,\n  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS = 19,\n  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS_AFTER_APPEND = 20,\n  RD_KAFKA_RESP_ERR_INVALID_REQUIRED_ACKS = 21,\n  RD_KAFKA_RESP_ERR_ILLEGAL_GENERATION = 22,\n  RD_KAFKA_RESP_ERR_INCONSISTENT_GROUP_PROTOCOL = 23,\n  RD_KAFKA_RESP_ERR_INVALID_GROUP_ID = 24,\n  RD_KAFKA_RESP_ERR_UNKNOWN_MEMBER_ID = 25,\n  RD_KAFKA_RESP_ERR_INVALID_SESSION_TIMEOUT = 26,\n  RD_KAFKA_RESP_ERR_REBALANCE_IN_PROGRESS = 27,\n  RD_KAFKA_RESP_ERR_INVALID_COMMIT_OFFSET_SIZE = 28,\n  RD_KAFKA_RESP_ERR_TOPIC_AUTHORIZATION_FAILED = 29,\n  RD_KAFKA_RESP_ERR_GROUP_AUTHORIZATION_FAILED = 30,\n  RD_KAFKA_RESP_ERR_CLUSTER_AUTHORIZATION_FAILED = 31,\n  RD_KAFKA_RESP_ERR_INVALID_TIMESTAMP = 32,\n  RD_KAFKA_RESP_ERR_UNSUPPORTED_SASL_MECHANISM = 33,\n  RD_KAFKA_RESP_ERR_ILLEGAL_SASL_STATE = 34,\n  RD_KAFKA_RESP_ERR_UNSUPPORTED_VERSION = 35,\n  RD_KAFKA_RESP_ERR_TOPIC_ALREADY_EXISTS = 36,\n  RD_KAFKA_RESP_ERR_INVALID_PARTITIONS = 37,\n  RD_KAFKA_RESP_ERR_INVALID_REPLICATION_FACTOR = 38,\n  RD_KAFKA_RESP_ERR_INVALID_REPLICA_ASSIGNMENT = 39,\n  RD_KAFKA_RESP_ERR_INVALID_CONFIG = 40,\n  RD_KAFKA_RESP_ERR_NOT_CONTROLLER = 41,\n  RD_KAFKA_RESP_ERR_INVALID_REQUEST = 42,\n  RD_KAFKA_RESP_ERR_UNSUPPORTED_FOR_MESSAGE_FORMAT = 43,\n  RD_KAFKA_RESP_ERR_POLICY_VIOLATION = 44,\n  RD_KAFKA_RESP_ERR_OUT_OF_ORDER_SEQUENCE_NUMBER = 45,\n  RD_KAFKA_RESP_ERR_DUPLICATE_SEQUENCE_NUMBER = 46,\n  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_EPOCH = 47,\n  RD_KAFKA_RESP_ERR_INVALID_TXN_STATE = 48,\n  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_ID_MAPPING = 49,\n  RD_KAFKA_RESP_ERR_INVALID_TRANSACTION_TIMEOUT = 50,\n  RD_KAFKA_RESP_ERR_CONCURRENT_TRANSACTIONS = 51,\n  RD_KAFKA_RESP_ERR_TRANSACTION_COORDINATOR_FENCED = 52,\n  RD_KAFKA_RESP_ERR_TRANSACTIONAL_ID_AUTHORIZATION_FAILED = 53,\n  RD_KAFKA_RESP_ERR_SECURITY_DISABLED = 54,\n  RD_KAFKA_RESP_ERR_OPERATION_NOT_ATTEMPTED = 55,\n  RD_KAFKA_RESP_ERR_KAFKA_STORAGE_ERROR = 56,\n  RD_KAFKA_RESP_ERR_LOG_DIR_NOT_FOUND = 57,\n  RD_KAFKA_RESP_ERR_SASL_AUTHENTICATION_FAILED = 58,\n  RD_KAFKA_RESP_ERR_UNKNOWN_PRODUCER_ID = 59,\n  RD_KAFKA_RESP_ERR_REASSIGNMENT_IN_PROGRESS = 60,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTH_DISABLED = 61,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_NOT_FOUND = 62,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_OWNER_MISMATCH = 63,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_REQUEST_NOT_ALLOWED = 64,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTHORIZATION_FAILED = 65,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_EXPIRED = 66,\n  RD_KAFKA_RESP_ERR_INVALID_PRINCIPAL_TYPE = 67,\n  RD_KAFKA_RESP_ERR_NON_EMPTY_GROUP = 68,\n  RD_KAFKA_RESP_ERR_GROUP_ID_NOT_FOUND = 69,\n  RD_KAFKA_RESP_ERR_FETCH_SESSION_ID_NOT_FOUND = 70,\n  RD_KAFKA_RESP_ERR_INVALID_FETCH_SESSION_EPOCH = 71,\n  RD_KAFKA_RESP_ERR_LISTENER_NOT_FOUND = 72,\n  RD_KAFKA_RESP_ERR_TOPIC_DELETION_DISABLED = 73,\n  RD_KAFKA_RESP_ERR_FENCED_LEADER_EPOCH = 74,\n  RD_KAFKA_RESP_ERR_UNKNOWN_LEADER_EPOCH = 75,\n  RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76,\n  RD_KAFKA_RESP_ERR_STALE_BROKER_EPOCH = 77,\n  RD_KAFKA_RESP_ERR_OFFSET_NOT_AVAILABLE = 78,\n  RD_KAFKA_RESP_ERR_MEMBER_ID_REQUIRED = 79,\n  RD_KAFKA_RESP_ERR_PREFERRED_LEADER_NOT_AVAILABLE = 80,\n  RD_KAFKA_RESP_ERR_GROUP_MAX_SIZE_REACHED = 81,\n  RD_KAFKA_RESP_ERR_FENCED_INSTANCE_ID = 82,\n  RD_KAFKA_RESP_ERR_ELIGIBLE_LEADERS_NOT_AVAILABLE = 83,\n  RD_KAFKA_RESP_ERR_ELECTION_NOT_NEEDED = 84,\n  RD_KAFKA_RESP_ERR_NO_REASSIGNMENT_IN_PROGRESS = 85,\n  RD_KAFKA_RESP_ERR_GROUP_SUBSCRIBED_TO_TOPIC = 86,\n  RD_KAFKA_RESP_ERR_INVALID_RECORD = 87,\n  RD_KAFKA_RESP_ERR_UNSTABLE_OFFSET_COMMIT = 88,\n  RD_KAFKA_RESP_ERR_THROTTLING_QUOTA_EXCEEDED = 89,\n  RD_KAFKA_RESP_ERR_PRODUCER_FENCED = 90,\n  RD_KAFKA_RESP_ERR_RESOURCE_NOT_FOUND = 91,\n  RD_KAFKA_RESP_ERR_DUPLICATE_RESOURCE = 92,\n  RD_KAFKA_RESP_ERR_UNACCEPTABLE_CREDENTIAL = 93,\n  RD_KAFKA_RESP_ERR_INCONSISTENT_VOTER_SET = 94,\n  RD_KAFKA_RESP_ERR_INVALID_UPDATE_VERSION = 95,\n  RD_KAFKA_RESP_ERR_FEATURE_UPDATE_FAILED = 96,\n  RD_KAFKA_RESP_ERR_PRINCIPAL_DESERIALIZATION_FAILURE = 97,\n  RD_KAFKA_RESP_ERR_END_ALL,\n} rd_kafka_resp_err_t;\nstruct rd_kafka_err_desc {\n  rd_kafka_resp_err_t code;\n  char *name;\n  char *desc;\n};\nvoid rd_kafka_get_err_descs(const struct rd_kafka_err_desc **errdescs, size_t *cntp);\nconst char *rd_kafka_err2str(rd_kafka_resp_err_t err);\nconst char *rd_kafka_err2name(rd_kafka_resp_err_t err);\nrd_kafka_resp_err_t rd_kafka_last_error(void);\nrd_kafka_resp_err_t rd_kafka_errno2err(int errnox);\nint rd_kafka_errno(void);\nrd_kafka_resp_err_t rd_kafka_fatal_error(rd_kafka_t *rk, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_test_fatal_error(rd_kafka_t *rk, rd_kafka_resp_err_t err, const char *reason);\nrd_kafka_resp_err_t rd_kafka_error_code(const rd_kafka_error_t *error);\nconst char *rd_kafka_error_name(const rd_kafka_error_t *error);\nconst char *rd_kafka_error_string(const rd_kafka_error_t *error);\nint rd_kafka_error_is_fatal(const rd_kafka_error_t *error);\nint rd_kafka_error_is_retriable(const rd_kafka_error_t *error);\nint rd_kafka_error_txn_requires_abort(const rd_kafka_error_t *error);\nvoid rd_kafka_error_destroy(rd_kafka_error_t *error);\nrd_kafka_error_t *rd_kafka_error_new(rd_kafka_resp_err_t code, const char *fmt, ...);\ntypedef struct rd_kafka_topic_partition_s {\n  char *topic;\n  int32_t partition;\n  int64_t offset;\n  void *metadata;\n  size_t metadata_size;\n  void *opaque;\n  rd_kafka_resp_err_t err;\n  void *_private;\n} rd_kafka_topic_partition_t;\nvoid rd_kafka_topic_partition_destroy(rd_kafka_topic_partition_t *rktpar);\nvoid rd_kafka_topic_partition_set_leader_epoch(rd_kafka_topic_partition_t *rktpar, int32_t leader_epoch);\nint32_t rd_kafka_topic_partition_get_leader_epoch(const rd_kafka_topic_partition_t *rktpar);\ntypedef struct rd_kafka_topic_partition_list_s {\n  int cnt;\n  int size;\n  rd_kafka_topic_partition_t *elems;\n} rd_kafka_topic_partition_list_t;\nrd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_new(int size);\nvoid rd_kafka_topic_partition_list_destroy(rd_kafka_topic_partition_list_t *rkparlist);\nrd_kafka_topic_partition_t *rd_kafka_topic_partition_list_add(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);\nvoid rd_kafka_topic_partition_list_add_range(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t start, int32_t stop);\nint rd_kafka_topic_partition_list_del(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);\nint rd_kafka_topic_partition_list_del_by_idx(rd_kafka_topic_partition_list_t *rktparlist, int idx);\nrd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_copy(const rd_kafka_topic_partition_list_t *src);\nrd_kafka_resp_err_t rd_kafka_topic_partition_list_set_offset(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition, int64_t offset);\nrd_kafka_topic_partition_t *rd_kafka_topic_partition_list_find(const rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);\nvoid rd_kafka_topic_partition_list_sort(rd_kafka_topic_partition_list_t *rktparlist, int (*cmp)(const void *a, const void *b, void *cmp_opaque), void *cmp_opaque);\ntypedef enum rd_kafka_vtype_t {\n  RD_KAFKA_VTYPE_END,\n  RD_KAFKA_VTYPE_TOPIC,\n  RD_KAFKA_VTYPE_RKT,\n  RD_KAFKA_VTYPE_PARTITION,\n  RD_KAFKA_VTYPE_VALUE,\n  RD_KAFKA_VTYPE_KEY,\n  RD_KAFKA_VTYPE_OPAQUE,\n  RD_KAFKA_VTYPE_MSGFLAGS,\n  RD_KAFKA_VTYPE_TIMESTAMP,\n  RD_KAFKA_VTYPE_HEADER,\n  RD_KAFKA_VTYPE_HEADERS,\n} rd_kafka_vtype_t;\ntypedef struct rd_kafka_vu_s {\n  rd_kafka_vtype_t vtype;\n  union {\n    char *cstr;\n    rd_kafka_topic_t *rkt;\n    int i;\n    int32_t i32;\n    int64_t i64;\n    struct {\n      void *ptr;\n      size_t size;\n    } mem;\n    struct {\n      char *name;\n      void *val;\n      ssize_t size;\n    } header;\n    rd_kafka_headers_t *headers;\n    void *ptr;\n    char _pad[64];\n  } u;\n} rd_kafka_vu_t;\nrd_kafka_headers_t *rd_kafka_headers_new(size_t initial_count);\nvoid rd_kafka_headers_destroy(rd_kafka_headers_t *hdrs);\nrd_kafka_headers_t *rd_kafka_headers_copy(const rd_kafka_headers_t *src);\nrd_kafka_resp_err_t rd_kafka_header_add(rd_kafka_headers_t *hdrs, const char *name, ssize_t name_size, const void *value, ssize_t value_size);\nrd_kafka_resp_err_t rd_kafka_header_remove(rd_kafka_headers_t *hdrs, const char *name);\nrd_kafka_resp_err_t rd_kafka_header_get_last(const rd_kafka_headers_t *hdrs, const char *name, const void **valuep, size_t *sizep);\nrd_kafka_resp_err_t rd_kafka_header_get(const rd_kafka_headers_t *hdrs, size_t idx, const char *name, const void **valuep, size_t *sizep);\nrd_kafka_resp_err_t rd_kafka_header_get_all(const rd_kafka_headers_t *hdrs, size_t idx, const char **namep, const void **valuep, size_t *sizep);\ntypedef struct rd_kafka_message_s {\n  rd_kafka_resp_err_t err;\n  rd_kafka_topic_t *rkt;\n  int32_t partition;\n  void *payload;\n  size_t len;\n  void *key;\n  size_t key_len;\n  int64_t offset;\n  void *_private;\n} rd_kafka_message_t;\nvoid rd_kafka_message_destroy(rd_kafka_message_t *rkmessage);\nconst char *rd_kafka_message_errstr(const rd_kafka_message_t *rkmessage);\nint64_t rd_kafka_message_timestamp(const rd_kafka_message_t *rkmessage, rd_kafka_timestamp_type_t *tstype);\nint64_t rd_kafka_message_latency(const rd_kafka_message_t *rkmessage);\nint32_t rd_kafka_message_broker_id(const rd_kafka_message_t *rkmessage);\nrd_kafka_resp_err_t rd_kafka_message_headers(const rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);\nrd_kafka_resp_err_t rd_kafka_message_detach_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);\nvoid rd_kafka_message_set_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t *hdrs);\nsize_t rd_kafka_header_cnt(const rd_kafka_headers_t *hdrs);\ntypedef enum {\n  RD_KAFKA_MSG_STATUS_NOT_PERSISTED = 0,\n  RD_KAFKA_MSG_STATUS_POSSIBLY_PERSISTED = 1,\n  RD_KAFKA_MSG_STATUS_PERSISTED = 2,\n} rd_kafka_msg_status_t;\nrd_kafka_msg_status_t rd_kafka_message_status(const rd_kafka_message_t *rkmessage);\nint32_t rd_kafka_message_leader_epoch(const rd_kafka_message_t *rkmessage);\nconst char *rd_kafka_Uuid_base64str(const rd_kafka_Uuid_t *uuid);\nint64_t rd_kafka_Uuid_least_significant_bits(const rd_kafka_Uuid_t *uuid);\nint64_t rd_kafka_Uuid_most_significant_bits(const rd_kafka_Uuid_t *uuid);\nrd_kafka_Uuid_t *rd_kafka_Uuid_new(int64_t most_significant_bits, int64_t least_significant_bits);\nrd_kafka_Uuid_t *rd_kafka_Uuid_copy(const rd_kafka_Uuid_t *uuid);\nvoid rd_kafka_Uuid_destroy(rd_kafka_Uuid_t *uuid);\ntypedef enum {\n  RD_KAFKA_CONF_UNKNOWN = (- 2),\n  RD_KAFKA_CONF_INVALID = (- 1),\n  RD_KAFKA_CONF_OK = 0,\n} rd_kafka_conf_res_t;\nrd_kafka_conf_t *rd_kafka_conf_new(void);\nvoid rd_kafka_conf_destroy(rd_kafka_conf_t *conf);\nrd_kafka_conf_t *rd_kafka_conf_dup(const rd_kafka_conf_t *conf);\nrd_kafka_conf_t *rd_kafka_conf_dup_filter(const rd_kafka_conf_t *conf, size_t filter_cnt, const char **filter);\nconst rd_kafka_conf_t *rd_kafka_conf(rd_kafka_t *rk);\nrd_kafka_conf_res_t rd_kafka_conf_set(rd_kafka_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);\nvoid rd_kafka_conf_set_events(rd_kafka_conf_t *conf, int events);\nvoid rd_kafka_conf_set_background_event_cb(rd_kafka_conf_t *conf, void (*event_cb)(rd_kafka_t *rk, rd_kafka_event_t *rkev, void *opaque));\nvoid rd_kafka_conf_set_dr_cb(rd_kafka_conf_t *conf, void (*dr_cb)(rd_kafka_t *rk, void *payload, size_t len, rd_kafka_resp_err_t err, void *opaque, void *msg_opaque));\nvoid rd_kafka_conf_set_dr_msg_cb(rd_kafka_conf_t *conf, void (*dr_msg_cb)(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, void *opaque));\nvoid rd_kafka_conf_set_consume_cb(rd_kafka_conf_t *conf, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *opaque));\nvoid rd_kafka_conf_set_rebalance_cb(rd_kafka_conf_t *conf, void (*rebalance_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *partitions, void *opaque));\nvoid rd_kafka_conf_set_offset_commit_cb(rd_kafka_conf_t *conf, void (*offset_commit_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *opaque));\nvoid rd_kafka_conf_set_error_cb(rd_kafka_conf_t *conf, void (*error_cb)(rd_kafka_t *rk, int err, const char *reason, void *opaque));\nvoid rd_kafka_conf_set_throttle_cb(rd_kafka_conf_t *conf, void (*throttle_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int throttle_time_ms, void *opaque));\nvoid rd_kafka_conf_set_log_cb(rd_kafka_conf_t *conf, void (*log_cb)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));\nvoid rd_kafka_conf_set_stats_cb(rd_kafka_conf_t *conf, int (*stats_cb)(rd_kafka_t *rk, char *json, size_t json_len, void *opaque));\nvoid rd_kafka_conf_set_oauthbearer_token_refresh_cb(rd_kafka_conf_t *conf, void (*oauthbearer_token_refresh_cb)(rd_kafka_t *rk, const char *oauthbearer_config, void *opaque));\nvoid rd_kafka_conf_enable_sasl_queue(rd_kafka_conf_t *conf, int enable);\nvoid rd_kafka_conf_set_socket_cb(rd_kafka_conf_t *conf, int (*socket_cb)(int domain, int type, int protocol, void *opaque));\nvoid rd_kafka_conf_set_connect_cb(rd_kafka_conf_t *conf, int (*connect_cb)(int sockfd, const struct sockaddr *addr, int addrlen, const char *id, void *opaque));\nvoid rd_kafka_conf_set_closesocket_cb(rd_kafka_conf_t *conf, int (*closesocket_cb)(int sockfd, void *opaque));\nstruct addrinfo;\nvoid rd_kafka_conf_set_resolve_cb(rd_kafka_conf_t *conf, int (*resolve_cb)(const char *node, const char *service, const struct addrinfo *hints, struct addrinfo **res, void *opaque));\nrd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert_verify_cb(rd_kafka_conf_t *conf, int (*ssl_cert_verify_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int *x509_error, int depth, const char *buf, size_t size, char *errstr, size_t errstr_size, void *opaque));\ntypedef enum rd_kafka_cert_type_t {\n  RD_KAFKA_CERT_PUBLIC_KEY,\n  RD_KAFKA_CERT_PRIVATE_KEY,\n  RD_KAFKA_CERT_CA,\n  RD_KAFKA_CERT__CNT,\n} rd_kafka_cert_type_t;\ntypedef enum rd_kafka_cert_enc_t {\n  RD_KAFKA_CERT_ENC_PKCS12,\n  RD_KAFKA_CERT_ENC_DER,\n  RD_KAFKA_CERT_ENC_PEM,\n  RD_KAFKA_CERT_ENC__CNT,\n} rd_kafka_cert_enc_t;\nrd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert(rd_kafka_conf_t *conf, rd_kafka_cert_type_t cert_type, rd_kafka_cert_enc_t cert_enc, const void *buffer, size_t size, char *errstr, size_t errstr_size);\nvoid rd_kafka_conf_set_engine_callback_data(rd_kafka_conf_t *conf, void *callback_data);\nvoid rd_kafka_conf_set_opaque(rd_kafka_conf_t *conf, void *opaque);\nvoid *rd_kafka_opaque(const rd_kafka_t *rk);\nvoid rd_kafka_conf_set_default_topic_conf(rd_kafka_conf_t *conf, rd_kafka_topic_conf_t *tconf);\nrd_kafka_topic_conf_t *rd_kafka_conf_get_default_topic_conf(rd_kafka_conf_t *conf);\nrd_kafka_conf_res_t rd_kafka_conf_get(const rd_kafka_conf_t *conf, const char *name, char *dest, size_t *dest_size);\nrd_kafka_conf_res_t rd_kafka_topic_conf_get(const rd_kafka_topic_conf_t *conf, const char *name, char *dest, size_t *dest_size);\nconst char **rd_kafka_conf_dump(rd_kafka_conf_t *conf, size_t *cntp);\nconst char **rd_kafka_topic_conf_dump(rd_kafka_topic_conf_t *conf, size_t *cntp);\nvoid rd_kafka_conf_dump_free(const char **arr, size_t cnt);\nvoid rd_kafka_conf_properties_show(FILE *fp);\nrd_kafka_topic_conf_t *rd_kafka_topic_conf_new(void);\nrd_kafka_topic_conf_t *rd_kafka_topic_conf_dup(const rd_kafka_topic_conf_t *conf);\nrd_kafka_topic_conf_t *rd_kafka_default_topic_conf_dup(rd_kafka_t *rk);\nvoid rd_kafka_topic_conf_destroy(rd_kafka_topic_conf_t *topic_conf);\nrd_kafka_conf_res_t rd_kafka_topic_conf_set(rd_kafka_topic_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);\nvoid rd_kafka_topic_conf_set_opaque(rd_kafka_topic_conf_t *conf, void *rkt_opaque);\nvoid rd_kafka_topic_conf_set_partitioner_cb(rd_kafka_topic_conf_t *topic_conf, int32_t (*partitioner)(const rd_kafka_topic_t *rkt, const void *keydata, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque));\nvoid rd_kafka_topic_conf_set_msg_order_cmp(rd_kafka_topic_conf_t *topic_conf, int (*msg_order_cmp)(const rd_kafka_message_t *a, const rd_kafka_message_t *b));\nint rd_kafka_topic_partition_available(const rd_kafka_topic_t *rkt, int32_t partition);\nint32_t rd_kafka_msg_partitioner_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_consistent(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_consistent_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_murmur2(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_murmur2_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_fnv1a(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_fnv1a_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nrd_kafka_t *rd_kafka_new(rd_kafka_type_t type, rd_kafka_conf_t *conf, char *errstr, size_t errstr_size);\nvoid rd_kafka_destroy(rd_kafka_t *rk);\nvoid rd_kafka_destroy_flags(rd_kafka_t *rk, int flags);\nconst char *rd_kafka_name(const rd_kafka_t *rk);\nrd_kafka_type_t rd_kafka_type(const rd_kafka_t *rk);\nchar *rd_kafka_memberid(const rd_kafka_t *rk);\nchar *rd_kafka_clusterid(rd_kafka_t *rk, int timeout_ms);\nint32_t rd_kafka_controllerid(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_topic_t *rd_kafka_topic_new(rd_kafka_t *rk, const char *topic, rd_kafka_topic_conf_t *conf);\nvoid rd_kafka_topic_destroy(rd_kafka_topic_t *rkt);\nconst char *rd_kafka_topic_name(const rd_kafka_topic_t *rkt);\nvoid *rd_kafka_topic_opaque(const rd_kafka_topic_t *rkt);\nint rd_kafka_poll(rd_kafka_t *rk, int timeout_ms);\nvoid rd_kafka_yield(rd_kafka_t *rk);\nrd_kafka_resp_err_t rd_kafka_pause_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_resp_err_t rd_kafka_resume_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_resp_err_t rd_kafka_query_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high, int timeout_ms);\nrd_kafka_resp_err_t rd_kafka_get_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high);\nrd_kafka_resp_err_t rd_kafka_offsets_for_times(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets, int timeout_ms);\nvoid *rd_kafka_mem_calloc(rd_kafka_t *rk, size_t num, size_t size);\nvoid *rd_kafka_mem_malloc(rd_kafka_t *rk, size_t size);\nvoid rd_kafka_mem_free(rd_kafka_t *rk, void *ptr);\nrd_kafka_queue_t *rd_kafka_queue_new(rd_kafka_t *rk);\nvoid rd_kafka_queue_destroy(rd_kafka_queue_t *rkqu);\nrd_kafka_queue_t *rd_kafka_queue_get_main(rd_kafka_t *rk);\nrd_kafka_queue_t *rd_kafka_queue_get_sasl(rd_kafka_t *rk);\nrd_kafka_error_t *rd_kafka_sasl_background_callbacks_enable(rd_kafka_t *rk);\nrd_kafka_error_t *rd_kafka_sasl_set_credentials(rd_kafka_t *rk, const char *username, const char *password);\nrd_kafka_queue_t *rd_kafka_queue_get_consumer(rd_kafka_t *rk);\nrd_kafka_queue_t *rd_kafka_queue_get_partition(rd_kafka_t *rk, const char *topic, int32_t partition);\nrd_kafka_queue_t *rd_kafka_queue_get_background(rd_kafka_t *rk);\nvoid rd_kafka_queue_forward(rd_kafka_queue_t *src, rd_kafka_queue_t *dst);\nrd_kafka_resp_err_t rd_kafka_set_log_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu);\nsize_t rd_kafka_queue_length(rd_kafka_queue_t *rkqu);\nvoid rd_kafka_queue_io_event_enable(rd_kafka_queue_t *rkqu, int fd, const void *payload, size_t size);\nvoid rd_kafka_queue_cb_event_enable(rd_kafka_queue_t *rkqu, void (*event_cb)(rd_kafka_t *rk, void *qev_opaque), void *qev_opaque);\nvoid rd_kafka_queue_yield(rd_kafka_queue_t *rkqu);\nint rd_kafka_consume_start(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);\nint rd_kafka_consume_start_queue(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, rd_kafka_queue_t *rkqu);\nint rd_kafka_consume_stop(rd_kafka_topic_t *rkt, int32_t partition);\nrd_kafka_resp_err_t rd_kafka_seek(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, int timeout_ms);\nrd_kafka_error_t *rd_kafka_seek_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms);\nrd_kafka_message_t *rd_kafka_consume(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms);\nssize_t rd_kafka_consume_batch(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);\nint rd_kafka_consume_callback(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);\nrd_kafka_message_t *rd_kafka_consume_queue(rd_kafka_queue_t *rkqu, int timeout_ms);\nssize_t rd_kafka_consume_batch_queue(rd_kafka_queue_t *rkqu, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);\nint rd_kafka_consume_callback_queue(rd_kafka_queue_t *rkqu, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);\nrd_kafka_resp_err_t rd_kafka_offset_store(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);\nrd_kafka_resp_err_t rd_kafka_offsets_store(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets);\nrd_kafka_error_t *rd_kafka_offset_store_message(rd_kafka_message_t *rkmessage);\nrd_kafka_resp_err_t rd_kafka_subscribe(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *topics);\nrd_kafka_resp_err_t rd_kafka_unsubscribe(rd_kafka_t *rk);\nrd_kafka_resp_err_t rd_kafka_subscription(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **topics);\nrd_kafka_message_t *rd_kafka_consumer_poll(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_resp_err_t rd_kafka_consumer_close(rd_kafka_t *rk);\nrd_kafka_error_t *rd_kafka_consumer_close_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu);\nint rd_kafka_consumer_closed(rd_kafka_t *rk);\nrd_kafka_error_t *rd_kafka_incremental_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_error_t *rd_kafka_incremental_unassign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);\nconst char *rd_kafka_rebalance_protocol(rd_kafka_t *rk);\nrd_kafka_resp_err_t rd_kafka_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_resp_err_t rd_kafka_assignment(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **partitions);\nint rd_kafka_assignment_lost(rd_kafka_t *rk);\nrd_kafka_resp_err_t rd_kafka_commit(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, int async);\nrd_kafka_resp_err_t rd_kafka_commit_message(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, int async);\nrd_kafka_resp_err_t rd_kafka_commit_queue(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_queue_t *rkqu, void (*cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *commit_opaque), void *commit_opaque);\nrd_kafka_resp_err_t rd_kafka_committed(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms);\nrd_kafka_resp_err_t rd_kafka_position(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata(rd_kafka_t *rk);\nrd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata_new(const char *group_id);\nrd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata_new_with_genid(const char *group_id, int32_t generation_id, const char *member_id, const char *group_instance_id);\nvoid rd_kafka_consumer_group_metadata_destroy(rd_kafka_consumer_group_metadata_t *);\nrd_kafka_error_t *rd_kafka_consumer_group_metadata_write(const rd_kafka_consumer_group_metadata_t *cgmd, void **bufferp, size_t *sizep);\nrd_kafka_error_t *rd_kafka_consumer_group_metadata_read(rd_kafka_consumer_group_metadata_t **cgmdp, const void *buffer, size_t size);\nint rd_kafka_produce(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, void *payload, size_t len, const void *key, size_t keylen, void *msg_opaque);\nrd_kafka_resp_err_t rd_kafka_producev(rd_kafka_t *rk, ...);\nrd_kafka_error_t *rd_kafka_produceva(rd_kafka_t *rk, const rd_kafka_vu_t *vus, size_t cnt);\nint rd_kafka_produce_batch(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, rd_kafka_message_t *rkmessages, int message_cnt);\nrd_kafka_resp_err_t rd_kafka_flush(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_resp_err_t rd_kafka_purge(rd_kafka_t *rk, int purge_flags);\ntypedef struct rd_kafka_metadata_broker {\n  int32_t id;\n  char *host;\n  int port;\n} rd_kafka_metadata_broker_t;\ntypedef struct rd_kafka_metadata_partition {\n  int32_t id;\n  rd_kafka_resp_err_t err;\n  int32_t leader;\n  int replica_cnt;\n  int32_t *replicas;\n  int isr_cnt;\n  int32_t *isrs;\n} rd_kafka_metadata_partition_t;\ntypedef struct rd_kafka_metadata_topic {\n  char *topic;\n  int partition_cnt;\n  struct rd_kafka_metadata_partition *partitions;\n  rd_kafka_resp_err_t err;\n} rd_kafka_metadata_topic_t;\ntypedef struct rd_kafka_metadata {\n  int broker_cnt;\n  struct rd_kafka_metadata_broker *brokers;\n  int topic_cnt;\n  struct rd_kafka_metadata_topic *topics;\n  int32_t orig_broker_id;\n  char *orig_broker_name;\n} rd_kafka_metadata_t;\nrd_kafka_resp_err_t rd_kafka_metadata(rd_kafka_t *rk, int all_topics, rd_kafka_topic_t *only_rkt, const struct rd_kafka_metadata **metadatap, int timeout_ms);\nvoid rd_kafka_metadata_destroy(const struct rd_kafka_metadata *metadata);\ntypedef struct rd_kafka_Node_s rd_kafka_Node_t;\nint rd_kafka_Node_id(const rd_kafka_Node_t *node);\nconst char *rd_kafka_Node_host(const rd_kafka_Node_t *node);\nuint16_t rd_kafka_Node_port(const rd_kafka_Node_t *node);\nconst char *rd_kafka_Node_rack(const rd_kafka_Node_t *node);\nstruct rd_kafka_group_member_info {\n  char *member_id;\n  char *client_id;\n  char *client_host;\n  void *member_metadata;\n  int member_metadata_size;\n  void *member_assignment;\n  int member_assignment_size;\n};\ntypedef enum {\n  RD_KAFKA_CONSUMER_GROUP_STATE_UNKNOWN = 0,\n  RD_KAFKA_CONSUMER_GROUP_STATE_PREPARING_REBALANCE = 1,\n  RD_KAFKA_CONSUMER_GROUP_STATE_COMPLETING_REBALANCE = 2,\n  RD_KAFKA_CONSUMER_GROUP_STATE_STABLE = 3,\n  RD_KAFKA_CONSUMER_GROUP_STATE_DEAD = 4,\n  RD_KAFKA_CONSUMER_GROUP_STATE_EMPTY = 5,\n  RD_KAFKA_CONSUMER_GROUP_STATE__CNT,\n} rd_kafka_consumer_group_state_t;\nstruct rd_kafka_group_info {\n  struct rd_kafka_metadata_broker broker;\n  char *group;\n  rd_kafka_resp_err_t err;\n  char *state;\n  char *protocol_type;\n  char *protocol;\n  struct rd_kafka_group_member_info *members;\n  int member_cnt;\n};\nstruct rd_kafka_group_list {\n  struct rd_kafka_group_info *groups;\n  int group_cnt;\n};\nrd_kafka_resp_err_t rd_kafka_list_groups(rd_kafka_t *rk, const char *group, const struct rd_kafka_group_list **grplistp, int timeout_ms);\nconst char *rd_kafka_consumer_group_state_name(rd_kafka_consumer_group_state_t state);\nrd_kafka_consumer_group_state_t rd_kafka_consumer_group_state_code(const char *name);\nvoid rd_kafka_group_list_destroy(const struct rd_kafka_group_list *grplist);\nint rd_kafka_brokers_add(rd_kafka_t *rk, const char *brokerlist);\nvoid rd_kafka_set_logger(rd_kafka_t *rk, void (*func)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));\nvoid rd_kafka_set_log_level(rd_kafka_t *rk, int level);\nvoid rd_kafka_log_print(const rd_kafka_t *rk, int level, const char *fac, const char *buf);\nvoid rd_kafka_log_syslog(const rd_kafka_t *rk, int level, const char *fac, const char *buf);\nint rd_kafka_outq_len(rd_kafka_t *rk);\nvoid rd_kafka_dump(FILE *fp, rd_kafka_t *rk);\nint rd_kafka_thread_cnt(void);\ntypedef enum rd_kafka_thread_type_t {\n  RD_KAFKA_THREAD_MAIN,\n  RD_KAFKA_THREAD_BACKGROUND,\n  RD_KAFKA_THREAD_BROKER,\n} rd_kafka_thread_type_t;\nint rd_kafka_wait_destroyed(int timeout_ms);\nint rd_kafka_unittest(void);\nrd_kafka_resp_err_t rd_kafka_poll_set_consumer(rd_kafka_t *rk);\ntypedef int rd_kafka_event_type_t;\nrd_kafka_event_type_t rd_kafka_event_type(const rd_kafka_event_t *rkev);\nconst char *rd_kafka_event_name(const rd_kafka_event_t *rkev);\nvoid rd_kafka_event_destroy(rd_kafka_event_t *rkev);\nconst rd_kafka_message_t *rd_kafka_event_message_next(rd_kafka_event_t *rkev);\nsize_t rd_kafka_event_message_array(rd_kafka_event_t *rkev, const rd_kafka_message_t **rkmessages, size_t size);\nsize_t rd_kafka_event_message_count(rd_kafka_event_t *rkev);\nconst char *rd_kafka_event_config_string(rd_kafka_event_t *rkev);\nrd_kafka_resp_err_t rd_kafka_event_error(rd_kafka_event_t *rkev);\nconst char *rd_kafka_event_error_string(rd_kafka_event_t *rkev);\nint rd_kafka_event_error_is_fatal(rd_kafka_event_t *rkev);\nvoid *rd_kafka_event_opaque(rd_kafka_event_t *rkev);\nint rd_kafka_event_log(rd_kafka_event_t *rkev, const char **fac, const char **str, int *level);\nint rd_kafka_event_debug_contexts(rd_kafka_event_t *rkev, char *dst, size_t dstsize);\nconst char *rd_kafka_event_stats(rd_kafka_event_t *rkev);\nrd_kafka_topic_partition_list_t *rd_kafka_event_topic_partition_list(rd_kafka_event_t *rkev);\nrd_kafka_topic_partition_t *rd_kafka_event_topic_partition(rd_kafka_event_t *rkev);\ntypedef rd_kafka_event_t rd_kafka_CreateTopics_result_t;\ntypedef rd_kafka_event_t rd_kafka_DeleteTopics_result_t;\ntypedef rd_kafka_event_t rd_kafka_CreateAcls_result_t;\ntypedef rd_kafka_event_t rd_kafka_DescribeAcls_result_t;\ntypedef rd_kafka_event_t rd_kafka_DeleteAcls_result_t;\ntypedef rd_kafka_event_t rd_kafka_CreatePartitions_result_t;\ntypedef rd_kafka_event_t rd_kafka_AlterConfigs_result_t;\ntypedef rd_kafka_event_t rd_kafka_IncrementalAlterConfigs_result_t;\ntypedef rd_kafka_event_t rd_kafka_DescribeConfigs_result_t;\ntypedef rd_kafka_event_t rd_kafka_DeleteRecords_result_t;\ntypedef rd_kafka_event_t rd_kafka_ListConsumerGroups_result_t;\ntypedef rd_kafka_event_t rd_kafka_DescribeConsumerGroups_result_t;\ntypedef rd_kafka_event_t rd_kafka_DeleteGroups_result_t;\ntypedef rd_kafka_event_t rd_kafka_DeleteConsumerGroupOffsets_result_t;\ntypedef rd_kafka_event_t rd_kafka_AlterConsumerGroupOffsets_result_t;\ntypedef rd_kafka_event_t rd_kafka_ListConsumerGroupOffsets_result_t;\ntypedef rd_kafka_event_t rd_kafka_DescribeTopics_result_t;\ntypedef rd_kafka_event_t rd_kafka_DescribeCluster_result_t;\ntypedef rd_kafka_event_t rd_kafka_DescribeUserScramCredentials_result_t;\ntypedef rd_kafka_event_t rd_kafka_AlterUserScramCredentials_result_t;\ntypedef rd_kafka_event_t rd_kafka_ListOffsets_result_t;\nconst rd_kafka_CreateTopics_result_t *rd_kafka_event_CreateTopics_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DeleteTopics_result_t *rd_kafka_event_DeleteTopics_result(rd_kafka_event_t *rkev);\nconst rd_kafka_CreatePartitions_result_t *rd_kafka_event_CreatePartitions_result(rd_kafka_event_t *rkev);\nconst rd_kafka_AlterConfigs_result_t *rd_kafka_event_AlterConfigs_result(rd_kafka_event_t *rkev);\nconst rd_kafka_IncrementalAlterConfigs_result_t *rd_kafka_event_IncrementalAlterConfigs_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DescribeConfigs_result_t *rd_kafka_event_DescribeConfigs_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DeleteRecords_result_t *rd_kafka_event_DeleteRecords_result(rd_kafka_event_t *rkev);\nconst rd_kafka_ListConsumerGroups_result_t *rd_kafka_event_ListConsumerGroups_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DescribeConsumerGroups_result_t *rd_kafka_event_DescribeConsumerGroups_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DescribeTopics_result_t *rd_kafka_event_DescribeTopics_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DescribeCluster_result_t *rd_kafka_event_DescribeCluster_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DeleteGroups_result_t *rd_kafka_event_DeleteGroups_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DeleteConsumerGroupOffsets_result_t *rd_kafka_event_DeleteConsumerGroupOffsets_result(rd_kafka_event_t *rkev);\nconst rd_kafka_CreateAcls_result_t *rd_kafka_event_CreateAcls_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DescribeAcls_result_t *rd_kafka_event_DescribeAcls_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DeleteAcls_result_t *rd_kafka_event_DeleteAcls_result(rd_kafka_event_t *rkev);\nconst rd_kafka_ListConsumerGroupOffsets_result_t *rd_kafka_event_ListConsumerGroupOffsets_result(rd_kafka_event_t *rkev);\nconst rd_kafka_AlterConsumerGroupOffsets_result_t *rd_kafka_event_AlterConsumerGroupOffsets_result(rd_kafka_event_t *rkev);\nconst rd_kafka_ListOffsets_result_t *rd_kafka_event_ListOffsets_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DescribeUserScramCredentials_result_t *rd_kafka_event_DescribeUserScramCredentials_result(rd_kafka_event_t *rkev);\nconst rd_kafka_AlterUserScramCredentials_result_t *rd_kafka_event_AlterUserScramCredentials_result(rd_kafka_event_t *rkev);\nrd_kafka_event_t *rd_kafka_queue_poll(rd_kafka_queue_t *rkqu, int timeout_ms);\nint rd_kafka_queue_poll_callback(rd_kafka_queue_t *rkqu, int timeout_ms);\ntypedef rd_kafka_resp_err_t (rd_kafka_plugin_f_conf_init_t)(rd_kafka_conf_t *conf, void **plug_opaquep, char *errstr, size_t errstr_size);\ntypedef rd_kafka_conf_res_t (rd_kafka_interceptor_f_on_conf_set_t)(rd_kafka_conf_t *conf, const char *name, const char *val, char *errstr, size_t errstr_size, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_dup_t)(rd_kafka_conf_t *new_conf, const rd_kafka_conf_t *old_conf, size_t filter_cnt, const char **filter, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_destroy_t)(void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_new_t)(rd_kafka_t *rk, const rd_kafka_conf_t *conf, void *ic_opaque, char *errstr, size_t errstr_size);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_destroy_t)(rd_kafka_t *rk, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_send_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_acknowledgement_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_consume_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_commit_t)(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_resp_err_t err, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_request_sent_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_response_received_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, int64_t rtt, rd_kafka_resp_err_t err, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_start_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_exit_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_broker_state_change_t)(rd_kafka_t *rk, int32_t broker_id, const char *secproto, const char *name, int port, const char *state, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_set(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_set_t *on_conf_set, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_dup(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_dup_t *on_conf_dup, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_destroy(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_destroy_t *on_conf_destroy, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_new(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_new_t *on_new, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_destroy(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_destroy_t *on_destroy, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_send(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_send_t *on_send, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_acknowledgement(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_acknowledgement_t *on_acknowledgement, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_consume(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_consume_t *on_consume, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_commit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_commit_t *on_commit, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_request_sent(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_request_sent_t *on_request_sent, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_response_received(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_response_received_t *on_response_received, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_start(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_start_t *on_thread_start, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_exit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_exit_t *on_thread_exit, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_broker_state_change(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_broker_state_change_t *on_broker_state_change, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_topic_result_error(const rd_kafka_topic_result_t *topicres);\nconst char *rd_kafka_topic_result_error_string(const rd_kafka_topic_result_t *topicres);\nconst char *rd_kafka_topic_result_name(const rd_kafka_topic_result_t *topicres);\nconst rd_kafka_error_t *rd_kafka_group_result_error(const rd_kafka_group_result_t *groupres);\nconst char *rd_kafka_group_result_name(const rd_kafka_group_result_t *groupres);\nconst rd_kafka_topic_partition_list_t *rd_kafka_group_result_partitions(const rd_kafka_group_result_t *groupres);\ntypedef enum rd_kafka_admin_op_t {\n  RD_KAFKA_ADMIN_OP_ANY = 0,\n  RD_KAFKA_ADMIN_OP_CREATETOPICS,\n  RD_KAFKA_ADMIN_OP_DELETETOPICS,\n  RD_KAFKA_ADMIN_OP_CREATEPARTITIONS,\n  RD_KAFKA_ADMIN_OP_ALTERCONFIGS,\n  RD_KAFKA_ADMIN_OP_DESCRIBECONFIGS,\n  RD_KAFKA_ADMIN_OP_DELETERECORDS,\n  RD_KAFKA_ADMIN_OP_DELETEGROUPS,\n  RD_KAFKA_ADMIN_OP_DELETECONSUMERGROUPOFFSETS,\n  RD_KAFKA_ADMIN_OP_CREATEACLS,\n  RD_KAFKA_ADMIN_OP_DESCRIBEACLS,\n  RD_KAFKA_ADMIN_OP_DELETEACLS,\n  RD_KAFKA_ADMIN_OP_LISTCONSUMERGROUPS,\n  RD_KAFKA_ADMIN_OP_DESCRIBECONSUMERGROUPS,\n  RD_KAFKA_ADMIN_OP_LISTCONSUMERGROUPOFFSETS,\n  RD_KAFKA_ADMIN_OP_ALTERCONSUMERGROUPOFFSETS,\n  RD_KAFKA_ADMIN_OP_INCREMENTALALTERCONFIGS,\n  RD_KAFKA_ADMIN_OP_DESCRIBEUSERSCRAMCREDENTIALS,\n  RD_KAFKA_ADMIN_OP_ALTERUSERSCRAMCREDENTIALS,\n  RD_KAFKA_ADMIN_OP_DESCRIBETOPICS,\n  RD_KAFKA_ADMIN_OP_DESCRIBECLUSTER,\n  RD_KAFKA_ADMIN_OP_LISTOFFSETS,\n  RD_KAFKA_ADMIN_OP__CNT,\n} rd_kafka_admin_op_t;\ntypedef struct rd_kafka_AdminOptions_s rd_kafka_AdminOptions_t;\ntypedef enum rd_kafka_IsolationLevel_t {\n  RD_KAFKA_ISOLATION_LEVEL_READ_UNCOMMITTED = 0,\n  RD_KAFKA_ISOLATION_LEVEL_READ_COMMITTED = 1,\n} rd_kafka_IsolationLevel_t;\nrd_kafka_AdminOptions_t *rd_kafka_AdminOptions_new(rd_kafka_t *rk, rd_kafka_admin_op_t for_api);\nvoid rd_kafka_AdminOptions_destroy(rd_kafka_AdminOptions_t *options);\nrd_kafka_resp_err_t rd_kafka_AdminOptions_set_request_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_AdminOptions_set_operation_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_AdminOptions_set_validate_only(rd_kafka_AdminOptions_t *options, int true_or_false, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_AdminOptions_set_broker(rd_kafka_AdminOptions_t *options, int32_t broker_id, char *errstr, size_t errstr_size);\nrd_kafka_error_t *rd_kafka_AdminOptions_set_require_stable_offsets(rd_kafka_AdminOptions_t *options, int true_or_false);\nrd_kafka_error_t *rd_kafka_AdminOptions_set_include_authorized_operations(rd_kafka_AdminOptions_t *options, int true_or_false);\nrd_kafka_error_t *rd_kafka_AdminOptions_set_match_consumer_group_states(rd_kafka_AdminOptions_t *options, const rd_kafka_consumer_group_state_t *consumer_group_states, size_t consumer_group_states_cnt);\nrd_kafka_error_t *rd_kafka_AdminOptions_set_isolation_level(rd_kafka_AdminOptions_t *options, rd_kafka_IsolationLevel_t value);\nvoid rd_kafka_AdminOptions_set_opaque(rd_kafka_AdminOptions_t *options, void *ev_opaque);\ntypedef enum rd_kafka_AclOperation_t {\n  RD_KAFKA_ACL_OPERATION_UNKNOWN = 0,\n  RD_KAFKA_ACL_OPERATION_ANY = 1,\n  RD_KAFKA_ACL_OPERATION_ALL = 2,\n  RD_KAFKA_ACL_OPERATION_READ = 3,\n  RD_KAFKA_ACL_OPERATION_WRITE = 4,\n  RD_KAFKA_ACL_OPERATION_CREATE = 5,\n  RD_KAFKA_ACL_OPERATION_DELETE = 6,\n  RD_KAFKA_ACL_OPERATION_ALTER = 7,\n  RD_KAFKA_ACL_OPERATION_DESCRIBE = 8,\n  RD_KAFKA_ACL_OPERATION_CLUSTER_ACTION = 9,\n  RD_KAFKA_ACL_OPERATION_DESCRIBE_CONFIGS = 10,\n  RD_KAFKA_ACL_OPERATION_ALTER_CONFIGS = 11,\n  RD_KAFKA_ACL_OPERATION_IDEMPOTENT_WRITE = 12,\n  RD_KAFKA_ACL_OPERATION__CNT,\n} rd_kafka_AclOperation_t;\ntypedef struct rd_kafka_NewTopic_s rd_kafka_NewTopic_t;\nrd_kafka_NewTopic_t *rd_kafka_NewTopic_new(const char *topic, int num_partitions, int replication_factor, char *errstr, size_t errstr_size);\nvoid rd_kafka_NewTopic_destroy(rd_kafka_NewTopic_t *new_topic);\nvoid rd_kafka_NewTopic_destroy_array(rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt);\nrd_kafka_resp_err_t rd_kafka_NewTopic_set_replica_assignment(rd_kafka_NewTopic_t *new_topic, int32_t partition, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_NewTopic_set_config(rd_kafka_NewTopic_t *new_topic, const char *name, const char *value);\nvoid rd_kafka_CreateTopics(rd_kafka_t *rk, rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_topic_result_t **rd_kafka_CreateTopics_result_topics(const rd_kafka_CreateTopics_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_DeleteTopic_s rd_kafka_DeleteTopic_t;\nrd_kafka_DeleteTopic_t *rd_kafka_DeleteTopic_new(const char *topic);\nvoid rd_kafka_DeleteTopic_destroy(rd_kafka_DeleteTopic_t *del_topic);\nvoid rd_kafka_DeleteTopic_destroy_array(rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt);\nvoid rd_kafka_DeleteTopics(rd_kafka_t *rk, rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_topic_result_t **rd_kafka_DeleteTopics_result_topics(const rd_kafka_DeleteTopics_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_NewPartitions_s rd_kafka_NewPartitions_t;\nrd_kafka_NewPartitions_t *rd_kafka_NewPartitions_new(const char *topic, size_t new_total_cnt, char *errstr, size_t errstr_size);\nvoid rd_kafka_NewPartitions_destroy(rd_kafka_NewPartitions_t *new_parts);\nvoid rd_kafka_NewPartitions_destroy_array(rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt);\nrd_kafka_resp_err_t rd_kafka_NewPartitions_set_replica_assignment(rd_kafka_NewPartitions_t *new_parts, int32_t new_partition_idx, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);\nvoid rd_kafka_CreatePartitions(rd_kafka_t *rk, rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_topic_result_t **rd_kafka_CreatePartitions_result_topics(const rd_kafka_CreatePartitions_result_t *result, size_t *cntp);\ntypedef enum rd_kafka_ConfigSource_t {\n  RD_KAFKA_CONFIG_SOURCE_UNKNOWN_CONFIG = 0,\n  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_TOPIC_CONFIG = 1,\n  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_BROKER_CONFIG = 2,\n  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_DEFAULT_BROKER_CONFIG = 3,\n  RD_KAFKA_CONFIG_SOURCE_STATIC_BROKER_CONFIG = 4,\n  RD_KAFKA_CONFIG_SOURCE_DEFAULT_CONFIG = 5,\n  RD_KAFKA_CONFIG_SOURCE__CNT,\n} rd_kafka_ConfigSource_t;\nconst char *rd_kafka_ConfigSource_name(rd_kafka_ConfigSource_t confsource);\ntypedef struct rd_kafka_ConfigEntry_s rd_kafka_ConfigEntry_t;\nconst char *rd_kafka_ConfigEntry_name(const rd_kafka_ConfigEntry_t *entry);\nconst char *rd_kafka_ConfigEntry_value(const rd_kafka_ConfigEntry_t *entry);\nrd_kafka_ConfigSource_t rd_kafka_ConfigEntry_source(const rd_kafka_ConfigEntry_t *entry);\nint rd_kafka_ConfigEntry_is_read_only(const rd_kafka_ConfigEntry_t *entry);\nint rd_kafka_ConfigEntry_is_default(const rd_kafka_ConfigEntry_t *entry);\nint rd_kafka_ConfigEntry_is_sensitive(const rd_kafka_ConfigEntry_t *entry);\nint rd_kafka_ConfigEntry_is_synonym(const rd_kafka_ConfigEntry_t *entry);\nconst rd_kafka_ConfigEntry_t **rd_kafka_ConfigEntry_synonyms(const rd_kafka_ConfigEntry_t *entry, size_t *cntp);\ntypedef enum rd_kafka_ResourceType_t {\n  RD_KAFKA_RESOURCE_UNKNOWN = 0,\n  RD_KAFKA_RESOURCE_ANY = 1,\n  RD_KAFKA_RESOURCE_TOPIC = 2,\n  RD_KAFKA_RESOURCE_GROUP = 3,\n  RD_KAFKA_RESOURCE_BROKER = 4,\n  RD_KAFKA_RESOURCE__CNT,\n} rd_kafka_ResourceType_t;\ntypedef enum rd_kafka_ResourcePatternType_t {\n  RD_KAFKA_RESOURCE_PATTERN_UNKNOWN = 0,\n  RD_KAFKA_RESOURCE_PATTERN_ANY = 1,\n  RD_KAFKA_RESOURCE_PATTERN_MATCH = 2,\n  RD_KAFKA_RESOURCE_PATTERN_LITERAL = 3,\n  RD_KAFKA_RESOURCE_PATTERN_PREFIXED = 4,\n  RD_KAFKA_RESOURCE_PATTERN_TYPE__CNT,\n} rd_kafka_ResourcePatternType_t;\ntypedef enum rd_kafka_AlterConfigOpType_t {\n  RD_KAFKA_ALTER_CONFIG_OP_TYPE_SET = 0,\n  RD_KAFKA_ALTER_CONFIG_OP_TYPE_DELETE = 1,\n  RD_KAFKA_ALTER_CONFIG_OP_TYPE_APPEND = 2,\n  RD_KAFKA_ALTER_CONFIG_OP_TYPE_SUBTRACT = 3,\n  RD_KAFKA_ALTER_CONFIG_OP_TYPE__CNT,\n} rd_kafka_AlterConfigOpType_t;\nconst char *rd_kafka_ResourcePatternType_name(rd_kafka_ResourcePatternType_t resource_pattern_type);\nconst char *rd_kafka_ResourceType_name(rd_kafka_ResourceType_t restype);\ntypedef struct rd_kafka_ConfigResource_s rd_kafka_ConfigResource_t;\nrd_kafka_ConfigResource_t *rd_kafka_ConfigResource_new(rd_kafka_ResourceType_t restype, const char *resname);\nvoid rd_kafka_ConfigResource_destroy(rd_kafka_ConfigResource_t *config);\nvoid rd_kafka_ConfigResource_destroy_array(rd_kafka_ConfigResource_t **config, size_t config_cnt);\nrd_kafka_resp_err_t rd_kafka_ConfigResource_set_config(rd_kafka_ConfigResource_t *config, const char *name, const char *value);\nrd_kafka_error_t *rd_kafka_ConfigResource_add_incremental_config(rd_kafka_ConfigResource_t *config, const char *name, rd_kafka_AlterConfigOpType_t op_type, const char *value);\nconst rd_kafka_ConfigEntry_t **rd_kafka_ConfigResource_configs(const rd_kafka_ConfigResource_t *config, size_t *cntp);\nrd_kafka_ResourceType_t rd_kafka_ConfigResource_type(const rd_kafka_ConfigResource_t *config);\nconst char *rd_kafka_ConfigResource_name(const rd_kafka_ConfigResource_t *config);\nrd_kafka_resp_err_t rd_kafka_ConfigResource_error(const rd_kafka_ConfigResource_t *config);\nconst char *rd_kafka_ConfigResource_error_string(const rd_kafka_ConfigResource_t *config);\nvoid rd_kafka_AlterConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_ConfigResource_t **rd_kafka_AlterConfigs_result_resources(const rd_kafka_AlterConfigs_result_t *result, size_t *cntp);\nvoid rd_kafka_IncrementalAlterConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_ConfigResource_t **rd_kafka_IncrementalAlterConfigs_result_resources(const rd_kafka_IncrementalAlterConfigs_result_t *result, size_t *cntp);\nvoid rd_kafka_DescribeConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_ConfigResource_t **rd_kafka_DescribeConfigs_result_resources(const rd_kafka_DescribeConfigs_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_DeleteRecords_s rd_kafka_DeleteRecords_t;\nrd_kafka_DeleteRecords_t *rd_kafka_DeleteRecords_new(const rd_kafka_topic_partition_list_t *before_offsets);\nvoid rd_kafka_DeleteRecords_destroy(rd_kafka_DeleteRecords_t *del_records);\nvoid rd_kafka_DeleteRecords_destroy_array(rd_kafka_DeleteRecords_t **del_records, size_t del_record_cnt);\nvoid rd_kafka_DeleteRecords(rd_kafka_t *rk, rd_kafka_DeleteRecords_t **del_records, size_t del_record_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_topic_partition_list_t *rd_kafka_DeleteRecords_result_offsets(const rd_kafka_DeleteRecords_result_t *result);\ntypedef struct rd_kafka_TopicCollection_s rd_kafka_TopicCollection_t;\ntypedef struct rd_kafka_TopicPartitionInfo_s rd_kafka_TopicPartitionInfo_t;\ntypedef struct rd_kafka_TopicDescription_s rd_kafka_TopicDescription_t;\nrd_kafka_TopicCollection_t *rd_kafka_TopicCollection_of_topic_names(const char **topics, size_t topics_cnt);\nvoid rd_kafka_TopicCollection_destroy(rd_kafka_TopicCollection_t *topics);\nvoid rd_kafka_DescribeTopics(rd_kafka_t *rk, const rd_kafka_TopicCollection_t *topics, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_TopicDescription_t **rd_kafka_DescribeTopics_result_topics(const rd_kafka_DescribeTopics_result_t *result, size_t *cntp);\nconst rd_kafka_TopicPartitionInfo_t **rd_kafka_TopicDescription_partitions(const rd_kafka_TopicDescription_t *topicdesc, size_t *cntp);\nconst int rd_kafka_TopicPartitionInfo_partition(const rd_kafka_TopicPartitionInfo_t *partition);\nconst rd_kafka_Node_t *rd_kafka_TopicPartitionInfo_leader(const rd_kafka_TopicPartitionInfo_t *partition);\nconst rd_kafka_Node_t **rd_kafka_TopicPartitionInfo_isr(const rd_kafka_TopicPartitionInfo_t *partition, size_t *cntp);\nconst rd_kafka_Node_t **rd_kafka_TopicPartitionInfo_replicas(const rd_kafka_TopicPartitionInfo_t *partition, size_t *cntp);\nconst rd_kafka_AclOperation_t *rd_kafka_TopicDescription_authorized_operations(const rd_kafka_TopicDescription_t *topicdesc, size_t *cntp);\nconst char *rd_kafka_TopicDescription_name(const rd_kafka_TopicDescription_t *topicdesc);\nconst rd_kafka_Uuid_t *rd_kafka_TopicDescription_topic_id(const rd_kafka_TopicDescription_t *topicdesc);\nint rd_kafka_TopicDescription_is_internal(const rd_kafka_TopicDescription_t *topicdesc);\nconst rd_kafka_error_t *rd_kafka_TopicDescription_error(const rd_kafka_TopicDescription_t *topicdesc);\nvoid rd_kafka_DescribeCluster(rd_kafka_t *rk, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_Node_t **rd_kafka_DescribeCluster_result_nodes(const rd_kafka_DescribeCluster_result_t *result, size_t *cntp);\nconst rd_kafka_AclOperation_t *rd_kafka_DescribeCluster_result_authorized_operations(const rd_kafka_DescribeCluster_result_t *result, size_t *cntp);\nconst rd_kafka_Node_t *rd_kafka_DescribeCluster_result_controller(const rd_kafka_DescribeCluster_result_t *result);\nconst char *rd_kafka_DescribeCluster_result_cluster_id(const rd_kafka_DescribeCluster_result_t *result);\ntypedef struct rd_kafka_ConsumerGroupListing_s rd_kafka_ConsumerGroupListing_t;\ntypedef struct rd_kafka_ListConsumerGroupsResult_s rd_kafka_ListConsumerGroupsResult_t;\nvoid rd_kafka_ListConsumerGroups(rd_kafka_t *rk, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst char *rd_kafka_ConsumerGroupListing_group_id(const rd_kafka_ConsumerGroupListing_t *grplist);\nint rd_kafka_ConsumerGroupListing_is_simple_consumer_group(const rd_kafka_ConsumerGroupListing_t *grplist);\nrd_kafka_consumer_group_state_t rd_kafka_ConsumerGroupListing_state(const rd_kafka_ConsumerGroupListing_t *grplist);\nconst rd_kafka_ConsumerGroupListing_t **rd_kafka_ListConsumerGroups_result_valid(const rd_kafka_ListConsumerGroups_result_t *result, size_t *cntp);\nconst rd_kafka_error_t **rd_kafka_ListConsumerGroups_result_errors(const rd_kafka_ListConsumerGroups_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_ConsumerGroupDescription_s rd_kafka_ConsumerGroupDescription_t;\ntypedef struct rd_kafka_MemberDescription_s rd_kafka_MemberDescription_t;\ntypedef struct rd_kafka_MemberAssignment_s rd_kafka_MemberAssignment_t;\nvoid rd_kafka_DescribeConsumerGroups(rd_kafka_t *rk, const char **groups, size_t groups_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_ConsumerGroupDescription_t **rd_kafka_DescribeConsumerGroups_result_groups(const rd_kafka_DescribeConsumerGroups_result_t *result, size_t *cntp);\nconst char *rd_kafka_ConsumerGroupDescription_group_id(const rd_kafka_ConsumerGroupDescription_t *grpdesc);\nconst rd_kafka_error_t *rd_kafka_ConsumerGroupDescription_error(const rd_kafka_ConsumerGroupDescription_t *grpdesc);\nint rd_kafka_ConsumerGroupDescription_is_simple_consumer_group(const rd_kafka_ConsumerGroupDescription_t *grpdesc);\nconst char *rd_kafka_ConsumerGroupDescription_partition_assignor(const rd_kafka_ConsumerGroupDescription_t *grpdesc);\nconst rd_kafka_AclOperation_t *rd_kafka_ConsumerGroupDescription_authorized_operations(const rd_kafka_ConsumerGroupDescription_t *grpdesc, size_t *cntp);\nrd_kafka_consumer_group_state_t rd_kafka_ConsumerGroupDescription_state(const rd_kafka_ConsumerGroupDescription_t *grpdesc);\nconst rd_kafka_Node_t *rd_kafka_ConsumerGroupDescription_coordinator(const rd_kafka_ConsumerGroupDescription_t *grpdesc);\nsize_t rd_kafka_ConsumerGroupDescription_member_count(const rd_kafka_ConsumerGroupDescription_t *grpdesc);\nconst rd_kafka_MemberDescription_t *rd_kafka_ConsumerGroupDescription_member(const rd_kafka_ConsumerGroupDescription_t *grpdesc, size_t idx);\nconst char *rd_kafka_MemberDescription_client_id(const rd_kafka_MemberDescription_t *member);\nconst char *rd_kafka_MemberDescription_group_instance_id(const rd_kafka_MemberDescription_t *member);\nconst char *rd_kafka_MemberDescription_consumer_id(const rd_kafka_MemberDescription_t *member);\nconst char *rd_kafka_MemberDescription_host(const rd_kafka_MemberDescription_t *member);\nconst rd_kafka_MemberAssignment_t *rd_kafka_MemberDescription_assignment(const rd_kafka_MemberDescription_t *member);\nconst rd_kafka_topic_partition_list_t *rd_kafka_MemberAssignment_partitions(const rd_kafka_MemberAssignment_t *assignment);\ntypedef struct rd_kafka_DeleteGroup_s rd_kafka_DeleteGroup_t;\nrd_kafka_DeleteGroup_t *rd_kafka_DeleteGroup_new(const char *group);\nvoid rd_kafka_DeleteGroup_destroy(rd_kafka_DeleteGroup_t *del_group);\nvoid rd_kafka_DeleteGroup_destroy_array(rd_kafka_DeleteGroup_t **del_groups, size_t del_group_cnt);\nvoid rd_kafka_DeleteGroups(rd_kafka_t *rk, rd_kafka_DeleteGroup_t **del_groups, size_t del_group_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_group_result_t **rd_kafka_DeleteGroups_result_groups(const rd_kafka_DeleteGroups_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_ListConsumerGroupOffsets_s rd_kafka_ListConsumerGroupOffsets_t;\nrd_kafka_ListConsumerGroupOffsets_t *rd_kafka_ListConsumerGroupOffsets_new(const char *group_id, const rd_kafka_topic_partition_list_t *partitions);\nvoid rd_kafka_ListConsumerGroupOffsets_destroy(rd_kafka_ListConsumerGroupOffsets_t *list_grpoffsets);\nvoid rd_kafka_ListConsumerGroupOffsets_destroy_array(rd_kafka_ListConsumerGroupOffsets_t **list_grpoffsets, size_t list_grpoffset_cnt);\nvoid rd_kafka_ListConsumerGroupOffsets(rd_kafka_t *rk, rd_kafka_ListConsumerGroupOffsets_t **list_grpoffsets, size_t list_grpoffsets_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_group_result_t **rd_kafka_ListConsumerGroupOffsets_result_groups(const rd_kafka_ListConsumerGroupOffsets_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_AlterConsumerGroupOffsets_s rd_kafka_AlterConsumerGroupOffsets_t;\nrd_kafka_AlterConsumerGroupOffsets_t *rd_kafka_AlterConsumerGroupOffsets_new(const char *group_id, const rd_kafka_topic_partition_list_t *partitions);\nvoid rd_kafka_AlterConsumerGroupOffsets_destroy(rd_kafka_AlterConsumerGroupOffsets_t *alter_grpoffsets);\nvoid rd_kafka_AlterConsumerGroupOffsets_destroy_array(rd_kafka_AlterConsumerGroupOffsets_t **alter_grpoffsets, size_t alter_grpoffset_cnt);\nvoid rd_kafka_AlterConsumerGroupOffsets(rd_kafka_t *rk, rd_kafka_AlterConsumerGroupOffsets_t **alter_grpoffsets, size_t alter_grpoffsets_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_group_result_t **rd_kafka_AlterConsumerGroupOffsets_result_groups(const rd_kafka_AlterConsumerGroupOffsets_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_DeleteConsumerGroupOffsets_s rd_kafka_DeleteConsumerGroupOffsets_t;\nrd_kafka_DeleteConsumerGroupOffsets_t *rd_kafka_DeleteConsumerGroupOffsets_new(const char *group, const rd_kafka_topic_partition_list_t *partitions);\nvoid rd_kafka_DeleteConsumerGroupOffsets_destroy(rd_kafka_DeleteConsumerGroupOffsets_t *del_grpoffsets);\nvoid rd_kafka_DeleteConsumerGroupOffsets_destroy_array(rd_kafka_DeleteConsumerGroupOffsets_t **del_grpoffsets, size_t del_grpoffset_cnt);\nvoid rd_kafka_DeleteConsumerGroupOffsets(rd_kafka_t *rk, rd_kafka_DeleteConsumerGroupOffsets_t **del_grpoffsets, size_t del_grpoffsets_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_group_result_t **rd_kafka_DeleteConsumerGroupOffsets_result_groups(const rd_kafka_DeleteConsumerGroupOffsets_result_t *result, size_t *cntp);\ntypedef enum rd_kafka_OffsetSpec_t {\n  RD_KAFKA_OFFSET_SPEC_MAX_TIMESTAMP = (- 3),\n  RD_KAFKA_OFFSET_SPEC_EARLIEST = (- 2),\n  RD_KAFKA_OFFSET_SPEC_LATEST = (- 1),\n} rd_kafka_OffsetSpec_t;\ntypedef struct rd_kafka_ListOffsetsResultInfo_s rd_kafka_ListOffsetsResultInfo_t;\nconst rd_kafka_topic_partition_t *rd_kafka_ListOffsetsResultInfo_topic_partition(const rd_kafka_ListOffsetsResultInfo_t *result_info);\nint64_t rd_kafka_ListOffsetsResultInfo_timestamp(const rd_kafka_ListOffsetsResultInfo_t *result_info);\nconst rd_kafka_ListOffsetsResultInfo_t **rd_kafka_ListOffsets_result_infos(const rd_kafka_ListOffsets_result_t *result, size_t *cntp);\nvoid rd_kafka_ListOffsets(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *topic_partitions, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\ntypedef enum rd_kafka_ScramMechanism_t {\n  RD_KAFKA_SCRAM_MECHANISM_UNKNOWN = 0,\n  RD_KAFKA_SCRAM_MECHANISM_SHA_256 = 1,\n  RD_KAFKA_SCRAM_MECHANISM_SHA_512 = 2,\n  RD_KAFKA_SCRAM_MECHANISM__CNT,\n} rd_kafka_ScramMechanism_t;\ntypedef struct rd_kafka_ScramCredentialInfo_s rd_kafka_ScramCredentialInfo_t;\nrd_kafka_ScramMechanism_t rd_kafka_ScramCredentialInfo_mechanism(const rd_kafka_ScramCredentialInfo_t *scram_credential_info);\nint32_t rd_kafka_ScramCredentialInfo_iterations(const rd_kafka_ScramCredentialInfo_t *scram_credential_info);\ntypedef struct rd_kafka_UserScramCredentialsDescription_s rd_kafka_UserScramCredentialsDescription_t;\nconst char *rd_kafka_UserScramCredentialsDescription_user(const rd_kafka_UserScramCredentialsDescription_t *description);\nconst rd_kafka_error_t *rd_kafka_UserScramCredentialsDescription_error(const rd_kafka_UserScramCredentialsDescription_t *description);\nsize_t rd_kafka_UserScramCredentialsDescription_scramcredentialinfo_count(const rd_kafka_UserScramCredentialsDescription_t *description);\nconst rd_kafka_ScramCredentialInfo_t *rd_kafka_UserScramCredentialsDescription_scramcredentialinfo(const rd_kafka_UserScramCredentialsDescription_t *description, size_t idx);\nconst rd_kafka_UserScramCredentialsDescription_t **rd_kafka_DescribeUserScramCredentials_result_descriptions(const rd_kafka_DescribeUserScramCredentials_result_t *result, size_t *cntp);\nvoid rd_kafka_DescribeUserScramCredentials(rd_kafka_t *rk, const char **users, size_t user_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\ntypedef struct rd_kafka_UserScramCredentialAlteration_s rd_kafka_UserScramCredentialAlteration_t;\nrd_kafka_UserScramCredentialAlteration_t *rd_kafka_UserScramCredentialUpsertion_new(const char *username, rd_kafka_ScramMechanism_t mechanism, int32_t iterations, const unsigned char *password, size_t password_size, const unsigned char *salt, size_t salt_size);\nrd_kafka_UserScramCredentialAlteration_t *rd_kafka_UserScramCredentialDeletion_new(const char *username, rd_kafka_ScramMechanism_t mechanism);\nvoid rd_kafka_UserScramCredentialAlteration_destroy(rd_kafka_UserScramCredentialAlteration_t *alteration);\nvoid rd_kafka_UserScramCredentialAlteration_destroy_array(rd_kafka_UserScramCredentialAlteration_t **alterations, size_t alteration_cnt);\ntypedef struct rd_kafka_AlterUserScramCredentials_result_response_s rd_kafka_AlterUserScramCredentials_result_response_t;\nconst char *rd_kafka_AlterUserScramCredentials_result_response_user(const rd_kafka_AlterUserScramCredentials_result_response_t *response);\nconst rd_kafka_error_t *rd_kafka_AlterUserScramCredentials_result_response_error(const rd_kafka_AlterUserScramCredentials_result_response_t *response);\nconst rd_kafka_AlterUserScramCredentials_result_response_t **rd_kafka_AlterUserScramCredentials_result_responses(const rd_kafka_AlterUserScramCredentials_result_t *result, size_t *cntp);\nvoid rd_kafka_AlterUserScramCredentials(rd_kafka_t *rk, rd_kafka_UserScramCredentialAlteration_t **alterations, size_t alteration_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\ntypedef struct rd_kafka_AclBinding_s rd_kafka_AclBinding_t;\ntypedef rd_kafka_AclBinding_t rd_kafka_AclBindingFilter_t;\nconst rd_kafka_error_t *rd_kafka_acl_result_error(const rd_kafka_acl_result_t *aclres);\nconst char *rd_kafka_AclOperation_name(rd_kafka_AclOperation_t acl_operation);\ntypedef enum rd_kafka_AclPermissionType_t {\n  RD_KAFKA_ACL_PERMISSION_TYPE_UNKNOWN = 0,\n  RD_KAFKA_ACL_PERMISSION_TYPE_ANY = 1,\n  RD_KAFKA_ACL_PERMISSION_TYPE_DENY = 2,\n  RD_KAFKA_ACL_PERMISSION_TYPE_ALLOW = 3,\n  RD_KAFKA_ACL_PERMISSION_TYPE__CNT,\n} rd_kafka_AclPermissionType_t;\nconst char *rd_kafka_AclPermissionType_name(rd_kafka_AclPermissionType_t acl_permission_type);\nrd_kafka_AclBinding_t *rd_kafka_AclBinding_new(rd_kafka_ResourceType_t restype, const char *name, rd_kafka_ResourcePatternType_t resource_pattern_type, const char *principal, const char *host, rd_kafka_AclOperation_t operation, rd_kafka_AclPermissionType_t permission_type, char *errstr, size_t errstr_size);\nrd_kafka_AclBindingFilter_t *rd_kafka_AclBindingFilter_new(rd_kafka_ResourceType_t restype, const char *name, rd_kafka_ResourcePatternType_t resource_pattern_type, const char *principal, const char *host, rd_kafka_AclOperation_t operation, rd_kafka_AclPermissionType_t permission_type, char *errstr, size_t errstr_size);\nrd_kafka_ResourceType_t rd_kafka_AclBinding_restype(const rd_kafka_AclBinding_t *acl);\nconst char *rd_kafka_AclBinding_name(const rd_kafka_AclBinding_t *acl);\nconst char *rd_kafka_AclBinding_principal(const rd_kafka_AclBinding_t *acl);\nconst char *rd_kafka_AclBinding_host(const rd_kafka_AclBinding_t *acl);\nrd_kafka_AclOperation_t rd_kafka_AclBinding_operation(const rd_kafka_AclBinding_t *acl);\nrd_kafka_AclPermissionType_t rd_kafka_AclBinding_permission_type(const rd_kafka_AclBinding_t *acl);\nrd_kafka_ResourcePatternType_t rd_kafka_AclBinding_resource_pattern_type(const rd_kafka_AclBinding_t *acl);\nconst rd_kafka_error_t *rd_kafka_AclBinding_error(const rd_kafka_AclBinding_t *acl);\nvoid rd_kafka_AclBinding_destroy(rd_kafka_AclBinding_t *acl_binding);\nvoid rd_kafka_AclBinding_destroy_array(rd_kafka_AclBinding_t **acl_bindings, size_t acl_bindings_cnt);\nconst rd_kafka_acl_result_t **rd_kafka_CreateAcls_result_acls(const rd_kafka_CreateAcls_result_t *result, size_t *cntp);\nvoid rd_kafka_CreateAcls(rd_kafka_t *rk, rd_kafka_AclBinding_t **new_acls, size_t new_acls_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_AclBinding_t **rd_kafka_DescribeAcls_result_acls(const rd_kafka_DescribeAcls_result_t *result, size_t *cntp);\nvoid rd_kafka_DescribeAcls(rd_kafka_t *rk, rd_kafka_AclBindingFilter_t *acl_filter, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\ntypedef struct rd_kafka_DeleteAcls_result_response_s rd_kafka_DeleteAcls_result_response_t;\nconst rd_kafka_DeleteAcls_result_response_t **rd_kafka_DeleteAcls_result_responses(const rd_kafka_DeleteAcls_result_t *result, size_t *cntp);\nconst rd_kafka_error_t *rd_kafka_DeleteAcls_result_response_error(const rd_kafka_DeleteAcls_result_response_t *result_response);\nconst rd_kafka_AclBinding_t **rd_kafka_DeleteAcls_result_response_matching_acls(const rd_kafka_DeleteAcls_result_response_t *result_response, size_t *matching_acls_cntp);\nvoid rd_kafka_DeleteAcls(rd_kafka_t *rk, rd_kafka_AclBindingFilter_t **del_acls, size_t del_acls_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nrd_kafka_resp_err_t rd_kafka_oauthbearer_set_token(rd_kafka_t *rk, const char *token_value, int64_t md_lifetime_ms, const char *md_principal_name, const char **extensions, size_t extension_size, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_oauthbearer_set_token_failure(rd_kafka_t *rk, const char *errstr);\nrd_kafka_error_t *rd_kafka_init_transactions(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_error_t *rd_kafka_begin_transaction(rd_kafka_t *rk);\nrd_kafka_error_t *rd_kafka_send_offsets_to_transaction(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, const rd_kafka_consumer_group_metadata_t *cgmetadata, int timeout_ms);\nrd_kafka_error_t *rd_kafka_commit_transaction(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_error_t *rd_kafka_abort_transaction(rd_kafka_t *rk, int timeout_ms);\ntypedef struct rd_kafka_mock_cluster_s rd_kafka_mock_cluster_t;\nrd_kafka_mock_cluster_t *rd_kafka_mock_cluster_new(rd_kafka_t *rk, int broker_cnt);\nvoid rd_kafka_mock_cluster_destroy(rd_kafka_mock_cluster_t *mcluster);\nrd_kafka_t *rd_kafka_mock_cluster_handle(const rd_kafka_mock_cluster_t *mcluster);\nrd_kafka_mock_cluster_t *rd_kafka_handle_mock_cluster(const rd_kafka_t *rk);\nconst char *rd_kafka_mock_cluster_bootstraps(const rd_kafka_mock_cluster_t *mcluster);\nvoid rd_kafka_mock_clear_request_errors(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey);\nvoid rd_kafka_mock_push_request_errors(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, size_t cnt, ...);\nvoid rd_kafka_mock_push_request_errors_array(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, size_t cnt, const rd_kafka_resp_err_t *errors);\nrd_kafka_resp_err_t rd_kafka_mock_broker_push_request_error_rtts(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int16_t ApiKey, size_t cnt, ...);\nrd_kafka_resp_err_t rd_kafka_mock_broker_error_stack_cnt(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int16_t ApiKey, size_t *cntp);\nvoid rd_kafka_mock_topic_set_error(rd_kafka_mock_cluster_t *mcluster, const char *topic, rd_kafka_resp_err_t err);\nrd_kafka_resp_err_t rd_kafka_mock_topic_create(rd_kafka_mock_cluster_t *mcluster, const char *topic, int partition_cnt, int replication_factor);\nrd_kafka_resp_err_t rd_kafka_mock_partition_set_leader(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id);\nrd_kafka_resp_err_t rd_kafka_mock_partition_set_follower(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id);\nrd_kafka_resp_err_t rd_kafka_mock_partition_set_follower_wmarks(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int64_t lo, int64_t hi);\nrd_kafka_resp_err_t rd_kafka_mock_broker_set_down(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id);\nrd_kafka_resp_err_t rd_kafka_mock_broker_set_up(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id);\nrd_kafka_resp_err_t rd_kafka_mock_broker_set_rtt(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int rtt_ms);\nrd_kafka_resp_err_t rd_kafka_mock_broker_set_rack(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, const char *rack);\nrd_kafka_resp_err_t rd_kafka_mock_coordinator_set(rd_kafka_mock_cluster_t *mcluster, const char *key_type, const char *key, int32_t broker_id);\nrd_kafka_resp_err_t rd_kafka_mock_set_apiversion(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, int16_t MinVersion, int16_t MaxVersion);\nvoid rd_kafka_mock_start_request_tracking(rd_kafka_mock_cluster_t *mcluster);\nvoid rd_kafka_mock_stop_request_tracking(rd_kafka_mock_cluster_t *mcluster);\ntypedef struct rd_kafka_mock_request_s rd_kafka_mock_request_t;\nvoid rd_kafka_mock_request_destroy(rd_kafka_mock_request_t *mreq);\nint32_t rd_kafka_mock_request_id(rd_kafka_mock_request_t *mreq);\nint16_t rd_kafka_mock_request_api_key(rd_kafka_mock_request_t *mreq);\nint64_t rd_kafka_mock_request_timestamp(rd_kafka_mock_request_t *mreq);\nrd_kafka_mock_request_t **rd_kafka_mock_get_requests(rd_kafka_mock_cluster_t *mcluster, size_t *cntp);\nvoid rd_kafka_mock_clear_requests(rd_kafka_mock_cluster_t *mcluster);\n'\n</code></pre> rdkafka.h, rdkafka_mock.h</p>"},{"location":"api/constants/#rd_kafka_version_30","title":"RD_KAFKA_VERSION","text":"<pre><code>public RD_KAFKA_VERSION = 33816831\n</code></pre> <p>librdkafka version </p> <p>Interpreted as hex <code>MM.mm.rr.xx</code>:</p> <ul> <li>MM = Major</li> <li>mm = minor</li> <li>rr = revision</li> <li>xx = pre-release id (0xff is the final release)</li> </ul> <p>E.g.: <code>0x000801ff</code> = 0.8.1</p> RemarksThis value should only be used during compile time, for runtime checks of version use rd_kafka_version()  <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_unsupported_compression_type_30","title":"RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE","text":"<pre><code>public RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76\n</code></pre> <p>Unsupported compression type </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_end_all_30","title":"RD_KAFKA_RESP_ERR_END_ALL","text":"<p><pre><code>public RD_KAFKA_RESP_ERR_END_ALL = 114\n</code></pre> enum rd_kafka_resp_err_t</p>"},{"location":"api/constants/#rd_kafka_admin_op__cnt_30","title":"RD_KAFKA_ADMIN_OP__CNT","text":"<pre><code>public RD_KAFKA_ADMIN_OP__CNT = 22\n</code></pre> <p>Number of ops defined </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe </li> </ul>"},{"location":"api/constants/#rd_kafka_resource__cnt_30","title":"RD_KAFKA_RESOURCE__CNT","text":"<pre><code>public RD_KAFKA_RESOURCE__CNT = 5\n</code></pre> <p>Number of resource types defined </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#acca83a66d7783ff7683ed2691cc907c9 </li> </ul>"},{"location":"api/constants/#rd_kafka_cdef_30","title":"RD_KAFKA_CDEF","text":"<p><pre><code>public RD_KAFKA_CDEF = 'typedef long int ssize_t;\ntypedef struct _IO_FILE FILE;\ntypedef long int mode_t;\ntypedef signed int int16_t;\ntypedef unsigned int uint16_t;\ntypedef signed int int32_t;\ntypedef signed long int int64_t;\nint rd_kafka_version(void);\nconst char *rd_kafka_version_str(void);\ntypedef enum rd_kafka_type_t {\n  RD_KAFKA_PRODUCER,\n  RD_KAFKA_CONSUMER,\n} rd_kafka_type_t;\ntypedef enum rd_kafka_timestamp_type_t {\n  RD_KAFKA_TIMESTAMP_NOT_AVAILABLE,\n  RD_KAFKA_TIMESTAMP_CREATE_TIME,\n  RD_KAFKA_TIMESTAMP_LOG_APPEND_TIME,\n} rd_kafka_timestamp_type_t;\nconst char *rd_kafka_get_debug_contexts(void);\ntypedef struct rd_kafka_s rd_kafka_t;\ntypedef struct rd_kafka_topic_s rd_kafka_topic_t;\ntypedef struct rd_kafka_conf_s rd_kafka_conf_t;\ntypedef struct rd_kafka_topic_conf_s rd_kafka_topic_conf_t;\ntypedef struct rd_kafka_queue_s rd_kafka_queue_t;\ntypedef struct rd_kafka_op_s rd_kafka_event_t;\ntypedef struct rd_kafka_topic_result_s rd_kafka_topic_result_t;\ntypedef struct rd_kafka_consumer_group_metadata_s rd_kafka_consumer_group_metadata_t;\ntypedef struct rd_kafka_error_s {\n  unsigned int code;\n  char *errstr;\n  unsigned char fatal;\n  unsigned char retriable;\n  unsigned char txn_requires_abort;\n} rd_kafka_error_t;\ntypedef struct rd_kafka_headers_s rd_kafka_headers_t;\ntypedef struct rd_kafka_group_result_s rd_kafka_group_result_t;\ntypedef struct rd_kafka_acl_result_s rd_kafka_acl_result_t;\ntypedef struct rd_kafka_Uuid_s rd_kafka_Uuid_t;\ntypedef enum {\n  RD_KAFKA_RESP_ERR__BEGIN = (- 200),\n  RD_KAFKA_RESP_ERR__BAD_MSG = (- 199),\n  RD_KAFKA_RESP_ERR__BAD_COMPRESSION = (- 198),\n  RD_KAFKA_RESP_ERR__DESTROY = (- 197),\n  RD_KAFKA_RESP_ERR__FAIL = (- 196),\n  RD_KAFKA_RESP_ERR__TRANSPORT = (- 195),\n  RD_KAFKA_RESP_ERR__CRIT_SYS_RESOURCE = (- 194),\n  RD_KAFKA_RESP_ERR__RESOLVE = (- 193),\n  RD_KAFKA_RESP_ERR__MSG_TIMED_OUT = (- 192),\n  RD_KAFKA_RESP_ERR__PARTITION_EOF = (- 191),\n  RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION = (- 190),\n  RD_KAFKA_RESP_ERR__FS = (- 189),\n  RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC = (- 188),\n  RD_KAFKA_RESP_ERR__ALL_BROKERS_DOWN = (- 187),\n  RD_KAFKA_RESP_ERR__INVALID_ARG = (- 186),\n  RD_KAFKA_RESP_ERR__TIMED_OUT = (- 185),\n  RD_KAFKA_RESP_ERR__QUEUE_FULL = (- 184),\n  RD_KAFKA_RESP_ERR__ISR_INSUFF = (- 183),\n  RD_KAFKA_RESP_ERR__NODE_UPDATE = (- 182),\n  RD_KAFKA_RESP_ERR__SSL = (- 181),\n  RD_KAFKA_RESP_ERR__WAIT_COORD = (- 180),\n  RD_KAFKA_RESP_ERR__UNKNOWN_GROUP = (- 179),\n  RD_KAFKA_RESP_ERR__IN_PROGRESS = (- 178),\n  RD_KAFKA_RESP_ERR__PREV_IN_PROGRESS = (- 177),\n  RD_KAFKA_RESP_ERR__EXISTING_SUBSCRIPTION = (- 176),\n  RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS = (- 175),\n  RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS = (- 174),\n  RD_KAFKA_RESP_ERR__CONFLICT = (- 173),\n  RD_KAFKA_RESP_ERR__STATE = (- 172),\n  RD_KAFKA_RESP_ERR__UNKNOWN_PROTOCOL = (- 171),\n  RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED = (- 170),\n  RD_KAFKA_RESP_ERR__AUTHENTICATION = (- 169),\n  RD_KAFKA_RESP_ERR__NO_OFFSET = (- 168),\n  RD_KAFKA_RESP_ERR__OUTDATED = (- 167),\n  RD_KAFKA_RESP_ERR__TIMED_OUT_QUEUE = (- 166),\n  RD_KAFKA_RESP_ERR__UNSUPPORTED_FEATURE = (- 165),\n  RD_KAFKA_RESP_ERR__WAIT_CACHE = (- 164),\n  RD_KAFKA_RESP_ERR__INTR = (- 163),\n  RD_KAFKA_RESP_ERR__KEY_SERIALIZATION = (- 162),\n  RD_KAFKA_RESP_ERR__VALUE_SERIALIZATION = (- 161),\n  RD_KAFKA_RESP_ERR__KEY_DESERIALIZATION = (- 160),\n  RD_KAFKA_RESP_ERR__VALUE_DESERIALIZATION = (- 159),\n  RD_KAFKA_RESP_ERR__PARTIAL = (- 158),\n  RD_KAFKA_RESP_ERR__READ_ONLY = (- 157),\n  RD_KAFKA_RESP_ERR__NOENT = (- 156),\n  RD_KAFKA_RESP_ERR__UNDERFLOW = (- 155),\n  RD_KAFKA_RESP_ERR__INVALID_TYPE = (- 154),\n  RD_KAFKA_RESP_ERR__RETRY = (- 153),\n  RD_KAFKA_RESP_ERR__PURGE_QUEUE = (- 152),\n  RD_KAFKA_RESP_ERR__PURGE_INFLIGHT = (- 151),\n  RD_KAFKA_RESP_ERR__FATAL = (- 150),\n  RD_KAFKA_RESP_ERR__INCONSISTENT = (- 149),\n  RD_KAFKA_RESP_ERR__GAPLESS_GUARANTEE = (- 148),\n  RD_KAFKA_RESP_ERR__MAX_POLL_EXCEEDED = (- 147),\n  RD_KAFKA_RESP_ERR__UNKNOWN_BROKER = (- 146),\n  RD_KAFKA_RESP_ERR__NOT_CONFIGURED = (- 145),\n  RD_KAFKA_RESP_ERR__FENCED = (- 144),\n  RD_KAFKA_RESP_ERR__APPLICATION = (- 143),\n  RD_KAFKA_RESP_ERR__ASSIGNMENT_LOST = (- 142),\n  RD_KAFKA_RESP_ERR__NOOP = (- 141),\n  RD_KAFKA_RESP_ERR__AUTO_OFFSET_RESET = (- 140),\n  RD_KAFKA_RESP_ERR__LOG_TRUNCATION = (- 139),\n  RD_KAFKA_RESP_ERR__INVALID_DIFFERENT_RECORD = (- 138),\n  RD_KAFKA_RESP_ERR__END = (- 100),\n  RD_KAFKA_RESP_ERR_UNKNOWN = (- 1),\n  RD_KAFKA_RESP_ERR_NO_ERROR = 0,\n  RD_KAFKA_RESP_ERR_OFFSET_OUT_OF_RANGE = 1,\n  RD_KAFKA_RESP_ERR_INVALID_MSG = 2,\n  RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART = 3,\n  RD_KAFKA_RESP_ERR_INVALID_MSG_SIZE = 4,\n  RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE = 5,\n  RD_KAFKA_RESP_ERR_NOT_LEADER_FOR_PARTITION = 6,\n  RD_KAFKA_RESP_ERR_REQUEST_TIMED_OUT = 7,\n  RD_KAFKA_RESP_ERR_BROKER_NOT_AVAILABLE = 8,\n  RD_KAFKA_RESP_ERR_REPLICA_NOT_AVAILABLE = 9,\n  RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE = 10,\n  RD_KAFKA_RESP_ERR_STALE_CTRL_EPOCH = 11,\n  RD_KAFKA_RESP_ERR_OFFSET_METADATA_TOO_LARGE = 12,\n  RD_KAFKA_RESP_ERR_NETWORK_EXCEPTION = 13,\n  RD_KAFKA_RESP_ERR_COORDINATOR_LOAD_IN_PROGRESS = 14,\n  RD_KAFKA_RESP_ERR_COORDINATOR_NOT_AVAILABLE = 15,\n  RD_KAFKA_RESP_ERR_NOT_COORDINATOR = 16,\n  RD_KAFKA_RESP_ERR_TOPIC_EXCEPTION = 17,\n  RD_KAFKA_RESP_ERR_RECORD_LIST_TOO_LARGE = 18,\n  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS = 19,\n  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS_AFTER_APPEND = 20,\n  RD_KAFKA_RESP_ERR_INVALID_REQUIRED_ACKS = 21,\n  RD_KAFKA_RESP_ERR_ILLEGAL_GENERATION = 22,\n  RD_KAFKA_RESP_ERR_INCONSISTENT_GROUP_PROTOCOL = 23,\n  RD_KAFKA_RESP_ERR_INVALID_GROUP_ID = 24,\n  RD_KAFKA_RESP_ERR_UNKNOWN_MEMBER_ID = 25,\n  RD_KAFKA_RESP_ERR_INVALID_SESSION_TIMEOUT = 26,\n  RD_KAFKA_RESP_ERR_REBALANCE_IN_PROGRESS = 27,\n  RD_KAFKA_RESP_ERR_INVALID_COMMIT_OFFSET_SIZE = 28,\n  RD_KAFKA_RESP_ERR_TOPIC_AUTHORIZATION_FAILED = 29,\n  RD_KAFKA_RESP_ERR_GROUP_AUTHORIZATION_FAILED = 30,\n  RD_KAFKA_RESP_ERR_CLUSTER_AUTHORIZATION_FAILED = 31,\n  RD_KAFKA_RESP_ERR_INVALID_TIMESTAMP = 32,\n  RD_KAFKA_RESP_ERR_UNSUPPORTED_SASL_MECHANISM = 33,\n  RD_KAFKA_RESP_ERR_ILLEGAL_SASL_STATE = 34,\n  RD_KAFKA_RESP_ERR_UNSUPPORTED_VERSION = 35,\n  RD_KAFKA_RESP_ERR_TOPIC_ALREADY_EXISTS = 36,\n  RD_KAFKA_RESP_ERR_INVALID_PARTITIONS = 37,\n  RD_KAFKA_RESP_ERR_INVALID_REPLICATION_FACTOR = 38,\n  RD_KAFKA_RESP_ERR_INVALID_REPLICA_ASSIGNMENT = 39,\n  RD_KAFKA_RESP_ERR_INVALID_CONFIG = 40,\n  RD_KAFKA_RESP_ERR_NOT_CONTROLLER = 41,\n  RD_KAFKA_RESP_ERR_INVALID_REQUEST = 42,\n  RD_KAFKA_RESP_ERR_UNSUPPORTED_FOR_MESSAGE_FORMAT = 43,\n  RD_KAFKA_RESP_ERR_POLICY_VIOLATION = 44,\n  RD_KAFKA_RESP_ERR_OUT_OF_ORDER_SEQUENCE_NUMBER = 45,\n  RD_KAFKA_RESP_ERR_DUPLICATE_SEQUENCE_NUMBER = 46,\n  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_EPOCH = 47,\n  RD_KAFKA_RESP_ERR_INVALID_TXN_STATE = 48,\n  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_ID_MAPPING = 49,\n  RD_KAFKA_RESP_ERR_INVALID_TRANSACTION_TIMEOUT = 50,\n  RD_KAFKA_RESP_ERR_CONCURRENT_TRANSACTIONS = 51,\n  RD_KAFKA_RESP_ERR_TRANSACTION_COORDINATOR_FENCED = 52,\n  RD_KAFKA_RESP_ERR_TRANSACTIONAL_ID_AUTHORIZATION_FAILED = 53,\n  RD_KAFKA_RESP_ERR_SECURITY_DISABLED = 54,\n  RD_KAFKA_RESP_ERR_OPERATION_NOT_ATTEMPTED = 55,\n  RD_KAFKA_RESP_ERR_KAFKA_STORAGE_ERROR = 56,\n  RD_KAFKA_RESP_ERR_LOG_DIR_NOT_FOUND = 57,\n  RD_KAFKA_RESP_ERR_SASL_AUTHENTICATION_FAILED = 58,\n  RD_KAFKA_RESP_ERR_UNKNOWN_PRODUCER_ID = 59,\n  RD_KAFKA_RESP_ERR_REASSIGNMENT_IN_PROGRESS = 60,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTH_DISABLED = 61,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_NOT_FOUND = 62,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_OWNER_MISMATCH = 63,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_REQUEST_NOT_ALLOWED = 64,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTHORIZATION_FAILED = 65,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_EXPIRED = 66,\n  RD_KAFKA_RESP_ERR_INVALID_PRINCIPAL_TYPE = 67,\n  RD_KAFKA_RESP_ERR_NON_EMPTY_GROUP = 68,\n  RD_KAFKA_RESP_ERR_GROUP_ID_NOT_FOUND = 69,\n  RD_KAFKA_RESP_ERR_FETCH_SESSION_ID_NOT_FOUND = 70,\n  RD_KAFKA_RESP_ERR_INVALID_FETCH_SESSION_EPOCH = 71,\n  RD_KAFKA_RESP_ERR_LISTENER_NOT_FOUND = 72,\n  RD_KAFKA_RESP_ERR_TOPIC_DELETION_DISABLED = 73,\n  RD_KAFKA_RESP_ERR_FENCED_LEADER_EPOCH = 74,\n  RD_KAFKA_RESP_ERR_UNKNOWN_LEADER_EPOCH = 75,\n  RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76,\n  RD_KAFKA_RESP_ERR_STALE_BROKER_EPOCH = 77,\n  RD_KAFKA_RESP_ERR_OFFSET_NOT_AVAILABLE = 78,\n  RD_KAFKA_RESP_ERR_MEMBER_ID_REQUIRED = 79,\n  RD_KAFKA_RESP_ERR_PREFERRED_LEADER_NOT_AVAILABLE = 80,\n  RD_KAFKA_RESP_ERR_GROUP_MAX_SIZE_REACHED = 81,\n  RD_KAFKA_RESP_ERR_FENCED_INSTANCE_ID = 82,\n  RD_KAFKA_RESP_ERR_ELIGIBLE_LEADERS_NOT_AVAILABLE = 83,\n  RD_KAFKA_RESP_ERR_ELECTION_NOT_NEEDED = 84,\n  RD_KAFKA_RESP_ERR_NO_REASSIGNMENT_IN_PROGRESS = 85,\n  RD_KAFKA_RESP_ERR_GROUP_SUBSCRIBED_TO_TOPIC = 86,\n  RD_KAFKA_RESP_ERR_INVALID_RECORD = 87,\n  RD_KAFKA_RESP_ERR_UNSTABLE_OFFSET_COMMIT = 88,\n  RD_KAFKA_RESP_ERR_THROTTLING_QUOTA_EXCEEDED = 89,\n  RD_KAFKA_RESP_ERR_PRODUCER_FENCED = 90,\n  RD_KAFKA_RESP_ERR_RESOURCE_NOT_FOUND = 91,\n  RD_KAFKA_RESP_ERR_DUPLICATE_RESOURCE = 92,\n  RD_KAFKA_RESP_ERR_UNACCEPTABLE_CREDENTIAL = 93,\n  RD_KAFKA_RESP_ERR_INCONSISTENT_VOTER_SET = 94,\n  RD_KAFKA_RESP_ERR_INVALID_UPDATE_VERSION = 95,\n  RD_KAFKA_RESP_ERR_FEATURE_UPDATE_FAILED = 96,\n  RD_KAFKA_RESP_ERR_PRINCIPAL_DESERIALIZATION_FAILURE = 97,\n  RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_ID = 100,\n  RD_KAFKA_RESP_ERR_FENCED_MEMBER_EPOCH = 110,\n  RD_KAFKA_RESP_ERR_UNRELEASED_INSTANCE_ID = 111,\n  RD_KAFKA_RESP_ERR_UNSUPPORTED_ASSIGNOR = 112,\n  RD_KAFKA_RESP_ERR_STALE_MEMBER_EPOCH = 113,\n  RD_KAFKA_RESP_ERR_END_ALL,\n} rd_kafka_resp_err_t;\nstruct rd_kafka_err_desc {\n  rd_kafka_resp_err_t code;\n  char *name;\n  char *desc;\n};\nvoid rd_kafka_get_err_descs(const struct rd_kafka_err_desc **errdescs, size_t *cntp);\nconst char *rd_kafka_err2str(rd_kafka_resp_err_t err);\nconst char *rd_kafka_err2name(rd_kafka_resp_err_t err);\nrd_kafka_resp_err_t rd_kafka_last_error(void);\nrd_kafka_resp_err_t rd_kafka_errno2err(int errnox);\nint rd_kafka_errno(void);\nrd_kafka_resp_err_t rd_kafka_fatal_error(rd_kafka_t *rk, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_test_fatal_error(rd_kafka_t *rk, rd_kafka_resp_err_t err, const char *reason);\nrd_kafka_resp_err_t rd_kafka_error_code(const rd_kafka_error_t *error);\nconst char *rd_kafka_error_name(const rd_kafka_error_t *error);\nconst char *rd_kafka_error_string(const rd_kafka_error_t *error);\nint rd_kafka_error_is_fatal(const rd_kafka_error_t *error);\nint rd_kafka_error_is_retriable(const rd_kafka_error_t *error);\nint rd_kafka_error_txn_requires_abort(const rd_kafka_error_t *error);\nvoid rd_kafka_error_destroy(rd_kafka_error_t *error);\nrd_kafka_error_t *rd_kafka_error_new(rd_kafka_resp_err_t code, const char *fmt, ...);\ntypedef struct rd_kafka_topic_partition_s {\n  char *topic;\n  int32_t partition;\n  int64_t offset;\n  void *metadata;\n  size_t metadata_size;\n  void *opaque;\n  rd_kafka_resp_err_t err;\n  void *_private;\n} rd_kafka_topic_partition_t;\nvoid rd_kafka_topic_partition_destroy(rd_kafka_topic_partition_t *rktpar);\nvoid rd_kafka_topic_partition_set_leader_epoch(rd_kafka_topic_partition_t *rktpar, int32_t leader_epoch);\nint32_t rd_kafka_topic_partition_get_leader_epoch(const rd_kafka_topic_partition_t *rktpar);\ntypedef struct rd_kafka_topic_partition_list_s {\n  int cnt;\n  int size;\n  rd_kafka_topic_partition_t *elems;\n} rd_kafka_topic_partition_list_t;\nrd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_new(int size);\nvoid rd_kafka_topic_partition_list_destroy(rd_kafka_topic_partition_list_t *rkparlist);\nrd_kafka_topic_partition_t *rd_kafka_topic_partition_list_add(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);\nvoid rd_kafka_topic_partition_list_add_range(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t start, int32_t stop);\nint rd_kafka_topic_partition_list_del(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);\nint rd_kafka_topic_partition_list_del_by_idx(rd_kafka_topic_partition_list_t *rktparlist, int idx);\nrd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_copy(const rd_kafka_topic_partition_list_t *src);\nrd_kafka_resp_err_t rd_kafka_topic_partition_list_set_offset(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition, int64_t offset);\nrd_kafka_topic_partition_t *rd_kafka_topic_partition_list_find(const rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);\nvoid rd_kafka_topic_partition_list_sort(rd_kafka_topic_partition_list_t *rktparlist, int (*cmp)(const void *a, const void *b, void *cmp_opaque), void *cmp_opaque);\ntypedef enum rd_kafka_vtype_t {\n  RD_KAFKA_VTYPE_END,\n  RD_KAFKA_VTYPE_TOPIC,\n  RD_KAFKA_VTYPE_RKT,\n  RD_KAFKA_VTYPE_PARTITION,\n  RD_KAFKA_VTYPE_VALUE,\n  RD_KAFKA_VTYPE_KEY,\n  RD_KAFKA_VTYPE_OPAQUE,\n  RD_KAFKA_VTYPE_MSGFLAGS,\n  RD_KAFKA_VTYPE_TIMESTAMP,\n  RD_KAFKA_VTYPE_HEADER,\n  RD_KAFKA_VTYPE_HEADERS,\n} rd_kafka_vtype_t;\ntypedef struct rd_kafka_vu_s {\n  rd_kafka_vtype_t vtype;\n  union {\n    char *cstr;\n    rd_kafka_topic_t *rkt;\n    int i;\n    int32_t i32;\n    int64_t i64;\n    struct {\n      void *ptr;\n      size_t size;\n    } mem;\n    struct {\n      char *name;\n      void *val;\n      ssize_t size;\n    } header;\n    rd_kafka_headers_t *headers;\n    void *ptr;\n    char _pad[64];\n  } u;\n} rd_kafka_vu_t;\nrd_kafka_headers_t *rd_kafka_headers_new(size_t initial_count);\nvoid rd_kafka_headers_destroy(rd_kafka_headers_t *hdrs);\nrd_kafka_headers_t *rd_kafka_headers_copy(const rd_kafka_headers_t *src);\nrd_kafka_resp_err_t rd_kafka_header_add(rd_kafka_headers_t *hdrs, const char *name, ssize_t name_size, const void *value, ssize_t value_size);\nrd_kafka_resp_err_t rd_kafka_header_remove(rd_kafka_headers_t *hdrs, const char *name);\nrd_kafka_resp_err_t rd_kafka_header_get_last(const rd_kafka_headers_t *hdrs, const char *name, const void **valuep, size_t *sizep);\nrd_kafka_resp_err_t rd_kafka_header_get(const rd_kafka_headers_t *hdrs, size_t idx, const char *name, const void **valuep, size_t *sizep);\nrd_kafka_resp_err_t rd_kafka_header_get_all(const rd_kafka_headers_t *hdrs, size_t idx, const char **namep, const void **valuep, size_t *sizep);\ntypedef struct rd_kafka_message_s {\n  rd_kafka_resp_err_t err;\n  rd_kafka_topic_t *rkt;\n  int32_t partition;\n  void *payload;\n  size_t len;\n  void *key;\n  size_t key_len;\n  int64_t offset;\n  void *_private;\n} rd_kafka_message_t;\nvoid rd_kafka_message_destroy(rd_kafka_message_t *rkmessage);\nconst char *rd_kafka_message_errstr(const rd_kafka_message_t *rkmessage);\nconst char *rd_kafka_message_produce_errstr(const rd_kafka_message_t *rkmessage);\nint64_t rd_kafka_message_timestamp(const rd_kafka_message_t *rkmessage, rd_kafka_timestamp_type_t *tstype);\nint64_t rd_kafka_message_latency(const rd_kafka_message_t *rkmessage);\nint32_t rd_kafka_message_broker_id(const rd_kafka_message_t *rkmessage);\nrd_kafka_resp_err_t rd_kafka_message_headers(const rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);\nrd_kafka_resp_err_t rd_kafka_message_detach_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);\nvoid rd_kafka_message_set_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t *hdrs);\nsize_t rd_kafka_header_cnt(const rd_kafka_headers_t *hdrs);\ntypedef enum {\n  RD_KAFKA_MSG_STATUS_NOT_PERSISTED = 0,\n  RD_KAFKA_MSG_STATUS_POSSIBLY_PERSISTED = 1,\n  RD_KAFKA_MSG_STATUS_PERSISTED = 2,\n} rd_kafka_msg_status_t;\nrd_kafka_msg_status_t rd_kafka_message_status(const rd_kafka_message_t *rkmessage);\nint32_t rd_kafka_message_leader_epoch(const rd_kafka_message_t *rkmessage);\nconst char *rd_kafka_Uuid_base64str(const rd_kafka_Uuid_t *uuid);\nint64_t rd_kafka_Uuid_least_significant_bits(const rd_kafka_Uuid_t *uuid);\nint64_t rd_kafka_Uuid_most_significant_bits(const rd_kafka_Uuid_t *uuid);\nrd_kafka_Uuid_t *rd_kafka_Uuid_new(int64_t most_significant_bits, int64_t least_significant_bits);\nrd_kafka_Uuid_t *rd_kafka_Uuid_copy(const rd_kafka_Uuid_t *uuid);\nvoid rd_kafka_Uuid_destroy(rd_kafka_Uuid_t *uuid);\ntypedef enum {\n  RD_KAFKA_CONF_UNKNOWN = (- 2),\n  RD_KAFKA_CONF_INVALID = (- 1),\n  RD_KAFKA_CONF_OK = 0,\n} rd_kafka_conf_res_t;\nrd_kafka_conf_t *rd_kafka_conf_new(void);\nvoid rd_kafka_conf_destroy(rd_kafka_conf_t *conf);\nrd_kafka_conf_t *rd_kafka_conf_dup(const rd_kafka_conf_t *conf);\nrd_kafka_conf_t *rd_kafka_conf_dup_filter(const rd_kafka_conf_t *conf, size_t filter_cnt, const char **filter);\nconst rd_kafka_conf_t *rd_kafka_conf(rd_kafka_t *rk);\nrd_kafka_conf_res_t rd_kafka_conf_set(rd_kafka_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);\nvoid rd_kafka_conf_set_events(rd_kafka_conf_t *conf, int events);\nvoid rd_kafka_conf_set_background_event_cb(rd_kafka_conf_t *conf, void (*event_cb)(rd_kafka_t *rk, rd_kafka_event_t *rkev, void *opaque));\nvoid rd_kafka_conf_set_dr_cb(rd_kafka_conf_t *conf, void (*dr_cb)(rd_kafka_t *rk, void *payload, size_t len, rd_kafka_resp_err_t err, void *opaque, void *msg_opaque));\nvoid rd_kafka_conf_set_dr_msg_cb(rd_kafka_conf_t *conf, void (*dr_msg_cb)(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, void *opaque));\nvoid rd_kafka_conf_set_consume_cb(rd_kafka_conf_t *conf, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *opaque));\nvoid rd_kafka_conf_set_rebalance_cb(rd_kafka_conf_t *conf, void (*rebalance_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *partitions, void *opaque));\nvoid rd_kafka_conf_set_offset_commit_cb(rd_kafka_conf_t *conf, void (*offset_commit_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *opaque));\nvoid rd_kafka_conf_set_error_cb(rd_kafka_conf_t *conf, void (*error_cb)(rd_kafka_t *rk, int err, const char *reason, void *opaque));\nvoid rd_kafka_conf_set_throttle_cb(rd_kafka_conf_t *conf, void (*throttle_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int throttle_time_ms, void *opaque));\nvoid rd_kafka_conf_set_log_cb(rd_kafka_conf_t *conf, void (*log_cb)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));\nvoid rd_kafka_conf_set_stats_cb(rd_kafka_conf_t *conf, int (*stats_cb)(rd_kafka_t *rk, char *json, size_t json_len, void *opaque));\nvoid rd_kafka_conf_set_oauthbearer_token_refresh_cb(rd_kafka_conf_t *conf, void (*oauthbearer_token_refresh_cb)(rd_kafka_t *rk, const char *oauthbearer_config, void *opaque));\nvoid rd_kafka_conf_enable_sasl_queue(rd_kafka_conf_t *conf, int enable);\nvoid rd_kafka_conf_set_socket_cb(rd_kafka_conf_t *conf, int (*socket_cb)(int domain, int type, int protocol, void *opaque));\nvoid rd_kafka_conf_set_connect_cb(rd_kafka_conf_t *conf, int (*connect_cb)(int sockfd, const struct sockaddr *addr, int addrlen, const char *id, void *opaque));\nvoid rd_kafka_conf_set_closesocket_cb(rd_kafka_conf_t *conf, int (*closesocket_cb)(int sockfd, void *opaque));\nstruct addrinfo;\nvoid rd_kafka_conf_set_resolve_cb(rd_kafka_conf_t *conf, int (*resolve_cb)(const char *node, const char *service, const struct addrinfo *hints, struct addrinfo **res, void *opaque));\nrd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert_verify_cb(rd_kafka_conf_t *conf, int (*ssl_cert_verify_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int *x509_error, int depth, const char *buf, size_t size, char *errstr, size_t errstr_size, void *opaque));\ntypedef enum rd_kafka_cert_type_t {\n  RD_KAFKA_CERT_PUBLIC_KEY,\n  RD_KAFKA_CERT_PRIVATE_KEY,\n  RD_KAFKA_CERT_CA,\n  RD_KAFKA_CERT__CNT,\n} rd_kafka_cert_type_t;\ntypedef enum rd_kafka_cert_enc_t {\n  RD_KAFKA_CERT_ENC_PKCS12,\n  RD_KAFKA_CERT_ENC_DER,\n  RD_KAFKA_CERT_ENC_PEM,\n  RD_KAFKA_CERT_ENC__CNT,\n} rd_kafka_cert_enc_t;\nrd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert(rd_kafka_conf_t *conf, rd_kafka_cert_type_t cert_type, rd_kafka_cert_enc_t cert_enc, const void *buffer, size_t size, char *errstr, size_t errstr_size);\nvoid rd_kafka_conf_set_engine_callback_data(rd_kafka_conf_t *conf, void *callback_data);\nvoid rd_kafka_conf_set_opaque(rd_kafka_conf_t *conf, void *opaque);\nvoid *rd_kafka_opaque(const rd_kafka_t *rk);\nvoid rd_kafka_conf_set_default_topic_conf(rd_kafka_conf_t *conf, rd_kafka_topic_conf_t *tconf);\nrd_kafka_topic_conf_t *rd_kafka_conf_get_default_topic_conf(rd_kafka_conf_t *conf);\nrd_kafka_conf_res_t rd_kafka_conf_get(const rd_kafka_conf_t *conf, const char *name, char *dest, size_t *dest_size);\nrd_kafka_conf_res_t rd_kafka_topic_conf_get(const rd_kafka_topic_conf_t *conf, const char *name, char *dest, size_t *dest_size);\nconst char **rd_kafka_conf_dump(rd_kafka_conf_t *conf, size_t *cntp);\nconst char **rd_kafka_topic_conf_dump(rd_kafka_topic_conf_t *conf, size_t *cntp);\nvoid rd_kafka_conf_dump_free(const char **arr, size_t cnt);\nvoid rd_kafka_conf_properties_show(FILE *fp);\nrd_kafka_topic_conf_t *rd_kafka_topic_conf_new(void);\nrd_kafka_topic_conf_t *rd_kafka_topic_conf_dup(const rd_kafka_topic_conf_t *conf);\nrd_kafka_topic_conf_t *rd_kafka_default_topic_conf_dup(rd_kafka_t *rk);\nvoid rd_kafka_topic_conf_destroy(rd_kafka_topic_conf_t *topic_conf);\nrd_kafka_conf_res_t rd_kafka_topic_conf_set(rd_kafka_topic_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);\nvoid rd_kafka_topic_conf_set_opaque(rd_kafka_topic_conf_t *conf, void *rkt_opaque);\nvoid rd_kafka_topic_conf_set_partitioner_cb(rd_kafka_topic_conf_t *topic_conf, int32_t (*partitioner)(const rd_kafka_topic_t *rkt, const void *keydata, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque));\nvoid rd_kafka_topic_conf_set_msg_order_cmp(rd_kafka_topic_conf_t *topic_conf, int (*msg_order_cmp)(const rd_kafka_message_t *a, const rd_kafka_message_t *b));\nint rd_kafka_topic_partition_available(const rd_kafka_topic_t *rkt, int32_t partition);\nint32_t rd_kafka_msg_partitioner_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_consistent(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_consistent_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_murmur2(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_murmur2_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_fnv1a(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_fnv1a_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nrd_kafka_t *rd_kafka_new(rd_kafka_type_t type, rd_kafka_conf_t *conf, char *errstr, size_t errstr_size);\nvoid rd_kafka_destroy(rd_kafka_t *rk);\nvoid rd_kafka_destroy_flags(rd_kafka_t *rk, int flags);\nconst char *rd_kafka_name(const rd_kafka_t *rk);\nrd_kafka_type_t rd_kafka_type(const rd_kafka_t *rk);\nchar *rd_kafka_memberid(const rd_kafka_t *rk);\nchar *rd_kafka_clusterid(rd_kafka_t *rk, int timeout_ms);\nint32_t rd_kafka_controllerid(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_topic_t *rd_kafka_topic_new(rd_kafka_t *rk, const char *topic, rd_kafka_topic_conf_t *conf);\nvoid rd_kafka_topic_destroy(rd_kafka_topic_t *rkt);\nconst char *rd_kafka_topic_name(const rd_kafka_topic_t *rkt);\nvoid *rd_kafka_topic_opaque(const rd_kafka_topic_t *rkt);\nint rd_kafka_poll(rd_kafka_t *rk, int timeout_ms);\nvoid rd_kafka_yield(rd_kafka_t *rk);\nrd_kafka_resp_err_t rd_kafka_pause_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_resp_err_t rd_kafka_resume_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_resp_err_t rd_kafka_query_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high, int timeout_ms);\nrd_kafka_resp_err_t rd_kafka_get_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high);\nrd_kafka_resp_err_t rd_kafka_offsets_for_times(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets, int timeout_ms);\nvoid *rd_kafka_mem_calloc(rd_kafka_t *rk, size_t num, size_t size);\nvoid *rd_kafka_mem_malloc(rd_kafka_t *rk, size_t size);\nvoid rd_kafka_mem_free(rd_kafka_t *rk, void *ptr);\nrd_kafka_queue_t *rd_kafka_queue_new(rd_kafka_t *rk);\nvoid rd_kafka_queue_destroy(rd_kafka_queue_t *rkqu);\nrd_kafka_queue_t *rd_kafka_queue_get_main(rd_kafka_t *rk);\nrd_kafka_queue_t *rd_kafka_queue_get_sasl(rd_kafka_t *rk);\nrd_kafka_error_t *rd_kafka_sasl_background_callbacks_enable(rd_kafka_t *rk);\nrd_kafka_error_t *rd_kafka_sasl_set_credentials(rd_kafka_t *rk, const char *username, const char *password);\nrd_kafka_queue_t *rd_kafka_queue_get_consumer(rd_kafka_t *rk);\nrd_kafka_queue_t *rd_kafka_queue_get_partition(rd_kafka_t *rk, const char *topic, int32_t partition);\nrd_kafka_queue_t *rd_kafka_queue_get_background(rd_kafka_t *rk);\nvoid rd_kafka_queue_forward(rd_kafka_queue_t *src, rd_kafka_queue_t *dst);\nrd_kafka_resp_err_t rd_kafka_set_log_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu);\nsize_t rd_kafka_queue_length(rd_kafka_queue_t *rkqu);\nvoid rd_kafka_queue_io_event_enable(rd_kafka_queue_t *rkqu, int fd, const void *payload, size_t size);\nvoid rd_kafka_queue_cb_event_enable(rd_kafka_queue_t *rkqu, void (*event_cb)(rd_kafka_t *rk, void *qev_opaque), void *qev_opaque);\nvoid rd_kafka_queue_yield(rd_kafka_queue_t *rkqu);\nint rd_kafka_consume_start(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);\nint rd_kafka_consume_start_queue(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, rd_kafka_queue_t *rkqu);\nint rd_kafka_consume_stop(rd_kafka_topic_t *rkt, int32_t partition);\nrd_kafka_resp_err_t rd_kafka_seek(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, int timeout_ms);\nrd_kafka_error_t *rd_kafka_seek_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms);\nrd_kafka_message_t *rd_kafka_consume(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms);\nssize_t rd_kafka_consume_batch(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);\nint rd_kafka_consume_callback(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);\nrd_kafka_message_t *rd_kafka_consume_queue(rd_kafka_queue_t *rkqu, int timeout_ms);\nssize_t rd_kafka_consume_batch_queue(rd_kafka_queue_t *rkqu, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);\nint rd_kafka_consume_callback_queue(rd_kafka_queue_t *rkqu, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);\nrd_kafka_resp_err_t rd_kafka_offset_store(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);\nrd_kafka_resp_err_t rd_kafka_offsets_store(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets);\nrd_kafka_error_t *rd_kafka_offset_store_message(rd_kafka_message_t *rkmessage);\nrd_kafka_resp_err_t rd_kafka_subscribe(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *topics);\nrd_kafka_resp_err_t rd_kafka_unsubscribe(rd_kafka_t *rk);\nrd_kafka_resp_err_t rd_kafka_subscription(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **topics);\nrd_kafka_message_t *rd_kafka_consumer_poll(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_resp_err_t rd_kafka_consumer_close(rd_kafka_t *rk);\nrd_kafka_error_t *rd_kafka_consumer_close_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu);\nint rd_kafka_consumer_closed(rd_kafka_t *rk);\nrd_kafka_error_t *rd_kafka_incremental_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_error_t *rd_kafka_incremental_unassign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);\nconst char *rd_kafka_rebalance_protocol(rd_kafka_t *rk);\nrd_kafka_resp_err_t rd_kafka_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_resp_err_t rd_kafka_assignment(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **partitions);\nint rd_kafka_assignment_lost(rd_kafka_t *rk);\nrd_kafka_resp_err_t rd_kafka_commit(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, int async);\nrd_kafka_resp_err_t rd_kafka_commit_message(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, int async);\nrd_kafka_resp_err_t rd_kafka_commit_queue(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_queue_t *rkqu, void (*cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *commit_opaque), void *commit_opaque);\nrd_kafka_resp_err_t rd_kafka_committed(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms);\nrd_kafka_resp_err_t rd_kafka_position(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata(rd_kafka_t *rk);\nrd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata_new(const char *group_id);\nrd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata_new_with_genid(const char *group_id, int32_t generation_id, const char *member_id, const char *group_instance_id);\nconst char *rd_kafka_consumer_group_metadata_member_id(const rd_kafka_consumer_group_metadata_t *group_metadata);\nvoid rd_kafka_consumer_group_metadata_destroy(rd_kafka_consumer_group_metadata_t *);\nrd_kafka_error_t *rd_kafka_consumer_group_metadata_write(const rd_kafka_consumer_group_metadata_t *cgmd, void **bufferp, size_t *sizep);\nrd_kafka_error_t *rd_kafka_consumer_group_metadata_read(rd_kafka_consumer_group_metadata_t **cgmdp, const void *buffer, size_t size);\nint rd_kafka_produce(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, void *payload, size_t len, const void *key, size_t keylen, void *msg_opaque);\nrd_kafka_resp_err_t rd_kafka_producev(rd_kafka_t *rk, ...);\nrd_kafka_error_t *rd_kafka_produceva(rd_kafka_t *rk, const rd_kafka_vu_t *vus, size_t cnt);\nint rd_kafka_produce_batch(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, rd_kafka_message_t *rkmessages, int message_cnt);\nrd_kafka_resp_err_t rd_kafka_flush(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_resp_err_t rd_kafka_purge(rd_kafka_t *rk, int purge_flags);\ntypedef struct rd_kafka_metadata_broker {\n  int32_t id;\n  char *host;\n  int port;\n} rd_kafka_metadata_broker_t;\ntypedef struct rd_kafka_metadata_partition {\n  int32_t id;\n  rd_kafka_resp_err_t err;\n  int32_t leader;\n  int replica_cnt;\n  int32_t *replicas;\n  int isr_cnt;\n  int32_t *isrs;\n} rd_kafka_metadata_partition_t;\ntypedef struct rd_kafka_metadata_topic {\n  char *topic;\n  int partition_cnt;\n  struct rd_kafka_metadata_partition *partitions;\n  rd_kafka_resp_err_t err;\n} rd_kafka_metadata_topic_t;\ntypedef struct rd_kafka_metadata {\n  int broker_cnt;\n  struct rd_kafka_metadata_broker *brokers;\n  int topic_cnt;\n  struct rd_kafka_metadata_topic *topics;\n  int32_t orig_broker_id;\n  char *orig_broker_name;\n} rd_kafka_metadata_t;\nrd_kafka_resp_err_t rd_kafka_metadata(rd_kafka_t *rk, int all_topics, rd_kafka_topic_t *only_rkt, const struct rd_kafka_metadata **metadatap, int timeout_ms);\nvoid rd_kafka_metadata_destroy(const struct rd_kafka_metadata *metadata);\ntypedef struct rd_kafka_Node_s rd_kafka_Node_t;\nint rd_kafka_Node_id(const rd_kafka_Node_t *node);\nconst char *rd_kafka_Node_host(const rd_kafka_Node_t *node);\nuint16_t rd_kafka_Node_port(const rd_kafka_Node_t *node);\nconst char *rd_kafka_Node_rack(const rd_kafka_Node_t *node);\nstruct rd_kafka_group_member_info {\n  char *member_id;\n  char *client_id;\n  char *client_host;\n  void *member_metadata;\n  int member_metadata_size;\n  void *member_assignment;\n  int member_assignment_size;\n};\ntypedef enum {\n  RD_KAFKA_CONSUMER_GROUP_STATE_UNKNOWN = 0,\n  RD_KAFKA_CONSUMER_GROUP_STATE_PREPARING_REBALANCE = 1,\n  RD_KAFKA_CONSUMER_GROUP_STATE_COMPLETING_REBALANCE = 2,\n  RD_KAFKA_CONSUMER_GROUP_STATE_STABLE = 3,\n  RD_KAFKA_CONSUMER_GROUP_STATE_DEAD = 4,\n  RD_KAFKA_CONSUMER_GROUP_STATE_EMPTY = 5,\n  RD_KAFKA_CONSUMER_GROUP_STATE__CNT,\n} rd_kafka_consumer_group_state_t;\nstruct rd_kafka_group_info {\n  struct rd_kafka_metadata_broker broker;\n  char *group;\n  rd_kafka_resp_err_t err;\n  char *state;\n  char *protocol_type;\n  char *protocol;\n  struct rd_kafka_group_member_info *members;\n  int member_cnt;\n};\nstruct rd_kafka_group_list {\n  struct rd_kafka_group_info *groups;\n  int group_cnt;\n};\nrd_kafka_resp_err_t rd_kafka_list_groups(rd_kafka_t *rk, const char *group, const struct rd_kafka_group_list **grplistp, int timeout_ms);\nconst char *rd_kafka_consumer_group_state_name(rd_kafka_consumer_group_state_t state);\nrd_kafka_consumer_group_state_t rd_kafka_consumer_group_state_code(const char *name);\nvoid rd_kafka_group_list_destroy(const struct rd_kafka_group_list *grplist);\nint rd_kafka_brokers_add(rd_kafka_t *rk, const char *brokerlist);\nvoid rd_kafka_set_logger(rd_kafka_t *rk, void (*func)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));\nvoid rd_kafka_set_log_level(rd_kafka_t *rk, int level);\nvoid rd_kafka_log_print(const rd_kafka_t *rk, int level, const char *fac, const char *buf);\nvoid rd_kafka_log_syslog(const rd_kafka_t *rk, int level, const char *fac, const char *buf);\nint rd_kafka_outq_len(rd_kafka_t *rk);\nvoid rd_kafka_dump(FILE *fp, rd_kafka_t *rk);\nint rd_kafka_thread_cnt(void);\ntypedef enum rd_kafka_thread_type_t {\n  RD_KAFKA_THREAD_MAIN,\n  RD_KAFKA_THREAD_BACKGROUND,\n  RD_KAFKA_THREAD_BROKER,\n} rd_kafka_thread_type_t;\nint rd_kafka_wait_destroyed(int timeout_ms);\nint rd_kafka_unittest(void);\nrd_kafka_resp_err_t rd_kafka_poll_set_consumer(rd_kafka_t *rk);\ntypedef int rd_kafka_event_type_t;\nrd_kafka_event_type_t rd_kafka_event_type(const rd_kafka_event_t *rkev);\nconst char *rd_kafka_event_name(const rd_kafka_event_t *rkev);\nvoid rd_kafka_event_destroy(rd_kafka_event_t *rkev);\nconst rd_kafka_message_t *rd_kafka_event_message_next(rd_kafka_event_t *rkev);\nsize_t rd_kafka_event_message_array(rd_kafka_event_t *rkev, const rd_kafka_message_t **rkmessages, size_t size);\nsize_t rd_kafka_event_message_count(rd_kafka_event_t *rkev);\nconst char *rd_kafka_event_config_string(rd_kafka_event_t *rkev);\nrd_kafka_resp_err_t rd_kafka_event_error(rd_kafka_event_t *rkev);\nconst char *rd_kafka_event_error_string(rd_kafka_event_t *rkev);\nint rd_kafka_event_error_is_fatal(rd_kafka_event_t *rkev);\nvoid *rd_kafka_event_opaque(rd_kafka_event_t *rkev);\nint rd_kafka_event_log(rd_kafka_event_t *rkev, const char **fac, const char **str, int *level);\nint rd_kafka_event_debug_contexts(rd_kafka_event_t *rkev, char *dst, size_t dstsize);\nconst char *rd_kafka_event_stats(rd_kafka_event_t *rkev);\nrd_kafka_topic_partition_list_t *rd_kafka_event_topic_partition_list(rd_kafka_event_t *rkev);\nrd_kafka_topic_partition_t *rd_kafka_event_topic_partition(rd_kafka_event_t *rkev);\ntypedef rd_kafka_event_t rd_kafka_CreateTopics_result_t;\ntypedef rd_kafka_event_t rd_kafka_DeleteTopics_result_t;\ntypedef rd_kafka_event_t rd_kafka_CreateAcls_result_t;\ntypedef rd_kafka_event_t rd_kafka_DescribeAcls_result_t;\ntypedef rd_kafka_event_t rd_kafka_DeleteAcls_result_t;\ntypedef rd_kafka_event_t rd_kafka_CreatePartitions_result_t;\ntypedef rd_kafka_event_t rd_kafka_AlterConfigs_result_t;\ntypedef rd_kafka_event_t rd_kafka_IncrementalAlterConfigs_result_t;\ntypedef rd_kafka_event_t rd_kafka_DescribeConfigs_result_t;\ntypedef rd_kafka_event_t rd_kafka_DeleteRecords_result_t;\ntypedef rd_kafka_event_t rd_kafka_ListConsumerGroups_result_t;\ntypedef rd_kafka_event_t rd_kafka_DescribeConsumerGroups_result_t;\ntypedef rd_kafka_event_t rd_kafka_DeleteGroups_result_t;\ntypedef rd_kafka_event_t rd_kafka_DeleteConsumerGroupOffsets_result_t;\ntypedef rd_kafka_event_t rd_kafka_AlterConsumerGroupOffsets_result_t;\ntypedef rd_kafka_event_t rd_kafka_ListConsumerGroupOffsets_result_t;\ntypedef rd_kafka_event_t rd_kafka_DescribeTopics_result_t;\ntypedef rd_kafka_event_t rd_kafka_DescribeCluster_result_t;\ntypedef rd_kafka_event_t rd_kafka_DescribeUserScramCredentials_result_t;\ntypedef rd_kafka_event_t rd_kafka_AlterUserScramCredentials_result_t;\ntypedef rd_kafka_event_t rd_kafka_ListOffsets_result_t;\nconst rd_kafka_CreateTopics_result_t *rd_kafka_event_CreateTopics_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DeleteTopics_result_t *rd_kafka_event_DeleteTopics_result(rd_kafka_event_t *rkev);\nconst rd_kafka_CreatePartitions_result_t *rd_kafka_event_CreatePartitions_result(rd_kafka_event_t *rkev);\nconst rd_kafka_AlterConfigs_result_t *rd_kafka_event_AlterConfigs_result(rd_kafka_event_t *rkev);\nconst rd_kafka_IncrementalAlterConfigs_result_t *rd_kafka_event_IncrementalAlterConfigs_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DescribeConfigs_result_t *rd_kafka_event_DescribeConfigs_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DeleteRecords_result_t *rd_kafka_event_DeleteRecords_result(rd_kafka_event_t *rkev);\nconst rd_kafka_ListConsumerGroups_result_t *rd_kafka_event_ListConsumerGroups_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DescribeConsumerGroups_result_t *rd_kafka_event_DescribeConsumerGroups_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DescribeTopics_result_t *rd_kafka_event_DescribeTopics_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DescribeCluster_result_t *rd_kafka_event_DescribeCluster_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DeleteGroups_result_t *rd_kafka_event_DeleteGroups_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DeleteConsumerGroupOffsets_result_t *rd_kafka_event_DeleteConsumerGroupOffsets_result(rd_kafka_event_t *rkev);\nconst rd_kafka_CreateAcls_result_t *rd_kafka_event_CreateAcls_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DescribeAcls_result_t *rd_kafka_event_DescribeAcls_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DeleteAcls_result_t *rd_kafka_event_DeleteAcls_result(rd_kafka_event_t *rkev);\nconst rd_kafka_ListConsumerGroupOffsets_result_t *rd_kafka_event_ListConsumerGroupOffsets_result(rd_kafka_event_t *rkev);\nconst rd_kafka_AlterConsumerGroupOffsets_result_t *rd_kafka_event_AlterConsumerGroupOffsets_result(rd_kafka_event_t *rkev);\nconst rd_kafka_ListOffsets_result_t *rd_kafka_event_ListOffsets_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DescribeUserScramCredentials_result_t *rd_kafka_event_DescribeUserScramCredentials_result(rd_kafka_event_t *rkev);\nconst rd_kafka_AlterUserScramCredentials_result_t *rd_kafka_event_AlterUserScramCredentials_result(rd_kafka_event_t *rkev);\nrd_kafka_event_t *rd_kafka_queue_poll(rd_kafka_queue_t *rkqu, int timeout_ms);\nint rd_kafka_queue_poll_callback(rd_kafka_queue_t *rkqu, int timeout_ms);\ntypedef rd_kafka_resp_err_t (rd_kafka_plugin_f_conf_init_t)(rd_kafka_conf_t *conf, void **plug_opaquep, char *errstr, size_t errstr_size);\ntypedef rd_kafka_conf_res_t (rd_kafka_interceptor_f_on_conf_set_t)(rd_kafka_conf_t *conf, const char *name, const char *val, char *errstr, size_t errstr_size, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_dup_t)(rd_kafka_conf_t *new_conf, const rd_kafka_conf_t *old_conf, size_t filter_cnt, const char **filter, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_destroy_t)(void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_new_t)(rd_kafka_t *rk, const rd_kafka_conf_t *conf, void *ic_opaque, char *errstr, size_t errstr_size);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_destroy_t)(rd_kafka_t *rk, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_send_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_acknowledgement_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_consume_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_commit_t)(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_resp_err_t err, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_request_sent_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_response_received_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, int64_t rtt, rd_kafka_resp_err_t err, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_start_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_exit_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_broker_state_change_t)(rd_kafka_t *rk, int32_t broker_id, const char *secproto, const char *name, int port, const char *state, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_set(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_set_t *on_conf_set, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_dup(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_dup_t *on_conf_dup, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_destroy(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_destroy_t *on_conf_destroy, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_new(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_new_t *on_new, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_destroy(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_destroy_t *on_destroy, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_send(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_send_t *on_send, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_acknowledgement(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_acknowledgement_t *on_acknowledgement, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_consume(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_consume_t *on_consume, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_commit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_commit_t *on_commit, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_request_sent(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_request_sent_t *on_request_sent, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_response_received(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_response_received_t *on_response_received, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_start(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_start_t *on_thread_start, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_exit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_exit_t *on_thread_exit, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_broker_state_change(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_broker_state_change_t *on_broker_state_change, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_topic_result_error(const rd_kafka_topic_result_t *topicres);\nconst char *rd_kafka_topic_result_error_string(const rd_kafka_topic_result_t *topicres);\nconst char *rd_kafka_topic_result_name(const rd_kafka_topic_result_t *topicres);\nconst rd_kafka_error_t *rd_kafka_group_result_error(const rd_kafka_group_result_t *groupres);\nconst char *rd_kafka_group_result_name(const rd_kafka_group_result_t *groupres);\nconst rd_kafka_topic_partition_list_t *rd_kafka_group_result_partitions(const rd_kafka_group_result_t *groupres);\ntypedef enum rd_kafka_admin_op_t {\n  RD_KAFKA_ADMIN_OP_ANY = 0,\n  RD_KAFKA_ADMIN_OP_CREATETOPICS,\n  RD_KAFKA_ADMIN_OP_DELETETOPICS,\n  RD_KAFKA_ADMIN_OP_CREATEPARTITIONS,\n  RD_KAFKA_ADMIN_OP_ALTERCONFIGS,\n  RD_KAFKA_ADMIN_OP_DESCRIBECONFIGS,\n  RD_KAFKA_ADMIN_OP_DELETERECORDS,\n  RD_KAFKA_ADMIN_OP_DELETEGROUPS,\n  RD_KAFKA_ADMIN_OP_DELETECONSUMERGROUPOFFSETS,\n  RD_KAFKA_ADMIN_OP_CREATEACLS,\n  RD_KAFKA_ADMIN_OP_DESCRIBEACLS,\n  RD_KAFKA_ADMIN_OP_DELETEACLS,\n  RD_KAFKA_ADMIN_OP_LISTCONSUMERGROUPS,\n  RD_KAFKA_ADMIN_OP_DESCRIBECONSUMERGROUPS,\n  RD_KAFKA_ADMIN_OP_LISTCONSUMERGROUPOFFSETS,\n  RD_KAFKA_ADMIN_OP_ALTERCONSUMERGROUPOFFSETS,\n  RD_KAFKA_ADMIN_OP_INCREMENTALALTERCONFIGS,\n  RD_KAFKA_ADMIN_OP_DESCRIBEUSERSCRAMCREDENTIALS,\n  RD_KAFKA_ADMIN_OP_ALTERUSERSCRAMCREDENTIALS,\n  RD_KAFKA_ADMIN_OP_DESCRIBETOPICS,\n  RD_KAFKA_ADMIN_OP_DESCRIBECLUSTER,\n  RD_KAFKA_ADMIN_OP_LISTOFFSETS,\n  RD_KAFKA_ADMIN_OP__CNT,\n} rd_kafka_admin_op_t;\ntypedef struct rd_kafka_AdminOptions_s rd_kafka_AdminOptions_t;\ntypedef enum rd_kafka_IsolationLevel_t {\n  RD_KAFKA_ISOLATION_LEVEL_READ_UNCOMMITTED = 0,\n  RD_KAFKA_ISOLATION_LEVEL_READ_COMMITTED = 1,\n} rd_kafka_IsolationLevel_t;\nrd_kafka_AdminOptions_t *rd_kafka_AdminOptions_new(rd_kafka_t *rk, rd_kafka_admin_op_t for_api);\nvoid rd_kafka_AdminOptions_destroy(rd_kafka_AdminOptions_t *options);\nrd_kafka_resp_err_t rd_kafka_AdminOptions_set_request_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_AdminOptions_set_operation_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_AdminOptions_set_validate_only(rd_kafka_AdminOptions_t *options, int true_or_false, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_AdminOptions_set_broker(rd_kafka_AdminOptions_t *options, int32_t broker_id, char *errstr, size_t errstr_size);\nrd_kafka_error_t *rd_kafka_AdminOptions_set_require_stable_offsets(rd_kafka_AdminOptions_t *options, int true_or_false);\nrd_kafka_error_t *rd_kafka_AdminOptions_set_include_authorized_operations(rd_kafka_AdminOptions_t *options, int true_or_false);\nrd_kafka_error_t *rd_kafka_AdminOptions_set_match_consumer_group_states(rd_kafka_AdminOptions_t *options, const rd_kafka_consumer_group_state_t *consumer_group_states, size_t consumer_group_states_cnt);\nrd_kafka_error_t *rd_kafka_AdminOptions_set_isolation_level(rd_kafka_AdminOptions_t *options, rd_kafka_IsolationLevel_t value);\nvoid rd_kafka_AdminOptions_set_opaque(rd_kafka_AdminOptions_t *options, void *ev_opaque);\ntypedef enum rd_kafka_AclOperation_t {\n  RD_KAFKA_ACL_OPERATION_UNKNOWN = 0,\n  RD_KAFKA_ACL_OPERATION_ANY = 1,\n  RD_KAFKA_ACL_OPERATION_ALL = 2,\n  RD_KAFKA_ACL_OPERATION_READ = 3,\n  RD_KAFKA_ACL_OPERATION_WRITE = 4,\n  RD_KAFKA_ACL_OPERATION_CREATE = 5,\n  RD_KAFKA_ACL_OPERATION_DELETE = 6,\n  RD_KAFKA_ACL_OPERATION_ALTER = 7,\n  RD_KAFKA_ACL_OPERATION_DESCRIBE = 8,\n  RD_KAFKA_ACL_OPERATION_CLUSTER_ACTION = 9,\n  RD_KAFKA_ACL_OPERATION_DESCRIBE_CONFIGS = 10,\n  RD_KAFKA_ACL_OPERATION_ALTER_CONFIGS = 11,\n  RD_KAFKA_ACL_OPERATION_IDEMPOTENT_WRITE = 12,\n  RD_KAFKA_ACL_OPERATION__CNT,\n} rd_kafka_AclOperation_t;\ntypedef struct rd_kafka_NewTopic_s rd_kafka_NewTopic_t;\nrd_kafka_NewTopic_t *rd_kafka_NewTopic_new(const char *topic, int num_partitions, int replication_factor, char *errstr, size_t errstr_size);\nvoid rd_kafka_NewTopic_destroy(rd_kafka_NewTopic_t *new_topic);\nvoid rd_kafka_NewTopic_destroy_array(rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt);\nrd_kafka_resp_err_t rd_kafka_NewTopic_set_replica_assignment(rd_kafka_NewTopic_t *new_topic, int32_t partition, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_NewTopic_set_config(rd_kafka_NewTopic_t *new_topic, const char *name, const char *value);\nvoid rd_kafka_CreateTopics(rd_kafka_t *rk, rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_topic_result_t **rd_kafka_CreateTopics_result_topics(const rd_kafka_CreateTopics_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_DeleteTopic_s rd_kafka_DeleteTopic_t;\nrd_kafka_DeleteTopic_t *rd_kafka_DeleteTopic_new(const char *topic);\nvoid rd_kafka_DeleteTopic_destroy(rd_kafka_DeleteTopic_t *del_topic);\nvoid rd_kafka_DeleteTopic_destroy_array(rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt);\nvoid rd_kafka_DeleteTopics(rd_kafka_t *rk, rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_topic_result_t **rd_kafka_DeleteTopics_result_topics(const rd_kafka_DeleteTopics_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_NewPartitions_s rd_kafka_NewPartitions_t;\nrd_kafka_NewPartitions_t *rd_kafka_NewPartitions_new(const char *topic, size_t new_total_cnt, char *errstr, size_t errstr_size);\nvoid rd_kafka_NewPartitions_destroy(rd_kafka_NewPartitions_t *new_parts);\nvoid rd_kafka_NewPartitions_destroy_array(rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt);\nrd_kafka_resp_err_t rd_kafka_NewPartitions_set_replica_assignment(rd_kafka_NewPartitions_t *new_parts, int32_t new_partition_idx, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);\nvoid rd_kafka_CreatePartitions(rd_kafka_t *rk, rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_topic_result_t **rd_kafka_CreatePartitions_result_topics(const rd_kafka_CreatePartitions_result_t *result, size_t *cntp);\ntypedef enum rd_kafka_ConfigSource_t {\n  RD_KAFKA_CONFIG_SOURCE_UNKNOWN_CONFIG = 0,\n  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_TOPIC_CONFIG = 1,\n  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_BROKER_CONFIG = 2,\n  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_DEFAULT_BROKER_CONFIG = 3,\n  RD_KAFKA_CONFIG_SOURCE_STATIC_BROKER_CONFIG = 4,\n  RD_KAFKA_CONFIG_SOURCE_DEFAULT_CONFIG = 5,\n  RD_KAFKA_CONFIG_SOURCE__CNT,\n} rd_kafka_ConfigSource_t;\nconst char *rd_kafka_ConfigSource_name(rd_kafka_ConfigSource_t confsource);\ntypedef struct rd_kafka_ConfigEntry_s rd_kafka_ConfigEntry_t;\nconst char *rd_kafka_ConfigEntry_name(const rd_kafka_ConfigEntry_t *entry);\nconst char *rd_kafka_ConfigEntry_value(const rd_kafka_ConfigEntry_t *entry);\nrd_kafka_ConfigSource_t rd_kafka_ConfigEntry_source(const rd_kafka_ConfigEntry_t *entry);\nint rd_kafka_ConfigEntry_is_read_only(const rd_kafka_ConfigEntry_t *entry);\nint rd_kafka_ConfigEntry_is_default(const rd_kafka_ConfigEntry_t *entry);\nint rd_kafka_ConfigEntry_is_sensitive(const rd_kafka_ConfigEntry_t *entry);\nint rd_kafka_ConfigEntry_is_synonym(const rd_kafka_ConfigEntry_t *entry);\nconst rd_kafka_ConfigEntry_t **rd_kafka_ConfigEntry_synonyms(const rd_kafka_ConfigEntry_t *entry, size_t *cntp);\ntypedef enum rd_kafka_ResourceType_t {\n  RD_KAFKA_RESOURCE_UNKNOWN = 0,\n  RD_KAFKA_RESOURCE_ANY = 1,\n  RD_KAFKA_RESOURCE_TOPIC = 2,\n  RD_KAFKA_RESOURCE_GROUP = 3,\n  RD_KAFKA_RESOURCE_BROKER = 4,\n  RD_KAFKA_RESOURCE__CNT,\n} rd_kafka_ResourceType_t;\ntypedef enum rd_kafka_ResourcePatternType_t {\n  RD_KAFKA_RESOURCE_PATTERN_UNKNOWN = 0,\n  RD_KAFKA_RESOURCE_PATTERN_ANY = 1,\n  RD_KAFKA_RESOURCE_PATTERN_MATCH = 2,\n  RD_KAFKA_RESOURCE_PATTERN_LITERAL = 3,\n  RD_KAFKA_RESOURCE_PATTERN_PREFIXED = 4,\n  RD_KAFKA_RESOURCE_PATTERN_TYPE__CNT,\n} rd_kafka_ResourcePatternType_t;\ntypedef enum rd_kafka_AlterConfigOpType_t {\n  RD_KAFKA_ALTER_CONFIG_OP_TYPE_SET = 0,\n  RD_KAFKA_ALTER_CONFIG_OP_TYPE_DELETE = 1,\n  RD_KAFKA_ALTER_CONFIG_OP_TYPE_APPEND = 2,\n  RD_KAFKA_ALTER_CONFIG_OP_TYPE_SUBTRACT = 3,\n  RD_KAFKA_ALTER_CONFIG_OP_TYPE__CNT,\n} rd_kafka_AlterConfigOpType_t;\nconst char *rd_kafka_ResourcePatternType_name(rd_kafka_ResourcePatternType_t resource_pattern_type);\nconst char *rd_kafka_ResourceType_name(rd_kafka_ResourceType_t restype);\ntypedef struct rd_kafka_ConfigResource_s rd_kafka_ConfigResource_t;\nrd_kafka_ConfigResource_t *rd_kafka_ConfigResource_new(rd_kafka_ResourceType_t restype, const char *resname);\nvoid rd_kafka_ConfigResource_destroy(rd_kafka_ConfigResource_t *config);\nvoid rd_kafka_ConfigResource_destroy_array(rd_kafka_ConfigResource_t **config, size_t config_cnt);\nrd_kafka_resp_err_t rd_kafka_ConfigResource_set_config(rd_kafka_ConfigResource_t *config, const char *name, const char *value);\nrd_kafka_error_t *rd_kafka_ConfigResource_add_incremental_config(rd_kafka_ConfigResource_t *config, const char *name, rd_kafka_AlterConfigOpType_t op_type, const char *value);\nconst rd_kafka_ConfigEntry_t **rd_kafka_ConfigResource_configs(const rd_kafka_ConfigResource_t *config, size_t *cntp);\nrd_kafka_ResourceType_t rd_kafka_ConfigResource_type(const rd_kafka_ConfigResource_t *config);\nconst char *rd_kafka_ConfigResource_name(const rd_kafka_ConfigResource_t *config);\nrd_kafka_resp_err_t rd_kafka_ConfigResource_error(const rd_kafka_ConfigResource_t *config);\nconst char *rd_kafka_ConfigResource_error_string(const rd_kafka_ConfigResource_t *config);\nvoid rd_kafka_AlterConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_ConfigResource_t **rd_kafka_AlterConfigs_result_resources(const rd_kafka_AlterConfigs_result_t *result, size_t *cntp);\nvoid rd_kafka_IncrementalAlterConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_ConfigResource_t **rd_kafka_IncrementalAlterConfigs_result_resources(const rd_kafka_IncrementalAlterConfigs_result_t *result, size_t *cntp);\nvoid rd_kafka_DescribeConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_ConfigResource_t **rd_kafka_DescribeConfigs_result_resources(const rd_kafka_DescribeConfigs_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_DeleteRecords_s rd_kafka_DeleteRecords_t;\nrd_kafka_DeleteRecords_t *rd_kafka_DeleteRecords_new(const rd_kafka_topic_partition_list_t *before_offsets);\nvoid rd_kafka_DeleteRecords_destroy(rd_kafka_DeleteRecords_t *del_records);\nvoid rd_kafka_DeleteRecords_destroy_array(rd_kafka_DeleteRecords_t **del_records, size_t del_record_cnt);\nvoid rd_kafka_DeleteRecords(rd_kafka_t *rk, rd_kafka_DeleteRecords_t **del_records, size_t del_record_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_topic_partition_list_t *rd_kafka_DeleteRecords_result_offsets(const rd_kafka_DeleteRecords_result_t *result);\ntypedef struct rd_kafka_TopicCollection_s rd_kafka_TopicCollection_t;\ntypedef struct rd_kafka_TopicPartitionInfo_s rd_kafka_TopicPartitionInfo_t;\ntypedef struct rd_kafka_TopicDescription_s rd_kafka_TopicDescription_t;\nrd_kafka_TopicCollection_t *rd_kafka_TopicCollection_of_topic_names(const char **topics, size_t topics_cnt);\nvoid rd_kafka_TopicCollection_destroy(rd_kafka_TopicCollection_t *topics);\nvoid rd_kafka_DescribeTopics(rd_kafka_t *rk, const rd_kafka_TopicCollection_t *topics, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_TopicDescription_t **rd_kafka_DescribeTopics_result_topics(const rd_kafka_DescribeTopics_result_t *result, size_t *cntp);\nconst rd_kafka_TopicPartitionInfo_t **rd_kafka_TopicDescription_partitions(const rd_kafka_TopicDescription_t *topicdesc, size_t *cntp);\nconst int rd_kafka_TopicPartitionInfo_partition(const rd_kafka_TopicPartitionInfo_t *partition);\nconst rd_kafka_Node_t *rd_kafka_TopicPartitionInfo_leader(const rd_kafka_TopicPartitionInfo_t *partition);\nconst rd_kafka_Node_t **rd_kafka_TopicPartitionInfo_isr(const rd_kafka_TopicPartitionInfo_t *partition, size_t *cntp);\nconst rd_kafka_Node_t **rd_kafka_TopicPartitionInfo_replicas(const rd_kafka_TopicPartitionInfo_t *partition, size_t *cntp);\nconst rd_kafka_AclOperation_t *rd_kafka_TopicDescription_authorized_operations(const rd_kafka_TopicDescription_t *topicdesc, size_t *cntp);\nconst char *rd_kafka_TopicDescription_name(const rd_kafka_TopicDescription_t *topicdesc);\nconst rd_kafka_Uuid_t *rd_kafka_TopicDescription_topic_id(const rd_kafka_TopicDescription_t *topicdesc);\nint rd_kafka_TopicDescription_is_internal(const rd_kafka_TopicDescription_t *topicdesc);\nconst rd_kafka_error_t *rd_kafka_TopicDescription_error(const rd_kafka_TopicDescription_t *topicdesc);\nvoid rd_kafka_DescribeCluster(rd_kafka_t *rk, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_Node_t **rd_kafka_DescribeCluster_result_nodes(const rd_kafka_DescribeCluster_result_t *result, size_t *cntp);\nconst rd_kafka_AclOperation_t *rd_kafka_DescribeCluster_result_authorized_operations(const rd_kafka_DescribeCluster_result_t *result, size_t *cntp);\nconst rd_kafka_Node_t *rd_kafka_DescribeCluster_result_controller(const rd_kafka_DescribeCluster_result_t *result);\nconst char *rd_kafka_DescribeCluster_result_cluster_id(const rd_kafka_DescribeCluster_result_t *result);\ntypedef struct rd_kafka_ConsumerGroupListing_s rd_kafka_ConsumerGroupListing_t;\ntypedef struct rd_kafka_ListConsumerGroupsResult_s rd_kafka_ListConsumerGroupsResult_t;\nvoid rd_kafka_ListConsumerGroups(rd_kafka_t *rk, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst char *rd_kafka_ConsumerGroupListing_group_id(const rd_kafka_ConsumerGroupListing_t *grplist);\nint rd_kafka_ConsumerGroupListing_is_simple_consumer_group(const rd_kafka_ConsumerGroupListing_t *grplist);\nrd_kafka_consumer_group_state_t rd_kafka_ConsumerGroupListing_state(const rd_kafka_ConsumerGroupListing_t *grplist);\nconst rd_kafka_ConsumerGroupListing_t **rd_kafka_ListConsumerGroups_result_valid(const rd_kafka_ListConsumerGroups_result_t *result, size_t *cntp);\nconst rd_kafka_error_t **rd_kafka_ListConsumerGroups_result_errors(const rd_kafka_ListConsumerGroups_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_ConsumerGroupDescription_s rd_kafka_ConsumerGroupDescription_t;\ntypedef struct rd_kafka_MemberDescription_s rd_kafka_MemberDescription_t;\ntypedef struct rd_kafka_MemberAssignment_s rd_kafka_MemberAssignment_t;\nvoid rd_kafka_DescribeConsumerGroups(rd_kafka_t *rk, const char **groups, size_t groups_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_ConsumerGroupDescription_t **rd_kafka_DescribeConsumerGroups_result_groups(const rd_kafka_DescribeConsumerGroups_result_t *result, size_t *cntp);\nconst char *rd_kafka_ConsumerGroupDescription_group_id(const rd_kafka_ConsumerGroupDescription_t *grpdesc);\nconst rd_kafka_error_t *rd_kafka_ConsumerGroupDescription_error(const rd_kafka_ConsumerGroupDescription_t *grpdesc);\nint rd_kafka_ConsumerGroupDescription_is_simple_consumer_group(const rd_kafka_ConsumerGroupDescription_t *grpdesc);\nconst char *rd_kafka_ConsumerGroupDescription_partition_assignor(const rd_kafka_ConsumerGroupDescription_t *grpdesc);\nconst rd_kafka_AclOperation_t *rd_kafka_ConsumerGroupDescription_authorized_operations(const rd_kafka_ConsumerGroupDescription_t *grpdesc, size_t *cntp);\nrd_kafka_consumer_group_state_t rd_kafka_ConsumerGroupDescription_state(const rd_kafka_ConsumerGroupDescription_t *grpdesc);\nconst rd_kafka_Node_t *rd_kafka_ConsumerGroupDescription_coordinator(const rd_kafka_ConsumerGroupDescription_t *grpdesc);\nsize_t rd_kafka_ConsumerGroupDescription_member_count(const rd_kafka_ConsumerGroupDescription_t *grpdesc);\nconst rd_kafka_MemberDescription_t *rd_kafka_ConsumerGroupDescription_member(const rd_kafka_ConsumerGroupDescription_t *grpdesc, size_t idx);\nconst char *rd_kafka_MemberDescription_client_id(const rd_kafka_MemberDescription_t *member);\nconst char *rd_kafka_MemberDescription_group_instance_id(const rd_kafka_MemberDescription_t *member);\nconst char *rd_kafka_MemberDescription_consumer_id(const rd_kafka_MemberDescription_t *member);\nconst char *rd_kafka_MemberDescription_host(const rd_kafka_MemberDescription_t *member);\nconst rd_kafka_MemberAssignment_t *rd_kafka_MemberDescription_assignment(const rd_kafka_MemberDescription_t *member);\nconst rd_kafka_topic_partition_list_t *rd_kafka_MemberAssignment_partitions(const rd_kafka_MemberAssignment_t *assignment);\ntypedef struct rd_kafka_DeleteGroup_s rd_kafka_DeleteGroup_t;\nrd_kafka_DeleteGroup_t *rd_kafka_DeleteGroup_new(const char *group);\nvoid rd_kafka_DeleteGroup_destroy(rd_kafka_DeleteGroup_t *del_group);\nvoid rd_kafka_DeleteGroup_destroy_array(rd_kafka_DeleteGroup_t **del_groups, size_t del_group_cnt);\nvoid rd_kafka_DeleteGroups(rd_kafka_t *rk, rd_kafka_DeleteGroup_t **del_groups, size_t del_group_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_group_result_t **rd_kafka_DeleteGroups_result_groups(const rd_kafka_DeleteGroups_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_ListConsumerGroupOffsets_s rd_kafka_ListConsumerGroupOffsets_t;\nrd_kafka_ListConsumerGroupOffsets_t *rd_kafka_ListConsumerGroupOffsets_new(const char *group_id, const rd_kafka_topic_partition_list_t *partitions);\nvoid rd_kafka_ListConsumerGroupOffsets_destroy(rd_kafka_ListConsumerGroupOffsets_t *list_grpoffsets);\nvoid rd_kafka_ListConsumerGroupOffsets_destroy_array(rd_kafka_ListConsumerGroupOffsets_t **list_grpoffsets, size_t list_grpoffset_cnt);\nvoid rd_kafka_ListConsumerGroupOffsets(rd_kafka_t *rk, rd_kafka_ListConsumerGroupOffsets_t **list_grpoffsets, size_t list_grpoffsets_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_group_result_t **rd_kafka_ListConsumerGroupOffsets_result_groups(const rd_kafka_ListConsumerGroupOffsets_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_AlterConsumerGroupOffsets_s rd_kafka_AlterConsumerGroupOffsets_t;\nrd_kafka_AlterConsumerGroupOffsets_t *rd_kafka_AlterConsumerGroupOffsets_new(const char *group_id, const rd_kafka_topic_partition_list_t *partitions);\nvoid rd_kafka_AlterConsumerGroupOffsets_destroy(rd_kafka_AlterConsumerGroupOffsets_t *alter_grpoffsets);\nvoid rd_kafka_AlterConsumerGroupOffsets_destroy_array(rd_kafka_AlterConsumerGroupOffsets_t **alter_grpoffsets, size_t alter_grpoffset_cnt);\nvoid rd_kafka_AlterConsumerGroupOffsets(rd_kafka_t *rk, rd_kafka_AlterConsumerGroupOffsets_t **alter_grpoffsets, size_t alter_grpoffsets_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_group_result_t **rd_kafka_AlterConsumerGroupOffsets_result_groups(const rd_kafka_AlterConsumerGroupOffsets_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_DeleteConsumerGroupOffsets_s rd_kafka_DeleteConsumerGroupOffsets_t;\nrd_kafka_DeleteConsumerGroupOffsets_t *rd_kafka_DeleteConsumerGroupOffsets_new(const char *group, const rd_kafka_topic_partition_list_t *partitions);\nvoid rd_kafka_DeleteConsumerGroupOffsets_destroy(rd_kafka_DeleteConsumerGroupOffsets_t *del_grpoffsets);\nvoid rd_kafka_DeleteConsumerGroupOffsets_destroy_array(rd_kafka_DeleteConsumerGroupOffsets_t **del_grpoffsets, size_t del_grpoffset_cnt);\nvoid rd_kafka_DeleteConsumerGroupOffsets(rd_kafka_t *rk, rd_kafka_DeleteConsumerGroupOffsets_t **del_grpoffsets, size_t del_grpoffsets_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_group_result_t **rd_kafka_DeleteConsumerGroupOffsets_result_groups(const rd_kafka_DeleteConsumerGroupOffsets_result_t *result, size_t *cntp);\ntypedef enum rd_kafka_OffsetSpec_t {\n  RD_KAFKA_OFFSET_SPEC_MAX_TIMESTAMP = (- 3),\n  RD_KAFKA_OFFSET_SPEC_EARLIEST = (- 2),\n  RD_KAFKA_OFFSET_SPEC_LATEST = (- 1),\n} rd_kafka_OffsetSpec_t;\ntypedef struct rd_kafka_ListOffsetsResultInfo_s rd_kafka_ListOffsetsResultInfo_t;\nconst rd_kafka_topic_partition_t *rd_kafka_ListOffsetsResultInfo_topic_partition(const rd_kafka_ListOffsetsResultInfo_t *result_info);\nint64_t rd_kafka_ListOffsetsResultInfo_timestamp(const rd_kafka_ListOffsetsResultInfo_t *result_info);\nconst rd_kafka_ListOffsetsResultInfo_t **rd_kafka_ListOffsets_result_infos(const rd_kafka_ListOffsets_result_t *result, size_t *cntp);\nvoid rd_kafka_ListOffsets(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *topic_partitions, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\ntypedef enum rd_kafka_ScramMechanism_t {\n  RD_KAFKA_SCRAM_MECHANISM_UNKNOWN = 0,\n  RD_KAFKA_SCRAM_MECHANISM_SHA_256 = 1,\n  RD_KAFKA_SCRAM_MECHANISM_SHA_512 = 2,\n  RD_KAFKA_SCRAM_MECHANISM__CNT,\n} rd_kafka_ScramMechanism_t;\ntypedef struct rd_kafka_ScramCredentialInfo_s rd_kafka_ScramCredentialInfo_t;\nrd_kafka_ScramMechanism_t rd_kafka_ScramCredentialInfo_mechanism(const rd_kafka_ScramCredentialInfo_t *scram_credential_info);\nint32_t rd_kafka_ScramCredentialInfo_iterations(const rd_kafka_ScramCredentialInfo_t *scram_credential_info);\ntypedef struct rd_kafka_UserScramCredentialsDescription_s rd_kafka_UserScramCredentialsDescription_t;\nconst char *rd_kafka_UserScramCredentialsDescription_user(const rd_kafka_UserScramCredentialsDescription_t *description);\nconst rd_kafka_error_t *rd_kafka_UserScramCredentialsDescription_error(const rd_kafka_UserScramCredentialsDescription_t *description);\nsize_t rd_kafka_UserScramCredentialsDescription_scramcredentialinfo_count(const rd_kafka_UserScramCredentialsDescription_t *description);\nconst rd_kafka_ScramCredentialInfo_t *rd_kafka_UserScramCredentialsDescription_scramcredentialinfo(const rd_kafka_UserScramCredentialsDescription_t *description, size_t idx);\nconst rd_kafka_UserScramCredentialsDescription_t **rd_kafka_DescribeUserScramCredentials_result_descriptions(const rd_kafka_DescribeUserScramCredentials_result_t *result, size_t *cntp);\nvoid rd_kafka_DescribeUserScramCredentials(rd_kafka_t *rk, const char **users, size_t user_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\ntypedef struct rd_kafka_UserScramCredentialAlteration_s rd_kafka_UserScramCredentialAlteration_t;\nrd_kafka_UserScramCredentialAlteration_t *rd_kafka_UserScramCredentialUpsertion_new(const char *username, rd_kafka_ScramMechanism_t mechanism, int32_t iterations, const unsigned char *password, size_t password_size, const unsigned char *salt, size_t salt_size);\nrd_kafka_UserScramCredentialAlteration_t *rd_kafka_UserScramCredentialDeletion_new(const char *username, rd_kafka_ScramMechanism_t mechanism);\nvoid rd_kafka_UserScramCredentialAlteration_destroy(rd_kafka_UserScramCredentialAlteration_t *alteration);\nvoid rd_kafka_UserScramCredentialAlteration_destroy_array(rd_kafka_UserScramCredentialAlteration_t **alterations, size_t alteration_cnt);\ntypedef struct rd_kafka_AlterUserScramCredentials_result_response_s rd_kafka_AlterUserScramCredentials_result_response_t;\nconst char *rd_kafka_AlterUserScramCredentials_result_response_user(const rd_kafka_AlterUserScramCredentials_result_response_t *response);\nconst rd_kafka_error_t *rd_kafka_AlterUserScramCredentials_result_response_error(const rd_kafka_AlterUserScramCredentials_result_response_t *response);\nconst rd_kafka_AlterUserScramCredentials_result_response_t **rd_kafka_AlterUserScramCredentials_result_responses(const rd_kafka_AlterUserScramCredentials_result_t *result, size_t *cntp);\nvoid rd_kafka_AlterUserScramCredentials(rd_kafka_t *rk, rd_kafka_UserScramCredentialAlteration_t **alterations, size_t alteration_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\ntypedef struct rd_kafka_AclBinding_s rd_kafka_AclBinding_t;\ntypedef rd_kafka_AclBinding_t rd_kafka_AclBindingFilter_t;\nconst rd_kafka_error_t *rd_kafka_acl_result_error(const rd_kafka_acl_result_t *aclres);\nconst char *rd_kafka_AclOperation_name(rd_kafka_AclOperation_t acl_operation);\ntypedef enum rd_kafka_AclPermissionType_t {\n  RD_KAFKA_ACL_PERMISSION_TYPE_UNKNOWN = 0,\n  RD_KAFKA_ACL_PERMISSION_TYPE_ANY = 1,\n  RD_KAFKA_ACL_PERMISSION_TYPE_DENY = 2,\n  RD_KAFKA_ACL_PERMISSION_TYPE_ALLOW = 3,\n  RD_KAFKA_ACL_PERMISSION_TYPE__CNT,\n} rd_kafka_AclPermissionType_t;\nconst char *rd_kafka_AclPermissionType_name(rd_kafka_AclPermissionType_t acl_permission_type);\nrd_kafka_AclBinding_t *rd_kafka_AclBinding_new(rd_kafka_ResourceType_t restype, const char *name, rd_kafka_ResourcePatternType_t resource_pattern_type, const char *principal, const char *host, rd_kafka_AclOperation_t operation, rd_kafka_AclPermissionType_t permission_type, char *errstr, size_t errstr_size);\nrd_kafka_AclBindingFilter_t *rd_kafka_AclBindingFilter_new(rd_kafka_ResourceType_t restype, const char *name, rd_kafka_ResourcePatternType_t resource_pattern_type, const char *principal, const char *host, rd_kafka_AclOperation_t operation, rd_kafka_AclPermissionType_t permission_type, char *errstr, size_t errstr_size);\nrd_kafka_ResourceType_t rd_kafka_AclBinding_restype(const rd_kafka_AclBinding_t *acl);\nconst char *rd_kafka_AclBinding_name(const rd_kafka_AclBinding_t *acl);\nconst char *rd_kafka_AclBinding_principal(const rd_kafka_AclBinding_t *acl);\nconst char *rd_kafka_AclBinding_host(const rd_kafka_AclBinding_t *acl);\nrd_kafka_AclOperation_t rd_kafka_AclBinding_operation(const rd_kafka_AclBinding_t *acl);\nrd_kafka_AclPermissionType_t rd_kafka_AclBinding_permission_type(const rd_kafka_AclBinding_t *acl);\nrd_kafka_ResourcePatternType_t rd_kafka_AclBinding_resource_pattern_type(const rd_kafka_AclBinding_t *acl);\nconst rd_kafka_error_t *rd_kafka_AclBinding_error(const rd_kafka_AclBinding_t *acl);\nvoid rd_kafka_AclBinding_destroy(rd_kafka_AclBinding_t *acl_binding);\nvoid rd_kafka_AclBinding_destroy_array(rd_kafka_AclBinding_t **acl_bindings, size_t acl_bindings_cnt);\nconst rd_kafka_acl_result_t **rd_kafka_CreateAcls_result_acls(const rd_kafka_CreateAcls_result_t *result, size_t *cntp);\nvoid rd_kafka_CreateAcls(rd_kafka_t *rk, rd_kafka_AclBinding_t **new_acls, size_t new_acls_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_AclBinding_t **rd_kafka_DescribeAcls_result_acls(const rd_kafka_DescribeAcls_result_t *result, size_t *cntp);\nvoid rd_kafka_DescribeAcls(rd_kafka_t *rk, rd_kafka_AclBindingFilter_t *acl_filter, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\ntypedef struct rd_kafka_DeleteAcls_result_response_s rd_kafka_DeleteAcls_result_response_t;\nconst rd_kafka_DeleteAcls_result_response_t **rd_kafka_DeleteAcls_result_responses(const rd_kafka_DeleteAcls_result_t *result, size_t *cntp);\nconst rd_kafka_error_t *rd_kafka_DeleteAcls_result_response_error(const rd_kafka_DeleteAcls_result_response_t *result_response);\nconst rd_kafka_AclBinding_t **rd_kafka_DeleteAcls_result_response_matching_acls(const rd_kafka_DeleteAcls_result_response_t *result_response, size_t *matching_acls_cntp);\nvoid rd_kafka_DeleteAcls(rd_kafka_t *rk, rd_kafka_AclBindingFilter_t **del_acls, size_t del_acls_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nrd_kafka_resp_err_t rd_kafka_oauthbearer_set_token(rd_kafka_t *rk, const char *token_value, int64_t md_lifetime_ms, const char *md_principal_name, const char **extensions, size_t extension_size, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_oauthbearer_set_token_failure(rd_kafka_t *rk, const char *errstr);\nrd_kafka_error_t *rd_kafka_init_transactions(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_error_t *rd_kafka_begin_transaction(rd_kafka_t *rk);\nrd_kafka_error_t *rd_kafka_send_offsets_to_transaction(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, const rd_kafka_consumer_group_metadata_t *cgmetadata, int timeout_ms);\nrd_kafka_error_t *rd_kafka_commit_transaction(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_error_t *rd_kafka_abort_transaction(rd_kafka_t *rk, int timeout_ms);\ntypedef struct rd_kafka_mock_cluster_s rd_kafka_mock_cluster_t;\nrd_kafka_mock_cluster_t *rd_kafka_mock_cluster_new(rd_kafka_t *rk, int broker_cnt);\nvoid rd_kafka_mock_cluster_destroy(rd_kafka_mock_cluster_t *mcluster);\nrd_kafka_t *rd_kafka_mock_cluster_handle(const rd_kafka_mock_cluster_t *mcluster);\nrd_kafka_mock_cluster_t *rd_kafka_handle_mock_cluster(const rd_kafka_t *rk);\nconst char *rd_kafka_mock_cluster_bootstraps(const rd_kafka_mock_cluster_t *mcluster);\nvoid rd_kafka_mock_clear_request_errors(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey);\nvoid rd_kafka_mock_push_request_errors(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, size_t cnt, ...);\nvoid rd_kafka_mock_push_request_errors_array(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, size_t cnt, const rd_kafka_resp_err_t *errors);\nrd_kafka_resp_err_t rd_kafka_mock_broker_push_request_error_rtts(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int16_t ApiKey, size_t cnt, ...);\nrd_kafka_resp_err_t rd_kafka_mock_broker_error_stack_cnt(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int16_t ApiKey, size_t *cntp);\nvoid rd_kafka_mock_topic_set_error(rd_kafka_mock_cluster_t *mcluster, const char *topic, rd_kafka_resp_err_t err);\nrd_kafka_resp_err_t rd_kafka_mock_topic_create(rd_kafka_mock_cluster_t *mcluster, const char *topic, int partition_cnt, int replication_factor);\nrd_kafka_resp_err_t rd_kafka_mock_partition_set_leader(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id);\nrd_kafka_resp_err_t rd_kafka_mock_partition_set_follower(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id);\nrd_kafka_resp_err_t rd_kafka_mock_partition_set_follower_wmarks(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int64_t lo, int64_t hi);\nrd_kafka_resp_err_t rd_kafka_mock_partition_push_leader_response(rd_kafka_mock_cluster_t *mcluster, const char *topic, int partition, int32_t leader_id, int32_t leader_epoch);\nrd_kafka_resp_err_t rd_kafka_mock_broker_set_down(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id);\nrd_kafka_resp_err_t rd_kafka_mock_broker_set_up(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id);\nrd_kafka_resp_err_t rd_kafka_mock_broker_set_rtt(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int rtt_ms);\nrd_kafka_resp_err_t rd_kafka_mock_broker_set_rack(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, const char *rack);\nrd_kafka_resp_err_t rd_kafka_mock_coordinator_set(rd_kafka_mock_cluster_t *mcluster, const char *key_type, const char *key, int32_t broker_id);\nrd_kafka_resp_err_t rd_kafka_mock_set_apiversion(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, int16_t MinVersion, int16_t MaxVersion);\nvoid rd_kafka_mock_start_request_tracking(rd_kafka_mock_cluster_t *mcluster);\nvoid rd_kafka_mock_stop_request_tracking(rd_kafka_mock_cluster_t *mcluster);\ntypedef struct rd_kafka_mock_request_s rd_kafka_mock_request_t;\nvoid rd_kafka_mock_request_destroy(rd_kafka_mock_request_t *mreq);\nvoid rd_kafka_mock_request_destroy_array(rd_kafka_mock_request_t **mreqs, size_t mreq_cnt);\nint32_t rd_kafka_mock_request_id(rd_kafka_mock_request_t *mreq);\nint16_t rd_kafka_mock_request_api_key(rd_kafka_mock_request_t *mreq);\nint64_t rd_kafka_mock_request_timestamp(rd_kafka_mock_request_t *mreq);\nrd_kafka_mock_request_t **rd_kafka_mock_get_requests(rd_kafka_mock_cluster_t *mcluster, size_t *cntp);\nvoid rd_kafka_mock_clear_requests(rd_kafka_mock_cluster_t *mcluster);\n'\n</code></pre> rdkafka.h, rdkafka_mock.h</p>"},{"location":"api/constants/#rd_kafka_version_31","title":"RD_KAFKA_VERSION","text":"<pre><code>public RD_KAFKA_VERSION = 33882367\n</code></pre> <p>librdkafka version </p> <p>Interpreted as hex <code>MM.mm.rr.xx</code>:</p> <ul> <li>MM = Major</li> <li>mm = minor</li> <li>rr = revision</li> <li>xx = pre-release id (0xff is the final release)</li> </ul> <p>E.g.: <code>0x000801ff</code> = 0.8.1</p> RemarksThis value should only be used during compile time, for runtime checks of version use rd_kafka_version()  <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_unsupported_compression_type_31","title":"RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE","text":"<pre><code>public RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76\n</code></pre> <p>Unsupported compression type </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_end_all_31","title":"RD_KAFKA_RESP_ERR_END_ALL","text":"<p><pre><code>public RD_KAFKA_RESP_ERR_END_ALL = 119\n</code></pre> enum rd_kafka_resp_err_t</p>"},{"location":"api/constants/#rd_kafka_admin_op__cnt_31","title":"RD_KAFKA_ADMIN_OP__CNT","text":"<pre><code>public RD_KAFKA_ADMIN_OP__CNT = 22\n</code></pre> <p>Number of ops defined </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe </li> </ul>"},{"location":"api/constants/#rd_kafka_resource__cnt_31","title":"RD_KAFKA_RESOURCE__CNT","text":"<pre><code>public RD_KAFKA_RESOURCE__CNT = 5\n</code></pre> <p>Number of resource types defined </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#acca83a66d7783ff7683ed2691cc907c9 </li> </ul>"},{"location":"api/constants/#rd_kafka_cdef_31","title":"RD_KAFKA_CDEF","text":"<p><pre><code>public RD_KAFKA_CDEF = 'typedef long int ssize_t;\ntypedef struct _IO_FILE FILE;\ntypedef long int mode_t;\ntypedef signed int int16_t;\ntypedef unsigned int uint16_t;\ntypedef signed int int32_t;\ntypedef signed long int int64_t;\nint rd_kafka_version(void);\nconst char *rd_kafka_version_str(void);\ntypedef enum rd_kafka_type_t {\n  RD_KAFKA_PRODUCER,\n  RD_KAFKA_CONSUMER,\n} rd_kafka_type_t;\ntypedef enum rd_kafka_timestamp_type_t {\n  RD_KAFKA_TIMESTAMP_NOT_AVAILABLE,\n  RD_KAFKA_TIMESTAMP_CREATE_TIME,\n  RD_KAFKA_TIMESTAMP_LOG_APPEND_TIME,\n} rd_kafka_timestamp_type_t;\nconst char *rd_kafka_get_debug_contexts(void);\ntypedef struct rd_kafka_s rd_kafka_t;\ntypedef struct rd_kafka_topic_s rd_kafka_topic_t;\ntypedef struct rd_kafka_conf_s rd_kafka_conf_t;\ntypedef struct rd_kafka_topic_conf_s rd_kafka_topic_conf_t;\ntypedef struct rd_kafka_queue_s rd_kafka_queue_t;\ntypedef struct rd_kafka_op_s rd_kafka_event_t;\ntypedef struct rd_kafka_topic_result_s rd_kafka_topic_result_t;\ntypedef struct rd_kafka_consumer_group_metadata_s rd_kafka_consumer_group_metadata_t;\ntypedef struct rd_kafka_error_s {\n  unsigned int code;\n  char *errstr;\n  unsigned char fatal;\n  unsigned char retriable;\n  unsigned char txn_requires_abort;\n} rd_kafka_error_t;\ntypedef struct rd_kafka_headers_s rd_kafka_headers_t;\ntypedef struct rd_kafka_group_result_s rd_kafka_group_result_t;\ntypedef struct rd_kafka_acl_result_s rd_kafka_acl_result_t;\ntypedef struct rd_kafka_Uuid_s rd_kafka_Uuid_t;\ntypedef enum {\n  RD_KAFKA_RESP_ERR__BEGIN = (- 200),\n  RD_KAFKA_RESP_ERR__BAD_MSG = (- 199),\n  RD_KAFKA_RESP_ERR__BAD_COMPRESSION = (- 198),\n  RD_KAFKA_RESP_ERR__DESTROY = (- 197),\n  RD_KAFKA_RESP_ERR__FAIL = (- 196),\n  RD_KAFKA_RESP_ERR__TRANSPORT = (- 195),\n  RD_KAFKA_RESP_ERR__CRIT_SYS_RESOURCE = (- 194),\n  RD_KAFKA_RESP_ERR__RESOLVE = (- 193),\n  RD_KAFKA_RESP_ERR__MSG_TIMED_OUT = (- 192),\n  RD_KAFKA_RESP_ERR__PARTITION_EOF = (- 191),\n  RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION = (- 190),\n  RD_KAFKA_RESP_ERR__FS = (- 189),\n  RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC = (- 188),\n  RD_KAFKA_RESP_ERR__ALL_BROKERS_DOWN = (- 187),\n  RD_KAFKA_RESP_ERR__INVALID_ARG = (- 186),\n  RD_KAFKA_RESP_ERR__TIMED_OUT = (- 185),\n  RD_KAFKA_RESP_ERR__QUEUE_FULL = (- 184),\n  RD_KAFKA_RESP_ERR__ISR_INSUFF = (- 183),\n  RD_KAFKA_RESP_ERR__NODE_UPDATE = (- 182),\n  RD_KAFKA_RESP_ERR__SSL = (- 181),\n  RD_KAFKA_RESP_ERR__WAIT_COORD = (- 180),\n  RD_KAFKA_RESP_ERR__UNKNOWN_GROUP = (- 179),\n  RD_KAFKA_RESP_ERR__IN_PROGRESS = (- 178),\n  RD_KAFKA_RESP_ERR__PREV_IN_PROGRESS = (- 177),\n  RD_KAFKA_RESP_ERR__EXISTING_SUBSCRIPTION = (- 176),\n  RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS = (- 175),\n  RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS = (- 174),\n  RD_KAFKA_RESP_ERR__CONFLICT = (- 173),\n  RD_KAFKA_RESP_ERR__STATE = (- 172),\n  RD_KAFKA_RESP_ERR__UNKNOWN_PROTOCOL = (- 171),\n  RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED = (- 170),\n  RD_KAFKA_RESP_ERR__AUTHENTICATION = (- 169),\n  RD_KAFKA_RESP_ERR__NO_OFFSET = (- 168),\n  RD_KAFKA_RESP_ERR__OUTDATED = (- 167),\n  RD_KAFKA_RESP_ERR__TIMED_OUT_QUEUE = (- 166),\n  RD_KAFKA_RESP_ERR__UNSUPPORTED_FEATURE = (- 165),\n  RD_KAFKA_RESP_ERR__WAIT_CACHE = (- 164),\n  RD_KAFKA_RESP_ERR__INTR = (- 163),\n  RD_KAFKA_RESP_ERR__KEY_SERIALIZATION = (- 162),\n  RD_KAFKA_RESP_ERR__VALUE_SERIALIZATION = (- 161),\n  RD_KAFKA_RESP_ERR__KEY_DESERIALIZATION = (- 160),\n  RD_KAFKA_RESP_ERR__VALUE_DESERIALIZATION = (- 159),\n  RD_KAFKA_RESP_ERR__PARTIAL = (- 158),\n  RD_KAFKA_RESP_ERR__READ_ONLY = (- 157),\n  RD_KAFKA_RESP_ERR__NOENT = (- 156),\n  RD_KAFKA_RESP_ERR__UNDERFLOW = (- 155),\n  RD_KAFKA_RESP_ERR__INVALID_TYPE = (- 154),\n  RD_KAFKA_RESP_ERR__RETRY = (- 153),\n  RD_KAFKA_RESP_ERR__PURGE_QUEUE = (- 152),\n  RD_KAFKA_RESP_ERR__PURGE_INFLIGHT = (- 151),\n  RD_KAFKA_RESP_ERR__FATAL = (- 150),\n  RD_KAFKA_RESP_ERR__INCONSISTENT = (- 149),\n  RD_KAFKA_RESP_ERR__GAPLESS_GUARANTEE = (- 148),\n  RD_KAFKA_RESP_ERR__MAX_POLL_EXCEEDED = (- 147),\n  RD_KAFKA_RESP_ERR__UNKNOWN_BROKER = (- 146),\n  RD_KAFKA_RESP_ERR__NOT_CONFIGURED = (- 145),\n  RD_KAFKA_RESP_ERR__FENCED = (- 144),\n  RD_KAFKA_RESP_ERR__APPLICATION = (- 143),\n  RD_KAFKA_RESP_ERR__ASSIGNMENT_LOST = (- 142),\n  RD_KAFKA_RESP_ERR__NOOP = (- 141),\n  RD_KAFKA_RESP_ERR__AUTO_OFFSET_RESET = (- 140),\n  RD_KAFKA_RESP_ERR__LOG_TRUNCATION = (- 139),\n  RD_KAFKA_RESP_ERR__INVALID_DIFFERENT_RECORD = (- 138),\n  RD_KAFKA_RESP_ERR__END = (- 100),\n  RD_KAFKA_RESP_ERR_UNKNOWN = (- 1),\n  RD_KAFKA_RESP_ERR_NO_ERROR = 0,\n  RD_KAFKA_RESP_ERR_OFFSET_OUT_OF_RANGE = 1,\n  RD_KAFKA_RESP_ERR_INVALID_MSG = 2,\n  RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART = 3,\n  RD_KAFKA_RESP_ERR_INVALID_MSG_SIZE = 4,\n  RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE = 5,\n  RD_KAFKA_RESP_ERR_NOT_LEADER_FOR_PARTITION = 6,\n  RD_KAFKA_RESP_ERR_REQUEST_TIMED_OUT = 7,\n  RD_KAFKA_RESP_ERR_BROKER_NOT_AVAILABLE = 8,\n  RD_KAFKA_RESP_ERR_REPLICA_NOT_AVAILABLE = 9,\n  RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE = 10,\n  RD_KAFKA_RESP_ERR_STALE_CTRL_EPOCH = 11,\n  RD_KAFKA_RESP_ERR_OFFSET_METADATA_TOO_LARGE = 12,\n  RD_KAFKA_RESP_ERR_NETWORK_EXCEPTION = 13,\n  RD_KAFKA_RESP_ERR_COORDINATOR_LOAD_IN_PROGRESS = 14,\n  RD_KAFKA_RESP_ERR_COORDINATOR_NOT_AVAILABLE = 15,\n  RD_KAFKA_RESP_ERR_NOT_COORDINATOR = 16,\n  RD_KAFKA_RESP_ERR_TOPIC_EXCEPTION = 17,\n  RD_KAFKA_RESP_ERR_RECORD_LIST_TOO_LARGE = 18,\n  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS = 19,\n  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS_AFTER_APPEND = 20,\n  RD_KAFKA_RESP_ERR_INVALID_REQUIRED_ACKS = 21,\n  RD_KAFKA_RESP_ERR_ILLEGAL_GENERATION = 22,\n  RD_KAFKA_RESP_ERR_INCONSISTENT_GROUP_PROTOCOL = 23,\n  RD_KAFKA_RESP_ERR_INVALID_GROUP_ID = 24,\n  RD_KAFKA_RESP_ERR_UNKNOWN_MEMBER_ID = 25,\n  RD_KAFKA_RESP_ERR_INVALID_SESSION_TIMEOUT = 26,\n  RD_KAFKA_RESP_ERR_REBALANCE_IN_PROGRESS = 27,\n  RD_KAFKA_RESP_ERR_INVALID_COMMIT_OFFSET_SIZE = 28,\n  RD_KAFKA_RESP_ERR_TOPIC_AUTHORIZATION_FAILED = 29,\n  RD_KAFKA_RESP_ERR_GROUP_AUTHORIZATION_FAILED = 30,\n  RD_KAFKA_RESP_ERR_CLUSTER_AUTHORIZATION_FAILED = 31,\n  RD_KAFKA_RESP_ERR_INVALID_TIMESTAMP = 32,\n  RD_KAFKA_RESP_ERR_UNSUPPORTED_SASL_MECHANISM = 33,\n  RD_KAFKA_RESP_ERR_ILLEGAL_SASL_STATE = 34,\n  RD_KAFKA_RESP_ERR_UNSUPPORTED_VERSION = 35,\n  RD_KAFKA_RESP_ERR_TOPIC_ALREADY_EXISTS = 36,\n  RD_KAFKA_RESP_ERR_INVALID_PARTITIONS = 37,\n  RD_KAFKA_RESP_ERR_INVALID_REPLICATION_FACTOR = 38,\n  RD_KAFKA_RESP_ERR_INVALID_REPLICA_ASSIGNMENT = 39,\n  RD_KAFKA_RESP_ERR_INVALID_CONFIG = 40,\n  RD_KAFKA_RESP_ERR_NOT_CONTROLLER = 41,\n  RD_KAFKA_RESP_ERR_INVALID_REQUEST = 42,\n  RD_KAFKA_RESP_ERR_UNSUPPORTED_FOR_MESSAGE_FORMAT = 43,\n  RD_KAFKA_RESP_ERR_POLICY_VIOLATION = 44,\n  RD_KAFKA_RESP_ERR_OUT_OF_ORDER_SEQUENCE_NUMBER = 45,\n  RD_KAFKA_RESP_ERR_DUPLICATE_SEQUENCE_NUMBER = 46,\n  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_EPOCH = 47,\n  RD_KAFKA_RESP_ERR_INVALID_TXN_STATE = 48,\n  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_ID_MAPPING = 49,\n  RD_KAFKA_RESP_ERR_INVALID_TRANSACTION_TIMEOUT = 50,\n  RD_KAFKA_RESP_ERR_CONCURRENT_TRANSACTIONS = 51,\n  RD_KAFKA_RESP_ERR_TRANSACTION_COORDINATOR_FENCED = 52,\n  RD_KAFKA_RESP_ERR_TRANSACTIONAL_ID_AUTHORIZATION_FAILED = 53,\n  RD_KAFKA_RESP_ERR_SECURITY_DISABLED = 54,\n  RD_KAFKA_RESP_ERR_OPERATION_NOT_ATTEMPTED = 55,\n  RD_KAFKA_RESP_ERR_KAFKA_STORAGE_ERROR = 56,\n  RD_KAFKA_RESP_ERR_LOG_DIR_NOT_FOUND = 57,\n  RD_KAFKA_RESP_ERR_SASL_AUTHENTICATION_FAILED = 58,\n  RD_KAFKA_RESP_ERR_UNKNOWN_PRODUCER_ID = 59,\n  RD_KAFKA_RESP_ERR_REASSIGNMENT_IN_PROGRESS = 60,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTH_DISABLED = 61,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_NOT_FOUND = 62,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_OWNER_MISMATCH = 63,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_REQUEST_NOT_ALLOWED = 64,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTHORIZATION_FAILED = 65,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_EXPIRED = 66,\n  RD_KAFKA_RESP_ERR_INVALID_PRINCIPAL_TYPE = 67,\n  RD_KAFKA_RESP_ERR_NON_EMPTY_GROUP = 68,\n  RD_KAFKA_RESP_ERR_GROUP_ID_NOT_FOUND = 69,\n  RD_KAFKA_RESP_ERR_FETCH_SESSION_ID_NOT_FOUND = 70,\n  RD_KAFKA_RESP_ERR_INVALID_FETCH_SESSION_EPOCH = 71,\n  RD_KAFKA_RESP_ERR_LISTENER_NOT_FOUND = 72,\n  RD_KAFKA_RESP_ERR_TOPIC_DELETION_DISABLED = 73,\n  RD_KAFKA_RESP_ERR_FENCED_LEADER_EPOCH = 74,\n  RD_KAFKA_RESP_ERR_UNKNOWN_LEADER_EPOCH = 75,\n  RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76,\n  RD_KAFKA_RESP_ERR_STALE_BROKER_EPOCH = 77,\n  RD_KAFKA_RESP_ERR_OFFSET_NOT_AVAILABLE = 78,\n  RD_KAFKA_RESP_ERR_MEMBER_ID_REQUIRED = 79,\n  RD_KAFKA_RESP_ERR_PREFERRED_LEADER_NOT_AVAILABLE = 80,\n  RD_KAFKA_RESP_ERR_GROUP_MAX_SIZE_REACHED = 81,\n  RD_KAFKA_RESP_ERR_FENCED_INSTANCE_ID = 82,\n  RD_KAFKA_RESP_ERR_ELIGIBLE_LEADERS_NOT_AVAILABLE = 83,\n  RD_KAFKA_RESP_ERR_ELECTION_NOT_NEEDED = 84,\n  RD_KAFKA_RESP_ERR_NO_REASSIGNMENT_IN_PROGRESS = 85,\n  RD_KAFKA_RESP_ERR_GROUP_SUBSCRIBED_TO_TOPIC = 86,\n  RD_KAFKA_RESP_ERR_INVALID_RECORD = 87,\n  RD_KAFKA_RESP_ERR_UNSTABLE_OFFSET_COMMIT = 88,\n  RD_KAFKA_RESP_ERR_THROTTLING_QUOTA_EXCEEDED = 89,\n  RD_KAFKA_RESP_ERR_PRODUCER_FENCED = 90,\n  RD_KAFKA_RESP_ERR_RESOURCE_NOT_FOUND = 91,\n  RD_KAFKA_RESP_ERR_DUPLICATE_RESOURCE = 92,\n  RD_KAFKA_RESP_ERR_UNACCEPTABLE_CREDENTIAL = 93,\n  RD_KAFKA_RESP_ERR_INCONSISTENT_VOTER_SET = 94,\n  RD_KAFKA_RESP_ERR_INVALID_UPDATE_VERSION = 95,\n  RD_KAFKA_RESP_ERR_FEATURE_UPDATE_FAILED = 96,\n  RD_KAFKA_RESP_ERR_PRINCIPAL_DESERIALIZATION_FAILURE = 97,\n  RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_ID = 100,\n  RD_KAFKA_RESP_ERR_FENCED_MEMBER_EPOCH = 110,\n  RD_KAFKA_RESP_ERR_UNRELEASED_INSTANCE_ID = 111,\n  RD_KAFKA_RESP_ERR_UNSUPPORTED_ASSIGNOR = 112,\n  RD_KAFKA_RESP_ERR_STALE_MEMBER_EPOCH = 113,\n  RD_KAFKA_RESP_ERR_UNKNOWN_SUBSCRIPTION_ID = 117,\n  RD_KAFKA_RESP_ERR_TELEMETRY_TOO_LARGE = 118,\n  RD_KAFKA_RESP_ERR_END_ALL,\n} rd_kafka_resp_err_t;\nstruct rd_kafka_err_desc {\n  rd_kafka_resp_err_t code;\n  char *name;\n  char *desc;\n};\nvoid rd_kafka_get_err_descs(const struct rd_kafka_err_desc **errdescs, size_t *cntp);\nconst char *rd_kafka_err2str(rd_kafka_resp_err_t err);\nconst char *rd_kafka_err2name(rd_kafka_resp_err_t err);\nrd_kafka_resp_err_t rd_kafka_last_error(void);\nrd_kafka_resp_err_t rd_kafka_errno2err(int errnox);\nint rd_kafka_errno(void);\nrd_kafka_resp_err_t rd_kafka_fatal_error(rd_kafka_t *rk, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_test_fatal_error(rd_kafka_t *rk, rd_kafka_resp_err_t err, const char *reason);\nrd_kafka_resp_err_t rd_kafka_error_code(const rd_kafka_error_t *error);\nconst char *rd_kafka_error_name(const rd_kafka_error_t *error);\nconst char *rd_kafka_error_string(const rd_kafka_error_t *error);\nint rd_kafka_error_is_fatal(const rd_kafka_error_t *error);\nint rd_kafka_error_is_retriable(const rd_kafka_error_t *error);\nint rd_kafka_error_txn_requires_abort(const rd_kafka_error_t *error);\nvoid rd_kafka_error_destroy(rd_kafka_error_t *error);\nrd_kafka_error_t *rd_kafka_error_new(rd_kafka_resp_err_t code, const char *fmt, ...);\ntypedef struct rd_kafka_topic_partition_s {\n  char *topic;\n  int32_t partition;\n  int64_t offset;\n  void *metadata;\n  size_t metadata_size;\n  void *opaque;\n  rd_kafka_resp_err_t err;\n  void *_private;\n} rd_kafka_topic_partition_t;\nvoid rd_kafka_topic_partition_destroy(rd_kafka_topic_partition_t *rktpar);\nvoid rd_kafka_topic_partition_set_leader_epoch(rd_kafka_topic_partition_t *rktpar, int32_t leader_epoch);\nint32_t rd_kafka_topic_partition_get_leader_epoch(const rd_kafka_topic_partition_t *rktpar);\ntypedef struct rd_kafka_topic_partition_list_s {\n  int cnt;\n  int size;\n  rd_kafka_topic_partition_t *elems;\n} rd_kafka_topic_partition_list_t;\nrd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_new(int size);\nvoid rd_kafka_topic_partition_list_destroy(rd_kafka_topic_partition_list_t *rkparlist);\nrd_kafka_topic_partition_t *rd_kafka_topic_partition_list_add(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);\nvoid rd_kafka_topic_partition_list_add_range(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t start, int32_t stop);\nint rd_kafka_topic_partition_list_del(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);\nint rd_kafka_topic_partition_list_del_by_idx(rd_kafka_topic_partition_list_t *rktparlist, int idx);\nrd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_copy(const rd_kafka_topic_partition_list_t *src);\nrd_kafka_resp_err_t rd_kafka_topic_partition_list_set_offset(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition, int64_t offset);\nrd_kafka_topic_partition_t *rd_kafka_topic_partition_list_find(const rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);\nvoid rd_kafka_topic_partition_list_sort(rd_kafka_topic_partition_list_t *rktparlist, int (*cmp)(const void *a, const void *b, void *cmp_opaque), void *cmp_opaque);\ntypedef enum rd_kafka_vtype_t {\n  RD_KAFKA_VTYPE_END,\n  RD_KAFKA_VTYPE_TOPIC,\n  RD_KAFKA_VTYPE_RKT,\n  RD_KAFKA_VTYPE_PARTITION,\n  RD_KAFKA_VTYPE_VALUE,\n  RD_KAFKA_VTYPE_KEY,\n  RD_KAFKA_VTYPE_OPAQUE,\n  RD_KAFKA_VTYPE_MSGFLAGS,\n  RD_KAFKA_VTYPE_TIMESTAMP,\n  RD_KAFKA_VTYPE_HEADER,\n  RD_KAFKA_VTYPE_HEADERS,\n} rd_kafka_vtype_t;\ntypedef struct rd_kafka_vu_s {\n  rd_kafka_vtype_t vtype;\n  union {\n    char *cstr;\n    rd_kafka_topic_t *rkt;\n    int i;\n    int32_t i32;\n    int64_t i64;\n    struct {\n      void *ptr;\n      size_t size;\n    } mem;\n    struct {\n      char *name;\n      void *val;\n      ssize_t size;\n    } header;\n    rd_kafka_headers_t *headers;\n    void *ptr;\n    char _pad[64];\n  } u;\n} rd_kafka_vu_t;\nrd_kafka_headers_t *rd_kafka_headers_new(size_t initial_count);\nvoid rd_kafka_headers_destroy(rd_kafka_headers_t *hdrs);\nrd_kafka_headers_t *rd_kafka_headers_copy(const rd_kafka_headers_t *src);\nrd_kafka_resp_err_t rd_kafka_header_add(rd_kafka_headers_t *hdrs, const char *name, ssize_t name_size, const void *value, ssize_t value_size);\nrd_kafka_resp_err_t rd_kafka_header_remove(rd_kafka_headers_t *hdrs, const char *name);\nrd_kafka_resp_err_t rd_kafka_header_get_last(const rd_kafka_headers_t *hdrs, const char *name, const void **valuep, size_t *sizep);\nrd_kafka_resp_err_t rd_kafka_header_get(const rd_kafka_headers_t *hdrs, size_t idx, const char *name, const void **valuep, size_t *sizep);\nrd_kafka_resp_err_t rd_kafka_header_get_all(const rd_kafka_headers_t *hdrs, size_t idx, const char **namep, const void **valuep, size_t *sizep);\ntypedef struct rd_kafka_message_s {\n  rd_kafka_resp_err_t err;\n  rd_kafka_topic_t *rkt;\n  int32_t partition;\n  void *payload;\n  size_t len;\n  void *key;\n  size_t key_len;\n  int64_t offset;\n  void *_private;\n} rd_kafka_message_t;\nvoid rd_kafka_message_destroy(rd_kafka_message_t *rkmessage);\nconst char *rd_kafka_message_errstr(const rd_kafka_message_t *rkmessage);\nconst char *rd_kafka_message_produce_errstr(const rd_kafka_message_t *rkmessage);\nint64_t rd_kafka_message_timestamp(const rd_kafka_message_t *rkmessage, rd_kafka_timestamp_type_t *tstype);\nint64_t rd_kafka_message_latency(const rd_kafka_message_t *rkmessage);\nint32_t rd_kafka_message_broker_id(const rd_kafka_message_t *rkmessage);\nrd_kafka_resp_err_t rd_kafka_message_headers(const rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);\nrd_kafka_resp_err_t rd_kafka_message_detach_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);\nvoid rd_kafka_message_set_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t *hdrs);\nsize_t rd_kafka_header_cnt(const rd_kafka_headers_t *hdrs);\ntypedef enum {\n  RD_KAFKA_MSG_STATUS_NOT_PERSISTED = 0,\n  RD_KAFKA_MSG_STATUS_POSSIBLY_PERSISTED = 1,\n  RD_KAFKA_MSG_STATUS_PERSISTED = 2,\n} rd_kafka_msg_status_t;\nrd_kafka_msg_status_t rd_kafka_message_status(const rd_kafka_message_t *rkmessage);\nint32_t rd_kafka_message_leader_epoch(const rd_kafka_message_t *rkmessage);\nconst char *rd_kafka_Uuid_base64str(const rd_kafka_Uuid_t *uuid);\nint64_t rd_kafka_Uuid_least_significant_bits(const rd_kafka_Uuid_t *uuid);\nint64_t rd_kafka_Uuid_most_significant_bits(const rd_kafka_Uuid_t *uuid);\nrd_kafka_Uuid_t *rd_kafka_Uuid_new(int64_t most_significant_bits, int64_t least_significant_bits);\nrd_kafka_Uuid_t *rd_kafka_Uuid_copy(const rd_kafka_Uuid_t *uuid);\nvoid rd_kafka_Uuid_destroy(rd_kafka_Uuid_t *uuid);\ntypedef enum {\n  RD_KAFKA_CONF_UNKNOWN = (- 2),\n  RD_KAFKA_CONF_INVALID = (- 1),\n  RD_KAFKA_CONF_OK = 0,\n} rd_kafka_conf_res_t;\nrd_kafka_conf_t *rd_kafka_conf_new(void);\nvoid rd_kafka_conf_destroy(rd_kafka_conf_t *conf);\nrd_kafka_conf_t *rd_kafka_conf_dup(const rd_kafka_conf_t *conf);\nrd_kafka_conf_t *rd_kafka_conf_dup_filter(const rd_kafka_conf_t *conf, size_t filter_cnt, const char **filter);\nconst rd_kafka_conf_t *rd_kafka_conf(rd_kafka_t *rk);\nrd_kafka_conf_res_t rd_kafka_conf_set(rd_kafka_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);\nvoid rd_kafka_conf_set_events(rd_kafka_conf_t *conf, int events);\nvoid rd_kafka_conf_set_background_event_cb(rd_kafka_conf_t *conf, void (*event_cb)(rd_kafka_t *rk, rd_kafka_event_t *rkev, void *opaque));\nvoid rd_kafka_conf_set_dr_cb(rd_kafka_conf_t *conf, void (*dr_cb)(rd_kafka_t *rk, void *payload, size_t len, rd_kafka_resp_err_t err, void *opaque, void *msg_opaque));\nvoid rd_kafka_conf_set_dr_msg_cb(rd_kafka_conf_t *conf, void (*dr_msg_cb)(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, void *opaque));\nvoid rd_kafka_conf_set_consume_cb(rd_kafka_conf_t *conf, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *opaque));\nvoid rd_kafka_conf_set_rebalance_cb(rd_kafka_conf_t *conf, void (*rebalance_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *partitions, void *opaque));\nvoid rd_kafka_conf_set_offset_commit_cb(rd_kafka_conf_t *conf, void (*offset_commit_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *opaque));\nvoid rd_kafka_conf_set_error_cb(rd_kafka_conf_t *conf, void (*error_cb)(rd_kafka_t *rk, int err, const char *reason, void *opaque));\nvoid rd_kafka_conf_set_throttle_cb(rd_kafka_conf_t *conf, void (*throttle_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int throttle_time_ms, void *opaque));\nvoid rd_kafka_conf_set_log_cb(rd_kafka_conf_t *conf, void (*log_cb)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));\nvoid rd_kafka_conf_set_stats_cb(rd_kafka_conf_t *conf, int (*stats_cb)(rd_kafka_t *rk, char *json, size_t json_len, void *opaque));\nvoid rd_kafka_conf_set_oauthbearer_token_refresh_cb(rd_kafka_conf_t *conf, void (*oauthbearer_token_refresh_cb)(rd_kafka_t *rk, const char *oauthbearer_config, void *opaque));\nvoid rd_kafka_conf_enable_sasl_queue(rd_kafka_conf_t *conf, int enable);\nvoid rd_kafka_conf_set_socket_cb(rd_kafka_conf_t *conf, int (*socket_cb)(int domain, int type, int protocol, void *opaque));\nvoid rd_kafka_conf_set_connect_cb(rd_kafka_conf_t *conf, int (*connect_cb)(int sockfd, const struct sockaddr *addr, int addrlen, const char *id, void *opaque));\nvoid rd_kafka_conf_set_closesocket_cb(rd_kafka_conf_t *conf, int (*closesocket_cb)(int sockfd, void *opaque));\nstruct addrinfo;\nvoid rd_kafka_conf_set_resolve_cb(rd_kafka_conf_t *conf, int (*resolve_cb)(const char *node, const char *service, const struct addrinfo *hints, struct addrinfo **res, void *opaque));\nrd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert_verify_cb(rd_kafka_conf_t *conf, int (*ssl_cert_verify_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int *x509_error, int depth, const char *buf, size_t size, char *errstr, size_t errstr_size, void *opaque));\ntypedef enum rd_kafka_cert_type_t {\n  RD_KAFKA_CERT_PUBLIC_KEY,\n  RD_KAFKA_CERT_PRIVATE_KEY,\n  RD_KAFKA_CERT_CA,\n  RD_KAFKA_CERT__CNT,\n} rd_kafka_cert_type_t;\ntypedef enum rd_kafka_cert_enc_t {\n  RD_KAFKA_CERT_ENC_PKCS12,\n  RD_KAFKA_CERT_ENC_DER,\n  RD_KAFKA_CERT_ENC_PEM,\n  RD_KAFKA_CERT_ENC__CNT,\n} rd_kafka_cert_enc_t;\nrd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert(rd_kafka_conf_t *conf, rd_kafka_cert_type_t cert_type, rd_kafka_cert_enc_t cert_enc, const void *buffer, size_t size, char *errstr, size_t errstr_size);\nvoid rd_kafka_conf_set_engine_callback_data(rd_kafka_conf_t *conf, void *callback_data);\nvoid rd_kafka_conf_set_opaque(rd_kafka_conf_t *conf, void *opaque);\nvoid *rd_kafka_opaque(const rd_kafka_t *rk);\nvoid rd_kafka_conf_set_default_topic_conf(rd_kafka_conf_t *conf, rd_kafka_topic_conf_t *tconf);\nrd_kafka_topic_conf_t *rd_kafka_conf_get_default_topic_conf(rd_kafka_conf_t *conf);\nrd_kafka_conf_res_t rd_kafka_conf_get(const rd_kafka_conf_t *conf, const char *name, char *dest, size_t *dest_size);\nrd_kafka_conf_res_t rd_kafka_topic_conf_get(const rd_kafka_topic_conf_t *conf, const char *name, char *dest, size_t *dest_size);\nconst char **rd_kafka_conf_dump(rd_kafka_conf_t *conf, size_t *cntp);\nconst char **rd_kafka_topic_conf_dump(rd_kafka_topic_conf_t *conf, size_t *cntp);\nvoid rd_kafka_conf_dump_free(const char **arr, size_t cnt);\nvoid rd_kafka_conf_properties_show(FILE *fp);\nrd_kafka_topic_conf_t *rd_kafka_topic_conf_new(void);\nrd_kafka_topic_conf_t *rd_kafka_topic_conf_dup(const rd_kafka_topic_conf_t *conf);\nrd_kafka_topic_conf_t *rd_kafka_default_topic_conf_dup(rd_kafka_t *rk);\nvoid rd_kafka_topic_conf_destroy(rd_kafka_topic_conf_t *topic_conf);\nrd_kafka_conf_res_t rd_kafka_topic_conf_set(rd_kafka_topic_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);\nvoid rd_kafka_topic_conf_set_opaque(rd_kafka_topic_conf_t *conf, void *rkt_opaque);\nvoid rd_kafka_topic_conf_set_partitioner_cb(rd_kafka_topic_conf_t *topic_conf, int32_t (*partitioner)(const rd_kafka_topic_t *rkt, const void *keydata, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque));\nvoid rd_kafka_topic_conf_set_msg_order_cmp(rd_kafka_topic_conf_t *topic_conf, int (*msg_order_cmp)(const rd_kafka_message_t *a, const rd_kafka_message_t *b));\nint rd_kafka_topic_partition_available(const rd_kafka_topic_t *rkt, int32_t partition);\nint32_t rd_kafka_msg_partitioner_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_consistent(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_consistent_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_murmur2(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_murmur2_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_fnv1a(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_fnv1a_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nrd_kafka_t *rd_kafka_new(rd_kafka_type_t type, rd_kafka_conf_t *conf, char *errstr, size_t errstr_size);\nvoid rd_kafka_destroy(rd_kafka_t *rk);\nvoid rd_kafka_destroy_flags(rd_kafka_t *rk, int flags);\nconst char *rd_kafka_name(const rd_kafka_t *rk);\nrd_kafka_type_t rd_kafka_type(const rd_kafka_t *rk);\nchar *rd_kafka_memberid(const rd_kafka_t *rk);\nchar *rd_kafka_clusterid(rd_kafka_t *rk, int timeout_ms);\nint32_t rd_kafka_controllerid(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_topic_t *rd_kafka_topic_new(rd_kafka_t *rk, const char *topic, rd_kafka_topic_conf_t *conf);\nvoid rd_kafka_topic_destroy(rd_kafka_topic_t *rkt);\nconst char *rd_kafka_topic_name(const rd_kafka_topic_t *rkt);\nvoid *rd_kafka_topic_opaque(const rd_kafka_topic_t *rkt);\nint rd_kafka_poll(rd_kafka_t *rk, int timeout_ms);\nvoid rd_kafka_yield(rd_kafka_t *rk);\nrd_kafka_resp_err_t rd_kafka_pause_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_resp_err_t rd_kafka_resume_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_resp_err_t rd_kafka_query_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high, int timeout_ms);\nrd_kafka_resp_err_t rd_kafka_get_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high);\nrd_kafka_resp_err_t rd_kafka_offsets_for_times(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets, int timeout_ms);\nvoid *rd_kafka_mem_calloc(rd_kafka_t *rk, size_t num, size_t size);\nvoid *rd_kafka_mem_malloc(rd_kafka_t *rk, size_t size);\nvoid rd_kafka_mem_free(rd_kafka_t *rk, void *ptr);\nrd_kafka_queue_t *rd_kafka_queue_new(rd_kafka_t *rk);\nvoid rd_kafka_queue_destroy(rd_kafka_queue_t *rkqu);\nrd_kafka_queue_t *rd_kafka_queue_get_main(rd_kafka_t *rk);\nrd_kafka_queue_t *rd_kafka_queue_get_sasl(rd_kafka_t *rk);\nrd_kafka_error_t *rd_kafka_sasl_background_callbacks_enable(rd_kafka_t *rk);\nrd_kafka_error_t *rd_kafka_sasl_set_credentials(rd_kafka_t *rk, const char *username, const char *password);\nrd_kafka_queue_t *rd_kafka_queue_get_consumer(rd_kafka_t *rk);\nrd_kafka_queue_t *rd_kafka_queue_get_partition(rd_kafka_t *rk, const char *topic, int32_t partition);\nrd_kafka_queue_t *rd_kafka_queue_get_background(rd_kafka_t *rk);\nvoid rd_kafka_queue_forward(rd_kafka_queue_t *src, rd_kafka_queue_t *dst);\nrd_kafka_resp_err_t rd_kafka_set_log_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu);\nsize_t rd_kafka_queue_length(rd_kafka_queue_t *rkqu);\nvoid rd_kafka_queue_io_event_enable(rd_kafka_queue_t *rkqu, int fd, const void *payload, size_t size);\nvoid rd_kafka_queue_cb_event_enable(rd_kafka_queue_t *rkqu, void (*event_cb)(rd_kafka_t *rk, void *qev_opaque), void *qev_opaque);\nvoid rd_kafka_queue_yield(rd_kafka_queue_t *rkqu);\nint rd_kafka_consume_start(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);\nint rd_kafka_consume_start_queue(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, rd_kafka_queue_t *rkqu);\nint rd_kafka_consume_stop(rd_kafka_topic_t *rkt, int32_t partition);\nrd_kafka_resp_err_t rd_kafka_seek(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, int timeout_ms);\nrd_kafka_error_t *rd_kafka_seek_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms);\nrd_kafka_message_t *rd_kafka_consume(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms);\nssize_t rd_kafka_consume_batch(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);\nint rd_kafka_consume_callback(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);\nrd_kafka_message_t *rd_kafka_consume_queue(rd_kafka_queue_t *rkqu, int timeout_ms);\nssize_t rd_kafka_consume_batch_queue(rd_kafka_queue_t *rkqu, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);\nint rd_kafka_consume_callback_queue(rd_kafka_queue_t *rkqu, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);\nrd_kafka_resp_err_t rd_kafka_offset_store(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);\nrd_kafka_resp_err_t rd_kafka_offsets_store(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets);\nrd_kafka_error_t *rd_kafka_offset_store_message(rd_kafka_message_t *rkmessage);\nrd_kafka_resp_err_t rd_kafka_subscribe(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *topics);\nrd_kafka_resp_err_t rd_kafka_unsubscribe(rd_kafka_t *rk);\nrd_kafka_resp_err_t rd_kafka_subscription(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **topics);\nrd_kafka_message_t *rd_kafka_consumer_poll(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_resp_err_t rd_kafka_consumer_close(rd_kafka_t *rk);\nrd_kafka_error_t *rd_kafka_consumer_close_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu);\nint rd_kafka_consumer_closed(rd_kafka_t *rk);\nrd_kafka_error_t *rd_kafka_incremental_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_error_t *rd_kafka_incremental_unassign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);\nconst char *rd_kafka_rebalance_protocol(rd_kafka_t *rk);\nrd_kafka_resp_err_t rd_kafka_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_resp_err_t rd_kafka_assignment(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **partitions);\nint rd_kafka_assignment_lost(rd_kafka_t *rk);\nrd_kafka_resp_err_t rd_kafka_commit(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, int async);\nrd_kafka_resp_err_t rd_kafka_commit_message(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, int async);\nrd_kafka_resp_err_t rd_kafka_commit_queue(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_queue_t *rkqu, void (*cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *commit_opaque), void *commit_opaque);\nrd_kafka_resp_err_t rd_kafka_committed(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms);\nrd_kafka_resp_err_t rd_kafka_position(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata(rd_kafka_t *rk);\nrd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata_new(const char *group_id);\nrd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata_new_with_genid(const char *group_id, int32_t generation_id, const char *member_id, const char *group_instance_id);\nconst char *rd_kafka_consumer_group_metadata_member_id(const rd_kafka_consumer_group_metadata_t *group_metadata);\nvoid rd_kafka_consumer_group_metadata_destroy(rd_kafka_consumer_group_metadata_t *);\nrd_kafka_error_t *rd_kafka_consumer_group_metadata_write(const rd_kafka_consumer_group_metadata_t *cgmd, void **bufferp, size_t *sizep);\nrd_kafka_error_t *rd_kafka_consumer_group_metadata_read(rd_kafka_consumer_group_metadata_t **cgmdp, const void *buffer, size_t size);\nint rd_kafka_produce(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, void *payload, size_t len, const void *key, size_t keylen, void *msg_opaque);\nrd_kafka_resp_err_t rd_kafka_producev(rd_kafka_t *rk, ...);\nrd_kafka_error_t *rd_kafka_produceva(rd_kafka_t *rk, const rd_kafka_vu_t *vus, size_t cnt);\nint rd_kafka_produce_batch(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, rd_kafka_message_t *rkmessages, int message_cnt);\nrd_kafka_resp_err_t rd_kafka_flush(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_resp_err_t rd_kafka_purge(rd_kafka_t *rk, int purge_flags);\ntypedef struct rd_kafka_metadata_broker {\n  int32_t id;\n  char *host;\n  int port;\n} rd_kafka_metadata_broker_t;\ntypedef struct rd_kafka_metadata_partition {\n  int32_t id;\n  rd_kafka_resp_err_t err;\n  int32_t leader;\n  int replica_cnt;\n  int32_t *replicas;\n  int isr_cnt;\n  int32_t *isrs;\n} rd_kafka_metadata_partition_t;\ntypedef struct rd_kafka_metadata_topic {\n  char *topic;\n  int partition_cnt;\n  struct rd_kafka_metadata_partition *partitions;\n  rd_kafka_resp_err_t err;\n} rd_kafka_metadata_topic_t;\ntypedef struct rd_kafka_metadata {\n  int broker_cnt;\n  struct rd_kafka_metadata_broker *brokers;\n  int topic_cnt;\n  struct rd_kafka_metadata_topic *topics;\n  int32_t orig_broker_id;\n  char *orig_broker_name;\n} rd_kafka_metadata_t;\nrd_kafka_resp_err_t rd_kafka_metadata(rd_kafka_t *rk, int all_topics, rd_kafka_topic_t *only_rkt, const struct rd_kafka_metadata **metadatap, int timeout_ms);\nvoid rd_kafka_metadata_destroy(const struct rd_kafka_metadata *metadata);\ntypedef struct rd_kafka_Node_s rd_kafka_Node_t;\nint rd_kafka_Node_id(const rd_kafka_Node_t *node);\nconst char *rd_kafka_Node_host(const rd_kafka_Node_t *node);\nuint16_t rd_kafka_Node_port(const rd_kafka_Node_t *node);\nconst char *rd_kafka_Node_rack(const rd_kafka_Node_t *node);\nstruct rd_kafka_group_member_info {\n  char *member_id;\n  char *client_id;\n  char *client_host;\n  void *member_metadata;\n  int member_metadata_size;\n  void *member_assignment;\n  int member_assignment_size;\n};\ntypedef enum {\n  RD_KAFKA_CONSUMER_GROUP_STATE_UNKNOWN = 0,\n  RD_KAFKA_CONSUMER_GROUP_STATE_PREPARING_REBALANCE = 1,\n  RD_KAFKA_CONSUMER_GROUP_STATE_COMPLETING_REBALANCE = 2,\n  RD_KAFKA_CONSUMER_GROUP_STATE_STABLE = 3,\n  RD_KAFKA_CONSUMER_GROUP_STATE_DEAD = 4,\n  RD_KAFKA_CONSUMER_GROUP_STATE_EMPTY = 5,\n  RD_KAFKA_CONSUMER_GROUP_STATE__CNT,\n} rd_kafka_consumer_group_state_t;\nstruct rd_kafka_group_info {\n  struct rd_kafka_metadata_broker broker;\n  char *group;\n  rd_kafka_resp_err_t err;\n  char *state;\n  char *protocol_type;\n  char *protocol;\n  struct rd_kafka_group_member_info *members;\n  int member_cnt;\n};\nstruct rd_kafka_group_list {\n  struct rd_kafka_group_info *groups;\n  int group_cnt;\n};\nrd_kafka_resp_err_t rd_kafka_list_groups(rd_kafka_t *rk, const char *group, const struct rd_kafka_group_list **grplistp, int timeout_ms);\nconst char *rd_kafka_consumer_group_state_name(rd_kafka_consumer_group_state_t state);\nrd_kafka_consumer_group_state_t rd_kafka_consumer_group_state_code(const char *name);\nvoid rd_kafka_group_list_destroy(const struct rd_kafka_group_list *grplist);\nint rd_kafka_brokers_add(rd_kafka_t *rk, const char *brokerlist);\nvoid rd_kafka_set_logger(rd_kafka_t *rk, void (*func)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));\nvoid rd_kafka_set_log_level(rd_kafka_t *rk, int level);\nvoid rd_kafka_log_print(const rd_kafka_t *rk, int level, const char *fac, const char *buf);\nvoid rd_kafka_log_syslog(const rd_kafka_t *rk, int level, const char *fac, const char *buf);\nint rd_kafka_outq_len(rd_kafka_t *rk);\nvoid rd_kafka_dump(FILE *fp, rd_kafka_t *rk);\nint rd_kafka_thread_cnt(void);\ntypedef enum rd_kafka_thread_type_t {\n  RD_KAFKA_THREAD_MAIN,\n  RD_KAFKA_THREAD_BACKGROUND,\n  RD_KAFKA_THREAD_BROKER,\n} rd_kafka_thread_type_t;\nint rd_kafka_wait_destroyed(int timeout_ms);\nint rd_kafka_unittest(void);\nrd_kafka_resp_err_t rd_kafka_poll_set_consumer(rd_kafka_t *rk);\ntypedef int rd_kafka_event_type_t;\nrd_kafka_event_type_t rd_kafka_event_type(const rd_kafka_event_t *rkev);\nconst char *rd_kafka_event_name(const rd_kafka_event_t *rkev);\nvoid rd_kafka_event_destroy(rd_kafka_event_t *rkev);\nconst rd_kafka_message_t *rd_kafka_event_message_next(rd_kafka_event_t *rkev);\nsize_t rd_kafka_event_message_array(rd_kafka_event_t *rkev, const rd_kafka_message_t **rkmessages, size_t size);\nsize_t rd_kafka_event_message_count(rd_kafka_event_t *rkev);\nconst char *rd_kafka_event_config_string(rd_kafka_event_t *rkev);\nrd_kafka_resp_err_t rd_kafka_event_error(rd_kafka_event_t *rkev);\nconst char *rd_kafka_event_error_string(rd_kafka_event_t *rkev);\nint rd_kafka_event_error_is_fatal(rd_kafka_event_t *rkev);\nvoid *rd_kafka_event_opaque(rd_kafka_event_t *rkev);\nint rd_kafka_event_log(rd_kafka_event_t *rkev, const char **fac, const char **str, int *level);\nint rd_kafka_event_debug_contexts(rd_kafka_event_t *rkev, char *dst, size_t dstsize);\nconst char *rd_kafka_event_stats(rd_kafka_event_t *rkev);\nrd_kafka_topic_partition_list_t *rd_kafka_event_topic_partition_list(rd_kafka_event_t *rkev);\nrd_kafka_topic_partition_t *rd_kafka_event_topic_partition(rd_kafka_event_t *rkev);\ntypedef rd_kafka_event_t rd_kafka_CreateTopics_result_t;\ntypedef rd_kafka_event_t rd_kafka_DeleteTopics_result_t;\ntypedef rd_kafka_event_t rd_kafka_CreateAcls_result_t;\ntypedef rd_kafka_event_t rd_kafka_DescribeAcls_result_t;\ntypedef rd_kafka_event_t rd_kafka_DeleteAcls_result_t;\ntypedef rd_kafka_event_t rd_kafka_CreatePartitions_result_t;\ntypedef rd_kafka_event_t rd_kafka_AlterConfigs_result_t;\ntypedef rd_kafka_event_t rd_kafka_IncrementalAlterConfigs_result_t;\ntypedef rd_kafka_event_t rd_kafka_DescribeConfigs_result_t;\ntypedef rd_kafka_event_t rd_kafka_DeleteRecords_result_t;\ntypedef rd_kafka_event_t rd_kafka_ListConsumerGroups_result_t;\ntypedef rd_kafka_event_t rd_kafka_DescribeConsumerGroups_result_t;\ntypedef rd_kafka_event_t rd_kafka_DeleteGroups_result_t;\ntypedef rd_kafka_event_t rd_kafka_DeleteConsumerGroupOffsets_result_t;\ntypedef rd_kafka_event_t rd_kafka_AlterConsumerGroupOffsets_result_t;\ntypedef rd_kafka_event_t rd_kafka_ListConsumerGroupOffsets_result_t;\ntypedef rd_kafka_event_t rd_kafka_DescribeTopics_result_t;\ntypedef rd_kafka_event_t rd_kafka_DescribeCluster_result_t;\ntypedef rd_kafka_event_t rd_kafka_DescribeUserScramCredentials_result_t;\ntypedef rd_kafka_event_t rd_kafka_AlterUserScramCredentials_result_t;\ntypedef rd_kafka_event_t rd_kafka_ListOffsets_result_t;\nconst rd_kafka_CreateTopics_result_t *rd_kafka_event_CreateTopics_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DeleteTopics_result_t *rd_kafka_event_DeleteTopics_result(rd_kafka_event_t *rkev);\nconst rd_kafka_CreatePartitions_result_t *rd_kafka_event_CreatePartitions_result(rd_kafka_event_t *rkev);\nconst rd_kafka_AlterConfigs_result_t *rd_kafka_event_AlterConfigs_result(rd_kafka_event_t *rkev);\nconst rd_kafka_IncrementalAlterConfigs_result_t *rd_kafka_event_IncrementalAlterConfigs_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DescribeConfigs_result_t *rd_kafka_event_DescribeConfigs_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DeleteRecords_result_t *rd_kafka_event_DeleteRecords_result(rd_kafka_event_t *rkev);\nconst rd_kafka_ListConsumerGroups_result_t *rd_kafka_event_ListConsumerGroups_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DescribeConsumerGroups_result_t *rd_kafka_event_DescribeConsumerGroups_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DescribeTopics_result_t *rd_kafka_event_DescribeTopics_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DescribeCluster_result_t *rd_kafka_event_DescribeCluster_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DeleteGroups_result_t *rd_kafka_event_DeleteGroups_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DeleteConsumerGroupOffsets_result_t *rd_kafka_event_DeleteConsumerGroupOffsets_result(rd_kafka_event_t *rkev);\nconst rd_kafka_CreateAcls_result_t *rd_kafka_event_CreateAcls_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DescribeAcls_result_t *rd_kafka_event_DescribeAcls_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DeleteAcls_result_t *rd_kafka_event_DeleteAcls_result(rd_kafka_event_t *rkev);\nconst rd_kafka_ListConsumerGroupOffsets_result_t *rd_kafka_event_ListConsumerGroupOffsets_result(rd_kafka_event_t *rkev);\nconst rd_kafka_AlterConsumerGroupOffsets_result_t *rd_kafka_event_AlterConsumerGroupOffsets_result(rd_kafka_event_t *rkev);\nconst rd_kafka_ListOffsets_result_t *rd_kafka_event_ListOffsets_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DescribeUserScramCredentials_result_t *rd_kafka_event_DescribeUserScramCredentials_result(rd_kafka_event_t *rkev);\nconst rd_kafka_AlterUserScramCredentials_result_t *rd_kafka_event_AlterUserScramCredentials_result(rd_kafka_event_t *rkev);\nrd_kafka_event_t *rd_kafka_queue_poll(rd_kafka_queue_t *rkqu, int timeout_ms);\nint rd_kafka_queue_poll_callback(rd_kafka_queue_t *rkqu, int timeout_ms);\ntypedef rd_kafka_resp_err_t (rd_kafka_plugin_f_conf_init_t)(rd_kafka_conf_t *conf, void **plug_opaquep, char *errstr, size_t errstr_size);\ntypedef rd_kafka_conf_res_t (rd_kafka_interceptor_f_on_conf_set_t)(rd_kafka_conf_t *conf, const char *name, const char *val, char *errstr, size_t errstr_size, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_dup_t)(rd_kafka_conf_t *new_conf, const rd_kafka_conf_t *old_conf, size_t filter_cnt, const char **filter, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_destroy_t)(void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_new_t)(rd_kafka_t *rk, const rd_kafka_conf_t *conf, void *ic_opaque, char *errstr, size_t errstr_size);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_destroy_t)(rd_kafka_t *rk, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_send_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_acknowledgement_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_consume_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_commit_t)(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_resp_err_t err, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_request_sent_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_response_received_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, int64_t rtt, rd_kafka_resp_err_t err, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_start_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_exit_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_broker_state_change_t)(rd_kafka_t *rk, int32_t broker_id, const char *secproto, const char *name, int port, const char *state, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_set(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_set_t *on_conf_set, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_dup(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_dup_t *on_conf_dup, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_destroy(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_destroy_t *on_conf_destroy, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_new(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_new_t *on_new, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_destroy(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_destroy_t *on_destroy, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_send(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_send_t *on_send, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_acknowledgement(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_acknowledgement_t *on_acknowledgement, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_consume(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_consume_t *on_consume, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_commit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_commit_t *on_commit, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_request_sent(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_request_sent_t *on_request_sent, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_response_received(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_response_received_t *on_response_received, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_start(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_start_t *on_thread_start, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_exit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_exit_t *on_thread_exit, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_broker_state_change(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_broker_state_change_t *on_broker_state_change, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_topic_result_error(const rd_kafka_topic_result_t *topicres);\nconst char *rd_kafka_topic_result_error_string(const rd_kafka_topic_result_t *topicres);\nconst char *rd_kafka_topic_result_name(const rd_kafka_topic_result_t *topicres);\nconst rd_kafka_error_t *rd_kafka_group_result_error(const rd_kafka_group_result_t *groupres);\nconst char *rd_kafka_group_result_name(const rd_kafka_group_result_t *groupres);\nconst rd_kafka_topic_partition_list_t *rd_kafka_group_result_partitions(const rd_kafka_group_result_t *groupres);\ntypedef enum rd_kafka_admin_op_t {\n  RD_KAFKA_ADMIN_OP_ANY = 0,\n  RD_KAFKA_ADMIN_OP_CREATETOPICS,\n  RD_KAFKA_ADMIN_OP_DELETETOPICS,\n  RD_KAFKA_ADMIN_OP_CREATEPARTITIONS,\n  RD_KAFKA_ADMIN_OP_ALTERCONFIGS,\n  RD_KAFKA_ADMIN_OP_DESCRIBECONFIGS,\n  RD_KAFKA_ADMIN_OP_DELETERECORDS,\n  RD_KAFKA_ADMIN_OP_DELETEGROUPS,\n  RD_KAFKA_ADMIN_OP_DELETECONSUMERGROUPOFFSETS,\n  RD_KAFKA_ADMIN_OP_CREATEACLS,\n  RD_KAFKA_ADMIN_OP_DESCRIBEACLS,\n  RD_KAFKA_ADMIN_OP_DELETEACLS,\n  RD_KAFKA_ADMIN_OP_LISTCONSUMERGROUPS,\n  RD_KAFKA_ADMIN_OP_DESCRIBECONSUMERGROUPS,\n  RD_KAFKA_ADMIN_OP_LISTCONSUMERGROUPOFFSETS,\n  RD_KAFKA_ADMIN_OP_ALTERCONSUMERGROUPOFFSETS,\n  RD_KAFKA_ADMIN_OP_INCREMENTALALTERCONFIGS,\n  RD_KAFKA_ADMIN_OP_DESCRIBEUSERSCRAMCREDENTIALS,\n  RD_KAFKA_ADMIN_OP_ALTERUSERSCRAMCREDENTIALS,\n  RD_KAFKA_ADMIN_OP_DESCRIBETOPICS,\n  RD_KAFKA_ADMIN_OP_DESCRIBECLUSTER,\n  RD_KAFKA_ADMIN_OP_LISTOFFSETS,\n  RD_KAFKA_ADMIN_OP__CNT,\n} rd_kafka_admin_op_t;\ntypedef struct rd_kafka_AdminOptions_s rd_kafka_AdminOptions_t;\ntypedef enum rd_kafka_IsolationLevel_t {\n  RD_KAFKA_ISOLATION_LEVEL_READ_UNCOMMITTED = 0,\n  RD_KAFKA_ISOLATION_LEVEL_READ_COMMITTED = 1,\n} rd_kafka_IsolationLevel_t;\nrd_kafka_AdminOptions_t *rd_kafka_AdminOptions_new(rd_kafka_t *rk, rd_kafka_admin_op_t for_api);\nvoid rd_kafka_AdminOptions_destroy(rd_kafka_AdminOptions_t *options);\nrd_kafka_resp_err_t rd_kafka_AdminOptions_set_request_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_AdminOptions_set_operation_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_AdminOptions_set_validate_only(rd_kafka_AdminOptions_t *options, int true_or_false, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_AdminOptions_set_broker(rd_kafka_AdminOptions_t *options, int32_t broker_id, char *errstr, size_t errstr_size);\nrd_kafka_error_t *rd_kafka_AdminOptions_set_require_stable_offsets(rd_kafka_AdminOptions_t *options, int true_or_false);\nrd_kafka_error_t *rd_kafka_AdminOptions_set_include_authorized_operations(rd_kafka_AdminOptions_t *options, int true_or_false);\nrd_kafka_error_t *rd_kafka_AdminOptions_set_match_consumer_group_states(rd_kafka_AdminOptions_t *options, const rd_kafka_consumer_group_state_t *consumer_group_states, size_t consumer_group_states_cnt);\nrd_kafka_error_t *rd_kafka_AdminOptions_set_isolation_level(rd_kafka_AdminOptions_t *options, rd_kafka_IsolationLevel_t value);\nvoid rd_kafka_AdminOptions_set_opaque(rd_kafka_AdminOptions_t *options, void *ev_opaque);\ntypedef enum rd_kafka_AclOperation_t {\n  RD_KAFKA_ACL_OPERATION_UNKNOWN = 0,\n  RD_KAFKA_ACL_OPERATION_ANY = 1,\n  RD_KAFKA_ACL_OPERATION_ALL = 2,\n  RD_KAFKA_ACL_OPERATION_READ = 3,\n  RD_KAFKA_ACL_OPERATION_WRITE = 4,\n  RD_KAFKA_ACL_OPERATION_CREATE = 5,\n  RD_KAFKA_ACL_OPERATION_DELETE = 6,\n  RD_KAFKA_ACL_OPERATION_ALTER = 7,\n  RD_KAFKA_ACL_OPERATION_DESCRIBE = 8,\n  RD_KAFKA_ACL_OPERATION_CLUSTER_ACTION = 9,\n  RD_KAFKA_ACL_OPERATION_DESCRIBE_CONFIGS = 10,\n  RD_KAFKA_ACL_OPERATION_ALTER_CONFIGS = 11,\n  RD_KAFKA_ACL_OPERATION_IDEMPOTENT_WRITE = 12,\n  RD_KAFKA_ACL_OPERATION__CNT,\n} rd_kafka_AclOperation_t;\ntypedef struct rd_kafka_NewTopic_s rd_kafka_NewTopic_t;\nrd_kafka_NewTopic_t *rd_kafka_NewTopic_new(const char *topic, int num_partitions, int replication_factor, char *errstr, size_t errstr_size);\nvoid rd_kafka_NewTopic_destroy(rd_kafka_NewTopic_t *new_topic);\nvoid rd_kafka_NewTopic_destroy_array(rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt);\nrd_kafka_resp_err_t rd_kafka_NewTopic_set_replica_assignment(rd_kafka_NewTopic_t *new_topic, int32_t partition, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_NewTopic_set_config(rd_kafka_NewTopic_t *new_topic, const char *name, const char *value);\nvoid rd_kafka_CreateTopics(rd_kafka_t *rk, rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_topic_result_t **rd_kafka_CreateTopics_result_topics(const rd_kafka_CreateTopics_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_DeleteTopic_s rd_kafka_DeleteTopic_t;\nrd_kafka_DeleteTopic_t *rd_kafka_DeleteTopic_new(const char *topic);\nvoid rd_kafka_DeleteTopic_destroy(rd_kafka_DeleteTopic_t *del_topic);\nvoid rd_kafka_DeleteTopic_destroy_array(rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt);\nvoid rd_kafka_DeleteTopics(rd_kafka_t *rk, rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_topic_result_t **rd_kafka_DeleteTopics_result_topics(const rd_kafka_DeleteTopics_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_NewPartitions_s rd_kafka_NewPartitions_t;\nrd_kafka_NewPartitions_t *rd_kafka_NewPartitions_new(const char *topic, size_t new_total_cnt, char *errstr, size_t errstr_size);\nvoid rd_kafka_NewPartitions_destroy(rd_kafka_NewPartitions_t *new_parts);\nvoid rd_kafka_NewPartitions_destroy_array(rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt);\nrd_kafka_resp_err_t rd_kafka_NewPartitions_set_replica_assignment(rd_kafka_NewPartitions_t *new_parts, int32_t new_partition_idx, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);\nvoid rd_kafka_CreatePartitions(rd_kafka_t *rk, rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_topic_result_t **rd_kafka_CreatePartitions_result_topics(const rd_kafka_CreatePartitions_result_t *result, size_t *cntp);\ntypedef enum rd_kafka_ConfigSource_t {\n  RD_KAFKA_CONFIG_SOURCE_UNKNOWN_CONFIG = 0,\n  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_TOPIC_CONFIG = 1,\n  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_BROKER_CONFIG = 2,\n  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_DEFAULT_BROKER_CONFIG = 3,\n  RD_KAFKA_CONFIG_SOURCE_STATIC_BROKER_CONFIG = 4,\n  RD_KAFKA_CONFIG_SOURCE_DEFAULT_CONFIG = 5,\n  RD_KAFKA_CONFIG_SOURCE__CNT,\n} rd_kafka_ConfigSource_t;\nconst char *rd_kafka_ConfigSource_name(rd_kafka_ConfigSource_t confsource);\ntypedef struct rd_kafka_ConfigEntry_s rd_kafka_ConfigEntry_t;\nconst char *rd_kafka_ConfigEntry_name(const rd_kafka_ConfigEntry_t *entry);\nconst char *rd_kafka_ConfigEntry_value(const rd_kafka_ConfigEntry_t *entry);\nrd_kafka_ConfigSource_t rd_kafka_ConfigEntry_source(const rd_kafka_ConfigEntry_t *entry);\nint rd_kafka_ConfigEntry_is_read_only(const rd_kafka_ConfigEntry_t *entry);\nint rd_kafka_ConfigEntry_is_default(const rd_kafka_ConfigEntry_t *entry);\nint rd_kafka_ConfigEntry_is_sensitive(const rd_kafka_ConfigEntry_t *entry);\nint rd_kafka_ConfigEntry_is_synonym(const rd_kafka_ConfigEntry_t *entry);\nconst rd_kafka_ConfigEntry_t **rd_kafka_ConfigEntry_synonyms(const rd_kafka_ConfigEntry_t *entry, size_t *cntp);\ntypedef enum rd_kafka_ResourceType_t {\n  RD_KAFKA_RESOURCE_UNKNOWN = 0,\n  RD_KAFKA_RESOURCE_ANY = 1,\n  RD_KAFKA_RESOURCE_TOPIC = 2,\n  RD_KAFKA_RESOURCE_GROUP = 3,\n  RD_KAFKA_RESOURCE_BROKER = 4,\n  RD_KAFKA_RESOURCE__CNT,\n} rd_kafka_ResourceType_t;\ntypedef enum rd_kafka_ResourcePatternType_t {\n  RD_KAFKA_RESOURCE_PATTERN_UNKNOWN = 0,\n  RD_KAFKA_RESOURCE_PATTERN_ANY = 1,\n  RD_KAFKA_RESOURCE_PATTERN_MATCH = 2,\n  RD_KAFKA_RESOURCE_PATTERN_LITERAL = 3,\n  RD_KAFKA_RESOURCE_PATTERN_PREFIXED = 4,\n  RD_KAFKA_RESOURCE_PATTERN_TYPE__CNT,\n} rd_kafka_ResourcePatternType_t;\ntypedef enum rd_kafka_AlterConfigOpType_t {\n  RD_KAFKA_ALTER_CONFIG_OP_TYPE_SET = 0,\n  RD_KAFKA_ALTER_CONFIG_OP_TYPE_DELETE = 1,\n  RD_KAFKA_ALTER_CONFIG_OP_TYPE_APPEND = 2,\n  RD_KAFKA_ALTER_CONFIG_OP_TYPE_SUBTRACT = 3,\n  RD_KAFKA_ALTER_CONFIG_OP_TYPE__CNT,\n} rd_kafka_AlterConfigOpType_t;\nconst char *rd_kafka_ResourcePatternType_name(rd_kafka_ResourcePatternType_t resource_pattern_type);\nconst char *rd_kafka_ResourceType_name(rd_kafka_ResourceType_t restype);\ntypedef struct rd_kafka_ConfigResource_s rd_kafka_ConfigResource_t;\nrd_kafka_ConfigResource_t *rd_kafka_ConfigResource_new(rd_kafka_ResourceType_t restype, const char *resname);\nvoid rd_kafka_ConfigResource_destroy(rd_kafka_ConfigResource_t *config);\nvoid rd_kafka_ConfigResource_destroy_array(rd_kafka_ConfigResource_t **config, size_t config_cnt);\nrd_kafka_resp_err_t rd_kafka_ConfigResource_set_config(rd_kafka_ConfigResource_t *config, const char *name, const char *value);\nrd_kafka_error_t *rd_kafka_ConfigResource_add_incremental_config(rd_kafka_ConfigResource_t *config, const char *name, rd_kafka_AlterConfigOpType_t op_type, const char *value);\nconst rd_kafka_ConfigEntry_t **rd_kafka_ConfigResource_configs(const rd_kafka_ConfigResource_t *config, size_t *cntp);\nrd_kafka_ResourceType_t rd_kafka_ConfigResource_type(const rd_kafka_ConfigResource_t *config);\nconst char *rd_kafka_ConfigResource_name(const rd_kafka_ConfigResource_t *config);\nrd_kafka_resp_err_t rd_kafka_ConfigResource_error(const rd_kafka_ConfigResource_t *config);\nconst char *rd_kafka_ConfigResource_error_string(const rd_kafka_ConfigResource_t *config);\nvoid rd_kafka_AlterConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_ConfigResource_t **rd_kafka_AlterConfigs_result_resources(const rd_kafka_AlterConfigs_result_t *result, size_t *cntp);\nvoid rd_kafka_IncrementalAlterConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_ConfigResource_t **rd_kafka_IncrementalAlterConfigs_result_resources(const rd_kafka_IncrementalAlterConfigs_result_t *result, size_t *cntp);\nvoid rd_kafka_DescribeConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_ConfigResource_t **rd_kafka_DescribeConfigs_result_resources(const rd_kafka_DescribeConfigs_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_DeleteRecords_s rd_kafka_DeleteRecords_t;\nrd_kafka_DeleteRecords_t *rd_kafka_DeleteRecords_new(const rd_kafka_topic_partition_list_t *before_offsets);\nvoid rd_kafka_DeleteRecords_destroy(rd_kafka_DeleteRecords_t *del_records);\nvoid rd_kafka_DeleteRecords_destroy_array(rd_kafka_DeleteRecords_t **del_records, size_t del_record_cnt);\nvoid rd_kafka_DeleteRecords(rd_kafka_t *rk, rd_kafka_DeleteRecords_t **del_records, size_t del_record_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_topic_partition_list_t *rd_kafka_DeleteRecords_result_offsets(const rd_kafka_DeleteRecords_result_t *result);\ntypedef struct rd_kafka_TopicCollection_s rd_kafka_TopicCollection_t;\ntypedef struct rd_kafka_TopicPartitionInfo_s rd_kafka_TopicPartitionInfo_t;\ntypedef struct rd_kafka_TopicDescription_s rd_kafka_TopicDescription_t;\nrd_kafka_TopicCollection_t *rd_kafka_TopicCollection_of_topic_names(const char **topics, size_t topics_cnt);\nvoid rd_kafka_TopicCollection_destroy(rd_kafka_TopicCollection_t *topics);\nvoid rd_kafka_DescribeTopics(rd_kafka_t *rk, const rd_kafka_TopicCollection_t *topics, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_TopicDescription_t **rd_kafka_DescribeTopics_result_topics(const rd_kafka_DescribeTopics_result_t *result, size_t *cntp);\nconst rd_kafka_TopicPartitionInfo_t **rd_kafka_TopicDescription_partitions(const rd_kafka_TopicDescription_t *topicdesc, size_t *cntp);\nconst int rd_kafka_TopicPartitionInfo_partition(const rd_kafka_TopicPartitionInfo_t *partition);\nconst rd_kafka_Node_t *rd_kafka_TopicPartitionInfo_leader(const rd_kafka_TopicPartitionInfo_t *partition);\nconst rd_kafka_Node_t **rd_kafka_TopicPartitionInfo_isr(const rd_kafka_TopicPartitionInfo_t *partition, size_t *cntp);\nconst rd_kafka_Node_t **rd_kafka_TopicPartitionInfo_replicas(const rd_kafka_TopicPartitionInfo_t *partition, size_t *cntp);\nconst rd_kafka_AclOperation_t *rd_kafka_TopicDescription_authorized_operations(const rd_kafka_TopicDescription_t *topicdesc, size_t *cntp);\nconst char *rd_kafka_TopicDescription_name(const rd_kafka_TopicDescription_t *topicdesc);\nconst rd_kafka_Uuid_t *rd_kafka_TopicDescription_topic_id(const rd_kafka_TopicDescription_t *topicdesc);\nint rd_kafka_TopicDescription_is_internal(const rd_kafka_TopicDescription_t *topicdesc);\nconst rd_kafka_error_t *rd_kafka_TopicDescription_error(const rd_kafka_TopicDescription_t *topicdesc);\nvoid rd_kafka_DescribeCluster(rd_kafka_t *rk, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_Node_t **rd_kafka_DescribeCluster_result_nodes(const rd_kafka_DescribeCluster_result_t *result, size_t *cntp);\nconst rd_kafka_AclOperation_t *rd_kafka_DescribeCluster_result_authorized_operations(const rd_kafka_DescribeCluster_result_t *result, size_t *cntp);\nconst rd_kafka_Node_t *rd_kafka_DescribeCluster_result_controller(const rd_kafka_DescribeCluster_result_t *result);\nconst char *rd_kafka_DescribeCluster_result_cluster_id(const rd_kafka_DescribeCluster_result_t *result);\ntypedef struct rd_kafka_ConsumerGroupListing_s rd_kafka_ConsumerGroupListing_t;\ntypedef struct rd_kafka_ListConsumerGroupsResult_s rd_kafka_ListConsumerGroupsResult_t;\nvoid rd_kafka_ListConsumerGroups(rd_kafka_t *rk, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst char *rd_kafka_ConsumerGroupListing_group_id(const rd_kafka_ConsumerGroupListing_t *grplist);\nint rd_kafka_ConsumerGroupListing_is_simple_consumer_group(const rd_kafka_ConsumerGroupListing_t *grplist);\nrd_kafka_consumer_group_state_t rd_kafka_ConsumerGroupListing_state(const rd_kafka_ConsumerGroupListing_t *grplist);\nconst rd_kafka_ConsumerGroupListing_t **rd_kafka_ListConsumerGroups_result_valid(const rd_kafka_ListConsumerGroups_result_t *result, size_t *cntp);\nconst rd_kafka_error_t **rd_kafka_ListConsumerGroups_result_errors(const rd_kafka_ListConsumerGroups_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_ConsumerGroupDescription_s rd_kafka_ConsumerGroupDescription_t;\ntypedef struct rd_kafka_MemberDescription_s rd_kafka_MemberDescription_t;\ntypedef struct rd_kafka_MemberAssignment_s rd_kafka_MemberAssignment_t;\nvoid rd_kafka_DescribeConsumerGroups(rd_kafka_t *rk, const char **groups, size_t groups_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_ConsumerGroupDescription_t **rd_kafka_DescribeConsumerGroups_result_groups(const rd_kafka_DescribeConsumerGroups_result_t *result, size_t *cntp);\nconst char *rd_kafka_ConsumerGroupDescription_group_id(const rd_kafka_ConsumerGroupDescription_t *grpdesc);\nconst rd_kafka_error_t *rd_kafka_ConsumerGroupDescription_error(const rd_kafka_ConsumerGroupDescription_t *grpdesc);\nint rd_kafka_ConsumerGroupDescription_is_simple_consumer_group(const rd_kafka_ConsumerGroupDescription_t *grpdesc);\nconst char *rd_kafka_ConsumerGroupDescription_partition_assignor(const rd_kafka_ConsumerGroupDescription_t *grpdesc);\nconst rd_kafka_AclOperation_t *rd_kafka_ConsumerGroupDescription_authorized_operations(const rd_kafka_ConsumerGroupDescription_t *grpdesc, size_t *cntp);\nrd_kafka_consumer_group_state_t rd_kafka_ConsumerGroupDescription_state(const rd_kafka_ConsumerGroupDescription_t *grpdesc);\nconst rd_kafka_Node_t *rd_kafka_ConsumerGroupDescription_coordinator(const rd_kafka_ConsumerGroupDescription_t *grpdesc);\nsize_t rd_kafka_ConsumerGroupDescription_member_count(const rd_kafka_ConsumerGroupDescription_t *grpdesc);\nconst rd_kafka_MemberDescription_t *rd_kafka_ConsumerGroupDescription_member(const rd_kafka_ConsumerGroupDescription_t *grpdesc, size_t idx);\nconst char *rd_kafka_MemberDescription_client_id(const rd_kafka_MemberDescription_t *member);\nconst char *rd_kafka_MemberDescription_group_instance_id(const rd_kafka_MemberDescription_t *member);\nconst char *rd_kafka_MemberDescription_consumer_id(const rd_kafka_MemberDescription_t *member);\nconst char *rd_kafka_MemberDescription_host(const rd_kafka_MemberDescription_t *member);\nconst rd_kafka_MemberAssignment_t *rd_kafka_MemberDescription_assignment(const rd_kafka_MemberDescription_t *member);\nconst rd_kafka_topic_partition_list_t *rd_kafka_MemberAssignment_partitions(const rd_kafka_MemberAssignment_t *assignment);\ntypedef struct rd_kafka_DeleteGroup_s rd_kafka_DeleteGroup_t;\nrd_kafka_DeleteGroup_t *rd_kafka_DeleteGroup_new(const char *group);\nvoid rd_kafka_DeleteGroup_destroy(rd_kafka_DeleteGroup_t *del_group);\nvoid rd_kafka_DeleteGroup_destroy_array(rd_kafka_DeleteGroup_t **del_groups, size_t del_group_cnt);\nvoid rd_kafka_DeleteGroups(rd_kafka_t *rk, rd_kafka_DeleteGroup_t **del_groups, size_t del_group_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_group_result_t **rd_kafka_DeleteGroups_result_groups(const rd_kafka_DeleteGroups_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_ListConsumerGroupOffsets_s rd_kafka_ListConsumerGroupOffsets_t;\nrd_kafka_ListConsumerGroupOffsets_t *rd_kafka_ListConsumerGroupOffsets_new(const char *group_id, const rd_kafka_topic_partition_list_t *partitions);\nvoid rd_kafka_ListConsumerGroupOffsets_destroy(rd_kafka_ListConsumerGroupOffsets_t *list_grpoffsets);\nvoid rd_kafka_ListConsumerGroupOffsets_destroy_array(rd_kafka_ListConsumerGroupOffsets_t **list_grpoffsets, size_t list_grpoffset_cnt);\nvoid rd_kafka_ListConsumerGroupOffsets(rd_kafka_t *rk, rd_kafka_ListConsumerGroupOffsets_t **list_grpoffsets, size_t list_grpoffsets_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_group_result_t **rd_kafka_ListConsumerGroupOffsets_result_groups(const rd_kafka_ListConsumerGroupOffsets_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_AlterConsumerGroupOffsets_s rd_kafka_AlterConsumerGroupOffsets_t;\nrd_kafka_AlterConsumerGroupOffsets_t *rd_kafka_AlterConsumerGroupOffsets_new(const char *group_id, const rd_kafka_topic_partition_list_t *partitions);\nvoid rd_kafka_AlterConsumerGroupOffsets_destroy(rd_kafka_AlterConsumerGroupOffsets_t *alter_grpoffsets);\nvoid rd_kafka_AlterConsumerGroupOffsets_destroy_array(rd_kafka_AlterConsumerGroupOffsets_t **alter_grpoffsets, size_t alter_grpoffset_cnt);\nvoid rd_kafka_AlterConsumerGroupOffsets(rd_kafka_t *rk, rd_kafka_AlterConsumerGroupOffsets_t **alter_grpoffsets, size_t alter_grpoffsets_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_group_result_t **rd_kafka_AlterConsumerGroupOffsets_result_groups(const rd_kafka_AlterConsumerGroupOffsets_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_DeleteConsumerGroupOffsets_s rd_kafka_DeleteConsumerGroupOffsets_t;\nrd_kafka_DeleteConsumerGroupOffsets_t *rd_kafka_DeleteConsumerGroupOffsets_new(const char *group, const rd_kafka_topic_partition_list_t *partitions);\nvoid rd_kafka_DeleteConsumerGroupOffsets_destroy(rd_kafka_DeleteConsumerGroupOffsets_t *del_grpoffsets);\nvoid rd_kafka_DeleteConsumerGroupOffsets_destroy_array(rd_kafka_DeleteConsumerGroupOffsets_t **del_grpoffsets, size_t del_grpoffset_cnt);\nvoid rd_kafka_DeleteConsumerGroupOffsets(rd_kafka_t *rk, rd_kafka_DeleteConsumerGroupOffsets_t **del_grpoffsets, size_t del_grpoffsets_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_group_result_t **rd_kafka_DeleteConsumerGroupOffsets_result_groups(const rd_kafka_DeleteConsumerGroupOffsets_result_t *result, size_t *cntp);\ntypedef enum rd_kafka_OffsetSpec_t {\n  RD_KAFKA_OFFSET_SPEC_MAX_TIMESTAMP = (- 3),\n  RD_KAFKA_OFFSET_SPEC_EARLIEST = (- 2),\n  RD_KAFKA_OFFSET_SPEC_LATEST = (- 1),\n} rd_kafka_OffsetSpec_t;\ntypedef struct rd_kafka_ListOffsetsResultInfo_s rd_kafka_ListOffsetsResultInfo_t;\nconst rd_kafka_topic_partition_t *rd_kafka_ListOffsetsResultInfo_topic_partition(const rd_kafka_ListOffsetsResultInfo_t *result_info);\nint64_t rd_kafka_ListOffsetsResultInfo_timestamp(const rd_kafka_ListOffsetsResultInfo_t *result_info);\nconst rd_kafka_ListOffsetsResultInfo_t **rd_kafka_ListOffsets_result_infos(const rd_kafka_ListOffsets_result_t *result, size_t *cntp);\nvoid rd_kafka_ListOffsets(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *topic_partitions, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\ntypedef enum rd_kafka_ScramMechanism_t {\n  RD_KAFKA_SCRAM_MECHANISM_UNKNOWN = 0,\n  RD_KAFKA_SCRAM_MECHANISM_SHA_256 = 1,\n  RD_KAFKA_SCRAM_MECHANISM_SHA_512 = 2,\n  RD_KAFKA_SCRAM_MECHANISM__CNT,\n} rd_kafka_ScramMechanism_t;\ntypedef struct rd_kafka_ScramCredentialInfo_s rd_kafka_ScramCredentialInfo_t;\nrd_kafka_ScramMechanism_t rd_kafka_ScramCredentialInfo_mechanism(const rd_kafka_ScramCredentialInfo_t *scram_credential_info);\nint32_t rd_kafka_ScramCredentialInfo_iterations(const rd_kafka_ScramCredentialInfo_t *scram_credential_info);\ntypedef struct rd_kafka_UserScramCredentialsDescription_s rd_kafka_UserScramCredentialsDescription_t;\nconst char *rd_kafka_UserScramCredentialsDescription_user(const rd_kafka_UserScramCredentialsDescription_t *description);\nconst rd_kafka_error_t *rd_kafka_UserScramCredentialsDescription_error(const rd_kafka_UserScramCredentialsDescription_t *description);\nsize_t rd_kafka_UserScramCredentialsDescription_scramcredentialinfo_count(const rd_kafka_UserScramCredentialsDescription_t *description);\nconst rd_kafka_ScramCredentialInfo_t *rd_kafka_UserScramCredentialsDescription_scramcredentialinfo(const rd_kafka_UserScramCredentialsDescription_t *description, size_t idx);\nconst rd_kafka_UserScramCredentialsDescription_t **rd_kafka_DescribeUserScramCredentials_result_descriptions(const rd_kafka_DescribeUserScramCredentials_result_t *result, size_t *cntp);\nvoid rd_kafka_DescribeUserScramCredentials(rd_kafka_t *rk, const char **users, size_t user_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\ntypedef struct rd_kafka_UserScramCredentialAlteration_s rd_kafka_UserScramCredentialAlteration_t;\nrd_kafka_UserScramCredentialAlteration_t *rd_kafka_UserScramCredentialUpsertion_new(const char *username, rd_kafka_ScramMechanism_t mechanism, int32_t iterations, const unsigned char *password, size_t password_size, const unsigned char *salt, size_t salt_size);\nrd_kafka_UserScramCredentialAlteration_t *rd_kafka_UserScramCredentialDeletion_new(const char *username, rd_kafka_ScramMechanism_t mechanism);\nvoid rd_kafka_UserScramCredentialAlteration_destroy(rd_kafka_UserScramCredentialAlteration_t *alteration);\nvoid rd_kafka_UserScramCredentialAlteration_destroy_array(rd_kafka_UserScramCredentialAlteration_t **alterations, size_t alteration_cnt);\ntypedef struct rd_kafka_AlterUserScramCredentials_result_response_s rd_kafka_AlterUserScramCredentials_result_response_t;\nconst char *rd_kafka_AlterUserScramCredentials_result_response_user(const rd_kafka_AlterUserScramCredentials_result_response_t *response);\nconst rd_kafka_error_t *rd_kafka_AlterUserScramCredentials_result_response_error(const rd_kafka_AlterUserScramCredentials_result_response_t *response);\nconst rd_kafka_AlterUserScramCredentials_result_response_t **rd_kafka_AlterUserScramCredentials_result_responses(const rd_kafka_AlterUserScramCredentials_result_t *result, size_t *cntp);\nvoid rd_kafka_AlterUserScramCredentials(rd_kafka_t *rk, rd_kafka_UserScramCredentialAlteration_t **alterations, size_t alteration_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\ntypedef struct rd_kafka_AclBinding_s rd_kafka_AclBinding_t;\ntypedef rd_kafka_AclBinding_t rd_kafka_AclBindingFilter_t;\nconst rd_kafka_error_t *rd_kafka_acl_result_error(const rd_kafka_acl_result_t *aclres);\nconst char *rd_kafka_AclOperation_name(rd_kafka_AclOperation_t acl_operation);\ntypedef enum rd_kafka_AclPermissionType_t {\n  RD_KAFKA_ACL_PERMISSION_TYPE_UNKNOWN = 0,\n  RD_KAFKA_ACL_PERMISSION_TYPE_ANY = 1,\n  RD_KAFKA_ACL_PERMISSION_TYPE_DENY = 2,\n  RD_KAFKA_ACL_PERMISSION_TYPE_ALLOW = 3,\n  RD_KAFKA_ACL_PERMISSION_TYPE__CNT,\n} rd_kafka_AclPermissionType_t;\nconst char *rd_kafka_AclPermissionType_name(rd_kafka_AclPermissionType_t acl_permission_type);\nrd_kafka_AclBinding_t *rd_kafka_AclBinding_new(rd_kafka_ResourceType_t restype, const char *name, rd_kafka_ResourcePatternType_t resource_pattern_type, const char *principal, const char *host, rd_kafka_AclOperation_t operation, rd_kafka_AclPermissionType_t permission_type, char *errstr, size_t errstr_size);\nrd_kafka_AclBindingFilter_t *rd_kafka_AclBindingFilter_new(rd_kafka_ResourceType_t restype, const char *name, rd_kafka_ResourcePatternType_t resource_pattern_type, const char *principal, const char *host, rd_kafka_AclOperation_t operation, rd_kafka_AclPermissionType_t permission_type, char *errstr, size_t errstr_size);\nrd_kafka_ResourceType_t rd_kafka_AclBinding_restype(const rd_kafka_AclBinding_t *acl);\nconst char *rd_kafka_AclBinding_name(const rd_kafka_AclBinding_t *acl);\nconst char *rd_kafka_AclBinding_principal(const rd_kafka_AclBinding_t *acl);\nconst char *rd_kafka_AclBinding_host(const rd_kafka_AclBinding_t *acl);\nrd_kafka_AclOperation_t rd_kafka_AclBinding_operation(const rd_kafka_AclBinding_t *acl);\nrd_kafka_AclPermissionType_t rd_kafka_AclBinding_permission_type(const rd_kafka_AclBinding_t *acl);\nrd_kafka_ResourcePatternType_t rd_kafka_AclBinding_resource_pattern_type(const rd_kafka_AclBinding_t *acl);\nconst rd_kafka_error_t *rd_kafka_AclBinding_error(const rd_kafka_AclBinding_t *acl);\nvoid rd_kafka_AclBinding_destroy(rd_kafka_AclBinding_t *acl_binding);\nvoid rd_kafka_AclBinding_destroy_array(rd_kafka_AclBinding_t **acl_bindings, size_t acl_bindings_cnt);\nconst rd_kafka_acl_result_t **rd_kafka_CreateAcls_result_acls(const rd_kafka_CreateAcls_result_t *result, size_t *cntp);\nvoid rd_kafka_CreateAcls(rd_kafka_t *rk, rd_kafka_AclBinding_t **new_acls, size_t new_acls_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_AclBinding_t **rd_kafka_DescribeAcls_result_acls(const rd_kafka_DescribeAcls_result_t *result, size_t *cntp);\nvoid rd_kafka_DescribeAcls(rd_kafka_t *rk, rd_kafka_AclBindingFilter_t *acl_filter, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\ntypedef struct rd_kafka_DeleteAcls_result_response_s rd_kafka_DeleteAcls_result_response_t;\nconst rd_kafka_DeleteAcls_result_response_t **rd_kafka_DeleteAcls_result_responses(const rd_kafka_DeleteAcls_result_t *result, size_t *cntp);\nconst rd_kafka_error_t *rd_kafka_DeleteAcls_result_response_error(const rd_kafka_DeleteAcls_result_response_t *result_response);\nconst rd_kafka_AclBinding_t **rd_kafka_DeleteAcls_result_response_matching_acls(const rd_kafka_DeleteAcls_result_response_t *result_response, size_t *matching_acls_cntp);\nvoid rd_kafka_DeleteAcls(rd_kafka_t *rk, rd_kafka_AclBindingFilter_t **del_acls, size_t del_acls_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nrd_kafka_resp_err_t rd_kafka_oauthbearer_set_token(rd_kafka_t *rk, const char *token_value, int64_t md_lifetime_ms, const char *md_principal_name, const char **extensions, size_t extension_size, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_oauthbearer_set_token_failure(rd_kafka_t *rk, const char *errstr);\nrd_kafka_error_t *rd_kafka_init_transactions(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_error_t *rd_kafka_begin_transaction(rd_kafka_t *rk);\nrd_kafka_error_t *rd_kafka_send_offsets_to_transaction(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, const rd_kafka_consumer_group_metadata_t *cgmetadata, int timeout_ms);\nrd_kafka_error_t *rd_kafka_commit_transaction(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_error_t *rd_kafka_abort_transaction(rd_kafka_t *rk, int timeout_ms);\ntypedef struct rd_kafka_mock_cluster_s rd_kafka_mock_cluster_t;\nrd_kafka_mock_cluster_t *rd_kafka_mock_cluster_new(rd_kafka_t *rk, int broker_cnt);\nvoid rd_kafka_mock_cluster_destroy(rd_kafka_mock_cluster_t *mcluster);\nrd_kafka_t *rd_kafka_mock_cluster_handle(const rd_kafka_mock_cluster_t *mcluster);\nrd_kafka_mock_cluster_t *rd_kafka_handle_mock_cluster(const rd_kafka_t *rk);\nconst char *rd_kafka_mock_cluster_bootstraps(const rd_kafka_mock_cluster_t *mcluster);\nvoid rd_kafka_mock_clear_request_errors(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey);\nvoid rd_kafka_mock_push_request_errors(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, size_t cnt, ...);\nvoid rd_kafka_mock_push_request_errors_array(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, size_t cnt, const rd_kafka_resp_err_t *errors);\nrd_kafka_resp_err_t rd_kafka_mock_broker_push_request_error_rtts(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int16_t ApiKey, size_t cnt, ...);\nrd_kafka_resp_err_t rd_kafka_mock_broker_error_stack_cnt(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int16_t ApiKey, size_t *cntp);\nvoid rd_kafka_mock_topic_set_error(rd_kafka_mock_cluster_t *mcluster, const char *topic, rd_kafka_resp_err_t err);\nrd_kafka_resp_err_t rd_kafka_mock_topic_create(rd_kafka_mock_cluster_t *mcluster, const char *topic, int partition_cnt, int replication_factor);\nrd_kafka_resp_err_t rd_kafka_mock_partition_set_leader(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id);\nrd_kafka_resp_err_t rd_kafka_mock_partition_set_follower(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id);\nrd_kafka_resp_err_t rd_kafka_mock_partition_set_follower_wmarks(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int64_t lo, int64_t hi);\nrd_kafka_resp_err_t rd_kafka_mock_partition_push_leader_response(rd_kafka_mock_cluster_t *mcluster, const char *topic, int partition, int32_t leader_id, int32_t leader_epoch);\nrd_kafka_resp_err_t rd_kafka_mock_broker_set_down(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id);\nrd_kafka_resp_err_t rd_kafka_mock_broker_set_up(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id);\nrd_kafka_resp_err_t rd_kafka_mock_broker_set_rtt(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int rtt_ms);\nrd_kafka_resp_err_t rd_kafka_mock_broker_set_rack(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, const char *rack);\nrd_kafka_resp_err_t rd_kafka_mock_coordinator_set(rd_kafka_mock_cluster_t *mcluster, const char *key_type, const char *key, int32_t broker_id);\nrd_kafka_resp_err_t rd_kafka_mock_set_apiversion(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, int16_t MinVersion, int16_t MaxVersion);\nvoid rd_kafka_mock_start_request_tracking(rd_kafka_mock_cluster_t *mcluster);\nvoid rd_kafka_mock_stop_request_tracking(rd_kafka_mock_cluster_t *mcluster);\ntypedef struct rd_kafka_mock_request_s rd_kafka_mock_request_t;\nvoid rd_kafka_mock_request_destroy(rd_kafka_mock_request_t *mreq);\nvoid rd_kafka_mock_request_destroy_array(rd_kafka_mock_request_t **mreqs, size_t mreq_cnt);\nint32_t rd_kafka_mock_request_id(rd_kafka_mock_request_t *mreq);\nint16_t rd_kafka_mock_request_api_key(rd_kafka_mock_request_t *mreq);\nint64_t rd_kafka_mock_request_timestamp(rd_kafka_mock_request_t *mreq);\nrd_kafka_mock_request_t **rd_kafka_mock_get_requests(rd_kafka_mock_cluster_t *mcluster, size_t *cntp);\nvoid rd_kafka_mock_clear_requests(rd_kafka_mock_cluster_t *mcluster);\nrd_kafka_resp_err_t rd_kafka_mock_telemetry_set_requested_metrics(rd_kafka_mock_cluster_t *mcluster, char **metrics, size_t metrics_cnt);\nrd_kafka_resp_err_t rd_kafka_mock_telemetry_set_push_interval(rd_kafka_mock_cluster_t *mcluster, int64_t push_interval_ms);\n'\n</code></pre> rdkafka.h, rdkafka_mock.h</p>"},{"location":"api/constants/#rd_kafka_version_32","title":"RD_KAFKA_VERSION","text":"<pre><code>public RD_KAFKA_VERSION = 33883135\n</code></pre> <p>librdkafka version </p> <p>Interpreted as hex <code>MM.mm.rr.xx</code>:</p> <ul> <li>MM = Major</li> <li>mm = minor</li> <li>rr = revision</li> <li>xx = pre-release id (0xff is the final release)</li> </ul> <p>E.g.: <code>0x000801ff</code> = 0.8.1</p> RemarksThis value should only be used during compile time, for runtime checks of version use rd_kafka_version()  <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_unsupported_compression_type_32","title":"RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE","text":"<pre><code>public RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76\n</code></pre> <p>Unsupported compression type </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_end_all_32","title":"RD_KAFKA_RESP_ERR_END_ALL","text":"<p><pre><code>public RD_KAFKA_RESP_ERR_END_ALL = 119\n</code></pre> enum rd_kafka_resp_err_t</p>"},{"location":"api/constants/#rd_kafka_admin_op__cnt_32","title":"RD_KAFKA_ADMIN_OP__CNT","text":"<pre><code>public RD_KAFKA_ADMIN_OP__CNT = 22\n</code></pre> <p>Number of ops defined </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe </li> </ul>"},{"location":"api/constants/#rd_kafka_resource__cnt_32","title":"RD_KAFKA_RESOURCE__CNT","text":"<pre><code>public RD_KAFKA_RESOURCE__CNT = 5\n</code></pre> <p>Number of resource types defined </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#acca83a66d7783ff7683ed2691cc907c9 </li> </ul>"},{"location":"api/constants/#rd_kafka_cdef_32","title":"RD_KAFKA_CDEF","text":"<p><pre><code>public RD_KAFKA_CDEF = 'typedef long int ssize_t;\ntypedef struct _IO_FILE FILE;\ntypedef long int mode_t;\ntypedef signed int int16_t;\ntypedef unsigned int uint16_t;\ntypedef signed int int32_t;\ntypedef signed long int int64_t;\nint rd_kafka_version(void);\nconst char *rd_kafka_version_str(void);\ntypedef enum rd_kafka_type_t {\n  RD_KAFKA_PRODUCER,\n  RD_KAFKA_CONSUMER,\n} rd_kafka_type_t;\ntypedef enum rd_kafka_timestamp_type_t {\n  RD_KAFKA_TIMESTAMP_NOT_AVAILABLE,\n  RD_KAFKA_TIMESTAMP_CREATE_TIME,\n  RD_KAFKA_TIMESTAMP_LOG_APPEND_TIME,\n} rd_kafka_timestamp_type_t;\nconst char *rd_kafka_get_debug_contexts(void);\ntypedef struct rd_kafka_s rd_kafka_t;\ntypedef struct rd_kafka_topic_s rd_kafka_topic_t;\ntypedef struct rd_kafka_conf_s rd_kafka_conf_t;\ntypedef struct rd_kafka_topic_conf_s rd_kafka_topic_conf_t;\ntypedef struct rd_kafka_queue_s rd_kafka_queue_t;\ntypedef struct rd_kafka_op_s rd_kafka_event_t;\ntypedef struct rd_kafka_topic_result_s rd_kafka_topic_result_t;\ntypedef struct rd_kafka_consumer_group_metadata_s rd_kafka_consumer_group_metadata_t;\ntypedef struct rd_kafka_error_s {\n  unsigned int code;\n  char *errstr;\n  unsigned char fatal;\n  unsigned char retriable;\n  unsigned char txn_requires_abort;\n} rd_kafka_error_t;\ntypedef struct rd_kafka_headers_s rd_kafka_headers_t;\ntypedef struct rd_kafka_group_result_s rd_kafka_group_result_t;\ntypedef struct rd_kafka_acl_result_s rd_kafka_acl_result_t;\ntypedef struct rd_kafka_Uuid_s rd_kafka_Uuid_t;\ntypedef enum {\n  RD_KAFKA_RESP_ERR__BEGIN = (- 200),\n  RD_KAFKA_RESP_ERR__BAD_MSG = (- 199),\n  RD_KAFKA_RESP_ERR__BAD_COMPRESSION = (- 198),\n  RD_KAFKA_RESP_ERR__DESTROY = (- 197),\n  RD_KAFKA_RESP_ERR__FAIL = (- 196),\n  RD_KAFKA_RESP_ERR__TRANSPORT = (- 195),\n  RD_KAFKA_RESP_ERR__CRIT_SYS_RESOURCE = (- 194),\n  RD_KAFKA_RESP_ERR__RESOLVE = (- 193),\n  RD_KAFKA_RESP_ERR__MSG_TIMED_OUT = (- 192),\n  RD_KAFKA_RESP_ERR__PARTITION_EOF = (- 191),\n  RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION = (- 190),\n  RD_KAFKA_RESP_ERR__FS = (- 189),\n  RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC = (- 188),\n  RD_KAFKA_RESP_ERR__ALL_BROKERS_DOWN = (- 187),\n  RD_KAFKA_RESP_ERR__INVALID_ARG = (- 186),\n  RD_KAFKA_RESP_ERR__TIMED_OUT = (- 185),\n  RD_KAFKA_RESP_ERR__QUEUE_FULL = (- 184),\n  RD_KAFKA_RESP_ERR__ISR_INSUFF = (- 183),\n  RD_KAFKA_RESP_ERR__NODE_UPDATE = (- 182),\n  RD_KAFKA_RESP_ERR__SSL = (- 181),\n  RD_KAFKA_RESP_ERR__WAIT_COORD = (- 180),\n  RD_KAFKA_RESP_ERR__UNKNOWN_GROUP = (- 179),\n  RD_KAFKA_RESP_ERR__IN_PROGRESS = (- 178),\n  RD_KAFKA_RESP_ERR__PREV_IN_PROGRESS = (- 177),\n  RD_KAFKA_RESP_ERR__EXISTING_SUBSCRIPTION = (- 176),\n  RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS = (- 175),\n  RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS = (- 174),\n  RD_KAFKA_RESP_ERR__CONFLICT = (- 173),\n  RD_KAFKA_RESP_ERR__STATE = (- 172),\n  RD_KAFKA_RESP_ERR__UNKNOWN_PROTOCOL = (- 171),\n  RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED = (- 170),\n  RD_KAFKA_RESP_ERR__AUTHENTICATION = (- 169),\n  RD_KAFKA_RESP_ERR__NO_OFFSET = (- 168),\n  RD_KAFKA_RESP_ERR__OUTDATED = (- 167),\n  RD_KAFKA_RESP_ERR__TIMED_OUT_QUEUE = (- 166),\n  RD_KAFKA_RESP_ERR__UNSUPPORTED_FEATURE = (- 165),\n  RD_KAFKA_RESP_ERR__WAIT_CACHE = (- 164),\n  RD_KAFKA_RESP_ERR__INTR = (- 163),\n  RD_KAFKA_RESP_ERR__KEY_SERIALIZATION = (- 162),\n  RD_KAFKA_RESP_ERR__VALUE_SERIALIZATION = (- 161),\n  RD_KAFKA_RESP_ERR__KEY_DESERIALIZATION = (- 160),\n  RD_KAFKA_RESP_ERR__VALUE_DESERIALIZATION = (- 159),\n  RD_KAFKA_RESP_ERR__PARTIAL = (- 158),\n  RD_KAFKA_RESP_ERR__READ_ONLY = (- 157),\n  RD_KAFKA_RESP_ERR__NOENT = (- 156),\n  RD_KAFKA_RESP_ERR__UNDERFLOW = (- 155),\n  RD_KAFKA_RESP_ERR__INVALID_TYPE = (- 154),\n  RD_KAFKA_RESP_ERR__RETRY = (- 153),\n  RD_KAFKA_RESP_ERR__PURGE_QUEUE = (- 152),\n  RD_KAFKA_RESP_ERR__PURGE_INFLIGHT = (- 151),\n  RD_KAFKA_RESP_ERR__FATAL = (- 150),\n  RD_KAFKA_RESP_ERR__INCONSISTENT = (- 149),\n  RD_KAFKA_RESP_ERR__GAPLESS_GUARANTEE = (- 148),\n  RD_KAFKA_RESP_ERR__MAX_POLL_EXCEEDED = (- 147),\n  RD_KAFKA_RESP_ERR__UNKNOWN_BROKER = (- 146),\n  RD_KAFKA_RESP_ERR__NOT_CONFIGURED = (- 145),\n  RD_KAFKA_RESP_ERR__FENCED = (- 144),\n  RD_KAFKA_RESP_ERR__APPLICATION = (- 143),\n  RD_KAFKA_RESP_ERR__ASSIGNMENT_LOST = (- 142),\n  RD_KAFKA_RESP_ERR__NOOP = (- 141),\n  RD_KAFKA_RESP_ERR__AUTO_OFFSET_RESET = (- 140),\n  RD_KAFKA_RESP_ERR__LOG_TRUNCATION = (- 139),\n  RD_KAFKA_RESP_ERR__INVALID_DIFFERENT_RECORD = (- 138),\n  RD_KAFKA_RESP_ERR__END = (- 100),\n  RD_KAFKA_RESP_ERR_UNKNOWN = (- 1),\n  RD_KAFKA_RESP_ERR_NO_ERROR = 0,\n  RD_KAFKA_RESP_ERR_OFFSET_OUT_OF_RANGE = 1,\n  RD_KAFKA_RESP_ERR_INVALID_MSG = 2,\n  RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART = 3,\n  RD_KAFKA_RESP_ERR_INVALID_MSG_SIZE = 4,\n  RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE = 5,\n  RD_KAFKA_RESP_ERR_NOT_LEADER_FOR_PARTITION = 6,\n  RD_KAFKA_RESP_ERR_REQUEST_TIMED_OUT = 7,\n  RD_KAFKA_RESP_ERR_BROKER_NOT_AVAILABLE = 8,\n  RD_KAFKA_RESP_ERR_REPLICA_NOT_AVAILABLE = 9,\n  RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE = 10,\n  RD_KAFKA_RESP_ERR_STALE_CTRL_EPOCH = 11,\n  RD_KAFKA_RESP_ERR_OFFSET_METADATA_TOO_LARGE = 12,\n  RD_KAFKA_RESP_ERR_NETWORK_EXCEPTION = 13,\n  RD_KAFKA_RESP_ERR_COORDINATOR_LOAD_IN_PROGRESS = 14,\n  RD_KAFKA_RESP_ERR_COORDINATOR_NOT_AVAILABLE = 15,\n  RD_KAFKA_RESP_ERR_NOT_COORDINATOR = 16,\n  RD_KAFKA_RESP_ERR_TOPIC_EXCEPTION = 17,\n  RD_KAFKA_RESP_ERR_RECORD_LIST_TOO_LARGE = 18,\n  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS = 19,\n  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS_AFTER_APPEND = 20,\n  RD_KAFKA_RESP_ERR_INVALID_REQUIRED_ACKS = 21,\n  RD_KAFKA_RESP_ERR_ILLEGAL_GENERATION = 22,\n  RD_KAFKA_RESP_ERR_INCONSISTENT_GROUP_PROTOCOL = 23,\n  RD_KAFKA_RESP_ERR_INVALID_GROUP_ID = 24,\n  RD_KAFKA_RESP_ERR_UNKNOWN_MEMBER_ID = 25,\n  RD_KAFKA_RESP_ERR_INVALID_SESSION_TIMEOUT = 26,\n  RD_KAFKA_RESP_ERR_REBALANCE_IN_PROGRESS = 27,\n  RD_KAFKA_RESP_ERR_INVALID_COMMIT_OFFSET_SIZE = 28,\n  RD_KAFKA_RESP_ERR_TOPIC_AUTHORIZATION_FAILED = 29,\n  RD_KAFKA_RESP_ERR_GROUP_AUTHORIZATION_FAILED = 30,\n  RD_KAFKA_RESP_ERR_CLUSTER_AUTHORIZATION_FAILED = 31,\n  RD_KAFKA_RESP_ERR_INVALID_TIMESTAMP = 32,\n  RD_KAFKA_RESP_ERR_UNSUPPORTED_SASL_MECHANISM = 33,\n  RD_KAFKA_RESP_ERR_ILLEGAL_SASL_STATE = 34,\n  RD_KAFKA_RESP_ERR_UNSUPPORTED_VERSION = 35,\n  RD_KAFKA_RESP_ERR_TOPIC_ALREADY_EXISTS = 36,\n  RD_KAFKA_RESP_ERR_INVALID_PARTITIONS = 37,\n  RD_KAFKA_RESP_ERR_INVALID_REPLICATION_FACTOR = 38,\n  RD_KAFKA_RESP_ERR_INVALID_REPLICA_ASSIGNMENT = 39,\n  RD_KAFKA_RESP_ERR_INVALID_CONFIG = 40,\n  RD_KAFKA_RESP_ERR_NOT_CONTROLLER = 41,\n  RD_KAFKA_RESP_ERR_INVALID_REQUEST = 42,\n  RD_KAFKA_RESP_ERR_UNSUPPORTED_FOR_MESSAGE_FORMAT = 43,\n  RD_KAFKA_RESP_ERR_POLICY_VIOLATION = 44,\n  RD_KAFKA_RESP_ERR_OUT_OF_ORDER_SEQUENCE_NUMBER = 45,\n  RD_KAFKA_RESP_ERR_DUPLICATE_SEQUENCE_NUMBER = 46,\n  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_EPOCH = 47,\n  RD_KAFKA_RESP_ERR_INVALID_TXN_STATE = 48,\n  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_ID_MAPPING = 49,\n  RD_KAFKA_RESP_ERR_INVALID_TRANSACTION_TIMEOUT = 50,\n  RD_KAFKA_RESP_ERR_CONCURRENT_TRANSACTIONS = 51,\n  RD_KAFKA_RESP_ERR_TRANSACTION_COORDINATOR_FENCED = 52,\n  RD_KAFKA_RESP_ERR_TRANSACTIONAL_ID_AUTHORIZATION_FAILED = 53,\n  RD_KAFKA_RESP_ERR_SECURITY_DISABLED = 54,\n  RD_KAFKA_RESP_ERR_OPERATION_NOT_ATTEMPTED = 55,\n  RD_KAFKA_RESP_ERR_KAFKA_STORAGE_ERROR = 56,\n  RD_KAFKA_RESP_ERR_LOG_DIR_NOT_FOUND = 57,\n  RD_KAFKA_RESP_ERR_SASL_AUTHENTICATION_FAILED = 58,\n  RD_KAFKA_RESP_ERR_UNKNOWN_PRODUCER_ID = 59,\n  RD_KAFKA_RESP_ERR_REASSIGNMENT_IN_PROGRESS = 60,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTH_DISABLED = 61,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_NOT_FOUND = 62,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_OWNER_MISMATCH = 63,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_REQUEST_NOT_ALLOWED = 64,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTHORIZATION_FAILED = 65,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_EXPIRED = 66,\n  RD_KAFKA_RESP_ERR_INVALID_PRINCIPAL_TYPE = 67,\n  RD_KAFKA_RESP_ERR_NON_EMPTY_GROUP = 68,\n  RD_KAFKA_RESP_ERR_GROUP_ID_NOT_FOUND = 69,\n  RD_KAFKA_RESP_ERR_FETCH_SESSION_ID_NOT_FOUND = 70,\n  RD_KAFKA_RESP_ERR_INVALID_FETCH_SESSION_EPOCH = 71,\n  RD_KAFKA_RESP_ERR_LISTENER_NOT_FOUND = 72,\n  RD_KAFKA_RESP_ERR_TOPIC_DELETION_DISABLED = 73,\n  RD_KAFKA_RESP_ERR_FENCED_LEADER_EPOCH = 74,\n  RD_KAFKA_RESP_ERR_UNKNOWN_LEADER_EPOCH = 75,\n  RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76,\n  RD_KAFKA_RESP_ERR_STALE_BROKER_EPOCH = 77,\n  RD_KAFKA_RESP_ERR_OFFSET_NOT_AVAILABLE = 78,\n  RD_KAFKA_RESP_ERR_MEMBER_ID_REQUIRED = 79,\n  RD_KAFKA_RESP_ERR_PREFERRED_LEADER_NOT_AVAILABLE = 80,\n  RD_KAFKA_RESP_ERR_GROUP_MAX_SIZE_REACHED = 81,\n  RD_KAFKA_RESP_ERR_FENCED_INSTANCE_ID = 82,\n  RD_KAFKA_RESP_ERR_ELIGIBLE_LEADERS_NOT_AVAILABLE = 83,\n  RD_KAFKA_RESP_ERR_ELECTION_NOT_NEEDED = 84,\n  RD_KAFKA_RESP_ERR_NO_REASSIGNMENT_IN_PROGRESS = 85,\n  RD_KAFKA_RESP_ERR_GROUP_SUBSCRIBED_TO_TOPIC = 86,\n  RD_KAFKA_RESP_ERR_INVALID_RECORD = 87,\n  RD_KAFKA_RESP_ERR_UNSTABLE_OFFSET_COMMIT = 88,\n  RD_KAFKA_RESP_ERR_THROTTLING_QUOTA_EXCEEDED = 89,\n  RD_KAFKA_RESP_ERR_PRODUCER_FENCED = 90,\n  RD_KAFKA_RESP_ERR_RESOURCE_NOT_FOUND = 91,\n  RD_KAFKA_RESP_ERR_DUPLICATE_RESOURCE = 92,\n  RD_KAFKA_RESP_ERR_UNACCEPTABLE_CREDENTIAL = 93,\n  RD_KAFKA_RESP_ERR_INCONSISTENT_VOTER_SET = 94,\n  RD_KAFKA_RESP_ERR_INVALID_UPDATE_VERSION = 95,\n  RD_KAFKA_RESP_ERR_FEATURE_UPDATE_FAILED = 96,\n  RD_KAFKA_RESP_ERR_PRINCIPAL_DESERIALIZATION_FAILURE = 97,\n  RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_ID = 100,\n  RD_KAFKA_RESP_ERR_FENCED_MEMBER_EPOCH = 110,\n  RD_KAFKA_RESP_ERR_UNRELEASED_INSTANCE_ID = 111,\n  RD_KAFKA_RESP_ERR_UNSUPPORTED_ASSIGNOR = 112,\n  RD_KAFKA_RESP_ERR_STALE_MEMBER_EPOCH = 113,\n  RD_KAFKA_RESP_ERR_UNKNOWN_SUBSCRIPTION_ID = 117,\n  RD_KAFKA_RESP_ERR_TELEMETRY_TOO_LARGE = 118,\n  RD_KAFKA_RESP_ERR_END_ALL,\n} rd_kafka_resp_err_t;\nstruct rd_kafka_err_desc {\n  rd_kafka_resp_err_t code;\n  char *name;\n  char *desc;\n};\nvoid rd_kafka_get_err_descs(const struct rd_kafka_err_desc **errdescs, size_t *cntp);\nconst char *rd_kafka_err2str(rd_kafka_resp_err_t err);\nconst char *rd_kafka_err2name(rd_kafka_resp_err_t err);\nrd_kafka_resp_err_t rd_kafka_last_error(void);\nrd_kafka_resp_err_t rd_kafka_errno2err(int errnox);\nint rd_kafka_errno(void);\nrd_kafka_resp_err_t rd_kafka_fatal_error(rd_kafka_t *rk, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_test_fatal_error(rd_kafka_t *rk, rd_kafka_resp_err_t err, const char *reason);\nrd_kafka_resp_err_t rd_kafka_error_code(const rd_kafka_error_t *error);\nconst char *rd_kafka_error_name(const rd_kafka_error_t *error);\nconst char *rd_kafka_error_string(const rd_kafka_error_t *error);\nint rd_kafka_error_is_fatal(const rd_kafka_error_t *error);\nint rd_kafka_error_is_retriable(const rd_kafka_error_t *error);\nint rd_kafka_error_txn_requires_abort(const rd_kafka_error_t *error);\nvoid rd_kafka_error_destroy(rd_kafka_error_t *error);\nrd_kafka_error_t *rd_kafka_error_new(rd_kafka_resp_err_t code, const char *fmt, ...);\ntypedef struct rd_kafka_topic_partition_s {\n  char *topic;\n  int32_t partition;\n  int64_t offset;\n  void *metadata;\n  size_t metadata_size;\n  void *opaque;\n  rd_kafka_resp_err_t err;\n  void *_private;\n} rd_kafka_topic_partition_t;\nvoid rd_kafka_topic_partition_destroy(rd_kafka_topic_partition_t *rktpar);\nvoid rd_kafka_topic_partition_set_leader_epoch(rd_kafka_topic_partition_t *rktpar, int32_t leader_epoch);\nint32_t rd_kafka_topic_partition_get_leader_epoch(const rd_kafka_topic_partition_t *rktpar);\ntypedef struct rd_kafka_topic_partition_list_s {\n  int cnt;\n  int size;\n  rd_kafka_topic_partition_t *elems;\n} rd_kafka_topic_partition_list_t;\nrd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_new(int size);\nvoid rd_kafka_topic_partition_list_destroy(rd_kafka_topic_partition_list_t *rkparlist);\nrd_kafka_topic_partition_t *rd_kafka_topic_partition_list_add(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);\nvoid rd_kafka_topic_partition_list_add_range(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t start, int32_t stop);\nint rd_kafka_topic_partition_list_del(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);\nint rd_kafka_topic_partition_list_del_by_idx(rd_kafka_topic_partition_list_t *rktparlist, int idx);\nrd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_copy(const rd_kafka_topic_partition_list_t *src);\nrd_kafka_resp_err_t rd_kafka_topic_partition_list_set_offset(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition, int64_t offset);\nrd_kafka_topic_partition_t *rd_kafka_topic_partition_list_find(const rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);\nvoid rd_kafka_topic_partition_list_sort(rd_kafka_topic_partition_list_t *rktparlist, int (*cmp)(const void *a, const void *b, void *cmp_opaque), void *cmp_opaque);\ntypedef enum rd_kafka_vtype_t {\n  RD_KAFKA_VTYPE_END,\n  RD_KAFKA_VTYPE_TOPIC,\n  RD_KAFKA_VTYPE_RKT,\n  RD_KAFKA_VTYPE_PARTITION,\n  RD_KAFKA_VTYPE_VALUE,\n  RD_KAFKA_VTYPE_KEY,\n  RD_KAFKA_VTYPE_OPAQUE,\n  RD_KAFKA_VTYPE_MSGFLAGS,\n  RD_KAFKA_VTYPE_TIMESTAMP,\n  RD_KAFKA_VTYPE_HEADER,\n  RD_KAFKA_VTYPE_HEADERS,\n} rd_kafka_vtype_t;\ntypedef struct rd_kafka_vu_s {\n  rd_kafka_vtype_t vtype;\n  union {\n    char *cstr;\n    rd_kafka_topic_t *rkt;\n    int i;\n    int32_t i32;\n    int64_t i64;\n    struct {\n      void *ptr;\n      size_t size;\n    } mem;\n    struct {\n      char *name;\n      void *val;\n      ssize_t size;\n    } header;\n    rd_kafka_headers_t *headers;\n    void *ptr;\n    char _pad[64];\n  } u;\n} rd_kafka_vu_t;\nrd_kafka_headers_t *rd_kafka_headers_new(size_t initial_count);\nvoid rd_kafka_headers_destroy(rd_kafka_headers_t *hdrs);\nrd_kafka_headers_t *rd_kafka_headers_copy(const rd_kafka_headers_t *src);\nrd_kafka_resp_err_t rd_kafka_header_add(rd_kafka_headers_t *hdrs, const char *name, ssize_t name_size, const void *value, ssize_t value_size);\nrd_kafka_resp_err_t rd_kafka_header_remove(rd_kafka_headers_t *hdrs, const char *name);\nrd_kafka_resp_err_t rd_kafka_header_get_last(const rd_kafka_headers_t *hdrs, const char *name, const void **valuep, size_t *sizep);\nrd_kafka_resp_err_t rd_kafka_header_get(const rd_kafka_headers_t *hdrs, size_t idx, const char *name, const void **valuep, size_t *sizep);\nrd_kafka_resp_err_t rd_kafka_header_get_all(const rd_kafka_headers_t *hdrs, size_t idx, const char **namep, const void **valuep, size_t *sizep);\ntypedef struct rd_kafka_message_s {\n  rd_kafka_resp_err_t err;\n  rd_kafka_topic_t *rkt;\n  int32_t partition;\n  void *payload;\n  size_t len;\n  void *key;\n  size_t key_len;\n  int64_t offset;\n  void *_private;\n} rd_kafka_message_t;\nvoid rd_kafka_message_destroy(rd_kafka_message_t *rkmessage);\nconst char *rd_kafka_message_errstr(const rd_kafka_message_t *rkmessage);\nconst char *rd_kafka_message_produce_errstr(const rd_kafka_message_t *rkmessage);\nint64_t rd_kafka_message_timestamp(const rd_kafka_message_t *rkmessage, rd_kafka_timestamp_type_t *tstype);\nint64_t rd_kafka_message_latency(const rd_kafka_message_t *rkmessage);\nint32_t rd_kafka_message_broker_id(const rd_kafka_message_t *rkmessage);\nrd_kafka_resp_err_t rd_kafka_message_headers(const rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);\nrd_kafka_resp_err_t rd_kafka_message_detach_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);\nvoid rd_kafka_message_set_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t *hdrs);\nsize_t rd_kafka_header_cnt(const rd_kafka_headers_t *hdrs);\ntypedef enum {\n  RD_KAFKA_MSG_STATUS_NOT_PERSISTED = 0,\n  RD_KAFKA_MSG_STATUS_POSSIBLY_PERSISTED = 1,\n  RD_KAFKA_MSG_STATUS_PERSISTED = 2,\n} rd_kafka_msg_status_t;\nrd_kafka_msg_status_t rd_kafka_message_status(const rd_kafka_message_t *rkmessage);\nint32_t rd_kafka_message_leader_epoch(const rd_kafka_message_t *rkmessage);\nconst char *rd_kafka_Uuid_base64str(const rd_kafka_Uuid_t *uuid);\nint64_t rd_kafka_Uuid_least_significant_bits(const rd_kafka_Uuid_t *uuid);\nint64_t rd_kafka_Uuid_most_significant_bits(const rd_kafka_Uuid_t *uuid);\nrd_kafka_Uuid_t *rd_kafka_Uuid_new(int64_t most_significant_bits, int64_t least_significant_bits);\nrd_kafka_Uuid_t *rd_kafka_Uuid_copy(const rd_kafka_Uuid_t *uuid);\nvoid rd_kafka_Uuid_destroy(rd_kafka_Uuid_t *uuid);\ntypedef enum {\n  RD_KAFKA_CONF_UNKNOWN = (- 2),\n  RD_KAFKA_CONF_INVALID = (- 1),\n  RD_KAFKA_CONF_OK = 0,\n} rd_kafka_conf_res_t;\nrd_kafka_conf_t *rd_kafka_conf_new(void);\nvoid rd_kafka_conf_destroy(rd_kafka_conf_t *conf);\nrd_kafka_conf_t *rd_kafka_conf_dup(const rd_kafka_conf_t *conf);\nrd_kafka_conf_t *rd_kafka_conf_dup_filter(const rd_kafka_conf_t *conf, size_t filter_cnt, const char **filter);\nconst rd_kafka_conf_t *rd_kafka_conf(rd_kafka_t *rk);\nrd_kafka_conf_res_t rd_kafka_conf_set(rd_kafka_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);\nvoid rd_kafka_conf_set_events(rd_kafka_conf_t *conf, int events);\nvoid rd_kafka_conf_set_background_event_cb(rd_kafka_conf_t *conf, void (*event_cb)(rd_kafka_t *rk, rd_kafka_event_t *rkev, void *opaque));\nvoid rd_kafka_conf_set_dr_cb(rd_kafka_conf_t *conf, void (*dr_cb)(rd_kafka_t *rk, void *payload, size_t len, rd_kafka_resp_err_t err, void *opaque, void *msg_opaque));\nvoid rd_kafka_conf_set_dr_msg_cb(rd_kafka_conf_t *conf, void (*dr_msg_cb)(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, void *opaque));\nvoid rd_kafka_conf_set_consume_cb(rd_kafka_conf_t *conf, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *opaque));\nvoid rd_kafka_conf_set_rebalance_cb(rd_kafka_conf_t *conf, void (*rebalance_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *partitions, void *opaque));\nvoid rd_kafka_conf_set_offset_commit_cb(rd_kafka_conf_t *conf, void (*offset_commit_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *opaque));\nvoid rd_kafka_conf_set_error_cb(rd_kafka_conf_t *conf, void (*error_cb)(rd_kafka_t *rk, int err, const char *reason, void *opaque));\nvoid rd_kafka_conf_set_throttle_cb(rd_kafka_conf_t *conf, void (*throttle_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int throttle_time_ms, void *opaque));\nvoid rd_kafka_conf_set_log_cb(rd_kafka_conf_t *conf, void (*log_cb)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));\nvoid rd_kafka_conf_set_stats_cb(rd_kafka_conf_t *conf, int (*stats_cb)(rd_kafka_t *rk, char *json, size_t json_len, void *opaque));\nvoid rd_kafka_conf_set_oauthbearer_token_refresh_cb(rd_kafka_conf_t *conf, void (*oauthbearer_token_refresh_cb)(rd_kafka_t *rk, const char *oauthbearer_config, void *opaque));\nvoid rd_kafka_conf_enable_sasl_queue(rd_kafka_conf_t *conf, int enable);\nvoid rd_kafka_conf_set_socket_cb(rd_kafka_conf_t *conf, int (*socket_cb)(int domain, int type, int protocol, void *opaque));\nvoid rd_kafka_conf_set_connect_cb(rd_kafka_conf_t *conf, int (*connect_cb)(int sockfd, const struct sockaddr *addr, int addrlen, const char *id, void *opaque));\nvoid rd_kafka_conf_set_closesocket_cb(rd_kafka_conf_t *conf, int (*closesocket_cb)(int sockfd, void *opaque));\nstruct addrinfo;\nvoid rd_kafka_conf_set_resolve_cb(rd_kafka_conf_t *conf, int (*resolve_cb)(const char *node, const char *service, const struct addrinfo *hints, struct addrinfo **res, void *opaque));\nrd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert_verify_cb(rd_kafka_conf_t *conf, int (*ssl_cert_verify_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int *x509_error, int depth, const char *buf, size_t size, char *errstr, size_t errstr_size, void *opaque));\ntypedef enum rd_kafka_cert_type_t {\n  RD_KAFKA_CERT_PUBLIC_KEY,\n  RD_KAFKA_CERT_PRIVATE_KEY,\n  RD_KAFKA_CERT_CA,\n  RD_KAFKA_CERT__CNT,\n} rd_kafka_cert_type_t;\ntypedef enum rd_kafka_cert_enc_t {\n  RD_KAFKA_CERT_ENC_PKCS12,\n  RD_KAFKA_CERT_ENC_DER,\n  RD_KAFKA_CERT_ENC_PEM,\n  RD_KAFKA_CERT_ENC__CNT,\n} rd_kafka_cert_enc_t;\nrd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert(rd_kafka_conf_t *conf, rd_kafka_cert_type_t cert_type, rd_kafka_cert_enc_t cert_enc, const void *buffer, size_t size, char *errstr, size_t errstr_size);\nvoid rd_kafka_conf_set_engine_callback_data(rd_kafka_conf_t *conf, void *callback_data);\nvoid rd_kafka_conf_set_opaque(rd_kafka_conf_t *conf, void *opaque);\nvoid *rd_kafka_opaque(const rd_kafka_t *rk);\nvoid rd_kafka_conf_set_default_topic_conf(rd_kafka_conf_t *conf, rd_kafka_topic_conf_t *tconf);\nrd_kafka_topic_conf_t *rd_kafka_conf_get_default_topic_conf(rd_kafka_conf_t *conf);\nrd_kafka_conf_res_t rd_kafka_conf_get(const rd_kafka_conf_t *conf, const char *name, char *dest, size_t *dest_size);\nrd_kafka_conf_res_t rd_kafka_topic_conf_get(const rd_kafka_topic_conf_t *conf, const char *name, char *dest, size_t *dest_size);\nconst char **rd_kafka_conf_dump(rd_kafka_conf_t *conf, size_t *cntp);\nconst char **rd_kafka_topic_conf_dump(rd_kafka_topic_conf_t *conf, size_t *cntp);\nvoid rd_kafka_conf_dump_free(const char **arr, size_t cnt);\nvoid rd_kafka_conf_properties_show(FILE *fp);\nrd_kafka_topic_conf_t *rd_kafka_topic_conf_new(void);\nrd_kafka_topic_conf_t *rd_kafka_topic_conf_dup(const rd_kafka_topic_conf_t *conf);\nrd_kafka_topic_conf_t *rd_kafka_default_topic_conf_dup(rd_kafka_t *rk);\nvoid rd_kafka_topic_conf_destroy(rd_kafka_topic_conf_t *topic_conf);\nrd_kafka_conf_res_t rd_kafka_topic_conf_set(rd_kafka_topic_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);\nvoid rd_kafka_topic_conf_set_opaque(rd_kafka_topic_conf_t *conf, void *rkt_opaque);\nvoid rd_kafka_topic_conf_set_partitioner_cb(rd_kafka_topic_conf_t *topic_conf, int32_t (*partitioner)(const rd_kafka_topic_t *rkt, const void *keydata, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque));\nvoid rd_kafka_topic_conf_set_msg_order_cmp(rd_kafka_topic_conf_t *topic_conf, int (*msg_order_cmp)(const rd_kafka_message_t *a, const rd_kafka_message_t *b));\nint rd_kafka_topic_partition_available(const rd_kafka_topic_t *rkt, int32_t partition);\nint32_t rd_kafka_msg_partitioner_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_consistent(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_consistent_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_murmur2(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_murmur2_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_fnv1a(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_fnv1a_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nrd_kafka_t *rd_kafka_new(rd_kafka_type_t type, rd_kafka_conf_t *conf, char *errstr, size_t errstr_size);\nvoid rd_kafka_destroy(rd_kafka_t *rk);\nvoid rd_kafka_destroy_flags(rd_kafka_t *rk, int flags);\nconst char *rd_kafka_name(const rd_kafka_t *rk);\nrd_kafka_type_t rd_kafka_type(const rd_kafka_t *rk);\nchar *rd_kafka_memberid(const rd_kafka_t *rk);\nchar *rd_kafka_clusterid(rd_kafka_t *rk, int timeout_ms);\nint32_t rd_kafka_controllerid(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_topic_t *rd_kafka_topic_new(rd_kafka_t *rk, const char *topic, rd_kafka_topic_conf_t *conf);\nvoid rd_kafka_topic_destroy(rd_kafka_topic_t *rkt);\nconst char *rd_kafka_topic_name(const rd_kafka_topic_t *rkt);\nvoid *rd_kafka_topic_opaque(const rd_kafka_topic_t *rkt);\nint rd_kafka_poll(rd_kafka_t *rk, int timeout_ms);\nvoid rd_kafka_yield(rd_kafka_t *rk);\nrd_kafka_resp_err_t rd_kafka_pause_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_resp_err_t rd_kafka_resume_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_resp_err_t rd_kafka_query_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high, int timeout_ms);\nrd_kafka_resp_err_t rd_kafka_get_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high);\nrd_kafka_resp_err_t rd_kafka_offsets_for_times(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets, int timeout_ms);\nvoid *rd_kafka_mem_calloc(rd_kafka_t *rk, size_t num, size_t size);\nvoid *rd_kafka_mem_malloc(rd_kafka_t *rk, size_t size);\nvoid rd_kafka_mem_free(rd_kafka_t *rk, void *ptr);\nrd_kafka_queue_t *rd_kafka_queue_new(rd_kafka_t *rk);\nvoid rd_kafka_queue_destroy(rd_kafka_queue_t *rkqu);\nrd_kafka_queue_t *rd_kafka_queue_get_main(rd_kafka_t *rk);\nrd_kafka_queue_t *rd_kafka_queue_get_sasl(rd_kafka_t *rk);\nrd_kafka_error_t *rd_kafka_sasl_background_callbacks_enable(rd_kafka_t *rk);\nrd_kafka_error_t *rd_kafka_sasl_set_credentials(rd_kafka_t *rk, const char *username, const char *password);\nrd_kafka_queue_t *rd_kafka_queue_get_consumer(rd_kafka_t *rk);\nrd_kafka_queue_t *rd_kafka_queue_get_partition(rd_kafka_t *rk, const char *topic, int32_t partition);\nrd_kafka_queue_t *rd_kafka_queue_get_background(rd_kafka_t *rk);\nvoid rd_kafka_queue_forward(rd_kafka_queue_t *src, rd_kafka_queue_t *dst);\nrd_kafka_resp_err_t rd_kafka_set_log_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu);\nsize_t rd_kafka_queue_length(rd_kafka_queue_t *rkqu);\nvoid rd_kafka_queue_io_event_enable(rd_kafka_queue_t *rkqu, int fd, const void *payload, size_t size);\nvoid rd_kafka_queue_cb_event_enable(rd_kafka_queue_t *rkqu, void (*event_cb)(rd_kafka_t *rk, void *qev_opaque), void *qev_opaque);\nvoid rd_kafka_queue_yield(rd_kafka_queue_t *rkqu);\nint rd_kafka_consume_start(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);\nint rd_kafka_consume_start_queue(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, rd_kafka_queue_t *rkqu);\nint rd_kafka_consume_stop(rd_kafka_topic_t *rkt, int32_t partition);\nrd_kafka_resp_err_t rd_kafka_seek(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, int timeout_ms);\nrd_kafka_error_t *rd_kafka_seek_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms);\nrd_kafka_message_t *rd_kafka_consume(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms);\nssize_t rd_kafka_consume_batch(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);\nint rd_kafka_consume_callback(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);\nrd_kafka_message_t *rd_kafka_consume_queue(rd_kafka_queue_t *rkqu, int timeout_ms);\nssize_t rd_kafka_consume_batch_queue(rd_kafka_queue_t *rkqu, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);\nint rd_kafka_consume_callback_queue(rd_kafka_queue_t *rkqu, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);\nrd_kafka_resp_err_t rd_kafka_offset_store(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);\nrd_kafka_resp_err_t rd_kafka_offsets_store(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets);\nrd_kafka_error_t *rd_kafka_offset_store_message(rd_kafka_message_t *rkmessage);\nrd_kafka_resp_err_t rd_kafka_subscribe(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *topics);\nrd_kafka_resp_err_t rd_kafka_unsubscribe(rd_kafka_t *rk);\nrd_kafka_resp_err_t rd_kafka_subscription(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **topics);\nrd_kafka_message_t *rd_kafka_consumer_poll(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_resp_err_t rd_kafka_consumer_close(rd_kafka_t *rk);\nrd_kafka_error_t *rd_kafka_consumer_close_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu);\nint rd_kafka_consumer_closed(rd_kafka_t *rk);\nrd_kafka_error_t *rd_kafka_incremental_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_error_t *rd_kafka_incremental_unassign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);\nconst char *rd_kafka_rebalance_protocol(rd_kafka_t *rk);\nrd_kafka_resp_err_t rd_kafka_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_resp_err_t rd_kafka_assignment(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **partitions);\nint rd_kafka_assignment_lost(rd_kafka_t *rk);\nrd_kafka_resp_err_t rd_kafka_commit(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, int async);\nrd_kafka_resp_err_t rd_kafka_commit_message(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, int async);\nrd_kafka_resp_err_t rd_kafka_commit_queue(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_queue_t *rkqu, void (*cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *commit_opaque), void *commit_opaque);\nrd_kafka_resp_err_t rd_kafka_committed(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms);\nrd_kafka_resp_err_t rd_kafka_position(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata(rd_kafka_t *rk);\nrd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata_new(const char *group_id);\nrd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata_new_with_genid(const char *group_id, int32_t generation_id, const char *member_id, const char *group_instance_id);\nconst char *rd_kafka_consumer_group_metadata_member_id(const rd_kafka_consumer_group_metadata_t *group_metadata);\nvoid rd_kafka_consumer_group_metadata_destroy(rd_kafka_consumer_group_metadata_t *);\nrd_kafka_error_t *rd_kafka_consumer_group_metadata_write(const rd_kafka_consumer_group_metadata_t *cgmd, void **bufferp, size_t *sizep);\nrd_kafka_error_t *rd_kafka_consumer_group_metadata_read(rd_kafka_consumer_group_metadata_t **cgmdp, const void *buffer, size_t size);\nint rd_kafka_produce(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, void *payload, size_t len, const void *key, size_t keylen, void *msg_opaque);\nrd_kafka_resp_err_t rd_kafka_producev(rd_kafka_t *rk, ...);\nrd_kafka_error_t *rd_kafka_produceva(rd_kafka_t *rk, const rd_kafka_vu_t *vus, size_t cnt);\nint rd_kafka_produce_batch(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, rd_kafka_message_t *rkmessages, int message_cnt);\nrd_kafka_resp_err_t rd_kafka_flush(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_resp_err_t rd_kafka_purge(rd_kafka_t *rk, int purge_flags);\ntypedef struct rd_kafka_metadata_broker {\n  int32_t id;\n  char *host;\n  int port;\n} rd_kafka_metadata_broker_t;\ntypedef struct rd_kafka_metadata_partition {\n  int32_t id;\n  rd_kafka_resp_err_t err;\n  int32_t leader;\n  int replica_cnt;\n  int32_t *replicas;\n  int isr_cnt;\n  int32_t *isrs;\n} rd_kafka_metadata_partition_t;\ntypedef struct rd_kafka_metadata_topic {\n  char *topic;\n  int partition_cnt;\n  struct rd_kafka_metadata_partition *partitions;\n  rd_kafka_resp_err_t err;\n} rd_kafka_metadata_topic_t;\ntypedef struct rd_kafka_metadata {\n  int broker_cnt;\n  struct rd_kafka_metadata_broker *brokers;\n  int topic_cnt;\n  struct rd_kafka_metadata_topic *topics;\n  int32_t orig_broker_id;\n  char *orig_broker_name;\n} rd_kafka_metadata_t;\nrd_kafka_resp_err_t rd_kafka_metadata(rd_kafka_t *rk, int all_topics, rd_kafka_topic_t *only_rkt, const struct rd_kafka_metadata **metadatap, int timeout_ms);\nvoid rd_kafka_metadata_destroy(const struct rd_kafka_metadata *metadata);\ntypedef struct rd_kafka_Node_s rd_kafka_Node_t;\nint rd_kafka_Node_id(const rd_kafka_Node_t *node);\nconst char *rd_kafka_Node_host(const rd_kafka_Node_t *node);\nuint16_t rd_kafka_Node_port(const rd_kafka_Node_t *node);\nconst char *rd_kafka_Node_rack(const rd_kafka_Node_t *node);\nstruct rd_kafka_group_member_info {\n  char *member_id;\n  char *client_id;\n  char *client_host;\n  void *member_metadata;\n  int member_metadata_size;\n  void *member_assignment;\n  int member_assignment_size;\n};\ntypedef enum {\n  RD_KAFKA_CONSUMER_GROUP_STATE_UNKNOWN = 0,\n  RD_KAFKA_CONSUMER_GROUP_STATE_PREPARING_REBALANCE = 1,\n  RD_KAFKA_CONSUMER_GROUP_STATE_COMPLETING_REBALANCE = 2,\n  RD_KAFKA_CONSUMER_GROUP_STATE_STABLE = 3,\n  RD_KAFKA_CONSUMER_GROUP_STATE_DEAD = 4,\n  RD_KAFKA_CONSUMER_GROUP_STATE_EMPTY = 5,\n  RD_KAFKA_CONSUMER_GROUP_STATE__CNT,\n} rd_kafka_consumer_group_state_t;\nstruct rd_kafka_group_info {\n  struct rd_kafka_metadata_broker broker;\n  char *group;\n  rd_kafka_resp_err_t err;\n  char *state;\n  char *protocol_type;\n  char *protocol;\n  struct rd_kafka_group_member_info *members;\n  int member_cnt;\n};\nstruct rd_kafka_group_list {\n  struct rd_kafka_group_info *groups;\n  int group_cnt;\n};\nrd_kafka_resp_err_t rd_kafka_list_groups(rd_kafka_t *rk, const char *group, const struct rd_kafka_group_list **grplistp, int timeout_ms);\nconst char *rd_kafka_consumer_group_state_name(rd_kafka_consumer_group_state_t state);\nrd_kafka_consumer_group_state_t rd_kafka_consumer_group_state_code(const char *name);\nvoid rd_kafka_group_list_destroy(const struct rd_kafka_group_list *grplist);\nint rd_kafka_brokers_add(rd_kafka_t *rk, const char *brokerlist);\nvoid rd_kafka_set_logger(rd_kafka_t *rk, void (*func)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));\nvoid rd_kafka_set_log_level(rd_kafka_t *rk, int level);\nvoid rd_kafka_log_print(const rd_kafka_t *rk, int level, const char *fac, const char *buf);\nvoid rd_kafka_log_syslog(const rd_kafka_t *rk, int level, const char *fac, const char *buf);\nint rd_kafka_outq_len(rd_kafka_t *rk);\nvoid rd_kafka_dump(FILE *fp, rd_kafka_t *rk);\nint rd_kafka_thread_cnt(void);\ntypedef enum rd_kafka_thread_type_t {\n  RD_KAFKA_THREAD_MAIN,\n  RD_KAFKA_THREAD_BACKGROUND,\n  RD_KAFKA_THREAD_BROKER,\n} rd_kafka_thread_type_t;\nint rd_kafka_wait_destroyed(int timeout_ms);\nint rd_kafka_unittest(void);\nrd_kafka_resp_err_t rd_kafka_poll_set_consumer(rd_kafka_t *rk);\ntypedef int rd_kafka_event_type_t;\nrd_kafka_event_type_t rd_kafka_event_type(const rd_kafka_event_t *rkev);\nconst char *rd_kafka_event_name(const rd_kafka_event_t *rkev);\nvoid rd_kafka_event_destroy(rd_kafka_event_t *rkev);\nconst rd_kafka_message_t *rd_kafka_event_message_next(rd_kafka_event_t *rkev);\nsize_t rd_kafka_event_message_array(rd_kafka_event_t *rkev, const rd_kafka_message_t **rkmessages, size_t size);\nsize_t rd_kafka_event_message_count(rd_kafka_event_t *rkev);\nconst char *rd_kafka_event_config_string(rd_kafka_event_t *rkev);\nrd_kafka_resp_err_t rd_kafka_event_error(rd_kafka_event_t *rkev);\nconst char *rd_kafka_event_error_string(rd_kafka_event_t *rkev);\nint rd_kafka_event_error_is_fatal(rd_kafka_event_t *rkev);\nvoid *rd_kafka_event_opaque(rd_kafka_event_t *rkev);\nint rd_kafka_event_log(rd_kafka_event_t *rkev, const char **fac, const char **str, int *level);\nint rd_kafka_event_debug_contexts(rd_kafka_event_t *rkev, char *dst, size_t dstsize);\nconst char *rd_kafka_event_stats(rd_kafka_event_t *rkev);\nrd_kafka_topic_partition_list_t *rd_kafka_event_topic_partition_list(rd_kafka_event_t *rkev);\nrd_kafka_topic_partition_t *rd_kafka_event_topic_partition(rd_kafka_event_t *rkev);\ntypedef rd_kafka_event_t rd_kafka_CreateTopics_result_t;\ntypedef rd_kafka_event_t rd_kafka_DeleteTopics_result_t;\ntypedef rd_kafka_event_t rd_kafka_CreateAcls_result_t;\ntypedef rd_kafka_event_t rd_kafka_DescribeAcls_result_t;\ntypedef rd_kafka_event_t rd_kafka_DeleteAcls_result_t;\ntypedef rd_kafka_event_t rd_kafka_CreatePartitions_result_t;\ntypedef rd_kafka_event_t rd_kafka_AlterConfigs_result_t;\ntypedef rd_kafka_event_t rd_kafka_IncrementalAlterConfigs_result_t;\ntypedef rd_kafka_event_t rd_kafka_DescribeConfigs_result_t;\ntypedef rd_kafka_event_t rd_kafka_DeleteRecords_result_t;\ntypedef rd_kafka_event_t rd_kafka_ListConsumerGroups_result_t;\ntypedef rd_kafka_event_t rd_kafka_DescribeConsumerGroups_result_t;\ntypedef rd_kafka_event_t rd_kafka_DeleteGroups_result_t;\ntypedef rd_kafka_event_t rd_kafka_DeleteConsumerGroupOffsets_result_t;\ntypedef rd_kafka_event_t rd_kafka_AlterConsumerGroupOffsets_result_t;\ntypedef rd_kafka_event_t rd_kafka_ListConsumerGroupOffsets_result_t;\ntypedef rd_kafka_event_t rd_kafka_DescribeTopics_result_t;\ntypedef rd_kafka_event_t rd_kafka_DescribeCluster_result_t;\ntypedef rd_kafka_event_t rd_kafka_DescribeUserScramCredentials_result_t;\ntypedef rd_kafka_event_t rd_kafka_AlterUserScramCredentials_result_t;\ntypedef rd_kafka_event_t rd_kafka_ListOffsets_result_t;\nconst rd_kafka_CreateTopics_result_t *rd_kafka_event_CreateTopics_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DeleteTopics_result_t *rd_kafka_event_DeleteTopics_result(rd_kafka_event_t *rkev);\nconst rd_kafka_CreatePartitions_result_t *rd_kafka_event_CreatePartitions_result(rd_kafka_event_t *rkev);\nconst rd_kafka_AlterConfigs_result_t *rd_kafka_event_AlterConfigs_result(rd_kafka_event_t *rkev);\nconst rd_kafka_IncrementalAlterConfigs_result_t *rd_kafka_event_IncrementalAlterConfigs_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DescribeConfigs_result_t *rd_kafka_event_DescribeConfigs_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DeleteRecords_result_t *rd_kafka_event_DeleteRecords_result(rd_kafka_event_t *rkev);\nconst rd_kafka_ListConsumerGroups_result_t *rd_kafka_event_ListConsumerGroups_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DescribeConsumerGroups_result_t *rd_kafka_event_DescribeConsumerGroups_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DescribeTopics_result_t *rd_kafka_event_DescribeTopics_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DescribeCluster_result_t *rd_kafka_event_DescribeCluster_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DeleteGroups_result_t *rd_kafka_event_DeleteGroups_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DeleteConsumerGroupOffsets_result_t *rd_kafka_event_DeleteConsumerGroupOffsets_result(rd_kafka_event_t *rkev);\nconst rd_kafka_CreateAcls_result_t *rd_kafka_event_CreateAcls_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DescribeAcls_result_t *rd_kafka_event_DescribeAcls_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DeleteAcls_result_t *rd_kafka_event_DeleteAcls_result(rd_kafka_event_t *rkev);\nconst rd_kafka_ListConsumerGroupOffsets_result_t *rd_kafka_event_ListConsumerGroupOffsets_result(rd_kafka_event_t *rkev);\nconst rd_kafka_AlterConsumerGroupOffsets_result_t *rd_kafka_event_AlterConsumerGroupOffsets_result(rd_kafka_event_t *rkev);\nconst rd_kafka_ListOffsets_result_t *rd_kafka_event_ListOffsets_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DescribeUserScramCredentials_result_t *rd_kafka_event_DescribeUserScramCredentials_result(rd_kafka_event_t *rkev);\nconst rd_kafka_AlterUserScramCredentials_result_t *rd_kafka_event_AlterUserScramCredentials_result(rd_kafka_event_t *rkev);\nrd_kafka_event_t *rd_kafka_queue_poll(rd_kafka_queue_t *rkqu, int timeout_ms);\nint rd_kafka_queue_poll_callback(rd_kafka_queue_t *rkqu, int timeout_ms);\ntypedef rd_kafka_resp_err_t (rd_kafka_plugin_f_conf_init_t)(rd_kafka_conf_t *conf, void **plug_opaquep, char *errstr, size_t errstr_size);\ntypedef rd_kafka_conf_res_t (rd_kafka_interceptor_f_on_conf_set_t)(rd_kafka_conf_t *conf, const char *name, const char *val, char *errstr, size_t errstr_size, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_dup_t)(rd_kafka_conf_t *new_conf, const rd_kafka_conf_t *old_conf, size_t filter_cnt, const char **filter, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_destroy_t)(void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_new_t)(rd_kafka_t *rk, const rd_kafka_conf_t *conf, void *ic_opaque, char *errstr, size_t errstr_size);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_destroy_t)(rd_kafka_t *rk, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_send_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_acknowledgement_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_consume_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_commit_t)(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_resp_err_t err, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_request_sent_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_response_received_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, int64_t rtt, rd_kafka_resp_err_t err, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_start_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_exit_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_broker_state_change_t)(rd_kafka_t *rk, int32_t broker_id, const char *secproto, const char *name, int port, const char *state, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_set(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_set_t *on_conf_set, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_dup(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_dup_t *on_conf_dup, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_destroy(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_destroy_t *on_conf_destroy, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_new(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_new_t *on_new, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_destroy(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_destroy_t *on_destroy, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_send(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_send_t *on_send, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_acknowledgement(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_acknowledgement_t *on_acknowledgement, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_consume(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_consume_t *on_consume, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_commit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_commit_t *on_commit, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_request_sent(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_request_sent_t *on_request_sent, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_response_received(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_response_received_t *on_response_received, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_start(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_start_t *on_thread_start, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_exit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_exit_t *on_thread_exit, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_broker_state_change(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_broker_state_change_t *on_broker_state_change, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_topic_result_error(const rd_kafka_topic_result_t *topicres);\nconst char *rd_kafka_topic_result_error_string(const rd_kafka_topic_result_t *topicres);\nconst char *rd_kafka_topic_result_name(const rd_kafka_topic_result_t *topicres);\nconst rd_kafka_error_t *rd_kafka_group_result_error(const rd_kafka_group_result_t *groupres);\nconst char *rd_kafka_group_result_name(const rd_kafka_group_result_t *groupres);\nconst rd_kafka_topic_partition_list_t *rd_kafka_group_result_partitions(const rd_kafka_group_result_t *groupres);\ntypedef enum rd_kafka_admin_op_t {\n  RD_KAFKA_ADMIN_OP_ANY = 0,\n  RD_KAFKA_ADMIN_OP_CREATETOPICS,\n  RD_KAFKA_ADMIN_OP_DELETETOPICS,\n  RD_KAFKA_ADMIN_OP_CREATEPARTITIONS,\n  RD_KAFKA_ADMIN_OP_ALTERCONFIGS,\n  RD_KAFKA_ADMIN_OP_DESCRIBECONFIGS,\n  RD_KAFKA_ADMIN_OP_DELETERECORDS,\n  RD_KAFKA_ADMIN_OP_DELETEGROUPS,\n  RD_KAFKA_ADMIN_OP_DELETECONSUMERGROUPOFFSETS,\n  RD_KAFKA_ADMIN_OP_CREATEACLS,\n  RD_KAFKA_ADMIN_OP_DESCRIBEACLS,\n  RD_KAFKA_ADMIN_OP_DELETEACLS,\n  RD_KAFKA_ADMIN_OP_LISTCONSUMERGROUPS,\n  RD_KAFKA_ADMIN_OP_DESCRIBECONSUMERGROUPS,\n  RD_KAFKA_ADMIN_OP_LISTCONSUMERGROUPOFFSETS,\n  RD_KAFKA_ADMIN_OP_ALTERCONSUMERGROUPOFFSETS,\n  RD_KAFKA_ADMIN_OP_INCREMENTALALTERCONFIGS,\n  RD_KAFKA_ADMIN_OP_DESCRIBEUSERSCRAMCREDENTIALS,\n  RD_KAFKA_ADMIN_OP_ALTERUSERSCRAMCREDENTIALS,\n  RD_KAFKA_ADMIN_OP_DESCRIBETOPICS,\n  RD_KAFKA_ADMIN_OP_DESCRIBECLUSTER,\n  RD_KAFKA_ADMIN_OP_LISTOFFSETS,\n  RD_KAFKA_ADMIN_OP__CNT,\n} rd_kafka_admin_op_t;\ntypedef struct rd_kafka_AdminOptions_s rd_kafka_AdminOptions_t;\ntypedef enum rd_kafka_IsolationLevel_t {\n  RD_KAFKA_ISOLATION_LEVEL_READ_UNCOMMITTED = 0,\n  RD_KAFKA_ISOLATION_LEVEL_READ_COMMITTED = 1,\n} rd_kafka_IsolationLevel_t;\nrd_kafka_AdminOptions_t *rd_kafka_AdminOptions_new(rd_kafka_t *rk, rd_kafka_admin_op_t for_api);\nvoid rd_kafka_AdminOptions_destroy(rd_kafka_AdminOptions_t *options);\nrd_kafka_resp_err_t rd_kafka_AdminOptions_set_request_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_AdminOptions_set_operation_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_AdminOptions_set_validate_only(rd_kafka_AdminOptions_t *options, int true_or_false, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_AdminOptions_set_broker(rd_kafka_AdminOptions_t *options, int32_t broker_id, char *errstr, size_t errstr_size);\nrd_kafka_error_t *rd_kafka_AdminOptions_set_require_stable_offsets(rd_kafka_AdminOptions_t *options, int true_or_false);\nrd_kafka_error_t *rd_kafka_AdminOptions_set_include_authorized_operations(rd_kafka_AdminOptions_t *options, int true_or_false);\nrd_kafka_error_t *rd_kafka_AdminOptions_set_match_consumer_group_states(rd_kafka_AdminOptions_t *options, const rd_kafka_consumer_group_state_t *consumer_group_states, size_t consumer_group_states_cnt);\nrd_kafka_error_t *rd_kafka_AdminOptions_set_isolation_level(rd_kafka_AdminOptions_t *options, rd_kafka_IsolationLevel_t value);\nvoid rd_kafka_AdminOptions_set_opaque(rd_kafka_AdminOptions_t *options, void *ev_opaque);\ntypedef enum rd_kafka_AclOperation_t {\n  RD_KAFKA_ACL_OPERATION_UNKNOWN = 0,\n  RD_KAFKA_ACL_OPERATION_ANY = 1,\n  RD_KAFKA_ACL_OPERATION_ALL = 2,\n  RD_KAFKA_ACL_OPERATION_READ = 3,\n  RD_KAFKA_ACL_OPERATION_WRITE = 4,\n  RD_KAFKA_ACL_OPERATION_CREATE = 5,\n  RD_KAFKA_ACL_OPERATION_DELETE = 6,\n  RD_KAFKA_ACL_OPERATION_ALTER = 7,\n  RD_KAFKA_ACL_OPERATION_DESCRIBE = 8,\n  RD_KAFKA_ACL_OPERATION_CLUSTER_ACTION = 9,\n  RD_KAFKA_ACL_OPERATION_DESCRIBE_CONFIGS = 10,\n  RD_KAFKA_ACL_OPERATION_ALTER_CONFIGS = 11,\n  RD_KAFKA_ACL_OPERATION_IDEMPOTENT_WRITE = 12,\n  RD_KAFKA_ACL_OPERATION__CNT,\n} rd_kafka_AclOperation_t;\ntypedef struct rd_kafka_NewTopic_s rd_kafka_NewTopic_t;\nrd_kafka_NewTopic_t *rd_kafka_NewTopic_new(const char *topic, int num_partitions, int replication_factor, char *errstr, size_t errstr_size);\nvoid rd_kafka_NewTopic_destroy(rd_kafka_NewTopic_t *new_topic);\nvoid rd_kafka_NewTopic_destroy_array(rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt);\nrd_kafka_resp_err_t rd_kafka_NewTopic_set_replica_assignment(rd_kafka_NewTopic_t *new_topic, int32_t partition, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_NewTopic_set_config(rd_kafka_NewTopic_t *new_topic, const char *name, const char *value);\nvoid rd_kafka_CreateTopics(rd_kafka_t *rk, rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_topic_result_t **rd_kafka_CreateTopics_result_topics(const rd_kafka_CreateTopics_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_DeleteTopic_s rd_kafka_DeleteTopic_t;\nrd_kafka_DeleteTopic_t *rd_kafka_DeleteTopic_new(const char *topic);\nvoid rd_kafka_DeleteTopic_destroy(rd_kafka_DeleteTopic_t *del_topic);\nvoid rd_kafka_DeleteTopic_destroy_array(rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt);\nvoid rd_kafka_DeleteTopics(rd_kafka_t *rk, rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_topic_result_t **rd_kafka_DeleteTopics_result_topics(const rd_kafka_DeleteTopics_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_NewPartitions_s rd_kafka_NewPartitions_t;\nrd_kafka_NewPartitions_t *rd_kafka_NewPartitions_new(const char *topic, size_t new_total_cnt, char *errstr, size_t errstr_size);\nvoid rd_kafka_NewPartitions_destroy(rd_kafka_NewPartitions_t *new_parts);\nvoid rd_kafka_NewPartitions_destroy_array(rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt);\nrd_kafka_resp_err_t rd_kafka_NewPartitions_set_replica_assignment(rd_kafka_NewPartitions_t *new_parts, int32_t new_partition_idx, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);\nvoid rd_kafka_CreatePartitions(rd_kafka_t *rk, rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_topic_result_t **rd_kafka_CreatePartitions_result_topics(const rd_kafka_CreatePartitions_result_t *result, size_t *cntp);\ntypedef enum rd_kafka_ConfigSource_t {\n  RD_KAFKA_CONFIG_SOURCE_UNKNOWN_CONFIG = 0,\n  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_TOPIC_CONFIG = 1,\n  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_BROKER_CONFIG = 2,\n  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_DEFAULT_BROKER_CONFIG = 3,\n  RD_KAFKA_CONFIG_SOURCE_STATIC_BROKER_CONFIG = 4,\n  RD_KAFKA_CONFIG_SOURCE_DEFAULT_CONFIG = 5,\n  RD_KAFKA_CONFIG_SOURCE__CNT,\n} rd_kafka_ConfigSource_t;\nconst char *rd_kafka_ConfigSource_name(rd_kafka_ConfigSource_t confsource);\ntypedef struct rd_kafka_ConfigEntry_s rd_kafka_ConfigEntry_t;\nconst char *rd_kafka_ConfigEntry_name(const rd_kafka_ConfigEntry_t *entry);\nconst char *rd_kafka_ConfigEntry_value(const rd_kafka_ConfigEntry_t *entry);\nrd_kafka_ConfigSource_t rd_kafka_ConfigEntry_source(const rd_kafka_ConfigEntry_t *entry);\nint rd_kafka_ConfigEntry_is_read_only(const rd_kafka_ConfigEntry_t *entry);\nint rd_kafka_ConfigEntry_is_default(const rd_kafka_ConfigEntry_t *entry);\nint rd_kafka_ConfigEntry_is_sensitive(const rd_kafka_ConfigEntry_t *entry);\nint rd_kafka_ConfigEntry_is_synonym(const rd_kafka_ConfigEntry_t *entry);\nconst rd_kafka_ConfigEntry_t **rd_kafka_ConfigEntry_synonyms(const rd_kafka_ConfigEntry_t *entry, size_t *cntp);\ntypedef enum rd_kafka_ResourceType_t {\n  RD_KAFKA_RESOURCE_UNKNOWN = 0,\n  RD_KAFKA_RESOURCE_ANY = 1,\n  RD_KAFKA_RESOURCE_TOPIC = 2,\n  RD_KAFKA_RESOURCE_GROUP = 3,\n  RD_KAFKA_RESOURCE_BROKER = 4,\n  RD_KAFKA_RESOURCE__CNT,\n} rd_kafka_ResourceType_t;\ntypedef enum rd_kafka_ResourcePatternType_t {\n  RD_KAFKA_RESOURCE_PATTERN_UNKNOWN = 0,\n  RD_KAFKA_RESOURCE_PATTERN_ANY = 1,\n  RD_KAFKA_RESOURCE_PATTERN_MATCH = 2,\n  RD_KAFKA_RESOURCE_PATTERN_LITERAL = 3,\n  RD_KAFKA_RESOURCE_PATTERN_PREFIXED = 4,\n  RD_KAFKA_RESOURCE_PATTERN_TYPE__CNT,\n} rd_kafka_ResourcePatternType_t;\ntypedef enum rd_kafka_AlterConfigOpType_t {\n  RD_KAFKA_ALTER_CONFIG_OP_TYPE_SET = 0,\n  RD_KAFKA_ALTER_CONFIG_OP_TYPE_DELETE = 1,\n  RD_KAFKA_ALTER_CONFIG_OP_TYPE_APPEND = 2,\n  RD_KAFKA_ALTER_CONFIG_OP_TYPE_SUBTRACT = 3,\n  RD_KAFKA_ALTER_CONFIG_OP_TYPE__CNT,\n} rd_kafka_AlterConfigOpType_t;\nconst char *rd_kafka_ResourcePatternType_name(rd_kafka_ResourcePatternType_t resource_pattern_type);\nconst char *rd_kafka_ResourceType_name(rd_kafka_ResourceType_t restype);\ntypedef struct rd_kafka_ConfigResource_s rd_kafka_ConfigResource_t;\nrd_kafka_ConfigResource_t *rd_kafka_ConfigResource_new(rd_kafka_ResourceType_t restype, const char *resname);\nvoid rd_kafka_ConfigResource_destroy(rd_kafka_ConfigResource_t *config);\nvoid rd_kafka_ConfigResource_destroy_array(rd_kafka_ConfigResource_t **config, size_t config_cnt);\nrd_kafka_resp_err_t rd_kafka_ConfigResource_set_config(rd_kafka_ConfigResource_t *config, const char *name, const char *value);\nrd_kafka_error_t *rd_kafka_ConfigResource_add_incremental_config(rd_kafka_ConfigResource_t *config, const char *name, rd_kafka_AlterConfigOpType_t op_type, const char *value);\nconst rd_kafka_ConfigEntry_t **rd_kafka_ConfigResource_configs(const rd_kafka_ConfigResource_t *config, size_t *cntp);\nrd_kafka_ResourceType_t rd_kafka_ConfigResource_type(const rd_kafka_ConfigResource_t *config);\nconst char *rd_kafka_ConfigResource_name(const rd_kafka_ConfigResource_t *config);\nrd_kafka_resp_err_t rd_kafka_ConfigResource_error(const rd_kafka_ConfigResource_t *config);\nconst char *rd_kafka_ConfigResource_error_string(const rd_kafka_ConfigResource_t *config);\nvoid rd_kafka_AlterConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_ConfigResource_t **rd_kafka_AlterConfigs_result_resources(const rd_kafka_AlterConfigs_result_t *result, size_t *cntp);\nvoid rd_kafka_IncrementalAlterConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_ConfigResource_t **rd_kafka_IncrementalAlterConfigs_result_resources(const rd_kafka_IncrementalAlterConfigs_result_t *result, size_t *cntp);\nvoid rd_kafka_DescribeConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_ConfigResource_t **rd_kafka_DescribeConfigs_result_resources(const rd_kafka_DescribeConfigs_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_DeleteRecords_s rd_kafka_DeleteRecords_t;\nrd_kafka_DeleteRecords_t *rd_kafka_DeleteRecords_new(const rd_kafka_topic_partition_list_t *before_offsets);\nvoid rd_kafka_DeleteRecords_destroy(rd_kafka_DeleteRecords_t *del_records);\nvoid rd_kafka_DeleteRecords_destroy_array(rd_kafka_DeleteRecords_t **del_records, size_t del_record_cnt);\nvoid rd_kafka_DeleteRecords(rd_kafka_t *rk, rd_kafka_DeleteRecords_t **del_records, size_t del_record_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_topic_partition_list_t *rd_kafka_DeleteRecords_result_offsets(const rd_kafka_DeleteRecords_result_t *result);\ntypedef struct rd_kafka_TopicCollection_s rd_kafka_TopicCollection_t;\ntypedef struct rd_kafka_TopicPartitionInfo_s rd_kafka_TopicPartitionInfo_t;\ntypedef struct rd_kafka_TopicDescription_s rd_kafka_TopicDescription_t;\nrd_kafka_TopicCollection_t *rd_kafka_TopicCollection_of_topic_names(const char **topics, size_t topics_cnt);\nvoid rd_kafka_TopicCollection_destroy(rd_kafka_TopicCollection_t *topics);\nvoid rd_kafka_DescribeTopics(rd_kafka_t *rk, const rd_kafka_TopicCollection_t *topics, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_TopicDescription_t **rd_kafka_DescribeTopics_result_topics(const rd_kafka_DescribeTopics_result_t *result, size_t *cntp);\nconst rd_kafka_TopicPartitionInfo_t **rd_kafka_TopicDescription_partitions(const rd_kafka_TopicDescription_t *topicdesc, size_t *cntp);\nconst int rd_kafka_TopicPartitionInfo_partition(const rd_kafka_TopicPartitionInfo_t *partition);\nconst rd_kafka_Node_t *rd_kafka_TopicPartitionInfo_leader(const rd_kafka_TopicPartitionInfo_t *partition);\nconst rd_kafka_Node_t **rd_kafka_TopicPartitionInfo_isr(const rd_kafka_TopicPartitionInfo_t *partition, size_t *cntp);\nconst rd_kafka_Node_t **rd_kafka_TopicPartitionInfo_replicas(const rd_kafka_TopicPartitionInfo_t *partition, size_t *cntp);\nconst rd_kafka_AclOperation_t *rd_kafka_TopicDescription_authorized_operations(const rd_kafka_TopicDescription_t *topicdesc, size_t *cntp);\nconst char *rd_kafka_TopicDescription_name(const rd_kafka_TopicDescription_t *topicdesc);\nconst rd_kafka_Uuid_t *rd_kafka_TopicDescription_topic_id(const rd_kafka_TopicDescription_t *topicdesc);\nint rd_kafka_TopicDescription_is_internal(const rd_kafka_TopicDescription_t *topicdesc);\nconst rd_kafka_error_t *rd_kafka_TopicDescription_error(const rd_kafka_TopicDescription_t *topicdesc);\nvoid rd_kafka_DescribeCluster(rd_kafka_t *rk, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_Node_t **rd_kafka_DescribeCluster_result_nodes(const rd_kafka_DescribeCluster_result_t *result, size_t *cntp);\nconst rd_kafka_AclOperation_t *rd_kafka_DescribeCluster_result_authorized_operations(const rd_kafka_DescribeCluster_result_t *result, size_t *cntp);\nconst rd_kafka_Node_t *rd_kafka_DescribeCluster_result_controller(const rd_kafka_DescribeCluster_result_t *result);\nconst char *rd_kafka_DescribeCluster_result_cluster_id(const rd_kafka_DescribeCluster_result_t *result);\ntypedef struct rd_kafka_ConsumerGroupListing_s rd_kafka_ConsumerGroupListing_t;\ntypedef struct rd_kafka_ListConsumerGroupsResult_s rd_kafka_ListConsumerGroupsResult_t;\nvoid rd_kafka_ListConsumerGroups(rd_kafka_t *rk, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst char *rd_kafka_ConsumerGroupListing_group_id(const rd_kafka_ConsumerGroupListing_t *grplist);\nint rd_kafka_ConsumerGroupListing_is_simple_consumer_group(const rd_kafka_ConsumerGroupListing_t *grplist);\nrd_kafka_consumer_group_state_t rd_kafka_ConsumerGroupListing_state(const rd_kafka_ConsumerGroupListing_t *grplist);\nconst rd_kafka_ConsumerGroupListing_t **rd_kafka_ListConsumerGroups_result_valid(const rd_kafka_ListConsumerGroups_result_t *result, size_t *cntp);\nconst rd_kafka_error_t **rd_kafka_ListConsumerGroups_result_errors(const rd_kafka_ListConsumerGroups_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_ConsumerGroupDescription_s rd_kafka_ConsumerGroupDescription_t;\ntypedef struct rd_kafka_MemberDescription_s rd_kafka_MemberDescription_t;\ntypedef struct rd_kafka_MemberAssignment_s rd_kafka_MemberAssignment_t;\nvoid rd_kafka_DescribeConsumerGroups(rd_kafka_t *rk, const char **groups, size_t groups_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_ConsumerGroupDescription_t **rd_kafka_DescribeConsumerGroups_result_groups(const rd_kafka_DescribeConsumerGroups_result_t *result, size_t *cntp);\nconst char *rd_kafka_ConsumerGroupDescription_group_id(const rd_kafka_ConsumerGroupDescription_t *grpdesc);\nconst rd_kafka_error_t *rd_kafka_ConsumerGroupDescription_error(const rd_kafka_ConsumerGroupDescription_t *grpdesc);\nint rd_kafka_ConsumerGroupDescription_is_simple_consumer_group(const rd_kafka_ConsumerGroupDescription_t *grpdesc);\nconst char *rd_kafka_ConsumerGroupDescription_partition_assignor(const rd_kafka_ConsumerGroupDescription_t *grpdesc);\nconst rd_kafka_AclOperation_t *rd_kafka_ConsumerGroupDescription_authorized_operations(const rd_kafka_ConsumerGroupDescription_t *grpdesc, size_t *cntp);\nrd_kafka_consumer_group_state_t rd_kafka_ConsumerGroupDescription_state(const rd_kafka_ConsumerGroupDescription_t *grpdesc);\nconst rd_kafka_Node_t *rd_kafka_ConsumerGroupDescription_coordinator(const rd_kafka_ConsumerGroupDescription_t *grpdesc);\nsize_t rd_kafka_ConsumerGroupDescription_member_count(const rd_kafka_ConsumerGroupDescription_t *grpdesc);\nconst rd_kafka_MemberDescription_t *rd_kafka_ConsumerGroupDescription_member(const rd_kafka_ConsumerGroupDescription_t *grpdesc, size_t idx);\nconst char *rd_kafka_MemberDescription_client_id(const rd_kafka_MemberDescription_t *member);\nconst char *rd_kafka_MemberDescription_group_instance_id(const rd_kafka_MemberDescription_t *member);\nconst char *rd_kafka_MemberDescription_consumer_id(const rd_kafka_MemberDescription_t *member);\nconst char *rd_kafka_MemberDescription_host(const rd_kafka_MemberDescription_t *member);\nconst rd_kafka_MemberAssignment_t *rd_kafka_MemberDescription_assignment(const rd_kafka_MemberDescription_t *member);\nconst rd_kafka_topic_partition_list_t *rd_kafka_MemberAssignment_partitions(const rd_kafka_MemberAssignment_t *assignment);\ntypedef struct rd_kafka_DeleteGroup_s rd_kafka_DeleteGroup_t;\nrd_kafka_DeleteGroup_t *rd_kafka_DeleteGroup_new(const char *group);\nvoid rd_kafka_DeleteGroup_destroy(rd_kafka_DeleteGroup_t *del_group);\nvoid rd_kafka_DeleteGroup_destroy_array(rd_kafka_DeleteGroup_t **del_groups, size_t del_group_cnt);\nvoid rd_kafka_DeleteGroups(rd_kafka_t *rk, rd_kafka_DeleteGroup_t **del_groups, size_t del_group_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_group_result_t **rd_kafka_DeleteGroups_result_groups(const rd_kafka_DeleteGroups_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_ListConsumerGroupOffsets_s rd_kafka_ListConsumerGroupOffsets_t;\nrd_kafka_ListConsumerGroupOffsets_t *rd_kafka_ListConsumerGroupOffsets_new(const char *group_id, const rd_kafka_topic_partition_list_t *partitions);\nvoid rd_kafka_ListConsumerGroupOffsets_destroy(rd_kafka_ListConsumerGroupOffsets_t *list_grpoffsets);\nvoid rd_kafka_ListConsumerGroupOffsets_destroy_array(rd_kafka_ListConsumerGroupOffsets_t **list_grpoffsets, size_t list_grpoffset_cnt);\nvoid rd_kafka_ListConsumerGroupOffsets(rd_kafka_t *rk, rd_kafka_ListConsumerGroupOffsets_t **list_grpoffsets, size_t list_grpoffsets_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_group_result_t **rd_kafka_ListConsumerGroupOffsets_result_groups(const rd_kafka_ListConsumerGroupOffsets_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_AlterConsumerGroupOffsets_s rd_kafka_AlterConsumerGroupOffsets_t;\nrd_kafka_AlterConsumerGroupOffsets_t *rd_kafka_AlterConsumerGroupOffsets_new(const char *group_id, const rd_kafka_topic_partition_list_t *partitions);\nvoid rd_kafka_AlterConsumerGroupOffsets_destroy(rd_kafka_AlterConsumerGroupOffsets_t *alter_grpoffsets);\nvoid rd_kafka_AlterConsumerGroupOffsets_destroy_array(rd_kafka_AlterConsumerGroupOffsets_t **alter_grpoffsets, size_t alter_grpoffset_cnt);\nvoid rd_kafka_AlterConsumerGroupOffsets(rd_kafka_t *rk, rd_kafka_AlterConsumerGroupOffsets_t **alter_grpoffsets, size_t alter_grpoffsets_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_group_result_t **rd_kafka_AlterConsumerGroupOffsets_result_groups(const rd_kafka_AlterConsumerGroupOffsets_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_DeleteConsumerGroupOffsets_s rd_kafka_DeleteConsumerGroupOffsets_t;\nrd_kafka_DeleteConsumerGroupOffsets_t *rd_kafka_DeleteConsumerGroupOffsets_new(const char *group, const rd_kafka_topic_partition_list_t *partitions);\nvoid rd_kafka_DeleteConsumerGroupOffsets_destroy(rd_kafka_DeleteConsumerGroupOffsets_t *del_grpoffsets);\nvoid rd_kafka_DeleteConsumerGroupOffsets_destroy_array(rd_kafka_DeleteConsumerGroupOffsets_t **del_grpoffsets, size_t del_grpoffset_cnt);\nvoid rd_kafka_DeleteConsumerGroupOffsets(rd_kafka_t *rk, rd_kafka_DeleteConsumerGroupOffsets_t **del_grpoffsets, size_t del_grpoffsets_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_group_result_t **rd_kafka_DeleteConsumerGroupOffsets_result_groups(const rd_kafka_DeleteConsumerGroupOffsets_result_t *result, size_t *cntp);\ntypedef enum rd_kafka_OffsetSpec_t {\n  RD_KAFKA_OFFSET_SPEC_MAX_TIMESTAMP = (- 3),\n  RD_KAFKA_OFFSET_SPEC_EARLIEST = (- 2),\n  RD_KAFKA_OFFSET_SPEC_LATEST = (- 1),\n} rd_kafka_OffsetSpec_t;\ntypedef struct rd_kafka_ListOffsetsResultInfo_s rd_kafka_ListOffsetsResultInfo_t;\nconst rd_kafka_topic_partition_t *rd_kafka_ListOffsetsResultInfo_topic_partition(const rd_kafka_ListOffsetsResultInfo_t *result_info);\nint64_t rd_kafka_ListOffsetsResultInfo_timestamp(const rd_kafka_ListOffsetsResultInfo_t *result_info);\nconst rd_kafka_ListOffsetsResultInfo_t **rd_kafka_ListOffsets_result_infos(const rd_kafka_ListOffsets_result_t *result, size_t *cntp);\nvoid rd_kafka_ListOffsets(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *topic_partitions, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\ntypedef enum rd_kafka_ScramMechanism_t {\n  RD_KAFKA_SCRAM_MECHANISM_UNKNOWN = 0,\n  RD_KAFKA_SCRAM_MECHANISM_SHA_256 = 1,\n  RD_KAFKA_SCRAM_MECHANISM_SHA_512 = 2,\n  RD_KAFKA_SCRAM_MECHANISM__CNT,\n} rd_kafka_ScramMechanism_t;\ntypedef struct rd_kafka_ScramCredentialInfo_s rd_kafka_ScramCredentialInfo_t;\nrd_kafka_ScramMechanism_t rd_kafka_ScramCredentialInfo_mechanism(const rd_kafka_ScramCredentialInfo_t *scram_credential_info);\nint32_t rd_kafka_ScramCredentialInfo_iterations(const rd_kafka_ScramCredentialInfo_t *scram_credential_info);\ntypedef struct rd_kafka_UserScramCredentialsDescription_s rd_kafka_UserScramCredentialsDescription_t;\nconst char *rd_kafka_UserScramCredentialsDescription_user(const rd_kafka_UserScramCredentialsDescription_t *description);\nconst rd_kafka_error_t *rd_kafka_UserScramCredentialsDescription_error(const rd_kafka_UserScramCredentialsDescription_t *description);\nsize_t rd_kafka_UserScramCredentialsDescription_scramcredentialinfo_count(const rd_kafka_UserScramCredentialsDescription_t *description);\nconst rd_kafka_ScramCredentialInfo_t *rd_kafka_UserScramCredentialsDescription_scramcredentialinfo(const rd_kafka_UserScramCredentialsDescription_t *description, size_t idx);\nconst rd_kafka_UserScramCredentialsDescription_t **rd_kafka_DescribeUserScramCredentials_result_descriptions(const rd_kafka_DescribeUserScramCredentials_result_t *result, size_t *cntp);\nvoid rd_kafka_DescribeUserScramCredentials(rd_kafka_t *rk, const char **users, size_t user_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\ntypedef struct rd_kafka_UserScramCredentialAlteration_s rd_kafka_UserScramCredentialAlteration_t;\nrd_kafka_UserScramCredentialAlteration_t *rd_kafka_UserScramCredentialUpsertion_new(const char *username, rd_kafka_ScramMechanism_t mechanism, int32_t iterations, const unsigned char *password, size_t password_size, const unsigned char *salt, size_t salt_size);\nrd_kafka_UserScramCredentialAlteration_t *rd_kafka_UserScramCredentialDeletion_new(const char *username, rd_kafka_ScramMechanism_t mechanism);\nvoid rd_kafka_UserScramCredentialAlteration_destroy(rd_kafka_UserScramCredentialAlteration_t *alteration);\nvoid rd_kafka_UserScramCredentialAlteration_destroy_array(rd_kafka_UserScramCredentialAlteration_t **alterations, size_t alteration_cnt);\ntypedef struct rd_kafka_AlterUserScramCredentials_result_response_s rd_kafka_AlterUserScramCredentials_result_response_t;\nconst char *rd_kafka_AlterUserScramCredentials_result_response_user(const rd_kafka_AlterUserScramCredentials_result_response_t *response);\nconst rd_kafka_error_t *rd_kafka_AlterUserScramCredentials_result_response_error(const rd_kafka_AlterUserScramCredentials_result_response_t *response);\nconst rd_kafka_AlterUserScramCredentials_result_response_t **rd_kafka_AlterUserScramCredentials_result_responses(const rd_kafka_AlterUserScramCredentials_result_t *result, size_t *cntp);\nvoid rd_kafka_AlterUserScramCredentials(rd_kafka_t *rk, rd_kafka_UserScramCredentialAlteration_t **alterations, size_t alteration_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\ntypedef struct rd_kafka_AclBinding_s rd_kafka_AclBinding_t;\ntypedef rd_kafka_AclBinding_t rd_kafka_AclBindingFilter_t;\nconst rd_kafka_error_t *rd_kafka_acl_result_error(const rd_kafka_acl_result_t *aclres);\nconst char *rd_kafka_AclOperation_name(rd_kafka_AclOperation_t acl_operation);\ntypedef enum rd_kafka_AclPermissionType_t {\n  RD_KAFKA_ACL_PERMISSION_TYPE_UNKNOWN = 0,\n  RD_KAFKA_ACL_PERMISSION_TYPE_ANY = 1,\n  RD_KAFKA_ACL_PERMISSION_TYPE_DENY = 2,\n  RD_KAFKA_ACL_PERMISSION_TYPE_ALLOW = 3,\n  RD_KAFKA_ACL_PERMISSION_TYPE__CNT,\n} rd_kafka_AclPermissionType_t;\nconst char *rd_kafka_AclPermissionType_name(rd_kafka_AclPermissionType_t acl_permission_type);\nrd_kafka_AclBinding_t *rd_kafka_AclBinding_new(rd_kafka_ResourceType_t restype, const char *name, rd_kafka_ResourcePatternType_t resource_pattern_type, const char *principal, const char *host, rd_kafka_AclOperation_t operation, rd_kafka_AclPermissionType_t permission_type, char *errstr, size_t errstr_size);\nrd_kafka_AclBindingFilter_t *rd_kafka_AclBindingFilter_new(rd_kafka_ResourceType_t restype, const char *name, rd_kafka_ResourcePatternType_t resource_pattern_type, const char *principal, const char *host, rd_kafka_AclOperation_t operation, rd_kafka_AclPermissionType_t permission_type, char *errstr, size_t errstr_size);\nrd_kafka_ResourceType_t rd_kafka_AclBinding_restype(const rd_kafka_AclBinding_t *acl);\nconst char *rd_kafka_AclBinding_name(const rd_kafka_AclBinding_t *acl);\nconst char *rd_kafka_AclBinding_principal(const rd_kafka_AclBinding_t *acl);\nconst char *rd_kafka_AclBinding_host(const rd_kafka_AclBinding_t *acl);\nrd_kafka_AclOperation_t rd_kafka_AclBinding_operation(const rd_kafka_AclBinding_t *acl);\nrd_kafka_AclPermissionType_t rd_kafka_AclBinding_permission_type(const rd_kafka_AclBinding_t *acl);\nrd_kafka_ResourcePatternType_t rd_kafka_AclBinding_resource_pattern_type(const rd_kafka_AclBinding_t *acl);\nconst rd_kafka_error_t *rd_kafka_AclBinding_error(const rd_kafka_AclBinding_t *acl);\nvoid rd_kafka_AclBinding_destroy(rd_kafka_AclBinding_t *acl_binding);\nvoid rd_kafka_AclBinding_destroy_array(rd_kafka_AclBinding_t **acl_bindings, size_t acl_bindings_cnt);\nconst rd_kafka_acl_result_t **rd_kafka_CreateAcls_result_acls(const rd_kafka_CreateAcls_result_t *result, size_t *cntp);\nvoid rd_kafka_CreateAcls(rd_kafka_t *rk, rd_kafka_AclBinding_t **new_acls, size_t new_acls_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_AclBinding_t **rd_kafka_DescribeAcls_result_acls(const rd_kafka_DescribeAcls_result_t *result, size_t *cntp);\nvoid rd_kafka_DescribeAcls(rd_kafka_t *rk, rd_kafka_AclBindingFilter_t *acl_filter, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\ntypedef struct rd_kafka_DeleteAcls_result_response_s rd_kafka_DeleteAcls_result_response_t;\nconst rd_kafka_DeleteAcls_result_response_t **rd_kafka_DeleteAcls_result_responses(const rd_kafka_DeleteAcls_result_t *result, size_t *cntp);\nconst rd_kafka_error_t *rd_kafka_DeleteAcls_result_response_error(const rd_kafka_DeleteAcls_result_response_t *result_response);\nconst rd_kafka_AclBinding_t **rd_kafka_DeleteAcls_result_response_matching_acls(const rd_kafka_DeleteAcls_result_response_t *result_response, size_t *matching_acls_cntp);\nvoid rd_kafka_DeleteAcls(rd_kafka_t *rk, rd_kafka_AclBindingFilter_t **del_acls, size_t del_acls_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nrd_kafka_resp_err_t rd_kafka_oauthbearer_set_token(rd_kafka_t *rk, const char *token_value, int64_t md_lifetime_ms, const char *md_principal_name, const char **extensions, size_t extension_size, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_oauthbearer_set_token_failure(rd_kafka_t *rk, const char *errstr);\nrd_kafka_error_t *rd_kafka_init_transactions(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_error_t *rd_kafka_begin_transaction(rd_kafka_t *rk);\nrd_kafka_error_t *rd_kafka_send_offsets_to_transaction(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, const rd_kafka_consumer_group_metadata_t *cgmetadata, int timeout_ms);\nrd_kafka_error_t *rd_kafka_commit_transaction(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_error_t *rd_kafka_abort_transaction(rd_kafka_t *rk, int timeout_ms);\ntypedef struct rd_kafka_mock_cluster_s rd_kafka_mock_cluster_t;\nrd_kafka_mock_cluster_t *rd_kafka_mock_cluster_new(rd_kafka_t *rk, int broker_cnt);\nvoid rd_kafka_mock_cluster_destroy(rd_kafka_mock_cluster_t *mcluster);\nrd_kafka_t *rd_kafka_mock_cluster_handle(const rd_kafka_mock_cluster_t *mcluster);\nrd_kafka_mock_cluster_t *rd_kafka_handle_mock_cluster(const rd_kafka_t *rk);\nconst char *rd_kafka_mock_cluster_bootstraps(const rd_kafka_mock_cluster_t *mcluster);\nvoid rd_kafka_mock_clear_request_errors(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey);\nvoid rd_kafka_mock_push_request_errors(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, size_t cnt, ...);\nvoid rd_kafka_mock_push_request_errors_array(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, size_t cnt, const rd_kafka_resp_err_t *errors);\nrd_kafka_resp_err_t rd_kafka_mock_broker_push_request_error_rtts(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int16_t ApiKey, size_t cnt, ...);\nrd_kafka_resp_err_t rd_kafka_mock_broker_error_stack_cnt(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int16_t ApiKey, size_t *cntp);\nvoid rd_kafka_mock_topic_set_error(rd_kafka_mock_cluster_t *mcluster, const char *topic, rd_kafka_resp_err_t err);\nrd_kafka_resp_err_t rd_kafka_mock_topic_create(rd_kafka_mock_cluster_t *mcluster, const char *topic, int partition_cnt, int replication_factor);\nrd_kafka_resp_err_t rd_kafka_mock_partition_set_leader(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id);\nrd_kafka_resp_err_t rd_kafka_mock_partition_set_follower(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id);\nrd_kafka_resp_err_t rd_kafka_mock_partition_set_follower_wmarks(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int64_t lo, int64_t hi);\nrd_kafka_resp_err_t rd_kafka_mock_partition_push_leader_response(rd_kafka_mock_cluster_t *mcluster, const char *topic, int partition, int32_t leader_id, int32_t leader_epoch);\nrd_kafka_resp_err_t rd_kafka_mock_broker_set_down(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id);\nrd_kafka_resp_err_t rd_kafka_mock_broker_set_up(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id);\nrd_kafka_resp_err_t rd_kafka_mock_broker_set_rtt(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int rtt_ms);\nrd_kafka_resp_err_t rd_kafka_mock_broker_set_rack(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, const char *rack);\nrd_kafka_resp_err_t rd_kafka_mock_coordinator_set(rd_kafka_mock_cluster_t *mcluster, const char *key_type, const char *key, int32_t broker_id);\nrd_kafka_resp_err_t rd_kafka_mock_set_apiversion(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, int16_t MinVersion, int16_t MaxVersion);\nvoid rd_kafka_mock_start_request_tracking(rd_kafka_mock_cluster_t *mcluster);\nvoid rd_kafka_mock_stop_request_tracking(rd_kafka_mock_cluster_t *mcluster);\ntypedef struct rd_kafka_mock_request_s rd_kafka_mock_request_t;\nvoid rd_kafka_mock_request_destroy(rd_kafka_mock_request_t *mreq);\nvoid rd_kafka_mock_request_destroy_array(rd_kafka_mock_request_t **mreqs, size_t mreq_cnt);\nint32_t rd_kafka_mock_request_id(rd_kafka_mock_request_t *mreq);\nint16_t rd_kafka_mock_request_api_key(rd_kafka_mock_request_t *mreq);\nint64_t rd_kafka_mock_request_timestamp(rd_kafka_mock_request_t *mreq);\nrd_kafka_mock_request_t **rd_kafka_mock_get_requests(rd_kafka_mock_cluster_t *mcluster, size_t *cntp);\nvoid rd_kafka_mock_clear_requests(rd_kafka_mock_cluster_t *mcluster);\nrd_kafka_resp_err_t rd_kafka_mock_telemetry_set_requested_metrics(rd_kafka_mock_cluster_t *mcluster, char **metrics, size_t metrics_cnt);\nrd_kafka_resp_err_t rd_kafka_mock_telemetry_set_push_interval(rd_kafka_mock_cluster_t *mcluster, int64_t push_interval_ms);\n'\n</code></pre> rdkafka.h, rdkafka_mock.h</p>"},{"location":"api/constants/#rd_kafka_version_33","title":"RD_KAFKA_VERSION","text":"<pre><code>public RD_KAFKA_VERSION = 33947903\n</code></pre> <p>librdkafka version </p> <p>Interpreted as hex <code>MM.mm.rr.xx</code>:</p> <ul> <li>MM = Major</li> <li>mm = minor</li> <li>rr = revision</li> <li>xx = pre-release id (0xff is the final release)</li> </ul> <p>E.g.: <code>0x000801ff</code> = 0.8.1</p> RemarksThis value should only be used during compile time, for runtime checks of version use rd_kafka_version()  <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_unsupported_compression_type_33","title":"RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE","text":"<pre><code>public RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76\n</code></pre> <p>Unsupported compression type </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_end_all_33","title":"RD_KAFKA_RESP_ERR_END_ALL","text":"<p><pre><code>public RD_KAFKA_RESP_ERR_END_ALL = 119\n</code></pre> enum rd_kafka_resp_err_t</p>"},{"location":"api/constants/#rd_kafka_admin_op__cnt_33","title":"RD_KAFKA_ADMIN_OP__CNT","text":"<pre><code>public RD_KAFKA_ADMIN_OP__CNT = 23\n</code></pre> <p>Number of ops defined </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe </li> </ul>"},{"location":"api/constants/#rd_kafka_resource__cnt_33","title":"RD_KAFKA_RESOURCE__CNT","text":"<pre><code>public RD_KAFKA_RESOURCE__CNT = 6\n</code></pre> <p>Number of resource types defined </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#acca83a66d7783ff7683ed2691cc907c9 </li> </ul>"},{"location":"api/constants/#rd_kafka_cdef_33","title":"RD_KAFKA_CDEF","text":"<p><pre><code>public RD_KAFKA_CDEF = 'typedef long int ssize_t;\ntypedef struct _IO_FILE FILE;\ntypedef long int mode_t;\ntypedef signed int int16_t;\ntypedef unsigned int uint16_t;\ntypedef signed int int32_t;\ntypedef signed long int int64_t;\nint rd_kafka_version(void);\nconst char *rd_kafka_version_str(void);\ntypedef enum rd_kafka_type_t {\n  RD_KAFKA_PRODUCER,\n  RD_KAFKA_CONSUMER,\n} rd_kafka_type_t;\ntypedef enum rd_kafka_timestamp_type_t {\n  RD_KAFKA_TIMESTAMP_NOT_AVAILABLE,\n  RD_KAFKA_TIMESTAMP_CREATE_TIME,\n  RD_KAFKA_TIMESTAMP_LOG_APPEND_TIME,\n} rd_kafka_timestamp_type_t;\nconst char *rd_kafka_get_debug_contexts(void);\ntypedef struct rd_kafka_s rd_kafka_t;\ntypedef struct rd_kafka_topic_s rd_kafka_topic_t;\ntypedef struct rd_kafka_conf_s rd_kafka_conf_t;\ntypedef struct rd_kafka_topic_conf_s rd_kafka_topic_conf_t;\ntypedef struct rd_kafka_queue_s rd_kafka_queue_t;\ntypedef struct rd_kafka_op_s rd_kafka_event_t;\ntypedef struct rd_kafka_topic_result_s rd_kafka_topic_result_t;\ntypedef struct rd_kafka_consumer_group_metadata_s rd_kafka_consumer_group_metadata_t;\ntypedef struct rd_kafka_error_s {\n  unsigned int code;\n  char *errstr;\n  unsigned char fatal;\n  unsigned char retriable;\n  unsigned char txn_requires_abort;\n} rd_kafka_error_t;\ntypedef struct rd_kafka_headers_s rd_kafka_headers_t;\ntypedef struct rd_kafka_group_result_s rd_kafka_group_result_t;\ntypedef struct rd_kafka_acl_result_s rd_kafka_acl_result_t;\ntypedef struct rd_kafka_Uuid_s rd_kafka_Uuid_t;\ntypedef struct rd_kafka_topic_partition_result_s rd_kafka_topic_partition_result_t;\ntypedef enum {\n  RD_KAFKA_RESP_ERR__BEGIN = (- 200),\n  RD_KAFKA_RESP_ERR__BAD_MSG = (- 199),\n  RD_KAFKA_RESP_ERR__BAD_COMPRESSION = (- 198),\n  RD_KAFKA_RESP_ERR__DESTROY = (- 197),\n  RD_KAFKA_RESP_ERR__FAIL = (- 196),\n  RD_KAFKA_RESP_ERR__TRANSPORT = (- 195),\n  RD_KAFKA_RESP_ERR__CRIT_SYS_RESOURCE = (- 194),\n  RD_KAFKA_RESP_ERR__RESOLVE = (- 193),\n  RD_KAFKA_RESP_ERR__MSG_TIMED_OUT = (- 192),\n  RD_KAFKA_RESP_ERR__PARTITION_EOF = (- 191),\n  RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION = (- 190),\n  RD_KAFKA_RESP_ERR__FS = (- 189),\n  RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC = (- 188),\n  RD_KAFKA_RESP_ERR__ALL_BROKERS_DOWN = (- 187),\n  RD_KAFKA_RESP_ERR__INVALID_ARG = (- 186),\n  RD_KAFKA_RESP_ERR__TIMED_OUT = (- 185),\n  RD_KAFKA_RESP_ERR__QUEUE_FULL = (- 184),\n  RD_KAFKA_RESP_ERR__ISR_INSUFF = (- 183),\n  RD_KAFKA_RESP_ERR__NODE_UPDATE = (- 182),\n  RD_KAFKA_RESP_ERR__SSL = (- 181),\n  RD_KAFKA_RESP_ERR__WAIT_COORD = (- 180),\n  RD_KAFKA_RESP_ERR__UNKNOWN_GROUP = (- 179),\n  RD_KAFKA_RESP_ERR__IN_PROGRESS = (- 178),\n  RD_KAFKA_RESP_ERR__PREV_IN_PROGRESS = (- 177),\n  RD_KAFKA_RESP_ERR__EXISTING_SUBSCRIPTION = (- 176),\n  RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS = (- 175),\n  RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS = (- 174),\n  RD_KAFKA_RESP_ERR__CONFLICT = (- 173),\n  RD_KAFKA_RESP_ERR__STATE = (- 172),\n  RD_KAFKA_RESP_ERR__UNKNOWN_PROTOCOL = (- 171),\n  RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED = (- 170),\n  RD_KAFKA_RESP_ERR__AUTHENTICATION = (- 169),\n  RD_KAFKA_RESP_ERR__NO_OFFSET = (- 168),\n  RD_KAFKA_RESP_ERR__OUTDATED = (- 167),\n  RD_KAFKA_RESP_ERR__TIMED_OUT_QUEUE = (- 166),\n  RD_KAFKA_RESP_ERR__UNSUPPORTED_FEATURE = (- 165),\n  RD_KAFKA_RESP_ERR__WAIT_CACHE = (- 164),\n  RD_KAFKA_RESP_ERR__INTR = (- 163),\n  RD_KAFKA_RESP_ERR__KEY_SERIALIZATION = (- 162),\n  RD_KAFKA_RESP_ERR__VALUE_SERIALIZATION = (- 161),\n  RD_KAFKA_RESP_ERR__KEY_DESERIALIZATION = (- 160),\n  RD_KAFKA_RESP_ERR__VALUE_DESERIALIZATION = (- 159),\n  RD_KAFKA_RESP_ERR__PARTIAL = (- 158),\n  RD_KAFKA_RESP_ERR__READ_ONLY = (- 157),\n  RD_KAFKA_RESP_ERR__NOENT = (- 156),\n  RD_KAFKA_RESP_ERR__UNDERFLOW = (- 155),\n  RD_KAFKA_RESP_ERR__INVALID_TYPE = (- 154),\n  RD_KAFKA_RESP_ERR__RETRY = (- 153),\n  RD_KAFKA_RESP_ERR__PURGE_QUEUE = (- 152),\n  RD_KAFKA_RESP_ERR__PURGE_INFLIGHT = (- 151),\n  RD_KAFKA_RESP_ERR__FATAL = (- 150),\n  RD_KAFKA_RESP_ERR__INCONSISTENT = (- 149),\n  RD_KAFKA_RESP_ERR__GAPLESS_GUARANTEE = (- 148),\n  RD_KAFKA_RESP_ERR__MAX_POLL_EXCEEDED = (- 147),\n  RD_KAFKA_RESP_ERR__UNKNOWN_BROKER = (- 146),\n  RD_KAFKA_RESP_ERR__NOT_CONFIGURED = (- 145),\n  RD_KAFKA_RESP_ERR__FENCED = (- 144),\n  RD_KAFKA_RESP_ERR__APPLICATION = (- 143),\n  RD_KAFKA_RESP_ERR__ASSIGNMENT_LOST = (- 142),\n  RD_KAFKA_RESP_ERR__NOOP = (- 141),\n  RD_KAFKA_RESP_ERR__AUTO_OFFSET_RESET = (- 140),\n  RD_KAFKA_RESP_ERR__LOG_TRUNCATION = (- 139),\n  RD_KAFKA_RESP_ERR__INVALID_DIFFERENT_RECORD = (- 138),\n  RD_KAFKA_RESP_ERR__END = (- 100),\n  RD_KAFKA_RESP_ERR_UNKNOWN = (- 1),\n  RD_KAFKA_RESP_ERR_NO_ERROR = 0,\n  RD_KAFKA_RESP_ERR_OFFSET_OUT_OF_RANGE = 1,\n  RD_KAFKA_RESP_ERR_INVALID_MSG = 2,\n  RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART = 3,\n  RD_KAFKA_RESP_ERR_INVALID_MSG_SIZE = 4,\n  RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE = 5,\n  RD_KAFKA_RESP_ERR_NOT_LEADER_FOR_PARTITION = 6,\n  RD_KAFKA_RESP_ERR_REQUEST_TIMED_OUT = 7,\n  RD_KAFKA_RESP_ERR_BROKER_NOT_AVAILABLE = 8,\n  RD_KAFKA_RESP_ERR_REPLICA_NOT_AVAILABLE = 9,\n  RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE = 10,\n  RD_KAFKA_RESP_ERR_STALE_CTRL_EPOCH = 11,\n  RD_KAFKA_RESP_ERR_OFFSET_METADATA_TOO_LARGE = 12,\n  RD_KAFKA_RESP_ERR_NETWORK_EXCEPTION = 13,\n  RD_KAFKA_RESP_ERR_COORDINATOR_LOAD_IN_PROGRESS = 14,\n  RD_KAFKA_RESP_ERR_COORDINATOR_NOT_AVAILABLE = 15,\n  RD_KAFKA_RESP_ERR_NOT_COORDINATOR = 16,\n  RD_KAFKA_RESP_ERR_TOPIC_EXCEPTION = 17,\n  RD_KAFKA_RESP_ERR_RECORD_LIST_TOO_LARGE = 18,\n  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS = 19,\n  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS_AFTER_APPEND = 20,\n  RD_KAFKA_RESP_ERR_INVALID_REQUIRED_ACKS = 21,\n  RD_KAFKA_RESP_ERR_ILLEGAL_GENERATION = 22,\n  RD_KAFKA_RESP_ERR_INCONSISTENT_GROUP_PROTOCOL = 23,\n  RD_KAFKA_RESP_ERR_INVALID_GROUP_ID = 24,\n  RD_KAFKA_RESP_ERR_UNKNOWN_MEMBER_ID = 25,\n  RD_KAFKA_RESP_ERR_INVALID_SESSION_TIMEOUT = 26,\n  RD_KAFKA_RESP_ERR_REBALANCE_IN_PROGRESS = 27,\n  RD_KAFKA_RESP_ERR_INVALID_COMMIT_OFFSET_SIZE = 28,\n  RD_KAFKA_RESP_ERR_TOPIC_AUTHORIZATION_FAILED = 29,\n  RD_KAFKA_RESP_ERR_GROUP_AUTHORIZATION_FAILED = 30,\n  RD_KAFKA_RESP_ERR_CLUSTER_AUTHORIZATION_FAILED = 31,\n  RD_KAFKA_RESP_ERR_INVALID_TIMESTAMP = 32,\n  RD_KAFKA_RESP_ERR_UNSUPPORTED_SASL_MECHANISM = 33,\n  RD_KAFKA_RESP_ERR_ILLEGAL_SASL_STATE = 34,\n  RD_KAFKA_RESP_ERR_UNSUPPORTED_VERSION = 35,\n  RD_KAFKA_RESP_ERR_TOPIC_ALREADY_EXISTS = 36,\n  RD_KAFKA_RESP_ERR_INVALID_PARTITIONS = 37,\n  RD_KAFKA_RESP_ERR_INVALID_REPLICATION_FACTOR = 38,\n  RD_KAFKA_RESP_ERR_INVALID_REPLICA_ASSIGNMENT = 39,\n  RD_KAFKA_RESP_ERR_INVALID_CONFIG = 40,\n  RD_KAFKA_RESP_ERR_NOT_CONTROLLER = 41,\n  RD_KAFKA_RESP_ERR_INVALID_REQUEST = 42,\n  RD_KAFKA_RESP_ERR_UNSUPPORTED_FOR_MESSAGE_FORMAT = 43,\n  RD_KAFKA_RESP_ERR_POLICY_VIOLATION = 44,\n  RD_KAFKA_RESP_ERR_OUT_OF_ORDER_SEQUENCE_NUMBER = 45,\n  RD_KAFKA_RESP_ERR_DUPLICATE_SEQUENCE_NUMBER = 46,\n  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_EPOCH = 47,\n  RD_KAFKA_RESP_ERR_INVALID_TXN_STATE = 48,\n  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_ID_MAPPING = 49,\n  RD_KAFKA_RESP_ERR_INVALID_TRANSACTION_TIMEOUT = 50,\n  RD_KAFKA_RESP_ERR_CONCURRENT_TRANSACTIONS = 51,\n  RD_KAFKA_RESP_ERR_TRANSACTION_COORDINATOR_FENCED = 52,\n  RD_KAFKA_RESP_ERR_TRANSACTIONAL_ID_AUTHORIZATION_FAILED = 53,\n  RD_KAFKA_RESP_ERR_SECURITY_DISABLED = 54,\n  RD_KAFKA_RESP_ERR_OPERATION_NOT_ATTEMPTED = 55,\n  RD_KAFKA_RESP_ERR_KAFKA_STORAGE_ERROR = 56,\n  RD_KAFKA_RESP_ERR_LOG_DIR_NOT_FOUND = 57,\n  RD_KAFKA_RESP_ERR_SASL_AUTHENTICATION_FAILED = 58,\n  RD_KAFKA_RESP_ERR_UNKNOWN_PRODUCER_ID = 59,\n  RD_KAFKA_RESP_ERR_REASSIGNMENT_IN_PROGRESS = 60,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTH_DISABLED = 61,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_NOT_FOUND = 62,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_OWNER_MISMATCH = 63,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_REQUEST_NOT_ALLOWED = 64,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTHORIZATION_FAILED = 65,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_EXPIRED = 66,\n  RD_KAFKA_RESP_ERR_INVALID_PRINCIPAL_TYPE = 67,\n  RD_KAFKA_RESP_ERR_NON_EMPTY_GROUP = 68,\n  RD_KAFKA_RESP_ERR_GROUP_ID_NOT_FOUND = 69,\n  RD_KAFKA_RESP_ERR_FETCH_SESSION_ID_NOT_FOUND = 70,\n  RD_KAFKA_RESP_ERR_INVALID_FETCH_SESSION_EPOCH = 71,\n  RD_KAFKA_RESP_ERR_LISTENER_NOT_FOUND = 72,\n  RD_KAFKA_RESP_ERR_TOPIC_DELETION_DISABLED = 73,\n  RD_KAFKA_RESP_ERR_FENCED_LEADER_EPOCH = 74,\n  RD_KAFKA_RESP_ERR_UNKNOWN_LEADER_EPOCH = 75,\n  RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76,\n  RD_KAFKA_RESP_ERR_STALE_BROKER_EPOCH = 77,\n  RD_KAFKA_RESP_ERR_OFFSET_NOT_AVAILABLE = 78,\n  RD_KAFKA_RESP_ERR_MEMBER_ID_REQUIRED = 79,\n  RD_KAFKA_RESP_ERR_PREFERRED_LEADER_NOT_AVAILABLE = 80,\n  RD_KAFKA_RESP_ERR_GROUP_MAX_SIZE_REACHED = 81,\n  RD_KAFKA_RESP_ERR_FENCED_INSTANCE_ID = 82,\n  RD_KAFKA_RESP_ERR_ELIGIBLE_LEADERS_NOT_AVAILABLE = 83,\n  RD_KAFKA_RESP_ERR_ELECTION_NOT_NEEDED = 84,\n  RD_KAFKA_RESP_ERR_NO_REASSIGNMENT_IN_PROGRESS = 85,\n  RD_KAFKA_RESP_ERR_GROUP_SUBSCRIBED_TO_TOPIC = 86,\n  RD_KAFKA_RESP_ERR_INVALID_RECORD = 87,\n  RD_KAFKA_RESP_ERR_UNSTABLE_OFFSET_COMMIT = 88,\n  RD_KAFKA_RESP_ERR_THROTTLING_QUOTA_EXCEEDED = 89,\n  RD_KAFKA_RESP_ERR_PRODUCER_FENCED = 90,\n  RD_KAFKA_RESP_ERR_RESOURCE_NOT_FOUND = 91,\n  RD_KAFKA_RESP_ERR_DUPLICATE_RESOURCE = 92,\n  RD_KAFKA_RESP_ERR_UNACCEPTABLE_CREDENTIAL = 93,\n  RD_KAFKA_RESP_ERR_INCONSISTENT_VOTER_SET = 94,\n  RD_KAFKA_RESP_ERR_INVALID_UPDATE_VERSION = 95,\n  RD_KAFKA_RESP_ERR_FEATURE_UPDATE_FAILED = 96,\n  RD_KAFKA_RESP_ERR_PRINCIPAL_DESERIALIZATION_FAILURE = 97,\n  RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_ID = 100,\n  RD_KAFKA_RESP_ERR_FENCED_MEMBER_EPOCH = 110,\n  RD_KAFKA_RESP_ERR_UNRELEASED_INSTANCE_ID = 111,\n  RD_KAFKA_RESP_ERR_UNSUPPORTED_ASSIGNOR = 112,\n  RD_KAFKA_RESP_ERR_STALE_MEMBER_EPOCH = 113,\n  RD_KAFKA_RESP_ERR_UNKNOWN_SUBSCRIPTION_ID = 117,\n  RD_KAFKA_RESP_ERR_TELEMETRY_TOO_LARGE = 118,\n  RD_KAFKA_RESP_ERR_END_ALL,\n} rd_kafka_resp_err_t;\nstruct rd_kafka_err_desc {\n  rd_kafka_resp_err_t code;\n  char *name;\n  char *desc;\n};\nvoid rd_kafka_get_err_descs(const struct rd_kafka_err_desc **errdescs, size_t *cntp);\nconst char *rd_kafka_err2str(rd_kafka_resp_err_t err);\nconst char *rd_kafka_err2name(rd_kafka_resp_err_t err);\nrd_kafka_resp_err_t rd_kafka_last_error(void);\nrd_kafka_resp_err_t rd_kafka_errno2err(int errnox);\nint rd_kafka_errno(void);\nrd_kafka_resp_err_t rd_kafka_fatal_error(rd_kafka_t *rk, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_test_fatal_error(rd_kafka_t *rk, rd_kafka_resp_err_t err, const char *reason);\nrd_kafka_resp_err_t rd_kafka_error_code(const rd_kafka_error_t *error);\nconst char *rd_kafka_error_name(const rd_kafka_error_t *error);\nconst char *rd_kafka_error_string(const rd_kafka_error_t *error);\nint rd_kafka_error_is_fatal(const rd_kafka_error_t *error);\nint rd_kafka_error_is_retriable(const rd_kafka_error_t *error);\nint rd_kafka_error_txn_requires_abort(const rd_kafka_error_t *error);\nvoid rd_kafka_error_destroy(rd_kafka_error_t *error);\nrd_kafka_error_t *rd_kafka_error_new(rd_kafka_resp_err_t code, const char *fmt, ...);\ntypedef struct rd_kafka_topic_partition_s {\n  char *topic;\n  int32_t partition;\n  int64_t offset;\n  void *metadata;\n  size_t metadata_size;\n  void *opaque;\n  rd_kafka_resp_err_t err;\n  void *_private;\n} rd_kafka_topic_partition_t;\nvoid rd_kafka_topic_partition_destroy(rd_kafka_topic_partition_t *rktpar);\nvoid rd_kafka_topic_partition_set_leader_epoch(rd_kafka_topic_partition_t *rktpar, int32_t leader_epoch);\nint32_t rd_kafka_topic_partition_get_leader_epoch(const rd_kafka_topic_partition_t *rktpar);\ntypedef struct rd_kafka_topic_partition_list_s {\n  int cnt;\n  int size;\n  rd_kafka_topic_partition_t *elems;\n} rd_kafka_topic_partition_list_t;\nrd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_new(int size);\nvoid rd_kafka_topic_partition_list_destroy(rd_kafka_topic_partition_list_t *rkparlist);\nrd_kafka_topic_partition_t *rd_kafka_topic_partition_list_add(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);\nvoid rd_kafka_topic_partition_list_add_range(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t start, int32_t stop);\nint rd_kafka_topic_partition_list_del(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);\nint rd_kafka_topic_partition_list_del_by_idx(rd_kafka_topic_partition_list_t *rktparlist, int idx);\nrd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_copy(const rd_kafka_topic_partition_list_t *src);\nrd_kafka_resp_err_t rd_kafka_topic_partition_list_set_offset(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition, int64_t offset);\nrd_kafka_topic_partition_t *rd_kafka_topic_partition_list_find(const rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);\nvoid rd_kafka_topic_partition_list_sort(rd_kafka_topic_partition_list_t *rktparlist, int (*cmp)(const void *a, const void *b, void *cmp_opaque), void *cmp_opaque);\ntypedef enum rd_kafka_vtype_t {\n  RD_KAFKA_VTYPE_END,\n  RD_KAFKA_VTYPE_TOPIC,\n  RD_KAFKA_VTYPE_RKT,\n  RD_KAFKA_VTYPE_PARTITION,\n  RD_KAFKA_VTYPE_VALUE,\n  RD_KAFKA_VTYPE_KEY,\n  RD_KAFKA_VTYPE_OPAQUE,\n  RD_KAFKA_VTYPE_MSGFLAGS,\n  RD_KAFKA_VTYPE_TIMESTAMP,\n  RD_KAFKA_VTYPE_HEADER,\n  RD_KAFKA_VTYPE_HEADERS,\n} rd_kafka_vtype_t;\ntypedef struct rd_kafka_vu_s {\n  rd_kafka_vtype_t vtype;\n  union {\n    char *cstr;\n    rd_kafka_topic_t *rkt;\n    int i;\n    int32_t i32;\n    int64_t i64;\n    struct {\n      void *ptr;\n      size_t size;\n    } mem;\n    struct {\n      char *name;\n      void *val;\n      ssize_t size;\n    } header;\n    rd_kafka_headers_t *headers;\n    void *ptr;\n    char _pad[64];\n  } u;\n} rd_kafka_vu_t;\nrd_kafka_headers_t *rd_kafka_headers_new(size_t initial_count);\nvoid rd_kafka_headers_destroy(rd_kafka_headers_t *hdrs);\nrd_kafka_headers_t *rd_kafka_headers_copy(const rd_kafka_headers_t *src);\nrd_kafka_resp_err_t rd_kafka_header_add(rd_kafka_headers_t *hdrs, const char *name, ssize_t name_size, const void *value, ssize_t value_size);\nrd_kafka_resp_err_t rd_kafka_header_remove(rd_kafka_headers_t *hdrs, const char *name);\nrd_kafka_resp_err_t rd_kafka_header_get_last(const rd_kafka_headers_t *hdrs, const char *name, const void **valuep, size_t *sizep);\nrd_kafka_resp_err_t rd_kafka_header_get(const rd_kafka_headers_t *hdrs, size_t idx, const char *name, const void **valuep, size_t *sizep);\nrd_kafka_resp_err_t rd_kafka_header_get_all(const rd_kafka_headers_t *hdrs, size_t idx, const char **namep, const void **valuep, size_t *sizep);\ntypedef struct rd_kafka_message_s {\n  rd_kafka_resp_err_t err;\n  rd_kafka_topic_t *rkt;\n  int32_t partition;\n  void *payload;\n  size_t len;\n  void *key;\n  size_t key_len;\n  int64_t offset;\n  void *_private;\n} rd_kafka_message_t;\nvoid rd_kafka_message_destroy(rd_kafka_message_t *rkmessage);\nconst char *rd_kafka_message_errstr(const rd_kafka_message_t *rkmessage);\nconst char *rd_kafka_message_produce_errstr(const rd_kafka_message_t *rkmessage);\nint64_t rd_kafka_message_timestamp(const rd_kafka_message_t *rkmessage, rd_kafka_timestamp_type_t *tstype);\nint64_t rd_kafka_message_latency(const rd_kafka_message_t *rkmessage);\nint32_t rd_kafka_message_broker_id(const rd_kafka_message_t *rkmessage);\nrd_kafka_resp_err_t rd_kafka_message_headers(const rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);\nrd_kafka_resp_err_t rd_kafka_message_detach_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);\nvoid rd_kafka_message_set_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t *hdrs);\nsize_t rd_kafka_header_cnt(const rd_kafka_headers_t *hdrs);\ntypedef enum {\n  RD_KAFKA_MSG_STATUS_NOT_PERSISTED = 0,\n  RD_KAFKA_MSG_STATUS_POSSIBLY_PERSISTED = 1,\n  RD_KAFKA_MSG_STATUS_PERSISTED = 2,\n} rd_kafka_msg_status_t;\nrd_kafka_msg_status_t rd_kafka_message_status(const rd_kafka_message_t *rkmessage);\nint32_t rd_kafka_message_leader_epoch(const rd_kafka_message_t *rkmessage);\nconst char *rd_kafka_Uuid_base64str(const rd_kafka_Uuid_t *uuid);\nint64_t rd_kafka_Uuid_least_significant_bits(const rd_kafka_Uuid_t *uuid);\nint64_t rd_kafka_Uuid_most_significant_bits(const rd_kafka_Uuid_t *uuid);\nrd_kafka_Uuid_t *rd_kafka_Uuid_new(int64_t most_significant_bits, int64_t least_significant_bits);\nrd_kafka_Uuid_t *rd_kafka_Uuid_copy(const rd_kafka_Uuid_t *uuid);\nvoid rd_kafka_Uuid_destroy(rd_kafka_Uuid_t *uuid);\ntypedef enum {\n  RD_KAFKA_CONF_UNKNOWN = (- 2),\n  RD_KAFKA_CONF_INVALID = (- 1),\n  RD_KAFKA_CONF_OK = 0,\n} rd_kafka_conf_res_t;\nrd_kafka_conf_t *rd_kafka_conf_new(void);\nvoid rd_kafka_conf_destroy(rd_kafka_conf_t *conf);\nrd_kafka_conf_t *rd_kafka_conf_dup(const rd_kafka_conf_t *conf);\nrd_kafka_conf_t *rd_kafka_conf_dup_filter(const rd_kafka_conf_t *conf, size_t filter_cnt, const char **filter);\nconst rd_kafka_conf_t *rd_kafka_conf(rd_kafka_t *rk);\nrd_kafka_conf_res_t rd_kafka_conf_set(rd_kafka_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);\nvoid rd_kafka_conf_set_events(rd_kafka_conf_t *conf, int events);\nvoid rd_kafka_conf_set_background_event_cb(rd_kafka_conf_t *conf, void (*event_cb)(rd_kafka_t *rk, rd_kafka_event_t *rkev, void *opaque));\nvoid rd_kafka_conf_set_dr_cb(rd_kafka_conf_t *conf, void (*dr_cb)(rd_kafka_t *rk, void *payload, size_t len, rd_kafka_resp_err_t err, void *opaque, void *msg_opaque));\nvoid rd_kafka_conf_set_dr_msg_cb(rd_kafka_conf_t *conf, void (*dr_msg_cb)(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, void *opaque));\nvoid rd_kafka_conf_set_consume_cb(rd_kafka_conf_t *conf, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *opaque));\nvoid rd_kafka_conf_set_rebalance_cb(rd_kafka_conf_t *conf, void (*rebalance_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *partitions, void *opaque));\nvoid rd_kafka_conf_set_offset_commit_cb(rd_kafka_conf_t *conf, void (*offset_commit_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *opaque));\nvoid rd_kafka_conf_set_error_cb(rd_kafka_conf_t *conf, void (*error_cb)(rd_kafka_t *rk, int err, const char *reason, void *opaque));\nvoid rd_kafka_conf_set_throttle_cb(rd_kafka_conf_t *conf, void (*throttle_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int throttle_time_ms, void *opaque));\nvoid rd_kafka_conf_set_log_cb(rd_kafka_conf_t *conf, void (*log_cb)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));\nvoid rd_kafka_conf_set_stats_cb(rd_kafka_conf_t *conf, int (*stats_cb)(rd_kafka_t *rk, char *json, size_t json_len, void *opaque));\nvoid rd_kafka_conf_set_oauthbearer_token_refresh_cb(rd_kafka_conf_t *conf, void (*oauthbearer_token_refresh_cb)(rd_kafka_t *rk, const char *oauthbearer_config, void *opaque));\nvoid rd_kafka_conf_enable_sasl_queue(rd_kafka_conf_t *conf, int enable);\nvoid rd_kafka_conf_set_socket_cb(rd_kafka_conf_t *conf, int (*socket_cb)(int domain, int type, int protocol, void *opaque));\nvoid rd_kafka_conf_set_connect_cb(rd_kafka_conf_t *conf, int (*connect_cb)(int sockfd, const struct sockaddr *addr, int addrlen, const char *id, void *opaque));\nvoid rd_kafka_conf_set_closesocket_cb(rd_kafka_conf_t *conf, int (*closesocket_cb)(int sockfd, void *opaque));\nstruct addrinfo;\nvoid rd_kafka_conf_set_resolve_cb(rd_kafka_conf_t *conf, int (*resolve_cb)(const char *node, const char *service, const struct addrinfo *hints, struct addrinfo **res, void *opaque));\nrd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert_verify_cb(rd_kafka_conf_t *conf, int (*ssl_cert_verify_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int *x509_error, int depth, const char *buf, size_t size, char *errstr, size_t errstr_size, void *opaque));\ntypedef enum rd_kafka_cert_type_t {\n  RD_KAFKA_CERT_PUBLIC_KEY,\n  RD_KAFKA_CERT_PRIVATE_KEY,\n  RD_KAFKA_CERT_CA,\n  RD_KAFKA_CERT__CNT,\n} rd_kafka_cert_type_t;\ntypedef enum rd_kafka_cert_enc_t {\n  RD_KAFKA_CERT_ENC_PKCS12,\n  RD_KAFKA_CERT_ENC_DER,\n  RD_KAFKA_CERT_ENC_PEM,\n  RD_KAFKA_CERT_ENC__CNT,\n} rd_kafka_cert_enc_t;\nrd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert(rd_kafka_conf_t *conf, rd_kafka_cert_type_t cert_type, rd_kafka_cert_enc_t cert_enc, const void *buffer, size_t size, char *errstr, size_t errstr_size);\nvoid rd_kafka_conf_set_engine_callback_data(rd_kafka_conf_t *conf, void *callback_data);\nvoid rd_kafka_conf_set_opaque(rd_kafka_conf_t *conf, void *opaque);\nvoid *rd_kafka_opaque(const rd_kafka_t *rk);\nvoid rd_kafka_conf_set_default_topic_conf(rd_kafka_conf_t *conf, rd_kafka_topic_conf_t *tconf);\nrd_kafka_topic_conf_t *rd_kafka_conf_get_default_topic_conf(rd_kafka_conf_t *conf);\nrd_kafka_conf_res_t rd_kafka_conf_get(const rd_kafka_conf_t *conf, const char *name, char *dest, size_t *dest_size);\nrd_kafka_conf_res_t rd_kafka_topic_conf_get(const rd_kafka_topic_conf_t *conf, const char *name, char *dest, size_t *dest_size);\nconst char **rd_kafka_conf_dump(rd_kafka_conf_t *conf, size_t *cntp);\nconst char **rd_kafka_topic_conf_dump(rd_kafka_topic_conf_t *conf, size_t *cntp);\nvoid rd_kafka_conf_dump_free(const char **arr, size_t cnt);\nvoid rd_kafka_conf_properties_show(FILE *fp);\nrd_kafka_topic_conf_t *rd_kafka_topic_conf_new(void);\nrd_kafka_topic_conf_t *rd_kafka_topic_conf_dup(const rd_kafka_topic_conf_t *conf);\nrd_kafka_topic_conf_t *rd_kafka_default_topic_conf_dup(rd_kafka_t *rk);\nvoid rd_kafka_topic_conf_destroy(rd_kafka_topic_conf_t *topic_conf);\nrd_kafka_conf_res_t rd_kafka_topic_conf_set(rd_kafka_topic_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);\nvoid rd_kafka_topic_conf_set_opaque(rd_kafka_topic_conf_t *conf, void *rkt_opaque);\nvoid rd_kafka_topic_conf_set_partitioner_cb(rd_kafka_topic_conf_t *topic_conf, int32_t (*partitioner)(const rd_kafka_topic_t *rkt, const void *keydata, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque));\nvoid rd_kafka_topic_conf_set_msg_order_cmp(rd_kafka_topic_conf_t *topic_conf, int (*msg_order_cmp)(const rd_kafka_message_t *a, const rd_kafka_message_t *b));\nint rd_kafka_topic_partition_available(const rd_kafka_topic_t *rkt, int32_t partition);\nint32_t rd_kafka_msg_partitioner_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_consistent(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_consistent_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_murmur2(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_murmur2_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_fnv1a(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_fnv1a_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nrd_kafka_t *rd_kafka_new(rd_kafka_type_t type, rd_kafka_conf_t *conf, char *errstr, size_t errstr_size);\nvoid rd_kafka_destroy(rd_kafka_t *rk);\nvoid rd_kafka_destroy_flags(rd_kafka_t *rk, int flags);\nconst char *rd_kafka_name(const rd_kafka_t *rk);\nrd_kafka_type_t rd_kafka_type(const rd_kafka_t *rk);\nchar *rd_kafka_memberid(const rd_kafka_t *rk);\nchar *rd_kafka_clusterid(rd_kafka_t *rk, int timeout_ms);\nint32_t rd_kafka_controllerid(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_topic_t *rd_kafka_topic_new(rd_kafka_t *rk, const char *topic, rd_kafka_topic_conf_t *conf);\nvoid rd_kafka_topic_destroy(rd_kafka_topic_t *rkt);\nconst char *rd_kafka_topic_name(const rd_kafka_topic_t *rkt);\nvoid *rd_kafka_topic_opaque(const rd_kafka_topic_t *rkt);\nint rd_kafka_poll(rd_kafka_t *rk, int timeout_ms);\nvoid rd_kafka_yield(rd_kafka_t *rk);\nrd_kafka_resp_err_t rd_kafka_pause_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_resp_err_t rd_kafka_resume_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_resp_err_t rd_kafka_query_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high, int timeout_ms);\nrd_kafka_resp_err_t rd_kafka_get_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high);\nrd_kafka_resp_err_t rd_kafka_offsets_for_times(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets, int timeout_ms);\nvoid *rd_kafka_mem_calloc(rd_kafka_t *rk, size_t num, size_t size);\nvoid *rd_kafka_mem_malloc(rd_kafka_t *rk, size_t size);\nvoid rd_kafka_mem_free(rd_kafka_t *rk, void *ptr);\nrd_kafka_queue_t *rd_kafka_queue_new(rd_kafka_t *rk);\nvoid rd_kafka_queue_destroy(rd_kafka_queue_t *rkqu);\nrd_kafka_queue_t *rd_kafka_queue_get_main(rd_kafka_t *rk);\nrd_kafka_queue_t *rd_kafka_queue_get_sasl(rd_kafka_t *rk);\nrd_kafka_error_t *rd_kafka_sasl_background_callbacks_enable(rd_kafka_t *rk);\nrd_kafka_error_t *rd_kafka_sasl_set_credentials(rd_kafka_t *rk, const char *username, const char *password);\nrd_kafka_queue_t *rd_kafka_queue_get_consumer(rd_kafka_t *rk);\nrd_kafka_queue_t *rd_kafka_queue_get_partition(rd_kafka_t *rk, const char *topic, int32_t partition);\nrd_kafka_queue_t *rd_kafka_queue_get_background(rd_kafka_t *rk);\nvoid rd_kafka_queue_forward(rd_kafka_queue_t *src, rd_kafka_queue_t *dst);\nrd_kafka_resp_err_t rd_kafka_set_log_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu);\nsize_t rd_kafka_queue_length(rd_kafka_queue_t *rkqu);\nvoid rd_kafka_queue_io_event_enable(rd_kafka_queue_t *rkqu, int fd, const void *payload, size_t size);\nvoid rd_kafka_queue_cb_event_enable(rd_kafka_queue_t *rkqu, void (*event_cb)(rd_kafka_t *rk, void *qev_opaque), void *qev_opaque);\nvoid rd_kafka_queue_yield(rd_kafka_queue_t *rkqu);\nint rd_kafka_consume_start(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);\nint rd_kafka_consume_start_queue(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, rd_kafka_queue_t *rkqu);\nint rd_kafka_consume_stop(rd_kafka_topic_t *rkt, int32_t partition);\nrd_kafka_resp_err_t rd_kafka_seek(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, int timeout_ms);\nrd_kafka_error_t *rd_kafka_seek_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms);\nrd_kafka_message_t *rd_kafka_consume(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms);\nssize_t rd_kafka_consume_batch(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);\nint rd_kafka_consume_callback(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);\nrd_kafka_message_t *rd_kafka_consume_queue(rd_kafka_queue_t *rkqu, int timeout_ms);\nssize_t rd_kafka_consume_batch_queue(rd_kafka_queue_t *rkqu, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);\nint rd_kafka_consume_callback_queue(rd_kafka_queue_t *rkqu, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);\nrd_kafka_resp_err_t rd_kafka_offset_store(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);\nrd_kafka_resp_err_t rd_kafka_offsets_store(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets);\nrd_kafka_error_t *rd_kafka_offset_store_message(rd_kafka_message_t *rkmessage);\nrd_kafka_resp_err_t rd_kafka_subscribe(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *topics);\nrd_kafka_resp_err_t rd_kafka_unsubscribe(rd_kafka_t *rk);\nrd_kafka_resp_err_t rd_kafka_subscription(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **topics);\nrd_kafka_message_t *rd_kafka_consumer_poll(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_resp_err_t rd_kafka_consumer_close(rd_kafka_t *rk);\nrd_kafka_error_t *rd_kafka_consumer_close_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu);\nint rd_kafka_consumer_closed(rd_kafka_t *rk);\nrd_kafka_error_t *rd_kafka_incremental_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_error_t *rd_kafka_incremental_unassign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);\nconst char *rd_kafka_rebalance_protocol(rd_kafka_t *rk);\nrd_kafka_resp_err_t rd_kafka_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_resp_err_t rd_kafka_assignment(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **partitions);\nint rd_kafka_assignment_lost(rd_kafka_t *rk);\nrd_kafka_resp_err_t rd_kafka_commit(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, int async);\nrd_kafka_resp_err_t rd_kafka_commit_message(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, int async);\nrd_kafka_resp_err_t rd_kafka_commit_queue(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_queue_t *rkqu, void (*cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *commit_opaque), void *commit_opaque);\nrd_kafka_resp_err_t rd_kafka_committed(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms);\nrd_kafka_resp_err_t rd_kafka_position(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata(rd_kafka_t *rk);\nrd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata_new(const char *group_id);\nrd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata_new_with_genid(const char *group_id, int32_t generation_id, const char *member_id, const char *group_instance_id);\nconst char *rd_kafka_consumer_group_metadata_member_id(const rd_kafka_consumer_group_metadata_t *group_metadata);\nvoid rd_kafka_consumer_group_metadata_destroy(rd_kafka_consumer_group_metadata_t *);\nrd_kafka_error_t *rd_kafka_consumer_group_metadata_write(const rd_kafka_consumer_group_metadata_t *cgmd, void **bufferp, size_t *sizep);\nrd_kafka_error_t *rd_kafka_consumer_group_metadata_read(rd_kafka_consumer_group_metadata_t **cgmdp, const void *buffer, size_t size);\nint rd_kafka_produce(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, void *payload, size_t len, const void *key, size_t keylen, void *msg_opaque);\nrd_kafka_resp_err_t rd_kafka_producev(rd_kafka_t *rk, ...);\nrd_kafka_error_t *rd_kafka_produceva(rd_kafka_t *rk, const rd_kafka_vu_t *vus, size_t cnt);\nint rd_kafka_produce_batch(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, rd_kafka_message_t *rkmessages, int message_cnt);\nrd_kafka_resp_err_t rd_kafka_flush(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_resp_err_t rd_kafka_purge(rd_kafka_t *rk, int purge_flags);\ntypedef struct rd_kafka_metadata_broker {\n  int32_t id;\n  char *host;\n  int port;\n} rd_kafka_metadata_broker_t;\ntypedef struct rd_kafka_metadata_partition {\n  int32_t id;\n  rd_kafka_resp_err_t err;\n  int32_t leader;\n  int replica_cnt;\n  int32_t *replicas;\n  int isr_cnt;\n  int32_t *isrs;\n} rd_kafka_metadata_partition_t;\ntypedef struct rd_kafka_metadata_topic {\n  char *topic;\n  int partition_cnt;\n  struct rd_kafka_metadata_partition *partitions;\n  rd_kafka_resp_err_t err;\n} rd_kafka_metadata_topic_t;\ntypedef struct rd_kafka_metadata {\n  int broker_cnt;\n  struct rd_kafka_metadata_broker *brokers;\n  int topic_cnt;\n  struct rd_kafka_metadata_topic *topics;\n  int32_t orig_broker_id;\n  char *orig_broker_name;\n} rd_kafka_metadata_t;\nrd_kafka_resp_err_t rd_kafka_metadata(rd_kafka_t *rk, int all_topics, rd_kafka_topic_t *only_rkt, const struct rd_kafka_metadata **metadatap, int timeout_ms);\nvoid rd_kafka_metadata_destroy(const struct rd_kafka_metadata *metadata);\ntypedef struct rd_kafka_Node_s rd_kafka_Node_t;\nint rd_kafka_Node_id(const rd_kafka_Node_t *node);\nconst char *rd_kafka_Node_host(const rd_kafka_Node_t *node);\nuint16_t rd_kafka_Node_port(const rd_kafka_Node_t *node);\nconst char *rd_kafka_Node_rack(const rd_kafka_Node_t *node);\nstruct rd_kafka_group_member_info {\n  char *member_id;\n  char *client_id;\n  char *client_host;\n  void *member_metadata;\n  int member_metadata_size;\n  void *member_assignment;\n  int member_assignment_size;\n};\ntypedef enum {\n  RD_KAFKA_CONSUMER_GROUP_STATE_UNKNOWN = 0,\n  RD_KAFKA_CONSUMER_GROUP_STATE_PREPARING_REBALANCE = 1,\n  RD_KAFKA_CONSUMER_GROUP_STATE_COMPLETING_REBALANCE = 2,\n  RD_KAFKA_CONSUMER_GROUP_STATE_STABLE = 3,\n  RD_KAFKA_CONSUMER_GROUP_STATE_DEAD = 4,\n  RD_KAFKA_CONSUMER_GROUP_STATE_EMPTY = 5,\n  RD_KAFKA_CONSUMER_GROUP_STATE__CNT,\n} rd_kafka_consumer_group_state_t;\ntypedef enum {\n  RD_KAFKA_CONSUMER_GROUP_TYPE_UNKNOWN = 0,\n  RD_KAFKA_CONSUMER_GROUP_TYPE_CONSUMER = 1,\n  RD_KAFKA_CONSUMER_GROUP_TYPE_CLASSIC = 2,\n  RD_KAFKA_CONSUMER_GROUP_TYPE__CNT,\n} rd_kafka_consumer_group_type_t;\nstruct rd_kafka_group_info {\n  struct rd_kafka_metadata_broker broker;\n  char *group;\n  rd_kafka_resp_err_t err;\n  char *state;\n  char *protocol_type;\n  char *protocol;\n  struct rd_kafka_group_member_info *members;\n  int member_cnt;\n};\nstruct rd_kafka_group_list {\n  struct rd_kafka_group_info *groups;\n  int group_cnt;\n};\nrd_kafka_resp_err_t rd_kafka_list_groups(rd_kafka_t *rk, const char *group, const struct rd_kafka_group_list **grplistp, int timeout_ms);\nconst char *rd_kafka_consumer_group_state_name(rd_kafka_consumer_group_state_t state);\nrd_kafka_consumer_group_state_t rd_kafka_consumer_group_state_code(const char *name);\nconst char *rd_kafka_consumer_group_type_name(rd_kafka_consumer_group_type_t type);\nrd_kafka_consumer_group_type_t rd_kafka_consumer_group_type_code(const char *name);\nvoid rd_kafka_group_list_destroy(const struct rd_kafka_group_list *grplist);\nint rd_kafka_brokers_add(rd_kafka_t *rk, const char *brokerlist);\nvoid rd_kafka_set_logger(rd_kafka_t *rk, void (*func)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));\nvoid rd_kafka_set_log_level(rd_kafka_t *rk, int level);\nvoid rd_kafka_log_print(const rd_kafka_t *rk, int level, const char *fac, const char *buf);\nvoid rd_kafka_log_syslog(const rd_kafka_t *rk, int level, const char *fac, const char *buf);\nint rd_kafka_outq_len(rd_kafka_t *rk);\nvoid rd_kafka_dump(FILE *fp, rd_kafka_t *rk);\nint rd_kafka_thread_cnt(void);\ntypedef enum rd_kafka_thread_type_t {\n  RD_KAFKA_THREAD_MAIN,\n  RD_KAFKA_THREAD_BACKGROUND,\n  RD_KAFKA_THREAD_BROKER,\n} rd_kafka_thread_type_t;\nint rd_kafka_wait_destroyed(int timeout_ms);\nint rd_kafka_unittest(void);\nrd_kafka_resp_err_t rd_kafka_poll_set_consumer(rd_kafka_t *rk);\ntypedef int rd_kafka_event_type_t;\nrd_kafka_event_type_t rd_kafka_event_type(const rd_kafka_event_t *rkev);\nconst char *rd_kafka_event_name(const rd_kafka_event_t *rkev);\nvoid rd_kafka_event_destroy(rd_kafka_event_t *rkev);\nconst rd_kafka_message_t *rd_kafka_event_message_next(rd_kafka_event_t *rkev);\nsize_t rd_kafka_event_message_array(rd_kafka_event_t *rkev, const rd_kafka_message_t **rkmessages, size_t size);\nsize_t rd_kafka_event_message_count(rd_kafka_event_t *rkev);\nconst char *rd_kafka_event_config_string(rd_kafka_event_t *rkev);\nrd_kafka_resp_err_t rd_kafka_event_error(rd_kafka_event_t *rkev);\nconst char *rd_kafka_event_error_string(rd_kafka_event_t *rkev);\nint rd_kafka_event_error_is_fatal(rd_kafka_event_t *rkev);\nvoid *rd_kafka_event_opaque(rd_kafka_event_t *rkev);\nint rd_kafka_event_log(rd_kafka_event_t *rkev, const char **fac, const char **str, int *level);\nint rd_kafka_event_debug_contexts(rd_kafka_event_t *rkev, char *dst, size_t dstsize);\nconst char *rd_kafka_event_stats(rd_kafka_event_t *rkev);\nrd_kafka_topic_partition_list_t *rd_kafka_event_topic_partition_list(rd_kafka_event_t *rkev);\nrd_kafka_topic_partition_t *rd_kafka_event_topic_partition(rd_kafka_event_t *rkev);\ntypedef rd_kafka_event_t rd_kafka_CreateTopics_result_t;\ntypedef rd_kafka_event_t rd_kafka_DeleteTopics_result_t;\ntypedef rd_kafka_event_t rd_kafka_CreateAcls_result_t;\ntypedef rd_kafka_event_t rd_kafka_DescribeAcls_result_t;\ntypedef rd_kafka_event_t rd_kafka_DeleteAcls_result_t;\ntypedef rd_kafka_event_t rd_kafka_CreatePartitions_result_t;\ntypedef rd_kafka_event_t rd_kafka_AlterConfigs_result_t;\ntypedef rd_kafka_event_t rd_kafka_IncrementalAlterConfigs_result_t;\ntypedef rd_kafka_event_t rd_kafka_DescribeConfigs_result_t;\ntypedef rd_kafka_event_t rd_kafka_DeleteRecords_result_t;\ntypedef rd_kafka_event_t rd_kafka_ListConsumerGroups_result_t;\ntypedef rd_kafka_event_t rd_kafka_DescribeConsumerGroups_result_t;\ntypedef rd_kafka_event_t rd_kafka_DeleteGroups_result_t;\ntypedef rd_kafka_event_t rd_kafka_DeleteConsumerGroupOffsets_result_t;\ntypedef rd_kafka_event_t rd_kafka_AlterConsumerGroupOffsets_result_t;\ntypedef rd_kafka_event_t rd_kafka_ListConsumerGroupOffsets_result_t;\ntypedef rd_kafka_event_t rd_kafka_DescribeTopics_result_t;\ntypedef rd_kafka_event_t rd_kafka_DescribeCluster_result_t;\ntypedef rd_kafka_event_t rd_kafka_DescribeUserScramCredentials_result_t;\ntypedef rd_kafka_event_t rd_kafka_AlterUserScramCredentials_result_t;\ntypedef rd_kafka_event_t rd_kafka_ListOffsets_result_t;\ntypedef rd_kafka_event_t rd_kafka_ElectLeaders_result_t;\nconst rd_kafka_CreateTopics_result_t *rd_kafka_event_CreateTopics_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DeleteTopics_result_t *rd_kafka_event_DeleteTopics_result(rd_kafka_event_t *rkev);\nconst rd_kafka_CreatePartitions_result_t *rd_kafka_event_CreatePartitions_result(rd_kafka_event_t *rkev);\nconst rd_kafka_AlterConfigs_result_t *rd_kafka_event_AlterConfigs_result(rd_kafka_event_t *rkev);\nconst rd_kafka_IncrementalAlterConfigs_result_t *rd_kafka_event_IncrementalAlterConfigs_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DescribeConfigs_result_t *rd_kafka_event_DescribeConfigs_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DeleteRecords_result_t *rd_kafka_event_DeleteRecords_result(rd_kafka_event_t *rkev);\nconst rd_kafka_ListConsumerGroups_result_t *rd_kafka_event_ListConsumerGroups_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DescribeConsumerGroups_result_t *rd_kafka_event_DescribeConsumerGroups_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DescribeTopics_result_t *rd_kafka_event_DescribeTopics_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DescribeCluster_result_t *rd_kafka_event_DescribeCluster_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DeleteGroups_result_t *rd_kafka_event_DeleteGroups_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DeleteConsumerGroupOffsets_result_t *rd_kafka_event_DeleteConsumerGroupOffsets_result(rd_kafka_event_t *rkev);\nconst rd_kafka_CreateAcls_result_t *rd_kafka_event_CreateAcls_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DescribeAcls_result_t *rd_kafka_event_DescribeAcls_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DeleteAcls_result_t *rd_kafka_event_DeleteAcls_result(rd_kafka_event_t *rkev);\nconst rd_kafka_ListConsumerGroupOffsets_result_t *rd_kafka_event_ListConsumerGroupOffsets_result(rd_kafka_event_t *rkev);\nconst rd_kafka_AlterConsumerGroupOffsets_result_t *rd_kafka_event_AlterConsumerGroupOffsets_result(rd_kafka_event_t *rkev);\nconst rd_kafka_ListOffsets_result_t *rd_kafka_event_ListOffsets_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DescribeUserScramCredentials_result_t *rd_kafka_event_DescribeUserScramCredentials_result(rd_kafka_event_t *rkev);\nconst rd_kafka_AlterUserScramCredentials_result_t *rd_kafka_event_AlterUserScramCredentials_result(rd_kafka_event_t *rkev);\nconst rd_kafka_ElectLeaders_result_t *rd_kafka_event_ElectLeaders_result(rd_kafka_event_t *rkev);\nrd_kafka_event_t *rd_kafka_queue_poll(rd_kafka_queue_t *rkqu, int timeout_ms);\nint rd_kafka_queue_poll_callback(rd_kafka_queue_t *rkqu, int timeout_ms);\ntypedef rd_kafka_resp_err_t (rd_kafka_plugin_f_conf_init_t)(rd_kafka_conf_t *conf, void **plug_opaquep, char *errstr, size_t errstr_size);\ntypedef rd_kafka_conf_res_t (rd_kafka_interceptor_f_on_conf_set_t)(rd_kafka_conf_t *conf, const char *name, const char *val, char *errstr, size_t errstr_size, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_dup_t)(rd_kafka_conf_t *new_conf, const rd_kafka_conf_t *old_conf, size_t filter_cnt, const char **filter, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_destroy_t)(void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_new_t)(rd_kafka_t *rk, const rd_kafka_conf_t *conf, void *ic_opaque, char *errstr, size_t errstr_size);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_destroy_t)(rd_kafka_t *rk, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_send_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_acknowledgement_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_consume_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_commit_t)(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_resp_err_t err, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_request_sent_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_response_received_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, int64_t rtt, rd_kafka_resp_err_t err, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_start_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_exit_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_broker_state_change_t)(rd_kafka_t *rk, int32_t broker_id, const char *secproto, const char *name, int port, const char *state, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_set(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_set_t *on_conf_set, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_dup(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_dup_t *on_conf_dup, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_destroy(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_destroy_t *on_conf_destroy, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_new(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_new_t *on_new, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_destroy(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_destroy_t *on_destroy, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_send(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_send_t *on_send, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_acknowledgement(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_acknowledgement_t *on_acknowledgement, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_consume(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_consume_t *on_consume, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_commit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_commit_t *on_commit, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_request_sent(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_request_sent_t *on_request_sent, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_response_received(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_response_received_t *on_response_received, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_start(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_start_t *on_thread_start, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_exit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_exit_t *on_thread_exit, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_broker_state_change(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_broker_state_change_t *on_broker_state_change, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_topic_result_error(const rd_kafka_topic_result_t *topicres);\nconst char *rd_kafka_topic_result_error_string(const rd_kafka_topic_result_t *topicres);\nconst char *rd_kafka_topic_result_name(const rd_kafka_topic_result_t *topicres);\nconst rd_kafka_error_t *rd_kafka_group_result_error(const rd_kafka_group_result_t *groupres);\nconst char *rd_kafka_group_result_name(const rd_kafka_group_result_t *groupres);\nconst rd_kafka_topic_partition_list_t *rd_kafka_group_result_partitions(const rd_kafka_group_result_t *groupres);\nconst rd_kafka_topic_partition_t *rd_kafka_topic_partition_result_partition(const rd_kafka_topic_partition_result_t *partition_result);\nconst rd_kafka_error_t *rd_kafka_topic_partition_result_error(const rd_kafka_topic_partition_result_t *partition_result);\ntypedef enum rd_kafka_admin_op_t {\n  RD_KAFKA_ADMIN_OP_ANY = 0,\n  RD_KAFKA_ADMIN_OP_CREATETOPICS,\n  RD_KAFKA_ADMIN_OP_DELETETOPICS,\n  RD_KAFKA_ADMIN_OP_CREATEPARTITIONS,\n  RD_KAFKA_ADMIN_OP_ALTERCONFIGS,\n  RD_KAFKA_ADMIN_OP_DESCRIBECONFIGS,\n  RD_KAFKA_ADMIN_OP_DELETERECORDS,\n  RD_KAFKA_ADMIN_OP_DELETEGROUPS,\n  RD_KAFKA_ADMIN_OP_DELETECONSUMERGROUPOFFSETS,\n  RD_KAFKA_ADMIN_OP_CREATEACLS,\n  RD_KAFKA_ADMIN_OP_DESCRIBEACLS,\n  RD_KAFKA_ADMIN_OP_DELETEACLS,\n  RD_KAFKA_ADMIN_OP_LISTCONSUMERGROUPS,\n  RD_KAFKA_ADMIN_OP_DESCRIBECONSUMERGROUPS,\n  RD_KAFKA_ADMIN_OP_LISTCONSUMERGROUPOFFSETS,\n  RD_KAFKA_ADMIN_OP_ALTERCONSUMERGROUPOFFSETS,\n  RD_KAFKA_ADMIN_OP_INCREMENTALALTERCONFIGS,\n  RD_KAFKA_ADMIN_OP_DESCRIBEUSERSCRAMCREDENTIALS,\n  RD_KAFKA_ADMIN_OP_ALTERUSERSCRAMCREDENTIALS,\n  RD_KAFKA_ADMIN_OP_DESCRIBETOPICS,\n  RD_KAFKA_ADMIN_OP_DESCRIBECLUSTER,\n  RD_KAFKA_ADMIN_OP_LISTOFFSETS,\n  RD_KAFKA_ADMIN_OP_ELECTLEADERS,\n  RD_KAFKA_ADMIN_OP__CNT,\n} rd_kafka_admin_op_t;\ntypedef struct rd_kafka_AdminOptions_s rd_kafka_AdminOptions_t;\ntypedef enum rd_kafka_IsolationLevel_t {\n  RD_KAFKA_ISOLATION_LEVEL_READ_UNCOMMITTED = 0,\n  RD_KAFKA_ISOLATION_LEVEL_READ_COMMITTED = 1,\n} rd_kafka_IsolationLevel_t;\nrd_kafka_AdminOptions_t *rd_kafka_AdminOptions_new(rd_kafka_t *rk, rd_kafka_admin_op_t for_api);\nvoid rd_kafka_AdminOptions_destroy(rd_kafka_AdminOptions_t *options);\nrd_kafka_resp_err_t rd_kafka_AdminOptions_set_request_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_AdminOptions_set_operation_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_AdminOptions_set_validate_only(rd_kafka_AdminOptions_t *options, int true_or_false, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_AdminOptions_set_broker(rd_kafka_AdminOptions_t *options, int32_t broker_id, char *errstr, size_t errstr_size);\nrd_kafka_error_t *rd_kafka_AdminOptions_set_require_stable_offsets(rd_kafka_AdminOptions_t *options, int true_or_false);\nrd_kafka_error_t *rd_kafka_AdminOptions_set_include_authorized_operations(rd_kafka_AdminOptions_t *options, int true_or_false);\nrd_kafka_error_t *rd_kafka_AdminOptions_set_match_consumer_group_states(rd_kafka_AdminOptions_t *options, const rd_kafka_consumer_group_state_t *consumer_group_states, size_t consumer_group_states_cnt);\nrd_kafka_error_t *rd_kafka_AdminOptions_set_match_consumer_group_types(rd_kafka_AdminOptions_t *options, const rd_kafka_consumer_group_type_t *consumer_group_types, size_t consumer_group_types_cnt);\nrd_kafka_error_t *rd_kafka_AdminOptions_set_isolation_level(rd_kafka_AdminOptions_t *options, rd_kafka_IsolationLevel_t value);\nvoid rd_kafka_AdminOptions_set_opaque(rd_kafka_AdminOptions_t *options, void *ev_opaque);\ntypedef enum rd_kafka_AclOperation_t {\n  RD_KAFKA_ACL_OPERATION_UNKNOWN = 0,\n  RD_KAFKA_ACL_OPERATION_ANY = 1,\n  RD_KAFKA_ACL_OPERATION_ALL = 2,\n  RD_KAFKA_ACL_OPERATION_READ = 3,\n  RD_KAFKA_ACL_OPERATION_WRITE = 4,\n  RD_KAFKA_ACL_OPERATION_CREATE = 5,\n  RD_KAFKA_ACL_OPERATION_DELETE = 6,\n  RD_KAFKA_ACL_OPERATION_ALTER = 7,\n  RD_KAFKA_ACL_OPERATION_DESCRIBE = 8,\n  RD_KAFKA_ACL_OPERATION_CLUSTER_ACTION = 9,\n  RD_KAFKA_ACL_OPERATION_DESCRIBE_CONFIGS = 10,\n  RD_KAFKA_ACL_OPERATION_ALTER_CONFIGS = 11,\n  RD_KAFKA_ACL_OPERATION_IDEMPOTENT_WRITE = 12,\n  RD_KAFKA_ACL_OPERATION__CNT,\n} rd_kafka_AclOperation_t;\ntypedef struct rd_kafka_NewTopic_s rd_kafka_NewTopic_t;\nrd_kafka_NewTopic_t *rd_kafka_NewTopic_new(const char *topic, int num_partitions, int replication_factor, char *errstr, size_t errstr_size);\nvoid rd_kafka_NewTopic_destroy(rd_kafka_NewTopic_t *new_topic);\nvoid rd_kafka_NewTopic_destroy_array(rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt);\nrd_kafka_resp_err_t rd_kafka_NewTopic_set_replica_assignment(rd_kafka_NewTopic_t *new_topic, int32_t partition, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_NewTopic_set_config(rd_kafka_NewTopic_t *new_topic, const char *name, const char *value);\nvoid rd_kafka_CreateTopics(rd_kafka_t *rk, rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_topic_result_t **rd_kafka_CreateTopics_result_topics(const rd_kafka_CreateTopics_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_DeleteTopic_s rd_kafka_DeleteTopic_t;\nrd_kafka_DeleteTopic_t *rd_kafka_DeleteTopic_new(const char *topic);\nvoid rd_kafka_DeleteTopic_destroy(rd_kafka_DeleteTopic_t *del_topic);\nvoid rd_kafka_DeleteTopic_destroy_array(rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt);\nvoid rd_kafka_DeleteTopics(rd_kafka_t *rk, rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_topic_result_t **rd_kafka_DeleteTopics_result_topics(const rd_kafka_DeleteTopics_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_NewPartitions_s rd_kafka_NewPartitions_t;\nrd_kafka_NewPartitions_t *rd_kafka_NewPartitions_new(const char *topic, size_t new_total_cnt, char *errstr, size_t errstr_size);\nvoid rd_kafka_NewPartitions_destroy(rd_kafka_NewPartitions_t *new_parts);\nvoid rd_kafka_NewPartitions_destroy_array(rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt);\nrd_kafka_resp_err_t rd_kafka_NewPartitions_set_replica_assignment(rd_kafka_NewPartitions_t *new_parts, int32_t new_partition_idx, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);\nvoid rd_kafka_CreatePartitions(rd_kafka_t *rk, rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_topic_result_t **rd_kafka_CreatePartitions_result_topics(const rd_kafka_CreatePartitions_result_t *result, size_t *cntp);\ntypedef enum rd_kafka_ConfigSource_t {\n  RD_KAFKA_CONFIG_SOURCE_UNKNOWN_CONFIG = 0,\n  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_TOPIC_CONFIG = 1,\n  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_BROKER_CONFIG = 2,\n  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_DEFAULT_BROKER_CONFIG = 3,\n  RD_KAFKA_CONFIG_SOURCE_STATIC_BROKER_CONFIG = 4,\n  RD_KAFKA_CONFIG_SOURCE_DEFAULT_CONFIG = 5,\n  RD_KAFKA_CONFIG_SOURCE__CNT,\n} rd_kafka_ConfigSource_t;\nconst char *rd_kafka_ConfigSource_name(rd_kafka_ConfigSource_t confsource);\ntypedef struct rd_kafka_ConfigEntry_s rd_kafka_ConfigEntry_t;\nconst char *rd_kafka_ConfigEntry_name(const rd_kafka_ConfigEntry_t *entry);\nconst char *rd_kafka_ConfigEntry_value(const rd_kafka_ConfigEntry_t *entry);\nrd_kafka_ConfigSource_t rd_kafka_ConfigEntry_source(const rd_kafka_ConfigEntry_t *entry);\nint rd_kafka_ConfigEntry_is_read_only(const rd_kafka_ConfigEntry_t *entry);\nint rd_kafka_ConfigEntry_is_default(const rd_kafka_ConfigEntry_t *entry);\nint rd_kafka_ConfigEntry_is_sensitive(const rd_kafka_ConfigEntry_t *entry);\nint rd_kafka_ConfigEntry_is_synonym(const rd_kafka_ConfigEntry_t *entry);\nconst rd_kafka_ConfigEntry_t **rd_kafka_ConfigEntry_synonyms(const rd_kafka_ConfigEntry_t *entry, size_t *cntp);\ntypedef enum rd_kafka_ResourceType_t {\n  RD_KAFKA_RESOURCE_UNKNOWN = 0,\n  RD_KAFKA_RESOURCE_ANY = 1,\n  RD_KAFKA_RESOURCE_TOPIC = 2,\n  RD_KAFKA_RESOURCE_GROUP = 3,\n  RD_KAFKA_RESOURCE_BROKER = 4,\n  RD_KAFKA_RESOURCE_TRANSACTIONAL_ID = 5,\n  RD_KAFKA_RESOURCE__CNT,\n} rd_kafka_ResourceType_t;\ntypedef enum rd_kafka_ResourcePatternType_t {\n  RD_KAFKA_RESOURCE_PATTERN_UNKNOWN = 0,\n  RD_KAFKA_RESOURCE_PATTERN_ANY = 1,\n  RD_KAFKA_RESOURCE_PATTERN_MATCH = 2,\n  RD_KAFKA_RESOURCE_PATTERN_LITERAL = 3,\n  RD_KAFKA_RESOURCE_PATTERN_PREFIXED = 4,\n  RD_KAFKA_RESOURCE_PATTERN_TYPE__CNT,\n} rd_kafka_ResourcePatternType_t;\ntypedef enum rd_kafka_AlterConfigOpType_t {\n  RD_KAFKA_ALTER_CONFIG_OP_TYPE_SET = 0,\n  RD_KAFKA_ALTER_CONFIG_OP_TYPE_DELETE = 1,\n  RD_KAFKA_ALTER_CONFIG_OP_TYPE_APPEND = 2,\n  RD_KAFKA_ALTER_CONFIG_OP_TYPE_SUBTRACT = 3,\n  RD_KAFKA_ALTER_CONFIG_OP_TYPE__CNT,\n} rd_kafka_AlterConfigOpType_t;\nconst char *rd_kafka_ResourcePatternType_name(rd_kafka_ResourcePatternType_t resource_pattern_type);\nconst char *rd_kafka_ResourceType_name(rd_kafka_ResourceType_t restype);\ntypedef struct rd_kafka_ConfigResource_s rd_kafka_ConfigResource_t;\nrd_kafka_ConfigResource_t *rd_kafka_ConfigResource_new(rd_kafka_ResourceType_t restype, const char *resname);\nvoid rd_kafka_ConfigResource_destroy(rd_kafka_ConfigResource_t *config);\nvoid rd_kafka_ConfigResource_destroy_array(rd_kafka_ConfigResource_t **config, size_t config_cnt);\nrd_kafka_resp_err_t rd_kafka_ConfigResource_set_config(rd_kafka_ConfigResource_t *config, const char *name, const char *value);\nrd_kafka_error_t *rd_kafka_ConfigResource_add_incremental_config(rd_kafka_ConfigResource_t *config, const char *name, rd_kafka_AlterConfigOpType_t op_type, const char *value);\nconst rd_kafka_ConfigEntry_t **rd_kafka_ConfigResource_configs(const rd_kafka_ConfigResource_t *config, size_t *cntp);\nrd_kafka_ResourceType_t rd_kafka_ConfigResource_type(const rd_kafka_ConfigResource_t *config);\nconst char *rd_kafka_ConfigResource_name(const rd_kafka_ConfigResource_t *config);\nrd_kafka_resp_err_t rd_kafka_ConfigResource_error(const rd_kafka_ConfigResource_t *config);\nconst char *rd_kafka_ConfigResource_error_string(const rd_kafka_ConfigResource_t *config);\nvoid rd_kafka_AlterConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_ConfigResource_t **rd_kafka_AlterConfigs_result_resources(const rd_kafka_AlterConfigs_result_t *result, size_t *cntp);\nvoid rd_kafka_IncrementalAlterConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_ConfigResource_t **rd_kafka_IncrementalAlterConfigs_result_resources(const rd_kafka_IncrementalAlterConfigs_result_t *result, size_t *cntp);\nvoid rd_kafka_DescribeConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_ConfigResource_t **rd_kafka_DescribeConfigs_result_resources(const rd_kafka_DescribeConfigs_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_DeleteRecords_s rd_kafka_DeleteRecords_t;\nrd_kafka_DeleteRecords_t *rd_kafka_DeleteRecords_new(const rd_kafka_topic_partition_list_t *before_offsets);\nvoid rd_kafka_DeleteRecords_destroy(rd_kafka_DeleteRecords_t *del_records);\nvoid rd_kafka_DeleteRecords_destroy_array(rd_kafka_DeleteRecords_t **del_records, size_t del_record_cnt);\nvoid rd_kafka_DeleteRecords(rd_kafka_t *rk, rd_kafka_DeleteRecords_t **del_records, size_t del_record_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_topic_partition_list_t *rd_kafka_DeleteRecords_result_offsets(const rd_kafka_DeleteRecords_result_t *result);\ntypedef struct rd_kafka_TopicCollection_s rd_kafka_TopicCollection_t;\ntypedef struct rd_kafka_TopicPartitionInfo_s rd_kafka_TopicPartitionInfo_t;\ntypedef struct rd_kafka_TopicDescription_s rd_kafka_TopicDescription_t;\nrd_kafka_TopicCollection_t *rd_kafka_TopicCollection_of_topic_names(const char **topics, size_t topics_cnt);\nvoid rd_kafka_TopicCollection_destroy(rd_kafka_TopicCollection_t *topics);\nvoid rd_kafka_DescribeTopics(rd_kafka_t *rk, const rd_kafka_TopicCollection_t *topics, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_TopicDescription_t **rd_kafka_DescribeTopics_result_topics(const rd_kafka_DescribeTopics_result_t *result, size_t *cntp);\nconst rd_kafka_TopicPartitionInfo_t **rd_kafka_TopicDescription_partitions(const rd_kafka_TopicDescription_t *topicdesc, size_t *cntp);\nconst int rd_kafka_TopicPartitionInfo_partition(const rd_kafka_TopicPartitionInfo_t *partition);\nconst rd_kafka_Node_t *rd_kafka_TopicPartitionInfo_leader(const rd_kafka_TopicPartitionInfo_t *partition);\nconst rd_kafka_Node_t **rd_kafka_TopicPartitionInfo_isr(const rd_kafka_TopicPartitionInfo_t *partition, size_t *cntp);\nconst rd_kafka_Node_t **rd_kafka_TopicPartitionInfo_replicas(const rd_kafka_TopicPartitionInfo_t *partition, size_t *cntp);\nconst rd_kafka_AclOperation_t *rd_kafka_TopicDescription_authorized_operations(const rd_kafka_TopicDescription_t *topicdesc, size_t *cntp);\nconst char *rd_kafka_TopicDescription_name(const rd_kafka_TopicDescription_t *topicdesc);\nconst rd_kafka_Uuid_t *rd_kafka_TopicDescription_topic_id(const rd_kafka_TopicDescription_t *topicdesc);\nint rd_kafka_TopicDescription_is_internal(const rd_kafka_TopicDescription_t *topicdesc);\nconst rd_kafka_error_t *rd_kafka_TopicDescription_error(const rd_kafka_TopicDescription_t *topicdesc);\nvoid rd_kafka_DescribeCluster(rd_kafka_t *rk, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_Node_t **rd_kafka_DescribeCluster_result_nodes(const rd_kafka_DescribeCluster_result_t *result, size_t *cntp);\nconst rd_kafka_AclOperation_t *rd_kafka_DescribeCluster_result_authorized_operations(const rd_kafka_DescribeCluster_result_t *result, size_t *cntp);\nconst rd_kafka_Node_t *rd_kafka_DescribeCluster_result_controller(const rd_kafka_DescribeCluster_result_t *result);\nconst char *rd_kafka_DescribeCluster_result_cluster_id(const rd_kafka_DescribeCluster_result_t *result);\ntypedef struct rd_kafka_ConsumerGroupListing_s rd_kafka_ConsumerGroupListing_t;\ntypedef struct rd_kafka_ListConsumerGroupsResult_s rd_kafka_ListConsumerGroupsResult_t;\nvoid rd_kafka_ListConsumerGroups(rd_kafka_t *rk, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst char *rd_kafka_ConsumerGroupListing_group_id(const rd_kafka_ConsumerGroupListing_t *grplist);\nint rd_kafka_ConsumerGroupListing_is_simple_consumer_group(const rd_kafka_ConsumerGroupListing_t *grplist);\nrd_kafka_consumer_group_state_t rd_kafka_ConsumerGroupListing_state(const rd_kafka_ConsumerGroupListing_t *grplist);\nrd_kafka_consumer_group_type_t rd_kafka_ConsumerGroupListing_type(const rd_kafka_ConsumerGroupListing_t *grplist);\nconst rd_kafka_ConsumerGroupListing_t **rd_kafka_ListConsumerGroups_result_valid(const rd_kafka_ListConsumerGroups_result_t *result, size_t *cntp);\nconst rd_kafka_error_t **rd_kafka_ListConsumerGroups_result_errors(const rd_kafka_ListConsumerGroups_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_ConsumerGroupDescription_s rd_kafka_ConsumerGroupDescription_t;\ntypedef struct rd_kafka_MemberDescription_s rd_kafka_MemberDescription_t;\ntypedef struct rd_kafka_MemberAssignment_s rd_kafka_MemberAssignment_t;\nvoid rd_kafka_DescribeConsumerGroups(rd_kafka_t *rk, const char **groups, size_t groups_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_ConsumerGroupDescription_t **rd_kafka_DescribeConsumerGroups_result_groups(const rd_kafka_DescribeConsumerGroups_result_t *result, size_t *cntp);\nconst char *rd_kafka_ConsumerGroupDescription_group_id(const rd_kafka_ConsumerGroupDescription_t *grpdesc);\nconst rd_kafka_error_t *rd_kafka_ConsumerGroupDescription_error(const rd_kafka_ConsumerGroupDescription_t *grpdesc);\nint rd_kafka_ConsumerGroupDescription_is_simple_consumer_group(const rd_kafka_ConsumerGroupDescription_t *grpdesc);\nconst char *rd_kafka_ConsumerGroupDescription_partition_assignor(const rd_kafka_ConsumerGroupDescription_t *grpdesc);\nconst rd_kafka_AclOperation_t *rd_kafka_ConsumerGroupDescription_authorized_operations(const rd_kafka_ConsumerGroupDescription_t *grpdesc, size_t *cntp);\nrd_kafka_consumer_group_state_t rd_kafka_ConsumerGroupDescription_state(const rd_kafka_ConsumerGroupDescription_t *grpdesc);\nconst rd_kafka_Node_t *rd_kafka_ConsumerGroupDescription_coordinator(const rd_kafka_ConsumerGroupDescription_t *grpdesc);\nsize_t rd_kafka_ConsumerGroupDescription_member_count(const rd_kafka_ConsumerGroupDescription_t *grpdesc);\nconst rd_kafka_MemberDescription_t *rd_kafka_ConsumerGroupDescription_member(const rd_kafka_ConsumerGroupDescription_t *grpdesc, size_t idx);\nconst char *rd_kafka_MemberDescription_client_id(const rd_kafka_MemberDescription_t *member);\nconst char *rd_kafka_MemberDescription_group_instance_id(const rd_kafka_MemberDescription_t *member);\nconst char *rd_kafka_MemberDescription_consumer_id(const rd_kafka_MemberDescription_t *member);\nconst char *rd_kafka_MemberDescription_host(const rd_kafka_MemberDescription_t *member);\nconst rd_kafka_MemberAssignment_t *rd_kafka_MemberDescription_assignment(const rd_kafka_MemberDescription_t *member);\nconst rd_kafka_topic_partition_list_t *rd_kafka_MemberAssignment_partitions(const rd_kafka_MemberAssignment_t *assignment);\ntypedef struct rd_kafka_DeleteGroup_s rd_kafka_DeleteGroup_t;\nrd_kafka_DeleteGroup_t *rd_kafka_DeleteGroup_new(const char *group);\nvoid rd_kafka_DeleteGroup_destroy(rd_kafka_DeleteGroup_t *del_group);\nvoid rd_kafka_DeleteGroup_destroy_array(rd_kafka_DeleteGroup_t **del_groups, size_t del_group_cnt);\nvoid rd_kafka_DeleteGroups(rd_kafka_t *rk, rd_kafka_DeleteGroup_t **del_groups, size_t del_group_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_group_result_t **rd_kafka_DeleteGroups_result_groups(const rd_kafka_DeleteGroups_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_ListConsumerGroupOffsets_s rd_kafka_ListConsumerGroupOffsets_t;\nrd_kafka_ListConsumerGroupOffsets_t *rd_kafka_ListConsumerGroupOffsets_new(const char *group_id, const rd_kafka_topic_partition_list_t *partitions);\nvoid rd_kafka_ListConsumerGroupOffsets_destroy(rd_kafka_ListConsumerGroupOffsets_t *list_grpoffsets);\nvoid rd_kafka_ListConsumerGroupOffsets_destroy_array(rd_kafka_ListConsumerGroupOffsets_t **list_grpoffsets, size_t list_grpoffset_cnt);\nvoid rd_kafka_ListConsumerGroupOffsets(rd_kafka_t *rk, rd_kafka_ListConsumerGroupOffsets_t **list_grpoffsets, size_t list_grpoffsets_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_group_result_t **rd_kafka_ListConsumerGroupOffsets_result_groups(const rd_kafka_ListConsumerGroupOffsets_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_AlterConsumerGroupOffsets_s rd_kafka_AlterConsumerGroupOffsets_t;\nrd_kafka_AlterConsumerGroupOffsets_t *rd_kafka_AlterConsumerGroupOffsets_new(const char *group_id, const rd_kafka_topic_partition_list_t *partitions);\nvoid rd_kafka_AlterConsumerGroupOffsets_destroy(rd_kafka_AlterConsumerGroupOffsets_t *alter_grpoffsets);\nvoid rd_kafka_AlterConsumerGroupOffsets_destroy_array(rd_kafka_AlterConsumerGroupOffsets_t **alter_grpoffsets, size_t alter_grpoffset_cnt);\nvoid rd_kafka_AlterConsumerGroupOffsets(rd_kafka_t *rk, rd_kafka_AlterConsumerGroupOffsets_t **alter_grpoffsets, size_t alter_grpoffsets_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_group_result_t **rd_kafka_AlterConsumerGroupOffsets_result_groups(const rd_kafka_AlterConsumerGroupOffsets_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_DeleteConsumerGroupOffsets_s rd_kafka_DeleteConsumerGroupOffsets_t;\nrd_kafka_DeleteConsumerGroupOffsets_t *rd_kafka_DeleteConsumerGroupOffsets_new(const char *group, const rd_kafka_topic_partition_list_t *partitions);\nvoid rd_kafka_DeleteConsumerGroupOffsets_destroy(rd_kafka_DeleteConsumerGroupOffsets_t *del_grpoffsets);\nvoid rd_kafka_DeleteConsumerGroupOffsets_destroy_array(rd_kafka_DeleteConsumerGroupOffsets_t **del_grpoffsets, size_t del_grpoffset_cnt);\nvoid rd_kafka_DeleteConsumerGroupOffsets(rd_kafka_t *rk, rd_kafka_DeleteConsumerGroupOffsets_t **del_grpoffsets, size_t del_grpoffsets_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_group_result_t **rd_kafka_DeleteConsumerGroupOffsets_result_groups(const rd_kafka_DeleteConsumerGroupOffsets_result_t *result, size_t *cntp);\ntypedef enum rd_kafka_OffsetSpec_t {\n  RD_KAFKA_OFFSET_SPEC_MAX_TIMESTAMP = (- 3),\n  RD_KAFKA_OFFSET_SPEC_EARLIEST = (- 2),\n  RD_KAFKA_OFFSET_SPEC_LATEST = (- 1),\n} rd_kafka_OffsetSpec_t;\ntypedef struct rd_kafka_ListOffsetsResultInfo_s rd_kafka_ListOffsetsResultInfo_t;\nconst rd_kafka_topic_partition_t *rd_kafka_ListOffsetsResultInfo_topic_partition(const rd_kafka_ListOffsetsResultInfo_t *result_info);\nint64_t rd_kafka_ListOffsetsResultInfo_timestamp(const rd_kafka_ListOffsetsResultInfo_t *result_info);\nconst rd_kafka_ListOffsetsResultInfo_t **rd_kafka_ListOffsets_result_infos(const rd_kafka_ListOffsets_result_t *result, size_t *cntp);\nvoid rd_kafka_ListOffsets(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *topic_partitions, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\ntypedef enum rd_kafka_ScramMechanism_t {\n  RD_KAFKA_SCRAM_MECHANISM_UNKNOWN = 0,\n  RD_KAFKA_SCRAM_MECHANISM_SHA_256 = 1,\n  RD_KAFKA_SCRAM_MECHANISM_SHA_512 = 2,\n  RD_KAFKA_SCRAM_MECHANISM__CNT,\n} rd_kafka_ScramMechanism_t;\ntypedef struct rd_kafka_ScramCredentialInfo_s rd_kafka_ScramCredentialInfo_t;\nrd_kafka_ScramMechanism_t rd_kafka_ScramCredentialInfo_mechanism(const rd_kafka_ScramCredentialInfo_t *scram_credential_info);\nint32_t rd_kafka_ScramCredentialInfo_iterations(const rd_kafka_ScramCredentialInfo_t *scram_credential_info);\ntypedef struct rd_kafka_UserScramCredentialsDescription_s rd_kafka_UserScramCredentialsDescription_t;\nconst char *rd_kafka_UserScramCredentialsDescription_user(const rd_kafka_UserScramCredentialsDescription_t *description);\nconst rd_kafka_error_t *rd_kafka_UserScramCredentialsDescription_error(const rd_kafka_UserScramCredentialsDescription_t *description);\nsize_t rd_kafka_UserScramCredentialsDescription_scramcredentialinfo_count(const rd_kafka_UserScramCredentialsDescription_t *description);\nconst rd_kafka_ScramCredentialInfo_t *rd_kafka_UserScramCredentialsDescription_scramcredentialinfo(const rd_kafka_UserScramCredentialsDescription_t *description, size_t idx);\nconst rd_kafka_UserScramCredentialsDescription_t **rd_kafka_DescribeUserScramCredentials_result_descriptions(const rd_kafka_DescribeUserScramCredentials_result_t *result, size_t *cntp);\nvoid rd_kafka_DescribeUserScramCredentials(rd_kafka_t *rk, const char **users, size_t user_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\ntypedef struct rd_kafka_UserScramCredentialAlteration_s rd_kafka_UserScramCredentialAlteration_t;\nrd_kafka_UserScramCredentialAlteration_t *rd_kafka_UserScramCredentialUpsertion_new(const char *username, rd_kafka_ScramMechanism_t mechanism, int32_t iterations, const unsigned char *password, size_t password_size, const unsigned char *salt, size_t salt_size);\nrd_kafka_UserScramCredentialAlteration_t *rd_kafka_UserScramCredentialDeletion_new(const char *username, rd_kafka_ScramMechanism_t mechanism);\nvoid rd_kafka_UserScramCredentialAlteration_destroy(rd_kafka_UserScramCredentialAlteration_t *alteration);\nvoid rd_kafka_UserScramCredentialAlteration_destroy_array(rd_kafka_UserScramCredentialAlteration_t **alterations, size_t alteration_cnt);\ntypedef struct rd_kafka_AlterUserScramCredentials_result_response_s rd_kafka_AlterUserScramCredentials_result_response_t;\nconst char *rd_kafka_AlterUserScramCredentials_result_response_user(const rd_kafka_AlterUserScramCredentials_result_response_t *response);\nconst rd_kafka_error_t *rd_kafka_AlterUserScramCredentials_result_response_error(const rd_kafka_AlterUserScramCredentials_result_response_t *response);\nconst rd_kafka_AlterUserScramCredentials_result_response_t **rd_kafka_AlterUserScramCredentials_result_responses(const rd_kafka_AlterUserScramCredentials_result_t *result, size_t *cntp);\nvoid rd_kafka_AlterUserScramCredentials(rd_kafka_t *rk, rd_kafka_UserScramCredentialAlteration_t **alterations, size_t alteration_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\ntypedef struct rd_kafka_AclBinding_s rd_kafka_AclBinding_t;\ntypedef rd_kafka_AclBinding_t rd_kafka_AclBindingFilter_t;\nconst rd_kafka_error_t *rd_kafka_acl_result_error(const rd_kafka_acl_result_t *aclres);\nconst char *rd_kafka_AclOperation_name(rd_kafka_AclOperation_t acl_operation);\ntypedef enum rd_kafka_AclPermissionType_t {\n  RD_KAFKA_ACL_PERMISSION_TYPE_UNKNOWN = 0,\n  RD_KAFKA_ACL_PERMISSION_TYPE_ANY = 1,\n  RD_KAFKA_ACL_PERMISSION_TYPE_DENY = 2,\n  RD_KAFKA_ACL_PERMISSION_TYPE_ALLOW = 3,\n  RD_KAFKA_ACL_PERMISSION_TYPE__CNT,\n} rd_kafka_AclPermissionType_t;\nconst char *rd_kafka_AclPermissionType_name(rd_kafka_AclPermissionType_t acl_permission_type);\nrd_kafka_AclBinding_t *rd_kafka_AclBinding_new(rd_kafka_ResourceType_t restype, const char *name, rd_kafka_ResourcePatternType_t resource_pattern_type, const char *principal, const char *host, rd_kafka_AclOperation_t operation, rd_kafka_AclPermissionType_t permission_type, char *errstr, size_t errstr_size);\nrd_kafka_AclBindingFilter_t *rd_kafka_AclBindingFilter_new(rd_kafka_ResourceType_t restype, const char *name, rd_kafka_ResourcePatternType_t resource_pattern_type, const char *principal, const char *host, rd_kafka_AclOperation_t operation, rd_kafka_AclPermissionType_t permission_type, char *errstr, size_t errstr_size);\nrd_kafka_ResourceType_t rd_kafka_AclBinding_restype(const rd_kafka_AclBinding_t *acl);\nconst char *rd_kafka_AclBinding_name(const rd_kafka_AclBinding_t *acl);\nconst char *rd_kafka_AclBinding_principal(const rd_kafka_AclBinding_t *acl);\nconst char *rd_kafka_AclBinding_host(const rd_kafka_AclBinding_t *acl);\nrd_kafka_AclOperation_t rd_kafka_AclBinding_operation(const rd_kafka_AclBinding_t *acl);\nrd_kafka_AclPermissionType_t rd_kafka_AclBinding_permission_type(const rd_kafka_AclBinding_t *acl);\nrd_kafka_ResourcePatternType_t rd_kafka_AclBinding_resource_pattern_type(const rd_kafka_AclBinding_t *acl);\nconst rd_kafka_error_t *rd_kafka_AclBinding_error(const rd_kafka_AclBinding_t *acl);\nvoid rd_kafka_AclBinding_destroy(rd_kafka_AclBinding_t *acl_binding);\nvoid rd_kafka_AclBinding_destroy_array(rd_kafka_AclBinding_t **acl_bindings, size_t acl_bindings_cnt);\nconst rd_kafka_acl_result_t **rd_kafka_CreateAcls_result_acls(const rd_kafka_CreateAcls_result_t *result, size_t *cntp);\nvoid rd_kafka_CreateAcls(rd_kafka_t *rk, rd_kafka_AclBinding_t **new_acls, size_t new_acls_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_AclBinding_t **rd_kafka_DescribeAcls_result_acls(const rd_kafka_DescribeAcls_result_t *result, size_t *cntp);\nvoid rd_kafka_DescribeAcls(rd_kafka_t *rk, rd_kafka_AclBindingFilter_t *acl_filter, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\ntypedef struct rd_kafka_DeleteAcls_result_response_s rd_kafka_DeleteAcls_result_response_t;\nconst rd_kafka_DeleteAcls_result_response_t **rd_kafka_DeleteAcls_result_responses(const rd_kafka_DeleteAcls_result_t *result, size_t *cntp);\nconst rd_kafka_error_t *rd_kafka_DeleteAcls_result_response_error(const rd_kafka_DeleteAcls_result_response_t *result_response);\nconst rd_kafka_AclBinding_t **rd_kafka_DeleteAcls_result_response_matching_acls(const rd_kafka_DeleteAcls_result_response_t *result_response, size_t *matching_acls_cntp);\nvoid rd_kafka_DeleteAcls(rd_kafka_t *rk, rd_kafka_AclBindingFilter_t **del_acls, size_t del_acls_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\ntypedef struct rd_kafka_ElectLeaders_s rd_kafka_ElectLeaders_t;\ntypedef enum rd_kafka_ElectionType_t {\n  RD_KAFKA_ELECTION_TYPE_PREFERRED = 0,\n  RD_KAFKA_ELECTION_TYPE_UNCLEAN = 1,\n} rd_kafka_ElectionType_t;\nrd_kafka_ElectLeaders_t *rd_kafka_ElectLeaders_new(rd_kafka_ElectionType_t election_type, rd_kafka_topic_partition_list_t *partitions);\nvoid rd_kafka_ElectLeaders_destroy(rd_kafka_ElectLeaders_t *elect_leaders);\nvoid rd_kafka_ElectLeaders(rd_kafka_t *rk, rd_kafka_ElectLeaders_t *elect_leaders, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_topic_partition_result_t **rd_kafka_ElectLeaders_result_partitions(const rd_kafka_ElectLeaders_result_t *result, size_t *cntp);\nrd_kafka_resp_err_t rd_kafka_oauthbearer_set_token(rd_kafka_t *rk, const char *token_value, int64_t md_lifetime_ms, const char *md_principal_name, const char **extensions, size_t extension_size, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_oauthbearer_set_token_failure(rd_kafka_t *rk, const char *errstr);\nrd_kafka_error_t *rd_kafka_init_transactions(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_error_t *rd_kafka_begin_transaction(rd_kafka_t *rk);\nrd_kafka_error_t *rd_kafka_send_offsets_to_transaction(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, const rd_kafka_consumer_group_metadata_t *cgmetadata, int timeout_ms);\nrd_kafka_error_t *rd_kafka_commit_transaction(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_error_t *rd_kafka_abort_transaction(rd_kafka_t *rk, int timeout_ms);\ntypedef struct rd_kafka_mock_cluster_s rd_kafka_mock_cluster_t;\nrd_kafka_mock_cluster_t *rd_kafka_mock_cluster_new(rd_kafka_t *rk, int broker_cnt);\nvoid rd_kafka_mock_cluster_destroy(rd_kafka_mock_cluster_t *mcluster);\nrd_kafka_t *rd_kafka_mock_cluster_handle(const rd_kafka_mock_cluster_t *mcluster);\nrd_kafka_mock_cluster_t *rd_kafka_handle_mock_cluster(const rd_kafka_t *rk);\nconst char *rd_kafka_mock_cluster_bootstraps(const rd_kafka_mock_cluster_t *mcluster);\nvoid rd_kafka_mock_clear_request_errors(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey);\nvoid rd_kafka_mock_push_request_errors(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, size_t cnt, ...);\nvoid rd_kafka_mock_push_request_errors_array(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, size_t cnt, const rd_kafka_resp_err_t *errors);\nvoid rd_kafka_mock_group_initial_rebalance_delay_ms(rd_kafka_mock_cluster_t *mcluster, int32_t delay_ms);\nrd_kafka_resp_err_t rd_kafka_mock_broker_push_request_error_rtts(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int16_t ApiKey, size_t cnt, ...);\nrd_kafka_resp_err_t rd_kafka_mock_broker_error_stack_cnt(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int16_t ApiKey, size_t *cntp);\nvoid rd_kafka_mock_topic_set_error(rd_kafka_mock_cluster_t *mcluster, const char *topic, rd_kafka_resp_err_t err);\nrd_kafka_resp_err_t rd_kafka_mock_topic_create(rd_kafka_mock_cluster_t *mcluster, const char *topic, int partition_cnt, int replication_factor);\nrd_kafka_resp_err_t rd_kafka_mock_partition_set_leader(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id);\nrd_kafka_resp_err_t rd_kafka_mock_partition_set_follower(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id);\nrd_kafka_resp_err_t rd_kafka_mock_partition_set_follower_wmarks(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int64_t lo, int64_t hi);\nrd_kafka_resp_err_t rd_kafka_mock_partition_push_leader_response(rd_kafka_mock_cluster_t *mcluster, const char *topic, int partition, int32_t leader_id, int32_t leader_epoch);\nrd_kafka_resp_err_t rd_kafka_mock_broker_set_down(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id);\nrd_kafka_resp_err_t rd_kafka_mock_broker_set_up(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id);\nrd_kafka_resp_err_t rd_kafka_mock_broker_set_rtt(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int rtt_ms);\nrd_kafka_resp_err_t rd_kafka_mock_broker_set_rack(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, const char *rack);\nrd_kafka_resp_err_t rd_kafka_mock_coordinator_set(rd_kafka_mock_cluster_t *mcluster, const char *key_type, const char *key, int32_t broker_id);\nrd_kafka_resp_err_t rd_kafka_mock_set_apiversion(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, int16_t MinVersion, int16_t MaxVersion);\nvoid rd_kafka_mock_start_request_tracking(rd_kafka_mock_cluster_t *mcluster);\nvoid rd_kafka_mock_stop_request_tracking(rd_kafka_mock_cluster_t *mcluster);\ntypedef struct rd_kafka_mock_request_s rd_kafka_mock_request_t;\nvoid rd_kafka_mock_request_destroy(rd_kafka_mock_request_t *mreq);\nvoid rd_kafka_mock_request_destroy_array(rd_kafka_mock_request_t **mreqs, size_t mreq_cnt);\nint32_t rd_kafka_mock_request_id(rd_kafka_mock_request_t *mreq);\nint16_t rd_kafka_mock_request_api_key(rd_kafka_mock_request_t *mreq);\nint64_t rd_kafka_mock_request_timestamp(rd_kafka_mock_request_t *mreq);\nrd_kafka_mock_request_t **rd_kafka_mock_get_requests(rd_kafka_mock_cluster_t *mcluster, size_t *cntp);\nvoid rd_kafka_mock_clear_requests(rd_kafka_mock_cluster_t *mcluster);\nrd_kafka_resp_err_t rd_kafka_mock_telemetry_set_requested_metrics(rd_kafka_mock_cluster_t *mcluster, char **metrics, size_t metrics_cnt);\nrd_kafka_resp_err_t rd_kafka_mock_telemetry_set_push_interval(rd_kafka_mock_cluster_t *mcluster, int64_t push_interval_ms);\n'\n</code></pre> rdkafka.h, rdkafka_mock.h</p>"},{"location":"api/constants/#rd_kafka_version_34","title":"RD_KAFKA_VERSION","text":"<pre><code>public RD_KAFKA_VERSION = 33948159\n</code></pre> <p>librdkafka version </p> <p>Interpreted as hex <code>MM.mm.rr.xx</code>:</p> <ul> <li>MM = Major</li> <li>mm = minor</li> <li>rr = revision</li> <li>xx = pre-release id (0xff is the final release)</li> </ul> <p>E.g.: <code>0x000801ff</code> = 0.8.1</p> RemarksThis value should only be used during compile time, for runtime checks of version use rd_kafka_version()  <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_unsupported_compression_type_34","title":"RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE","text":"<pre><code>public RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76\n</code></pre> <p>Unsupported compression type </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_end_all_34","title":"RD_KAFKA_RESP_ERR_END_ALL","text":"<p><pre><code>public RD_KAFKA_RESP_ERR_END_ALL = 119\n</code></pre> enum rd_kafka_resp_err_t</p>"},{"location":"api/constants/#rd_kafka_admin_op__cnt_34","title":"RD_KAFKA_ADMIN_OP__CNT","text":"<pre><code>public RD_KAFKA_ADMIN_OP__CNT = 23\n</code></pre> <p>Number of ops defined </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe </li> </ul>"},{"location":"api/constants/#rd_kafka_resource__cnt_34","title":"RD_KAFKA_RESOURCE__CNT","text":"<pre><code>public RD_KAFKA_RESOURCE__CNT = 6\n</code></pre> <p>Number of resource types defined </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#acca83a66d7783ff7683ed2691cc907c9 </li> </ul>"},{"location":"api/constants/#rd_kafka_cdef_34","title":"RD_KAFKA_CDEF","text":"<p><pre><code>public RD_KAFKA_CDEF = 'typedef long int ssize_t;\ntypedef struct _IO_FILE FILE;\ntypedef long int mode_t;\ntypedef signed int int16_t;\ntypedef unsigned int uint16_t;\ntypedef signed int int32_t;\ntypedef signed long int int64_t;\nint rd_kafka_version(void);\nconst char *rd_kafka_version_str(void);\ntypedef enum rd_kafka_type_t {\n  RD_KAFKA_PRODUCER,\n  RD_KAFKA_CONSUMER,\n} rd_kafka_type_t;\ntypedef enum rd_kafka_timestamp_type_t {\n  RD_KAFKA_TIMESTAMP_NOT_AVAILABLE,\n  RD_KAFKA_TIMESTAMP_CREATE_TIME,\n  RD_KAFKA_TIMESTAMP_LOG_APPEND_TIME,\n} rd_kafka_timestamp_type_t;\nconst char *rd_kafka_get_debug_contexts(void);\ntypedef struct rd_kafka_s rd_kafka_t;\ntypedef struct rd_kafka_topic_s rd_kafka_topic_t;\ntypedef struct rd_kafka_conf_s rd_kafka_conf_t;\ntypedef struct rd_kafka_topic_conf_s rd_kafka_topic_conf_t;\ntypedef struct rd_kafka_queue_s rd_kafka_queue_t;\ntypedef struct rd_kafka_op_s rd_kafka_event_t;\ntypedef struct rd_kafka_topic_result_s rd_kafka_topic_result_t;\ntypedef struct rd_kafka_consumer_group_metadata_s rd_kafka_consumer_group_metadata_t;\ntypedef struct rd_kafka_error_s {\n  unsigned int code;\n  char *errstr;\n  unsigned char fatal;\n  unsigned char retriable;\n  unsigned char txn_requires_abort;\n} rd_kafka_error_t;\ntypedef struct rd_kafka_headers_s rd_kafka_headers_t;\ntypedef struct rd_kafka_group_result_s rd_kafka_group_result_t;\ntypedef struct rd_kafka_acl_result_s rd_kafka_acl_result_t;\ntypedef struct rd_kafka_Uuid_s rd_kafka_Uuid_t;\ntypedef struct rd_kafka_topic_partition_result_s rd_kafka_topic_partition_result_t;\ntypedef enum {\n  RD_KAFKA_RESP_ERR__BEGIN = (- 200),\n  RD_KAFKA_RESP_ERR__BAD_MSG = (- 199),\n  RD_KAFKA_RESP_ERR__BAD_COMPRESSION = (- 198),\n  RD_KAFKA_RESP_ERR__DESTROY = (- 197),\n  RD_KAFKA_RESP_ERR__FAIL = (- 196),\n  RD_KAFKA_RESP_ERR__TRANSPORT = (- 195),\n  RD_KAFKA_RESP_ERR__CRIT_SYS_RESOURCE = (- 194),\n  RD_KAFKA_RESP_ERR__RESOLVE = (- 193),\n  RD_KAFKA_RESP_ERR__MSG_TIMED_OUT = (- 192),\n  RD_KAFKA_RESP_ERR__PARTITION_EOF = (- 191),\n  RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION = (- 190),\n  RD_KAFKA_RESP_ERR__FS = (- 189),\n  RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC = (- 188),\n  RD_KAFKA_RESP_ERR__ALL_BROKERS_DOWN = (- 187),\n  RD_KAFKA_RESP_ERR__INVALID_ARG = (- 186),\n  RD_KAFKA_RESP_ERR__TIMED_OUT = (- 185),\n  RD_KAFKA_RESP_ERR__QUEUE_FULL = (- 184),\n  RD_KAFKA_RESP_ERR__ISR_INSUFF = (- 183),\n  RD_KAFKA_RESP_ERR__NODE_UPDATE = (- 182),\n  RD_KAFKA_RESP_ERR__SSL = (- 181),\n  RD_KAFKA_RESP_ERR__WAIT_COORD = (- 180),\n  RD_KAFKA_RESP_ERR__UNKNOWN_GROUP = (- 179),\n  RD_KAFKA_RESP_ERR__IN_PROGRESS = (- 178),\n  RD_KAFKA_RESP_ERR__PREV_IN_PROGRESS = (- 177),\n  RD_KAFKA_RESP_ERR__EXISTING_SUBSCRIPTION = (- 176),\n  RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS = (- 175),\n  RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS = (- 174),\n  RD_KAFKA_RESP_ERR__CONFLICT = (- 173),\n  RD_KAFKA_RESP_ERR__STATE = (- 172),\n  RD_KAFKA_RESP_ERR__UNKNOWN_PROTOCOL = (- 171),\n  RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED = (- 170),\n  RD_KAFKA_RESP_ERR__AUTHENTICATION = (- 169),\n  RD_KAFKA_RESP_ERR__NO_OFFSET = (- 168),\n  RD_KAFKA_RESP_ERR__OUTDATED = (- 167),\n  RD_KAFKA_RESP_ERR__TIMED_OUT_QUEUE = (- 166),\n  RD_KAFKA_RESP_ERR__UNSUPPORTED_FEATURE = (- 165),\n  RD_KAFKA_RESP_ERR__WAIT_CACHE = (- 164),\n  RD_KAFKA_RESP_ERR__INTR = (- 163),\n  RD_KAFKA_RESP_ERR__KEY_SERIALIZATION = (- 162),\n  RD_KAFKA_RESP_ERR__VALUE_SERIALIZATION = (- 161),\n  RD_KAFKA_RESP_ERR__KEY_DESERIALIZATION = (- 160),\n  RD_KAFKA_RESP_ERR__VALUE_DESERIALIZATION = (- 159),\n  RD_KAFKA_RESP_ERR__PARTIAL = (- 158),\n  RD_KAFKA_RESP_ERR__READ_ONLY = (- 157),\n  RD_KAFKA_RESP_ERR__NOENT = (- 156),\n  RD_KAFKA_RESP_ERR__UNDERFLOW = (- 155),\n  RD_KAFKA_RESP_ERR__INVALID_TYPE = (- 154),\n  RD_KAFKA_RESP_ERR__RETRY = (- 153),\n  RD_KAFKA_RESP_ERR__PURGE_QUEUE = (- 152),\n  RD_KAFKA_RESP_ERR__PURGE_INFLIGHT = (- 151),\n  RD_KAFKA_RESP_ERR__FATAL = (- 150),\n  RD_KAFKA_RESP_ERR__INCONSISTENT = (- 149),\n  RD_KAFKA_RESP_ERR__GAPLESS_GUARANTEE = (- 148),\n  RD_KAFKA_RESP_ERR__MAX_POLL_EXCEEDED = (- 147),\n  RD_KAFKA_RESP_ERR__UNKNOWN_BROKER = (- 146),\n  RD_KAFKA_RESP_ERR__NOT_CONFIGURED = (- 145),\n  RD_KAFKA_RESP_ERR__FENCED = (- 144),\n  RD_KAFKA_RESP_ERR__APPLICATION = (- 143),\n  RD_KAFKA_RESP_ERR__ASSIGNMENT_LOST = (- 142),\n  RD_KAFKA_RESP_ERR__NOOP = (- 141),\n  RD_KAFKA_RESP_ERR__AUTO_OFFSET_RESET = (- 140),\n  RD_KAFKA_RESP_ERR__LOG_TRUNCATION = (- 139),\n  RD_KAFKA_RESP_ERR__INVALID_DIFFERENT_RECORD = (- 138),\n  RD_KAFKA_RESP_ERR__END = (- 100),\n  RD_KAFKA_RESP_ERR_UNKNOWN = (- 1),\n  RD_KAFKA_RESP_ERR_NO_ERROR = 0,\n  RD_KAFKA_RESP_ERR_OFFSET_OUT_OF_RANGE = 1,\n  RD_KAFKA_RESP_ERR_INVALID_MSG = 2,\n  RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART = 3,\n  RD_KAFKA_RESP_ERR_INVALID_MSG_SIZE = 4,\n  RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE = 5,\n  RD_KAFKA_RESP_ERR_NOT_LEADER_FOR_PARTITION = 6,\n  RD_KAFKA_RESP_ERR_REQUEST_TIMED_OUT = 7,\n  RD_KAFKA_RESP_ERR_BROKER_NOT_AVAILABLE = 8,\n  RD_KAFKA_RESP_ERR_REPLICA_NOT_AVAILABLE = 9,\n  RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE = 10,\n  RD_KAFKA_RESP_ERR_STALE_CTRL_EPOCH = 11,\n  RD_KAFKA_RESP_ERR_OFFSET_METADATA_TOO_LARGE = 12,\n  RD_KAFKA_RESP_ERR_NETWORK_EXCEPTION = 13,\n  RD_KAFKA_RESP_ERR_COORDINATOR_LOAD_IN_PROGRESS = 14,\n  RD_KAFKA_RESP_ERR_COORDINATOR_NOT_AVAILABLE = 15,\n  RD_KAFKA_RESP_ERR_NOT_COORDINATOR = 16,\n  RD_KAFKA_RESP_ERR_TOPIC_EXCEPTION = 17,\n  RD_KAFKA_RESP_ERR_RECORD_LIST_TOO_LARGE = 18,\n  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS = 19,\n  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS_AFTER_APPEND = 20,\n  RD_KAFKA_RESP_ERR_INVALID_REQUIRED_ACKS = 21,\n  RD_KAFKA_RESP_ERR_ILLEGAL_GENERATION = 22,\n  RD_KAFKA_RESP_ERR_INCONSISTENT_GROUP_PROTOCOL = 23,\n  RD_KAFKA_RESP_ERR_INVALID_GROUP_ID = 24,\n  RD_KAFKA_RESP_ERR_UNKNOWN_MEMBER_ID = 25,\n  RD_KAFKA_RESP_ERR_INVALID_SESSION_TIMEOUT = 26,\n  RD_KAFKA_RESP_ERR_REBALANCE_IN_PROGRESS = 27,\n  RD_KAFKA_RESP_ERR_INVALID_COMMIT_OFFSET_SIZE = 28,\n  RD_KAFKA_RESP_ERR_TOPIC_AUTHORIZATION_FAILED = 29,\n  RD_KAFKA_RESP_ERR_GROUP_AUTHORIZATION_FAILED = 30,\n  RD_KAFKA_RESP_ERR_CLUSTER_AUTHORIZATION_FAILED = 31,\n  RD_KAFKA_RESP_ERR_INVALID_TIMESTAMP = 32,\n  RD_KAFKA_RESP_ERR_UNSUPPORTED_SASL_MECHANISM = 33,\n  RD_KAFKA_RESP_ERR_ILLEGAL_SASL_STATE = 34,\n  RD_KAFKA_RESP_ERR_UNSUPPORTED_VERSION = 35,\n  RD_KAFKA_RESP_ERR_TOPIC_ALREADY_EXISTS = 36,\n  RD_KAFKA_RESP_ERR_INVALID_PARTITIONS = 37,\n  RD_KAFKA_RESP_ERR_INVALID_REPLICATION_FACTOR = 38,\n  RD_KAFKA_RESP_ERR_INVALID_REPLICA_ASSIGNMENT = 39,\n  RD_KAFKA_RESP_ERR_INVALID_CONFIG = 40,\n  RD_KAFKA_RESP_ERR_NOT_CONTROLLER = 41,\n  RD_KAFKA_RESP_ERR_INVALID_REQUEST = 42,\n  RD_KAFKA_RESP_ERR_UNSUPPORTED_FOR_MESSAGE_FORMAT = 43,\n  RD_KAFKA_RESP_ERR_POLICY_VIOLATION = 44,\n  RD_KAFKA_RESP_ERR_OUT_OF_ORDER_SEQUENCE_NUMBER = 45,\n  RD_KAFKA_RESP_ERR_DUPLICATE_SEQUENCE_NUMBER = 46,\n  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_EPOCH = 47,\n  RD_KAFKA_RESP_ERR_INVALID_TXN_STATE = 48,\n  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_ID_MAPPING = 49,\n  RD_KAFKA_RESP_ERR_INVALID_TRANSACTION_TIMEOUT = 50,\n  RD_KAFKA_RESP_ERR_CONCURRENT_TRANSACTIONS = 51,\n  RD_KAFKA_RESP_ERR_TRANSACTION_COORDINATOR_FENCED = 52,\n  RD_KAFKA_RESP_ERR_TRANSACTIONAL_ID_AUTHORIZATION_FAILED = 53,\n  RD_KAFKA_RESP_ERR_SECURITY_DISABLED = 54,\n  RD_KAFKA_RESP_ERR_OPERATION_NOT_ATTEMPTED = 55,\n  RD_KAFKA_RESP_ERR_KAFKA_STORAGE_ERROR = 56,\n  RD_KAFKA_RESP_ERR_LOG_DIR_NOT_FOUND = 57,\n  RD_KAFKA_RESP_ERR_SASL_AUTHENTICATION_FAILED = 58,\n  RD_KAFKA_RESP_ERR_UNKNOWN_PRODUCER_ID = 59,\n  RD_KAFKA_RESP_ERR_REASSIGNMENT_IN_PROGRESS = 60,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTH_DISABLED = 61,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_NOT_FOUND = 62,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_OWNER_MISMATCH = 63,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_REQUEST_NOT_ALLOWED = 64,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTHORIZATION_FAILED = 65,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_EXPIRED = 66,\n  RD_KAFKA_RESP_ERR_INVALID_PRINCIPAL_TYPE = 67,\n  RD_KAFKA_RESP_ERR_NON_EMPTY_GROUP = 68,\n  RD_KAFKA_RESP_ERR_GROUP_ID_NOT_FOUND = 69,\n  RD_KAFKA_RESP_ERR_FETCH_SESSION_ID_NOT_FOUND = 70,\n  RD_KAFKA_RESP_ERR_INVALID_FETCH_SESSION_EPOCH = 71,\n  RD_KAFKA_RESP_ERR_LISTENER_NOT_FOUND = 72,\n  RD_KAFKA_RESP_ERR_TOPIC_DELETION_DISABLED = 73,\n  RD_KAFKA_RESP_ERR_FENCED_LEADER_EPOCH = 74,\n  RD_KAFKA_RESP_ERR_UNKNOWN_LEADER_EPOCH = 75,\n  RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76,\n  RD_KAFKA_RESP_ERR_STALE_BROKER_EPOCH = 77,\n  RD_KAFKA_RESP_ERR_OFFSET_NOT_AVAILABLE = 78,\n  RD_KAFKA_RESP_ERR_MEMBER_ID_REQUIRED = 79,\n  RD_KAFKA_RESP_ERR_PREFERRED_LEADER_NOT_AVAILABLE = 80,\n  RD_KAFKA_RESP_ERR_GROUP_MAX_SIZE_REACHED = 81,\n  RD_KAFKA_RESP_ERR_FENCED_INSTANCE_ID = 82,\n  RD_KAFKA_RESP_ERR_ELIGIBLE_LEADERS_NOT_AVAILABLE = 83,\n  RD_KAFKA_RESP_ERR_ELECTION_NOT_NEEDED = 84,\n  RD_KAFKA_RESP_ERR_NO_REASSIGNMENT_IN_PROGRESS = 85,\n  RD_KAFKA_RESP_ERR_GROUP_SUBSCRIBED_TO_TOPIC = 86,\n  RD_KAFKA_RESP_ERR_INVALID_RECORD = 87,\n  RD_KAFKA_RESP_ERR_UNSTABLE_OFFSET_COMMIT = 88,\n  RD_KAFKA_RESP_ERR_THROTTLING_QUOTA_EXCEEDED = 89,\n  RD_KAFKA_RESP_ERR_PRODUCER_FENCED = 90,\n  RD_KAFKA_RESP_ERR_RESOURCE_NOT_FOUND = 91,\n  RD_KAFKA_RESP_ERR_DUPLICATE_RESOURCE = 92,\n  RD_KAFKA_RESP_ERR_UNACCEPTABLE_CREDENTIAL = 93,\n  RD_KAFKA_RESP_ERR_INCONSISTENT_VOTER_SET = 94,\n  RD_KAFKA_RESP_ERR_INVALID_UPDATE_VERSION = 95,\n  RD_KAFKA_RESP_ERR_FEATURE_UPDATE_FAILED = 96,\n  RD_KAFKA_RESP_ERR_PRINCIPAL_DESERIALIZATION_FAILURE = 97,\n  RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_ID = 100,\n  RD_KAFKA_RESP_ERR_FENCED_MEMBER_EPOCH = 110,\n  RD_KAFKA_RESP_ERR_UNRELEASED_INSTANCE_ID = 111,\n  RD_KAFKA_RESP_ERR_UNSUPPORTED_ASSIGNOR = 112,\n  RD_KAFKA_RESP_ERR_STALE_MEMBER_EPOCH = 113,\n  RD_KAFKA_RESP_ERR_UNKNOWN_SUBSCRIPTION_ID = 117,\n  RD_KAFKA_RESP_ERR_TELEMETRY_TOO_LARGE = 118,\n  RD_KAFKA_RESP_ERR_END_ALL,\n} rd_kafka_resp_err_t;\nstruct rd_kafka_err_desc {\n  rd_kafka_resp_err_t code;\n  char *name;\n  char *desc;\n};\nvoid rd_kafka_get_err_descs(const struct rd_kafka_err_desc **errdescs, size_t *cntp);\nconst char *rd_kafka_err2str(rd_kafka_resp_err_t err);\nconst char *rd_kafka_err2name(rd_kafka_resp_err_t err);\nrd_kafka_resp_err_t rd_kafka_last_error(void);\nrd_kafka_resp_err_t rd_kafka_errno2err(int errnox);\nint rd_kafka_errno(void);\nrd_kafka_resp_err_t rd_kafka_fatal_error(rd_kafka_t *rk, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_test_fatal_error(rd_kafka_t *rk, rd_kafka_resp_err_t err, const char *reason);\nrd_kafka_resp_err_t rd_kafka_error_code(const rd_kafka_error_t *error);\nconst char *rd_kafka_error_name(const rd_kafka_error_t *error);\nconst char *rd_kafka_error_string(const rd_kafka_error_t *error);\nint rd_kafka_error_is_fatal(const rd_kafka_error_t *error);\nint rd_kafka_error_is_retriable(const rd_kafka_error_t *error);\nint rd_kafka_error_txn_requires_abort(const rd_kafka_error_t *error);\nvoid rd_kafka_error_destroy(rd_kafka_error_t *error);\nrd_kafka_error_t *rd_kafka_error_new(rd_kafka_resp_err_t code, const char *fmt, ...);\ntypedef struct rd_kafka_topic_partition_s {\n  char *topic;\n  int32_t partition;\n  int64_t offset;\n  void *metadata;\n  size_t metadata_size;\n  void *opaque;\n  rd_kafka_resp_err_t err;\n  void *_private;\n} rd_kafka_topic_partition_t;\nvoid rd_kafka_topic_partition_destroy(rd_kafka_topic_partition_t *rktpar);\nvoid rd_kafka_topic_partition_set_leader_epoch(rd_kafka_topic_partition_t *rktpar, int32_t leader_epoch);\nint32_t rd_kafka_topic_partition_get_leader_epoch(const rd_kafka_topic_partition_t *rktpar);\ntypedef struct rd_kafka_topic_partition_list_s {\n  int cnt;\n  int size;\n  rd_kafka_topic_partition_t *elems;\n} rd_kafka_topic_partition_list_t;\nrd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_new(int size);\nvoid rd_kafka_topic_partition_list_destroy(rd_kafka_topic_partition_list_t *rkparlist);\nrd_kafka_topic_partition_t *rd_kafka_topic_partition_list_add(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);\nvoid rd_kafka_topic_partition_list_add_range(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t start, int32_t stop);\nint rd_kafka_topic_partition_list_del(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);\nint rd_kafka_topic_partition_list_del_by_idx(rd_kafka_topic_partition_list_t *rktparlist, int idx);\nrd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_copy(const rd_kafka_topic_partition_list_t *src);\nrd_kafka_resp_err_t rd_kafka_topic_partition_list_set_offset(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition, int64_t offset);\nrd_kafka_topic_partition_t *rd_kafka_topic_partition_list_find(const rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);\nvoid rd_kafka_topic_partition_list_sort(rd_kafka_topic_partition_list_t *rktparlist, int (*cmp)(const void *a, const void *b, void *cmp_opaque), void *cmp_opaque);\ntypedef enum rd_kafka_vtype_t {\n  RD_KAFKA_VTYPE_END,\n  RD_KAFKA_VTYPE_TOPIC,\n  RD_KAFKA_VTYPE_RKT,\n  RD_KAFKA_VTYPE_PARTITION,\n  RD_KAFKA_VTYPE_VALUE,\n  RD_KAFKA_VTYPE_KEY,\n  RD_KAFKA_VTYPE_OPAQUE,\n  RD_KAFKA_VTYPE_MSGFLAGS,\n  RD_KAFKA_VTYPE_TIMESTAMP,\n  RD_KAFKA_VTYPE_HEADER,\n  RD_KAFKA_VTYPE_HEADERS,\n} rd_kafka_vtype_t;\ntypedef struct rd_kafka_vu_s {\n  rd_kafka_vtype_t vtype;\n  union {\n    char *cstr;\n    rd_kafka_topic_t *rkt;\n    int i;\n    int32_t i32;\n    int64_t i64;\n    struct {\n      void *ptr;\n      size_t size;\n    } mem;\n    struct {\n      char *name;\n      void *val;\n      ssize_t size;\n    } header;\n    rd_kafka_headers_t *headers;\n    void *ptr;\n    char _pad[64];\n  } u;\n} rd_kafka_vu_t;\nrd_kafka_headers_t *rd_kafka_headers_new(size_t initial_count);\nvoid rd_kafka_headers_destroy(rd_kafka_headers_t *hdrs);\nrd_kafka_headers_t *rd_kafka_headers_copy(const rd_kafka_headers_t *src);\nrd_kafka_resp_err_t rd_kafka_header_add(rd_kafka_headers_t *hdrs, const char *name, ssize_t name_size, const void *value, ssize_t value_size);\nrd_kafka_resp_err_t rd_kafka_header_remove(rd_kafka_headers_t *hdrs, const char *name);\nrd_kafka_resp_err_t rd_kafka_header_get_last(const rd_kafka_headers_t *hdrs, const char *name, const void **valuep, size_t *sizep);\nrd_kafka_resp_err_t rd_kafka_header_get(const rd_kafka_headers_t *hdrs, size_t idx, const char *name, const void **valuep, size_t *sizep);\nrd_kafka_resp_err_t rd_kafka_header_get_all(const rd_kafka_headers_t *hdrs, size_t idx, const char **namep, const void **valuep, size_t *sizep);\ntypedef struct rd_kafka_message_s {\n  rd_kafka_resp_err_t err;\n  rd_kafka_topic_t *rkt;\n  int32_t partition;\n  void *payload;\n  size_t len;\n  void *key;\n  size_t key_len;\n  int64_t offset;\n  void *_private;\n} rd_kafka_message_t;\nvoid rd_kafka_message_destroy(rd_kafka_message_t *rkmessage);\nconst char *rd_kafka_message_errstr(const rd_kafka_message_t *rkmessage);\nconst char *rd_kafka_message_produce_errstr(const rd_kafka_message_t *rkmessage);\nint64_t rd_kafka_message_timestamp(const rd_kafka_message_t *rkmessage, rd_kafka_timestamp_type_t *tstype);\nint64_t rd_kafka_message_latency(const rd_kafka_message_t *rkmessage);\nint32_t rd_kafka_message_broker_id(const rd_kafka_message_t *rkmessage);\nrd_kafka_resp_err_t rd_kafka_message_headers(const rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);\nrd_kafka_resp_err_t rd_kafka_message_detach_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);\nvoid rd_kafka_message_set_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t *hdrs);\nsize_t rd_kafka_header_cnt(const rd_kafka_headers_t *hdrs);\ntypedef enum {\n  RD_KAFKA_MSG_STATUS_NOT_PERSISTED = 0,\n  RD_KAFKA_MSG_STATUS_POSSIBLY_PERSISTED = 1,\n  RD_KAFKA_MSG_STATUS_PERSISTED = 2,\n} rd_kafka_msg_status_t;\nrd_kafka_msg_status_t rd_kafka_message_status(const rd_kafka_message_t *rkmessage);\nint32_t rd_kafka_message_leader_epoch(const rd_kafka_message_t *rkmessage);\nconst char *rd_kafka_Uuid_base64str(const rd_kafka_Uuid_t *uuid);\nint64_t rd_kafka_Uuid_least_significant_bits(const rd_kafka_Uuid_t *uuid);\nint64_t rd_kafka_Uuid_most_significant_bits(const rd_kafka_Uuid_t *uuid);\nrd_kafka_Uuid_t *rd_kafka_Uuid_new(int64_t most_significant_bits, int64_t least_significant_bits);\nrd_kafka_Uuid_t *rd_kafka_Uuid_copy(const rd_kafka_Uuid_t *uuid);\nvoid rd_kafka_Uuid_destroy(rd_kafka_Uuid_t *uuid);\ntypedef enum {\n  RD_KAFKA_CONF_UNKNOWN = (- 2),\n  RD_KAFKA_CONF_INVALID = (- 1),\n  RD_KAFKA_CONF_OK = 0,\n} rd_kafka_conf_res_t;\nrd_kafka_conf_t *rd_kafka_conf_new(void);\nvoid rd_kafka_conf_destroy(rd_kafka_conf_t *conf);\nrd_kafka_conf_t *rd_kafka_conf_dup(const rd_kafka_conf_t *conf);\nrd_kafka_conf_t *rd_kafka_conf_dup_filter(const rd_kafka_conf_t *conf, size_t filter_cnt, const char **filter);\nconst rd_kafka_conf_t *rd_kafka_conf(rd_kafka_t *rk);\nrd_kafka_conf_res_t rd_kafka_conf_set(rd_kafka_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);\nvoid rd_kafka_conf_set_events(rd_kafka_conf_t *conf, int events);\nvoid rd_kafka_conf_set_background_event_cb(rd_kafka_conf_t *conf, void (*event_cb)(rd_kafka_t *rk, rd_kafka_event_t *rkev, void *opaque));\nvoid rd_kafka_conf_set_dr_cb(rd_kafka_conf_t *conf, void (*dr_cb)(rd_kafka_t *rk, void *payload, size_t len, rd_kafka_resp_err_t err, void *opaque, void *msg_opaque));\nvoid rd_kafka_conf_set_dr_msg_cb(rd_kafka_conf_t *conf, void (*dr_msg_cb)(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, void *opaque));\nvoid rd_kafka_conf_set_consume_cb(rd_kafka_conf_t *conf, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *opaque));\nvoid rd_kafka_conf_set_rebalance_cb(rd_kafka_conf_t *conf, void (*rebalance_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *partitions, void *opaque));\nvoid rd_kafka_conf_set_offset_commit_cb(rd_kafka_conf_t *conf, void (*offset_commit_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *opaque));\nvoid rd_kafka_conf_set_error_cb(rd_kafka_conf_t *conf, void (*error_cb)(rd_kafka_t *rk, int err, const char *reason, void *opaque));\nvoid rd_kafka_conf_set_throttle_cb(rd_kafka_conf_t *conf, void (*throttle_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int throttle_time_ms, void *opaque));\nvoid rd_kafka_conf_set_log_cb(rd_kafka_conf_t *conf, void (*log_cb)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));\nvoid rd_kafka_conf_set_stats_cb(rd_kafka_conf_t *conf, int (*stats_cb)(rd_kafka_t *rk, char *json, size_t json_len, void *opaque));\nvoid rd_kafka_conf_set_oauthbearer_token_refresh_cb(rd_kafka_conf_t *conf, void (*oauthbearer_token_refresh_cb)(rd_kafka_t *rk, const char *oauthbearer_config, void *opaque));\nvoid rd_kafka_conf_enable_sasl_queue(rd_kafka_conf_t *conf, int enable);\nvoid rd_kafka_conf_set_socket_cb(rd_kafka_conf_t *conf, int (*socket_cb)(int domain, int type, int protocol, void *opaque));\nvoid rd_kafka_conf_set_connect_cb(rd_kafka_conf_t *conf, int (*connect_cb)(int sockfd, const struct sockaddr *addr, int addrlen, const char *id, void *opaque));\nvoid rd_kafka_conf_set_closesocket_cb(rd_kafka_conf_t *conf, int (*closesocket_cb)(int sockfd, void *opaque));\nstruct addrinfo;\nvoid rd_kafka_conf_set_resolve_cb(rd_kafka_conf_t *conf, int (*resolve_cb)(const char *node, const char *service, const struct addrinfo *hints, struct addrinfo **res, void *opaque));\nrd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert_verify_cb(rd_kafka_conf_t *conf, int (*ssl_cert_verify_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int *x509_error, int depth, const char *buf, size_t size, char *errstr, size_t errstr_size, void *opaque));\ntypedef enum rd_kafka_cert_type_t {\n  RD_KAFKA_CERT_PUBLIC_KEY,\n  RD_KAFKA_CERT_PRIVATE_KEY,\n  RD_KAFKA_CERT_CA,\n  RD_KAFKA_CERT__CNT,\n} rd_kafka_cert_type_t;\ntypedef enum rd_kafka_cert_enc_t {\n  RD_KAFKA_CERT_ENC_PKCS12,\n  RD_KAFKA_CERT_ENC_DER,\n  RD_KAFKA_CERT_ENC_PEM,\n  RD_KAFKA_CERT_ENC__CNT,\n} rd_kafka_cert_enc_t;\nrd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert(rd_kafka_conf_t *conf, rd_kafka_cert_type_t cert_type, rd_kafka_cert_enc_t cert_enc, const void *buffer, size_t size, char *errstr, size_t errstr_size);\nvoid rd_kafka_conf_set_engine_callback_data(rd_kafka_conf_t *conf, void *callback_data);\nvoid rd_kafka_conf_set_opaque(rd_kafka_conf_t *conf, void *opaque);\nvoid *rd_kafka_opaque(const rd_kafka_t *rk);\nvoid rd_kafka_conf_set_default_topic_conf(rd_kafka_conf_t *conf, rd_kafka_topic_conf_t *tconf);\nrd_kafka_topic_conf_t *rd_kafka_conf_get_default_topic_conf(rd_kafka_conf_t *conf);\nrd_kafka_conf_res_t rd_kafka_conf_get(const rd_kafka_conf_t *conf, const char *name, char *dest, size_t *dest_size);\nrd_kafka_conf_res_t rd_kafka_topic_conf_get(const rd_kafka_topic_conf_t *conf, const char *name, char *dest, size_t *dest_size);\nconst char **rd_kafka_conf_dump(rd_kafka_conf_t *conf, size_t *cntp);\nconst char **rd_kafka_topic_conf_dump(rd_kafka_topic_conf_t *conf, size_t *cntp);\nvoid rd_kafka_conf_dump_free(const char **arr, size_t cnt);\nvoid rd_kafka_conf_properties_show(FILE *fp);\nrd_kafka_topic_conf_t *rd_kafka_topic_conf_new(void);\nrd_kafka_topic_conf_t *rd_kafka_topic_conf_dup(const rd_kafka_topic_conf_t *conf);\nrd_kafka_topic_conf_t *rd_kafka_default_topic_conf_dup(rd_kafka_t *rk);\nvoid rd_kafka_topic_conf_destroy(rd_kafka_topic_conf_t *topic_conf);\nrd_kafka_conf_res_t rd_kafka_topic_conf_set(rd_kafka_topic_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);\nvoid rd_kafka_topic_conf_set_opaque(rd_kafka_topic_conf_t *conf, void *rkt_opaque);\nvoid rd_kafka_topic_conf_set_partitioner_cb(rd_kafka_topic_conf_t *topic_conf, int32_t (*partitioner)(const rd_kafka_topic_t *rkt, const void *keydata, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque));\nvoid rd_kafka_topic_conf_set_msg_order_cmp(rd_kafka_topic_conf_t *topic_conf, int (*msg_order_cmp)(const rd_kafka_message_t *a, const rd_kafka_message_t *b));\nint rd_kafka_topic_partition_available(const rd_kafka_topic_t *rkt, int32_t partition);\nint32_t rd_kafka_msg_partitioner_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_consistent(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_consistent_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_murmur2(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_murmur2_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_fnv1a(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_fnv1a_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nrd_kafka_t *rd_kafka_new(rd_kafka_type_t type, rd_kafka_conf_t *conf, char *errstr, size_t errstr_size);\nvoid rd_kafka_destroy(rd_kafka_t *rk);\nvoid rd_kafka_destroy_flags(rd_kafka_t *rk, int flags);\nconst char *rd_kafka_name(const rd_kafka_t *rk);\nrd_kafka_type_t rd_kafka_type(const rd_kafka_t *rk);\nchar *rd_kafka_memberid(const rd_kafka_t *rk);\nchar *rd_kafka_clusterid(rd_kafka_t *rk, int timeout_ms);\nint32_t rd_kafka_controllerid(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_topic_t *rd_kafka_topic_new(rd_kafka_t *rk, const char *topic, rd_kafka_topic_conf_t *conf);\nvoid rd_kafka_topic_destroy(rd_kafka_topic_t *rkt);\nconst char *rd_kafka_topic_name(const rd_kafka_topic_t *rkt);\nvoid *rd_kafka_topic_opaque(const rd_kafka_topic_t *rkt);\nint rd_kafka_poll(rd_kafka_t *rk, int timeout_ms);\nvoid rd_kafka_yield(rd_kafka_t *rk);\nrd_kafka_resp_err_t rd_kafka_pause_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_resp_err_t rd_kafka_resume_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_resp_err_t rd_kafka_query_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high, int timeout_ms);\nrd_kafka_resp_err_t rd_kafka_get_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high);\nrd_kafka_resp_err_t rd_kafka_offsets_for_times(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets, int timeout_ms);\nvoid *rd_kafka_mem_calloc(rd_kafka_t *rk, size_t num, size_t size);\nvoid *rd_kafka_mem_malloc(rd_kafka_t *rk, size_t size);\nvoid rd_kafka_mem_free(rd_kafka_t *rk, void *ptr);\nrd_kafka_queue_t *rd_kafka_queue_new(rd_kafka_t *rk);\nvoid rd_kafka_queue_destroy(rd_kafka_queue_t *rkqu);\nrd_kafka_queue_t *rd_kafka_queue_get_main(rd_kafka_t *rk);\nrd_kafka_queue_t *rd_kafka_queue_get_sasl(rd_kafka_t *rk);\nrd_kafka_error_t *rd_kafka_sasl_background_callbacks_enable(rd_kafka_t *rk);\nrd_kafka_error_t *rd_kafka_sasl_set_credentials(rd_kafka_t *rk, const char *username, const char *password);\nrd_kafka_queue_t *rd_kafka_queue_get_consumer(rd_kafka_t *rk);\nrd_kafka_queue_t *rd_kafka_queue_get_partition(rd_kafka_t *rk, const char *topic, int32_t partition);\nrd_kafka_queue_t *rd_kafka_queue_get_background(rd_kafka_t *rk);\nvoid rd_kafka_queue_forward(rd_kafka_queue_t *src, rd_kafka_queue_t *dst);\nrd_kafka_resp_err_t rd_kafka_set_log_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu);\nsize_t rd_kafka_queue_length(rd_kafka_queue_t *rkqu);\nvoid rd_kafka_queue_io_event_enable(rd_kafka_queue_t *rkqu, int fd, const void *payload, size_t size);\nvoid rd_kafka_queue_cb_event_enable(rd_kafka_queue_t *rkqu, void (*event_cb)(rd_kafka_t *rk, void *qev_opaque), void *qev_opaque);\nvoid rd_kafka_queue_yield(rd_kafka_queue_t *rkqu);\nint rd_kafka_consume_start(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);\nint rd_kafka_consume_start_queue(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, rd_kafka_queue_t *rkqu);\nint rd_kafka_consume_stop(rd_kafka_topic_t *rkt, int32_t partition);\nrd_kafka_resp_err_t rd_kafka_seek(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, int timeout_ms);\nrd_kafka_error_t *rd_kafka_seek_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms);\nrd_kafka_message_t *rd_kafka_consume(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms);\nssize_t rd_kafka_consume_batch(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);\nint rd_kafka_consume_callback(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);\nrd_kafka_message_t *rd_kafka_consume_queue(rd_kafka_queue_t *rkqu, int timeout_ms);\nssize_t rd_kafka_consume_batch_queue(rd_kafka_queue_t *rkqu, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);\nint rd_kafka_consume_callback_queue(rd_kafka_queue_t *rkqu, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);\nrd_kafka_resp_err_t rd_kafka_offset_store(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);\nrd_kafka_resp_err_t rd_kafka_offsets_store(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets);\nrd_kafka_error_t *rd_kafka_offset_store_message(rd_kafka_message_t *rkmessage);\nrd_kafka_resp_err_t rd_kafka_subscribe(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *topics);\nrd_kafka_resp_err_t rd_kafka_unsubscribe(rd_kafka_t *rk);\nrd_kafka_resp_err_t rd_kafka_subscription(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **topics);\nrd_kafka_message_t *rd_kafka_consumer_poll(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_resp_err_t rd_kafka_consumer_close(rd_kafka_t *rk);\nrd_kafka_error_t *rd_kafka_consumer_close_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu);\nint rd_kafka_consumer_closed(rd_kafka_t *rk);\nrd_kafka_error_t *rd_kafka_incremental_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_error_t *rd_kafka_incremental_unassign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);\nconst char *rd_kafka_rebalance_protocol(rd_kafka_t *rk);\nrd_kafka_resp_err_t rd_kafka_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_resp_err_t rd_kafka_assignment(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **partitions);\nint rd_kafka_assignment_lost(rd_kafka_t *rk);\nrd_kafka_resp_err_t rd_kafka_commit(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, int async);\nrd_kafka_resp_err_t rd_kafka_commit_message(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, int async);\nrd_kafka_resp_err_t rd_kafka_commit_queue(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_queue_t *rkqu, void (*cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *commit_opaque), void *commit_opaque);\nrd_kafka_resp_err_t rd_kafka_committed(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms);\nrd_kafka_resp_err_t rd_kafka_position(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata(rd_kafka_t *rk);\nrd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata_new(const char *group_id);\nrd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata_new_with_genid(const char *group_id, int32_t generation_id, const char *member_id, const char *group_instance_id);\nconst char *rd_kafka_consumer_group_metadata_member_id(const rd_kafka_consumer_group_metadata_t *group_metadata);\nvoid rd_kafka_consumer_group_metadata_destroy(rd_kafka_consumer_group_metadata_t *);\nrd_kafka_error_t *rd_kafka_consumer_group_metadata_write(const rd_kafka_consumer_group_metadata_t *cgmd, void **bufferp, size_t *sizep);\nrd_kafka_error_t *rd_kafka_consumer_group_metadata_read(rd_kafka_consumer_group_metadata_t **cgmdp, const void *buffer, size_t size);\nint rd_kafka_produce(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, void *payload, size_t len, const void *key, size_t keylen, void *msg_opaque);\nrd_kafka_resp_err_t rd_kafka_producev(rd_kafka_t *rk, ...);\nrd_kafka_error_t *rd_kafka_produceva(rd_kafka_t *rk, const rd_kafka_vu_t *vus, size_t cnt);\nint rd_kafka_produce_batch(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, rd_kafka_message_t *rkmessages, int message_cnt);\nrd_kafka_resp_err_t rd_kafka_flush(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_resp_err_t rd_kafka_purge(rd_kafka_t *rk, int purge_flags);\ntypedef struct rd_kafka_metadata_broker {\n  int32_t id;\n  char *host;\n  int port;\n} rd_kafka_metadata_broker_t;\ntypedef struct rd_kafka_metadata_partition {\n  int32_t id;\n  rd_kafka_resp_err_t err;\n  int32_t leader;\n  int replica_cnt;\n  int32_t *replicas;\n  int isr_cnt;\n  int32_t *isrs;\n} rd_kafka_metadata_partition_t;\ntypedef struct rd_kafka_metadata_topic {\n  char *topic;\n  int partition_cnt;\n  struct rd_kafka_metadata_partition *partitions;\n  rd_kafka_resp_err_t err;\n} rd_kafka_metadata_topic_t;\ntypedef struct rd_kafka_metadata {\n  int broker_cnt;\n  struct rd_kafka_metadata_broker *brokers;\n  int topic_cnt;\n  struct rd_kafka_metadata_topic *topics;\n  int32_t orig_broker_id;\n  char *orig_broker_name;\n} rd_kafka_metadata_t;\nrd_kafka_resp_err_t rd_kafka_metadata(rd_kafka_t *rk, int all_topics, rd_kafka_topic_t *only_rkt, const struct rd_kafka_metadata **metadatap, int timeout_ms);\nvoid rd_kafka_metadata_destroy(const struct rd_kafka_metadata *metadata);\ntypedef struct rd_kafka_Node_s rd_kafka_Node_t;\nint rd_kafka_Node_id(const rd_kafka_Node_t *node);\nconst char *rd_kafka_Node_host(const rd_kafka_Node_t *node);\nuint16_t rd_kafka_Node_port(const rd_kafka_Node_t *node);\nconst char *rd_kafka_Node_rack(const rd_kafka_Node_t *node);\nstruct rd_kafka_group_member_info {\n  char *member_id;\n  char *client_id;\n  char *client_host;\n  void *member_metadata;\n  int member_metadata_size;\n  void *member_assignment;\n  int member_assignment_size;\n};\ntypedef enum {\n  RD_KAFKA_CONSUMER_GROUP_STATE_UNKNOWN = 0,\n  RD_KAFKA_CONSUMER_GROUP_STATE_PREPARING_REBALANCE = 1,\n  RD_KAFKA_CONSUMER_GROUP_STATE_COMPLETING_REBALANCE = 2,\n  RD_KAFKA_CONSUMER_GROUP_STATE_STABLE = 3,\n  RD_KAFKA_CONSUMER_GROUP_STATE_DEAD = 4,\n  RD_KAFKA_CONSUMER_GROUP_STATE_EMPTY = 5,\n  RD_KAFKA_CONSUMER_GROUP_STATE__CNT,\n} rd_kafka_consumer_group_state_t;\ntypedef enum {\n  RD_KAFKA_CONSUMER_GROUP_TYPE_UNKNOWN = 0,\n  RD_KAFKA_CONSUMER_GROUP_TYPE_CONSUMER = 1,\n  RD_KAFKA_CONSUMER_GROUP_TYPE_CLASSIC = 2,\n  RD_KAFKA_CONSUMER_GROUP_TYPE__CNT,\n} rd_kafka_consumer_group_type_t;\nstruct rd_kafka_group_info {\n  struct rd_kafka_metadata_broker broker;\n  char *group;\n  rd_kafka_resp_err_t err;\n  char *state;\n  char *protocol_type;\n  char *protocol;\n  struct rd_kafka_group_member_info *members;\n  int member_cnt;\n};\nstruct rd_kafka_group_list {\n  struct rd_kafka_group_info *groups;\n  int group_cnt;\n};\nrd_kafka_resp_err_t rd_kafka_list_groups(rd_kafka_t *rk, const char *group, const struct rd_kafka_group_list **grplistp, int timeout_ms);\nconst char *rd_kafka_consumer_group_state_name(rd_kafka_consumer_group_state_t state);\nrd_kafka_consumer_group_state_t rd_kafka_consumer_group_state_code(const char *name);\nconst char *rd_kafka_consumer_group_type_name(rd_kafka_consumer_group_type_t type);\nrd_kafka_consumer_group_type_t rd_kafka_consumer_group_type_code(const char *name);\nvoid rd_kafka_group_list_destroy(const struct rd_kafka_group_list *grplist);\nint rd_kafka_brokers_add(rd_kafka_t *rk, const char *brokerlist);\nvoid rd_kafka_set_logger(rd_kafka_t *rk, void (*func)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));\nvoid rd_kafka_set_log_level(rd_kafka_t *rk, int level);\nvoid rd_kafka_log_print(const rd_kafka_t *rk, int level, const char *fac, const char *buf);\nvoid rd_kafka_log_syslog(const rd_kafka_t *rk, int level, const char *fac, const char *buf);\nint rd_kafka_outq_len(rd_kafka_t *rk);\nvoid rd_kafka_dump(FILE *fp, rd_kafka_t *rk);\nint rd_kafka_thread_cnt(void);\ntypedef enum rd_kafka_thread_type_t {\n  RD_KAFKA_THREAD_MAIN,\n  RD_KAFKA_THREAD_BACKGROUND,\n  RD_KAFKA_THREAD_BROKER,\n} rd_kafka_thread_type_t;\nint rd_kafka_wait_destroyed(int timeout_ms);\nint rd_kafka_unittest(void);\nrd_kafka_resp_err_t rd_kafka_poll_set_consumer(rd_kafka_t *rk);\ntypedef int rd_kafka_event_type_t;\nrd_kafka_event_type_t rd_kafka_event_type(const rd_kafka_event_t *rkev);\nconst char *rd_kafka_event_name(const rd_kafka_event_t *rkev);\nvoid rd_kafka_event_destroy(rd_kafka_event_t *rkev);\nconst rd_kafka_message_t *rd_kafka_event_message_next(rd_kafka_event_t *rkev);\nsize_t rd_kafka_event_message_array(rd_kafka_event_t *rkev, const rd_kafka_message_t **rkmessages, size_t size);\nsize_t rd_kafka_event_message_count(rd_kafka_event_t *rkev);\nconst char *rd_kafka_event_config_string(rd_kafka_event_t *rkev);\nrd_kafka_resp_err_t rd_kafka_event_error(rd_kafka_event_t *rkev);\nconst char *rd_kafka_event_error_string(rd_kafka_event_t *rkev);\nint rd_kafka_event_error_is_fatal(rd_kafka_event_t *rkev);\nvoid *rd_kafka_event_opaque(rd_kafka_event_t *rkev);\nint rd_kafka_event_log(rd_kafka_event_t *rkev, const char **fac, const char **str, int *level);\nint rd_kafka_event_debug_contexts(rd_kafka_event_t *rkev, char *dst, size_t dstsize);\nconst char *rd_kafka_event_stats(rd_kafka_event_t *rkev);\nrd_kafka_topic_partition_list_t *rd_kafka_event_topic_partition_list(rd_kafka_event_t *rkev);\nrd_kafka_topic_partition_t *rd_kafka_event_topic_partition(rd_kafka_event_t *rkev);\ntypedef rd_kafka_event_t rd_kafka_CreateTopics_result_t;\ntypedef rd_kafka_event_t rd_kafka_DeleteTopics_result_t;\ntypedef rd_kafka_event_t rd_kafka_CreateAcls_result_t;\ntypedef rd_kafka_event_t rd_kafka_DescribeAcls_result_t;\ntypedef rd_kafka_event_t rd_kafka_DeleteAcls_result_t;\ntypedef rd_kafka_event_t rd_kafka_CreatePartitions_result_t;\ntypedef rd_kafka_event_t rd_kafka_AlterConfigs_result_t;\ntypedef rd_kafka_event_t rd_kafka_IncrementalAlterConfigs_result_t;\ntypedef rd_kafka_event_t rd_kafka_DescribeConfigs_result_t;\ntypedef rd_kafka_event_t rd_kafka_DeleteRecords_result_t;\ntypedef rd_kafka_event_t rd_kafka_ListConsumerGroups_result_t;\ntypedef rd_kafka_event_t rd_kafka_DescribeConsumerGroups_result_t;\ntypedef rd_kafka_event_t rd_kafka_DeleteGroups_result_t;\ntypedef rd_kafka_event_t rd_kafka_DeleteConsumerGroupOffsets_result_t;\ntypedef rd_kafka_event_t rd_kafka_AlterConsumerGroupOffsets_result_t;\ntypedef rd_kafka_event_t rd_kafka_ListConsumerGroupOffsets_result_t;\ntypedef rd_kafka_event_t rd_kafka_DescribeTopics_result_t;\ntypedef rd_kafka_event_t rd_kafka_DescribeCluster_result_t;\ntypedef rd_kafka_event_t rd_kafka_DescribeUserScramCredentials_result_t;\ntypedef rd_kafka_event_t rd_kafka_AlterUserScramCredentials_result_t;\ntypedef rd_kafka_event_t rd_kafka_ListOffsets_result_t;\ntypedef rd_kafka_event_t rd_kafka_ElectLeaders_result_t;\nconst rd_kafka_CreateTopics_result_t *rd_kafka_event_CreateTopics_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DeleteTopics_result_t *rd_kafka_event_DeleteTopics_result(rd_kafka_event_t *rkev);\nconst rd_kafka_CreatePartitions_result_t *rd_kafka_event_CreatePartitions_result(rd_kafka_event_t *rkev);\nconst rd_kafka_AlterConfigs_result_t *rd_kafka_event_AlterConfigs_result(rd_kafka_event_t *rkev);\nconst rd_kafka_IncrementalAlterConfigs_result_t *rd_kafka_event_IncrementalAlterConfigs_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DescribeConfigs_result_t *rd_kafka_event_DescribeConfigs_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DeleteRecords_result_t *rd_kafka_event_DeleteRecords_result(rd_kafka_event_t *rkev);\nconst rd_kafka_ListConsumerGroups_result_t *rd_kafka_event_ListConsumerGroups_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DescribeConsumerGroups_result_t *rd_kafka_event_DescribeConsumerGroups_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DescribeTopics_result_t *rd_kafka_event_DescribeTopics_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DescribeCluster_result_t *rd_kafka_event_DescribeCluster_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DeleteGroups_result_t *rd_kafka_event_DeleteGroups_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DeleteConsumerGroupOffsets_result_t *rd_kafka_event_DeleteConsumerGroupOffsets_result(rd_kafka_event_t *rkev);\nconst rd_kafka_CreateAcls_result_t *rd_kafka_event_CreateAcls_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DescribeAcls_result_t *rd_kafka_event_DescribeAcls_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DeleteAcls_result_t *rd_kafka_event_DeleteAcls_result(rd_kafka_event_t *rkev);\nconst rd_kafka_ListConsumerGroupOffsets_result_t *rd_kafka_event_ListConsumerGroupOffsets_result(rd_kafka_event_t *rkev);\nconst rd_kafka_AlterConsumerGroupOffsets_result_t *rd_kafka_event_AlterConsumerGroupOffsets_result(rd_kafka_event_t *rkev);\nconst rd_kafka_ListOffsets_result_t *rd_kafka_event_ListOffsets_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DescribeUserScramCredentials_result_t *rd_kafka_event_DescribeUserScramCredentials_result(rd_kafka_event_t *rkev);\nconst rd_kafka_AlterUserScramCredentials_result_t *rd_kafka_event_AlterUserScramCredentials_result(rd_kafka_event_t *rkev);\nconst rd_kafka_ElectLeaders_result_t *rd_kafka_event_ElectLeaders_result(rd_kafka_event_t *rkev);\nrd_kafka_event_t *rd_kafka_queue_poll(rd_kafka_queue_t *rkqu, int timeout_ms);\nint rd_kafka_queue_poll_callback(rd_kafka_queue_t *rkqu, int timeout_ms);\ntypedef rd_kafka_resp_err_t (rd_kafka_plugin_f_conf_init_t)(rd_kafka_conf_t *conf, void **plug_opaquep, char *errstr, size_t errstr_size);\ntypedef rd_kafka_conf_res_t (rd_kafka_interceptor_f_on_conf_set_t)(rd_kafka_conf_t *conf, const char *name, const char *val, char *errstr, size_t errstr_size, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_dup_t)(rd_kafka_conf_t *new_conf, const rd_kafka_conf_t *old_conf, size_t filter_cnt, const char **filter, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_destroy_t)(void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_new_t)(rd_kafka_t *rk, const rd_kafka_conf_t *conf, void *ic_opaque, char *errstr, size_t errstr_size);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_destroy_t)(rd_kafka_t *rk, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_send_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_acknowledgement_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_consume_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_commit_t)(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_resp_err_t err, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_request_sent_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_response_received_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, int64_t rtt, rd_kafka_resp_err_t err, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_start_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_exit_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_broker_state_change_t)(rd_kafka_t *rk, int32_t broker_id, const char *secproto, const char *name, int port, const char *state, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_set(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_set_t *on_conf_set, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_dup(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_dup_t *on_conf_dup, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_destroy(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_destroy_t *on_conf_destroy, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_new(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_new_t *on_new, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_destroy(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_destroy_t *on_destroy, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_send(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_send_t *on_send, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_acknowledgement(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_acknowledgement_t *on_acknowledgement, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_consume(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_consume_t *on_consume, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_commit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_commit_t *on_commit, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_request_sent(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_request_sent_t *on_request_sent, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_response_received(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_response_received_t *on_response_received, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_start(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_start_t *on_thread_start, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_exit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_exit_t *on_thread_exit, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_broker_state_change(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_broker_state_change_t *on_broker_state_change, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_topic_result_error(const rd_kafka_topic_result_t *topicres);\nconst char *rd_kafka_topic_result_error_string(const rd_kafka_topic_result_t *topicres);\nconst char *rd_kafka_topic_result_name(const rd_kafka_topic_result_t *topicres);\nconst rd_kafka_error_t *rd_kafka_group_result_error(const rd_kafka_group_result_t *groupres);\nconst char *rd_kafka_group_result_name(const rd_kafka_group_result_t *groupres);\nconst rd_kafka_topic_partition_list_t *rd_kafka_group_result_partitions(const rd_kafka_group_result_t *groupres);\nconst rd_kafka_topic_partition_t *rd_kafka_topic_partition_result_partition(const rd_kafka_topic_partition_result_t *partition_result);\nconst rd_kafka_error_t *rd_kafka_topic_partition_result_error(const rd_kafka_topic_partition_result_t *partition_result);\ntypedef enum rd_kafka_admin_op_t {\n  RD_KAFKA_ADMIN_OP_ANY = 0,\n  RD_KAFKA_ADMIN_OP_CREATETOPICS,\n  RD_KAFKA_ADMIN_OP_DELETETOPICS,\n  RD_KAFKA_ADMIN_OP_CREATEPARTITIONS,\n  RD_KAFKA_ADMIN_OP_ALTERCONFIGS,\n  RD_KAFKA_ADMIN_OP_DESCRIBECONFIGS,\n  RD_KAFKA_ADMIN_OP_DELETERECORDS,\n  RD_KAFKA_ADMIN_OP_DELETEGROUPS,\n  RD_KAFKA_ADMIN_OP_DELETECONSUMERGROUPOFFSETS,\n  RD_KAFKA_ADMIN_OP_CREATEACLS,\n  RD_KAFKA_ADMIN_OP_DESCRIBEACLS,\n  RD_KAFKA_ADMIN_OP_DELETEACLS,\n  RD_KAFKA_ADMIN_OP_LISTCONSUMERGROUPS,\n  RD_KAFKA_ADMIN_OP_DESCRIBECONSUMERGROUPS,\n  RD_KAFKA_ADMIN_OP_LISTCONSUMERGROUPOFFSETS,\n  RD_KAFKA_ADMIN_OP_ALTERCONSUMERGROUPOFFSETS,\n  RD_KAFKA_ADMIN_OP_INCREMENTALALTERCONFIGS,\n  RD_KAFKA_ADMIN_OP_DESCRIBEUSERSCRAMCREDENTIALS,\n  RD_KAFKA_ADMIN_OP_ALTERUSERSCRAMCREDENTIALS,\n  RD_KAFKA_ADMIN_OP_DESCRIBETOPICS,\n  RD_KAFKA_ADMIN_OP_DESCRIBECLUSTER,\n  RD_KAFKA_ADMIN_OP_LISTOFFSETS,\n  RD_KAFKA_ADMIN_OP_ELECTLEADERS,\n  RD_KAFKA_ADMIN_OP__CNT,\n} rd_kafka_admin_op_t;\ntypedef struct rd_kafka_AdminOptions_s rd_kafka_AdminOptions_t;\ntypedef enum rd_kafka_IsolationLevel_t {\n  RD_KAFKA_ISOLATION_LEVEL_READ_UNCOMMITTED = 0,\n  RD_KAFKA_ISOLATION_LEVEL_READ_COMMITTED = 1,\n} rd_kafka_IsolationLevel_t;\nrd_kafka_AdminOptions_t *rd_kafka_AdminOptions_new(rd_kafka_t *rk, rd_kafka_admin_op_t for_api);\nvoid rd_kafka_AdminOptions_destroy(rd_kafka_AdminOptions_t *options);\nrd_kafka_resp_err_t rd_kafka_AdminOptions_set_request_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_AdminOptions_set_operation_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_AdminOptions_set_validate_only(rd_kafka_AdminOptions_t *options, int true_or_false, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_AdminOptions_set_broker(rd_kafka_AdminOptions_t *options, int32_t broker_id, char *errstr, size_t errstr_size);\nrd_kafka_error_t *rd_kafka_AdminOptions_set_require_stable_offsets(rd_kafka_AdminOptions_t *options, int true_or_false);\nrd_kafka_error_t *rd_kafka_AdminOptions_set_include_authorized_operations(rd_kafka_AdminOptions_t *options, int true_or_false);\nrd_kafka_error_t *rd_kafka_AdminOptions_set_match_consumer_group_states(rd_kafka_AdminOptions_t *options, const rd_kafka_consumer_group_state_t *consumer_group_states, size_t consumer_group_states_cnt);\nrd_kafka_error_t *rd_kafka_AdminOptions_set_match_consumer_group_types(rd_kafka_AdminOptions_t *options, const rd_kafka_consumer_group_type_t *consumer_group_types, size_t consumer_group_types_cnt);\nrd_kafka_error_t *rd_kafka_AdminOptions_set_isolation_level(rd_kafka_AdminOptions_t *options, rd_kafka_IsolationLevel_t value);\nvoid rd_kafka_AdminOptions_set_opaque(rd_kafka_AdminOptions_t *options, void *ev_opaque);\ntypedef enum rd_kafka_AclOperation_t {\n  RD_KAFKA_ACL_OPERATION_UNKNOWN = 0,\n  RD_KAFKA_ACL_OPERATION_ANY = 1,\n  RD_KAFKA_ACL_OPERATION_ALL = 2,\n  RD_KAFKA_ACL_OPERATION_READ = 3,\n  RD_KAFKA_ACL_OPERATION_WRITE = 4,\n  RD_KAFKA_ACL_OPERATION_CREATE = 5,\n  RD_KAFKA_ACL_OPERATION_DELETE = 6,\n  RD_KAFKA_ACL_OPERATION_ALTER = 7,\n  RD_KAFKA_ACL_OPERATION_DESCRIBE = 8,\n  RD_KAFKA_ACL_OPERATION_CLUSTER_ACTION = 9,\n  RD_KAFKA_ACL_OPERATION_DESCRIBE_CONFIGS = 10,\n  RD_KAFKA_ACL_OPERATION_ALTER_CONFIGS = 11,\n  RD_KAFKA_ACL_OPERATION_IDEMPOTENT_WRITE = 12,\n  RD_KAFKA_ACL_OPERATION__CNT,\n} rd_kafka_AclOperation_t;\ntypedef struct rd_kafka_NewTopic_s rd_kafka_NewTopic_t;\nrd_kafka_NewTopic_t *rd_kafka_NewTopic_new(const char *topic, int num_partitions, int replication_factor, char *errstr, size_t errstr_size);\nvoid rd_kafka_NewTopic_destroy(rd_kafka_NewTopic_t *new_topic);\nvoid rd_kafka_NewTopic_destroy_array(rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt);\nrd_kafka_resp_err_t rd_kafka_NewTopic_set_replica_assignment(rd_kafka_NewTopic_t *new_topic, int32_t partition, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_NewTopic_set_config(rd_kafka_NewTopic_t *new_topic, const char *name, const char *value);\nvoid rd_kafka_CreateTopics(rd_kafka_t *rk, rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_topic_result_t **rd_kafka_CreateTopics_result_topics(const rd_kafka_CreateTopics_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_DeleteTopic_s rd_kafka_DeleteTopic_t;\nrd_kafka_DeleteTopic_t *rd_kafka_DeleteTopic_new(const char *topic);\nvoid rd_kafka_DeleteTopic_destroy(rd_kafka_DeleteTopic_t *del_topic);\nvoid rd_kafka_DeleteTopic_destroy_array(rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt);\nvoid rd_kafka_DeleteTopics(rd_kafka_t *rk, rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_topic_result_t **rd_kafka_DeleteTopics_result_topics(const rd_kafka_DeleteTopics_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_NewPartitions_s rd_kafka_NewPartitions_t;\nrd_kafka_NewPartitions_t *rd_kafka_NewPartitions_new(const char *topic, size_t new_total_cnt, char *errstr, size_t errstr_size);\nvoid rd_kafka_NewPartitions_destroy(rd_kafka_NewPartitions_t *new_parts);\nvoid rd_kafka_NewPartitions_destroy_array(rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt);\nrd_kafka_resp_err_t rd_kafka_NewPartitions_set_replica_assignment(rd_kafka_NewPartitions_t *new_parts, int32_t new_partition_idx, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);\nvoid rd_kafka_CreatePartitions(rd_kafka_t *rk, rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_topic_result_t **rd_kafka_CreatePartitions_result_topics(const rd_kafka_CreatePartitions_result_t *result, size_t *cntp);\ntypedef enum rd_kafka_ConfigSource_t {\n  RD_KAFKA_CONFIG_SOURCE_UNKNOWN_CONFIG = 0,\n  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_TOPIC_CONFIG = 1,\n  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_BROKER_CONFIG = 2,\n  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_DEFAULT_BROKER_CONFIG = 3,\n  RD_KAFKA_CONFIG_SOURCE_STATIC_BROKER_CONFIG = 4,\n  RD_KAFKA_CONFIG_SOURCE_DEFAULT_CONFIG = 5,\n  RD_KAFKA_CONFIG_SOURCE__CNT,\n} rd_kafka_ConfigSource_t;\nconst char *rd_kafka_ConfigSource_name(rd_kafka_ConfigSource_t confsource);\ntypedef struct rd_kafka_ConfigEntry_s rd_kafka_ConfigEntry_t;\nconst char *rd_kafka_ConfigEntry_name(const rd_kafka_ConfigEntry_t *entry);\nconst char *rd_kafka_ConfigEntry_value(const rd_kafka_ConfigEntry_t *entry);\nrd_kafka_ConfigSource_t rd_kafka_ConfigEntry_source(const rd_kafka_ConfigEntry_t *entry);\nint rd_kafka_ConfigEntry_is_read_only(const rd_kafka_ConfigEntry_t *entry);\nint rd_kafka_ConfigEntry_is_default(const rd_kafka_ConfigEntry_t *entry);\nint rd_kafka_ConfigEntry_is_sensitive(const rd_kafka_ConfigEntry_t *entry);\nint rd_kafka_ConfigEntry_is_synonym(const rd_kafka_ConfigEntry_t *entry);\nconst rd_kafka_ConfigEntry_t **rd_kafka_ConfigEntry_synonyms(const rd_kafka_ConfigEntry_t *entry, size_t *cntp);\ntypedef enum rd_kafka_ResourceType_t {\n  RD_KAFKA_RESOURCE_UNKNOWN = 0,\n  RD_KAFKA_RESOURCE_ANY = 1,\n  RD_KAFKA_RESOURCE_TOPIC = 2,\n  RD_KAFKA_RESOURCE_GROUP = 3,\n  RD_KAFKA_RESOURCE_BROKER = 4,\n  RD_KAFKA_RESOURCE_TRANSACTIONAL_ID = 5,\n  RD_KAFKA_RESOURCE__CNT,\n} rd_kafka_ResourceType_t;\ntypedef enum rd_kafka_ResourcePatternType_t {\n  RD_KAFKA_RESOURCE_PATTERN_UNKNOWN = 0,\n  RD_KAFKA_RESOURCE_PATTERN_ANY = 1,\n  RD_KAFKA_RESOURCE_PATTERN_MATCH = 2,\n  RD_KAFKA_RESOURCE_PATTERN_LITERAL = 3,\n  RD_KAFKA_RESOURCE_PATTERN_PREFIXED = 4,\n  RD_KAFKA_RESOURCE_PATTERN_TYPE__CNT,\n} rd_kafka_ResourcePatternType_t;\ntypedef enum rd_kafka_AlterConfigOpType_t {\n  RD_KAFKA_ALTER_CONFIG_OP_TYPE_SET = 0,\n  RD_KAFKA_ALTER_CONFIG_OP_TYPE_DELETE = 1,\n  RD_KAFKA_ALTER_CONFIG_OP_TYPE_APPEND = 2,\n  RD_KAFKA_ALTER_CONFIG_OP_TYPE_SUBTRACT = 3,\n  RD_KAFKA_ALTER_CONFIG_OP_TYPE__CNT,\n} rd_kafka_AlterConfigOpType_t;\nconst char *rd_kafka_ResourcePatternType_name(rd_kafka_ResourcePatternType_t resource_pattern_type);\nconst char *rd_kafka_ResourceType_name(rd_kafka_ResourceType_t restype);\ntypedef struct rd_kafka_ConfigResource_s rd_kafka_ConfigResource_t;\nrd_kafka_ConfigResource_t *rd_kafka_ConfigResource_new(rd_kafka_ResourceType_t restype, const char *resname);\nvoid rd_kafka_ConfigResource_destroy(rd_kafka_ConfigResource_t *config);\nvoid rd_kafka_ConfigResource_destroy_array(rd_kafka_ConfigResource_t **config, size_t config_cnt);\nrd_kafka_resp_err_t rd_kafka_ConfigResource_set_config(rd_kafka_ConfigResource_t *config, const char *name, const char *value);\nrd_kafka_error_t *rd_kafka_ConfigResource_add_incremental_config(rd_kafka_ConfigResource_t *config, const char *name, rd_kafka_AlterConfigOpType_t op_type, const char *value);\nconst rd_kafka_ConfigEntry_t **rd_kafka_ConfigResource_configs(const rd_kafka_ConfigResource_t *config, size_t *cntp);\nrd_kafka_ResourceType_t rd_kafka_ConfigResource_type(const rd_kafka_ConfigResource_t *config);\nconst char *rd_kafka_ConfigResource_name(const rd_kafka_ConfigResource_t *config);\nrd_kafka_resp_err_t rd_kafka_ConfigResource_error(const rd_kafka_ConfigResource_t *config);\nconst char *rd_kafka_ConfigResource_error_string(const rd_kafka_ConfigResource_t *config);\nvoid rd_kafka_AlterConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_ConfigResource_t **rd_kafka_AlterConfigs_result_resources(const rd_kafka_AlterConfigs_result_t *result, size_t *cntp);\nvoid rd_kafka_IncrementalAlterConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_ConfigResource_t **rd_kafka_IncrementalAlterConfigs_result_resources(const rd_kafka_IncrementalAlterConfigs_result_t *result, size_t *cntp);\nvoid rd_kafka_DescribeConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_ConfigResource_t **rd_kafka_DescribeConfigs_result_resources(const rd_kafka_DescribeConfigs_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_DeleteRecords_s rd_kafka_DeleteRecords_t;\nrd_kafka_DeleteRecords_t *rd_kafka_DeleteRecords_new(const rd_kafka_topic_partition_list_t *before_offsets);\nvoid rd_kafka_DeleteRecords_destroy(rd_kafka_DeleteRecords_t *del_records);\nvoid rd_kafka_DeleteRecords_destroy_array(rd_kafka_DeleteRecords_t **del_records, size_t del_record_cnt);\nvoid rd_kafka_DeleteRecords(rd_kafka_t *rk, rd_kafka_DeleteRecords_t **del_records, size_t del_record_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_topic_partition_list_t *rd_kafka_DeleteRecords_result_offsets(const rd_kafka_DeleteRecords_result_t *result);\ntypedef struct rd_kafka_TopicCollection_s rd_kafka_TopicCollection_t;\ntypedef struct rd_kafka_TopicPartitionInfo_s rd_kafka_TopicPartitionInfo_t;\ntypedef struct rd_kafka_TopicDescription_s rd_kafka_TopicDescription_t;\nrd_kafka_TopicCollection_t *rd_kafka_TopicCollection_of_topic_names(const char **topics, size_t topics_cnt);\nvoid rd_kafka_TopicCollection_destroy(rd_kafka_TopicCollection_t *topics);\nvoid rd_kafka_DescribeTopics(rd_kafka_t *rk, const rd_kafka_TopicCollection_t *topics, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_TopicDescription_t **rd_kafka_DescribeTopics_result_topics(const rd_kafka_DescribeTopics_result_t *result, size_t *cntp);\nconst rd_kafka_TopicPartitionInfo_t **rd_kafka_TopicDescription_partitions(const rd_kafka_TopicDescription_t *topicdesc, size_t *cntp);\nconst int rd_kafka_TopicPartitionInfo_partition(const rd_kafka_TopicPartitionInfo_t *partition);\nconst rd_kafka_Node_t *rd_kafka_TopicPartitionInfo_leader(const rd_kafka_TopicPartitionInfo_t *partition);\nconst rd_kafka_Node_t **rd_kafka_TopicPartitionInfo_isr(const rd_kafka_TopicPartitionInfo_t *partition, size_t *cntp);\nconst rd_kafka_Node_t **rd_kafka_TopicPartitionInfo_replicas(const rd_kafka_TopicPartitionInfo_t *partition, size_t *cntp);\nconst rd_kafka_AclOperation_t *rd_kafka_TopicDescription_authorized_operations(const rd_kafka_TopicDescription_t *topicdesc, size_t *cntp);\nconst char *rd_kafka_TopicDescription_name(const rd_kafka_TopicDescription_t *topicdesc);\nconst rd_kafka_Uuid_t *rd_kafka_TopicDescription_topic_id(const rd_kafka_TopicDescription_t *topicdesc);\nint rd_kafka_TopicDescription_is_internal(const rd_kafka_TopicDescription_t *topicdesc);\nconst rd_kafka_error_t *rd_kafka_TopicDescription_error(const rd_kafka_TopicDescription_t *topicdesc);\nvoid rd_kafka_DescribeCluster(rd_kafka_t *rk, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_Node_t **rd_kafka_DescribeCluster_result_nodes(const rd_kafka_DescribeCluster_result_t *result, size_t *cntp);\nconst rd_kafka_AclOperation_t *rd_kafka_DescribeCluster_result_authorized_operations(const rd_kafka_DescribeCluster_result_t *result, size_t *cntp);\nconst rd_kafka_Node_t *rd_kafka_DescribeCluster_result_controller(const rd_kafka_DescribeCluster_result_t *result);\nconst char *rd_kafka_DescribeCluster_result_cluster_id(const rd_kafka_DescribeCluster_result_t *result);\ntypedef struct rd_kafka_ConsumerGroupListing_s rd_kafka_ConsumerGroupListing_t;\ntypedef struct rd_kafka_ListConsumerGroupsResult_s rd_kafka_ListConsumerGroupsResult_t;\nvoid rd_kafka_ListConsumerGroups(rd_kafka_t *rk, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst char *rd_kafka_ConsumerGroupListing_group_id(const rd_kafka_ConsumerGroupListing_t *grplist);\nint rd_kafka_ConsumerGroupListing_is_simple_consumer_group(const rd_kafka_ConsumerGroupListing_t *grplist);\nrd_kafka_consumer_group_state_t rd_kafka_ConsumerGroupListing_state(const rd_kafka_ConsumerGroupListing_t *grplist);\nrd_kafka_consumer_group_type_t rd_kafka_ConsumerGroupListing_type(const rd_kafka_ConsumerGroupListing_t *grplist);\nconst rd_kafka_ConsumerGroupListing_t **rd_kafka_ListConsumerGroups_result_valid(const rd_kafka_ListConsumerGroups_result_t *result, size_t *cntp);\nconst rd_kafka_error_t **rd_kafka_ListConsumerGroups_result_errors(const rd_kafka_ListConsumerGroups_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_ConsumerGroupDescription_s rd_kafka_ConsumerGroupDescription_t;\ntypedef struct rd_kafka_MemberDescription_s rd_kafka_MemberDescription_t;\ntypedef struct rd_kafka_MemberAssignment_s rd_kafka_MemberAssignment_t;\nvoid rd_kafka_DescribeConsumerGroups(rd_kafka_t *rk, const char **groups, size_t groups_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_ConsumerGroupDescription_t **rd_kafka_DescribeConsumerGroups_result_groups(const rd_kafka_DescribeConsumerGroups_result_t *result, size_t *cntp);\nconst char *rd_kafka_ConsumerGroupDescription_group_id(const rd_kafka_ConsumerGroupDescription_t *grpdesc);\nconst rd_kafka_error_t *rd_kafka_ConsumerGroupDescription_error(const rd_kafka_ConsumerGroupDescription_t *grpdesc);\nint rd_kafka_ConsumerGroupDescription_is_simple_consumer_group(const rd_kafka_ConsumerGroupDescription_t *grpdesc);\nconst char *rd_kafka_ConsumerGroupDescription_partition_assignor(const rd_kafka_ConsumerGroupDescription_t *grpdesc);\nconst rd_kafka_AclOperation_t *rd_kafka_ConsumerGroupDescription_authorized_operations(const rd_kafka_ConsumerGroupDescription_t *grpdesc, size_t *cntp);\nrd_kafka_consumer_group_state_t rd_kafka_ConsumerGroupDescription_state(const rd_kafka_ConsumerGroupDescription_t *grpdesc);\nconst rd_kafka_Node_t *rd_kafka_ConsumerGroupDescription_coordinator(const rd_kafka_ConsumerGroupDescription_t *grpdesc);\nsize_t rd_kafka_ConsumerGroupDescription_member_count(const rd_kafka_ConsumerGroupDescription_t *grpdesc);\nconst rd_kafka_MemberDescription_t *rd_kafka_ConsumerGroupDescription_member(const rd_kafka_ConsumerGroupDescription_t *grpdesc, size_t idx);\nconst char *rd_kafka_MemberDescription_client_id(const rd_kafka_MemberDescription_t *member);\nconst char *rd_kafka_MemberDescription_group_instance_id(const rd_kafka_MemberDescription_t *member);\nconst char *rd_kafka_MemberDescription_consumer_id(const rd_kafka_MemberDescription_t *member);\nconst char *rd_kafka_MemberDescription_host(const rd_kafka_MemberDescription_t *member);\nconst rd_kafka_MemberAssignment_t *rd_kafka_MemberDescription_assignment(const rd_kafka_MemberDescription_t *member);\nconst rd_kafka_topic_partition_list_t *rd_kafka_MemberAssignment_partitions(const rd_kafka_MemberAssignment_t *assignment);\ntypedef struct rd_kafka_DeleteGroup_s rd_kafka_DeleteGroup_t;\nrd_kafka_DeleteGroup_t *rd_kafka_DeleteGroup_new(const char *group);\nvoid rd_kafka_DeleteGroup_destroy(rd_kafka_DeleteGroup_t *del_group);\nvoid rd_kafka_DeleteGroup_destroy_array(rd_kafka_DeleteGroup_t **del_groups, size_t del_group_cnt);\nvoid rd_kafka_DeleteGroups(rd_kafka_t *rk, rd_kafka_DeleteGroup_t **del_groups, size_t del_group_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_group_result_t **rd_kafka_DeleteGroups_result_groups(const rd_kafka_DeleteGroups_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_ListConsumerGroupOffsets_s rd_kafka_ListConsumerGroupOffsets_t;\nrd_kafka_ListConsumerGroupOffsets_t *rd_kafka_ListConsumerGroupOffsets_new(const char *group_id, const rd_kafka_topic_partition_list_t *partitions);\nvoid rd_kafka_ListConsumerGroupOffsets_destroy(rd_kafka_ListConsumerGroupOffsets_t *list_grpoffsets);\nvoid rd_kafka_ListConsumerGroupOffsets_destroy_array(rd_kafka_ListConsumerGroupOffsets_t **list_grpoffsets, size_t list_grpoffset_cnt);\nvoid rd_kafka_ListConsumerGroupOffsets(rd_kafka_t *rk, rd_kafka_ListConsumerGroupOffsets_t **list_grpoffsets, size_t list_grpoffsets_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_group_result_t **rd_kafka_ListConsumerGroupOffsets_result_groups(const rd_kafka_ListConsumerGroupOffsets_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_AlterConsumerGroupOffsets_s rd_kafka_AlterConsumerGroupOffsets_t;\nrd_kafka_AlterConsumerGroupOffsets_t *rd_kafka_AlterConsumerGroupOffsets_new(const char *group_id, const rd_kafka_topic_partition_list_t *partitions);\nvoid rd_kafka_AlterConsumerGroupOffsets_destroy(rd_kafka_AlterConsumerGroupOffsets_t *alter_grpoffsets);\nvoid rd_kafka_AlterConsumerGroupOffsets_destroy_array(rd_kafka_AlterConsumerGroupOffsets_t **alter_grpoffsets, size_t alter_grpoffset_cnt);\nvoid rd_kafka_AlterConsumerGroupOffsets(rd_kafka_t *rk, rd_kafka_AlterConsumerGroupOffsets_t **alter_grpoffsets, size_t alter_grpoffsets_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_group_result_t **rd_kafka_AlterConsumerGroupOffsets_result_groups(const rd_kafka_AlterConsumerGroupOffsets_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_DeleteConsumerGroupOffsets_s rd_kafka_DeleteConsumerGroupOffsets_t;\nrd_kafka_DeleteConsumerGroupOffsets_t *rd_kafka_DeleteConsumerGroupOffsets_new(const char *group, const rd_kafka_topic_partition_list_t *partitions);\nvoid rd_kafka_DeleteConsumerGroupOffsets_destroy(rd_kafka_DeleteConsumerGroupOffsets_t *del_grpoffsets);\nvoid rd_kafka_DeleteConsumerGroupOffsets_destroy_array(rd_kafka_DeleteConsumerGroupOffsets_t **del_grpoffsets, size_t del_grpoffset_cnt);\nvoid rd_kafka_DeleteConsumerGroupOffsets(rd_kafka_t *rk, rd_kafka_DeleteConsumerGroupOffsets_t **del_grpoffsets, size_t del_grpoffsets_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_group_result_t **rd_kafka_DeleteConsumerGroupOffsets_result_groups(const rd_kafka_DeleteConsumerGroupOffsets_result_t *result, size_t *cntp);\ntypedef enum rd_kafka_OffsetSpec_t {\n  RD_KAFKA_OFFSET_SPEC_MAX_TIMESTAMP = (- 3),\n  RD_KAFKA_OFFSET_SPEC_EARLIEST = (- 2),\n  RD_KAFKA_OFFSET_SPEC_LATEST = (- 1),\n} rd_kafka_OffsetSpec_t;\ntypedef struct rd_kafka_ListOffsetsResultInfo_s rd_kafka_ListOffsetsResultInfo_t;\nconst rd_kafka_topic_partition_t *rd_kafka_ListOffsetsResultInfo_topic_partition(const rd_kafka_ListOffsetsResultInfo_t *result_info);\nint64_t rd_kafka_ListOffsetsResultInfo_timestamp(const rd_kafka_ListOffsetsResultInfo_t *result_info);\nconst rd_kafka_ListOffsetsResultInfo_t **rd_kafka_ListOffsets_result_infos(const rd_kafka_ListOffsets_result_t *result, size_t *cntp);\nvoid rd_kafka_ListOffsets(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *topic_partitions, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\ntypedef enum rd_kafka_ScramMechanism_t {\n  RD_KAFKA_SCRAM_MECHANISM_UNKNOWN = 0,\n  RD_KAFKA_SCRAM_MECHANISM_SHA_256 = 1,\n  RD_KAFKA_SCRAM_MECHANISM_SHA_512 = 2,\n  RD_KAFKA_SCRAM_MECHANISM__CNT,\n} rd_kafka_ScramMechanism_t;\ntypedef struct rd_kafka_ScramCredentialInfo_s rd_kafka_ScramCredentialInfo_t;\nrd_kafka_ScramMechanism_t rd_kafka_ScramCredentialInfo_mechanism(const rd_kafka_ScramCredentialInfo_t *scram_credential_info);\nint32_t rd_kafka_ScramCredentialInfo_iterations(const rd_kafka_ScramCredentialInfo_t *scram_credential_info);\ntypedef struct rd_kafka_UserScramCredentialsDescription_s rd_kafka_UserScramCredentialsDescription_t;\nconst char *rd_kafka_UserScramCredentialsDescription_user(const rd_kafka_UserScramCredentialsDescription_t *description);\nconst rd_kafka_error_t *rd_kafka_UserScramCredentialsDescription_error(const rd_kafka_UserScramCredentialsDescription_t *description);\nsize_t rd_kafka_UserScramCredentialsDescription_scramcredentialinfo_count(const rd_kafka_UserScramCredentialsDescription_t *description);\nconst rd_kafka_ScramCredentialInfo_t *rd_kafka_UserScramCredentialsDescription_scramcredentialinfo(const rd_kafka_UserScramCredentialsDescription_t *description, size_t idx);\nconst rd_kafka_UserScramCredentialsDescription_t **rd_kafka_DescribeUserScramCredentials_result_descriptions(const rd_kafka_DescribeUserScramCredentials_result_t *result, size_t *cntp);\nvoid rd_kafka_DescribeUserScramCredentials(rd_kafka_t *rk, const char **users, size_t user_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\ntypedef struct rd_kafka_UserScramCredentialAlteration_s rd_kafka_UserScramCredentialAlteration_t;\nrd_kafka_UserScramCredentialAlteration_t *rd_kafka_UserScramCredentialUpsertion_new(const char *username, rd_kafka_ScramMechanism_t mechanism, int32_t iterations, const unsigned char *password, size_t password_size, const unsigned char *salt, size_t salt_size);\nrd_kafka_UserScramCredentialAlteration_t *rd_kafka_UserScramCredentialDeletion_new(const char *username, rd_kafka_ScramMechanism_t mechanism);\nvoid rd_kafka_UserScramCredentialAlteration_destroy(rd_kafka_UserScramCredentialAlteration_t *alteration);\nvoid rd_kafka_UserScramCredentialAlteration_destroy_array(rd_kafka_UserScramCredentialAlteration_t **alterations, size_t alteration_cnt);\ntypedef struct rd_kafka_AlterUserScramCredentials_result_response_s rd_kafka_AlterUserScramCredentials_result_response_t;\nconst char *rd_kafka_AlterUserScramCredentials_result_response_user(const rd_kafka_AlterUserScramCredentials_result_response_t *response);\nconst rd_kafka_error_t *rd_kafka_AlterUserScramCredentials_result_response_error(const rd_kafka_AlterUserScramCredentials_result_response_t *response);\nconst rd_kafka_AlterUserScramCredentials_result_response_t **rd_kafka_AlterUserScramCredentials_result_responses(const rd_kafka_AlterUserScramCredentials_result_t *result, size_t *cntp);\nvoid rd_kafka_AlterUserScramCredentials(rd_kafka_t *rk, rd_kafka_UserScramCredentialAlteration_t **alterations, size_t alteration_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\ntypedef struct rd_kafka_AclBinding_s rd_kafka_AclBinding_t;\ntypedef rd_kafka_AclBinding_t rd_kafka_AclBindingFilter_t;\nconst rd_kafka_error_t *rd_kafka_acl_result_error(const rd_kafka_acl_result_t *aclres);\nconst char *rd_kafka_AclOperation_name(rd_kafka_AclOperation_t acl_operation);\ntypedef enum rd_kafka_AclPermissionType_t {\n  RD_KAFKA_ACL_PERMISSION_TYPE_UNKNOWN = 0,\n  RD_KAFKA_ACL_PERMISSION_TYPE_ANY = 1,\n  RD_KAFKA_ACL_PERMISSION_TYPE_DENY = 2,\n  RD_KAFKA_ACL_PERMISSION_TYPE_ALLOW = 3,\n  RD_KAFKA_ACL_PERMISSION_TYPE__CNT,\n} rd_kafka_AclPermissionType_t;\nconst char *rd_kafka_AclPermissionType_name(rd_kafka_AclPermissionType_t acl_permission_type);\nrd_kafka_AclBinding_t *rd_kafka_AclBinding_new(rd_kafka_ResourceType_t restype, const char *name, rd_kafka_ResourcePatternType_t resource_pattern_type, const char *principal, const char *host, rd_kafka_AclOperation_t operation, rd_kafka_AclPermissionType_t permission_type, char *errstr, size_t errstr_size);\nrd_kafka_AclBindingFilter_t *rd_kafka_AclBindingFilter_new(rd_kafka_ResourceType_t restype, const char *name, rd_kafka_ResourcePatternType_t resource_pattern_type, const char *principal, const char *host, rd_kafka_AclOperation_t operation, rd_kafka_AclPermissionType_t permission_type, char *errstr, size_t errstr_size);\nrd_kafka_ResourceType_t rd_kafka_AclBinding_restype(const rd_kafka_AclBinding_t *acl);\nconst char *rd_kafka_AclBinding_name(const rd_kafka_AclBinding_t *acl);\nconst char *rd_kafka_AclBinding_principal(const rd_kafka_AclBinding_t *acl);\nconst char *rd_kafka_AclBinding_host(const rd_kafka_AclBinding_t *acl);\nrd_kafka_AclOperation_t rd_kafka_AclBinding_operation(const rd_kafka_AclBinding_t *acl);\nrd_kafka_AclPermissionType_t rd_kafka_AclBinding_permission_type(const rd_kafka_AclBinding_t *acl);\nrd_kafka_ResourcePatternType_t rd_kafka_AclBinding_resource_pattern_type(const rd_kafka_AclBinding_t *acl);\nconst rd_kafka_error_t *rd_kafka_AclBinding_error(const rd_kafka_AclBinding_t *acl);\nvoid rd_kafka_AclBinding_destroy(rd_kafka_AclBinding_t *acl_binding);\nvoid rd_kafka_AclBinding_destroy_array(rd_kafka_AclBinding_t **acl_bindings, size_t acl_bindings_cnt);\nconst rd_kafka_acl_result_t **rd_kafka_CreateAcls_result_acls(const rd_kafka_CreateAcls_result_t *result, size_t *cntp);\nvoid rd_kafka_CreateAcls(rd_kafka_t *rk, rd_kafka_AclBinding_t **new_acls, size_t new_acls_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_AclBinding_t **rd_kafka_DescribeAcls_result_acls(const rd_kafka_DescribeAcls_result_t *result, size_t *cntp);\nvoid rd_kafka_DescribeAcls(rd_kafka_t *rk, rd_kafka_AclBindingFilter_t *acl_filter, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\ntypedef struct rd_kafka_DeleteAcls_result_response_s rd_kafka_DeleteAcls_result_response_t;\nconst rd_kafka_DeleteAcls_result_response_t **rd_kafka_DeleteAcls_result_responses(const rd_kafka_DeleteAcls_result_t *result, size_t *cntp);\nconst rd_kafka_error_t *rd_kafka_DeleteAcls_result_response_error(const rd_kafka_DeleteAcls_result_response_t *result_response);\nconst rd_kafka_AclBinding_t **rd_kafka_DeleteAcls_result_response_matching_acls(const rd_kafka_DeleteAcls_result_response_t *result_response, size_t *matching_acls_cntp);\nvoid rd_kafka_DeleteAcls(rd_kafka_t *rk, rd_kafka_AclBindingFilter_t **del_acls, size_t del_acls_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\ntypedef struct rd_kafka_ElectLeaders_s rd_kafka_ElectLeaders_t;\ntypedef enum rd_kafka_ElectionType_t {\n  RD_KAFKA_ELECTION_TYPE_PREFERRED = 0,\n  RD_KAFKA_ELECTION_TYPE_UNCLEAN = 1,\n} rd_kafka_ElectionType_t;\nrd_kafka_ElectLeaders_t *rd_kafka_ElectLeaders_new(rd_kafka_ElectionType_t election_type, rd_kafka_topic_partition_list_t *partitions);\nvoid rd_kafka_ElectLeaders_destroy(rd_kafka_ElectLeaders_t *elect_leaders);\nvoid rd_kafka_ElectLeaders(rd_kafka_t *rk, rd_kafka_ElectLeaders_t *elect_leaders, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_topic_partition_result_t **rd_kafka_ElectLeaders_result_partitions(const rd_kafka_ElectLeaders_result_t *result, size_t *cntp);\nrd_kafka_resp_err_t rd_kafka_oauthbearer_set_token(rd_kafka_t *rk, const char *token_value, int64_t md_lifetime_ms, const char *md_principal_name, const char **extensions, size_t extension_size, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_oauthbearer_set_token_failure(rd_kafka_t *rk, const char *errstr);\nrd_kafka_error_t *rd_kafka_init_transactions(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_error_t *rd_kafka_begin_transaction(rd_kafka_t *rk);\nrd_kafka_error_t *rd_kafka_send_offsets_to_transaction(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, const rd_kafka_consumer_group_metadata_t *cgmetadata, int timeout_ms);\nrd_kafka_error_t *rd_kafka_commit_transaction(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_error_t *rd_kafka_abort_transaction(rd_kafka_t *rk, int timeout_ms);\ntypedef struct rd_kafka_mock_cluster_s rd_kafka_mock_cluster_t;\nrd_kafka_mock_cluster_t *rd_kafka_mock_cluster_new(rd_kafka_t *rk, int broker_cnt);\nvoid rd_kafka_mock_cluster_destroy(rd_kafka_mock_cluster_t *mcluster);\nrd_kafka_t *rd_kafka_mock_cluster_handle(const rd_kafka_mock_cluster_t *mcluster);\nrd_kafka_mock_cluster_t *rd_kafka_handle_mock_cluster(const rd_kafka_t *rk);\nconst char *rd_kafka_mock_cluster_bootstraps(const rd_kafka_mock_cluster_t *mcluster);\nvoid rd_kafka_mock_clear_request_errors(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey);\nvoid rd_kafka_mock_push_request_errors(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, size_t cnt, ...);\nvoid rd_kafka_mock_push_request_errors_array(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, size_t cnt, const rd_kafka_resp_err_t *errors);\nvoid rd_kafka_mock_group_initial_rebalance_delay_ms(rd_kafka_mock_cluster_t *mcluster, int32_t delay_ms);\nrd_kafka_resp_err_t rd_kafka_mock_broker_push_request_error_rtts(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int16_t ApiKey, size_t cnt, ...);\nrd_kafka_resp_err_t rd_kafka_mock_broker_error_stack_cnt(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int16_t ApiKey, size_t *cntp);\nvoid rd_kafka_mock_topic_set_error(rd_kafka_mock_cluster_t *mcluster, const char *topic, rd_kafka_resp_err_t err);\nrd_kafka_resp_err_t rd_kafka_mock_topic_create(rd_kafka_mock_cluster_t *mcluster, const char *topic, int partition_cnt, int replication_factor);\nrd_kafka_resp_err_t rd_kafka_mock_partition_set_leader(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id);\nrd_kafka_resp_err_t rd_kafka_mock_partition_set_follower(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id);\nrd_kafka_resp_err_t rd_kafka_mock_partition_set_follower_wmarks(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int64_t lo, int64_t hi);\nrd_kafka_resp_err_t rd_kafka_mock_partition_push_leader_response(rd_kafka_mock_cluster_t *mcluster, const char *topic, int partition, int32_t leader_id, int32_t leader_epoch);\nrd_kafka_resp_err_t rd_kafka_mock_broker_set_down(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id);\nrd_kafka_resp_err_t rd_kafka_mock_broker_set_up(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id);\nrd_kafka_resp_err_t rd_kafka_mock_broker_set_rtt(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int rtt_ms);\nrd_kafka_resp_err_t rd_kafka_mock_broker_set_rack(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, const char *rack);\nrd_kafka_resp_err_t rd_kafka_mock_coordinator_set(rd_kafka_mock_cluster_t *mcluster, const char *key_type, const char *key, int32_t broker_id);\nrd_kafka_resp_err_t rd_kafka_mock_set_apiversion(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, int16_t MinVersion, int16_t MaxVersion);\nvoid rd_kafka_mock_start_request_tracking(rd_kafka_mock_cluster_t *mcluster);\nvoid rd_kafka_mock_stop_request_tracking(rd_kafka_mock_cluster_t *mcluster);\ntypedef struct rd_kafka_mock_request_s rd_kafka_mock_request_t;\nvoid rd_kafka_mock_request_destroy(rd_kafka_mock_request_t *mreq);\nvoid rd_kafka_mock_request_destroy_array(rd_kafka_mock_request_t **mreqs, size_t mreq_cnt);\nint32_t rd_kafka_mock_request_id(rd_kafka_mock_request_t *mreq);\nint16_t rd_kafka_mock_request_api_key(rd_kafka_mock_request_t *mreq);\nint64_t rd_kafka_mock_request_timestamp(rd_kafka_mock_request_t *mreq);\nrd_kafka_mock_request_t **rd_kafka_mock_get_requests(rd_kafka_mock_cluster_t *mcluster, size_t *cntp);\nvoid rd_kafka_mock_clear_requests(rd_kafka_mock_cluster_t *mcluster);\nrd_kafka_resp_err_t rd_kafka_mock_telemetry_set_requested_metrics(rd_kafka_mock_cluster_t *mcluster, char **metrics, size_t metrics_cnt);\nrd_kafka_resp_err_t rd_kafka_mock_telemetry_set_push_interval(rd_kafka_mock_cluster_t *mcluster, int64_t push_interval_ms);\n'\n</code></pre> rdkafka.h, rdkafka_mock.h</p>"},{"location":"api/constants/#rd_kafka_version_35","title":"RD_KAFKA_VERSION","text":"<pre><code>public RD_KAFKA_VERSION = 34078975\n</code></pre> <p>librdkafka version </p> <p>Interpreted as hex <code>MM.mm.rr.xx</code>:</p> <ul> <li>MM = Major</li> <li>mm = minor</li> <li>rr = revision</li> <li>xx = pre-release id (0xff is the final release)</li> </ul> <p>E.g.: <code>0x000801ff</code> = 0.8.1</p> RemarksThis value should only be used during compile time, for runtime checks of version use rd_kafka_version()  <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_unsupported_compression_type_35","title":"RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE","text":"<pre><code>public RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76\n</code></pre> <p>Unsupported compression type </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </li> </ul>"},{"location":"api/constants/#rd_kafka_resp_err_end_all_35","title":"RD_KAFKA_RESP_ERR_END_ALL","text":"<p><pre><code>public RD_KAFKA_RESP_ERR_END_ALL = 119\n</code></pre> enum rd_kafka_resp_err_t</p>"},{"location":"api/constants/#rd_kafka_admin_op__cnt_35","title":"RD_KAFKA_ADMIN_OP__CNT","text":"<pre><code>public RD_KAFKA_ADMIN_OP__CNT = 23\n</code></pre> <p>Number of ops defined </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe </li> </ul>"},{"location":"api/constants/#rd_kafka_resource__cnt_35","title":"RD_KAFKA_RESOURCE__CNT","text":"<pre><code>public RD_KAFKA_RESOURCE__CNT = 6\n</code></pre> <p>Number of resource types defined </p> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#acca83a66d7783ff7683ed2691cc907c9 </li> </ul>"},{"location":"api/constants/#rd_kafka_cdef_35","title":"RD_KAFKA_CDEF","text":"<p><pre><code>public RD_KAFKA_CDEF = 'typedef long int ssize_t;\ntypedef struct _IO_FILE FILE;\ntypedef long int mode_t;\ntypedef signed int int16_t;\ntypedef unsigned int uint16_t;\ntypedef signed int int32_t;\ntypedef signed long int int64_t;\nint rd_kafka_version(void);\nconst char *rd_kafka_version_str(void);\ntypedef enum rd_kafka_type_t {\n  RD_KAFKA_PRODUCER,\n  RD_KAFKA_CONSUMER,\n} rd_kafka_type_t;\ntypedef enum rd_kafka_timestamp_type_t {\n  RD_KAFKA_TIMESTAMP_NOT_AVAILABLE,\n  RD_KAFKA_TIMESTAMP_CREATE_TIME,\n  RD_KAFKA_TIMESTAMP_LOG_APPEND_TIME,\n} rd_kafka_timestamp_type_t;\nconst char *rd_kafka_get_debug_contexts(void);\ntypedef struct rd_kafka_s rd_kafka_t;\ntypedef struct rd_kafka_topic_s rd_kafka_topic_t;\ntypedef struct rd_kafka_conf_s rd_kafka_conf_t;\ntypedef struct rd_kafka_topic_conf_s rd_kafka_topic_conf_t;\ntypedef struct rd_kafka_queue_s rd_kafka_queue_t;\ntypedef struct rd_kafka_op_s rd_kafka_event_t;\ntypedef struct rd_kafka_topic_result_s rd_kafka_topic_result_t;\ntypedef struct rd_kafka_consumer_group_metadata_s rd_kafka_consumer_group_metadata_t;\ntypedef struct rd_kafka_error_s {\n  unsigned int code;\n  char *errstr;\n  unsigned char fatal;\n  unsigned char retriable;\n  unsigned char txn_requires_abort;\n} rd_kafka_error_t;\ntypedef struct rd_kafka_headers_s rd_kafka_headers_t;\ntypedef struct rd_kafka_group_result_s rd_kafka_group_result_t;\ntypedef struct rd_kafka_acl_result_s rd_kafka_acl_result_t;\ntypedef struct rd_kafka_Uuid_s rd_kafka_Uuid_t;\ntypedef struct rd_kafka_topic_partition_result_s rd_kafka_topic_partition_result_t;\ntypedef enum {\n  RD_KAFKA_RESP_ERR__BEGIN = (- 200),\n  RD_KAFKA_RESP_ERR__BAD_MSG = (- 199),\n  RD_KAFKA_RESP_ERR__BAD_COMPRESSION = (- 198),\n  RD_KAFKA_RESP_ERR__DESTROY = (- 197),\n  RD_KAFKA_RESP_ERR__FAIL = (- 196),\n  RD_KAFKA_RESP_ERR__TRANSPORT = (- 195),\n  RD_KAFKA_RESP_ERR__CRIT_SYS_RESOURCE = (- 194),\n  RD_KAFKA_RESP_ERR__RESOLVE = (- 193),\n  RD_KAFKA_RESP_ERR__MSG_TIMED_OUT = (- 192),\n  RD_KAFKA_RESP_ERR__PARTITION_EOF = (- 191),\n  RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION = (- 190),\n  RD_KAFKA_RESP_ERR__FS = (- 189),\n  RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC = (- 188),\n  RD_KAFKA_RESP_ERR__ALL_BROKERS_DOWN = (- 187),\n  RD_KAFKA_RESP_ERR__INVALID_ARG = (- 186),\n  RD_KAFKA_RESP_ERR__TIMED_OUT = (- 185),\n  RD_KAFKA_RESP_ERR__QUEUE_FULL = (- 184),\n  RD_KAFKA_RESP_ERR__ISR_INSUFF = (- 183),\n  RD_KAFKA_RESP_ERR__NODE_UPDATE = (- 182),\n  RD_KAFKA_RESP_ERR__SSL = (- 181),\n  RD_KAFKA_RESP_ERR__WAIT_COORD = (- 180),\n  RD_KAFKA_RESP_ERR__UNKNOWN_GROUP = (- 179),\n  RD_KAFKA_RESP_ERR__IN_PROGRESS = (- 178),\n  RD_KAFKA_RESP_ERR__PREV_IN_PROGRESS = (- 177),\n  RD_KAFKA_RESP_ERR__EXISTING_SUBSCRIPTION = (- 176),\n  RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS = (- 175),\n  RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS = (- 174),\n  RD_KAFKA_RESP_ERR__CONFLICT = (- 173),\n  RD_KAFKA_RESP_ERR__STATE = (- 172),\n  RD_KAFKA_RESP_ERR__UNKNOWN_PROTOCOL = (- 171),\n  RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED = (- 170),\n  RD_KAFKA_RESP_ERR__AUTHENTICATION = (- 169),\n  RD_KAFKA_RESP_ERR__NO_OFFSET = (- 168),\n  RD_KAFKA_RESP_ERR__OUTDATED = (- 167),\n  RD_KAFKA_RESP_ERR__TIMED_OUT_QUEUE = (- 166),\n  RD_KAFKA_RESP_ERR__UNSUPPORTED_FEATURE = (- 165),\n  RD_KAFKA_RESP_ERR__WAIT_CACHE = (- 164),\n  RD_KAFKA_RESP_ERR__INTR = (- 163),\n  RD_KAFKA_RESP_ERR__KEY_SERIALIZATION = (- 162),\n  RD_KAFKA_RESP_ERR__VALUE_SERIALIZATION = (- 161),\n  RD_KAFKA_RESP_ERR__KEY_DESERIALIZATION = (- 160),\n  RD_KAFKA_RESP_ERR__VALUE_DESERIALIZATION = (- 159),\n  RD_KAFKA_RESP_ERR__PARTIAL = (- 158),\n  RD_KAFKA_RESP_ERR__READ_ONLY = (- 157),\n  RD_KAFKA_RESP_ERR__NOENT = (- 156),\n  RD_KAFKA_RESP_ERR__UNDERFLOW = (- 155),\n  RD_KAFKA_RESP_ERR__INVALID_TYPE = (- 154),\n  RD_KAFKA_RESP_ERR__RETRY = (- 153),\n  RD_KAFKA_RESP_ERR__PURGE_QUEUE = (- 152),\n  RD_KAFKA_RESP_ERR__PURGE_INFLIGHT = (- 151),\n  RD_KAFKA_RESP_ERR__FATAL = (- 150),\n  RD_KAFKA_RESP_ERR__INCONSISTENT = (- 149),\n  RD_KAFKA_RESP_ERR__GAPLESS_GUARANTEE = (- 148),\n  RD_KAFKA_RESP_ERR__MAX_POLL_EXCEEDED = (- 147),\n  RD_KAFKA_RESP_ERR__UNKNOWN_BROKER = (- 146),\n  RD_KAFKA_RESP_ERR__NOT_CONFIGURED = (- 145),\n  RD_KAFKA_RESP_ERR__FENCED = (- 144),\n  RD_KAFKA_RESP_ERR__APPLICATION = (- 143),\n  RD_KAFKA_RESP_ERR__ASSIGNMENT_LOST = (- 142),\n  RD_KAFKA_RESP_ERR__NOOP = (- 141),\n  RD_KAFKA_RESP_ERR__AUTO_OFFSET_RESET = (- 140),\n  RD_KAFKA_RESP_ERR__LOG_TRUNCATION = (- 139),\n  RD_KAFKA_RESP_ERR__INVALID_DIFFERENT_RECORD = (- 138),\n  RD_KAFKA_RESP_ERR__END = (- 100),\n  RD_KAFKA_RESP_ERR_UNKNOWN = (- 1),\n  RD_KAFKA_RESP_ERR_NO_ERROR = 0,\n  RD_KAFKA_RESP_ERR_OFFSET_OUT_OF_RANGE = 1,\n  RD_KAFKA_RESP_ERR_INVALID_MSG = 2,\n  RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART = 3,\n  RD_KAFKA_RESP_ERR_INVALID_MSG_SIZE = 4,\n  RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE = 5,\n  RD_KAFKA_RESP_ERR_NOT_LEADER_FOR_PARTITION = 6,\n  RD_KAFKA_RESP_ERR_REQUEST_TIMED_OUT = 7,\n  RD_KAFKA_RESP_ERR_BROKER_NOT_AVAILABLE = 8,\n  RD_KAFKA_RESP_ERR_REPLICA_NOT_AVAILABLE = 9,\n  RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE = 10,\n  RD_KAFKA_RESP_ERR_STALE_CTRL_EPOCH = 11,\n  RD_KAFKA_RESP_ERR_OFFSET_METADATA_TOO_LARGE = 12,\n  RD_KAFKA_RESP_ERR_NETWORK_EXCEPTION = 13,\n  RD_KAFKA_RESP_ERR_COORDINATOR_LOAD_IN_PROGRESS = 14,\n  RD_KAFKA_RESP_ERR_COORDINATOR_NOT_AVAILABLE = 15,\n  RD_KAFKA_RESP_ERR_NOT_COORDINATOR = 16,\n  RD_KAFKA_RESP_ERR_TOPIC_EXCEPTION = 17,\n  RD_KAFKA_RESP_ERR_RECORD_LIST_TOO_LARGE = 18,\n  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS = 19,\n  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS_AFTER_APPEND = 20,\n  RD_KAFKA_RESP_ERR_INVALID_REQUIRED_ACKS = 21,\n  RD_KAFKA_RESP_ERR_ILLEGAL_GENERATION = 22,\n  RD_KAFKA_RESP_ERR_INCONSISTENT_GROUP_PROTOCOL = 23,\n  RD_KAFKA_RESP_ERR_INVALID_GROUP_ID = 24,\n  RD_KAFKA_RESP_ERR_UNKNOWN_MEMBER_ID = 25,\n  RD_KAFKA_RESP_ERR_INVALID_SESSION_TIMEOUT = 26,\n  RD_KAFKA_RESP_ERR_REBALANCE_IN_PROGRESS = 27,\n  RD_KAFKA_RESP_ERR_INVALID_COMMIT_OFFSET_SIZE = 28,\n  RD_KAFKA_RESP_ERR_TOPIC_AUTHORIZATION_FAILED = 29,\n  RD_KAFKA_RESP_ERR_GROUP_AUTHORIZATION_FAILED = 30,\n  RD_KAFKA_RESP_ERR_CLUSTER_AUTHORIZATION_FAILED = 31,\n  RD_KAFKA_RESP_ERR_INVALID_TIMESTAMP = 32,\n  RD_KAFKA_RESP_ERR_UNSUPPORTED_SASL_MECHANISM = 33,\n  RD_KAFKA_RESP_ERR_ILLEGAL_SASL_STATE = 34,\n  RD_KAFKA_RESP_ERR_UNSUPPORTED_VERSION = 35,\n  RD_KAFKA_RESP_ERR_TOPIC_ALREADY_EXISTS = 36,\n  RD_KAFKA_RESP_ERR_INVALID_PARTITIONS = 37,\n  RD_KAFKA_RESP_ERR_INVALID_REPLICATION_FACTOR = 38,\n  RD_KAFKA_RESP_ERR_INVALID_REPLICA_ASSIGNMENT = 39,\n  RD_KAFKA_RESP_ERR_INVALID_CONFIG = 40,\n  RD_KAFKA_RESP_ERR_NOT_CONTROLLER = 41,\n  RD_KAFKA_RESP_ERR_INVALID_REQUEST = 42,\n  RD_KAFKA_RESP_ERR_UNSUPPORTED_FOR_MESSAGE_FORMAT = 43,\n  RD_KAFKA_RESP_ERR_POLICY_VIOLATION = 44,\n  RD_KAFKA_RESP_ERR_OUT_OF_ORDER_SEQUENCE_NUMBER = 45,\n  RD_KAFKA_RESP_ERR_DUPLICATE_SEQUENCE_NUMBER = 46,\n  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_EPOCH = 47,\n  RD_KAFKA_RESP_ERR_INVALID_TXN_STATE = 48,\n  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_ID_MAPPING = 49,\n  RD_KAFKA_RESP_ERR_INVALID_TRANSACTION_TIMEOUT = 50,\n  RD_KAFKA_RESP_ERR_CONCURRENT_TRANSACTIONS = 51,\n  RD_KAFKA_RESP_ERR_TRANSACTION_COORDINATOR_FENCED = 52,\n  RD_KAFKA_RESP_ERR_TRANSACTIONAL_ID_AUTHORIZATION_FAILED = 53,\n  RD_KAFKA_RESP_ERR_SECURITY_DISABLED = 54,\n  RD_KAFKA_RESP_ERR_OPERATION_NOT_ATTEMPTED = 55,\n  RD_KAFKA_RESP_ERR_KAFKA_STORAGE_ERROR = 56,\n  RD_KAFKA_RESP_ERR_LOG_DIR_NOT_FOUND = 57,\n  RD_KAFKA_RESP_ERR_SASL_AUTHENTICATION_FAILED = 58,\n  RD_KAFKA_RESP_ERR_UNKNOWN_PRODUCER_ID = 59,\n  RD_KAFKA_RESP_ERR_REASSIGNMENT_IN_PROGRESS = 60,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTH_DISABLED = 61,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_NOT_FOUND = 62,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_OWNER_MISMATCH = 63,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_REQUEST_NOT_ALLOWED = 64,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTHORIZATION_FAILED = 65,\n  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_EXPIRED = 66,\n  RD_KAFKA_RESP_ERR_INVALID_PRINCIPAL_TYPE = 67,\n  RD_KAFKA_RESP_ERR_NON_EMPTY_GROUP = 68,\n  RD_KAFKA_RESP_ERR_GROUP_ID_NOT_FOUND = 69,\n  RD_KAFKA_RESP_ERR_FETCH_SESSION_ID_NOT_FOUND = 70,\n  RD_KAFKA_RESP_ERR_INVALID_FETCH_SESSION_EPOCH = 71,\n  RD_KAFKA_RESP_ERR_LISTENER_NOT_FOUND = 72,\n  RD_KAFKA_RESP_ERR_TOPIC_DELETION_DISABLED = 73,\n  RD_KAFKA_RESP_ERR_FENCED_LEADER_EPOCH = 74,\n  RD_KAFKA_RESP_ERR_UNKNOWN_LEADER_EPOCH = 75,\n  RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76,\n  RD_KAFKA_RESP_ERR_STALE_BROKER_EPOCH = 77,\n  RD_KAFKA_RESP_ERR_OFFSET_NOT_AVAILABLE = 78,\n  RD_KAFKA_RESP_ERR_MEMBER_ID_REQUIRED = 79,\n  RD_KAFKA_RESP_ERR_PREFERRED_LEADER_NOT_AVAILABLE = 80,\n  RD_KAFKA_RESP_ERR_GROUP_MAX_SIZE_REACHED = 81,\n  RD_KAFKA_RESP_ERR_FENCED_INSTANCE_ID = 82,\n  RD_KAFKA_RESP_ERR_ELIGIBLE_LEADERS_NOT_AVAILABLE = 83,\n  RD_KAFKA_RESP_ERR_ELECTION_NOT_NEEDED = 84,\n  RD_KAFKA_RESP_ERR_NO_REASSIGNMENT_IN_PROGRESS = 85,\n  RD_KAFKA_RESP_ERR_GROUP_SUBSCRIBED_TO_TOPIC = 86,\n  RD_KAFKA_RESP_ERR_INVALID_RECORD = 87,\n  RD_KAFKA_RESP_ERR_UNSTABLE_OFFSET_COMMIT = 88,\n  RD_KAFKA_RESP_ERR_THROTTLING_QUOTA_EXCEEDED = 89,\n  RD_KAFKA_RESP_ERR_PRODUCER_FENCED = 90,\n  RD_KAFKA_RESP_ERR_RESOURCE_NOT_FOUND = 91,\n  RD_KAFKA_RESP_ERR_DUPLICATE_RESOURCE = 92,\n  RD_KAFKA_RESP_ERR_UNACCEPTABLE_CREDENTIAL = 93,\n  RD_KAFKA_RESP_ERR_INCONSISTENT_VOTER_SET = 94,\n  RD_KAFKA_RESP_ERR_INVALID_UPDATE_VERSION = 95,\n  RD_KAFKA_RESP_ERR_FEATURE_UPDATE_FAILED = 96,\n  RD_KAFKA_RESP_ERR_PRINCIPAL_DESERIALIZATION_FAILURE = 97,\n  RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_ID = 100,\n  RD_KAFKA_RESP_ERR_FENCED_MEMBER_EPOCH = 110,\n  RD_KAFKA_RESP_ERR_UNRELEASED_INSTANCE_ID = 111,\n  RD_KAFKA_RESP_ERR_UNSUPPORTED_ASSIGNOR = 112,\n  RD_KAFKA_RESP_ERR_STALE_MEMBER_EPOCH = 113,\n  RD_KAFKA_RESP_ERR_UNKNOWN_SUBSCRIPTION_ID = 117,\n  RD_KAFKA_RESP_ERR_TELEMETRY_TOO_LARGE = 118,\n  RD_KAFKA_RESP_ERR_END_ALL,\n} rd_kafka_resp_err_t;\nstruct rd_kafka_err_desc {\n  rd_kafka_resp_err_t code;\n  char *name;\n  char *desc;\n};\nvoid rd_kafka_get_err_descs(const struct rd_kafka_err_desc **errdescs, size_t *cntp);\nconst char *rd_kafka_err2str(rd_kafka_resp_err_t err);\nconst char *rd_kafka_err2name(rd_kafka_resp_err_t err);\nrd_kafka_resp_err_t rd_kafka_last_error(void);\nrd_kafka_resp_err_t rd_kafka_errno2err(int errnox);\nint rd_kafka_errno(void);\nrd_kafka_resp_err_t rd_kafka_fatal_error(rd_kafka_t *rk, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_test_fatal_error(rd_kafka_t *rk, rd_kafka_resp_err_t err, const char *reason);\nrd_kafka_resp_err_t rd_kafka_error_code(const rd_kafka_error_t *error);\nconst char *rd_kafka_error_name(const rd_kafka_error_t *error);\nconst char *rd_kafka_error_string(const rd_kafka_error_t *error);\nint rd_kafka_error_is_fatal(const rd_kafka_error_t *error);\nint rd_kafka_error_is_retriable(const rd_kafka_error_t *error);\nint rd_kafka_error_txn_requires_abort(const rd_kafka_error_t *error);\nvoid rd_kafka_error_destroy(rd_kafka_error_t *error);\nrd_kafka_error_t *rd_kafka_error_new(rd_kafka_resp_err_t code, const char *fmt, ...);\ntypedef struct rd_kafka_topic_partition_s {\n  char *topic;\n  int32_t partition;\n  int64_t offset;\n  void *metadata;\n  size_t metadata_size;\n  void *opaque;\n  rd_kafka_resp_err_t err;\n  void *_private;\n} rd_kafka_topic_partition_t;\nvoid rd_kafka_topic_partition_destroy(rd_kafka_topic_partition_t *rktpar);\nvoid rd_kafka_topic_partition_set_leader_epoch(rd_kafka_topic_partition_t *rktpar, int32_t leader_epoch);\nint32_t rd_kafka_topic_partition_get_leader_epoch(const rd_kafka_topic_partition_t *rktpar);\ntypedef struct rd_kafka_topic_partition_list_s {\n  int cnt;\n  int size;\n  rd_kafka_topic_partition_t *elems;\n} rd_kafka_topic_partition_list_t;\nrd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_new(int size);\nvoid rd_kafka_topic_partition_list_destroy(rd_kafka_topic_partition_list_t *rkparlist);\nrd_kafka_topic_partition_t *rd_kafka_topic_partition_list_add(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);\nvoid rd_kafka_topic_partition_list_add_range(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t start, int32_t stop);\nint rd_kafka_topic_partition_list_del(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);\nint rd_kafka_topic_partition_list_del_by_idx(rd_kafka_topic_partition_list_t *rktparlist, int idx);\nrd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_copy(const rd_kafka_topic_partition_list_t *src);\nrd_kafka_resp_err_t rd_kafka_topic_partition_list_set_offset(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition, int64_t offset);\nrd_kafka_topic_partition_t *rd_kafka_topic_partition_list_find(const rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);\nvoid rd_kafka_topic_partition_list_sort(rd_kafka_topic_partition_list_t *rktparlist, int (*cmp)(const void *a, const void *b, void *cmp_opaque), void *cmp_opaque);\ntypedef enum rd_kafka_vtype_t {\n  RD_KAFKA_VTYPE_END,\n  RD_KAFKA_VTYPE_TOPIC,\n  RD_KAFKA_VTYPE_RKT,\n  RD_KAFKA_VTYPE_PARTITION,\n  RD_KAFKA_VTYPE_VALUE,\n  RD_KAFKA_VTYPE_KEY,\n  RD_KAFKA_VTYPE_OPAQUE,\n  RD_KAFKA_VTYPE_MSGFLAGS,\n  RD_KAFKA_VTYPE_TIMESTAMP,\n  RD_KAFKA_VTYPE_HEADER,\n  RD_KAFKA_VTYPE_HEADERS,\n} rd_kafka_vtype_t;\ntypedef struct rd_kafka_vu_s {\n  rd_kafka_vtype_t vtype;\n  union {\n    char *cstr;\n    rd_kafka_topic_t *rkt;\n    int i;\n    int32_t i32;\n    int64_t i64;\n    struct {\n      void *ptr;\n      size_t size;\n    } mem;\n    struct {\n      char *name;\n      void *val;\n      ssize_t size;\n    } header;\n    rd_kafka_headers_t *headers;\n    void *ptr;\n    char _pad[64];\n  } u;\n} rd_kafka_vu_t;\nrd_kafka_headers_t *rd_kafka_headers_new(size_t initial_count);\nvoid rd_kafka_headers_destroy(rd_kafka_headers_t *hdrs);\nrd_kafka_headers_t *rd_kafka_headers_copy(const rd_kafka_headers_t *src);\nrd_kafka_resp_err_t rd_kafka_header_add(rd_kafka_headers_t *hdrs, const char *name, ssize_t name_size, const void *value, ssize_t value_size);\nrd_kafka_resp_err_t rd_kafka_header_remove(rd_kafka_headers_t *hdrs, const char *name);\nrd_kafka_resp_err_t rd_kafka_header_get_last(const rd_kafka_headers_t *hdrs, const char *name, const void **valuep, size_t *sizep);\nrd_kafka_resp_err_t rd_kafka_header_get(const rd_kafka_headers_t *hdrs, size_t idx, const char *name, const void **valuep, size_t *sizep);\nrd_kafka_resp_err_t rd_kafka_header_get_all(const rd_kafka_headers_t *hdrs, size_t idx, const char **namep, const void **valuep, size_t *sizep);\ntypedef struct rd_kafka_message_s {\n  rd_kafka_resp_err_t err;\n  rd_kafka_topic_t *rkt;\n  int32_t partition;\n  void *payload;\n  size_t len;\n  void *key;\n  size_t key_len;\n  int64_t offset;\n  void *_private;\n} rd_kafka_message_t;\nvoid rd_kafka_message_destroy(rd_kafka_message_t *rkmessage);\nconst char *rd_kafka_message_errstr(const rd_kafka_message_t *rkmessage);\nconst char *rd_kafka_message_produce_errstr(const rd_kafka_message_t *rkmessage);\nint64_t rd_kafka_message_timestamp(const rd_kafka_message_t *rkmessage, rd_kafka_timestamp_type_t *tstype);\nint64_t rd_kafka_message_latency(const rd_kafka_message_t *rkmessage);\nint32_t rd_kafka_message_broker_id(const rd_kafka_message_t *rkmessage);\nrd_kafka_resp_err_t rd_kafka_message_headers(const rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);\nrd_kafka_resp_err_t rd_kafka_message_detach_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);\nvoid rd_kafka_message_set_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t *hdrs);\nsize_t rd_kafka_header_cnt(const rd_kafka_headers_t *hdrs);\ntypedef enum {\n  RD_KAFKA_MSG_STATUS_NOT_PERSISTED = 0,\n  RD_KAFKA_MSG_STATUS_POSSIBLY_PERSISTED = 1,\n  RD_KAFKA_MSG_STATUS_PERSISTED = 2,\n} rd_kafka_msg_status_t;\nrd_kafka_msg_status_t rd_kafka_message_status(const rd_kafka_message_t *rkmessage);\nint32_t rd_kafka_message_leader_epoch(const rd_kafka_message_t *rkmessage);\nconst char *rd_kafka_Uuid_base64str(const rd_kafka_Uuid_t *uuid);\nint64_t rd_kafka_Uuid_least_significant_bits(const rd_kafka_Uuid_t *uuid);\nint64_t rd_kafka_Uuid_most_significant_bits(const rd_kafka_Uuid_t *uuid);\nrd_kafka_Uuid_t *rd_kafka_Uuid_new(int64_t most_significant_bits, int64_t least_significant_bits);\nrd_kafka_Uuid_t *rd_kafka_Uuid_copy(const rd_kafka_Uuid_t *uuid);\nvoid rd_kafka_Uuid_destroy(rd_kafka_Uuid_t *uuid);\ntypedef enum {\n  RD_KAFKA_CONF_UNKNOWN = (- 2),\n  RD_KAFKA_CONF_INVALID = (- 1),\n  RD_KAFKA_CONF_OK = 0,\n} rd_kafka_conf_res_t;\nrd_kafka_conf_t *rd_kafka_conf_new(void);\nvoid rd_kafka_conf_destroy(rd_kafka_conf_t *conf);\nrd_kafka_conf_t *rd_kafka_conf_dup(const rd_kafka_conf_t *conf);\nrd_kafka_conf_t *rd_kafka_conf_dup_filter(const rd_kafka_conf_t *conf, size_t filter_cnt, const char **filter);\nconst rd_kafka_conf_t *rd_kafka_conf(rd_kafka_t *rk);\nrd_kafka_conf_res_t rd_kafka_conf_set(rd_kafka_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);\nvoid rd_kafka_conf_set_events(rd_kafka_conf_t *conf, int events);\nvoid rd_kafka_conf_set_background_event_cb(rd_kafka_conf_t *conf, void (*event_cb)(rd_kafka_t *rk, rd_kafka_event_t *rkev, void *opaque));\nvoid rd_kafka_conf_set_dr_cb(rd_kafka_conf_t *conf, void (*dr_cb)(rd_kafka_t *rk, void *payload, size_t len, rd_kafka_resp_err_t err, void *opaque, void *msg_opaque));\nvoid rd_kafka_conf_set_dr_msg_cb(rd_kafka_conf_t *conf, void (*dr_msg_cb)(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, void *opaque));\nvoid rd_kafka_conf_set_consume_cb(rd_kafka_conf_t *conf, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *opaque));\nvoid rd_kafka_conf_set_rebalance_cb(rd_kafka_conf_t *conf, void (*rebalance_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *partitions, void *opaque));\nvoid rd_kafka_conf_set_offset_commit_cb(rd_kafka_conf_t *conf, void (*offset_commit_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *opaque));\nvoid rd_kafka_conf_set_error_cb(rd_kafka_conf_t *conf, void (*error_cb)(rd_kafka_t *rk, int err, const char *reason, void *opaque));\nvoid rd_kafka_conf_set_throttle_cb(rd_kafka_conf_t *conf, void (*throttle_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int throttle_time_ms, void *opaque));\nvoid rd_kafka_conf_set_log_cb(rd_kafka_conf_t *conf, void (*log_cb)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));\nvoid rd_kafka_conf_set_stats_cb(rd_kafka_conf_t *conf, int (*stats_cb)(rd_kafka_t *rk, char *json, size_t json_len, void *opaque));\nvoid rd_kafka_conf_set_oauthbearer_token_refresh_cb(rd_kafka_conf_t *conf, void (*oauthbearer_token_refresh_cb)(rd_kafka_t *rk, const char *oauthbearer_config, void *opaque));\nvoid rd_kafka_conf_enable_sasl_queue(rd_kafka_conf_t *conf, int enable);\nvoid rd_kafka_conf_set_socket_cb(rd_kafka_conf_t *conf, int (*socket_cb)(int domain, int type, int protocol, void *opaque));\nvoid rd_kafka_conf_set_connect_cb(rd_kafka_conf_t *conf, int (*connect_cb)(int sockfd, const struct sockaddr *addr, int addrlen, const char *id, void *opaque));\nvoid rd_kafka_conf_set_closesocket_cb(rd_kafka_conf_t *conf, int (*closesocket_cb)(int sockfd, void *opaque));\nstruct addrinfo;\nvoid rd_kafka_conf_set_resolve_cb(rd_kafka_conf_t *conf, int (*resolve_cb)(const char *node, const char *service, const struct addrinfo *hints, struct addrinfo **res, void *opaque));\nrd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert_verify_cb(rd_kafka_conf_t *conf, int (*ssl_cert_verify_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int *x509_error, int depth, const char *buf, size_t size, char *errstr, size_t errstr_size, void *opaque));\ntypedef enum rd_kafka_cert_type_t {\n  RD_KAFKA_CERT_PUBLIC_KEY,\n  RD_KAFKA_CERT_PRIVATE_KEY,\n  RD_KAFKA_CERT_CA,\n  RD_KAFKA_CERT__CNT,\n} rd_kafka_cert_type_t;\ntypedef enum rd_kafka_cert_enc_t {\n  RD_KAFKA_CERT_ENC_PKCS12,\n  RD_KAFKA_CERT_ENC_DER,\n  RD_KAFKA_CERT_ENC_PEM,\n  RD_KAFKA_CERT_ENC__CNT,\n} rd_kafka_cert_enc_t;\nrd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert(rd_kafka_conf_t *conf, rd_kafka_cert_type_t cert_type, rd_kafka_cert_enc_t cert_enc, const void *buffer, size_t size, char *errstr, size_t errstr_size);\nvoid rd_kafka_conf_set_engine_callback_data(rd_kafka_conf_t *conf, void *callback_data);\nvoid rd_kafka_conf_set_opaque(rd_kafka_conf_t *conf, void *opaque);\nvoid *rd_kafka_opaque(const rd_kafka_t *rk);\nvoid rd_kafka_conf_set_default_topic_conf(rd_kafka_conf_t *conf, rd_kafka_topic_conf_t *tconf);\nrd_kafka_topic_conf_t *rd_kafka_conf_get_default_topic_conf(rd_kafka_conf_t *conf);\nrd_kafka_conf_res_t rd_kafka_conf_get(const rd_kafka_conf_t *conf, const char *name, char *dest, size_t *dest_size);\nrd_kafka_conf_res_t rd_kafka_topic_conf_get(const rd_kafka_topic_conf_t *conf, const char *name, char *dest, size_t *dest_size);\nconst char **rd_kafka_conf_dump(rd_kafka_conf_t *conf, size_t *cntp);\nconst char **rd_kafka_topic_conf_dump(rd_kafka_topic_conf_t *conf, size_t *cntp);\nvoid rd_kafka_conf_dump_free(const char **arr, size_t cnt);\nvoid rd_kafka_conf_properties_show(FILE *fp);\nrd_kafka_topic_conf_t *rd_kafka_topic_conf_new(void);\nrd_kafka_topic_conf_t *rd_kafka_topic_conf_dup(const rd_kafka_topic_conf_t *conf);\nrd_kafka_topic_conf_t *rd_kafka_default_topic_conf_dup(rd_kafka_t *rk);\nvoid rd_kafka_topic_conf_destroy(rd_kafka_topic_conf_t *topic_conf);\nrd_kafka_conf_res_t rd_kafka_topic_conf_set(rd_kafka_topic_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);\nvoid rd_kafka_topic_conf_set_opaque(rd_kafka_topic_conf_t *conf, void *rkt_opaque);\nvoid rd_kafka_topic_conf_set_partitioner_cb(rd_kafka_topic_conf_t *topic_conf, int32_t (*partitioner)(const rd_kafka_topic_t *rkt, const void *keydata, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque));\nvoid rd_kafka_topic_conf_set_msg_order_cmp(rd_kafka_topic_conf_t *topic_conf, int (*msg_order_cmp)(const rd_kafka_message_t *a, const rd_kafka_message_t *b));\nint rd_kafka_topic_partition_available(const rd_kafka_topic_t *rkt, int32_t partition);\nint32_t rd_kafka_msg_partitioner_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_consistent(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_consistent_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_murmur2(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_murmur2_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_fnv1a(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nint32_t rd_kafka_msg_partitioner_fnv1a_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);\nrd_kafka_t *rd_kafka_new(rd_kafka_type_t type, rd_kafka_conf_t *conf, char *errstr, size_t errstr_size);\nvoid rd_kafka_destroy(rd_kafka_t *rk);\nvoid rd_kafka_destroy_flags(rd_kafka_t *rk, int flags);\nconst char *rd_kafka_name(const rd_kafka_t *rk);\nrd_kafka_type_t rd_kafka_type(const rd_kafka_t *rk);\nchar *rd_kafka_memberid(const rd_kafka_t *rk);\nchar *rd_kafka_clusterid(rd_kafka_t *rk, int timeout_ms);\nint32_t rd_kafka_controllerid(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_topic_t *rd_kafka_topic_new(rd_kafka_t *rk, const char *topic, rd_kafka_topic_conf_t *conf);\nvoid rd_kafka_topic_destroy(rd_kafka_topic_t *rkt);\nconst char *rd_kafka_topic_name(const rd_kafka_topic_t *rkt);\nvoid *rd_kafka_topic_opaque(const rd_kafka_topic_t *rkt);\nint rd_kafka_poll(rd_kafka_t *rk, int timeout_ms);\nvoid rd_kafka_yield(rd_kafka_t *rk);\nrd_kafka_resp_err_t rd_kafka_pause_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_resp_err_t rd_kafka_resume_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_resp_err_t rd_kafka_query_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high, int timeout_ms);\nrd_kafka_resp_err_t rd_kafka_get_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high);\nrd_kafka_resp_err_t rd_kafka_offsets_for_times(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets, int timeout_ms);\nvoid *rd_kafka_mem_calloc(rd_kafka_t *rk, size_t num, size_t size);\nvoid *rd_kafka_mem_malloc(rd_kafka_t *rk, size_t size);\nvoid rd_kafka_mem_free(rd_kafka_t *rk, void *ptr);\nrd_kafka_queue_t *rd_kafka_queue_new(rd_kafka_t *rk);\nvoid rd_kafka_queue_destroy(rd_kafka_queue_t *rkqu);\nrd_kafka_queue_t *rd_kafka_queue_get_main(rd_kafka_t *rk);\nrd_kafka_queue_t *rd_kafka_queue_get_sasl(rd_kafka_t *rk);\nrd_kafka_error_t *rd_kafka_sasl_background_callbacks_enable(rd_kafka_t *rk);\nrd_kafka_error_t *rd_kafka_sasl_set_credentials(rd_kafka_t *rk, const char *username, const char *password);\nrd_kafka_queue_t *rd_kafka_queue_get_consumer(rd_kafka_t *rk);\nrd_kafka_queue_t *rd_kafka_queue_get_partition(rd_kafka_t *rk, const char *topic, int32_t partition);\nrd_kafka_queue_t *rd_kafka_queue_get_background(rd_kafka_t *rk);\nvoid rd_kafka_queue_forward(rd_kafka_queue_t *src, rd_kafka_queue_t *dst);\nrd_kafka_resp_err_t rd_kafka_set_log_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu);\nsize_t rd_kafka_queue_length(rd_kafka_queue_t *rkqu);\nvoid rd_kafka_queue_io_event_enable(rd_kafka_queue_t *rkqu, int fd, const void *payload, size_t size);\nvoid rd_kafka_queue_cb_event_enable(rd_kafka_queue_t *rkqu, void (*event_cb)(rd_kafka_t *rk, void *qev_opaque), void *qev_opaque);\nvoid rd_kafka_queue_yield(rd_kafka_queue_t *rkqu);\nint rd_kafka_consume_start(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);\nint rd_kafka_consume_start_queue(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, rd_kafka_queue_t *rkqu);\nint rd_kafka_consume_stop(rd_kafka_topic_t *rkt, int32_t partition);\nrd_kafka_resp_err_t rd_kafka_seek(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, int timeout_ms);\nrd_kafka_error_t *rd_kafka_seek_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms);\nrd_kafka_message_t *rd_kafka_consume(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms);\nssize_t rd_kafka_consume_batch(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);\nint rd_kafka_consume_callback(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);\nrd_kafka_message_t *rd_kafka_consume_queue(rd_kafka_queue_t *rkqu, int timeout_ms);\nssize_t rd_kafka_consume_batch_queue(rd_kafka_queue_t *rkqu, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);\nint rd_kafka_consume_callback_queue(rd_kafka_queue_t *rkqu, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);\nrd_kafka_resp_err_t rd_kafka_offset_store(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);\nrd_kafka_resp_err_t rd_kafka_offsets_store(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets);\nrd_kafka_error_t *rd_kafka_offset_store_message(rd_kafka_message_t *rkmessage);\nrd_kafka_resp_err_t rd_kafka_subscribe(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *topics);\nrd_kafka_resp_err_t rd_kafka_unsubscribe(rd_kafka_t *rk);\nrd_kafka_resp_err_t rd_kafka_subscription(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **topics);\nrd_kafka_message_t *rd_kafka_consumer_poll(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_resp_err_t rd_kafka_consumer_close(rd_kafka_t *rk);\nrd_kafka_error_t *rd_kafka_consumer_close_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu);\nint rd_kafka_consumer_closed(rd_kafka_t *rk);\nrd_kafka_error_t *rd_kafka_incremental_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_error_t *rd_kafka_incremental_unassign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);\nconst char *rd_kafka_rebalance_protocol(rd_kafka_t *rk);\nrd_kafka_resp_err_t rd_kafka_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_resp_err_t rd_kafka_assignment(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **partitions);\nint rd_kafka_assignment_lost(rd_kafka_t *rk);\nrd_kafka_resp_err_t rd_kafka_commit(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, int async);\nrd_kafka_resp_err_t rd_kafka_commit_message(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, int async);\nrd_kafka_resp_err_t rd_kafka_commit_queue(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_queue_t *rkqu, void (*cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *commit_opaque), void *commit_opaque);\nrd_kafka_resp_err_t rd_kafka_committed(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms);\nrd_kafka_resp_err_t rd_kafka_position(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);\nrd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata(rd_kafka_t *rk);\nrd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata_new(const char *group_id);\nrd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata_new_with_genid(const char *group_id, int32_t generation_id, const char *member_id, const char *group_instance_id);\nconst char *rd_kafka_consumer_group_metadata_group_id(const rd_kafka_consumer_group_metadata_t *group_metadata);\nconst char *rd_kafka_consumer_group_metadata_group_instance_id(const rd_kafka_consumer_group_metadata_t *group_metadata);\nconst char *rd_kafka_consumer_group_metadata_member_id(const rd_kafka_consumer_group_metadata_t *group_metadata);\nint32_t rd_kafka_consumer_group_metadata_generation_id(const rd_kafka_consumer_group_metadata_t *group_metadata);\nvoid rd_kafka_consumer_group_metadata_destroy(rd_kafka_consumer_group_metadata_t *);\nrd_kafka_error_t *rd_kafka_consumer_group_metadata_write(const rd_kafka_consumer_group_metadata_t *cgmd, void **bufferp, size_t *sizep);\nrd_kafka_error_t *rd_kafka_consumer_group_metadata_read(rd_kafka_consumer_group_metadata_t **cgmdp, const void *buffer, size_t size);\nint rd_kafka_produce(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, void *payload, size_t len, const void *key, size_t keylen, void *msg_opaque);\nrd_kafka_resp_err_t rd_kafka_producev(rd_kafka_t *rk, ...);\nrd_kafka_error_t *rd_kafka_produceva(rd_kafka_t *rk, const rd_kafka_vu_t *vus, size_t cnt);\nint rd_kafka_produce_batch(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, rd_kafka_message_t *rkmessages, int message_cnt);\nrd_kafka_resp_err_t rd_kafka_flush(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_resp_err_t rd_kafka_purge(rd_kafka_t *rk, int purge_flags);\ntypedef struct rd_kafka_metadata_broker {\n  int32_t id;\n  char *host;\n  int port;\n} rd_kafka_metadata_broker_t;\ntypedef struct rd_kafka_metadata_partition {\n  int32_t id;\n  rd_kafka_resp_err_t err;\n  int32_t leader;\n  int replica_cnt;\n  int32_t *replicas;\n  int isr_cnt;\n  int32_t *isrs;\n} rd_kafka_metadata_partition_t;\ntypedef struct rd_kafka_metadata_topic {\n  char *topic;\n  int partition_cnt;\n  struct rd_kafka_metadata_partition *partitions;\n  rd_kafka_resp_err_t err;\n} rd_kafka_metadata_topic_t;\ntypedef struct rd_kafka_metadata {\n  int broker_cnt;\n  struct rd_kafka_metadata_broker *brokers;\n  int topic_cnt;\n  struct rd_kafka_metadata_topic *topics;\n  int32_t orig_broker_id;\n  char *orig_broker_name;\n} rd_kafka_metadata_t;\nrd_kafka_resp_err_t rd_kafka_metadata(rd_kafka_t *rk, int all_topics, rd_kafka_topic_t *only_rkt, const struct rd_kafka_metadata **metadatap, int timeout_ms);\nvoid rd_kafka_metadata_destroy(const struct rd_kafka_metadata *metadata);\ntypedef struct rd_kafka_Node_s rd_kafka_Node_t;\nint rd_kafka_Node_id(const rd_kafka_Node_t *node);\nconst char *rd_kafka_Node_host(const rd_kafka_Node_t *node);\nuint16_t rd_kafka_Node_port(const rd_kafka_Node_t *node);\nconst char *rd_kafka_Node_rack(const rd_kafka_Node_t *node);\nstruct rd_kafka_group_member_info {\n  char *member_id;\n  char *client_id;\n  char *client_host;\n  void *member_metadata;\n  int member_metadata_size;\n  void *member_assignment;\n  int member_assignment_size;\n};\ntypedef enum {\n  RD_KAFKA_CONSUMER_GROUP_STATE_UNKNOWN = 0,\n  RD_KAFKA_CONSUMER_GROUP_STATE_PREPARING_REBALANCE = 1,\n  RD_KAFKA_CONSUMER_GROUP_STATE_COMPLETING_REBALANCE = 2,\n  RD_KAFKA_CONSUMER_GROUP_STATE_STABLE = 3,\n  RD_KAFKA_CONSUMER_GROUP_STATE_DEAD = 4,\n  RD_KAFKA_CONSUMER_GROUP_STATE_EMPTY = 5,\n  RD_KAFKA_CONSUMER_GROUP_STATE__CNT,\n} rd_kafka_consumer_group_state_t;\ntypedef enum {\n  RD_KAFKA_CONSUMER_GROUP_TYPE_UNKNOWN = 0,\n  RD_KAFKA_CONSUMER_GROUP_TYPE_CONSUMER = 1,\n  RD_KAFKA_CONSUMER_GROUP_TYPE_CLASSIC = 2,\n  RD_KAFKA_CONSUMER_GROUP_TYPE__CNT,\n} rd_kafka_consumer_group_type_t;\nstruct rd_kafka_group_info {\n  struct rd_kafka_metadata_broker broker;\n  char *group;\n  rd_kafka_resp_err_t err;\n  char *state;\n  char *protocol_type;\n  char *protocol;\n  struct rd_kafka_group_member_info *members;\n  int member_cnt;\n};\nstruct rd_kafka_group_list {\n  struct rd_kafka_group_info *groups;\n  int group_cnt;\n};\nrd_kafka_resp_err_t rd_kafka_list_groups(rd_kafka_t *rk, const char *group, const struct rd_kafka_group_list **grplistp, int timeout_ms);\nconst char *rd_kafka_consumer_group_state_name(rd_kafka_consumer_group_state_t state);\nrd_kafka_consumer_group_state_t rd_kafka_consumer_group_state_code(const char *name);\nconst char *rd_kafka_consumer_group_type_name(rd_kafka_consumer_group_type_t type);\nrd_kafka_consumer_group_type_t rd_kafka_consumer_group_type_code(const char *name);\nvoid rd_kafka_group_list_destroy(const struct rd_kafka_group_list *grplist);\nint rd_kafka_brokers_add(rd_kafka_t *rk, const char *brokerlist);\nvoid rd_kafka_set_logger(rd_kafka_t *rk, void (*func)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));\nvoid rd_kafka_set_log_level(rd_kafka_t *rk, int level);\nvoid rd_kafka_log_print(const rd_kafka_t *rk, int level, const char *fac, const char *buf);\nvoid rd_kafka_log_syslog(const rd_kafka_t *rk, int level, const char *fac, const char *buf);\nint rd_kafka_outq_len(rd_kafka_t *rk);\nvoid rd_kafka_dump(FILE *fp, rd_kafka_t *rk);\nint rd_kafka_thread_cnt(void);\ntypedef enum rd_kafka_thread_type_t {\n  RD_KAFKA_THREAD_MAIN,\n  RD_KAFKA_THREAD_BACKGROUND,\n  RD_KAFKA_THREAD_BROKER,\n} rd_kafka_thread_type_t;\nint rd_kafka_wait_destroyed(int timeout_ms);\nint rd_kafka_unittest(void);\nrd_kafka_resp_err_t rd_kafka_poll_set_consumer(rd_kafka_t *rk);\ntypedef int rd_kafka_event_type_t;\nrd_kafka_event_type_t rd_kafka_event_type(const rd_kafka_event_t *rkev);\nconst char *rd_kafka_event_name(const rd_kafka_event_t *rkev);\nvoid rd_kafka_event_destroy(rd_kafka_event_t *rkev);\nconst rd_kafka_message_t *rd_kafka_event_message_next(rd_kafka_event_t *rkev);\nsize_t rd_kafka_event_message_array(rd_kafka_event_t *rkev, const rd_kafka_message_t **rkmessages, size_t size);\nsize_t rd_kafka_event_message_count(rd_kafka_event_t *rkev);\nconst char *rd_kafka_event_config_string(rd_kafka_event_t *rkev);\nrd_kafka_resp_err_t rd_kafka_event_error(rd_kafka_event_t *rkev);\nconst char *rd_kafka_event_error_string(rd_kafka_event_t *rkev);\nint rd_kafka_event_error_is_fatal(rd_kafka_event_t *rkev);\nvoid *rd_kafka_event_opaque(rd_kafka_event_t *rkev);\nint rd_kafka_event_log(rd_kafka_event_t *rkev, const char **fac, const char **str, int *level);\nint rd_kafka_event_debug_contexts(rd_kafka_event_t *rkev, char *dst, size_t dstsize);\nconst char *rd_kafka_event_stats(rd_kafka_event_t *rkev);\nrd_kafka_topic_partition_list_t *rd_kafka_event_topic_partition_list(rd_kafka_event_t *rkev);\nrd_kafka_topic_partition_t *rd_kafka_event_topic_partition(rd_kafka_event_t *rkev);\ntypedef rd_kafka_event_t rd_kafka_CreateTopics_result_t;\ntypedef rd_kafka_event_t rd_kafka_DeleteTopics_result_t;\ntypedef rd_kafka_event_t rd_kafka_CreateAcls_result_t;\ntypedef rd_kafka_event_t rd_kafka_DescribeAcls_result_t;\ntypedef rd_kafka_event_t rd_kafka_DeleteAcls_result_t;\ntypedef rd_kafka_event_t rd_kafka_CreatePartitions_result_t;\ntypedef rd_kafka_event_t rd_kafka_AlterConfigs_result_t;\ntypedef rd_kafka_event_t rd_kafka_IncrementalAlterConfigs_result_t;\ntypedef rd_kafka_event_t rd_kafka_DescribeConfigs_result_t;\ntypedef rd_kafka_event_t rd_kafka_DeleteRecords_result_t;\ntypedef rd_kafka_event_t rd_kafka_ListConsumerGroups_result_t;\ntypedef rd_kafka_event_t rd_kafka_DescribeConsumerGroups_result_t;\ntypedef rd_kafka_event_t rd_kafka_DeleteGroups_result_t;\ntypedef rd_kafka_event_t rd_kafka_DeleteConsumerGroupOffsets_result_t;\ntypedef rd_kafka_event_t rd_kafka_AlterConsumerGroupOffsets_result_t;\ntypedef rd_kafka_event_t rd_kafka_ListConsumerGroupOffsets_result_t;\ntypedef rd_kafka_event_t rd_kafka_DescribeTopics_result_t;\ntypedef rd_kafka_event_t rd_kafka_DescribeCluster_result_t;\ntypedef rd_kafka_event_t rd_kafka_DescribeUserScramCredentials_result_t;\ntypedef rd_kafka_event_t rd_kafka_AlterUserScramCredentials_result_t;\ntypedef rd_kafka_event_t rd_kafka_ListOffsets_result_t;\ntypedef rd_kafka_event_t rd_kafka_ElectLeaders_result_t;\nconst rd_kafka_CreateTopics_result_t *rd_kafka_event_CreateTopics_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DeleteTopics_result_t *rd_kafka_event_DeleteTopics_result(rd_kafka_event_t *rkev);\nconst rd_kafka_CreatePartitions_result_t *rd_kafka_event_CreatePartitions_result(rd_kafka_event_t *rkev);\nconst rd_kafka_AlterConfigs_result_t *rd_kafka_event_AlterConfigs_result(rd_kafka_event_t *rkev);\nconst rd_kafka_IncrementalAlterConfigs_result_t *rd_kafka_event_IncrementalAlterConfigs_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DescribeConfigs_result_t *rd_kafka_event_DescribeConfigs_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DeleteRecords_result_t *rd_kafka_event_DeleteRecords_result(rd_kafka_event_t *rkev);\nconst rd_kafka_ListConsumerGroups_result_t *rd_kafka_event_ListConsumerGroups_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DescribeConsumerGroups_result_t *rd_kafka_event_DescribeConsumerGroups_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DescribeTopics_result_t *rd_kafka_event_DescribeTopics_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DescribeCluster_result_t *rd_kafka_event_DescribeCluster_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DeleteGroups_result_t *rd_kafka_event_DeleteGroups_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DeleteConsumerGroupOffsets_result_t *rd_kafka_event_DeleteConsumerGroupOffsets_result(rd_kafka_event_t *rkev);\nconst rd_kafka_CreateAcls_result_t *rd_kafka_event_CreateAcls_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DescribeAcls_result_t *rd_kafka_event_DescribeAcls_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DeleteAcls_result_t *rd_kafka_event_DeleteAcls_result(rd_kafka_event_t *rkev);\nconst rd_kafka_ListConsumerGroupOffsets_result_t *rd_kafka_event_ListConsumerGroupOffsets_result(rd_kafka_event_t *rkev);\nconst rd_kafka_AlterConsumerGroupOffsets_result_t *rd_kafka_event_AlterConsumerGroupOffsets_result(rd_kafka_event_t *rkev);\nconst rd_kafka_ListOffsets_result_t *rd_kafka_event_ListOffsets_result(rd_kafka_event_t *rkev);\nconst rd_kafka_DescribeUserScramCredentials_result_t *rd_kafka_event_DescribeUserScramCredentials_result(rd_kafka_event_t *rkev);\nconst rd_kafka_AlterUserScramCredentials_result_t *rd_kafka_event_AlterUserScramCredentials_result(rd_kafka_event_t *rkev);\nconst rd_kafka_ElectLeaders_result_t *rd_kafka_event_ElectLeaders_result(rd_kafka_event_t *rkev);\nrd_kafka_event_t *rd_kafka_queue_poll(rd_kafka_queue_t *rkqu, int timeout_ms);\nint rd_kafka_queue_poll_callback(rd_kafka_queue_t *rkqu, int timeout_ms);\ntypedef rd_kafka_resp_err_t (rd_kafka_plugin_f_conf_init_t)(rd_kafka_conf_t *conf, void **plug_opaquep, char *errstr, size_t errstr_size);\ntypedef rd_kafka_conf_res_t (rd_kafka_interceptor_f_on_conf_set_t)(rd_kafka_conf_t *conf, const char *name, const char *val, char *errstr, size_t errstr_size, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_dup_t)(rd_kafka_conf_t *new_conf, const rd_kafka_conf_t *old_conf, size_t filter_cnt, const char **filter, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_destroy_t)(void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_new_t)(rd_kafka_t *rk, const rd_kafka_conf_t *conf, void *ic_opaque, char *errstr, size_t errstr_size);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_destroy_t)(rd_kafka_t *rk, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_send_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_acknowledgement_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_consume_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_commit_t)(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_resp_err_t err, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_request_sent_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_response_received_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, int64_t rtt, rd_kafka_resp_err_t err, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_start_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_exit_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);\ntypedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_broker_state_change_t)(rd_kafka_t *rk, int32_t broker_id, const char *secproto, const char *name, int port, const char *state, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_set(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_set_t *on_conf_set, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_dup(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_dup_t *on_conf_dup, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_destroy(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_destroy_t *on_conf_destroy, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_new(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_new_t *on_new, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_destroy(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_destroy_t *on_destroy, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_send(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_send_t *on_send, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_acknowledgement(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_acknowledgement_t *on_acknowledgement, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_consume(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_consume_t *on_consume, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_commit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_commit_t *on_commit, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_request_sent(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_request_sent_t *on_request_sent, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_response_received(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_response_received_t *on_response_received, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_start(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_start_t *on_thread_start, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_exit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_exit_t *on_thread_exit, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_interceptor_add_on_broker_state_change(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_broker_state_change_t *on_broker_state_change, void *ic_opaque);\nrd_kafka_resp_err_t rd_kafka_topic_result_error(const rd_kafka_topic_result_t *topicres);\nconst char *rd_kafka_topic_result_error_string(const rd_kafka_topic_result_t *topicres);\nconst char *rd_kafka_topic_result_name(const rd_kafka_topic_result_t *topicres);\nconst rd_kafka_error_t *rd_kafka_group_result_error(const rd_kafka_group_result_t *groupres);\nconst char *rd_kafka_group_result_name(const rd_kafka_group_result_t *groupres);\nconst rd_kafka_topic_partition_list_t *rd_kafka_group_result_partitions(const rd_kafka_group_result_t *groupres);\nconst rd_kafka_topic_partition_t *rd_kafka_topic_partition_result_partition(const rd_kafka_topic_partition_result_t *partition_result);\nconst rd_kafka_error_t *rd_kafka_topic_partition_result_error(const rd_kafka_topic_partition_result_t *partition_result);\ntypedef enum rd_kafka_admin_op_t {\n  RD_KAFKA_ADMIN_OP_ANY = 0,\n  RD_KAFKA_ADMIN_OP_CREATETOPICS,\n  RD_KAFKA_ADMIN_OP_DELETETOPICS,\n  RD_KAFKA_ADMIN_OP_CREATEPARTITIONS,\n  RD_KAFKA_ADMIN_OP_ALTERCONFIGS,\n  RD_KAFKA_ADMIN_OP_DESCRIBECONFIGS,\n  RD_KAFKA_ADMIN_OP_DELETERECORDS,\n  RD_KAFKA_ADMIN_OP_DELETEGROUPS,\n  RD_KAFKA_ADMIN_OP_DELETECONSUMERGROUPOFFSETS,\n  RD_KAFKA_ADMIN_OP_CREATEACLS,\n  RD_KAFKA_ADMIN_OP_DESCRIBEACLS,\n  RD_KAFKA_ADMIN_OP_DELETEACLS,\n  RD_KAFKA_ADMIN_OP_LISTCONSUMERGROUPS,\n  RD_KAFKA_ADMIN_OP_DESCRIBECONSUMERGROUPS,\n  RD_KAFKA_ADMIN_OP_LISTCONSUMERGROUPOFFSETS,\n  RD_KAFKA_ADMIN_OP_ALTERCONSUMERGROUPOFFSETS,\n  RD_KAFKA_ADMIN_OP_INCREMENTALALTERCONFIGS,\n  RD_KAFKA_ADMIN_OP_DESCRIBEUSERSCRAMCREDENTIALS,\n  RD_KAFKA_ADMIN_OP_ALTERUSERSCRAMCREDENTIALS,\n  RD_KAFKA_ADMIN_OP_DESCRIBETOPICS,\n  RD_KAFKA_ADMIN_OP_DESCRIBECLUSTER,\n  RD_KAFKA_ADMIN_OP_LISTOFFSETS,\n  RD_KAFKA_ADMIN_OP_ELECTLEADERS,\n  RD_KAFKA_ADMIN_OP__CNT,\n} rd_kafka_admin_op_t;\ntypedef struct rd_kafka_AdminOptions_s rd_kafka_AdminOptions_t;\ntypedef enum rd_kafka_IsolationLevel_t {\n  RD_KAFKA_ISOLATION_LEVEL_READ_UNCOMMITTED = 0,\n  RD_KAFKA_ISOLATION_LEVEL_READ_COMMITTED = 1,\n} rd_kafka_IsolationLevel_t;\nrd_kafka_AdminOptions_t *rd_kafka_AdminOptions_new(rd_kafka_t *rk, rd_kafka_admin_op_t for_api);\nvoid rd_kafka_AdminOptions_destroy(rd_kafka_AdminOptions_t *options);\nrd_kafka_resp_err_t rd_kafka_AdminOptions_set_request_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_AdminOptions_set_operation_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_AdminOptions_set_validate_only(rd_kafka_AdminOptions_t *options, int true_or_false, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_AdminOptions_set_broker(rd_kafka_AdminOptions_t *options, int32_t broker_id, char *errstr, size_t errstr_size);\nrd_kafka_error_t *rd_kafka_AdminOptions_set_require_stable_offsets(rd_kafka_AdminOptions_t *options, int true_or_false);\nrd_kafka_error_t *rd_kafka_AdminOptions_set_include_authorized_operations(rd_kafka_AdminOptions_t *options, int true_or_false);\nrd_kafka_error_t *rd_kafka_AdminOptions_set_match_consumer_group_states(rd_kafka_AdminOptions_t *options, const rd_kafka_consumer_group_state_t *consumer_group_states, size_t consumer_group_states_cnt);\nrd_kafka_error_t *rd_kafka_AdminOptions_set_match_consumer_group_types(rd_kafka_AdminOptions_t *options, const rd_kafka_consumer_group_type_t *consumer_group_types, size_t consumer_group_types_cnt);\nrd_kafka_error_t *rd_kafka_AdminOptions_set_isolation_level(rd_kafka_AdminOptions_t *options, rd_kafka_IsolationLevel_t value);\nvoid rd_kafka_AdminOptions_set_opaque(rd_kafka_AdminOptions_t *options, void *ev_opaque);\ntypedef enum rd_kafka_AclOperation_t {\n  RD_KAFKA_ACL_OPERATION_UNKNOWN = 0,\n  RD_KAFKA_ACL_OPERATION_ANY = 1,\n  RD_KAFKA_ACL_OPERATION_ALL = 2,\n  RD_KAFKA_ACL_OPERATION_READ = 3,\n  RD_KAFKA_ACL_OPERATION_WRITE = 4,\n  RD_KAFKA_ACL_OPERATION_CREATE = 5,\n  RD_KAFKA_ACL_OPERATION_DELETE = 6,\n  RD_KAFKA_ACL_OPERATION_ALTER = 7,\n  RD_KAFKA_ACL_OPERATION_DESCRIBE = 8,\n  RD_KAFKA_ACL_OPERATION_CLUSTER_ACTION = 9,\n  RD_KAFKA_ACL_OPERATION_DESCRIBE_CONFIGS = 10,\n  RD_KAFKA_ACL_OPERATION_ALTER_CONFIGS = 11,\n  RD_KAFKA_ACL_OPERATION_IDEMPOTENT_WRITE = 12,\n  RD_KAFKA_ACL_OPERATION__CNT,\n} rd_kafka_AclOperation_t;\ntypedef struct rd_kafka_NewTopic_s rd_kafka_NewTopic_t;\nrd_kafka_NewTopic_t *rd_kafka_NewTopic_new(const char *topic, int num_partitions, int replication_factor, char *errstr, size_t errstr_size);\nvoid rd_kafka_NewTopic_destroy(rd_kafka_NewTopic_t *new_topic);\nvoid rd_kafka_NewTopic_destroy_array(rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt);\nrd_kafka_resp_err_t rd_kafka_NewTopic_set_replica_assignment(rd_kafka_NewTopic_t *new_topic, int32_t partition, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_NewTopic_set_config(rd_kafka_NewTopic_t *new_topic, const char *name, const char *value);\nvoid rd_kafka_CreateTopics(rd_kafka_t *rk, rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_topic_result_t **rd_kafka_CreateTopics_result_topics(const rd_kafka_CreateTopics_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_DeleteTopic_s rd_kafka_DeleteTopic_t;\nrd_kafka_DeleteTopic_t *rd_kafka_DeleteTopic_new(const char *topic);\nvoid rd_kafka_DeleteTopic_destroy(rd_kafka_DeleteTopic_t *del_topic);\nvoid rd_kafka_DeleteTopic_destroy_array(rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt);\nvoid rd_kafka_DeleteTopics(rd_kafka_t *rk, rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_topic_result_t **rd_kafka_DeleteTopics_result_topics(const rd_kafka_DeleteTopics_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_NewPartitions_s rd_kafka_NewPartitions_t;\nrd_kafka_NewPartitions_t *rd_kafka_NewPartitions_new(const char *topic, size_t new_total_cnt, char *errstr, size_t errstr_size);\nvoid rd_kafka_NewPartitions_destroy(rd_kafka_NewPartitions_t *new_parts);\nvoid rd_kafka_NewPartitions_destroy_array(rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt);\nrd_kafka_resp_err_t rd_kafka_NewPartitions_set_replica_assignment(rd_kafka_NewPartitions_t *new_parts, int32_t new_partition_idx, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);\nvoid rd_kafka_CreatePartitions(rd_kafka_t *rk, rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_topic_result_t **rd_kafka_CreatePartitions_result_topics(const rd_kafka_CreatePartitions_result_t *result, size_t *cntp);\ntypedef enum rd_kafka_ConfigSource_t {\n  RD_KAFKA_CONFIG_SOURCE_UNKNOWN_CONFIG = 0,\n  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_TOPIC_CONFIG = 1,\n  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_BROKER_CONFIG = 2,\n  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_DEFAULT_BROKER_CONFIG = 3,\n  RD_KAFKA_CONFIG_SOURCE_STATIC_BROKER_CONFIG = 4,\n  RD_KAFKA_CONFIG_SOURCE_DEFAULT_CONFIG = 5,\n  RD_KAFKA_CONFIG_SOURCE__CNT,\n} rd_kafka_ConfigSource_t;\nconst char *rd_kafka_ConfigSource_name(rd_kafka_ConfigSource_t confsource);\ntypedef struct rd_kafka_ConfigEntry_s rd_kafka_ConfigEntry_t;\nconst char *rd_kafka_ConfigEntry_name(const rd_kafka_ConfigEntry_t *entry);\nconst char *rd_kafka_ConfigEntry_value(const rd_kafka_ConfigEntry_t *entry);\nrd_kafka_ConfigSource_t rd_kafka_ConfigEntry_source(const rd_kafka_ConfigEntry_t *entry);\nint rd_kafka_ConfigEntry_is_read_only(const rd_kafka_ConfigEntry_t *entry);\nint rd_kafka_ConfigEntry_is_default(const rd_kafka_ConfigEntry_t *entry);\nint rd_kafka_ConfigEntry_is_sensitive(const rd_kafka_ConfigEntry_t *entry);\nint rd_kafka_ConfigEntry_is_synonym(const rd_kafka_ConfigEntry_t *entry);\nconst rd_kafka_ConfigEntry_t **rd_kafka_ConfigEntry_synonyms(const rd_kafka_ConfigEntry_t *entry, size_t *cntp);\ntypedef enum rd_kafka_ResourceType_t {\n  RD_KAFKA_RESOURCE_UNKNOWN = 0,\n  RD_KAFKA_RESOURCE_ANY = 1,\n  RD_KAFKA_RESOURCE_TOPIC = 2,\n  RD_KAFKA_RESOURCE_GROUP = 3,\n  RD_KAFKA_RESOURCE_BROKER = 4,\n  RD_KAFKA_RESOURCE_TRANSACTIONAL_ID = 5,\n  RD_KAFKA_RESOURCE__CNT,\n} rd_kafka_ResourceType_t;\ntypedef enum rd_kafka_ResourcePatternType_t {\n  RD_KAFKA_RESOURCE_PATTERN_UNKNOWN = 0,\n  RD_KAFKA_RESOURCE_PATTERN_ANY = 1,\n  RD_KAFKA_RESOURCE_PATTERN_MATCH = 2,\n  RD_KAFKA_RESOURCE_PATTERN_LITERAL = 3,\n  RD_KAFKA_RESOURCE_PATTERN_PREFIXED = 4,\n  RD_KAFKA_RESOURCE_PATTERN_TYPE__CNT,\n} rd_kafka_ResourcePatternType_t;\ntypedef enum rd_kafka_AlterConfigOpType_t {\n  RD_KAFKA_ALTER_CONFIG_OP_TYPE_SET = 0,\n  RD_KAFKA_ALTER_CONFIG_OP_TYPE_DELETE = 1,\n  RD_KAFKA_ALTER_CONFIG_OP_TYPE_APPEND = 2,\n  RD_KAFKA_ALTER_CONFIG_OP_TYPE_SUBTRACT = 3,\n  RD_KAFKA_ALTER_CONFIG_OP_TYPE__CNT,\n} rd_kafka_AlterConfigOpType_t;\nconst char *rd_kafka_ResourcePatternType_name(rd_kafka_ResourcePatternType_t resource_pattern_type);\nconst char *rd_kafka_ResourceType_name(rd_kafka_ResourceType_t restype);\ntypedef struct rd_kafka_ConfigResource_s rd_kafka_ConfigResource_t;\nrd_kafka_ConfigResource_t *rd_kafka_ConfigResource_new(rd_kafka_ResourceType_t restype, const char *resname);\nvoid rd_kafka_ConfigResource_destroy(rd_kafka_ConfigResource_t *config);\nvoid rd_kafka_ConfigResource_destroy_array(rd_kafka_ConfigResource_t **config, size_t config_cnt);\nrd_kafka_resp_err_t rd_kafka_ConfigResource_set_config(rd_kafka_ConfigResource_t *config, const char *name, const char *value);\nrd_kafka_error_t *rd_kafka_ConfigResource_add_incremental_config(rd_kafka_ConfigResource_t *config, const char *name, rd_kafka_AlterConfigOpType_t op_type, const char *value);\nconst rd_kafka_ConfigEntry_t **rd_kafka_ConfigResource_configs(const rd_kafka_ConfigResource_t *config, size_t *cntp);\nrd_kafka_ResourceType_t rd_kafka_ConfigResource_type(const rd_kafka_ConfigResource_t *config);\nconst char *rd_kafka_ConfigResource_name(const rd_kafka_ConfigResource_t *config);\nrd_kafka_resp_err_t rd_kafka_ConfigResource_error(const rd_kafka_ConfigResource_t *config);\nconst char *rd_kafka_ConfigResource_error_string(const rd_kafka_ConfigResource_t *config);\nvoid rd_kafka_AlterConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_ConfigResource_t **rd_kafka_AlterConfigs_result_resources(const rd_kafka_AlterConfigs_result_t *result, size_t *cntp);\nvoid rd_kafka_IncrementalAlterConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_ConfigResource_t **rd_kafka_IncrementalAlterConfigs_result_resources(const rd_kafka_IncrementalAlterConfigs_result_t *result, size_t *cntp);\nvoid rd_kafka_DescribeConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_ConfigResource_t **rd_kafka_DescribeConfigs_result_resources(const rd_kafka_DescribeConfigs_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_DeleteRecords_s rd_kafka_DeleteRecords_t;\nrd_kafka_DeleteRecords_t *rd_kafka_DeleteRecords_new(const rd_kafka_topic_partition_list_t *before_offsets);\nvoid rd_kafka_DeleteRecords_destroy(rd_kafka_DeleteRecords_t *del_records);\nvoid rd_kafka_DeleteRecords_destroy_array(rd_kafka_DeleteRecords_t **del_records, size_t del_record_cnt);\nvoid rd_kafka_DeleteRecords(rd_kafka_t *rk, rd_kafka_DeleteRecords_t **del_records, size_t del_record_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_topic_partition_list_t *rd_kafka_DeleteRecords_result_offsets(const rd_kafka_DeleteRecords_result_t *result);\ntypedef struct rd_kafka_TopicCollection_s rd_kafka_TopicCollection_t;\ntypedef struct rd_kafka_TopicPartitionInfo_s rd_kafka_TopicPartitionInfo_t;\ntypedef struct rd_kafka_TopicDescription_s rd_kafka_TopicDescription_t;\nrd_kafka_TopicCollection_t *rd_kafka_TopicCollection_of_topic_names(const char **topics, size_t topics_cnt);\nvoid rd_kafka_TopicCollection_destroy(rd_kafka_TopicCollection_t *topics);\nvoid rd_kafka_DescribeTopics(rd_kafka_t *rk, const rd_kafka_TopicCollection_t *topics, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_TopicDescription_t **rd_kafka_DescribeTopics_result_topics(const rd_kafka_DescribeTopics_result_t *result, size_t *cntp);\nconst rd_kafka_TopicPartitionInfo_t **rd_kafka_TopicDescription_partitions(const rd_kafka_TopicDescription_t *topicdesc, size_t *cntp);\nconst int rd_kafka_TopicPartitionInfo_partition(const rd_kafka_TopicPartitionInfo_t *partition);\nconst rd_kafka_Node_t *rd_kafka_TopicPartitionInfo_leader(const rd_kafka_TopicPartitionInfo_t *partition);\nconst rd_kafka_Node_t **rd_kafka_TopicPartitionInfo_isr(const rd_kafka_TopicPartitionInfo_t *partition, size_t *cntp);\nconst rd_kafka_Node_t **rd_kafka_TopicPartitionInfo_replicas(const rd_kafka_TopicPartitionInfo_t *partition, size_t *cntp);\nconst rd_kafka_AclOperation_t *rd_kafka_TopicDescription_authorized_operations(const rd_kafka_TopicDescription_t *topicdesc, size_t *cntp);\nconst char *rd_kafka_TopicDescription_name(const rd_kafka_TopicDescription_t *topicdesc);\nconst rd_kafka_Uuid_t *rd_kafka_TopicDescription_topic_id(const rd_kafka_TopicDescription_t *topicdesc);\nint rd_kafka_TopicDescription_is_internal(const rd_kafka_TopicDescription_t *topicdesc);\nconst rd_kafka_error_t *rd_kafka_TopicDescription_error(const rd_kafka_TopicDescription_t *topicdesc);\nvoid rd_kafka_DescribeCluster(rd_kafka_t *rk, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_Node_t **rd_kafka_DescribeCluster_result_nodes(const rd_kafka_DescribeCluster_result_t *result, size_t *cntp);\nconst rd_kafka_AclOperation_t *rd_kafka_DescribeCluster_result_authorized_operations(const rd_kafka_DescribeCluster_result_t *result, size_t *cntp);\nconst rd_kafka_Node_t *rd_kafka_DescribeCluster_result_controller(const rd_kafka_DescribeCluster_result_t *result);\nconst char *rd_kafka_DescribeCluster_result_cluster_id(const rd_kafka_DescribeCluster_result_t *result);\ntypedef struct rd_kafka_ConsumerGroupListing_s rd_kafka_ConsumerGroupListing_t;\ntypedef struct rd_kafka_ListConsumerGroupsResult_s rd_kafka_ListConsumerGroupsResult_t;\nvoid rd_kafka_ListConsumerGroups(rd_kafka_t *rk, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst char *rd_kafka_ConsumerGroupListing_group_id(const rd_kafka_ConsumerGroupListing_t *grplist);\nint rd_kafka_ConsumerGroupListing_is_simple_consumer_group(const rd_kafka_ConsumerGroupListing_t *grplist);\nrd_kafka_consumer_group_state_t rd_kafka_ConsumerGroupListing_state(const rd_kafka_ConsumerGroupListing_t *grplist);\nrd_kafka_consumer_group_type_t rd_kafka_ConsumerGroupListing_type(const rd_kafka_ConsumerGroupListing_t *grplist);\nconst rd_kafka_ConsumerGroupListing_t **rd_kafka_ListConsumerGroups_result_valid(const rd_kafka_ListConsumerGroups_result_t *result, size_t *cntp);\nconst rd_kafka_error_t **rd_kafka_ListConsumerGroups_result_errors(const rd_kafka_ListConsumerGroups_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_ConsumerGroupDescription_s rd_kafka_ConsumerGroupDescription_t;\ntypedef struct rd_kafka_MemberDescription_s rd_kafka_MemberDescription_t;\ntypedef struct rd_kafka_MemberAssignment_s rd_kafka_MemberAssignment_t;\nvoid rd_kafka_DescribeConsumerGroups(rd_kafka_t *rk, const char **groups, size_t groups_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_ConsumerGroupDescription_t **rd_kafka_DescribeConsumerGroups_result_groups(const rd_kafka_DescribeConsumerGroups_result_t *result, size_t *cntp);\nconst char *rd_kafka_ConsumerGroupDescription_group_id(const rd_kafka_ConsumerGroupDescription_t *grpdesc);\nconst rd_kafka_error_t *rd_kafka_ConsumerGroupDescription_error(const rd_kafka_ConsumerGroupDescription_t *grpdesc);\nint rd_kafka_ConsumerGroupDescription_is_simple_consumer_group(const rd_kafka_ConsumerGroupDescription_t *grpdesc);\nconst char *rd_kafka_ConsumerGroupDescription_partition_assignor(const rd_kafka_ConsumerGroupDescription_t *grpdesc);\nconst rd_kafka_AclOperation_t *rd_kafka_ConsumerGroupDescription_authorized_operations(const rd_kafka_ConsumerGroupDescription_t *grpdesc, size_t *cntp);\nrd_kafka_consumer_group_state_t rd_kafka_ConsumerGroupDescription_state(const rd_kafka_ConsumerGroupDescription_t *grpdesc);\nconst rd_kafka_Node_t *rd_kafka_ConsumerGroupDescription_coordinator(const rd_kafka_ConsumerGroupDescription_t *grpdesc);\nsize_t rd_kafka_ConsumerGroupDescription_member_count(const rd_kafka_ConsumerGroupDescription_t *grpdesc);\nconst rd_kafka_MemberDescription_t *rd_kafka_ConsumerGroupDescription_member(const rd_kafka_ConsumerGroupDescription_t *grpdesc, size_t idx);\nconst char *rd_kafka_MemberDescription_client_id(const rd_kafka_MemberDescription_t *member);\nconst char *rd_kafka_MemberDescription_group_instance_id(const rd_kafka_MemberDescription_t *member);\nconst char *rd_kafka_MemberDescription_consumer_id(const rd_kafka_MemberDescription_t *member);\nconst char *rd_kafka_MemberDescription_host(const rd_kafka_MemberDescription_t *member);\nconst rd_kafka_MemberAssignment_t *rd_kafka_MemberDescription_assignment(const rd_kafka_MemberDescription_t *member);\nconst rd_kafka_topic_partition_list_t *rd_kafka_MemberAssignment_partitions(const rd_kafka_MemberAssignment_t *assignment);\ntypedef struct rd_kafka_DeleteGroup_s rd_kafka_DeleteGroup_t;\nrd_kafka_DeleteGroup_t *rd_kafka_DeleteGroup_new(const char *group);\nvoid rd_kafka_DeleteGroup_destroy(rd_kafka_DeleteGroup_t *del_group);\nvoid rd_kafka_DeleteGroup_destroy_array(rd_kafka_DeleteGroup_t **del_groups, size_t del_group_cnt);\nvoid rd_kafka_DeleteGroups(rd_kafka_t *rk, rd_kafka_DeleteGroup_t **del_groups, size_t del_group_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_group_result_t **rd_kafka_DeleteGroups_result_groups(const rd_kafka_DeleteGroups_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_ListConsumerGroupOffsets_s rd_kafka_ListConsumerGroupOffsets_t;\nrd_kafka_ListConsumerGroupOffsets_t *rd_kafka_ListConsumerGroupOffsets_new(const char *group_id, const rd_kafka_topic_partition_list_t *partitions);\nvoid rd_kafka_ListConsumerGroupOffsets_destroy(rd_kafka_ListConsumerGroupOffsets_t *list_grpoffsets);\nvoid rd_kafka_ListConsumerGroupOffsets_destroy_array(rd_kafka_ListConsumerGroupOffsets_t **list_grpoffsets, size_t list_grpoffset_cnt);\nvoid rd_kafka_ListConsumerGroupOffsets(rd_kafka_t *rk, rd_kafka_ListConsumerGroupOffsets_t **list_grpoffsets, size_t list_grpoffsets_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_group_result_t **rd_kafka_ListConsumerGroupOffsets_result_groups(const rd_kafka_ListConsumerGroupOffsets_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_AlterConsumerGroupOffsets_s rd_kafka_AlterConsumerGroupOffsets_t;\nrd_kafka_AlterConsumerGroupOffsets_t *rd_kafka_AlterConsumerGroupOffsets_new(const char *group_id, const rd_kafka_topic_partition_list_t *partitions);\nvoid rd_kafka_AlterConsumerGroupOffsets_destroy(rd_kafka_AlterConsumerGroupOffsets_t *alter_grpoffsets);\nvoid rd_kafka_AlterConsumerGroupOffsets_destroy_array(rd_kafka_AlterConsumerGroupOffsets_t **alter_grpoffsets, size_t alter_grpoffset_cnt);\nvoid rd_kafka_AlterConsumerGroupOffsets(rd_kafka_t *rk, rd_kafka_AlterConsumerGroupOffsets_t **alter_grpoffsets, size_t alter_grpoffsets_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_group_result_t **rd_kafka_AlterConsumerGroupOffsets_result_groups(const rd_kafka_AlterConsumerGroupOffsets_result_t *result, size_t *cntp);\ntypedef struct rd_kafka_DeleteConsumerGroupOffsets_s rd_kafka_DeleteConsumerGroupOffsets_t;\nrd_kafka_DeleteConsumerGroupOffsets_t *rd_kafka_DeleteConsumerGroupOffsets_new(const char *group, const rd_kafka_topic_partition_list_t *partitions);\nvoid rd_kafka_DeleteConsumerGroupOffsets_destroy(rd_kafka_DeleteConsumerGroupOffsets_t *del_grpoffsets);\nvoid rd_kafka_DeleteConsumerGroupOffsets_destroy_array(rd_kafka_DeleteConsumerGroupOffsets_t **del_grpoffsets, size_t del_grpoffset_cnt);\nvoid rd_kafka_DeleteConsumerGroupOffsets(rd_kafka_t *rk, rd_kafka_DeleteConsumerGroupOffsets_t **del_grpoffsets, size_t del_grpoffsets_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_group_result_t **rd_kafka_DeleteConsumerGroupOffsets_result_groups(const rd_kafka_DeleteConsumerGroupOffsets_result_t *result, size_t *cntp);\ntypedef enum rd_kafka_OffsetSpec_t {\n  RD_KAFKA_OFFSET_SPEC_MAX_TIMESTAMP = (- 3),\n  RD_KAFKA_OFFSET_SPEC_EARLIEST = (- 2),\n  RD_KAFKA_OFFSET_SPEC_LATEST = (- 1),\n} rd_kafka_OffsetSpec_t;\ntypedef struct rd_kafka_ListOffsetsResultInfo_s rd_kafka_ListOffsetsResultInfo_t;\nconst rd_kafka_topic_partition_t *rd_kafka_ListOffsetsResultInfo_topic_partition(const rd_kafka_ListOffsetsResultInfo_t *result_info);\nint64_t rd_kafka_ListOffsetsResultInfo_timestamp(const rd_kafka_ListOffsetsResultInfo_t *result_info);\nconst rd_kafka_ListOffsetsResultInfo_t **rd_kafka_ListOffsets_result_infos(const rd_kafka_ListOffsets_result_t *result, size_t *cntp);\nvoid rd_kafka_ListOffsets(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *topic_partitions, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\ntypedef enum rd_kafka_ScramMechanism_t {\n  RD_KAFKA_SCRAM_MECHANISM_UNKNOWN = 0,\n  RD_KAFKA_SCRAM_MECHANISM_SHA_256 = 1,\n  RD_KAFKA_SCRAM_MECHANISM_SHA_512 = 2,\n  RD_KAFKA_SCRAM_MECHANISM__CNT,\n} rd_kafka_ScramMechanism_t;\ntypedef struct rd_kafka_ScramCredentialInfo_s rd_kafka_ScramCredentialInfo_t;\nrd_kafka_ScramMechanism_t rd_kafka_ScramCredentialInfo_mechanism(const rd_kafka_ScramCredentialInfo_t *scram_credential_info);\nint32_t rd_kafka_ScramCredentialInfo_iterations(const rd_kafka_ScramCredentialInfo_t *scram_credential_info);\ntypedef struct rd_kafka_UserScramCredentialsDescription_s rd_kafka_UserScramCredentialsDescription_t;\nconst char *rd_kafka_UserScramCredentialsDescription_user(const rd_kafka_UserScramCredentialsDescription_t *description);\nconst rd_kafka_error_t *rd_kafka_UserScramCredentialsDescription_error(const rd_kafka_UserScramCredentialsDescription_t *description);\nsize_t rd_kafka_UserScramCredentialsDescription_scramcredentialinfo_count(const rd_kafka_UserScramCredentialsDescription_t *description);\nconst rd_kafka_ScramCredentialInfo_t *rd_kafka_UserScramCredentialsDescription_scramcredentialinfo(const rd_kafka_UserScramCredentialsDescription_t *description, size_t idx);\nconst rd_kafka_UserScramCredentialsDescription_t **rd_kafka_DescribeUserScramCredentials_result_descriptions(const rd_kafka_DescribeUserScramCredentials_result_t *result, size_t *cntp);\nvoid rd_kafka_DescribeUserScramCredentials(rd_kafka_t *rk, const char **users, size_t user_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\ntypedef struct rd_kafka_UserScramCredentialAlteration_s rd_kafka_UserScramCredentialAlteration_t;\nrd_kafka_UserScramCredentialAlteration_t *rd_kafka_UserScramCredentialUpsertion_new(const char *username, rd_kafka_ScramMechanism_t mechanism, int32_t iterations, const unsigned char *password, size_t password_size, const unsigned char *salt, size_t salt_size);\nrd_kafka_UserScramCredentialAlteration_t *rd_kafka_UserScramCredentialDeletion_new(const char *username, rd_kafka_ScramMechanism_t mechanism);\nvoid rd_kafka_UserScramCredentialAlteration_destroy(rd_kafka_UserScramCredentialAlteration_t *alteration);\nvoid rd_kafka_UserScramCredentialAlteration_destroy_array(rd_kafka_UserScramCredentialAlteration_t **alterations, size_t alteration_cnt);\ntypedef struct rd_kafka_AlterUserScramCredentials_result_response_s rd_kafka_AlterUserScramCredentials_result_response_t;\nconst char *rd_kafka_AlterUserScramCredentials_result_response_user(const rd_kafka_AlterUserScramCredentials_result_response_t *response);\nconst rd_kafka_error_t *rd_kafka_AlterUserScramCredentials_result_response_error(const rd_kafka_AlterUserScramCredentials_result_response_t *response);\nconst rd_kafka_AlterUserScramCredentials_result_response_t **rd_kafka_AlterUserScramCredentials_result_responses(const rd_kafka_AlterUserScramCredentials_result_t *result, size_t *cntp);\nvoid rd_kafka_AlterUserScramCredentials(rd_kafka_t *rk, rd_kafka_UserScramCredentialAlteration_t **alterations, size_t alteration_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\ntypedef struct rd_kafka_AclBinding_s rd_kafka_AclBinding_t;\ntypedef rd_kafka_AclBinding_t rd_kafka_AclBindingFilter_t;\nconst rd_kafka_error_t *rd_kafka_acl_result_error(const rd_kafka_acl_result_t *aclres);\nconst char *rd_kafka_AclOperation_name(rd_kafka_AclOperation_t acl_operation);\ntypedef enum rd_kafka_AclPermissionType_t {\n  RD_KAFKA_ACL_PERMISSION_TYPE_UNKNOWN = 0,\n  RD_KAFKA_ACL_PERMISSION_TYPE_ANY = 1,\n  RD_KAFKA_ACL_PERMISSION_TYPE_DENY = 2,\n  RD_KAFKA_ACL_PERMISSION_TYPE_ALLOW = 3,\n  RD_KAFKA_ACL_PERMISSION_TYPE__CNT,\n} rd_kafka_AclPermissionType_t;\nconst char *rd_kafka_AclPermissionType_name(rd_kafka_AclPermissionType_t acl_permission_type);\nrd_kafka_AclBinding_t *rd_kafka_AclBinding_new(rd_kafka_ResourceType_t restype, const char *name, rd_kafka_ResourcePatternType_t resource_pattern_type, const char *principal, const char *host, rd_kafka_AclOperation_t operation, rd_kafka_AclPermissionType_t permission_type, char *errstr, size_t errstr_size);\nrd_kafka_AclBindingFilter_t *rd_kafka_AclBindingFilter_new(rd_kafka_ResourceType_t restype, const char *name, rd_kafka_ResourcePatternType_t resource_pattern_type, const char *principal, const char *host, rd_kafka_AclOperation_t operation, rd_kafka_AclPermissionType_t permission_type, char *errstr, size_t errstr_size);\nrd_kafka_ResourceType_t rd_kafka_AclBinding_restype(const rd_kafka_AclBinding_t *acl);\nconst char *rd_kafka_AclBinding_name(const rd_kafka_AclBinding_t *acl);\nconst char *rd_kafka_AclBinding_principal(const rd_kafka_AclBinding_t *acl);\nconst char *rd_kafka_AclBinding_host(const rd_kafka_AclBinding_t *acl);\nrd_kafka_AclOperation_t rd_kafka_AclBinding_operation(const rd_kafka_AclBinding_t *acl);\nrd_kafka_AclPermissionType_t rd_kafka_AclBinding_permission_type(const rd_kafka_AclBinding_t *acl);\nrd_kafka_ResourcePatternType_t rd_kafka_AclBinding_resource_pattern_type(const rd_kafka_AclBinding_t *acl);\nconst rd_kafka_error_t *rd_kafka_AclBinding_error(const rd_kafka_AclBinding_t *acl);\nvoid rd_kafka_AclBinding_destroy(rd_kafka_AclBinding_t *acl_binding);\nvoid rd_kafka_AclBinding_destroy_array(rd_kafka_AclBinding_t **acl_bindings, size_t acl_bindings_cnt);\nconst rd_kafka_acl_result_t **rd_kafka_CreateAcls_result_acls(const rd_kafka_CreateAcls_result_t *result, size_t *cntp);\nvoid rd_kafka_CreateAcls(rd_kafka_t *rk, rd_kafka_AclBinding_t **new_acls, size_t new_acls_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_AclBinding_t **rd_kafka_DescribeAcls_result_acls(const rd_kafka_DescribeAcls_result_t *result, size_t *cntp);\nvoid rd_kafka_DescribeAcls(rd_kafka_t *rk, rd_kafka_AclBindingFilter_t *acl_filter, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\ntypedef struct rd_kafka_DeleteAcls_result_response_s rd_kafka_DeleteAcls_result_response_t;\nconst rd_kafka_DeleteAcls_result_response_t **rd_kafka_DeleteAcls_result_responses(const rd_kafka_DeleteAcls_result_t *result, size_t *cntp);\nconst rd_kafka_error_t *rd_kafka_DeleteAcls_result_response_error(const rd_kafka_DeleteAcls_result_response_t *result_response);\nconst rd_kafka_AclBinding_t **rd_kafka_DeleteAcls_result_response_matching_acls(const rd_kafka_DeleteAcls_result_response_t *result_response, size_t *matching_acls_cntp);\nvoid rd_kafka_DeleteAcls(rd_kafka_t *rk, rd_kafka_AclBindingFilter_t **del_acls, size_t del_acls_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\ntypedef struct rd_kafka_ElectLeaders_s rd_kafka_ElectLeaders_t;\ntypedef enum rd_kafka_ElectionType_t {\n  RD_KAFKA_ELECTION_TYPE_PREFERRED = 0,\n  RD_KAFKA_ELECTION_TYPE_UNCLEAN = 1,\n} rd_kafka_ElectionType_t;\nrd_kafka_ElectLeaders_t *rd_kafka_ElectLeaders_new(rd_kafka_ElectionType_t election_type, rd_kafka_topic_partition_list_t *partitions);\nvoid rd_kafka_ElectLeaders_destroy(rd_kafka_ElectLeaders_t *elect_leaders);\nvoid rd_kafka_ElectLeaders(rd_kafka_t *rk, rd_kafka_ElectLeaders_t *elect_leaders, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);\nconst rd_kafka_topic_partition_result_t **rd_kafka_ElectLeaders_result_partitions(const rd_kafka_ElectLeaders_result_t *result, size_t *cntp);\nrd_kafka_resp_err_t rd_kafka_oauthbearer_set_token(rd_kafka_t *rk, const char *token_value, int64_t md_lifetime_ms, const char *md_principal_name, const char **extensions, size_t extension_size, char *errstr, size_t errstr_size);\nrd_kafka_resp_err_t rd_kafka_oauthbearer_set_token_failure(rd_kafka_t *rk, const char *errstr);\nrd_kafka_error_t *rd_kafka_init_transactions(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_error_t *rd_kafka_begin_transaction(rd_kafka_t *rk);\nrd_kafka_error_t *rd_kafka_send_offsets_to_transaction(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, const rd_kafka_consumer_group_metadata_t *cgmetadata, int timeout_ms);\nrd_kafka_error_t *rd_kafka_commit_transaction(rd_kafka_t *rk, int timeout_ms);\nrd_kafka_error_t *rd_kafka_abort_transaction(rd_kafka_t *rk, int timeout_ms);\ntypedef struct rd_kafka_mock_cluster_s rd_kafka_mock_cluster_t;\nrd_kafka_mock_cluster_t *rd_kafka_mock_cluster_new(rd_kafka_t *rk, int broker_cnt);\nvoid rd_kafka_mock_cluster_destroy(rd_kafka_mock_cluster_t *mcluster);\nrd_kafka_t *rd_kafka_mock_cluster_handle(const rd_kafka_mock_cluster_t *mcluster);\nrd_kafka_mock_cluster_t *rd_kafka_handle_mock_cluster(const rd_kafka_t *rk);\nconst char *rd_kafka_mock_cluster_bootstraps(const rd_kafka_mock_cluster_t *mcluster);\nvoid rd_kafka_mock_clear_request_errors(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey);\nvoid rd_kafka_mock_push_request_errors(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, size_t cnt, ...);\nvoid rd_kafka_mock_push_request_errors_array(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, size_t cnt, const rd_kafka_resp_err_t *errors);\nvoid rd_kafka_mock_group_initial_rebalance_delay_ms(rd_kafka_mock_cluster_t *mcluster, int32_t delay_ms);\nrd_kafka_resp_err_t rd_kafka_mock_broker_push_request_error_rtts(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int16_t ApiKey, size_t cnt, ...);\nrd_kafka_resp_err_t rd_kafka_mock_broker_error_stack_cnt(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int16_t ApiKey, size_t *cntp);\nvoid rd_kafka_mock_topic_set_error(rd_kafka_mock_cluster_t *mcluster, const char *topic, rd_kafka_resp_err_t err);\nrd_kafka_resp_err_t rd_kafka_mock_topic_create(rd_kafka_mock_cluster_t *mcluster, const char *topic, int partition_cnt, int replication_factor);\nrd_kafka_resp_err_t rd_kafka_mock_partition_set_leader(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id);\nrd_kafka_resp_err_t rd_kafka_mock_partition_set_follower(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id);\nrd_kafka_resp_err_t rd_kafka_mock_partition_set_follower_wmarks(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int64_t lo, int64_t hi);\nrd_kafka_resp_err_t rd_kafka_mock_partition_push_leader_response(rd_kafka_mock_cluster_t *mcluster, const char *topic, int partition, int32_t leader_id, int32_t leader_epoch);\nrd_kafka_resp_err_t rd_kafka_mock_broker_set_down(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id);\nrd_kafka_resp_err_t rd_kafka_mock_broker_set_up(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id);\nrd_kafka_resp_err_t rd_kafka_mock_broker_set_rtt(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int rtt_ms);\nrd_kafka_resp_err_t rd_kafka_mock_broker_set_rack(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, const char *rack);\nrd_kafka_resp_err_t rd_kafka_mock_coordinator_set(rd_kafka_mock_cluster_t *mcluster, const char *key_type, const char *key, int32_t broker_id);\nrd_kafka_resp_err_t rd_kafka_mock_set_apiversion(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, int16_t MinVersion, int16_t MaxVersion);\nvoid rd_kafka_mock_start_request_tracking(rd_kafka_mock_cluster_t *mcluster);\nvoid rd_kafka_mock_stop_request_tracking(rd_kafka_mock_cluster_t *mcluster);\ntypedef struct rd_kafka_mock_request_s rd_kafka_mock_request_t;\nvoid rd_kafka_mock_request_destroy(rd_kafka_mock_request_t *mreq);\nvoid rd_kafka_mock_request_destroy_array(rd_kafka_mock_request_t **mreqs, size_t mreq_cnt);\nint32_t rd_kafka_mock_request_id(rd_kafka_mock_request_t *mreq);\nint16_t rd_kafka_mock_request_api_key(rd_kafka_mock_request_t *mreq);\nint64_t rd_kafka_mock_request_timestamp(rd_kafka_mock_request_t *mreq);\nrd_kafka_mock_request_t **rd_kafka_mock_get_requests(rd_kafka_mock_cluster_t *mcluster, size_t *cntp);\nvoid rd_kafka_mock_clear_requests(rd_kafka_mock_cluster_t *mcluster);\nrd_kafka_resp_err_t rd_kafka_mock_telemetry_set_requested_metrics(rd_kafka_mock_cluster_t *mcluster, char **metrics, size_t metrics_cnt);\nrd_kafka_resp_err_t rd_kafka_mock_telemetry_set_push_interval(rd_kafka_mock_cluster_t *mcluster, int64_t push_interval_ms);\ntypedef struct rd_kafka_mock_cgrp_consumer_target_assignment_s rd_kafka_mock_cgrp_consumer_target_assignment_t;\nrd_kafka_mock_cgrp_consumer_target_assignment_t *rd_kafka_mock_cgrp_consumer_target_assignment_new(char **member_ids, int member_cnt, rd_kafka_topic_partition_list_t **assignment);\nvoid rd_kafka_mock_cgrp_consumer_target_assignment_destroy(rd_kafka_mock_cgrp_consumer_target_assignment_t *target_assignment);\nvoid rd_kafka_mock_cgrp_consumer_target_assignment(rd_kafka_mock_cluster_t *mcluster, const char *group_id, rd_kafka_mock_cgrp_consumer_target_assignment_t *target_assignment);\nvoid rd_kafka_mock_set_group_consumer_session_timeout_ms(rd_kafka_mock_cluster_t *mcluster, int group_consumer_session_timeout_ms);\nvoid rd_kafka_mock_set_group_consumer_heartbeat_interval_ms(rd_kafka_mock_cluster_t *mcluster, int group_consumer_heartbeat_interval_ms);\n'\n</code></pre> rdkafka.h, rdkafka_mock.h</p>"},{"location":"api/functions/","title":"Functions","text":""},{"location":"api/functions/#rd_kafka_err2name","title":"rd_kafka_err2name","text":"<pre><code>\\rd_kafka_err2name() ( \n    int $err\n ): string\n</code></pre> Parameters err <code>int</code> Error code Returns <code>string</code> The error name as a string."},{"location":"api/functions/#rd_kafka_err2str","title":"rd_kafka_err2str","text":"<pre><code>\\rd_kafka_err2str() ( \n    int $err\n ): string\n</code></pre> Parameters err <code>int</code> Error code Returns <code>string</code> The error description a string."},{"location":"api/functions/#rd_kafka_errno2err","title":"rd_kafka_errno2err","text":"<pre><code>\\rd_kafka_errno2err() ( \n    int $errnox\n ): int\n</code></pre> Parameters errnox <code>int</code> A system errno Returns <code>int</code> A kafka error code as an integer. <p>Deprecated</p>"},{"location":"api/functions/#rd_kafka_errno","title":"rd_kafka_errno","text":"<pre><code>\\rd_kafka_errno() (  ): int\n</code></pre> Returns <code>int</code> The system errno as an integer. <p>Deprecated</p>"},{"location":"api/functions/#rd_kafka_offset_tail","title":"rd_kafka_offset_tail","text":"<pre><code>\\rd_kafka_offset_tail() ( \n    int $cnt\n ): int\n</code></pre> Parameters cnt <code>int</code> Returns <code>int</code> Returns the special offset as an integer."},{"location":"api/functions/#rd_kafka_thread_cnt","title":"rd_kafka_thread_cnt","text":"<pre><code>\\rd_kafka_thread_cnt() (  ): int\n</code></pre> Returns <code>int</code> Retrieve the current number of threads in use by librdkafka."},{"location":"api/functions/#rd_kafka_version","title":"rd_kafka_version","text":"<pre><code>\\rd_kafka_version() (  ): string\n</code></pre> Returns <code>string</code> The librdkafka version."},{"location":"api/RdKafka/Conf/","title":"Class Conf","text":"<p>Class \\RdKafka\\Conf</p> <p>See also</p> <ul> <li>Configuration reference for librdkafka</li> </ul>"},{"location":"api/RdKafka/Conf/#methods","title":"Methods","text":""},{"location":"api/RdKafka/Conf/#__construct","title":"__construct()","text":"<pre><code>public __construct (  ): \n</code></pre>"},{"location":"api/RdKafka/Conf/#__destruct","title":"__destruct()","text":"<pre><code>public __destruct (  ): \n</code></pre>"},{"location":"api/RdKafka/Conf/#dump","title":"dump()","text":"<pre><code>public dump (  ): array\n</code></pre> Returns <code>array</code>"},{"location":"api/RdKafka/Conf/#get","title":"get()","text":"<pre><code>public get ( \n    string $name\n ): string|null\n</code></pre> Parameters name <code>string</code> Returns <code>string|null</code>"},{"location":"api/RdKafka/Conf/#getcdata","title":"getCData()","text":"<pre><code>public getCData (  ): \\FFI\\CData\n</code></pre> Returns <code>\\FFI\\CData</code>"},{"location":"api/RdKafka/Conf/#set","title":"set()","text":"<pre><code>public set ( \n    string $name, \n    string $value\n ): void\n</code></pre> <p>Setting non string values like callbacks or <code>default_topic_conf</code> TopicConf objects is not supported.</p> <p>For callbacks and <code>default_topic_conf</code> use corresponding methods directly.</p> Parameters name <code>string</code> value <code>string</code> <p>See also</p> <ul> <li> <p>\\RdKafka\\Conf::setLogCb()</p> </li> <li> <p>\\RdKafka\\Conf::setErrorCb()</p> </li> <li> <p>\\RdKafka\\Conf::setOffsetCommitCb()</p> </li> <li> <p>\\RdKafka\\Conf::setRebalanceCb()</p> </li> <li> <p>\\RdKafka\\Conf::setStatsCb()</p> </li> <li> <p>\\RdKafka\\Conf::setDrMsgCb()</p> </li> <li> <p>\\RdKafka\\Conf::setDefaultTopicConf()</p> </li> </ul>"},{"location":"api/RdKafka/Conf/#setdefaulttopicconf","title":"setDefaultTopicConf()","text":"<pre><code>public setDefaultTopicConf ( \n    \\RdKafka\\TopicConf $topic_conf\n ): void\n</code></pre> Parameters topic_conf <code>\\RdKafka\\TopicConf</code> <p>Deprecated</p> <p>Set custom TopicConf explicitly in <code>Producer::newTopic()</code>, <code>Consumer::newTopic()</code> or <code>KafkaConsumer::newTopic()</code>.</p> <p>Note: Topic config properties can be also set directly via Conf.</p> <p>See also</p> <ul> <li> <p>\\RdKafka\\Producer::newTopic()</p> </li> <li> <p>\\RdKafka\\Consumer::newTopic()</p> </li> <li> <p>\\RdKafka\\KafkaConsumer::newTopic()</p> </li> </ul>"},{"location":"api/RdKafka/Conf/#setdrmsgcb","title":"setDrMsgCb()","text":"<pre><code>public setDrMsgCb ( \n    callable $callback\n ): void\n</code></pre> Parameters callback <code>callable</code> function(Producer $producer, Message $message, ?mixed $opaque = null)"},{"location":"api/RdKafka/Conf/#seterrorcb","title":"setErrorCb()","text":"<pre><code>public setErrorCb ( \n    callable $callback\n ): void\n</code></pre> Parameters callback <code>callable</code> function($consumerOrProducer, int $err, string $reason, ?mixed $opaque = null)"},{"location":"api/RdKafka/Conf/#setlogcb","title":"setLogCb()","text":"<pre><code>public setLogCb ( \n    ?callable $callback\n ): void\n</code></pre> Parameters callback <code>?callable</code> function($consumerOrProducer, int $level, string $facility, string $message) or null to disable logging"},{"location":"api/RdKafka/Conf/#setoffsetcommitcb","title":"setOffsetCommitCb()","text":"<pre><code>public setOffsetCommitCb ( \n    callable $callback\n ): void\n</code></pre> Parameters callback <code>callable</code> function(KafkaConsumer $consumer, int $err, array $topicPartitions, ?mixed $opaque = null)"},{"location":"api/RdKafka/Conf/#setopaque","title":"setOpaque()","text":"<pre><code>public setOpaque ( \n    mixed $opaque\n ): void\n</code></pre> Parameters opaque <code>mixed</code>"},{"location":"api/RdKafka/Conf/#setrebalancecb","title":"setRebalanceCb()","text":"<pre><code>public setRebalanceCb ( \n    callable $callback\n ): void\n</code></pre> Parameters callback <code>callable</code> function(KafkaConsumer $consumer, int $err, array $topicPartitions, ?mixed $opaque = null)"},{"location":"api/RdKafka/Conf/#setstatscb","title":"setStatsCb()","text":"<pre><code>public setStatsCb ( \n    callable $callback\n ): void\n</code></pre> Parameters callback <code>callable</code> function($consumerOrProducer, string $json, int $jsonLength, ?mixed $opaque = null)"},{"location":"api/RdKafka/Conf/#test-coverage","title":"Test Coverage \ud83d\udc9a","text":"<ul> <li>\ud83d\udc9a  Lines: 95.31% (61 / 64)</li> <li>\ud83d\udc9b  Methods: 85.71% (12 / 14)</li> </ul>"},{"location":"api/RdKafka/Consumer/","title":"Class Consumer","text":"<p>Class \\RdKafka\\Consumer</p> <ul> <li>extends \\RdKafka</li> </ul>"},{"location":"api/RdKafka/Consumer/#methods","title":"Methods","text":""},{"location":"api/RdKafka/Consumer/#__construct","title":"__construct()","text":"<pre><code>public __construct ( \n    ?\\RdKafka\\Conf $conf = null\n ): \n</code></pre> Parameters conf <code>?\\RdKafka\\Conf</code>"},{"location":"api/RdKafka/Consumer/#addbrokers","title":"addBrokers()","text":"<pre><code>public addBrokers ( \n    string $broker_list\n ): int\n</code></pre> Parameters broker_list <code>string</code> Returns <code>int</code>"},{"location":"api/RdKafka/Consumer/#getoutqlen","title":"getOutQLen()","text":"<pre><code>public getOutQLen (  ): int\n</code></pre> Returns <code>int</code>"},{"location":"api/RdKafka/Consumer/#newqueue","title":"newQueue()","text":"<pre><code>public newQueue (  ): \\RdKafka\\Queue\n</code></pre> Returns <code>\\RdKafka\\Queue</code>"},{"location":"api/RdKafka/Consumer/#newtopic","title":"newTopic()","text":"<pre><code>public newTopic ( \n    string $topic_name, \n    ?\\RdKafka\\TopicConf $topic_conf = null\n ): \\RdKafka\\ConsumerTopic\n</code></pre> Parameters topic_name <code>string</code> topic_conf <code>?\\RdKafka\\TopicConf</code> Returns <code>\\RdKafka\\ConsumerTopic</code>"},{"location":"api/RdKafka/Consumer/#poll","title":"poll()","text":"<pre><code>public poll ( \n    int $timeout_ms\n ): int\n</code></pre> Parameters timeout_ms <code>int</code> Returns <code>int</code>"},{"location":"api/RdKafka/Consumer/#test-coverage","title":"Test Coverage \ud83d\udc9a","text":"<ul> <li>\ud83d\udc9a  Lines: 100% (6 / 6)</li> <li>\ud83d\udc9a  Methods: 100% (6 / 6)</li> </ul>"},{"location":"api/RdKafka/ConsumerTopic/","title":"Class ConsumerTopic","text":"<p>Class \\RdKafka\\ConsumerTopic</p> <ul> <li>extends \\RdKafka\\Topic</li> </ul>"},{"location":"api/RdKafka/ConsumerTopic/#methods","title":"Methods","text":""},{"location":"api/RdKafka/ConsumerTopic/#__construct","title":"__construct()","text":"<pre><code>public __construct ( \n    \\RdKafka\\Consumer $consumer, \n    string $name, \n    ?\\RdKafka\\TopicConf $conf = null\n ): \n</code></pre> Parameters consumer <code>\\RdKafka\\Consumer</code> name <code>string</code> conf <code>?\\RdKafka\\TopicConf</code>"},{"location":"api/RdKafka/ConsumerTopic/#__destruct","title":"__destruct()","text":"<pre><code>public __destruct (  ): \n</code></pre>"},{"location":"api/RdKafka/ConsumerTopic/#consume","title":"consume()","text":"<pre><code>public consume ( \n    int $partition, \n    int $timeout_ms\n ): ?\\RdKafka\\Message\n</code></pre> Parameters partition <code>int</code> timeout_ms <code>int</code> Returns <code>?\\RdKafka\\Message</code>"},{"location":"api/RdKafka/ConsumerTopic/#consumebatch","title":"consumeBatch()","text":"<pre><code>public consumeBatch ( \n    int $partition, \n    int $timeout_ms, \n    int $batch_size\n ): \\RdKafka\\Message[]\n</code></pre> Parameters partition <code>int</code> timeout_ms <code>int</code> batch_size <code>int</code> Returns <code>\\RdKafka\\Message[]</code>"},{"location":"api/RdKafka/ConsumerTopic/#consumecallback","title":"consumeCallback()","text":"<pre><code>public consumeCallback ( \n    int $partition, \n    int $timeout_ms, \n    callable $callback, \n    mixed $opaque = null\n ): int\n</code></pre> Parameters partition <code>int</code> timeout_ms <code>int</code> callback <code>callable</code> opaque <code>mixed</code> Returns <code>int</code> <p>Deprecated</p> <p>since 1.4.0 librdkafka</p>"},{"location":"api/RdKafka/ConsumerTopic/#consumequeuestart","title":"consumeQueueStart()","text":"<pre><code>public consumeQueueStart ( \n    int $partition, \n    int $offset, \n    \\RdKafka\\Queue $queue\n ): void\n</code></pre> Parameters partition <code>int</code> offset <code>int</code> queue <code>\\RdKafka\\Queue</code>"},{"location":"api/RdKafka/ConsumerTopic/#consumestart","title":"consumeStart()","text":"<pre><code>public consumeStart ( \n    int $partition, \n    int $offset\n ): void\n</code></pre> Parameters partition <code>int</code> offset <code>int</code>"},{"location":"api/RdKafka/ConsumerTopic/#consumestop","title":"consumeStop()","text":"<pre><code>public consumeStop ( \n    int $partition\n ): void\n</code></pre> Parameters partition <code>int</code>"},{"location":"api/RdKafka/ConsumerTopic/#offsetstore","title":"offsetStore()","text":"<pre><code>public offsetStore ( \n    int $partition, \n    int $offset\n ): void\n</code></pre> Parameters partition <code>int</code> offset <code>int</code>"},{"location":"api/RdKafka/ConsumerTopic/#test-coverage","title":"Test Coverage \ud83d\udc9b","text":"<ul> <li>\ud83d\udc9b  Lines: 74.55% (82 / 110)</li> <li>\u2764\ufe0f  Methods: 27.27% (3 / 11)</li> </ul>"},{"location":"api/RdKafka/Event/","title":"Class Event","text":"<p>Class \\RdKafka\\Event</p>"},{"location":"api/RdKafka/Event/#methods","title":"Methods","text":""},{"location":"api/RdKafka/Event/#__construct","title":"__construct()","text":"<pre><code>public __construct ( \n    \\FFI\\CData $event\n ): \n</code></pre> Parameters event <code>\\FFI\\CData</code>"},{"location":"api/RdKafka/Event/#__destruct","title":"__destruct()","text":"<pre><code>public __destruct (  ): \n</code></pre>"},{"location":"api/RdKafka/Event/#error","title":"error()","text":"<pre><code>public error (  ): int\n</code></pre> Returns <code>int</code>"},{"location":"api/RdKafka/Event/#errorisfatal","title":"errorIsFatal()","text":"<pre><code>public errorIsFatal (  ): bool\n</code></pre> Returns <code>bool</code>"},{"location":"api/RdKafka/Event/#errorstring","title":"errorString()","text":"<pre><code>public errorString (  ): string\n</code></pre> Returns <code>string</code>"},{"location":"api/RdKafka/Event/#getcdata","title":"getCData()","text":"<pre><code>public getCData (  ): mixed\n</code></pre> Returns <code>mixed</code>"},{"location":"api/RdKafka/Event/#name","title":"name()","text":"<pre><code>public name (  ): string\n</code></pre> Returns <code>string</code>"},{"location":"api/RdKafka/Event/#type","title":"type()","text":"<pre><code>public type (  ): int\n</code></pre> Returns <code>int</code>"},{"location":"api/RdKafka/Event/#test-coverage","title":"Test Coverage \ud83d\udc9b","text":"<ul> <li>\ud83d\udc9b  Lines: 90% (9 / 10)</li> <li>\ud83d\udc9b  Methods: 87.5% (7 / 8)</li> </ul>"},{"location":"api/RdKafka/Exception/","title":"Class Exception","text":"<p>Class \\RdKafka\\Exception</p> <ul> <li>extends \\Exception</li> </ul>"},{"location":"api/RdKafka/Exception/#methods","title":"Methods","text":""},{"location":"api/RdKafka/Exception/#__construct","title":"__construct()","text":"<pre><code>public __construct ( \n    mixed $message = '', \n    mixed $code, \n    ?\\Throwable $previous = null\n ): \n</code></pre> Parameters message <code>mixed</code> code <code>mixed</code> previous <code>?\\Throwable</code>"},{"location":"api/RdKafka/Exception/#fromerror","title":"fromError()","text":"<pre><code>public static fromError ( \n    int $code\n ): self\n</code></pre> Parameters code <code>int</code> Returns <code>self</code>"},{"location":"api/RdKafka/Exception/#test-coverage","title":"Test Coverage \ud83d\udc9a","text":"<ul> <li>\ud83d\udc9a  Lines: 100% (2 / 2)</li> <li>\ud83d\udc9a  Methods: 100% (2 / 2)</li> </ul>"},{"location":"api/RdKafka/Exception/#extended-by","title":"Extended by","text":"<ul> <li>\\RdKafka\\KafkaErrorException</li> </ul>"},{"location":"api/RdKafka/KafkaConsumer/","title":"Class KafkaConsumer","text":"<p>Class \\RdKafka\\KafkaConsumer</p> <ul> <li>extends \\RdKafka</li> </ul>"},{"location":"api/RdKafka/KafkaConsumer/#methods","title":"Methods","text":""},{"location":"api/RdKafka/KafkaConsumer/#__construct","title":"__construct()","text":"<pre><code>public __construct ( \n    \\RdKafka\\Conf $conf\n ): \n</code></pre> Parameters conf <code>\\RdKafka\\Conf</code>"},{"location":"api/RdKafka/KafkaConsumer/#__destruct","title":"__destruct()","text":"<pre><code>public __destruct (  ): \n</code></pre>"},{"location":"api/RdKafka/KafkaConsumer/#assign","title":"assign()","text":"<pre><code>public assign ( \n    \\RdKafka\\TopicPartition[] $topic_partitions = null\n ): void\n</code></pre> Parameters topic_partitions <code>\\RdKafka\\TopicPartition[]</code>"},{"location":"api/RdKafka/KafkaConsumer/#close","title":"close()","text":"<pre><code>public close (  ): void\n</code></pre>"},{"location":"api/RdKafka/KafkaConsumer/#commit","title":"commit()","text":"<pre><code>public commit ( \n    \\RdKafka\\Message|\\RdKafka\\TopicPartition[]|null $message_or_offsets = null\n ): void\n</code></pre> Parameters message_or_offsets <code>\\RdKafka\\Message|\\RdKafka\\TopicPartition[]|null</code>"},{"location":"api/RdKafka/KafkaConsumer/#commitasync","title":"commitAsync()","text":"<pre><code>public commitAsync ( \n    \\RdKafka\\Message|\\RdKafka\\TopicPartition[]|null $message_or_offsets = null\n ): void\n</code></pre> Parameters message_or_offsets <code>\\RdKafka\\Message|\\RdKafka\\TopicPartition[]|null</code>"},{"location":"api/RdKafka/KafkaConsumer/#consume","title":"consume()","text":"<pre><code>public consume ( \n    int $timeout_ms\n ): \\RdKafka\\Message\n</code></pre> Parameters timeout_ms <code>int</code> Returns <code>\\RdKafka\\Message</code>"},{"location":"api/RdKafka/KafkaConsumer/#getassignment","title":"getAssignment()","text":"<pre><code>public getAssignment (  ): \\RdKafka\\TopicPartition[]\n</code></pre> Returns <code>\\RdKafka\\TopicPartition[]</code>"},{"location":"api/RdKafka/KafkaConsumer/#getcommittedoffsets","title":"getCommittedOffsets()","text":"<pre><code>public getCommittedOffsets ( \n    \\RdKafka\\TopicPartition[] $topics, \n    int $timeout_ms\n ): \\RdKafka\\TopicPartition[]\n</code></pre> Parameters topics <code>\\RdKafka\\TopicPartition[]</code> timeout_ms <code>int</code> Returns <code>\\RdKafka\\TopicPartition[]</code>"},{"location":"api/RdKafka/KafkaConsumer/#getsubscription","title":"getSubscription()","text":"<pre><code>public getSubscription (  ): array\n</code></pre> Returns <code>array</code>"},{"location":"api/RdKafka/KafkaConsumer/#newtopic","title":"newTopic()","text":"<pre><code>public newTopic ( \n    string $topic_name, \n    ?\\RdKafka\\TopicConf $topic_conf = null\n ): \\RdKafka\\KafkaConsumerTopic\n</code></pre> Parameters topic_name <code>string</code> topic_conf <code>?\\RdKafka\\TopicConf</code> Returns <code>\\RdKafka\\KafkaConsumerTopic</code>"},{"location":"api/RdKafka/KafkaConsumer/#offsetsfortimes","title":"offsetsForTimes()","text":"<pre><code>public offsetsForTimes ( \n    \\RdKafka\\TopicPartition[] $topicPartitions, \n    int $timeout_ms\n ): \\RdKafka\\TopicPartition[]\n</code></pre> Parameters topicPartitions <code>\\RdKafka\\TopicPartition[]</code> timeout_ms <code>int</code> Returns <code>\\RdKafka\\TopicPartition[]</code>"},{"location":"api/RdKafka/KafkaConsumer/#subscribe","title":"subscribe()","text":"<pre><code>public subscribe ( \n    array $topics\n ): void\n</code></pre> Parameters topics <code>array</code>"},{"location":"api/RdKafka/KafkaConsumer/#unsubscribe","title":"unsubscribe()","text":"<pre><code>public unsubscribe (  ): void\n</code></pre>"},{"location":"api/RdKafka/KafkaConsumer/#test-coverage","title":"Test Coverage \ud83d\udc9b","text":"<ul> <li>\ud83d\udc9b  Lines: 87.94% (124 / 141)</li> <li>\u2764\ufe0f  Methods: 41.18% (7 / 17)</li> </ul>"},{"location":"api/RdKafka/KafkaConsumerTopic/","title":"Class KafkaConsumerTopic","text":"<p>Class \\RdKafka\\KafkaConsumerTopic</p> <ul> <li>extends \\RdKafka\\Topic</li> </ul>"},{"location":"api/RdKafka/KafkaConsumerTopic/#methods","title":"Methods","text":""},{"location":"api/RdKafka/KafkaConsumerTopic/#__construct","title":"__construct()","text":"<pre><code>public __construct ( \n    \\RdKafka\\KafkaConsumer $consumer, \n    string $name, \n    ?\\RdKafka\\TopicConf $conf = null\n ): \n</code></pre> Parameters consumer <code>\\RdKafka\\KafkaConsumer</code> name <code>string</code> conf <code>?\\RdKafka\\TopicConf</code>"},{"location":"api/RdKafka/KafkaConsumerTopic/#offsetstore","title":"offsetStore()","text":"<pre><code>public offsetStore ( \n    int $partition, \n    int $offset\n ): void\n</code></pre> Parameters partition <code>int</code> offset <code>int</code>"},{"location":"api/RdKafka/KafkaConsumerTopic/#test-coverage","title":"Test Coverage \ud83d\udc9b","text":"<ul> <li>\ud83d\udc9b  Lines: 90% (9 / 10)</li> <li>\u2764\ufe0f  Methods: 50% (1 / 2)</li> </ul>"},{"location":"api/RdKafka/KafkaErrorException/","title":"Class KafkaErrorException","text":"<p>Class \\RdKafka\\KafkaErrorException</p> <ul> <li>extends \\RdKafka\\Exception</li> </ul>"},{"location":"api/RdKafka/KafkaErrorException/#methods","title":"Methods","text":""},{"location":"api/RdKafka/KafkaErrorException/#__construct","title":"__construct()","text":"<pre><code>public __construct ( \n    string $message, \n    int $code, \n    string $error_string, \n    bool $isFatal = false, \n    bool $isRetriable = false, \n    bool $transactionRequiresAbort = false\n ): \n</code></pre> Parameters message <code>string</code> code <code>int</code> error_string <code>string</code> isFatal <code>bool</code> isRetriable <code>bool</code> transactionRequiresAbort <code>bool</code>"},{"location":"api/RdKafka/KafkaErrorException/#fromcdata","title":"fromCData()","text":"<pre><code>public static fromCData ( \n    \\FFI\\CData $error\n ): mixed\n</code></pre> Parameters error <code>\\FFI\\CData</code> Returns <code>mixed</code>"},{"location":"api/RdKafka/KafkaErrorException/#geterrorstring","title":"getErrorString()","text":"<pre><code>public getErrorString (  ): string\n</code></pre> Returns <code>string</code>"},{"location":"api/RdKafka/KafkaErrorException/#isfatal","title":"isFatal()","text":"<pre><code>public isFatal (  ): bool\n</code></pre> Returns <code>bool</code>"},{"location":"api/RdKafka/KafkaErrorException/#isretriable","title":"isRetriable()","text":"<pre><code>public isRetriable (  ): bool\n</code></pre> Returns <code>bool</code>"},{"location":"api/RdKafka/KafkaErrorException/#transactionrequiresabort","title":"transactionRequiresAbort()","text":"<pre><code>public transactionRequiresAbort (  ): bool\n</code></pre> Returns <code>bool</code>"},{"location":"api/RdKafka/KafkaErrorException/#test-coverage","title":"Test Coverage \ud83d\udc9a","text":"<ul> <li>\ud83d\udc9a  Lines: 90.91% (20 / 22)</li> <li>\ud83d\udc9b  Methods: 83.33% (5 / 6)</li> </ul>"},{"location":"api/RdKafka/Message/","title":"Class Message","text":"<p>Class \\RdKafka\\Message</p>"},{"location":"api/RdKafka/Message/#properties","title":"Properties","text":""},{"location":"api/RdKafka/Message/#brokerid","title":"brokerId","text":"<pre><code> public int brokerId\n</code></pre>"},{"location":"api/RdKafka/Message/#err","title":"err","text":"<pre><code> public int err\n</code></pre>"},{"location":"api/RdKafka/Message/#headers","title":"headers","text":"<pre><code> public array headers\n</code></pre>"},{"location":"api/RdKafka/Message/#key","title":"key","text":"<pre><code> public ?string key\n</code></pre>"},{"location":"api/RdKafka/Message/#latency","title":"latency","text":"<pre><code> public int latency\n</code></pre>"},{"location":"api/RdKafka/Message/#len","title":"len","text":"<pre><code> public ?int len\n</code></pre>"},{"location":"api/RdKafka/Message/#offset","title":"offset","text":"<pre><code> public int offset\n</code></pre>"},{"location":"api/RdKafka/Message/#opaque","title":"opaque","text":"<pre><code> public mixed|null opaque\n</code></pre>"},{"location":"api/RdKafka/Message/#partition","title":"partition","text":"<pre><code> public int partition\n</code></pre>"},{"location":"api/RdKafka/Message/#payload","title":"payload","text":"<pre><code> public ?string payload\n</code></pre>"},{"location":"api/RdKafka/Message/#status","title":"status","text":"<pre><code> public int status\n</code></pre>"},{"location":"api/RdKafka/Message/#timestamp","title":"timestamp","text":"<pre><code> public int timestamp\n</code></pre>"},{"location":"api/RdKafka/Message/#timestamptype","title":"timestampType","text":"<pre><code> public int timestampType\n</code></pre>"},{"location":"api/RdKafka/Message/#topic_name","title":"topic_name","text":"<pre><code> public ?string topic_name\n</code></pre>"},{"location":"api/RdKafka/Message/#methods","title":"Methods","text":""},{"location":"api/RdKafka/Message/#__construct","title":"__construct()","text":"<pre><code>public __construct ( \n    \\FFI\\CData $nativeMessage\n ): \n</code></pre> Parameters nativeMessage <code>\\FFI\\CData</code>"},{"location":"api/RdKafka/Message/#errstr","title":"errstr()","text":"<pre><code>public errstr (  ): string\n</code></pre> Returns <code>string</code>"},{"location":"api/RdKafka/Message/#test-coverage","title":"Test Coverage \ud83d\udc9b","text":"<ul> <li>\ud83d\udc9b  Lines: 89.09% (49 / 55)</li> <li>\u2764\ufe0f  Methods: 33.33% (1 / 3)</li> </ul>"},{"location":"api/RdKafka/Metadata/","title":"Class Metadata","text":"<p>Class \\RdKafka\\Metadata</p>"},{"location":"api/RdKafka/Metadata/#methods","title":"Methods","text":""},{"location":"api/RdKafka/Metadata/#__construct","title":"__construct()","text":"<pre><code>public __construct ( \n    \\RdKafka $kafka, \n    bool $all_topics, \n    ?\\RdKafka\\Topic $only_topic, \n    int $timeout_ms\n ): \n</code></pre> Parameters kafka <code>\\RdKafka</code> all_topics <code>bool</code> only_topic <code>?\\RdKafka\\Topic</code> timeout_ms <code>int</code>"},{"location":"api/RdKafka/Metadata/#__destruct","title":"__destruct()","text":"<pre><code>public __destruct (  ): \n</code></pre>"},{"location":"api/RdKafka/Metadata/#getbrokers","title":"getBrokers()","text":"<pre><code>public getBrokers (  ): \\RdKafka\\Metadata\\Collection|\\RdKafka\\Metadata\\Broker[]\n</code></pre> Returns <code>\\RdKafka\\Metadata\\Collection|\\RdKafka\\Metadata\\Broker[]</code>"},{"location":"api/RdKafka/Metadata/#getorigbrokerid","title":"getOrigBrokerId()","text":"<pre><code>public getOrigBrokerId (  ): int\n</code></pre> Returns <code>int</code>"},{"location":"api/RdKafka/Metadata/#getorigbrokername","title":"getOrigBrokerName()","text":"<pre><code>public getOrigBrokerName (  ): string\n</code></pre> Returns <code>string</code>"},{"location":"api/RdKafka/Metadata/#gettopics","title":"getTopics()","text":"<pre><code>public getTopics (  ): \\RdKafka\\Metadata\\Collection|\\RdKafka\\Metadata\\Topic[]\n</code></pre> Returns <code>\\RdKafka\\Metadata\\Collection|\\RdKafka\\Metadata\\Topic[]</code>"},{"location":"api/RdKafka/Metadata/#test-coverage","title":"Test Coverage \ud83d\udc9a","text":"<ul> <li>\ud83d\udc9a  Lines: 96.15% (50 / 52)</li> <li>\ud83d\udc9b  Methods: 81.82% (9 / 11)</li> </ul>"},{"location":"api/RdKafka/Producer/","title":"Class Producer","text":"<p>Class \\RdKafka\\Producer</p> <ul> <li>extends \\RdKafka</li> </ul>"},{"location":"api/RdKafka/Producer/#methods","title":"Methods","text":""},{"location":"api/RdKafka/Producer/#__construct","title":"__construct()","text":"<pre><code>public __construct ( \n    ?\\RdKafka\\Conf $conf = null\n ): \n</code></pre> Parameters conf <code>?\\RdKafka\\Conf</code>"},{"location":"api/RdKafka/Producer/#aborttransaction","title":"abortTransaction()","text":"<pre><code>public abortTransaction ( \n    int $timeout_ms\n ): void\n</code></pre> Parameters timeout_ms <code>int</code>"},{"location":"api/RdKafka/Producer/#addbrokers","title":"addBrokers()","text":"<pre><code>public addBrokers ( \n    string $broker_list\n ): int\n</code></pre> Parameters broker_list <code>string</code> Returns <code>int</code>"},{"location":"api/RdKafka/Producer/#begintransaction","title":"beginTransaction()","text":"<pre><code>public beginTransaction (  ): void\n</code></pre>"},{"location":"api/RdKafka/Producer/#committransaction","title":"commitTransaction()","text":"<pre><code>public commitTransaction ( \n    int $timeout_ms\n ): void\n</code></pre> Parameters timeout_ms <code>int</code>"},{"location":"api/RdKafka/Producer/#flush","title":"flush()","text":"<pre><code>public flush ( \n    int $timeout_ms\n ): int\n</code></pre> Parameters timeout_ms <code>int</code> Returns <code>int</code>"},{"location":"api/RdKafka/Producer/#getoutqlen","title":"getOutQLen()","text":"<pre><code>public getOutQLen (  ): int\n</code></pre> Returns <code>int</code>"},{"location":"api/RdKafka/Producer/#inittransactions","title":"initTransactions()","text":"<pre><code>public initTransactions ( \n    int $timeout_ms\n ): void\n</code></pre> <p>Initializing transactions must be done before producing and starting a transaction</p> Parameters timeout_ms <code>int</code>"},{"location":"api/RdKafka/Producer/#newtopic","title":"newTopic()","text":"<pre><code>public newTopic ( \n    string $topic_name, \n    ?\\RdKafka\\TopicConf $topic_conf = null\n ): \\RdKafka\\ProducerTopic\n</code></pre> Parameters topic_name <code>string</code> topic_conf <code>?\\RdKafka\\TopicConf</code> Returns <code>\\RdKafka\\ProducerTopic</code>"},{"location":"api/RdKafka/Producer/#poll","title":"poll()","text":"<pre><code>public poll ( \n    int $timeout_ms\n ): int\n</code></pre> Parameters timeout_ms <code>int</code> Returns <code>int</code>"},{"location":"api/RdKafka/Producer/#purge","title":"purge()","text":"<pre><code>public purge ( \n    int $purge_flags\n ): int\n</code></pre> Parameters purge_flags <code>int</code> Returns <code>int</code>"},{"location":"api/RdKafka/Producer/#test-coverage","title":"Test Coverage \ud83d\udc9b","text":"<ul> <li>\ud83d\udc9b  Lines: 78.95% (15 / 19)</li> <li>\ud83e\udde1  Methods: 63.64% (7 / 11)</li> </ul>"},{"location":"api/RdKafka/ProducerTopic/","title":"Class ProducerTopic","text":"<p>Class \\RdKafka\\ProducerTopic</p> <ul> <li>extends \\RdKafka\\Topic</li> </ul>"},{"location":"api/RdKafka/ProducerTopic/#methods","title":"Methods","text":""},{"location":"api/RdKafka/ProducerTopic/#__construct","title":"__construct()","text":"<pre><code>public __construct ( \n    \\RdKafka\\Producer $producer, \n    string $name, \n    ?\\RdKafka\\TopicConf $conf = null\n ): \n</code></pre> Parameters producer <code>\\RdKafka\\Producer</code> name <code>string</code> conf <code>?\\RdKafka\\TopicConf</code>"},{"location":"api/RdKafka/ProducerTopic/#produce","title":"produce()","text":"<pre><code>public produce ( \n    int $partition, \n    int $msgflags, \n    ?string $payload = null, \n    ?string $key = null, \n    mixed $opaque = null\n ): void\n</code></pre> Parameters partition <code>int</code> msgflags <code>int</code> payload <code>?string</code> key <code>?string</code> opaque <code>mixed</code>"},{"location":"api/RdKafka/ProducerTopic/#producev","title":"producev()","text":"<pre><code>public producev ( \n    int $partition, \n    int $msgflags, \n    ?string $payload = null, \n    ?string $key = null, \n    ?array $headers = null, \n    ?int $timestamp_ms = null, \n    mixed $opaque = null\n ): void\n</code></pre> Parameters partition <code>int</code> msgflags <code>int</code> payload <code>?string</code> key <code>?string</code> headers <code>?array</code> timestamp_ms <code>?int</code> opaque <code>mixed</code>"},{"location":"api/RdKafka/ProducerTopic/#test-coverage","title":"Test Coverage \ud83d\udc9b","text":"<ul> <li>\ud83d\udc9b  Lines: 89.66% (52 / 58)</li> <li>\ud83e\udde1  Methods: 60% (3 / 5)</li> </ul>"},{"location":"api/RdKafka/Queue/","title":"Class Queue","text":"<p>Class \\RdKafka\\Queue</p>"},{"location":"api/RdKafka/Queue/#methods","title":"Methods","text":""},{"location":"api/RdKafka/Queue/#__construct","title":"__construct()","text":"<pre><code>public __construct ( \n    \\FFI\\CData $queue\n ): \n</code></pre> Parameters queue <code>\\FFI\\CData</code>"},{"location":"api/RdKafka/Queue/#__destruct","title":"__destruct()","text":"<pre><code>public __destruct (  ): \n</code></pre>"},{"location":"api/RdKafka/Queue/#consume","title":"consume()","text":"<pre><code>public consume ( \n    int $timeout_ms\n ): ?\\RdKafka\\Message\n</code></pre> Parameters timeout_ms <code>int</code> Returns <code>?\\RdKafka\\Message</code>"},{"location":"api/RdKafka/Queue/#fromrdkafka","title":"fromRdKafka()","text":"<pre><code>public static fromRdKafka ( \n    \\RdKafka $kafka\n ): self\n</code></pre> Parameters kafka <code>\\RdKafka</code> Returns <code>self</code>"},{"location":"api/RdKafka/Queue/#getcdata","title":"getCData()","text":"<pre><code>public getCData (  ): \\FFI\\CData\n</code></pre> Returns <code>\\FFI\\CData</code>"},{"location":"api/RdKafka/Queue/#poll","title":"poll()","text":"<pre><code>public poll ( \n    int $timeout_ms\n ): ?\\RdKafka\\Event\n</code></pre> Parameters timeout_ms <code>int</code> Returns <code>?\\RdKafka\\Event</code>"},{"location":"api/RdKafka/Queue/#test-coverage","title":"Test Coverage \ud83d\udc9b","text":"<ul> <li>\ud83d\udc9b  Lines: 88.46% (23 / 26)</li> <li>\u2764\ufe0f  Methods: 50% (3 / 6)</li> </ul>"},{"location":"api/RdKafka/Topic/","title":"Class Topic","text":"<p>abstract Class \\RdKafka\\Topic</p>"},{"location":"api/RdKafka/Topic/#methods","title":"Methods","text":""},{"location":"api/RdKafka/Topic/#__construct","title":"__construct()","text":"<pre><code>public __construct ( \n    \\RdKafka $kafka, \n    string $name, \n    ?\\RdKafka\\TopicConf $conf = null\n ): \n</code></pre> Parameters kafka <code>\\RdKafka</code> name <code>string</code> conf <code>?\\RdKafka\\TopicConf</code>"},{"location":"api/RdKafka/Topic/#__destruct","title":"__destruct()","text":"<pre><code>public __destruct (  ): \n</code></pre>"},{"location":"api/RdKafka/Topic/#getcdata","title":"getCData()","text":"<pre><code>public getCData (  ): \\FFI\\CData\n</code></pre> Returns <code>\\FFI\\CData</code>"},{"location":"api/RdKafka/Topic/#getname","title":"getName()","text":"<pre><code>public getName (  ): string\n</code></pre> Returns <code>string</code>"},{"location":"api/RdKafka/Topic/#test-coverage","title":"Test Coverage \ud83d\udc9b","text":"<ul> <li>\ud83d\udc9b  Lines: 88.24% (15 / 17)</li> <li>\ud83d\udc9b  Methods: 80% (4 / 5)</li> </ul>"},{"location":"api/RdKafka/Topic/#extended-by","title":"Extended by","text":"<ul> <li>\\RdKafka\\ConsumerTopic</li> <li>\\RdKafka\\KafkaConsumerTopic</li> <li>\\RdKafka\\ProducerTopic</li> </ul>"},{"location":"api/RdKafka/TopicConf/","title":"Class TopicConf","text":"<p>Class \\RdKafka\\TopicConf</p> <p>See also</p> <ul> <li>Configuration reference for librdkafka</li> </ul>"},{"location":"api/RdKafka/TopicConf/#methods","title":"Methods","text":""},{"location":"api/RdKafka/TopicConf/#__construct","title":"__construct()","text":"<pre><code>public __construct (  ): \n</code></pre>"},{"location":"api/RdKafka/TopicConf/#__destruct","title":"__destruct()","text":"<pre><code>public __destruct (  ): \n</code></pre>"},{"location":"api/RdKafka/TopicConf/#dump","title":"dump()","text":"<pre><code>public dump (  ): array\n</code></pre> Returns <code>array</code>"},{"location":"api/RdKafka/TopicConf/#getcdata","title":"getCData()","text":"<pre><code>public getCData (  ): \\FFI\\CData\n</code></pre> Returns <code>\\FFI\\CData</code>"},{"location":"api/RdKafka/TopicConf/#getopaque","title":"getOpaque()","text":"<pre><code>public getOpaque (  ): mixed|null\n</code></pre> Returns <code>mixed|null</code>"},{"location":"api/RdKafka/TopicConf/#set","title":"set()","text":"<pre><code>public set ( \n    string $name, \n    string $value\n ): void\n</code></pre> Parameters name <code>string</code> value <code>string</code>"},{"location":"api/RdKafka/TopicConf/#setopaque","title":"setOpaque()","text":"<pre><code>public setOpaque ( \n    mixed $opaque\n ): void\n</code></pre> Parameters opaque <code>mixed</code>"},{"location":"api/RdKafka/TopicConf/#setpartitioner","title":"setPartitioner()","text":"<pre><code>public setPartitioner ( \n    int $partitioner\n ): void\n</code></pre> Parameters partitioner <code>int</code>"},{"location":"api/RdKafka/TopicConf/#setpartitionercb","title":"setPartitionerCb()","text":"<pre><code>public setPartitionerCb ( \n    callable $callback\n ): void\n</code></pre> Parameters callback <code>callable</code>"},{"location":"api/RdKafka/TopicConf/#test-coverage","title":"Test Coverage \ud83d\udc9b","text":"<ul> <li>\ud83d\udc9b  Lines: 76.56% (49 / 64)</li> <li>\ud83e\udde1  Methods: 66.67% (6 / 9)</li> </ul>"},{"location":"api/RdKafka/TopicPartition/","title":"Class TopicPartition","text":"<p>Class \\RdKafka\\TopicPartition</p>"},{"location":"api/RdKafka/TopicPartition/#methods","title":"Methods","text":""},{"location":"api/RdKafka/TopicPartition/#__construct","title":"__construct()","text":"<pre><code>public __construct ( \n    string $topic, \n    int $partition, \n    int $offset, \n    string|null $metadata = null\n ): \n</code></pre> Parameters topic <code>string</code> partition <code>int</code> offset <code>int</code> metadata <code>string|null</code> requires librdkafka &gt;= 1.2.0"},{"location":"api/RdKafka/TopicPartition/#fromcdata","title":"fromCData()","text":"<pre><code>public static fromCData ( \n    \\FFI\\CData $topicPartition\n ): self\n</code></pre> Parameters topicPartition <code>\\FFI\\CData</code> Returns <code>self</code>"},{"location":"api/RdKafka/TopicPartition/#geterr","title":"getErr()","text":"<pre><code>public getErr (  ): ?int\n</code></pre> Returns <code>?int</code>"},{"location":"api/RdKafka/TopicPartition/#getmetadata","title":"getMetadata()","text":"<pre><code>public getMetadata (  ): ?string\n</code></pre> Returns <code>?string</code>"},{"location":"api/RdKafka/TopicPartition/#getmetadatasize","title":"getMetadataSize()","text":"<pre><code>public getMetadataSize (  ): int\n</code></pre> Returns <code>int</code>"},{"location":"api/RdKafka/TopicPartition/#getoffset","title":"getOffset()","text":"<pre><code>public getOffset (  ): int\n</code></pre> Returns <code>int</code>"},{"location":"api/RdKafka/TopicPartition/#getopqaque","title":"getOpqaque()","text":"<pre><code>public getOpqaque (  ): ?object\n</code></pre> Returns <code>?object</code>"},{"location":"api/RdKafka/TopicPartition/#getpartition","title":"getPartition()","text":"<pre><code>public getPartition (  ): int\n</code></pre> Returns <code>int</code>"},{"location":"api/RdKafka/TopicPartition/#gettopic","title":"getTopic()","text":"<pre><code>public getTopic (  ): string\n</code></pre> Returns <code>string</code>"},{"location":"api/RdKafka/TopicPartition/#setmetadata","title":"setMetadata()","text":"<pre><code>public setMetadata ( \n    ?string $metadata\n ): void\n</code></pre> Parameters metadata <code>?string</code>"},{"location":"api/RdKafka/TopicPartition/#setoffset","title":"setOffset()","text":"<pre><code>public setOffset ( \n    int $offset\n ): void\n</code></pre> Parameters offset <code>int</code>"},{"location":"api/RdKafka/TopicPartition/#setpartition","title":"setPartition()","text":"<pre><code>public setPartition ( \n    int $partition\n ): void\n</code></pre> Parameters partition <code>int</code>"},{"location":"api/RdKafka/TopicPartition/#settopic","title":"setTopic()","text":"<pre><code>public setTopic ( \n    string $topic_name\n ): void\n</code></pre> Parameters topic_name <code>string</code>"},{"location":"api/RdKafka/TopicPartition/#test-coverage","title":"Test Coverage \ud83d\udc9a","text":"<ul> <li>\ud83d\udc9a  Lines: 100% (30 / 30)</li> <li>\ud83d\udc9a  Methods: 100% (13 / 13)</li> </ul>"},{"location":"api/RdKafka/TopicPartitionList/","title":"Class TopicPartitionList","text":"<p>Class \\RdKafka\\TopicPartitionList</p> <ul> <li>implements  \\Iterator</li> <li>implements  \\Countable</li> </ul>"},{"location":"api/RdKafka/TopicPartitionList/#methods","title":"Methods","text":""},{"location":"api/RdKafka/TopicPartitionList/#__construct","title":"__construct()","text":"<pre><code>public __construct ( \n    \\RdKafka\\TopicPartition[] $items\n ): \n</code></pre> Parameters items <code>\\RdKafka\\TopicPartition[]</code>"},{"location":"api/RdKafka/TopicPartitionList/#asarray","title":"asArray()","text":"<pre><code>public asArray (  ): \\RdKafka\\TopicPartition[]\n</code></pre> Returns <code>\\RdKafka\\TopicPartition[]</code>"},{"location":"api/RdKafka/TopicPartitionList/#count","title":"count()","text":"<pre><code>public count (  ): int\n</code></pre> Returns <code>int</code>"},{"location":"api/RdKafka/TopicPartitionList/#current","title":"current()","text":"<pre><code>public current (  ): \\RdKafka\\TopicPartition\n</code></pre> Returns <code>\\RdKafka\\TopicPartition</code>"},{"location":"api/RdKafka/TopicPartitionList/#fromcdata","title":"fromCData()","text":"<pre><code>public static fromCData ( \n    \\FFI\\CData $topicPartitionList\n ): self\n</code></pre> Parameters topicPartitionList <code>\\FFI\\CData</code> Returns <code>self</code>"},{"location":"api/RdKafka/TopicPartitionList/#getcdata","title":"getCData()","text":"<pre><code>public getCData (  ): \\FFI\\CData\n</code></pre> Returns <code>\\FFI\\CData</code>"},{"location":"api/RdKafka/TopicPartitionList/#key","title":"key()","text":"<pre><code>public key (  ): int\n</code></pre> Returns <code>int</code>"},{"location":"api/RdKafka/TopicPartitionList/#next","title":"next()","text":"<pre><code>public next (  ): void\n</code></pre>"},{"location":"api/RdKafka/TopicPartitionList/#rewind","title":"rewind()","text":"<pre><code>public rewind (  ): void\n</code></pre>"},{"location":"api/RdKafka/TopicPartitionList/#valid","title":"valid()","text":"<pre><code>public valid (  ): bool\n</code></pre> Returns <code>bool</code>"},{"location":"api/RdKafka/TopicPartitionList/#test-coverage","title":"Test Coverage \ud83d\udc9a","text":"<ul> <li>\ud83d\udc9a  Lines: 96.3% (26 / 27)</li> <li>\ud83d\udc9b  Methods: 90% (9 / 10)</li> </ul>"},{"location":"api/RdKafka/Admin/AlterConfigsOptions/","title":"Class AlterConfigsOptions","text":"<p>Class \\RdKafka\\Admin\\AlterConfigsOptions</p> <ul> <li>extends \\RdKafka\\Admin\\Options</li> </ul>"},{"location":"api/RdKafka/Admin/AlterConfigsOptions/#methods","title":"Methods","text":""},{"location":"api/RdKafka/Admin/AlterConfigsOptions/#__construct","title":"__construct()","text":"<pre><code>public __construct ( \n    \\RdKafka $kafka\n ): \n</code></pre> Parameters kafka <code>\\RdKafka</code>"},{"location":"api/RdKafka/Admin/AlterConfigsOptions/#test-coverage","title":"Test Coverage \ud83d\udc9a","text":"<ul> <li>\ud83d\udc9a  Lines: 100% (1 / 1)</li> <li>\ud83d\udc9a  Methods: 100% (1 / 1)</li> </ul>"},{"location":"api/RdKafka/Admin/Client/","title":"Class Client","text":"<p>Class \\RdKafka\\Admin\\Client</p>"},{"location":"api/RdKafka/Admin/Client/#methods","title":"Methods","text":""},{"location":"api/RdKafka/Admin/Client/#alterconfigs","title":"alterConfigs()","text":"<pre><code>public alterConfigs ( \n    \\RdKafka\\Admin\\ConfigResource[] $resources, \n    ?\\RdKafka\\Admin\\AlterConfigsOptions $options = null\n ): \\RdKafka\\Admin\\ConfigResourceResult[]\n</code></pre> Parameters resources <code>\\RdKafka\\Admin\\ConfigResource[]</code> options <code>?\\RdKafka\\Admin\\AlterConfigsOptions</code> Returns <code>\\RdKafka\\Admin\\ConfigResourceResult[]</code>"},{"location":"api/RdKafka/Admin/Client/#createpartitions","title":"createPartitions()","text":"<pre><code>public createPartitions ( \n    \\RdKafka\\Admin\\NewPartitions[] $partitions, \n    ?\\RdKafka\\Admin\\CreatePartitionsOptions $options = null\n ): \\RdKafka\\Admin\\TopicResult[]\n</code></pre> Parameters partitions <code>\\RdKafka\\Admin\\NewPartitions[]</code> options <code>?\\RdKafka\\Admin\\CreatePartitionsOptions</code> Returns <code>\\RdKafka\\Admin\\TopicResult[]</code>"},{"location":"api/RdKafka/Admin/Client/#createtopics","title":"createTopics()","text":"<pre><code>public createTopics ( \n    \\RdKafka\\Admin\\NewTopic[] $topics, \n    ?\\RdKafka\\Admin\\CreateTopicsOptions $options = null\n ): \\RdKafka\\Admin\\TopicResult[]\n</code></pre> Parameters topics <code>\\RdKafka\\Admin\\NewTopic[]</code> options <code>?\\RdKafka\\Admin\\CreateTopicsOptions</code> Returns <code>\\RdKafka\\Admin\\TopicResult[]</code>"},{"location":"api/RdKafka/Admin/Client/#deleteconsumergroupoffsets","title":"deleteConsumerGroupOffsets()","text":"<pre><code>public deleteConsumerGroupOffsets ( \n    \\RdKafka\\Admin\\DeleteConsumerGroupOffsets $offsets, \n    ?\\RdKafka\\Admin\\DeleteConsumerGroupOffsetsOptions $options = null\n ): \\RdKafka\\Admin\\GroupResult[]\n</code></pre> Parameters offsets <code>\\RdKafka\\Admin\\DeleteConsumerGroupOffsets</code> options <code>?\\RdKafka\\Admin\\DeleteConsumerGroupOffsetsOptions</code> Returns <code>\\RdKafka\\Admin\\GroupResult[]</code>"},{"location":"api/RdKafka/Admin/Client/#deletegroups","title":"deleteGroups()","text":"<pre><code>public deleteGroups ( \n    \\RdKafka\\Admin\\DeleteGroup[] $groups, \n    ?\\RdKafka\\Admin\\DeleteGroupsOptions $options = null\n ): \\RdKafka\\Admin\\GroupResult[]\n</code></pre> Parameters groups <code>\\RdKafka\\Admin\\DeleteGroup[]</code> options <code>?\\RdKafka\\Admin\\DeleteGroupsOptions</code> Returns <code>\\RdKafka\\Admin\\GroupResult[]</code>"},{"location":"api/RdKafka/Admin/Client/#deleterecords","title":"deleteRecords()","text":"<pre><code>public deleteRecords ( \n    \\RdKafka\\Admin\\DeleteRecords[] $records, \n    ?\\RdKafka\\Admin\\DeleteRecordsOptions $options = null\n ): \\RdKafka\\TopicPartition[]\n</code></pre> Parameters records <code>\\RdKafka\\Admin\\DeleteRecords[]</code> options <code>?\\RdKafka\\Admin\\DeleteRecordsOptions</code> Returns <code>\\RdKafka\\TopicPartition[]</code>"},{"location":"api/RdKafka/Admin/Client/#deletetopics","title":"deleteTopics()","text":"<pre><code>public deleteTopics ( \n    \\RdKafka\\Admin\\DeleteTopic[] $topics, \n    ?\\RdKafka\\Admin\\DeleteTopicsOptions $options = null\n ): \\RdKafka\\Admin\\TopicResult[]\n</code></pre> Parameters topics <code>\\RdKafka\\Admin\\DeleteTopic[]</code> options <code>?\\RdKafka\\Admin\\DeleteTopicsOptions</code> Returns <code>\\RdKafka\\Admin\\TopicResult[]</code>"},{"location":"api/RdKafka/Admin/Client/#describeconfigs","title":"describeConfigs()","text":"<pre><code>public describeConfigs ( \n    \\RdKafka\\Admin\\ConfigResource[] $resources, \n    ?\\RdKafka\\Admin\\DescribeConfigsOptions $options = null\n ): \\RdKafka\\Admin\\ConfigResourceResult[]\n</code></pre> Parameters resources <code>\\RdKafka\\Admin\\ConfigResource[]</code> options <code>?\\RdKafka\\Admin\\DescribeConfigsOptions</code> Returns <code>\\RdKafka\\Admin\\ConfigResourceResult[]</code>"},{"location":"api/RdKafka/Admin/Client/#fromconf","title":"fromConf()","text":"<pre><code>public static fromConf ( \n    \\RdKafka\\Conf $conf\n ): self\n</code></pre> Parameters conf <code>\\RdKafka\\Conf</code> Returns <code>self</code>"},{"location":"api/RdKafka/Admin/Client/#fromconsumer","title":"fromConsumer()","text":"<pre><code>public static fromConsumer ( \n    \\RdKafka\\Consumer $consumer\n ): self\n</code></pre> Parameters consumer <code>\\RdKafka\\Consumer</code> Returns <code>self</code>"},{"location":"api/RdKafka/Admin/Client/#fromproducer","title":"fromProducer()","text":"<pre><code>public static fromProducer ( \n    \\RdKafka\\Producer $producer\n ): self\n</code></pre> Parameters producer <code>\\RdKafka\\Producer</code> Returns <code>self</code>"},{"location":"api/RdKafka/Admin/Client/#getmetadata","title":"getMetadata()","text":"<pre><code>public getMetadata ( \n    bool $all_topics, \n    ?\\RdKafka\\Topic $only_topic, \n    int $timeout_ms\n ): \\RdKafka\\Metadata\n</code></pre> Parameters all_topics <code>bool</code> only_topic <code>?\\RdKafka\\Topic</code> timeout_ms <code>int</code> Returns <code>\\RdKafka\\Metadata</code>"},{"location":"api/RdKafka/Admin/Client/#newalterconfigsoptions","title":"newAlterConfigsOptions()","text":"<pre><code>public newAlterConfigsOptions (  ): \\RdKafka\\Admin\\AlterConfigsOptions\n</code></pre> Returns <code>\\RdKafka\\Admin\\AlterConfigsOptions</code>"},{"location":"api/RdKafka/Admin/Client/#newcreatepartitionsoptions","title":"newCreatePartitionsOptions()","text":"<pre><code>public newCreatePartitionsOptions (  ): \\RdKafka\\Admin\\CreatePartitionsOptions\n</code></pre> Returns <code>\\RdKafka\\Admin\\CreatePartitionsOptions</code>"},{"location":"api/RdKafka/Admin/Client/#newcreatetopicsoptions","title":"newCreateTopicsOptions()","text":"<pre><code>public newCreateTopicsOptions (  ): \\RdKafka\\Admin\\CreateTopicsOptions\n</code></pre> Returns <code>\\RdKafka\\Admin\\CreateTopicsOptions</code>"},{"location":"api/RdKafka/Admin/Client/#newdeleteconsumergroupoffsetsoptions","title":"newDeleteConsumerGroupOffsetsOptions()","text":"<pre><code>public newDeleteConsumerGroupOffsetsOptions (  ): \\RdKafka\\Admin\\DeleteConsumerGroupOffsetsOptions\n</code></pre> Returns <code>\\RdKafka\\Admin\\DeleteConsumerGroupOffsetsOptions</code>"},{"location":"api/RdKafka/Admin/Client/#newdeletegroupsoptions","title":"newDeleteGroupsOptions()","text":"<pre><code>public newDeleteGroupsOptions (  ): \\RdKafka\\Admin\\DeleteGroupsOptions\n</code></pre> Returns <code>\\RdKafka\\Admin\\DeleteGroupsOptions</code>"},{"location":"api/RdKafka/Admin/Client/#newdeleterecordsoptions","title":"newDeleteRecordsOptions()","text":"<pre><code>public newDeleteRecordsOptions (  ): \\RdKafka\\Admin\\DeleteRecordsOptions\n</code></pre> Returns <code>\\RdKafka\\Admin\\DeleteRecordsOptions</code>"},{"location":"api/RdKafka/Admin/Client/#newdeletetopicsoptions","title":"newDeleteTopicsOptions()","text":"<pre><code>public newDeleteTopicsOptions (  ): \\RdKafka\\Admin\\DeleteTopicsOptions\n</code></pre> Returns <code>\\RdKafka\\Admin\\DeleteTopicsOptions</code>"},{"location":"api/RdKafka/Admin/Client/#newdescribeconfigsoptions","title":"newDescribeConfigsOptions()","text":"<pre><code>public newDescribeConfigsOptions (  ): \\RdKafka\\Admin\\DescribeConfigsOptions\n</code></pre> Returns <code>\\RdKafka\\Admin\\DescribeConfigsOptions</code>"},{"location":"api/RdKafka/Admin/Client/#setwaitforresulteventtimeout","title":"setWaitForResultEventTimeout()","text":"<pre><code>public setWaitForResultEventTimeout ( \n    int $timeoutMs\n ): void\n</code></pre> Parameters timeoutMs <code>int</code>"},{"location":"api/RdKafka/Admin/Client/#test-coverage","title":"Test Coverage \ud83d\udc9b","text":"<ul> <li>\ud83d\udc9b  Lines: 83.51% (162 / 194)</li> <li>\ud83d\udc9b  Methods: 79.17% (19 / 24)</li> </ul>"},{"location":"api/RdKafka/Admin/ConfigEntry/","title":"Class ConfigEntry","text":"<p>Class \\RdKafka\\Admin\\ConfigEntry</p>"},{"location":"api/RdKafka/Admin/ConfigEntry/#properties","title":"Properties","text":""},{"location":"api/RdKafka/Admin/ConfigEntry/#isdefault","title":"isDefault","text":"<pre><code> public bool isDefault\n</code></pre>"},{"location":"api/RdKafka/Admin/ConfigEntry/#isreadonly","title":"isReadOnly","text":"<pre><code> public bool isReadOnly\n</code></pre>"},{"location":"api/RdKafka/Admin/ConfigEntry/#issensitive","title":"isSensitive","text":"<pre><code> public bool isSensitive\n</code></pre>"},{"location":"api/RdKafka/Admin/ConfigEntry/#issynonym","title":"isSynonym","text":"<pre><code> public bool isSynonym\n</code></pre>"},{"location":"api/RdKafka/Admin/ConfigEntry/#name","title":"name","text":"<pre><code> public string name\n</code></pre>"},{"location":"api/RdKafka/Admin/ConfigEntry/#source","title":"source","text":"<pre><code> public int source\n</code></pre>"},{"location":"api/RdKafka/Admin/ConfigEntry/#synonyms","title":"synonyms","text":"<pre><code> public \\RdKafka\\Admin\\ConfigEntry[] synonyms\n</code></pre>"},{"location":"api/RdKafka/Admin/ConfigEntry/#value","title":"value","text":"<pre><code> public ?string value\n</code></pre>"},{"location":"api/RdKafka/Admin/ConfigEntry/#methods","title":"Methods","text":""},{"location":"api/RdKafka/Admin/ConfigEntry/#__construct","title":"__construct()","text":"<pre><code>public __construct ( \n    \\FFI\\CData $entry\n ): \n</code></pre> Parameters entry <code>\\FFI\\CData</code>"},{"location":"api/RdKafka/Admin/ConfigEntry/#test-coverage","title":"Test Coverage \ud83d\udc9a","text":"<ul> <li>\ud83d\udc9a  Lines: 100% (13 / 13)</li> <li>\ud83d\udc9a  Methods: 100% (1 / 1)</li> </ul>"},{"location":"api/RdKafka/Admin/ConfigResource/","title":"Class ConfigResource","text":"<p>Class \\RdKafka\\Admin\\ConfigResource</p>"},{"location":"api/RdKafka/Admin/ConfigResource/#methods","title":"Methods","text":""},{"location":"api/RdKafka/Admin/ConfigResource/#__construct","title":"__construct()","text":"<pre><code>public __construct ( \n    int $type, \n    string $name\n ): \n</code></pre> Parameters type <code>int</code> name <code>string</code>"},{"location":"api/RdKafka/Admin/ConfigResource/#__destruct","title":"__destruct()","text":"<pre><code>public __destruct (  ): \n</code></pre>"},{"location":"api/RdKafka/Admin/ConfigResource/#getcdata","title":"getCData()","text":"<pre><code>public getCData (  ): \\FFI\\CData\n</code></pre> Returns <code>\\FFI\\CData</code>"},{"location":"api/RdKafka/Admin/ConfigResource/#setconfig","title":"setConfig()","text":"<pre><code>public setConfig ( \n    string $name, \n    string $value\n ): void\n</code></pre> Parameters name <code>string</code> value <code>string</code>"},{"location":"api/RdKafka/Admin/ConfigResource/#test-coverage","title":"Test Coverage \ud83d\udc9a","text":"<ul> <li>\ud83d\udc9a  Lines: 92.31% (12 / 13)</li> <li>\ud83d\udc9b  Methods: 75% (3 / 4)</li> </ul>"},{"location":"api/RdKafka/Admin/ConfigResourceResult/","title":"Class ConfigResourceResult","text":"<p>Class \\RdKafka\\Admin\\ConfigResourceResult</p>"},{"location":"api/RdKafka/Admin/ConfigResourceResult/#properties","title":"Properties","text":""},{"location":"api/RdKafka/Admin/ConfigResourceResult/#configs","title":"configs","text":"<pre><code> public \\RdKafka\\Admin\\ConfigEntry[] configs\n</code></pre>"},{"location":"api/RdKafka/Admin/ConfigResourceResult/#error","title":"error","text":"<pre><code> public int error\n</code></pre>"},{"location":"api/RdKafka/Admin/ConfigResourceResult/#errorstring","title":"errorString","text":"<pre><code> public ?string errorString\n</code></pre>"},{"location":"api/RdKafka/Admin/ConfigResourceResult/#name","title":"name","text":"<pre><code> public string name\n</code></pre>"},{"location":"api/RdKafka/Admin/ConfigResourceResult/#type","title":"type","text":"<pre><code> public int type\n</code></pre>"},{"location":"api/RdKafka/Admin/ConfigResourceResult/#methods","title":"Methods","text":""},{"location":"api/RdKafka/Admin/ConfigResourceResult/#__construct","title":"__construct()","text":"<pre><code>public __construct ( \n    \\FFI\\CData $result\n ): \n</code></pre> Parameters result <code>\\FFI\\CData</code>"},{"location":"api/RdKafka/Admin/ConfigResourceResult/#test-coverage","title":"Test Coverage \ud83d\udc9a","text":"<ul> <li>\ud83d\udc9a  Lines: 100% (10 / 10)</li> <li>\ud83d\udc9a  Methods: 100% (1 / 1)</li> </ul>"},{"location":"api/RdKafka/Admin/CreatePartitionsOptions/","title":"Class CreatePartitionsOptions","text":"<p>Class \\RdKafka\\Admin\\CreatePartitionsOptions</p> <ul> <li>extends \\RdKafka\\Admin\\Options</li> </ul>"},{"location":"api/RdKafka/Admin/CreatePartitionsOptions/#methods","title":"Methods","text":""},{"location":"api/RdKafka/Admin/CreatePartitionsOptions/#__construct","title":"__construct()","text":"<pre><code>public __construct ( \n    \\RdKafka $kafka\n ): \n</code></pre> Parameters kafka <code>\\RdKafka</code>"},{"location":"api/RdKafka/Admin/CreatePartitionsOptions/#test-coverage","title":"Test Coverage \ud83d\udc9a","text":"<ul> <li>\ud83d\udc9a  Lines: 100% (1 / 1)</li> <li>\ud83d\udc9a  Methods: 100% (1 / 1)</li> </ul>"},{"location":"api/RdKafka/Admin/CreateTopicsOptions/","title":"Class CreateTopicsOptions","text":"<p>Class \\RdKafka\\Admin\\CreateTopicsOptions</p> <ul> <li>extends \\RdKafka\\Admin\\Options</li> </ul>"},{"location":"api/RdKafka/Admin/CreateTopicsOptions/#methods","title":"Methods","text":""},{"location":"api/RdKafka/Admin/CreateTopicsOptions/#__construct","title":"__construct()","text":"<pre><code>public __construct ( \n    \\RdKafka $kafka\n ): \n</code></pre> Parameters kafka <code>\\RdKafka</code>"},{"location":"api/RdKafka/Admin/CreateTopicsOptions/#test-coverage","title":"Test Coverage \ud83d\udc9a","text":"<ul> <li>\ud83d\udc9a  Lines: 100% (1 / 1)</li> <li>\ud83d\udc9a  Methods: 100% (1 / 1)</li> </ul>"},{"location":"api/RdKafka/Admin/DeleteConsumerGroupOffsets/","title":"Class DeleteConsumerGroupOffsets","text":"<p>Class \\RdKafka\\Admin\\DeleteConsumerGroupOffsets</p>"},{"location":"api/RdKafka/Admin/DeleteConsumerGroupOffsets/#methods","title":"Methods","text":""},{"location":"api/RdKafka/Admin/DeleteConsumerGroupOffsets/#__construct","title":"__construct()","text":"<pre><code>public __construct ( \n    string $group, \n    \\RdKafka\\TopicPartition $partitions\n ): \n</code></pre> Parameters group <code>string</code> partitions <code>\\RdKafka\\TopicPartition</code>"},{"location":"api/RdKafka/Admin/DeleteConsumerGroupOffsets/#__destruct","title":"__destruct()","text":"<pre><code>public __destruct (  ): \n</code></pre>"},{"location":"api/RdKafka/Admin/DeleteConsumerGroupOffsets/#getcdata","title":"getCData()","text":"<pre><code>public getCData (  ): \\FFI\\CData\n</code></pre> Returns <code>\\FFI\\CData</code>"},{"location":"api/RdKafka/Admin/DeleteConsumerGroupOffsets/#test-coverage","title":"Test Coverage \u2764\ufe0f","text":"<ul> <li>\u2764\ufe0f  Lines: 0% (0 / 10)</li> <li>\u2764\ufe0f  Methods: 0% (0 / 3)</li> </ul>"},{"location":"api/RdKafka/Admin/DeleteConsumerGroupOffsetsOptions/","title":"Class DeleteConsumerGroupOffsetsOptions","text":"<p>Class \\RdKafka\\Admin\\DeleteConsumerGroupOffsetsOptions</p> <ul> <li>extends \\RdKafka\\Admin\\Options</li> </ul>"},{"location":"api/RdKafka/Admin/DeleteConsumerGroupOffsetsOptions/#methods","title":"Methods","text":""},{"location":"api/RdKafka/Admin/DeleteConsumerGroupOffsetsOptions/#__construct","title":"__construct()","text":"<pre><code>public __construct ( \n    \\RdKafka $kafka\n ): \n</code></pre> Parameters kafka <code>\\RdKafka</code>"},{"location":"api/RdKafka/Admin/DeleteConsumerGroupOffsetsOptions/#test-coverage","title":"Test Coverage \u2764\ufe0f","text":"<ul> <li>\u2764\ufe0f  Lines: 0% (0 / 1)</li> <li>\u2764\ufe0f  Methods: 0% (0 / 1)</li> </ul>"},{"location":"api/RdKafka/Admin/DeleteGroup/","title":"Class DeleteGroup","text":"<p>Class \\RdKafka\\Admin\\DeleteGroup</p>"},{"location":"api/RdKafka/Admin/DeleteGroup/#methods","title":"Methods","text":""},{"location":"api/RdKafka/Admin/DeleteGroup/#__construct","title":"__construct()","text":"<pre><code>public __construct ( \n    string $name\n ): \n</code></pre> Parameters name <code>string</code>"},{"location":"api/RdKafka/Admin/DeleteGroup/#__destruct","title":"__destruct()","text":"<pre><code>public __destruct (  ): \n</code></pre>"},{"location":"api/RdKafka/Admin/DeleteGroup/#getcdata","title":"getCData()","text":"<pre><code>public getCData (  ): \\FFI\\CData\n</code></pre> Returns <code>\\FFI\\CData</code>"},{"location":"api/RdKafka/Admin/DeleteGroup/#test-coverage","title":"Test Coverage \u2764\ufe0f","text":"<ul> <li>\u2764\ufe0f  Lines: 0% (0 / 8)</li> <li>\u2764\ufe0f  Methods: 0% (0 / 3)</li> </ul>"},{"location":"api/RdKafka/Admin/DeleteGroupsOptions/","title":"Class DeleteGroupsOptions","text":"<p>Class \\RdKafka\\Admin\\DeleteGroupsOptions</p> <ul> <li>extends \\RdKafka\\Admin\\Options</li> </ul>"},{"location":"api/RdKafka/Admin/DeleteGroupsOptions/#methods","title":"Methods","text":""},{"location":"api/RdKafka/Admin/DeleteGroupsOptions/#__construct","title":"__construct()","text":"<pre><code>public __construct ( \n    \\RdKafka $kafka\n ): \n</code></pre> Parameters kafka <code>\\RdKafka</code>"},{"location":"api/RdKafka/Admin/DeleteGroupsOptions/#test-coverage","title":"Test Coverage \u2764\ufe0f","text":"<ul> <li>\u2764\ufe0f  Lines: 0% (0 / 1)</li> <li>\u2764\ufe0f  Methods: 0% (0 / 1)</li> </ul>"},{"location":"api/RdKafka/Admin/DeleteRecords/","title":"Class DeleteRecords","text":"<p>Class \\RdKafka\\Admin\\DeleteRecords</p>"},{"location":"api/RdKafka/Admin/DeleteRecords/#methods","title":"Methods","text":""},{"location":"api/RdKafka/Admin/DeleteRecords/#__construct","title":"__construct()","text":"<pre><code>public __construct ( \n    \\RdKafka\\TopicPartition $beforeOffsets\n ): \n</code></pre> Parameters beforeOffsets <code>\\RdKafka\\TopicPartition</code>"},{"location":"api/RdKafka/Admin/DeleteRecords/#__destruct","title":"__destruct()","text":"<pre><code>public __destruct (  ): \n</code></pre>"},{"location":"api/RdKafka/Admin/DeleteRecords/#getcdata","title":"getCData()","text":"<pre><code>public getCData (  ): \\FFI\\CData\n</code></pre> Returns <code>\\FFI\\CData</code>"},{"location":"api/RdKafka/Admin/DeleteRecords/#test-coverage","title":"Test Coverage \ud83e\udde1","text":"<ul> <li>\ud83e\udde1  Lines: 70% (7 / 10)</li> <li>\u2764\ufe0f  Methods: 33.33% (1 / 3)</li> </ul>"},{"location":"api/RdKafka/Admin/DeleteRecordsOptions/","title":"Class DeleteRecordsOptions","text":"<p>Class \\RdKafka\\Admin\\DeleteRecordsOptions</p> <ul> <li>extends \\RdKafka\\Admin\\Options</li> </ul>"},{"location":"api/RdKafka/Admin/DeleteRecordsOptions/#methods","title":"Methods","text":""},{"location":"api/RdKafka/Admin/DeleteRecordsOptions/#__construct","title":"__construct()","text":"<pre><code>public __construct ( \n    \\RdKafka $kafka\n ): \n</code></pre> Parameters kafka <code>\\RdKafka</code>"},{"location":"api/RdKafka/Admin/DeleteRecordsOptions/#test-coverage","title":"Test Coverage \ud83d\udc9a","text":"<ul> <li>\ud83d\udc9a  Lines: 100% (1 / 1)</li> <li>\ud83d\udc9a  Methods: 100% (1 / 1)</li> </ul>"},{"location":"api/RdKafka/Admin/DeleteTopic/","title":"Class DeleteTopic","text":"<p>Class \\RdKafka\\Admin\\DeleteTopic</p>"},{"location":"api/RdKafka/Admin/DeleteTopic/#methods","title":"Methods","text":""},{"location":"api/RdKafka/Admin/DeleteTopic/#__construct","title":"__construct()","text":"<pre><code>public __construct ( \n    string $name\n ): \n</code></pre> Parameters name <code>string</code>"},{"location":"api/RdKafka/Admin/DeleteTopic/#__destruct","title":"__destruct()","text":"<pre><code>public __destruct (  ): \n</code></pre>"},{"location":"api/RdKafka/Admin/DeleteTopic/#getcdata","title":"getCData()","text":"<pre><code>public getCData (  ): \\FFI\\CData\n</code></pre> Returns <code>\\FFI\\CData</code>"},{"location":"api/RdKafka/Admin/DeleteTopic/#test-coverage","title":"Test Coverage \ud83e\udde1","text":"<ul> <li>\ud83e\udde1  Lines: 62.5% (5 / 8)</li> <li>\u2764\ufe0f  Methods: 33.33% (1 / 3)</li> </ul>"},{"location":"api/RdKafka/Admin/DeleteTopicsOptions/","title":"Class DeleteTopicsOptions","text":"<p>Class \\RdKafka\\Admin\\DeleteTopicsOptions</p> <ul> <li>extends \\RdKafka\\Admin\\Options</li> </ul>"},{"location":"api/RdKafka/Admin/DeleteTopicsOptions/#methods","title":"Methods","text":""},{"location":"api/RdKafka/Admin/DeleteTopicsOptions/#__construct","title":"__construct()","text":"<pre><code>public __construct ( \n    \\RdKafka $kafka\n ): \n</code></pre> Parameters kafka <code>\\RdKafka</code>"},{"location":"api/RdKafka/Admin/DeleteTopicsOptions/#test-coverage","title":"Test Coverage \ud83d\udc9a","text":"<ul> <li>\ud83d\udc9a  Lines: 100% (1 / 1)</li> <li>\ud83d\udc9a  Methods: 100% (1 / 1)</li> </ul>"},{"location":"api/RdKafka/Admin/DescribeConfigsOptions/","title":"Class DescribeConfigsOptions","text":"<p>Class \\RdKafka\\Admin\\DescribeConfigsOptions</p> <ul> <li>extends \\RdKafka\\Admin\\Options</li> </ul>"},{"location":"api/RdKafka/Admin/DescribeConfigsOptions/#methods","title":"Methods","text":""},{"location":"api/RdKafka/Admin/DescribeConfigsOptions/#__construct","title":"__construct()","text":"<pre><code>public __construct ( \n    \\RdKafka $kafka\n ): \n</code></pre> Parameters kafka <code>\\RdKafka</code>"},{"location":"api/RdKafka/Admin/DescribeConfigsOptions/#test-coverage","title":"Test Coverage \ud83d\udc9a","text":"<ul> <li>\ud83d\udc9a  Lines: 100% (1 / 1)</li> <li>\ud83d\udc9a  Methods: 100% (1 / 1)</li> </ul>"},{"location":"api/RdKafka/Admin/GroupResult/","title":"Class GroupResult","text":"<p>Class \\RdKafka\\Admin\\GroupResult</p>"},{"location":"api/RdKafka/Admin/GroupResult/#properties","title":"Properties","text":""},{"location":"api/RdKafka/Admin/GroupResult/#error","title":"error","text":"<pre><code> public int error\n</code></pre>"},{"location":"api/RdKafka/Admin/GroupResult/#errorstring","title":"errorString","text":"<pre><code> public ?string errorString\n</code></pre>"},{"location":"api/RdKafka/Admin/GroupResult/#name","title":"name","text":"<pre><code> public ?string name\n</code></pre>"},{"location":"api/RdKafka/Admin/GroupResult/#partitions","title":"partitions","text":"<pre><code> public array partitions\n</code></pre>"},{"location":"api/RdKafka/Admin/GroupResult/#methods","title":"Methods","text":""},{"location":"api/RdKafka/Admin/GroupResult/#__construct","title":"__construct()","text":"<pre><code>public __construct ( \n    \\FFI\\CData $result\n ): \n</code></pre> Parameters result <code>\\FFI\\CData</code>"},{"location":"api/RdKafka/Admin/GroupResult/#test-coverage","title":"Test Coverage \u2764\ufe0f","text":"<ul> <li>\u2764\ufe0f  Lines: 0% (0 / 7)</li> <li>\u2764\ufe0f  Methods: 0% (0 / 1)</li> </ul>"},{"location":"api/RdKafka/Admin/NewPartitions/","title":"Class NewPartitions","text":"<p>Class \\RdKafka\\Admin\\NewPartitions</p>"},{"location":"api/RdKafka/Admin/NewPartitions/#methods","title":"Methods","text":""},{"location":"api/RdKafka/Admin/NewPartitions/#__construct","title":"__construct()","text":"<pre><code>public __construct ( \n    string $topicName, \n    int $new_total_cnt\n ): \n</code></pre> Parameters topicName <code>string</code> new_total_cnt <code>int</code>"},{"location":"api/RdKafka/Admin/NewPartitions/#__destruct","title":"__destruct()","text":"<pre><code>public __destruct (  ): \n</code></pre>"},{"location":"api/RdKafka/Admin/NewPartitions/#getcdata","title":"getCData()","text":"<pre><code>public getCData (  ): \\FFI\\CData\n</code></pre> Returns <code>\\FFI\\CData</code>"},{"location":"api/RdKafka/Admin/NewPartitions/#setreplicaassignment","title":"setReplicaAssignment()","text":"<pre><code>public setReplicaAssignment ( \n    int $new_partition_id, \n    int[] $broker_ids\n ): void\n</code></pre> Parameters new_partition_id <code>int</code> broker_ids <code>int[]</code>"},{"location":"api/RdKafka/Admin/NewPartitions/#test-coverage","title":"Test Coverage \ud83d\udc9a","text":"<ul> <li>\ud83d\udc9a  Lines: 91.89% (34 / 37)</li> <li>\u2764\ufe0f  Methods: 25% (1 / 4)</li> </ul>"},{"location":"api/RdKafka/Admin/NewTopic/","title":"Class NewTopic","text":"<p>Class \\RdKafka\\Admin\\NewTopic</p>"},{"location":"api/RdKafka/Admin/NewTopic/#methods","title":"Methods","text":""},{"location":"api/RdKafka/Admin/NewTopic/#__construct","title":"__construct()","text":"<pre><code>public __construct ( \n    string $name, \n    int $num_partitions, \n    int $replication_factor\n ): \n</code></pre> Parameters name <code>string</code> num_partitions <code>int</code> replication_factor <code>int</code>"},{"location":"api/RdKafka/Admin/NewTopic/#__destruct","title":"__destruct()","text":"<pre><code>public __destruct (  ): \n</code></pre>"},{"location":"api/RdKafka/Admin/NewTopic/#getcdata","title":"getCData()","text":"<pre><code>public getCData (  ): \\FFI\\CData\n</code></pre> Returns <code>\\FFI\\CData</code>"},{"location":"api/RdKafka/Admin/NewTopic/#setconfig","title":"setConfig()","text":"<pre><code>public setConfig ( \n    string $name, \n    string $value\n ): void\n</code></pre> Parameters name <code>string</code> value <code>string</code>"},{"location":"api/RdKafka/Admin/NewTopic/#setreplicaassignment","title":"setReplicaAssignment()","text":"<pre><code>public setReplicaAssignment ( \n    int $partition_id, \n    array $broker_ids\n ): void\n</code></pre> Parameters partition_id <code>int</code> broker_ids <code>array</code>"},{"location":"api/RdKafka/Admin/NewTopic/#test-coverage","title":"Test Coverage \ud83d\udc9b","text":"<ul> <li>\ud83d\udc9b  Lines: 85.37% (35 / 41)</li> <li>\u2764\ufe0f  Methods: 20% (1 / 5)</li> </ul>"},{"location":"api/RdKafka/Admin/Options/","title":"Class Options","text":"<p>abstract Class \\RdKafka\\Admin\\Options</p>"},{"location":"api/RdKafka/Admin/Options/#methods","title":"Methods","text":""},{"location":"api/RdKafka/Admin/Options/#__construct","title":"__construct()","text":"<pre><code>public __construct ( \n    \\RdKafka $kafka, \n    int $for_api\n ): \n</code></pre> Parameters kafka <code>\\RdKafka</code> for_api <code>int</code>"},{"location":"api/RdKafka/Admin/Options/#__destruct","title":"__destruct()","text":"<pre><code>public __destruct (  ): \n</code></pre>"},{"location":"api/RdKafka/Admin/Options/#getcdata","title":"getCData()","text":"<pre><code>public getCData (  ): \\FFI\\CData\n</code></pre> Returns <code>\\FFI\\CData</code>"},{"location":"api/RdKafka/Admin/Options/#setbrokerid","title":"setBrokerId()","text":"<pre><code>public setBrokerId ( \n    int $broker_id\n ): void\n</code></pre> Parameters broker_id <code>int</code>"},{"location":"api/RdKafka/Admin/Options/#setoperationtimeout","title":"setOperationTimeout()","text":"<pre><code>public setOperationTimeout ( \n    int $timeout_ms\n ): void\n</code></pre> Parameters timeout_ms <code>int</code>"},{"location":"api/RdKafka/Admin/Options/#setrequesttimeout","title":"setRequestTimeout()","text":"<pre><code>public setRequestTimeout ( \n    int $timeout_ms\n ): void\n</code></pre> Parameters timeout_ms <code>int</code>"},{"location":"api/RdKafka/Admin/Options/#setvalidateonly","title":"setValidateOnly()","text":"<pre><code>public setValidateOnly ( \n    bool $true_or_false\n ): void\n</code></pre> Parameters true_or_false <code>bool</code>"},{"location":"api/RdKafka/Admin/Options/#test-coverage","title":"Test Coverage \ud83d\udc9b","text":"<ul> <li>\ud83d\udc9b  Lines: 90% (36 / 40)</li> <li>\u2764\ufe0f  Methods: 42.86% (3 / 7)</li> </ul>"},{"location":"api/RdKafka/Admin/Options/#extended-by","title":"Extended by","text":"<ul> <li>\\RdKafka\\Admin\\AlterConfigsOptions</li> <li>\\RdKafka\\Admin\\CreatePartitionsOptions</li> <li>\\RdKafka\\Admin\\CreateTopicsOptions</li> <li>\\RdKafka\\Admin\\DeleteConsumerGroupOffsetsOptions</li> <li>\\RdKafka\\Admin\\DeleteGroupsOptions</li> <li>\\RdKafka\\Admin\\DeleteRecordsOptions</li> <li>\\RdKafka\\Admin\\DeleteTopicsOptions</li> <li>\\RdKafka\\Admin\\DescribeConfigsOptions</li> </ul>"},{"location":"api/RdKafka/Admin/TopicResult/","title":"Class TopicResult","text":"<p>Class \\RdKafka\\Admin\\TopicResult</p>"},{"location":"api/RdKafka/Admin/TopicResult/#properties","title":"Properties","text":""},{"location":"api/RdKafka/Admin/TopicResult/#error","title":"error","text":"<pre><code> public int error\n</code></pre>"},{"location":"api/RdKafka/Admin/TopicResult/#errorstring","title":"errorString","text":"<pre><code> public ?string errorString\n</code></pre>"},{"location":"api/RdKafka/Admin/TopicResult/#name","title":"name","text":"<pre><code> public string name\n</code></pre>"},{"location":"api/RdKafka/Admin/TopicResult/#methods","title":"Methods","text":""},{"location":"api/RdKafka/Admin/TopicResult/#__construct","title":"__construct()","text":"<pre><code>public __construct ( \n    \\FFI\\CData $result\n ): \n</code></pre> Parameters result <code>\\FFI\\CData</code>"},{"location":"api/RdKafka/Admin/TopicResult/#test-coverage","title":"Test Coverage \ud83d\udc9a","text":"<ul> <li>\ud83d\udc9a  Lines: 100% (3 / 3)</li> <li>\ud83d\udc9a  Methods: 100% (1 / 1)</li> </ul>"},{"location":"api/RdKafka/FFI/CallbackProxy/","title":"Class CallbackProxy","text":"<p>abstract Class \\RdKafka\\FFI\\CallbackProxy</p>"},{"location":"api/RdKafka/FFI/CallbackProxy/#methods","title":"Methods","text":""},{"location":"api/RdKafka/FFI/CallbackProxy/#create","title":"create()","text":"<pre><code>public static create ( \n    callable $callback\n ): \\Closure\n</code></pre> Parameters callback <code>callable</code> Returns <code>\\Closure</code>"},{"location":"api/RdKafka/FFI/CallbackProxy/#test-coverage","title":"Test Coverage \ud83d\udc9a","text":"<ul> <li>\ud83d\udc9a  Lines: 100% (4 / 4)</li> <li>\ud83d\udc9a  Methods: 100% (2 / 2)</li> </ul>"},{"location":"api/RdKafka/FFI/CallbackProxy/#extended-by","title":"Extended by","text":"<ul> <li>\\RdKafka\\FFI\\ConsumeCallbackProxy</li> <li>\\RdKafka\\FFI\\DrMsgCallbackProxy</li> <li>\\RdKafka\\FFI\\ErrorCallbackProxy</li> <li>\\RdKafka\\FFI\\LogCallbackProxy</li> <li>\\RdKafka\\FFI\\OffsetCommitCallbackProxy</li> <li>\\RdKafka\\FFI\\PartitionerCallbackProxy</li> <li>\\RdKafka\\FFI\\RebalanceCallbackProxy</li> <li>\\RdKafka\\FFI\\StatsCallbackProxy</li> </ul>"},{"location":"api/RdKafka/FFI/ConsumeCallbackProxy/","title":"Class ConsumeCallbackProxy","text":"<p>Class \\RdKafka\\FFI\\ConsumeCallbackProxy</p> <ul> <li>extends \\RdKafka\\FFI\\CallbackProxy</li> </ul>"},{"location":"api/RdKafka/FFI/ConsumeCallbackProxy/#methods","title":"Methods","text":""},{"location":"api/RdKafka/FFI/ConsumeCallbackProxy/#__invoke","title":"__invoke()","text":"<pre><code>public __invoke ( \n    \\FFI\\CData $nativeMessage, \n    ?\\FFI\\CData $opaque = null\n ): void\n</code></pre> Parameters nativeMessage <code>\\FFI\\CData</code> opaque <code>?\\FFI\\CData</code>"},{"location":"api/RdKafka/FFI/ConsumeCallbackProxy/#test-coverage","title":"Test Coverage \ud83d\udc9a","text":"<ul> <li>\ud83d\udc9a  Lines: 100% (4 / 4)</li> <li>\ud83d\udc9a  Methods: 100% (1 / 1)</li> </ul>"},{"location":"api/RdKafka/FFI/DrMsgCallbackProxy/","title":"Class DrMsgCallbackProxy","text":"<p>Class \\RdKafka\\FFI\\DrMsgCallbackProxy</p> <ul> <li>extends \\RdKafka\\FFI\\CallbackProxy</li> </ul>"},{"location":"api/RdKafka/FFI/DrMsgCallbackProxy/#methods","title":"Methods","text":""},{"location":"api/RdKafka/FFI/DrMsgCallbackProxy/#__invoke","title":"__invoke()","text":"<pre><code>public __invoke ( \n    \\FFI\\CData $producer, \n    \\FFI\\CData $nativeMessage, \n    ?\\FFI\\CData $opaque = null\n ): void\n</code></pre> Parameters producer <code>\\FFI\\CData</code> nativeMessage <code>\\FFI\\CData</code> opaque <code>?\\FFI\\CData</code>"},{"location":"api/RdKafka/FFI/DrMsgCallbackProxy/#test-coverage","title":"Test Coverage \ud83d\udc9a","text":"<ul> <li>\ud83d\udc9a  Lines: 100% (5 / 5)</li> <li>\ud83d\udc9a  Methods: 100% (1 / 1)</li> </ul>"},{"location":"api/RdKafka/FFI/ErrorCallbackProxy/","title":"Class ErrorCallbackProxy","text":"<p>Class \\RdKafka\\FFI\\ErrorCallbackProxy</p> <ul> <li>extends \\RdKafka\\FFI\\CallbackProxy</li> </ul>"},{"location":"api/RdKafka/FFI/ErrorCallbackProxy/#methods","title":"Methods","text":""},{"location":"api/RdKafka/FFI/ErrorCallbackProxy/#__invoke","title":"__invoke()","text":"<pre><code>public __invoke ( \n    \\FFI\\CData $consumerOrProducer, \n    int $err, \n    string $reason, \n    ?\\FFI\\CData $opaque = null\n ): void\n</code></pre> Parameters consumerOrProducer <code>\\FFI\\CData</code> err <code>int</code> reason <code>string</code> opaque <code>?\\FFI\\CData</code>"},{"location":"api/RdKafka/FFI/ErrorCallbackProxy/#test-coverage","title":"Test Coverage \ud83d\udc9a","text":"<ul> <li>\ud83d\udc9a  Lines: 100% (6 / 6)</li> <li>\ud83d\udc9a  Methods: 100% (1 / 1)</li> </ul>"},{"location":"api/RdKafka/FFI/Library/","title":"Class Library","text":"<p>Class \\RdKafka\\FFI\\Library</p> <ul> <li>uses \\RdKafka\\FFI\\Methods</li> </ul> <p>This class is for internal use. It provides access to the low level interface to librdkafka.</p> <p>Best practice is to use high level interfaces like \\RdKafka\\Conf, \\RdKafka\\Producer, \u2026</p> <p>See also</p> <ul> <li>https://docs.confluent.io/current/clients/librdkafka/rdkafka_8h.html</li> </ul>"},{"location":"api/RdKafka/FFI/Library/#constants","title":"Constants","text":""},{"location":"api/RdKafka/FFI/Library/#php_library_version","title":"PHP_LIBRARY_VERSION","text":"<pre><code>public PHP_LIBRARY_VERSION = '0.6.0'\n</code></pre>"},{"location":"api/RdKafka/FFI/Library/#version_autodetect","title":"VERSION_AUTODETECT","text":"<pre><code>public VERSION_AUTODETECT = ''\n</code></pre>"},{"location":"api/RdKafka/FFI/Library/#version_latest","title":"VERSION_LATEST","text":"<pre><code>public VERSION_LATEST = '2.8.0'\n</code></pre>"},{"location":"api/RdKafka/FFI/Library/#methods","title":"Methods","text":""},{"location":"api/RdKafka/FFI/Library/#cast","title":"cast()","text":"<pre><code>public static cast ( \n    mixed $type, \n    \\FFI\\CData $ptr\n ): \\FFI\\CData\n</code></pre> Parameters type <code>mixed</code> ptr <code>\\FFI\\CData</code> Returns <code>\\FFI\\CData</code>"},{"location":"api/RdKafka/FFI/Library/#getclientversion","title":"getClientVersion()","text":"<pre><code>public static getClientVersion (  ): string\n</code></pre> <p>The client version exposed to the brokers.</p> <p>The version has the format v{phpLibraryVersion}-v{bindingVersion}-librdkafka-v{librdkafkaVersion} - e.g. v0.1.0-dev-v1.5.2-librdkafka-v1.5.2)</p> Returns <code>string</code>"},{"location":"api/RdKafka/FFI/Library/#getffi","title":"getFFI()","text":"<pre><code>public static getFFI (  ): \\FFI\n</code></pre> Returns <code>\\FFI</code>"},{"location":"api/RdKafka/FFI/Library/#getlibrary","title":"getLibrary()","text":"<pre><code>public static getLibrary (  ): string\n</code></pre> Returns <code>string</code>"},{"location":"api/RdKafka/FFI/Library/#getlibraryversion","title":"getLibraryVersion()","text":"<pre><code>public static getLibraryVersion (  ): string\n</code></pre> <p>The version of librdkafka</p> Returns <code>string</code>"},{"location":"api/RdKafka/FFI/Library/#getversion","title":"getVersion()","text":"<pre><code>public static getVersion (  ): string\n</code></pre> <p>The version of the current binding with librdkafka</p> Returns <code>string</code>"},{"location":"api/RdKafka/FFI/Library/#hasmethod","title":"hasMethod()","text":"<pre><code>public static hasMethod ( \n    string $name\n ): bool\n</code></pre> <p>Whether method is supported by current binding version.</p> Parameters name <code>string</code> Returns <code>bool</code>"},{"location":"api/RdKafka/FFI/Library/#init","title":"init()","text":"<pre><code>public static init ( \n    string $version = self::VERSION_AUTODETECT, \n    string $scope = 'RdKafka', \n    ?string $library = null, \n    ?string $cdef = null\n ): void\n</code></pre> Parameters version <code>string</code> scope <code>string</code> library <code>?string</code> cdef <code>?string</code>"},{"location":"api/RdKafka/FFI/Library/#new","title":"new()","text":"<pre><code>public static new ( \n    string|\\FFI\\CData|mixed $type, \n    bool $owned = true, \n    bool $persistent = false\n ): \\FFI\\CData\n</code></pre> Parameters type <code>string|\\FFI\\CData|mixed</code> owned <code>bool</code> persistent <code>bool</code> Returns <code>\\FFI\\CData</code>"},{"location":"api/RdKafka/FFI/Library/#preload","title":"preload()","text":"<pre><code>public static preload ( \n    string $version = self::VERSION_AUTODETECT, \n    string $scope = 'RdKafka', \n    ?string $library = null, \n    ?string $cdef = null\n ): \\FFI\n</code></pre> Parameters version <code>string</code> scope <code>string</code> library <code>?string</code> cdef <code>?string</code> Returns <code>\\FFI</code>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_aclbindingfilter_new","title":"rd_kafka_AclBindingFilter_new()","text":"<pre><code>public static rd_kafka_AclBindingFilter_new ( \n    int $restype, \n    string|null $name, \n    int $resource_pattern_type, \n    string|null $principal, \n    string|null $host, \n    int $operation, \n    int $permission_type, \n    \\FFI\\CData|null $errstr, \n    int|null $errstr_size\n ): \\FFI\\CData|null\n</code></pre> <p>Create a new AclBindingFilter object. This object is later passed to rd_kafka_DescribeAcls() or rd_kafka_DeletesAcls() in order to filter the acls to retrieve or to delete. Use the same rd_kafka_AclBinding functions to query or destroy it. </p> Parameters restype <code>int</code> rd_kafka_ResourceType_t - The ResourceType or <code>RD_KAFKA_RESOURCE_ANY</code> if not filtering by this field. name <code>string|null</code> const char* - The resource name or NULL if not filtering by this field. resource_pattern_type <code>int</code> rd_kafka_ResourcePatternType_t - The pattern type or <code>RD_KAFKA_RESOURCE_PATTERN_ANY</code> if not filtering by this field. principal <code>string|null</code> const char* - A principal or NULL if not filtering by this field. host <code>string|null</code> const char* - An hostname or ip or NULL if not filtering by this field. operation <code>int</code> rd_kafka_AclOperation_t - A Kafka operation or <code>RD_KAFKA_ACL_OPERATION_ANY</code> if not filtering by this field. permission_type <code>int</code> rd_kafka_AclPermissionType_t - A Kafka permission type or <code>RD_KAFKA_ACL_PERMISSION_TYPE_ANY</code> if not filtering by this field. errstr <code>\\FFI\\CData|null</code> char* - An error string for returning errors or NULL to not use it. errstr_size <code>int|null</code> size_t - The <code>errstr</code> size or 0 to not use it. Returns <code>\\FFI\\CData|null</code> rd_kafka_AclBindingFilter_t* - a new allocated AclBindingFilter object, or NULL if the input parameters are invalid. Use rd_kafka_AclBinding_destroy() to free object when done. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a20003b0ae6aeb68f02f3929c5c797372 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_aclbinding_destroy","title":"rd_kafka_AclBinding_destroy()","text":"<pre><code>public static rd_kafka_AclBinding_destroy ( \n    \\FFI\\CData|null $acl_binding\n ): void\n</code></pre> Parameters acl_binding <code>\\FFI\\CData|null</code> rd_kafka_AclBinding_t*"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_aclbinding_destroy_array","title":"rd_kafka_AclBinding_destroy_array()","text":"<pre><code>public static rd_kafka_AclBinding_destroy_array ( \n    \\FFI\\CData|null $acl_bindings, \n    int|null $acl_bindings_cnt\n ): void\n</code></pre> Parameters acl_bindings <code>\\FFI\\CData|null</code> rd_kafka_AclBinding_t** acl_bindings_cnt <code>int|null</code> size_t"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_aclbinding_error","title":"rd_kafka_AclBinding_error()","text":"<pre><code>public static rd_kafka_AclBinding_error ( \n    \\FFI\\CData|null $acl\n ): \\FFI\\CData|null\n</code></pre> Parameters acl <code>\\FFI\\CData|null</code> const rd_kafka_AclBinding_t* - ) Returns <code>\\FFI\\CData|null</code> const rd_kafka_error_t* - the error object for the given acl binding, or NULL on success. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a047abe192b6445a37cbab1f1be355f3d </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_aclbinding_host","title":"rd_kafka_AclBinding_host()","text":"<pre><code>public static rd_kafka_AclBinding_host ( \n    \\FFI\\CData|null $acl\n ): string|null\n</code></pre> Remarkslifetime of the returned string is the same as the <code>acl</code>.  Parameters acl <code>\\FFI\\CData|null</code> const rd_kafka_AclBinding_t* - ) Returns <code>string|null</code> const char* - the host for the given acl binding. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8c242229f6b0b8faeb078fc814261fa7 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_aclbinding_name","title":"rd_kafka_AclBinding_name()","text":"<pre><code>public static rd_kafka_AclBinding_name ( \n    \\FFI\\CData|null $acl\n ): string|null\n</code></pre> Remarkslifetime of the returned string is the same as the <code>acl</code>.  Parameters acl <code>\\FFI\\CData|null</code> const rd_kafka_AclBinding_t* - ) Returns <code>string|null</code> const char* - the resource name for the given acl binding. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#acb03634b4456326f3592b79584c551ea </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_aclbinding_new","title":"rd_kafka_AclBinding_new()","text":"<pre><code>public static rd_kafka_AclBinding_new ( \n    int $restype, \n    string|null $name, \n    int $resource_pattern_type, \n    string|null $principal, \n    string|null $host, \n    int $operation, \n    int $permission_type, \n    \\FFI\\CData|null $errstr, \n    int|null $errstr_size\n ): \\FFI\\CData|null\n</code></pre> <p>Create a new AclBinding object. This object is later passed to rd_kafka_CreateAcls(). </p> Parameters restype <code>int</code> rd_kafka_ResourceType_t - The ResourceType. name <code>string|null</code> const char* - The resource name. resource_pattern_type <code>int</code> rd_kafka_ResourcePatternType_t - The pattern type. principal <code>string|null</code> const char* - A principal, following the kafka specification. host <code>string|null</code> const char* - An hostname or ip. operation <code>int</code> rd_kafka_AclOperation_t - A Kafka operation. permission_type <code>int</code> rd_kafka_AclPermissionType_t - A Kafka permission type. errstr <code>\\FFI\\CData|null</code> char* - An error string for returning errors or NULL to not use it. errstr_size <code>int|null</code> size_t - The <code>errstr</code> size or 0 to not use it. Returns <code>\\FFI\\CData|null</code> rd_kafka_AclBinding_t* - a new allocated AclBinding object, or NULL if the input parameters are invalid. Use rd_kafka_AclBinding_destroy() to free object when done. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a3475335e39b68c6033c87e05f5a4c5fa </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_aclbinding_operation","title":"rd_kafka_AclBinding_operation()","text":"<pre><code>public static rd_kafka_AclBinding_operation ( \n    \\FFI\\CData|null $acl\n ): int\n</code></pre> Parameters acl <code>\\FFI\\CData|null</code> const rd_kafka_AclBinding_t* - ) Returns <code>int</code> rd_kafka_AclOperation_t - the acl operation for the given acl binding. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ab4c620d7a3155c7f8cbf5556b99c2b7d </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_aclbinding_permission_type","title":"rd_kafka_AclBinding_permission_type()","text":"<pre><code>public static rd_kafka_AclBinding_permission_type ( \n    \\FFI\\CData|null $acl\n ): int\n</code></pre> Parameters acl <code>\\FFI\\CData|null</code> const rd_kafka_AclBinding_t* - ) Returns <code>int</code> rd_kafka_AclPermissionType_t - the permission type for the given acl binding. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aadb093357b1ed866ae99c710bd5e44f3 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_aclbinding_principal","title":"rd_kafka_AclBinding_principal()","text":"<pre><code>public static rd_kafka_AclBinding_principal ( \n    \\FFI\\CData|null $acl\n ): string|null\n</code></pre> Remarkslifetime of the returned string is the same as the <code>acl</code>.  Parameters acl <code>\\FFI\\CData|null</code> const rd_kafka_AclBinding_t* - ) Returns <code>string|null</code> const char* - the principal for the given acl binding. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ad99b0868262484fc46b7c36b7db2173b </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_aclbinding_resource_pattern_type","title":"rd_kafka_AclBinding_resource_pattern_type()","text":"<pre><code>public static rd_kafka_AclBinding_resource_pattern_type ( \n    \\FFI\\CData|null $acl\n ): int\n</code></pre> Parameters acl <code>\\FFI\\CData|null</code> const rd_kafka_AclBinding_t* - ) Returns <code>int</code> rd_kafka_ResourcePatternType_t - the resource pattern type for the given acl binding. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a7c24d7c8312ea58cfdd18f8bc06fc5c8 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_aclbinding_restype","title":"rd_kafka_AclBinding_restype()","text":"<pre><code>public static rd_kafka_AclBinding_restype ( \n    \\FFI\\CData|null $acl\n ): int\n</code></pre> Parameters acl <code>\\FFI\\CData|null</code> const rd_kafka_AclBinding_t* - ) Returns <code>int</code> rd_kafka_ResourceType_t - the resource type for the given acl binding. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#af576f429f52ace1379cf9d2a4c453d8c </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_acloperation_name","title":"rd_kafka_AclOperation_name()","text":"<pre><code>public static rd_kafka_AclOperation_name ( \n    int $acl_operation\n ): string|null\n</code></pre> Parameters acl_operation <code>int</code> rd_kafka_AclOperation_t - ) Returns <code>string|null</code> const char* - a string representation of the <code>acl_operation</code> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#afeab00c55bf43b5152ecef5167baa227 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_aclpermissiontype_name","title":"rd_kafka_AclPermissionType_name()","text":"<pre><code>public static rd_kafka_AclPermissionType_name ( \n    int $acl_permission_type\n ): string|null\n</code></pre> Parameters acl_permission_type <code>int</code> rd_kafka_AclPermissionType_t - ) Returns <code>string|null</code> const char* - a string representation of the <code>acl_permission_type</code> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a9df29768d60a17013bb4e2860378f248 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_adminoptions_destroy","title":"rd_kafka_AdminOptions_destroy()","text":"<pre><code>public static rd_kafka_AdminOptions_destroy ( \n    \\FFI\\CData|null $options\n ): void\n</code></pre> Parameters options <code>\\FFI\\CData|null</code> rd_kafka_AdminOptions_t*"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_adminoptions_new","title":"rd_kafka_AdminOptions_new()","text":"<pre><code>public static rd_kafka_AdminOptions_new ( \n    \\FFI\\CData|null $rk, \n    int $for_api\n ): \\FFI\\CData|null\n</code></pre> <p>Create a new AdminOptions object. </p> <pre>   The options object is not modified by the Admin API request APIs,\n   (e.g. CreateTopics) and may be reused for multiple calls.\n\n</pre> Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* - Client instance. for_api <code>int</code> rd_kafka_admin_op_t - Specifies what Admin API this AdminOptions object will be used for, which will enforce what AdminOptions_set_..() calls may be used based on the API, causing unsupported set..() calls to fail. Specifying RD_KAFKA_ADMIN_OP_ANY disables the enforcement allowing any option to be set, even if the option is not used in a future call to an Admin API method. Returns <code>\\FFI\\CData|null</code> rd_kafka_AdminOptions_t* - a new AdminOptions object (which must be freed with rd_kafka_AdminOptions_destroy()), or NULL if <code>for_api</code> was set to an unknown API op type. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a685d10a84d9c230ea81545b280925483 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_adminoptions_set_broker","title":"rd_kafka_AdminOptions_set_broker()","text":"<pre><code>public static rd_kafka_AdminOptions_set_broker ( \n    \\FFI\\CData|null $options, \n    int|null $broker_id, \n    \\FFI\\CData|null $errstr, \n    int|null $errstr_size\n ): int\n</code></pre> <p>Override what broker the Admin request will be sent to. </p> <p>By default, Admin requests are sent to the controller broker, with the following exceptions:</p> <ul> <li>AlterConfigs with a BROKER resource are sent to the broker id set as the resource name.</li> <li>IncrementalAlterConfigs with a BROKER resource are sent to the broker id set as the resource name.</li> <li>DescribeConfigs with a BROKER resource are sent to the broker id set as the resource name.</li> </ul> RemarksThis API should typically not be used, but serves as a workaround if new resource types are to the broker that the client does not know where to send.  Parameters options <code>\\FFI\\CData|null</code> rd_kafka_AdminOptions_t* - Admin Options. broker_id <code>int|null</code> int32_t - The broker to send the request to. errstr <code>\\FFI\\CData|null</code> char* - A human readable error string (nul-terminated) is written to this location that must be of at least <code>errstr_size</code> bytes. The <code>errstr</code> is only written in case of error. - Writable size in <code>errstr</code>. errstr_size <code>int|null</code> size_t Returns <code>int</code> rd_kafka_resp_err_t - RD_KAFKA_RESP_ERR_NO_ERROR on success or an error code on failure in which case an error string will be written <code>errstr</code>. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ae4a84f4fb6aaac8e09e186a7245a9727 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_adminoptions_set_include_authorized_operations","title":"rd_kafka_AdminOptions_set_include_authorized_operations()","text":"<pre><code>public static rd_kafka_AdminOptions_set_include_authorized_operations ( \n    \\FFI\\CData|null $options, \n    int|null $true_or_false\n ): \\FFI\\CData|null\n</code></pre> <p>Whether broker should return authorized operations for the given resource in the DescribeConsumerGroups, DescribeTopics, or DescribeCluster calls. </p> RemarksThis option is valid for DescribeConsumerGroups, DescribeTopics, DescribeCluster.  Parameters options <code>\\FFI\\CData|null</code> rd_kafka_AdminOptions_t* - Admin options. true_or_false <code>int|null</code> int - Defaults to false. Returns <code>\\FFI\\CData|null</code> rd_kafka_error_t* - NULL on success, a new error instance that must be released with rd_kafka_error_destroy() in case of error. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a22c4e359f297cf03f5a109cb72093a27 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_adminoptions_set_isolation_level","title":"rd_kafka_AdminOptions_set_isolation_level()","text":"<pre><code>public static rd_kafka_AdminOptions_set_isolation_level ( \n    \\FFI\\CData|null $options, \n    int $value\n ): \\FFI\\CData|null\n</code></pre> Parameters options <code>\\FFI\\CData|null</code> rd_kafka_AdminOptions_t* value <code>int</code> rd_kafka_IsolationLevel_t Returns <code>\\FFI\\CData|null</code> rd_kafka_error_t*"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_adminoptions_set_match_consumer_group_states","title":"rd_kafka_AdminOptions_set_match_consumer_group_states()","text":"<pre><code>public static rd_kafka_AdminOptions_set_match_consumer_group_states ( \n    \\FFI\\CData|null $options, \n    \\FFI\\CData|null $consumer_group_states, \n    int|null $consumer_group_states_cnt\n ): \\FFI\\CData|null\n</code></pre> <p>Set consumer groups states to query for. </p> RemarksThis option is valid for ListConsumerGroups.  Parameters options <code>\\FFI\\CData|null</code> rd_kafka_AdminOptions_t* - Admin options. consumer_group_states <code>\\FFI\\CData|null</code> const rd_kafka_consumer_group_state_t* - Array of consumer group states. consumer_group_states_cnt <code>int|null</code> size_t - Size of the <code>consumer_group_states</code> array. Returns <code>\\FFI\\CData|null</code> rd_kafka_error_t* - NULL on success, a new error instance that must be released with rd_kafka_error_destroy() in case of error. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a907d23eac09352f32321e9d0140caab1 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_adminoptions_set_match_consumer_group_types","title":"rd_kafka_AdminOptions_set_match_consumer_group_types()","text":"<pre><code>public static rd_kafka_AdminOptions_set_match_consumer_group_types ( \n    \\FFI\\CData|null $options, \n    \\FFI\\CData|null $consumer_group_types, \n    int|null $consumer_group_types_cnt\n ): \\FFI\\CData|null\n</code></pre> <p>Set consumer groups types to query for. </p> RemarksThis option is valid for ListConsumerGroups.  Parameters options <code>\\FFI\\CData|null</code> rd_kafka_AdminOptions_t* - Admin options. consumer_group_types <code>\\FFI\\CData|null</code> const rd_kafka_consumer_group_type_t* - Array of consumer group types. consumer_group_types_cnt <code>int|null</code> size_t - Size of the <code>consumer_group_types</code> array. Returns <code>\\FFI\\CData|null</code> rd_kafka_error_t* - NULL on success, a new error instance that must be released with rd_kafka_error_destroy() in case of error. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a93ca240fdff348f2cb46f870c51ffd1c </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_adminoptions_set_opaque","title":"rd_kafka_AdminOptions_set_opaque()","text":"<pre><code>public static rd_kafka_AdminOptions_set_opaque ( \n    \\FFI\\CData|null $options, \n    \\FFI\\CData|object|string|null $opaque\n ): void\n</code></pre> Parameters options <code>\\FFI\\CData|null</code> rd_kafka_AdminOptions_t* opaque <code>\\FFI\\CData|object|string|null</code> void*"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_adminoptions_set_operation_timeout","title":"rd_kafka_AdminOptions_set_operation_timeout()","text":"<pre><code>public static rd_kafka_AdminOptions_set_operation_timeout ( \n    \\FFI\\CData|null $options, \n    int|null $timeout_ms, \n    \\FFI\\CData|null $errstr, \n    int|null $errstr_size\n ): int\n</code></pre> <p>Sets the broker's operation timeout, such as the timeout for CreateTopics to complete the creation of topics on the controller before returning a result to the application. </p> <p>CreateTopics: values &lt;= 0 will return immediately after triggering topic creation, while &gt; 0 will wait this long for topic creation to propagate in cluster. Default: 60 seconds.</p> <p>DeleteTopics: same semantics as CreateTopics. CreatePartitions: same semantics as CreateTopics.</p> RemarksThis option is valid for CreateTopics, DeleteTopics, CreatePartitions, and DeleteRecords.  Parameters options <code>\\FFI\\CData|null</code> rd_kafka_AdminOptions_t* - Admin options. timeout_ms <code>int|null</code> int - Timeout in milliseconds. errstr <code>\\FFI\\CData|null</code> char* - A human readable error string (nul-terminated) is written to this location that must be of at least <code>errstr_size</code> bytes. The <code>errstr</code> is only written in case of error. - Writable size in <code>errstr</code>. errstr_size <code>int|null</code> size_t Returns <code>int</code> rd_kafka_resp_err_t - RD_KAFKA_RESP_ERR_NO_ERROR on success, or RD_KAFKA_RESP_ERR__INVALID_ARG if timeout was out of range in which case an error string will be written <code>errstr</code>. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a708390fc4e94ea64a98009d294116d4c </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_adminoptions_set_request_timeout","title":"rd_kafka_AdminOptions_set_request_timeout()","text":"<pre><code>public static rd_kafka_AdminOptions_set_request_timeout ( \n    \\FFI\\CData|null $options, \n    int|null $timeout_ms, \n    \\FFI\\CData|null $errstr, \n    int|null $errstr_size\n ): int\n</code></pre> <p>Sets the overall request timeout, including broker lookup, request transmission, operation time on broker, and response. </p> RemarksThis option is valid for all Admin API requests.  Parameters options <code>\\FFI\\CData|null</code> rd_kafka_AdminOptions_t* - Admin options. timeout_ms <code>int|null</code> int - Timeout in milliseconds. Defaults to <code>socket.timeout.ms</code>. errstr <code>\\FFI\\CData|null</code> char* - A human readable error string (nul-terminated) is written to this location that must be of at least <code>errstr_size</code> bytes. The <code>errstr</code> is only written in case of error. - Writable size in <code>errstr</code>. errstr_size <code>int|null</code> size_t Returns <code>int</code> rd_kafka_resp_err_t - RD_KAFKA_RESP_ERR_NO_ERROR on success, or RD_KAFKA_RESP_ERR__INVALID_ARG if timeout was out of range in which case an error string will be written <code>errstr</code>. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a9988b9e9984f7c884e11176beac17d62 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_adminoptions_set_require_stable_offsets","title":"rd_kafka_AdminOptions_set_require_stable_offsets()","text":"<pre><code>public static rd_kafka_AdminOptions_set_require_stable_offsets ( \n    \\FFI\\CData|null $options, \n    int|null $true_or_false\n ): \\FFI\\CData|null\n</code></pre> <p>Whether broker should return stable offsets (transaction-committed). </p> RemarksThis option is valid for ListConsumerGroupOffsets.  Parameters options <code>\\FFI\\CData|null</code> rd_kafka_AdminOptions_t* - Admin options. true_or_false <code>int|null</code> int - Defaults to false. Returns <code>\\FFI\\CData|null</code> rd_kafka_error_t* - NULL on success, a new error instance that must be released with rd_kafka_error_destroy() in case of error. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a378186db06498feeb35e03a3345fc562 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_adminoptions_set_validate_only","title":"rd_kafka_AdminOptions_set_validate_only()","text":"<pre><code>public static rd_kafka_AdminOptions_set_validate_only ( \n    \\FFI\\CData|null $options, \n    int|null $true_or_false, \n    \\FFI\\CData|null $errstr, \n    int|null $errstr_size\n ): int\n</code></pre> <p>Tell broker to only validate the request, without performing the requested operation (create topics, etc). </p> RemarksThis option is valid for CreateTopics, CreatePartitions, AlterConfigs.  Parameters options <code>\\FFI\\CData|null</code> rd_kafka_AdminOptions_t* - Admin options. true_or_false <code>int|null</code> int - Defaults to false. errstr <code>\\FFI\\CData|null</code> char* - A human readable error string (nul-terminated) is written to this location that must be of at least <code>errstr_size</code> bytes. The <code>errstr</code> is only written in case of error. - Writable size in <code>errstr</code>. errstr_size <code>int|null</code> size_t Returns <code>int</code> rd_kafka_resp_err_t - RD_KAFKA_RESP_ERR_NO_ERROR on success or an error code on failure in which case an error string will be written <code>errstr</code>. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ae94b1b0da81e43a4e928eea01952fb37 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_alterconfigs","title":"rd_kafka_AlterConfigs()","text":"<pre><code>public static rd_kafka_AlterConfigs ( \n    \\FFI\\CData|null $rk, \n    \\FFI\\CData|null $configs, \n    int|null $config_cnt, \n    \\FFI\\CData|null $options, \n    \\FFI\\CData|null $rkqu\n ): void\n</code></pre> <p>Update the configuration for the specified resources. Updates are not transactional so they may succeed for a subset of the provided resources while the others fail. The configuration for a particular resource is updated atomically, replacing values using the provided ConfigEntrys and reverting unspecified ConfigEntrys to their default values. </p> RemarksRequires broker version &gt;=0.11.0.0 WarningAlterConfigs will replace all existing configuration for the provided resources with the new configuration given, reverting all other configuration to their default values. RemarksMultiple resources and resource types may be set, but at most one resource of type <code>RD_KAFKA_RESOURCE_BROKER</code> is allowed per call since these resource requests must be sent to the broker specified in the resource. Deprecated:Use rd_kafka_IncrementalAlterConfigs(). Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* configs <code>\\FFI\\CData|null</code> rd_kafka_ConfigResource_t** config_cnt <code>int|null</code> size_t options <code>\\FFI\\CData|null</code> const rd_kafka_AdminOptions_t* rkqu <code>\\FFI\\CData|null</code> rd_kafka_queue_t* <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ade8d161dfb86a94179d286f36ec5b28e </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_alterconfigs_result_resources","title":"rd_kafka_AlterConfigs_result_resources()","text":"<pre><code>public static rd_kafka_AlterConfigs_result_resources ( \n    \\FFI\\CData|null $result, \n    \\FFI\\CData|null $cntp\n ): \\FFI\\CData|null\n</code></pre> <p>Get an array of resource results from a AlterConfigs result. </p> <p>Use <code>rd_kafka_ConfigResource_error()</code> and <code>rd_kafka_ConfigResource_error_string()</code> to extract per-resource error results on the returned array elements.</p> <p>The returned object life-times are the same as the <code>result</code> object.</p> Parameters result <code>\\FFI\\CData|null</code> const rd_kafka_AlterConfigs_result_t* - Result object to get resource results from. cntp <code>\\FFI\\CData|null</code> size_t* - is updated to the number of elements in the array. Returns <code>\\FFI\\CData|null</code> const rd_kafka_ConfigResource_t** - an array of ConfigResource elements, or NULL if not available. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a7a8a2fdf3473111a84e14bcb0a88ef05 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_alterconsumergroupoffsets","title":"rd_kafka_AlterConsumerGroupOffsets()","text":"<pre><code>public static rd_kafka_AlterConsumerGroupOffsets ( \n    \\FFI\\CData|null $rk, \n    \\FFI\\CData|null $alter_grpoffsets, \n    int|null $alter_grpoffsets_cnt, \n    \\FFI\\CData|null $options, \n    \\FFI\\CData|null $rkqu\n ): void\n</code></pre> <p>Alter committed offsets for a set of partitions in a consumer group. This will succeed at the partition level only if the group is not actively subscribed to the corresponding topic. </p> RemarksThe result event type emitted on the supplied queue is of type <code>RD_KAFKA_EVENT_ALTERCONSUMERGROUPOFFSETS_RESULT</code>  The current implementation only supports one group per invocation.  Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* - Client instance. alter_grpoffsets <code>\\FFI\\CData|null</code> rd_kafka_AlterConsumerGroupOffsets_t** - Array of group committed offsets to alter. MUST only be one single element. alter_grpoffsets_cnt <code>int|null</code> size_t - Number of elements in <code>alter_grpoffsets</code> array. MUST always be 1. options <code>\\FFI\\CData|null</code> const rd_kafka_AdminOptions_t* - Optional admin options, or NULL for defaults. rkqu <code>\\FFI\\CData|null</code> rd_kafka_queue_t* - Queue to emit result on. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a3bebec377020469583f6c8e2f0b06ec8 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_alterconsumergroupoffsets_destroy","title":"rd_kafka_AlterConsumerGroupOffsets_destroy()","text":"<pre><code>public static rd_kafka_AlterConsumerGroupOffsets_destroy ( \n    \\FFI\\CData|null $alter_grpoffsets\n ): void\n</code></pre> Parameters alter_grpoffsets <code>\\FFI\\CData|null</code> rd_kafka_AlterConsumerGroupOffsets_t*"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_alterconsumergroupoffsets_destroy_array","title":"rd_kafka_AlterConsumerGroupOffsets_destroy_array()","text":"<pre><code>public static rd_kafka_AlterConsumerGroupOffsets_destroy_array ( \n    \\FFI\\CData|null $alter_grpoffsets, \n    int|null $alter_grpoffset_cnt\n ): void\n</code></pre> Parameters alter_grpoffsets <code>\\FFI\\CData|null</code> rd_kafka_AlterConsumerGroupOffsets_t** alter_grpoffset_cnt <code>int|null</code> size_t"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_alterconsumergroupoffsets_new","title":"rd_kafka_AlterConsumerGroupOffsets_new()","text":"<pre><code>public static rd_kafka_AlterConsumerGroupOffsets_new ( \n    string|null $group_id, \n    \\FFI\\CData|null $partitions\n ): \\FFI\\CData|null\n</code></pre> <p>Create a new AlterConsumerGroupOffsets object. This object is later passed to rd_kafka_AlterConsumerGroupOffsets(). </p> Parameters group_id <code>string|null</code> const char* - Consumer group id. partitions <code>\\FFI\\CData|null</code> const rd_kafka_topic_partition_list_t* - Partitions to alter committed offsets for. Only the topic and partition fields are used. Returns <code>\\FFI\\CData|null</code> rd_kafka_AlterConsumerGroupOffsets_t* - a new allocated AlterConsumerGroupOffsets object. Use rd_kafka_AlterConsumerGroupOffsets_destroy() to free object when done. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aa04df04ed898431c1d85e57e9dfb020e </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_alterconsumergroupoffsets_result_groups","title":"rd_kafka_AlterConsumerGroupOffsets_result_groups()","text":"<pre><code>public static rd_kafka_AlterConsumerGroupOffsets_result_groups ( \n    \\FFI\\CData|null $result, \n    \\FFI\\CData|null $cntp\n ): \\FFI\\CData|null\n</code></pre> <p>Get an array of results from a AlterConsumerGroupOffsets result. </p> <p>The returned groups life-time is the same as the <code>result</code> object.</p> RemarksThe lifetime of the returned memory is the same as the lifetime of the <code>result</code> object.  Parameters result <code>\\FFI\\CData|null</code> const rd_kafka_AlterConsumerGroupOffsets_result_t* - Result to get group results from. cntp <code>\\FFI\\CData|null</code> size_t* - is updated to the number of elements in the array. Returns <code>\\FFI\\CData|null</code> const rd_kafka_group_result_t** <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a7eff1952f24e1d5f2bde678165886731 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_alteruserscramcredentials","title":"rd_kafka_AlterUserScramCredentials()","text":"<pre><code>public static rd_kafka_AlterUserScramCredentials ( \n    \\FFI\\CData|null $rk, \n    \\FFI\\CData|null $alterations, \n    int|null $alteration_cnt, \n    \\FFI\\CData|null $options, \n    \\FFI\\CData|null $rkqu\n ): void\n</code></pre> <p>Alter SASL/SCRAM credentials. This operation is supported by brokers with version 2.7.0 or higher. </p> RemarksFor upsertions to be processed, librdkfka must be build with OpenSSL support. It's needed to calculate the HMAC. Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* - Client instance. alterations <code>\\FFI\\CData|null</code> rd_kafka_UserScramCredentialAlteration_t** - The alterations to be applied. alteration_cnt <code>int|null</code> size_t - Number of elements in <code>alterations</code> array. options <code>\\FFI\\CData|null</code> const rd_kafka_AdminOptions_t* - Optional admin options, or NULL for defaults. rkqu <code>\\FFI\\CData|null</code> rd_kafka_queue_t* - Queue to emit result on. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ab02fa9f8f192f78c1ffb0111b0f5cb2f </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_alteruserscramcredentials_result_response_error","title":"rd_kafka_AlterUserScramCredentials_result_response_error()","text":"<pre><code>public static rd_kafka_AlterUserScramCredentials_result_response_error ( \n    \\FFI\\CData|null $response\n ): \\FFI\\CData|null\n</code></pre> Parameters response <code>\\FFI\\CData|null</code> const rd_kafka_AlterUserScramCredentials_result_response_t* Returns <code>\\FFI\\CData|null</code> const rd_kafka_error_t*"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_alteruserscramcredentials_result_response_user","title":"rd_kafka_AlterUserScramCredentials_result_response_user()","text":"<pre><code>public static rd_kafka_AlterUserScramCredentials_result_response_user ( \n    \\FFI\\CData|null $response\n ): string|null\n</code></pre> Parameters response <code>\\FFI\\CData|null</code> const rd_kafka_AlterUserScramCredentials_result_response_t* Returns <code>string|null</code> const char*"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_alteruserscramcredentials_result_responses","title":"rd_kafka_AlterUserScramCredentials_result_responses()","text":"<pre><code>public static rd_kafka_AlterUserScramCredentials_result_responses ( \n    \\FFI\\CData|null $result, \n    \\FFI\\CData|null $cntp\n ): \\FFI\\CData|null\n</code></pre> <p>Get an array of responses from a AlterUserScramCredentials result. </p> <p>The returned value life-time is the same as the <code>result</code> object.</p> Parameters result <code>\\FFI\\CData|null</code> const rd_kafka_AlterUserScramCredentials_result_t* - Result to get responses from. cntp <code>\\FFI\\CData|null</code> size_t* - is updated to the number of elements in the array. Returns <code>\\FFI\\CData|null</code> const rd_kafka_AlterUserScramCredentials_result_response_t** <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#abf118e72e7bea8ad0cd56a950dcfe2b3 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_configentry_is_default","title":"rd_kafka_ConfigEntry_is_default()","text":"<pre><code>public static rd_kafka_ConfigEntry_is_default ( \n    \\FFI\\CData|null $entry\n ): int|null\n</code></pre> RemarksShall only be used on a DescribeConfigs result, otherwise returns -1.  Parameters entry <code>\\FFI\\CData|null</code> const rd_kafka_ConfigEntry_t* - ) Returns <code>int|null</code> int - 1 if the config property is set to its default value on the broker, else 0. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#abd5a9f49896cff71788bae6cbd60fed9 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_configentry_is_read_only","title":"rd_kafka_ConfigEntry_is_read_only()","text":"<pre><code>public static rd_kafka_ConfigEntry_is_read_only ( \n    \\FFI\\CData|null $entry\n ): int|null\n</code></pre> RemarksShall only be used on a DescribeConfigs result, otherwise returns -1.  Parameters entry <code>\\FFI\\CData|null</code> const rd_kafka_ConfigEntry_t* - ) Returns <code>int|null</code> int - 1 if the config property is read-only on the broker, else 0. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aa7474dc1258cceb041491d2b75e96bcb </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_configentry_is_sensitive","title":"rd_kafka_ConfigEntry_is_sensitive()","text":"<pre><code>public static rd_kafka_ConfigEntry_is_sensitive ( \n    \\FFI\\CData|null $entry\n ): int|null\n</code></pre> RemarksAn application should take care not to include the value of sensitive configuration entries in its output.   Shall only be used on a DescribeConfigs result, otherwise returns -1.  Parameters entry <code>\\FFI\\CData|null</code> const rd_kafka_ConfigEntry_t* - ) Returns <code>int|null</code> int - 1 if the config property contains sensitive information (such as security configuration), else 0. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a7cca5d473790759cb59b5fefdc992a02 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_configentry_is_synonym","title":"rd_kafka_ConfigEntry_is_synonym()","text":"<pre><code>public static rd_kafka_ConfigEntry_is_synonym ( \n    \\FFI\\CData|null $entry\n ): int|null\n</code></pre> Parameters entry <code>\\FFI\\CData|null</code> const rd_kafka_ConfigEntry_t* - ) Returns <code>int|null</code> int - 1 if this entry is a synonym, else 0. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a1a4c6d3323beb8546fb9c0f7d13b2abb </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_configentry_name","title":"rd_kafka_ConfigEntry_name()","text":"<pre><code>public static rd_kafka_ConfigEntry_name ( \n    \\FFI\\CData|null $entry\n ): string|null\n</code></pre> Parameters entry <code>\\FFI\\CData|null</code> const rd_kafka_ConfigEntry_t* - ) Returns <code>string|null</code> const char* - the configuration property name <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ad68d560b00fdbad3a1e994bc423791f6 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_configentry_source","title":"rd_kafka_ConfigEntry_source()","text":"<pre><code>public static rd_kafka_ConfigEntry_source ( \n    \\FFI\\CData|null $entry\n ): int\n</code></pre> Parameters entry <code>\\FFI\\CData|null</code> const rd_kafka_ConfigEntry_t* - ) Returns <code>int</code> rd_kafka_ConfigSource_t - the config source. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aff8550b61387790dad381a6c1129d1b3 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_configentry_synonyms","title":"rd_kafka_ConfigEntry_synonyms()","text":"<pre><code>public static rd_kafka_ConfigEntry_synonyms ( \n    \\FFI\\CData|null $entry, \n    \\FFI\\CData|null $cntp\n ): \\FFI\\CData|null\n</code></pre> RemarksThe lifetime of the returned entry is the same as <code>conf</code> .   Shall only be used on a DescribeConfigs result, otherwise returns NULL.  Parameters entry <code>\\FFI\\CData|null</code> const rd_kafka_ConfigEntry_t* - Entry to get synonyms for. cntp <code>\\FFI\\CData|null</code> size_t* - is updated to the number of elements in the array. Returns <code>\\FFI\\CData|null</code> const rd_kafka_ConfigEntry_t** - the synonym config entry array. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8a9e60a1274f1889a6d20d8ac6ffb948 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_configentry_value","title":"rd_kafka_ConfigEntry_value()","text":"<pre><code>public static rd_kafka_ConfigEntry_value ( \n    \\FFI\\CData|null $entry\n ): string|null\n</code></pre> Parameters entry <code>\\FFI\\CData|null</code> const rd_kafka_ConfigEntry_t* - ) Returns <code>string|null</code> const char* - the configuration value, may be NULL for sensitive or unset properties. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a744ffc08e0ad1a86e62fa4d4da956770 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_configresource_add_incremental_config","title":"rd_kafka_ConfigResource_add_incremental_config()","text":"<pre><code>public static rd_kafka_ConfigResource_add_incremental_config ( \n    \\FFI\\CData|null $config, \n    string|null $name, \n    int $op_type, \n    string|null $value\n ): \\FFI\\CData|null\n</code></pre> <p>Add the value of the configuration entry for a subsequent incremental alter config operation. APPEND and SUBTRACT are possible for list-type configuration entries only. </p> Parameters config <code>\\FFI\\CData|null</code> rd_kafka_ConfigResource_t* - ConfigResource to add config property to. name <code>string|null</code> const char* - Configuration name, depends on resource type. op_type <code>int</code> rd_kafka_AlterConfigOpType_t - Operation type, one of rd_kafka_AlterConfigOpType_t. value <code>string|null</code> const char* - Configuration value, depends on resource type and <code>name</code>. Set to <code>NULL</code>, only with with op_type set to DELETE, to revert configuration value to default. Returns <code>\\FFI\\CData|null</code> rd_kafka_error_t* - NULL on success, or an rd_kafka_error_t * with the corresponding error code and string. Error ownership belongs to the caller. Possible error codes:<ul> <li>RD_KAFKA_RESP_ERR__INVALID_ARG on invalid input. </li> </ul> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ae989f95effcebe295a2a37c15d29b5ed </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_configresource_configs","title":"rd_kafka_ConfigResource_configs()","text":"<pre><code>public static rd_kafka_ConfigResource_configs ( \n    \\FFI\\CData|null $config, \n    \\FFI\\CData|null $cntp\n ): \\FFI\\CData|null\n</code></pre> <p>Get an array of config entries from a ConfigResource object. </p> <p>The returned object life-times are the same as the <code>config</code> object.</p> Parameters config <code>\\FFI\\CData|null</code> const rd_kafka_ConfigResource_t* - ConfigResource to get configs from. cntp <code>\\FFI\\CData|null</code> size_t* - is updated to the number of elements in the array. Returns <code>\\FFI\\CData|null</code> const rd_kafka_ConfigEntry_t** <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a5e95b289deaebe43f7a73874e8428f4d </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_configresource_destroy","title":"rd_kafka_ConfigResource_destroy()","text":"<pre><code>public static rd_kafka_ConfigResource_destroy ( \n    \\FFI\\CData|null $config\n ): void\n</code></pre> Parameters config <code>\\FFI\\CData|null</code> rd_kafka_ConfigResource_t*"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_configresource_destroy_array","title":"rd_kafka_ConfigResource_destroy_array()","text":"<pre><code>public static rd_kafka_ConfigResource_destroy_array ( \n    \\FFI\\CData|null $config, \n    int|null $config_cnt\n ): void\n</code></pre> Parameters config <code>\\FFI\\CData|null</code> rd_kafka_ConfigResource_t** config_cnt <code>int|null</code> size_t"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_configresource_error","title":"rd_kafka_ConfigResource_error()","text":"<pre><code>public static rd_kafka_ConfigResource_error ( \n    \\FFI\\CData|null $config\n ): int\n</code></pre> Parameters config <code>\\FFI\\CData|null</code> const rd_kafka_ConfigResource_t* - ) Returns <code>int</code> rd_kafka_resp_err_t - the error for this resource from an AlterConfigs request <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a6a4c8cf9e53472c30c6b1dd78e3ba560 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_configresource_error_string","title":"rd_kafka_ConfigResource_error_string()","text":"<pre><code>public static rd_kafka_ConfigResource_error_string ( \n    \\FFI\\CData|null $config\n ): string|null\n</code></pre> Parameters config <code>\\FFI\\CData|null</code> const rd_kafka_ConfigResource_t* - ) Returns <code>string|null</code> const char* - the error string for this resource from an AlterConfigs request, or NULL if no error. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a077c4a83e8b7fcf23057dad5a2af812f </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_configresource_name","title":"rd_kafka_ConfigResource_name()","text":"<pre><code>public static rd_kafka_ConfigResource_name ( \n    \\FFI\\CData|null $config\n ): string|null\n</code></pre> Parameters config <code>\\FFI\\CData|null</code> const rd_kafka_ConfigResource_t* - ) Returns <code>string|null</code> const char* - the name for <code>config</code> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#af70880e690cb45ff728a331e7e40baac </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_configresource_new","title":"rd_kafka_ConfigResource_new()","text":"<pre><code>public static rd_kafka_ConfigResource_new ( \n    int $restype, \n    string|null $resname\n ): \\FFI\\CData|null\n</code></pre> <p>Create new ConfigResource object. </p> Parameters restype <code>int</code> rd_kafka_ResourceType_t - The resource type (e.g., RD_KAFKA_RESOURCE_TOPIC) resname <code>string|null</code> const char* - The resource name (e.g., the topic name) Returns <code>\\FFI\\CData|null</code> rd_kafka_ConfigResource_t* - a newly allocated object <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#adedb3f1f695c5e5a90ee03fbdc7f6e4a </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_configresource_set_config","title":"rd_kafka_ConfigResource_set_config()","text":"<pre><code>public static rd_kafka_ConfigResource_set_config ( \n    \\FFI\\CData|null $config, \n    string|null $name, \n    string|null $value\n ): int\n</code></pre> <p>Set configuration name value pair. </p> <p>This will overwrite the current value.</p> Parameters config <code>\\FFI\\CData|null</code> rd_kafka_ConfigResource_t* - ConfigResource to set config property on. name <code>string|null</code> const char* - Configuration name, depends on resource type. value <code>string|null</code> const char* - Configuration value, depends on resource type and <code>name</code>. Set to <code>NULL</code> to revert configuration value to default. Returns <code>int</code> rd_kafka_resp_err_t - RD_KAFKA_RESP_ERR_NO_ERROR if config was added to resource, or RD_KAFKA_RESP_ERR__INVALID_ARG on invalid input. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#afbc1ffd0a5a938e6a9998365903010e5 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_configresource_type","title":"rd_kafka_ConfigResource_type()","text":"<pre><code>public static rd_kafka_ConfigResource_type ( \n    \\FFI\\CData|null $config\n ): int\n</code></pre> Parameters config <code>\\FFI\\CData|null</code> const rd_kafka_ConfigResource_t* - ) Returns <code>int</code> rd_kafka_ResourceType_t - the ResourceType for <code>config</code> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#afb2a6e896b74d2f07246ede8269eb8f6 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_configsource_name","title":"rd_kafka_ConfigSource_name()","text":"<pre><code>public static rd_kafka_ConfigSource_name ( \n    int $confsource\n ): string|null\n</code></pre> Parameters confsource <code>int</code> rd_kafka_ConfigSource_t - ) Returns <code>string|null</code> const char* - a string representation of the <code>confsource</code>. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ad946f1e500a4ce28ed9378d495586076 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_consumergroupdescription_authorized_operations","title":"rd_kafka_ConsumerGroupDescription_authorized_operations()","text":"<pre><code>public static rd_kafka_ConsumerGroupDescription_authorized_operations ( \n    \\FFI\\CData|null $grpdesc, \n    \\FFI\\CData|null $cntp\n ): \\FFI\\CData|null\n</code></pre> <p>Gets the authorized ACL operations for the <code>grpdesc</code> group. </p> RemarksThe lifetime of the returned memory is the same as the lifetime of the <code>grpdesc</code> object.  Parameters grpdesc <code>\\FFI\\CData|null</code> const rd_kafka_ConsumerGroupDescription_t* - The group description. cntp <code>\\FFI\\CData|null</code> size_t* - is updated with authorized ACL operations count. Returns <code>\\FFI\\CData|null</code> const rd_kafka_AclOperation_t* - The group authorized operations. Is NULL if operations were not requested. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a9bfd676eceeb2c768fbf9cb4df2f63c1 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_consumergroupdescription_coordinator","title":"rd_kafka_ConsumerGroupDescription_coordinator()","text":"<pre><code>public static rd_kafka_ConsumerGroupDescription_coordinator ( \n    \\FFI\\CData|null $grpdesc\n ): \\FFI\\CData|null\n</code></pre> <p>Gets the coordinator for the <code>grpdesc</code> group. </p> RemarksThe lifetime of the returned memory is the same as the lifetime of the <code>grpdesc</code> object.  Parameters grpdesc <code>\\FFI\\CData|null</code> const rd_kafka_ConsumerGroupDescription_t* - ) - The group description. Returns <code>\\FFI\\CData|null</code> const rd_kafka_Node_t* - The group coordinator. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a63c98664bac3c9cda112e0bda18a4328 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_consumergroupdescription_error","title":"rd_kafka_ConsumerGroupDescription_error()","text":"<pre><code>public static rd_kafka_ConsumerGroupDescription_error ( \n    \\FFI\\CData|null $grpdesc\n ): \\FFI\\CData|null\n</code></pre> <p>Gets the error for the <code>grpdesc</code> group. </p> RemarksThe lifetime of the returned memory is the same as the lifetime of the <code>grpdesc</code> object.  Parameters grpdesc <code>\\FFI\\CData|null</code> const rd_kafka_ConsumerGroupDescription_t* - ) - The group description. Returns <code>\\FFI\\CData|null</code> const rd_kafka_error_t* - The group description error. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a809554b4c1ba1d54d9daffc72e056d9d </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_consumergroupdescription_group_id","title":"rd_kafka_ConsumerGroupDescription_group_id()","text":"<pre><code>public static rd_kafka_ConsumerGroupDescription_group_id ( \n    \\FFI\\CData|null $grpdesc\n ): string|null\n</code></pre> <p>Gets the group id for the <code>grpdesc</code> group. </p> RemarksThe lifetime of the returned memory is the same as the lifetime of the <code>grpdesc</code> object.  Parameters grpdesc <code>\\FFI\\CData|null</code> const rd_kafka_ConsumerGroupDescription_t* - ) - The group description. Returns <code>string|null</code> const char* - The group id. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a1ac25283379d2cdcd7def61763ea1183 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_consumergroupdescription_is_simple_consumer_group","title":"rd_kafka_ConsumerGroupDescription_is_simple_consumer_group()","text":"<pre><code>public static rd_kafka_ConsumerGroupDescription_is_simple_consumer_group ( \n    \\FFI\\CData|null $grpdesc\n ): int|null\n</code></pre> <p>Is the <code>grpdesc</code> group a simple consumer group. </p> Parameters grpdesc <code>\\FFI\\CData|null</code> const rd_kafka_ConsumerGroupDescription_t* - ) - The group description. Returns <code>int|null</code> int - 1 if the group is a simple consumer group, else 0. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aa142302fb0912b8350254f22d1ebf0cf </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_consumergroupdescription_member","title":"rd_kafka_ConsumerGroupDescription_member()","text":"<pre><code>public static rd_kafka_ConsumerGroupDescription_member ( \n    \\FFI\\CData|null $grpdesc, \n    int|null $idx\n ): \\FFI\\CData|null\n</code></pre> <p>Gets a member of <code>grpdesc</code> group. </p> RemarksThe lifetime of the returned memory is the same as the lifetime of the <code>grpdesc</code> object.  Parameters grpdesc <code>\\FFI\\CData|null</code> const rd_kafka_ConsumerGroupDescription_t* - The group description. idx <code>int|null</code> size_t - The member idx. Returns <code>\\FFI\\CData|null</code> const rd_kafka_MemberDescription_t* - A member at index <code>idx</code>, or NULL if <code>idx</code> is out of range. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a7bdfd0d42f52fb3d8d58aca660ef36b0 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_consumergroupdescription_member_count","title":"rd_kafka_ConsumerGroupDescription_member_count()","text":"<pre><code>public static rd_kafka_ConsumerGroupDescription_member_count ( \n    \\FFI\\CData|null $grpdesc\n ): int|null\n</code></pre> <p>Gets the members count of <code>grpdesc</code> group. </p> Parameters grpdesc <code>\\FFI\\CData|null</code> const rd_kafka_ConsumerGroupDescription_t* - ) - The group description. Returns <code>int|null</code> size_t - The member count. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aa508c92d434adb9027cdec9022b10acf </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_consumergroupdescription_partition_assignor","title":"rd_kafka_ConsumerGroupDescription_partition_assignor()","text":"<pre><code>public static rd_kafka_ConsumerGroupDescription_partition_assignor ( \n    \\FFI\\CData|null $grpdesc\n ): string|null\n</code></pre> <p>Gets the partition assignor for the <code>grpdesc</code> group. </p> RemarksThe lifetime of the returned memory is the same as the lifetime of the <code>grpdesc</code> object.  Parameters grpdesc <code>\\FFI\\CData|null</code> const rd_kafka_ConsumerGroupDescription_t* - ) - The group description. Returns <code>string|null</code> const char* - The partition assignor. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a28ae221b77d6ea9b605b902f92a8022d </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_consumergroupdescription_state","title":"rd_kafka_ConsumerGroupDescription_state()","text":"<pre><code>public static rd_kafka_ConsumerGroupDescription_state ( \n    \\FFI\\CData|null $grpdesc\n ): int\n</code></pre> <p>Gets state for the <code>grpdesc</code> group. </p> Parameters grpdesc <code>\\FFI\\CData|null</code> const rd_kafka_ConsumerGroupDescription_t* - ) - The group description. Returns <code>int</code> rd_kafka_consumer_group_state_t - A group state. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#acc29475b069d8299cbc20b558fb2bb19 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_consumergrouplisting_group_id","title":"rd_kafka_ConsumerGroupListing_group_id()","text":"<pre><code>public static rd_kafka_ConsumerGroupListing_group_id ( \n    \\FFI\\CData|null $grplist\n ): string|null\n</code></pre> <p>Gets the group id for the <code>grplist</code> group. </p> RemarksThe lifetime of the returned memory is the same as the lifetime of the <code>grplist</code> object.  Parameters grplist <code>\\FFI\\CData|null</code> const rd_kafka_ConsumerGroupListing_t* - ) - The group listing. Returns <code>string|null</code> const char* - The group id. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a6527936dcb6222ed4ec34693aacdea24 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_consumergrouplisting_is_simple_consumer_group","title":"rd_kafka_ConsumerGroupListing_is_simple_consumer_group()","text":"<pre><code>public static rd_kafka_ConsumerGroupListing_is_simple_consumer_group ( \n    \\FFI\\CData|null $grplist\n ): int|null\n</code></pre> <p>Is the <code>grplist</code> group a simple consumer group. </p> Parameters grplist <code>\\FFI\\CData|null</code> const rd_kafka_ConsumerGroupListing_t* - ) - The group listing. Returns <code>int|null</code> int - 1 if the group is a simple consumer group, else 0. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ab41e0d25c3a013426d97d0bceb22e91d </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_consumergrouplisting_state","title":"rd_kafka_ConsumerGroupListing_state()","text":"<pre><code>public static rd_kafka_ConsumerGroupListing_state ( \n    \\FFI\\CData|null $grplist\n ): int\n</code></pre> <p>Gets state for the <code>grplist</code> group. </p> Parameters grplist <code>\\FFI\\CData|null</code> const rd_kafka_ConsumerGroupListing_t* - ) - The group listing. Returns <code>int</code> rd_kafka_consumer_group_state_t - A group state. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a050b8eb40679af7564533793b42954e3 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_consumergrouplisting_type","title":"rd_kafka_ConsumerGroupListing_type()","text":"<pre><code>public static rd_kafka_ConsumerGroupListing_type ( \n    \\FFI\\CData|null $grplist\n ): int\n</code></pre> <p>Gets type for the <code>grplist</code> group. </p> Parameters grplist <code>\\FFI\\CData|null</code> const rd_kafka_ConsumerGroupListing_t* - ) - The group listing. Returns <code>int</code> rd_kafka_consumer_group_type_t - A group type. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ad8e4f9a805d98acc521a32ff585fff90 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_createacls","title":"rd_kafka_CreateAcls()","text":"<pre><code>public static rd_kafka_CreateAcls ( \n    \\FFI\\CData|null $rk, \n    \\FFI\\CData|null $new_acls, \n    int|null $new_acls_cnt, \n    \\FFI\\CData|null $options, \n    \\FFI\\CData|null $rkqu\n ): void\n</code></pre> <p>Create acls as specified by the <code>new_acls</code> array of size <code>new_topic_cnt</code> elements. </p> <p>Supported admin options:</p> <ul> <li>rd_kafka_AdminOptions_set_request_timeout() - default socket.timeout.ms</li> </ul> RemarksThe result event type emitted on the supplied queue is of type <code>RD_KAFKA_EVENT_CREATEACLS_RESULT</code> Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* - Client instance. new_acls <code>\\FFI\\CData|null</code> rd_kafka_AclBinding_t** - Array of new acls to create. new_acls_cnt <code>int|null</code> size_t - Number of elements in <code>new_acls</code> array. options <code>\\FFI\\CData|null</code> const rd_kafka_AdminOptions_t* - Optional admin options, or NULL for defaults. rkqu <code>\\FFI\\CData|null</code> rd_kafka_queue_t* - Queue to emit result on. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a028d1a0ff870bcea561d3cf474aa7265 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_createacls_result_acls","title":"rd_kafka_CreateAcls_result_acls()","text":"<pre><code>public static rd_kafka_CreateAcls_result_acls ( \n    \\FFI\\CData|null $result, \n    \\FFI\\CData|null $cntp\n ): \\FFI\\CData|null\n</code></pre> <p>Get an array of acl results from a CreateAcls result. </p> <p>The returned <code>acl</code> result life-time is the same as the <code>result</code> object. </p> Parameters result <code>\\FFI\\CData|null</code> const rd_kafka_CreateAcls_result_t* - CreateAcls result to get acl results from. cntp <code>\\FFI\\CData|null</code> size_t* - is updated to the number of elements in the array. Returns <code>\\FFI\\CData|null</code> const rd_kafka_acl_result_t** <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#abfcceea2bb29d6fd800f11224f0f4238 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_createpartitions","title":"rd_kafka_CreatePartitions()","text":"<pre><code>public static rd_kafka_CreatePartitions ( \n    \\FFI\\CData|null $rk, \n    \\FFI\\CData|null $new_parts, \n    int|null $new_parts_cnt, \n    \\FFI\\CData|null $options, \n    \\FFI\\CData|null $rkqu\n ): void\n</code></pre> <p>Create additional partitions for the given topics, as specified by the <code>new_parts</code> array of size <code>new_parts_cnt</code> elements. </p> <p>Supported admin options:</p> <ul> <li>rd_kafka_AdminOptions_set_validate_only() - default false</li> <li>rd_kafka_AdminOptions_set_operation_timeout() - default 60 seconds</li> <li>rd_kafka_AdminOptions_set_request_timeout() - default socket.timeout.ms</li> </ul> RemarksThe result event type emitted on the supplied queue is of type <code>RD_KAFKA_EVENT_CREATEPARTITIONS_RESULT</code> Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* - Client instance. new_parts <code>\\FFI\\CData|null</code> rd_kafka_NewPartitions_t** - Array of topics for which new partitions are to be created. new_parts_cnt <code>int|null</code> size_t - Number of elements in <code>new_parts</code> array. options <code>\\FFI\\CData|null</code> const rd_kafka_AdminOptions_t* - Optional admin options, or NULL for defaults. rkqu <code>\\FFI\\CData|null</code> rd_kafka_queue_t* - Queue to emit result on. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a1bed8947475ee683033d7988f0b09378 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_createpartitions_result_topics","title":"rd_kafka_CreatePartitions_result_topics()","text":"<pre><code>public static rd_kafka_CreatePartitions_result_topics ( \n    \\FFI\\CData|null $result, \n    \\FFI\\CData|null $cntp\n ): \\FFI\\CData|null\n</code></pre> <p>Get an array of topic results from a CreatePartitions result. </p> <p>The returned <code>topics</code> life-time is the same as the <code>result</code> object.</p> Parameters result <code>\\FFI\\CData|null</code> const rd_kafka_CreatePartitions_result_t* - Result o get topic results from. cntp <code>\\FFI\\CData|null</code> size_t* - is updated to the number of elements in the array. Returns <code>\\FFI\\CData|null</code> const rd_kafka_topic_result_t** <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a2c2b415181b4e4d633d40a63ac01d681 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_createtopics","title":"rd_kafka_CreateTopics()","text":"<pre><code>public static rd_kafka_CreateTopics ( \n    \\FFI\\CData|null $rk, \n    \\FFI\\CData|null $new_topics, \n    int|null $new_topic_cnt, \n    \\FFI\\CData|null $options, \n    \\FFI\\CData|null $rkqu\n ): void\n</code></pre> <p>Create topics in cluster as specified by the <code>new_topics</code> array of size <code>new_topic_cnt</code> elements. </p> <p>Supported admin options:</p> <ul> <li>rd_kafka_AdminOptions_set_validate_only() - default false</li> <li>rd_kafka_AdminOptions_set_operation_timeout() - default 60 seconds</li> <li>rd_kafka_AdminOptions_set_request_timeout() - default socket.timeout.ms</li> </ul> RemarksThe result event type emitted on the supplied queue is of type <code>RD_KAFKA_EVENT_CREATETOPICS_RESULT</code> Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* - Client instance. new_topics <code>\\FFI\\CData|null</code> rd_kafka_NewTopic_t** - Array of new topics to create. new_topic_cnt <code>int|null</code> size_t - Number of elements in <code>new_topics</code> array. options <code>\\FFI\\CData|null</code> const rd_kafka_AdminOptions_t* - Optional admin options, or NULL for defaults. rkqu <code>\\FFI\\CData|null</code> rd_kafka_queue_t* - Queue to emit result on. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a6988b48e1a255fbb2badd6c6e11692f3 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_createtopics_result_topics","title":"rd_kafka_CreateTopics_result_topics()","text":"<pre><code>public static rd_kafka_CreateTopics_result_topics ( \n    \\FFI\\CData|null $result, \n    \\FFI\\CData|null $cntp\n ): \\FFI\\CData|null\n</code></pre> <p>Get an array of topic results from a CreateTopics result. </p> <p>The returned <code>topics</code> life-time is the same as the <code>result</code> object.</p> Parameters result <code>\\FFI\\CData|null</code> const rd_kafka_CreateTopics_result_t* - Result to get topics from. cntp <code>\\FFI\\CData|null</code> size_t* - Updated to the number of elements in the array. Returns <code>\\FFI\\CData|null</code> const rd_kafka_topic_result_t** <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a49451d78d3c7e5bd23367624c03897ea </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_deleteacls","title":"rd_kafka_DeleteAcls()","text":"<pre><code>public static rd_kafka_DeleteAcls ( \n    \\FFI\\CData|null $rk, \n    \\FFI\\CData|null $del_acls, \n    int|null $del_acls_cnt, \n    \\FFI\\CData|null $options, \n    \\FFI\\CData|null $rkqu\n ): void\n</code></pre> <p>Delete acls matching the filteres provided in <code>del_acls</code> array of size <code>del_acls_cnt</code>. </p> <p>Supported admin options:</p> <ul> <li>rd_kafka_AdminOptions_set_operation_timeout() - default 0</li> </ul> RemarksThe result event type emitted on the supplied queue is of type <code>RD_KAFKA_EVENT_DELETEACLS_RESULT</code> Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* - Client instance. del_acls <code>\\FFI\\CData|null</code> rd_kafka_AclBindingFilter_t** - Filters for the acls to delete. del_acls_cnt <code>int|null</code> size_t - Number of elements in <code>del_acls</code> array. options <code>\\FFI\\CData|null</code> const rd_kafka_AdminOptions_t* - Optional admin options, or NULL for defaults. rkqu <code>\\FFI\\CData|null</code> rd_kafka_queue_t* - Queue to emit result on. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a6118e40b9abfff686a61dc5e093468ef </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_deleteacls_result_response_error","title":"rd_kafka_DeleteAcls_result_response_error()","text":"<pre><code>public static rd_kafka_DeleteAcls_result_response_error ( \n    \\FFI\\CData|null $result_response\n ): \\FFI\\CData|null\n</code></pre> Parameters result_response <code>\\FFI\\CData|null</code> const rd_kafka_DeleteAcls_result_response_t* - ) Returns <code>\\FFI\\CData|null</code> const rd_kafka_error_t* - the error object for the given DeleteAcls result response, or NULL on success. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a519cf227ea6f1cadd19a767d430209c1 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_deleteacls_result_response_matching_acls","title":"rd_kafka_DeleteAcls_result_response_matching_acls()","text":"<pre><code>public static rd_kafka_DeleteAcls_result_response_matching_acls ( \n    \\FFI\\CData|null $result_response, \n    \\FFI\\CData|null $matching_acls_cntp\n ): \\FFI\\CData|null\n</code></pre> Remarkslifetime of the returned acl bindings is the same as the <code>result_response</code>.  Parameters result_response <code>\\FFI\\CData|null</code> const rd_kafka_DeleteAcls_result_response_t* matching_acls_cntp <code>\\FFI\\CData|null</code> size_t* Returns <code>\\FFI\\CData|null</code> const rd_kafka_AclBinding_t** - the matching acls array for the given DeleteAcls result response. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a157a9b9ab67703b3e531a67f7a8da7de </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_deleteacls_result_responses","title":"rd_kafka_DeleteAcls_result_responses()","text":"<pre><code>public static rd_kafka_DeleteAcls_result_responses ( \n    \\FFI\\CData|null $result, \n    \\FFI\\CData|null $cntp\n ): \\FFI\\CData|null\n</code></pre> <p>Get an array of DeleteAcls result responses from a DeleteAcls result. </p> <p>The returned <code>responses</code> life-time is the same as the <code>result</code> object. </p> Parameters result <code>\\FFI\\CData|null</code> const rd_kafka_DeleteAcls_result_t* - DeleteAcls result to get responses from. cntp <code>\\FFI\\CData|null</code> size_t* - is updated to the number of elements in the array. Returns <code>\\FFI\\CData|null</code> const rd_kafka_DeleteAcls_result_response_t** <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#af22ab28bfc36ac13ee043e95b0741dc0 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_deleteconsumergroupoffsets","title":"rd_kafka_DeleteConsumerGroupOffsets()","text":"<pre><code>public static rd_kafka_DeleteConsumerGroupOffsets ( \n    \\FFI\\CData|null $rk, \n    \\FFI\\CData|null $del_grpoffsets, \n    int|null $del_grpoffsets_cnt, \n    \\FFI\\CData|null $options, \n    \\FFI\\CData|null $rkqu\n ): void\n</code></pre> <p>Delete committed offsets for a set of partitions in a consumer group. This will succeed at the partition level only if the group is not actively subscribed to the corresponding topic. </p> RemarksThe result event type emitted on the supplied queue is of type <code>RD_KAFKA_EVENT_DELETECONSUMERGROUPOFFSETS_RESULT</code>  The current implementation only supports one group per invocation.  Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* - Client instance. del_grpoffsets <code>\\FFI\\CData|null</code> rd_kafka_DeleteConsumerGroupOffsets_t** - Array of group committed offsets to delete. MUST only be one single element. del_grpoffsets_cnt <code>int|null</code> size_t - Number of elements in <code>del_grpoffsets</code> array. MUST always be 1. options <code>\\FFI\\CData|null</code> const rd_kafka_AdminOptions_t* - Optional admin options, or NULL for defaults. rkqu <code>\\FFI\\CData|null</code> rd_kafka_queue_t* - Queue to emit result on. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#afa8e8de419157cf97a083b9355d3385f </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_deleteconsumergroupoffsets_destroy","title":"rd_kafka_DeleteConsumerGroupOffsets_destroy()","text":"<pre><code>public static rd_kafka_DeleteConsumerGroupOffsets_destroy ( \n    \\FFI\\CData|null $del_grpoffsets\n ): void\n</code></pre> Parameters del_grpoffsets <code>\\FFI\\CData|null</code> rd_kafka_DeleteConsumerGroupOffsets_t*"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_deleteconsumergroupoffsets_destroy_array","title":"rd_kafka_DeleteConsumerGroupOffsets_destroy_array()","text":"<pre><code>public static rd_kafka_DeleteConsumerGroupOffsets_destroy_array ( \n    \\FFI\\CData|null $del_grpoffsets, \n    int|null $del_grpoffset_cnt\n ): void\n</code></pre> Parameters del_grpoffsets <code>\\FFI\\CData|null</code> rd_kafka_DeleteConsumerGroupOffsets_t** del_grpoffset_cnt <code>int|null</code> size_t"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_deleteconsumergroupoffsets_new","title":"rd_kafka_DeleteConsumerGroupOffsets_new()","text":"<pre><code>public static rd_kafka_DeleteConsumerGroupOffsets_new ( \n    string|null $group, \n    \\FFI\\CData|null $partitions\n ): \\FFI\\CData|null\n</code></pre> <p>Create a new DeleteConsumerGroupOffsets object. This object is later passed to rd_kafka_DeleteConsumerGroupOffsets(). </p> Parameters group <code>string|null</code> const char* - Consumer group id. partitions <code>\\FFI\\CData|null</code> const rd_kafka_topic_partition_list_t* - Partitions to delete committed offsets for. Only the topic and partition fields are used. Returns <code>\\FFI\\CData|null</code> rd_kafka_DeleteConsumerGroupOffsets_t* - a new allocated DeleteConsumerGroupOffsets object. Use rd_kafka_DeleteConsumerGroupOffsets_destroy() to free object when done. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8bb6df9dd6ce4e86dea385f90151d81f </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_deleteconsumergroupoffsets_result_groups","title":"rd_kafka_DeleteConsumerGroupOffsets_result_groups()","text":"<pre><code>public static rd_kafka_DeleteConsumerGroupOffsets_result_groups ( \n    \\FFI\\CData|null $result, \n    \\FFI\\CData|null $cntp\n ): \\FFI\\CData|null\n</code></pre> <p>Get an array of results from a DeleteConsumerGroupOffsets result. </p> <p>The returned groups life-time is the same as the <code>result</code> object.</p> Parameters result <code>\\FFI\\CData|null</code> const rd_kafka_DeleteConsumerGroupOffsets_result_t* - Result to get group results from. cntp <code>\\FFI\\CData|null</code> size_t* - is updated to the number of elements in the array. Returns <code>\\FFI\\CData|null</code> const rd_kafka_group_result_t** <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a014654eaec7601933e6ec5d5613ef4b0 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_deletegroup_destroy","title":"rd_kafka_DeleteGroup_destroy()","text":"<pre><code>public static rd_kafka_DeleteGroup_destroy ( \n    \\FFI\\CData|null $del_group\n ): void\n</code></pre> Parameters del_group <code>\\FFI\\CData|null</code> rd_kafka_DeleteGroup_t*"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_deletegroup_destroy_array","title":"rd_kafka_DeleteGroup_destroy_array()","text":"<pre><code>public static rd_kafka_DeleteGroup_destroy_array ( \n    \\FFI\\CData|null $del_groups, \n    int|null $del_group_cnt\n ): void\n</code></pre> Parameters del_groups <code>\\FFI\\CData|null</code> rd_kafka_DeleteGroup_t** del_group_cnt <code>int|null</code> size_t"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_deletegroup_new","title":"rd_kafka_DeleteGroup_new()","text":"<pre><code>public static rd_kafka_DeleteGroup_new ( \n    string|null $group\n ): \\FFI\\CData|null\n</code></pre> <p>Create a new DeleteGroup object. This object is later passed to rd_kafka_DeleteGroups(). </p> Parameters group <code>string|null</code> const char* - ) - Name of group to delete. Returns <code>\\FFI\\CData|null</code> rd_kafka_DeleteGroup_t* - a new allocated DeleteGroup object. Use rd_kafka_DeleteGroup_destroy() to free object when done. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a6c3bb6e2b05f40bed55ffdfe2b4daa59 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_deletegroups","title":"rd_kafka_DeleteGroups()","text":"<pre><code>public static rd_kafka_DeleteGroups ( \n    \\FFI\\CData|null $rk, \n    \\FFI\\CData|null $del_groups, \n    int|null $del_group_cnt, \n    \\FFI\\CData|null $options, \n    \\FFI\\CData|null $rkqu\n ): void\n</code></pre> <p>Delete groups from cluster as specified by the <code>del_groups</code> array of size <code>del_group_cnt</code> elements. </p> RemarksThe result event type emitted on the supplied queue is of type <code>RD_KAFKA_EVENT_DELETEGROUPS_RESULT</code>  This function in called deleteConsumerGroups in the Java client.  Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* - Client instance. del_groups <code>\\FFI\\CData|null</code> rd_kafka_DeleteGroup_t** - Array of groups to delete. del_group_cnt <code>int|null</code> size_t - Number of elements in <code>del_groups</code> array. options <code>\\FFI\\CData|null</code> const rd_kafka_AdminOptions_t* - Optional admin options, or NULL for defaults. rkqu <code>\\FFI\\CData|null</code> rd_kafka_queue_t* - Queue to emit result on. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#af929e4f20999b43d7bd3724502c1b27a </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_deletegroups_result_groups","title":"rd_kafka_DeleteGroups_result_groups()","text":"<pre><code>public static rd_kafka_DeleteGroups_result_groups ( \n    \\FFI\\CData|null $result, \n    \\FFI\\CData|null $cntp\n ): \\FFI\\CData|null\n</code></pre> <p>Get an array of group results from a DeleteGroups result. </p> <p>The returned groups life-time is the same as the <code>result</code> object.</p> Parameters result <code>\\FFI\\CData|null</code> const rd_kafka_DeleteGroups_result_t* - Result to get group results from. cntp <code>\\FFI\\CData|null</code> size_t* - is updated to the number of elements in the array. Returns <code>\\FFI\\CData|null</code> const rd_kafka_group_result_t** <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a20097b0ced17760c9aa624552dbf47e7 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_deleterecords","title":"rd_kafka_DeleteRecords()","text":"<pre><code>public static rd_kafka_DeleteRecords ( \n    \\FFI\\CData|null $rk, \n    \\FFI\\CData|null $del_records, \n    int|null $del_record_cnt, \n    \\FFI\\CData|null $options, \n    \\FFI\\CData|null $rkqu\n ): void\n</code></pre> <p>Delete records (messages) in topic partitions older than the offsets provided. </p> <p>Supported admin options:</p> <ul> <li>rd_kafka_AdminOptions_set_operation_timeout() - default 60 seconds. Controls how long the brokers will wait for records to be deleted.</li> <li>rd_kafka_AdminOptions_set_request_timeout() - default socket.timeout.ms. Controls how long <code>rdkafka</code> will wait for the request to complete.</li> </ul> RemarksThe result event type emitted on the supplied queue is of type <code>RD_KAFKA_EVENT_DELETERECORDS_RESULT</code> Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* - Client instance. del_records <code>\\FFI\\CData|null</code> rd_kafka_DeleteRecords_t** - The offsets to delete (up to). Currently only one DeleteRecords_t (but containing multiple offsets) is supported. del_record_cnt <code>int|null</code> size_t - The number of elements in del_records, must be 1. options <code>\\FFI\\CData|null</code> const rd_kafka_AdminOptions_t* - Optional admin options, or NULL for defaults. rkqu <code>\\FFI\\CData|null</code> rd_kafka_queue_t* - Queue to emit result on. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aad06345d1b4cd13e56d7253b889b2349 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_deleterecords_destroy","title":"rd_kafka_DeleteRecords_destroy()","text":"<pre><code>public static rd_kafka_DeleteRecords_destroy ( \n    \\FFI\\CData|null $del_records\n ): void\n</code></pre> Parameters del_records <code>\\FFI\\CData|null</code> rd_kafka_DeleteRecords_t*"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_deleterecords_destroy_array","title":"rd_kafka_DeleteRecords_destroy_array()","text":"<pre><code>public static rd_kafka_DeleteRecords_destroy_array ( \n    \\FFI\\CData|null $del_records, \n    int|null $del_record_cnt\n ): void\n</code></pre> Parameters del_records <code>\\FFI\\CData|null</code> rd_kafka_DeleteRecords_t** del_record_cnt <code>int|null</code> size_t"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_deleterecords_new","title":"rd_kafka_DeleteRecords_new()","text":"<pre><code>public static rd_kafka_DeleteRecords_new ( \n    \\FFI\\CData|null $before_offsets\n ): \\FFI\\CData|null\n</code></pre> <p>Create a new DeleteRecords object. This object is later passed to rd_kafka_DeleteRecords(). </p> <p><code>before_offsets</code> must contain <code>topic</code>, <code>partition</code>, and <code>offset</code> is the offset before which the messages will be deleted (exclusive). Set <code>offset</code> to RD_KAFKA_OFFSET_END (high-watermark) in order to delete all data in the partition.</p> Parameters before_offsets <code>\\FFI\\CData|null</code> const rd_kafka_topic_partition_list_t* - ) - For each partition delete all messages up to but not including the specified offset. Returns <code>\\FFI\\CData|null</code> rd_kafka_DeleteRecords_t* - a new allocated DeleteRecords object. Use rd_kafka_DeleteRecords_destroy() to free object when done. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#adbbe46dc5bfe86a3ead89c130b13d9f8 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_deleterecords_result_offsets","title":"rd_kafka_DeleteRecords_result_offsets()","text":"<pre><code>public static rd_kafka_DeleteRecords_result_offsets ( \n    \\FFI\\CData|null $result\n ): \\FFI\\CData|null\n</code></pre> <p>Get a list of topic and partition results from a DeleteRecords result. The returned objects will contain <code>topic</code>, <code>partition</code>, <code>offset</code> and <code>err</code>. <code>offset</code> will be set to the post-deletion low-watermark (smallest available offset of all live replicas). <code>err</code> will be set per-partition if deletion failed. </p> <p>The returned object's life-time is the same as the <code>result</code> object. </p> Parameters result <code>\\FFI\\CData|null</code> const rd_kafka_DeleteRecords_result_t* - ) Returns <code>\\FFI\\CData|null</code> const rd_kafka_topic_partition_list_t* <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ac894a0e005db1fa671c1802ba3563b69 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_deletetopic_destroy","title":"rd_kafka_DeleteTopic_destroy()","text":"<pre><code>public static rd_kafka_DeleteTopic_destroy ( \n    \\FFI\\CData|null $del_topic\n ): void\n</code></pre> Parameters del_topic <code>\\FFI\\CData|null</code> rd_kafka_DeleteTopic_t*"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_deletetopic_destroy_array","title":"rd_kafka_DeleteTopic_destroy_array()","text":"<pre><code>public static rd_kafka_DeleteTopic_destroy_array ( \n    \\FFI\\CData|null $del_topics, \n    int|null $del_topic_cnt\n ): void\n</code></pre> Parameters del_topics <code>\\FFI\\CData|null</code> rd_kafka_DeleteTopic_t** del_topic_cnt <code>int|null</code> size_t"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_deletetopic_new","title":"rd_kafka_DeleteTopic_new()","text":"<pre><code>public static rd_kafka_DeleteTopic_new ( \n    string|null $topic\n ): \\FFI\\CData|null\n</code></pre> <p>Create a new DeleteTopic object. This object is later passed to rd_kafka_DeleteTopics(). </p> Parameters topic <code>string|null</code> const char* - ) - Topic name to delete. Returns <code>\\FFI\\CData|null</code> rd_kafka_DeleteTopic_t* - a new allocated DeleteTopic object. Use rd_kafka_DeleteTopic_destroy() to free object when done. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a1e0a19934a857ca8b59ddbe8dbe24b0e </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_deletetopics","title":"rd_kafka_DeleteTopics()","text":"<pre><code>public static rd_kafka_DeleteTopics ( \n    \\FFI\\CData|null $rk, \n    \\FFI\\CData|null $del_topics, \n    int|null $del_topic_cnt, \n    \\FFI\\CData|null $options, \n    \\FFI\\CData|null $rkqu\n ): void\n</code></pre> <p>Delete topics from cluster as specified by the <code>topics</code> array of size <code>topic_cnt</code> elements. </p> RemarksThe result event type emitted on the supplied queue is of type <code>RD_KAFKA_EVENT_DELETETOPICS_RESULT</code> Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* - Client instance. del_topics <code>\\FFI\\CData|null</code> rd_kafka_DeleteTopic_t** - Array of topics to delete. del_topic_cnt <code>int|null</code> size_t - Number of elements in <code>topics</code> array. options <code>\\FFI\\CData|null</code> const rd_kafka_AdminOptions_t* - Optional admin options, or NULL for defaults. rkqu <code>\\FFI\\CData|null</code> rd_kafka_queue_t* - Queue to emit result on. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ae6f7fd92bb32f14c30bbcd22cbda2b4a </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_deletetopics_result_topics","title":"rd_kafka_DeleteTopics_result_topics()","text":"<pre><code>public static rd_kafka_DeleteTopics_result_topics ( \n    \\FFI\\CData|null $result, \n    \\FFI\\CData|null $cntp\n ): \\FFI\\CData|null\n</code></pre> <p>Get an array of topic results from a DeleteTopics result. </p> <p>The returned <code>topics</code> life-time is the same as the <code>result</code> object.</p> Parameters result <code>\\FFI\\CData|null</code> const rd_kafka_DeleteTopics_result_t* - Result to get topic results from. cntp <code>\\FFI\\CData|null</code> size_t* - is updated to the number of elements in the array. Returns <code>\\FFI\\CData|null</code> const rd_kafka_topic_result_t** <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aef97d0923f7e8cec4fbec9866d32614a </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_describeacls","title":"rd_kafka_DescribeAcls()","text":"<pre><code>public static rd_kafka_DescribeAcls ( \n    \\FFI\\CData|null $rk, \n    \\FFI\\CData|null $acl_filter, \n    \\FFI\\CData|null $options, \n    \\FFI\\CData|null $rkqu\n ): void\n</code></pre> <p>Describe acls matching the filter provided in <code>acl_filter</code>. </p> <p>Supported admin options:</p> <ul> <li>rd_kafka_AdminOptions_set_operation_timeout() - default 0</li> </ul> RemarksThe result event type emitted on the supplied queue is of type <code>RD_KAFKA_EVENT_DESCRIBEACLS_RESULT</code> Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* - Client instance. acl_filter <code>\\FFI\\CData|null</code> rd_kafka_AclBindingFilter_t* - Filter for the returned acls. options <code>\\FFI\\CData|null</code> const rd_kafka_AdminOptions_t* - Optional admin options, or NULL for defaults. rkqu <code>\\FFI\\CData|null</code> rd_kafka_queue_t* - Queue to emit result on. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a7dcf8b0d43014b7412d9a5059006194b </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_describeacls_result_acls","title":"rd_kafka_DescribeAcls_result_acls()","text":"<pre><code>public static rd_kafka_DescribeAcls_result_acls ( \n    \\FFI\\CData|null $result, \n    \\FFI\\CData|null $cntp\n ): \\FFI\\CData|null\n</code></pre> <p>Get an array of resource results from a DescribeAcls result. </p> <p>DescribeAcls - describe access control lists.</p> <p>The returned <code>resources</code> life-time is the same as the <code>result</code> object. </p> Parameters result <code>\\FFI\\CData|null</code> const rd_kafka_DescribeAcls_result_t* - DescribeAcls result to get acls from. cntp <code>\\FFI\\CData|null</code> size_t* - is updated to the number of elements in the array. Returns <code>\\FFI\\CData|null</code> const rd_kafka_AclBinding_t** <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aa5d797f84a5dcf3c069636c1dc408934 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_describecluster","title":"rd_kafka_DescribeCluster()","text":"<pre><code>public static rd_kafka_DescribeCluster ( \n    \\FFI\\CData|null $rk, \n    \\FFI\\CData|null $options, \n    \\FFI\\CData|null $rkqu\n ): void\n</code></pre> <p>Describes the cluster. </p> RemarksThe result event type emitted on the supplied queue is of type <code>RD_KAFKA_EVENT_DESCRIBECLUSTER_RESULT</code> Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* - Client instance. options <code>\\FFI\\CData|null</code> const rd_kafka_AdminOptions_t* - Optional admin options, or NULL for defaults. Valid options:<ul> <li>include_authorized_operations </li> </ul> rkqu <code>\\FFI\\CData|null</code> rd_kafka_queue_t* - Queue to emit result on. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aeb726c502cc8ae2bf8688c4b6222b928 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_describecluster_result_authorized_operations","title":"rd_kafka_DescribeCluster_result_authorized_operations()","text":"<pre><code>public static rd_kafka_DescribeCluster_result_authorized_operations ( \n    \\FFI\\CData|null $result, \n    \\FFI\\CData|null $cntp\n ): \\FFI\\CData|null\n</code></pre> <p>Gets the authorized ACL operations for the <code>result</code> cluster. </p> RemarksThe lifetime of the returned memory is the same as the lifetime of the <code>result</code> object.  Parameters result <code>\\FFI\\CData|null</code> const rd_kafka_DescribeCluster_result_t* - The result of DescribeCluster. cntp <code>\\FFI\\CData|null</code> size_t* - is updated with authorized ACL operations count. Returns <code>\\FFI\\CData|null</code> const rd_kafka_AclOperation_t* - The cluster authorized operations. Is NULL if operations were not requested. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aa0f78bad0da719956778d43fedc42454 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_describecluster_result_cluster_id","title":"rd_kafka_DescribeCluster_result_cluster_id()","text":"<pre><code>public static rd_kafka_DescribeCluster_result_cluster_id ( \n    \\FFI\\CData|null $result\n ): string|null\n</code></pre> <p>Gets the cluster id for the <code>result</code> cluster. </p> RemarksThe lifetime of the returned memory is the same as the lifetime of the <code>result</code> object.  Parameters result <code>\\FFI\\CData|null</code> const rd_kafka_DescribeCluster_result_t* - ) - The result of DescribeCluster. Returns <code>string|null</code> const char* - The cluster id. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a70813d17f662b9b4524f42078a8ddd0f </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_describecluster_result_controller","title":"rd_kafka_DescribeCluster_result_controller()","text":"<pre><code>public static rd_kafka_DescribeCluster_result_controller ( \n    \\FFI\\CData|null $result\n ): \\FFI\\CData|null\n</code></pre> <p>Gets the current controller for the <code>result</code> cluster. </p> Parameters result <code>\\FFI\\CData|null</code> const rd_kafka_DescribeCluster_result_t* - ) - The result of DescribeCluster. Returns <code>\\FFI\\CData|null</code> const rd_kafka_Node_t* - The cluster current controller. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a268e83f5e58ea81ea87c2a9fb8a28af1 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_describecluster_result_nodes","title":"rd_kafka_DescribeCluster_result_nodes()","text":"<pre><code>public static rd_kafka_DescribeCluster_result_nodes ( \n    \\FFI\\CData|null $result, \n    \\FFI\\CData|null $cntp\n ): \\FFI\\CData|null\n</code></pre> <p>Gets the broker nodes for the <code>result</code> cluster. </p> RemarksThe lifetime of the returned memory is the same as the lifetime of the <code>result</code> object.  Parameters result <code>\\FFI\\CData|null</code> const rd_kafka_DescribeCluster_result_t* - The result of DescribeCluster. cntp <code>\\FFI\\CData|null</code> size_t* - is updated with the count of broker nodes. Returns <code>\\FFI\\CData|null</code> const rd_kafka_Node_t** - An array of broker nodes. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#add39eff7e0f0cde3614b661594310e28 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_describeconfigs","title":"rd_kafka_DescribeConfigs()","text":"<pre><code>public static rd_kafka_DescribeConfigs ( \n    \\FFI\\CData|null $rk, \n    \\FFI\\CData|null $configs, \n    int|null $config_cnt, \n    \\FFI\\CData|null $options, \n    \\FFI\\CData|null $rkqu\n ): void\n</code></pre> <p>Get configuration for the specified resources in <code>configs</code>. </p> <p>The returned configuration includes default values and the rd_kafka_ConfigEntry_is_default() or rd_kafka_ConfigEntry_source() methods may be used to distinguish them from user supplied values.</p> <p>The value of config entries where rd_kafka_ConfigEntry_is_sensitive() is true will always be NULL to avoid disclosing sensitive information, such as security settings.</p> <p>Configuration entries where rd_kafka_ConfigEntry_is_read_only() is true can't be updated (with rd_kafka_AlterConfigs()).</p> <p>Synonym configuration entries are returned if the broker supports it (broker version &gt;= 1.1.0). See rd_kafka_ConfigEntry_synonyms().</p> RemarksRequires broker version &gt;=0.11.0.0  Multiple resources and resource types may be requested, but at most one resource of type <code>RD_KAFKA_RESOURCE_BROKER</code> is allowed per call since these resource requests must be sent to the broker specified in the resource.  Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* configs <code>\\FFI\\CData|null</code> rd_kafka_ConfigResource_t** config_cnt <code>int|null</code> size_t options <code>\\FFI\\CData|null</code> const rd_kafka_AdminOptions_t* rkqu <code>\\FFI\\CData|null</code> rd_kafka_queue_t* <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ac6c5d7be2cd16c6875ddc946c9918df2 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_describeconfigs_result_resources","title":"rd_kafka_DescribeConfigs_result_resources()","text":"<pre><code>public static rd_kafka_DescribeConfigs_result_resources ( \n    \\FFI\\CData|null $result, \n    \\FFI\\CData|null $cntp\n ): \\FFI\\CData|null\n</code></pre> <p>Get an array of resource results from a DescribeConfigs result. </p> <p>The returned <code>resources</code> life-time is the same as the <code>result</code> object.</p> Parameters result <code>\\FFI\\CData|null</code> const rd_kafka_DescribeConfigs_result_t* - Result object to get resource results from. cntp <code>\\FFI\\CData|null</code> size_t* - is updated to the number of elements in the array. Returns <code>\\FFI\\CData|null</code> const rd_kafka_ConfigResource_t** <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a1f8eb6562e32b2638d75ca22161ab185 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_describeconsumergroups","title":"rd_kafka_DescribeConsumerGroups()","text":"<pre><code>public static rd_kafka_DescribeConsumerGroups ( \n    \\FFI\\CData|null $rk, \n    \\FFI\\CData|null $groups, \n    int|null $groups_cnt, \n    \\FFI\\CData|null $options, \n    \\FFI\\CData|null $rkqu\n ): void\n</code></pre> <p>Describe groups from cluster as specified by the <code>groups</code> array of size <code>groups_cnt</code> elements. </p> RemarksThe result event type emitted on the supplied queue is of type <code>RD_KAFKA_EVENT_DESCRIBECONSUMERGROUPS_RESULT</code> Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* - Client instance. groups <code>\\FFI\\CData|null</code> const char** - Array of groups to describe. groups_cnt <code>int|null</code> size_t - Number of elements in <code>groups</code> array. options <code>\\FFI\\CData|null</code> const rd_kafka_AdminOptions_t* - Optional admin options, or NULL for defaults. Valid options:<ul> <li>include_authorized_operations </li> </ul> rkqu <code>\\FFI\\CData|null</code> rd_kafka_queue_t* - Queue to emit result on. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a3c473e95da2231aaaeca990a6ff45ad1 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_describeconsumergroups_result_groups","title":"rd_kafka_DescribeConsumerGroups_result_groups()","text":"<pre><code>public static rd_kafka_DescribeConsumerGroups_result_groups ( \n    \\FFI\\CData|null $result, \n    \\FFI\\CData|null $cntp\n ): \\FFI\\CData|null\n</code></pre> <p>Get an array of group results from a DescribeConsumerGroups result. </p> <p>The returned groups life-time is the same as the <code>result</code> object.</p> RemarksThe lifetime of the returned memory is the same as the lifetime of the <code>result</code> object.  Parameters result <code>\\FFI\\CData|null</code> const rd_kafka_DescribeConsumerGroups_result_t* - Result to get group results from. cntp <code>\\FFI\\CData|null</code> size_t* - is updated to the number of elements in the array. Returns <code>\\FFI\\CData|null</code> const rd_kafka_ConsumerGroupDescription_t** <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a7105546ec6af24791fbb0da90f0d2384 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_describetopics","title":"rd_kafka_DescribeTopics()","text":"<pre><code>public static rd_kafka_DescribeTopics ( \n    \\FFI\\CData|null $rk, \n    \\FFI\\CData|null $topics, \n    \\FFI\\CData|null $options, \n    \\FFI\\CData|null $rkqu\n ): void\n</code></pre> <p>Describe topics as specified by the <code>topics</code> array of size <code>topics_cnt</code> elements. </p> RemarksThe result event type emitted on the supplied queue is of type <code>RD_KAFKA_EVENT_DESCRIBETOPICS_RESULT</code> Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* - Client instance. topics <code>\\FFI\\CData|null</code> const rd_kafka_TopicCollection_t* - Collection of topics to describe. options <code>\\FFI\\CData|null</code> const rd_kafka_AdminOptions_t* - Optional admin options, or NULL for defaults. Valid options:<ul> <li>include_authorized_operations </li> </ul> rkqu <code>\\FFI\\CData|null</code> rd_kafka_queue_t* - Queue to emit result on. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a71e57916fc3936132289c81974c54c71 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_describetopics_result_topics","title":"rd_kafka_DescribeTopics_result_topics()","text":"<pre><code>public static rd_kafka_DescribeTopics_result_topics ( \n    \\FFI\\CData|null $result, \n    \\FFI\\CData|null $cntp\n ): \\FFI\\CData|null\n</code></pre> <p>Get an array of topic results from a DescribeTopics result. </p> RemarksThe lifetime of the returned memory is the same as the lifetime of the <code>result</code> object.  Parameters result <code>\\FFI\\CData|null</code> const rd_kafka_DescribeTopics_result_t* - Result to get topics results from. cntp <code>\\FFI\\CData|null</code> size_t* - is updated to the number of elements in the array. Returns <code>\\FFI\\CData|null</code> const rd_kafka_TopicDescription_t** <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a88c8a277f6001c95bf5d04fde169c4e2 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_describeuserscramcredentials","title":"rd_kafka_DescribeUserScramCredentials()","text":"<pre><code>public static rd_kafka_DescribeUserScramCredentials ( \n    \\FFI\\CData|null $rk, \n    \\FFI\\CData|null $users, \n    int|null $user_cnt, \n    \\FFI\\CData|null $options, \n    \\FFI\\CData|null $rkqu\n ): void\n</code></pre> <p>Describe SASL/SCRAM credentials. This operation is supported by brokers with version 2.7.0 or higher. </p> Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* - Client instance. users <code>\\FFI\\CData|null</code> const char** - The users for which credentials are to be described. All users\u2019 credentials are described if NULL. user_cnt <code>int|null</code> size_t - Number of elements in <code>users</code> array. options <code>\\FFI\\CData|null</code> const rd_kafka_AdminOptions_t* - Optional admin options, or NULL for defaults. rkqu <code>\\FFI\\CData|null</code> rd_kafka_queue_t* - Queue to emit result on. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ac9d2f72dd1dddce0c7d24a4e413b3cf5 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_describeuserscramcredentials_result_descriptions","title":"rd_kafka_DescribeUserScramCredentials_result_descriptions()","text":"<pre><code>public static rd_kafka_DescribeUserScramCredentials_result_descriptions ( \n    \\FFI\\CData|null $result, \n    \\FFI\\CData|null $cntp\n ): \\FFI\\CData|null\n</code></pre> <p>Get an array of descriptions from a DescribeUserScramCredentials result. </p> <p>The returned value life-time is the same as the <code>result</code> object.</p> Parameters result <code>\\FFI\\CData|null</code> const rd_kafka_DescribeUserScramCredentials_result_t* - Result to get descriptions from. cntp <code>\\FFI\\CData|null</code> size_t* - is updated to the number of elements in the array. Returns <code>\\FFI\\CData|null</code> const rd_kafka_UserScramCredentialsDescription_t** <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a1d6db38eb4f640a20a5806da2b12bc47 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_electleaders","title":"rd_kafka_ElectLeaders()","text":"<pre><code>public static rd_kafka_ElectLeaders ( \n    \\FFI\\CData|null $rk, \n    \\FFI\\CData|null $elect_leaders, \n    \\FFI\\CData|null $options, \n    \\FFI\\CData|null $rkqu\n ): void\n</code></pre> <p>Elect Leaders for the provided Topic Partitions according to the specified election type. </p> <p>Supported admin options:</p> <ul> <li>rd_kafka_AdminOptions_set_operation_timeout() - default 60 seconds. Controls how long the brokers will wait for records to be deleted.</li> <li>rd_kafka_AdminOptions_set_request_timeout() - default socket.timeout.ms. Controls how long <code>rdkafka</code> will wait for the request to complete.</li> </ul> RemarksThe result event type emitted on the supplied queue is of type <code>RD_KAFKA_EVENT_ELECTLEADERS_RESULT</code>  If we are passing partitions as NULL, then the broker will attempt leader election for all partitions, but the results will contain only partitions for which there was an election or resulted in an error.  Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* - Client instance. elect_leaders <code>\\FFI\\CData|null</code> rd_kafka_ElectLeaders_t* - The elect leaders request containing election type and partitions information. options <code>\\FFI\\CData|null</code> const rd_kafka_AdminOptions_t* - Optional admin options, or NULL for defaults. rkqu <code>\\FFI\\CData|null</code> rd_kafka_queue_t* - Queue to emit result on. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ac96e1dcd76d254a5b0c37f8ed5a62b61 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_electleaders_destroy","title":"rd_kafka_ElectLeaders_destroy()","text":"<pre><code>public static rd_kafka_ElectLeaders_destroy ( \n    \\FFI\\CData|null $elect_leaders\n ): void\n</code></pre> <p>Destroy and free a rd_kafka_ElectLeaders_t object previously created with rd_kafka_ElectLeaders_new() </p> Parameters elect_leaders <code>\\FFI\\CData|null</code> rd_kafka_ElectLeaders_t* - ) - The rd_kafka_ElectLeaders_t object to be destroyed. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a033c1190f2a18a34aa9d9051eb17a190 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_electleaders_new","title":"rd_kafka_ElectLeaders_new()","text":"<pre><code>public static rd_kafka_ElectLeaders_new ( \n    int $election_type, \n    \\FFI\\CData|null $partitions\n ): \\FFI\\CData|null\n</code></pre> <p>Create a new rd_kafka_ElectLeaders_t object. This object is later passed to rd_kafka_ElectLeaders(). </p> Parameters election_type <code>int</code> rd_kafka_ElectionType_t - The election type that needs to be performed, preferred or unclean. partitions <code>\\FFI\\CData|null</code> rd_kafka_topic_partition_list_t* - The topic partitions for which the leader election needs to be performed. Returns <code>\\FFI\\CData|null</code> rd_kafka_ElectLeaders_t* - a new allocated elect leaders object or returns NULL in case of invalid election_type. Use rd_kafka_ElectLeaders_destroy() to free object when done. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a059bcca58185c29fdf9908d7d11e8b22 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_electleaders_result_partitions","title":"rd_kafka_ElectLeaders_result_partitions()","text":"<pre><code>public static rd_kafka_ElectLeaders_result_partitions ( \n    \\FFI\\CData|null $result, \n    \\FFI\\CData|null $cntp\n ): \\FFI\\CData|null\n</code></pre> <p>Get the array of topic partition result objects from the elect leaders result event and populates the size of the array in <code>cntp</code>. </p> Parameters result <code>\\FFI\\CData|null</code> const rd_kafka_ElectLeaders_result_t* - The elect leaders result. cntp <code>\\FFI\\CData|null</code> size_t* - The number of elements in the array. Returns <code>\\FFI\\CData|null</code> const rd_kafka_topic_partition_result_t** - the array of topic partition result objects from the elect leaders result event. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a7b745712f0acd7f6c1d8f916d7ad6581 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_incrementalalterconfigs","title":"rd_kafka_IncrementalAlterConfigs()","text":"<pre><code>public static rd_kafka_IncrementalAlterConfigs ( \n    \\FFI\\CData|null $rk, \n    \\FFI\\CData|null $configs, \n    int|null $config_cnt, \n    \\FFI\\CData|null $options, \n    \\FFI\\CData|null $rkqu\n ): void\n</code></pre> <p>Incrementally update the configuration for the specified resources. Updates are not transactional so they may succeed for some resources while fail for others. The configs for a particular resource are updated atomically, executing the corresponding incremental operations on the provided configurations. </p> RemarksRequires broker version &gt;=2.3.0  Multiple resources and resource types may be set, but at most one resource of type <code>RD_KAFKA_RESOURCE_BROKER</code> is allowed per call since these resource requests must be sent to the broker specified in the resource. Broker option will be ignored in this case. Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* - Client instance. configs <code>\\FFI\\CData|null</code> rd_kafka_ConfigResource_t** - Array of config entries to alter. config_cnt <code>int|null</code> size_t - Number of elements in <code>configs</code> array. options <code>\\FFI\\CData|null</code> const rd_kafka_AdminOptions_t* - Optional admin options, or NULL for defaults. rkqu <code>\\FFI\\CData|null</code> rd_kafka_queue_t* - Queue to emit result on. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a36805ba8496fed43f6e87421c259804b </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_incrementalalterconfigs_result_resources","title":"rd_kafka_IncrementalAlterConfigs_result_resources()","text":"<pre><code>public static rd_kafka_IncrementalAlterConfigs_result_resources ( \n    \\FFI\\CData|null $result, \n    \\FFI\\CData|null $cntp\n ): \\FFI\\CData|null\n</code></pre> <p>Get an array of resource results from a IncrementalAlterConfigs result. </p> <p>Use <code>rd_kafka_ConfigResource_error()</code> and <code>rd_kafka_ConfigResource_error_string()</code> to extract per-resource error results on the returned array elements.</p> <p>The returned object life-times are the same as the <code>result</code> object.</p> Parameters result <code>\\FFI\\CData|null</code> const rd_kafka_IncrementalAlterConfigs_result_t* - Result object to get resource results from. cntp <code>\\FFI\\CData|null</code> size_t* - is updated to the number of elements in the array. Returns <code>\\FFI\\CData|null</code> const rd_kafka_ConfigResource_t** - an array of ConfigResource elements, or NULL if not available. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ad1d8458aa405d06de7feb716ae5144b5 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_listconsumergroupoffsets","title":"rd_kafka_ListConsumerGroupOffsets()","text":"<pre><code>public static rd_kafka_ListConsumerGroupOffsets ( \n    \\FFI\\CData|null $rk, \n    \\FFI\\CData|null $list_grpoffsets, \n    int|null $list_grpoffsets_cnt, \n    \\FFI\\CData|null $options, \n    \\FFI\\CData|null $rkqu\n ): void\n</code></pre> <p>List committed offsets for a set of partitions in a consumer group. </p> RemarksThe result event type emitted on the supplied queue is of type <code>RD_KAFKA_EVENT_LISTCONSUMERGROUPOFFSETS_RESULT</code>  The current implementation only supports one group per invocation.  Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* - Client instance. list_grpoffsets <code>\\FFI\\CData|null</code> rd_kafka_ListConsumerGroupOffsets_t** - Array of group committed offsets to list. MUST only be one single element. list_grpoffsets_cnt <code>int|null</code> size_t - Number of elements in <code>list_grpoffsets</code> array. MUST always be 1. options <code>\\FFI\\CData|null</code> const rd_kafka_AdminOptions_t* - Optional admin options, or NULL for defaults. rkqu <code>\\FFI\\CData|null</code> rd_kafka_queue_t* - Queue to emit result on. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ab51163573f8a19f0ec240428fd8fca3e </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_listconsumergroupoffsets_destroy","title":"rd_kafka_ListConsumerGroupOffsets_destroy()","text":"<pre><code>public static rd_kafka_ListConsumerGroupOffsets_destroy ( \n    \\FFI\\CData|null $list_grpoffsets\n ): void\n</code></pre> Parameters list_grpoffsets <code>\\FFI\\CData|null</code> rd_kafka_ListConsumerGroupOffsets_t*"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_listconsumergroupoffsets_destroy_array","title":"rd_kafka_ListConsumerGroupOffsets_destroy_array()","text":"<pre><code>public static rd_kafka_ListConsumerGroupOffsets_destroy_array ( \n    \\FFI\\CData|null $list_grpoffsets, \n    int|null $list_grpoffset_cnt\n ): void\n</code></pre> Parameters list_grpoffsets <code>\\FFI\\CData|null</code> rd_kafka_ListConsumerGroupOffsets_t** list_grpoffset_cnt <code>int|null</code> size_t"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_listconsumergroupoffsets_new","title":"rd_kafka_ListConsumerGroupOffsets_new()","text":"<pre><code>public static rd_kafka_ListConsumerGroupOffsets_new ( \n    string|null $group_id, \n    \\FFI\\CData|null $partitions\n ): \\FFI\\CData|null\n</code></pre> <p>Create a new ListConsumerGroupOffsets object. This object is later passed to rd_kafka_ListConsumerGroupOffsets(). </p> Parameters group_id <code>string|null</code> const char* - Consumer group id. partitions <code>\\FFI\\CData|null</code> const rd_kafka_topic_partition_list_t* - Partitions to list committed offsets for. Only the topic and partition fields are used. Returns <code>\\FFI\\CData|null</code> rd_kafka_ListConsumerGroupOffsets_t* - a new allocated ListConsumerGroupOffsets object. Use rd_kafka_ListConsumerGroupOffsets_destroy() to free object when done. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#af96cc3e1031d498fdf46f5590d8a7ea2 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_listconsumergroupoffsets_result_groups","title":"rd_kafka_ListConsumerGroupOffsets_result_groups()","text":"<pre><code>public static rd_kafka_ListConsumerGroupOffsets_result_groups ( \n    \\FFI\\CData|null $result, \n    \\FFI\\CData|null $cntp\n ): \\FFI\\CData|null\n</code></pre> <p>Get an array of results from a ListConsumerGroupOffsets result. </p> <p>The returned groups life-time is the same as the <code>result</code> object.</p> RemarksThe lifetime of the returned memory is the same as the lifetime of the <code>result</code> object.  Parameters result <code>\\FFI\\CData|null</code> const rd_kafka_ListConsumerGroupOffsets_result_t* - Result to get group results from. cntp <code>\\FFI\\CData|null</code> size_t* - is updated to the number of elements in the array. Returns <code>\\FFI\\CData|null</code> const rd_kafka_group_result_t** <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a0b4b3b9c5388038f4aac0e939f56854d </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_listconsumergroups","title":"rd_kafka_ListConsumerGroups()","text":"<pre><code>public static rd_kafka_ListConsumerGroups ( \n    \\FFI\\CData|null $rk, \n    \\FFI\\CData|null $options, \n    \\FFI\\CData|null $rkqu\n ): void\n</code></pre> <p>List the consumer groups available in the cluster. </p> RemarksThe result event type emitted on the supplied queue is of type <code>RD_KAFKA_EVENT_LISTCONSUMERGROUPS_RESULT</code> Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* - Client instance. options <code>\\FFI\\CData|null</code> const rd_kafka_AdminOptions_t* - Optional admin options, or NULL for defaults. rkqu <code>\\FFI\\CData|null</code> rd_kafka_queue_t* - Queue to emit result on. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ad386f553c1b0a103bd4f891f48a516c2 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_listconsumergroups_result_errors","title":"rd_kafka_ListConsumerGroups_result_errors()","text":"<pre><code>public static rd_kafka_ListConsumerGroups_result_errors ( \n    \\FFI\\CData|null $result, \n    \\FFI\\CData|null $cntp\n ): \\FFI\\CData|null\n</code></pre> <p>Get an array of errors from a ListConsumerGroups call result. </p> <p>The returned errors life-time is the same as the <code>result</code> object.</p> RemarksThe lifetime of the returned memory is the same as the lifetime of the <code>result</code> object.  Parameters result <code>\\FFI\\CData|null</code> const rd_kafka_ListConsumerGroups_result_t* - ListConsumerGroups result. cntp <code>\\FFI\\CData|null</code> size_t* - Is updated to the number of elements in the array. Returns <code>\\FFI\\CData|null</code> const rd_kafka_error_t** - Array of errors in <code>result</code>. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a0d1251b00ea55f8bd652c7a056c11425 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_listconsumergroups_result_valid","title":"rd_kafka_ListConsumerGroups_result_valid()","text":"<pre><code>public static rd_kafka_ListConsumerGroups_result_valid ( \n    \\FFI\\CData|null $result, \n    \\FFI\\CData|null $cntp\n ): \\FFI\\CData|null\n</code></pre> <p>Get an array of valid list groups from a ListConsumerGroups result. </p> <p>The returned groups life-time is the same as the <code>result</code> object.</p> RemarksThe lifetime of the returned memory is the same as the lifetime of the <code>result</code> object.  Parameters result <code>\\FFI\\CData|null</code> const rd_kafka_ListConsumerGroups_result_t* - Result to get group results from. cntp <code>\\FFI\\CData|null</code> size_t* - is updated to the number of elements in the array. Returns <code>\\FFI\\CData|null</code> const rd_kafka_ConsumerGroupListing_t** <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a3a0b27d2db47bd67106a02c9ac211ae6 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_listoffsets","title":"rd_kafka_ListOffsets()","text":"<pre><code>public static rd_kafka_ListOffsets ( \n    \\FFI\\CData|null $rk, \n    \\FFI\\CData|null $topic_partitions, \n    \\FFI\\CData|null $options, \n    \\FFI\\CData|null $rkqu\n ): void\n</code></pre> <p>List offsets for the specified <code>topic_partitions</code>. This operation enables to find the beginning offset, end offset as well as the offset matching a timestamp in partitions or the offset with max timestamp. </p> <p>Supported admin options:</p> <ul> <li>rd_kafka_AdminOptions_set_isolation_level() - default <code>RD_KAFKA_ISOLATION_LEVEL_READ_UNCOMMITTED</code> </li> <li>rd_kafka_AdminOptions_set_request_timeout() - default socket.timeout.ms</li> </ul> RemarksThe result event type emitted on the supplied queue is of type <code>RD_KAFKA_EVENT_LISTOFFSETS_RESULT</code> Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* - Client instance. topic_partitions <code>\\FFI\\CData|null</code> rd_kafka_topic_partition_list_t* - topic_partition_list_t with the partitions and offsets to list. Each topic partition offset can be a value of the <code>rd_kafka_OffsetSpec_t</code> enum or a non-negative value, representing a timestamp, to query for the first offset after the given timestamp. options <code>\\FFI\\CData|null</code> const rd_kafka_AdminOptions_t* - Optional admin options, or NULL for defaults. rkqu <code>\\FFI\\CData|null</code> rd_kafka_queue_t* - Queue to emit result on. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a264a98c3d96233e68a05739baed9428f </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_listoffsetsresultinfo_timestamp","title":"rd_kafka_ListOffsetsResultInfo_timestamp()","text":"<pre><code>public static rd_kafka_ListOffsetsResultInfo_timestamp ( \n    \\FFI\\CData|null $result_info\n ): int|null\n</code></pre> Parameters result_info <code>\\FFI\\CData|null</code> const rd_kafka_ListOffsetsResultInfo_t* Returns <code>int|null</code> int64_t"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_listoffsetsresultinfo_topic_partition","title":"rd_kafka_ListOffsetsResultInfo_topic_partition()","text":"<pre><code>public static rd_kafka_ListOffsetsResultInfo_topic_partition ( \n    \\FFI\\CData|null $result_info\n ): \\FFI\\CData|null\n</code></pre> Parameters result_info <code>\\FFI\\CData|null</code> const rd_kafka_ListOffsetsResultInfo_t* Returns <code>\\FFI\\CData|null</code> const rd_kafka_topic_partition_t*"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_listoffsets_result_infos","title":"rd_kafka_ListOffsets_result_infos()","text":"<pre><code>public static rd_kafka_ListOffsets_result_infos ( \n    \\FFI\\CData|null $result, \n    \\FFI\\CData|null $cntp\n ): \\FFI\\CData|null\n</code></pre> Parameters result <code>\\FFI\\CData|null</code> const rd_kafka_ListOffsets_result_t* cntp <code>\\FFI\\CData|null</code> size_t* Returns <code>\\FFI\\CData|null</code> const rd_kafka_ListOffsetsResultInfo_t**"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_memberassignment_partitions","title":"rd_kafka_MemberAssignment_partitions()","text":"<pre><code>public static rd_kafka_MemberAssignment_partitions ( \n    \\FFI\\CData|null $assignment\n ): \\FFI\\CData|null\n</code></pre> <p>Gets assigned partitions of a member <code>assignment</code>. </p> RemarksThe lifetime of the returned memory is the same as the lifetime of the <code>assignment</code> object.  Parameters assignment <code>\\FFI\\CData|null</code> const rd_kafka_MemberAssignment_t* - ) - The group member assignment. Returns <code>\\FFI\\CData|null</code> const rd_kafka_topic_partition_list_t* - The assigned partitions. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a5da333973857cb6e128a856399a9a21f </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_memberdescription_assignment","title":"rd_kafka_MemberDescription_assignment()","text":"<pre><code>public static rd_kafka_MemberDescription_assignment ( \n    \\FFI\\CData|null $member\n ): \\FFI\\CData|null\n</code></pre> <p>Gets assignment of <code>member</code>. </p> RemarksThe lifetime of the returned memory is the same as the lifetime of the <code>member</code> object.  Parameters member <code>\\FFI\\CData|null</code> const rd_kafka_MemberDescription_t* - ) - The group member. Returns <code>\\FFI\\CData|null</code> const rd_kafka_MemberAssignment_t* - The member assignment. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a9c5094e0d39a8d6f96e08355ef11c549 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_memberdescription_client_id","title":"rd_kafka_MemberDescription_client_id()","text":"<pre><code>public static rd_kafka_MemberDescription_client_id ( \n    \\FFI\\CData|null $member\n ): string|null\n</code></pre> <p>Gets client id of <code>member</code>. </p> RemarksThe lifetime of the returned memory is the same as the lifetime of the <code>member</code> object.  Parameters member <code>\\FFI\\CData|null</code> const rd_kafka_MemberDescription_t* - ) - The group member. Returns <code>string|null</code> const char* - The client id. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#af51b7bb5ba85029cf61512e0d577752b </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_memberdescription_consumer_id","title":"rd_kafka_MemberDescription_consumer_id()","text":"<pre><code>public static rd_kafka_MemberDescription_consumer_id ( \n    \\FFI\\CData|null $member\n ): string|null\n</code></pre> <p>Gets consumer id of <code>member</code>. </p> RemarksThe lifetime of the returned memory is the same as the lifetime of the <code>member</code> object.  Parameters member <code>\\FFI\\CData|null</code> const rd_kafka_MemberDescription_t* - ) - The group member. Returns <code>string|null</code> const char* - The consumer id. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a870f35c37cb290231adb1ef8d4fa7454 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_memberdescription_group_instance_id","title":"rd_kafka_MemberDescription_group_instance_id()","text":"<pre><code>public static rd_kafka_MemberDescription_group_instance_id ( \n    \\FFI\\CData|null $member\n ): string|null\n</code></pre> <p>Gets group instance id of <code>member</code>. </p> RemarksThe lifetime of the returned memory is the same as the lifetime of the <code>member</code> object.  Parameters member <code>\\FFI\\CData|null</code> const rd_kafka_MemberDescription_t* - ) - The group member. Returns <code>string|null</code> const char* - The group instance id, or NULL if not available. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ac4a5a27065d4aac5c9cf68cb518a40d3 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_memberdescription_host","title":"rd_kafka_MemberDescription_host()","text":"<pre><code>public static rd_kafka_MemberDescription_host ( \n    \\FFI\\CData|null $member\n ): string|null\n</code></pre> <p>Gets host of <code>member</code>. </p> RemarksThe lifetime of the returned memory is the same as the lifetime of the <code>member</code> object.  Parameters member <code>\\FFI\\CData|null</code> const rd_kafka_MemberDescription_t* - ) - The group member. Returns <code>string|null</code> const char* - The host. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a74681ac4652977e239f18d7e13a40dfe </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_newpartitions_destroy","title":"rd_kafka_NewPartitions_destroy()","text":"<pre><code>public static rd_kafka_NewPartitions_destroy ( \n    \\FFI\\CData|null $new_parts\n ): void\n</code></pre> Parameters new_parts <code>\\FFI\\CData|null</code> rd_kafka_NewPartitions_t*"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_newpartitions_destroy_array","title":"rd_kafka_NewPartitions_destroy_array()","text":"<pre><code>public static rd_kafka_NewPartitions_destroy_array ( \n    \\FFI\\CData|null $new_parts, \n    int|null $new_parts_cnt\n ): void\n</code></pre> Parameters new_parts <code>\\FFI\\CData|null</code> rd_kafka_NewPartitions_t** new_parts_cnt <code>int|null</code> size_t"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_newpartitions_new","title":"rd_kafka_NewPartitions_new()","text":"<pre><code>public static rd_kafka_NewPartitions_new ( \n    string|null $topic, \n    int|null $new_total_cnt, \n    \\FFI\\CData|null $errstr, \n    int|null $errstr_size\n ): \\FFI\\CData|null\n</code></pre> <p>Create a new NewPartitions. This object is later passed to rd_kafka_CreatePartitions() to increase the number of partitions to <code>new_total_cnt</code> for an existing topic. </p> Parameters topic <code>string|null</code> const char* - Topic name to create more partitions for. new_total_cnt <code>int|null</code> size_t - Increase the topic\u2019s partition count to this value. errstr <code>\\FFI\\CData|null</code> char* - A human readable error string (nul-terminated) is written to this location that must be of at least <code>errstr_size</code> bytes. The <code>errstr</code> is only written in case of error. - Writable size in <code>errstr</code>. errstr_size <code>int|null</code> size_t Returns <code>\\FFI\\CData|null</code> rd_kafka_NewPartitions_t* - a new allocated NewPartitions object, or NULL if the input parameters are invalid. Use rd_kafka_NewPartitions_destroy() to free object when done. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#abdda69e9215a7e41d5b97cb7ed0c6bd3 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_newpartitions_set_replica_assignment","title":"rd_kafka_NewPartitions_set_replica_assignment()","text":"<pre><code>public static rd_kafka_NewPartitions_set_replica_assignment ( \n    \\FFI\\CData|null $new_parts, \n    int|null $new_partition_idx, \n    \\FFI\\CData|null $broker_ids, \n    int|null $broker_id_cnt, \n    \\FFI\\CData|null $errstr, \n    int|null $errstr_size\n ): int\n</code></pre> <p>Set the replica (broker id) assignment for <code>new_partition_idx</code> to the replica set in <code>broker_ids</code> (of <code>broker_id_cnt</code> elements). </p> RemarksAn application must either set the replica assignment for all new partitions, or none.  If called, this function must be called consecutively for each new partition being created, where <code>new_partition_idx</code> 0 is the first new partition, 1 is the second, and so on. <code>broker_id_cnt</code> should match the topic's replication factor.  Use rd_kafka_metadata() to retrieve the list of brokers in the cluster. See alsord_kafka_AdminOptions_set_validate_only()  Parameters new_parts <code>\\FFI\\CData|null</code> rd_kafka_NewPartitions_t* new_partition_idx <code>int|null</code> int32_t broker_ids <code>\\FFI\\CData|null</code> int32_t* broker_id_cnt <code>int|null</code> size_t errstr <code>\\FFI\\CData|null</code> char* errstr_size <code>int|null</code> size_t Returns <code>int</code> rd_kafka_resp_err_t - RD_KAFKA_RESP_ERR_NO_ERROR on success, or an error code if the arguments were invalid. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a6b38e8b7f3357844a7ef9b31cdc4af3c </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_newtopic_destroy","title":"rd_kafka_NewTopic_destroy()","text":"<pre><code>public static rd_kafka_NewTopic_destroy ( \n    \\FFI\\CData|null $new_topic\n ): void\n</code></pre> Parameters new_topic <code>\\FFI\\CData|null</code> rd_kafka_NewTopic_t*"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_newtopic_destroy_array","title":"rd_kafka_NewTopic_destroy_array()","text":"<pre><code>public static rd_kafka_NewTopic_destroy_array ( \n    \\FFI\\CData|null $new_topics, \n    int|null $new_topic_cnt\n ): void\n</code></pre> Parameters new_topics <code>\\FFI\\CData|null</code> rd_kafka_NewTopic_t** new_topic_cnt <code>int|null</code> size_t"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_newtopic_new","title":"rd_kafka_NewTopic_new()","text":"<pre><code>public static rd_kafka_NewTopic_new ( \n    string|null $topic, \n    int|null $num_partitions, \n    int|null $replication_factor, \n    \\FFI\\CData|null $errstr, \n    int|null $errstr_size\n ): \\FFI\\CData|null\n</code></pre> <p>Create a new NewTopic object. This object is later passed to rd_kafka_CreateTopics(). </p> Parameters topic <code>string|null</code> const char* - Topic name to create. num_partitions <code>int|null</code> int - Number of partitions in topic, or -1 to use the broker\u2019s default partition count (&gt;= 2.4.0). replication_factor <code>int|null</code> int - Default replication factor for the topic\u2019s partitions, or -1 to use the broker\u2019s default replication factor (&gt;= 2.4.0) or if set_replica_assignment() will be used. errstr <code>\\FFI\\CData|null</code> char* - A human readable error string (nul-terminated) is written to this location that must be of at least <code>errstr_size</code> bytes. The <code>errstr</code> is only written in case of error. - Writable size in <code>errstr</code>. errstr_size <code>int|null</code> size_t Returns <code>\\FFI\\CData|null</code> rd_kafka_NewTopic_t* - a new allocated NewTopic object, or NULL if the input parameters are invalid. Use rd_kafka_NewTopic_destroy() to free object when done. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a9f172cd394d605c9fabca3959e101f8b </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_newtopic_set_config","title":"rd_kafka_NewTopic_set_config()","text":"<pre><code>public static rd_kafka_NewTopic_set_config ( \n    \\FFI\\CData|null $new_topic, \n    string|null $name, \n    string|null $value\n ): int\n</code></pre> <p>Set (broker-side) topic configuration name/value pair. </p> RemarksThe name and value are not validated by the client, the validation takes place on the broker. See alsord_kafka_AdminOptions_set_validate_only()   http://kafka.apache.org/documentation.html#topicconfigs  Parameters new_topic <code>\\FFI\\CData|null</code> rd_kafka_NewTopic_t* name <code>string|null</code> const char* value <code>string|null</code> const char* Returns <code>int</code> rd_kafka_resp_err_t - RD_KAFKA_RESP_ERR_NO_ERROR on success, or an error code if the arguments were invalid. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a29ae721839f76830e7f7b8ba5df64bed </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_newtopic_set_replica_assignment","title":"rd_kafka_NewTopic_set_replica_assignment()","text":"<pre><code>public static rd_kafka_NewTopic_set_replica_assignment ( \n    \\FFI\\CData|null $new_topic, \n    int|null $partition, \n    \\FFI\\CData|null $broker_ids, \n    int|null $broker_id_cnt, \n    \\FFI\\CData|null $errstr, \n    int|null $errstr_size\n ): int\n</code></pre> <p>Set the replica (broker) assignment for <code>partition</code> to the replica set in <code>broker_ids</code> (of <code>broker_id_cnt</code> elements). </p> RemarksWhen this method is used, rd_kafka_NewTopic_new() must have been called with a <code>replication_factor</code> of -1.  An application must either set the replica assignment for all new partitions, or none.  If called, this function must be called consecutively for each partition, starting at 0.  Use rd_kafka_metadata() to retrieve the list of brokers in the cluster. See alsord_kafka_AdminOptions_set_validate_only()  Parameters new_topic <code>\\FFI\\CData|null</code> rd_kafka_NewTopic_t* partition <code>int|null</code> int32_t broker_ids <code>\\FFI\\CData|null</code> int32_t* broker_id_cnt <code>int|null</code> size_t errstr <code>\\FFI\\CData|null</code> char* errstr_size <code>int|null</code> size_t Returns <code>int</code> rd_kafka_resp_err_t - RD_KAFKA_RESP_ERR_NO_ERROR on success, or an error code if the arguments were invalid. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ade3dabb32c5e0ed5edcbc038a9345144 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_node_host","title":"rd_kafka_Node_host()","text":"<pre><code>public static rd_kafka_Node_host ( \n    \\FFI\\CData|null $node\n ): string|null\n</code></pre> <p>Get the host of <code>node</code>. </p> RemarksThe lifetime of the returned memory is the same as the lifetime of the <code>node</code> object.  Parameters node <code>\\FFI\\CData|null</code> const rd_kafka_Node_t* - ) - The Node instance. Returns <code>string|null</code> const char* - The node host. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a4916477d9d4a0e76d05dd4b203d92b3b </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_node_id","title":"rd_kafka_Node_id()","text":"<pre><code>public static rd_kafka_Node_id ( \n    \\FFI\\CData|null $node\n ): int|null\n</code></pre> <p>Get the id of <code>node</code>. </p> Parameters node <code>\\FFI\\CData|null</code> const rd_kafka_Node_t* - ) - The Node instance. Returns <code>int|null</code> int - The node id. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ac0f59992ab0e0ae07b80163afa0ea685 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_node_port","title":"rd_kafka_Node_port()","text":"<pre><code>public static rd_kafka_Node_port ( \n    \\FFI\\CData|null $node\n ): int|null\n</code></pre> <p>Get the port of <code>node</code>. </p> Parameters node <code>\\FFI\\CData|null</code> const rd_kafka_Node_t* - ) - The Node instance. Returns <code>int|null</code> uint16_t - The node port. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#abc3ff57cdfc63f694d7200e91570ab3a </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_node_rack","title":"rd_kafka_Node_rack()","text":"<pre><code>public static rd_kafka_Node_rack ( \n    \\FFI\\CData|null $node\n ): string|null\n</code></pre> <p>Get the rack of <code>node</code>. </p> Parameters node <code>\\FFI\\CData|null</code> const rd_kafka_Node_t* - ) - The Node instance Returns <code>string|null</code> const char* - The node rack id. May be NULL. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a4082b53761808c022c49700988138dc7 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_resourcepatterntype_name","title":"rd_kafka_ResourcePatternType_name()","text":"<pre><code>public static rd_kafka_ResourcePatternType_name ( \n    int $resource_pattern_type\n ): string|null\n</code></pre> Parameters resource_pattern_type <code>int</code> rd_kafka_ResourcePatternType_t - ) Returns <code>string|null</code> const char* - a string representation of the <code>resource_pattern_type</code> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a488574082a549170e09adb67faca2f46 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_resourcetype_name","title":"rd_kafka_ResourceType_name()","text":"<pre><code>public static rd_kafka_ResourceType_name ( \n    int $restype\n ): string|null\n</code></pre> Parameters restype <code>int</code> rd_kafka_ResourceType_t - ) Returns <code>string|null</code> const char* - a string representation of the <code>restype</code> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ac026f797b199338b30a684087d2365f8 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_scramcredentialinfo_iterations","title":"rd_kafka_ScramCredentialInfo_iterations()","text":"<pre><code>public static rd_kafka_ScramCredentialInfo_iterations ( \n    \\FFI\\CData|null $scram_credential_info\n ): int|null\n</code></pre> Parameters scram_credential_info <code>\\FFI\\CData|null</code> const rd_kafka_ScramCredentialInfo_t* Returns <code>int|null</code> int32_t"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_scramcredentialinfo_mechanism","title":"rd_kafka_ScramCredentialInfo_mechanism()","text":"<pre><code>public static rd_kafka_ScramCredentialInfo_mechanism ( \n    \\FFI\\CData|null $scram_credential_info\n ): int\n</code></pre> Parameters scram_credential_info <code>\\FFI\\CData|null</code> const rd_kafka_ScramCredentialInfo_t* Returns <code>int</code> rd_kafka_ScramMechanism_t"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_topiccollection_destroy","title":"rd_kafka_TopicCollection_destroy()","text":"<pre><code>public static rd_kafka_TopicCollection_destroy ( \n    \\FFI\\CData|null $topics\n ): void\n</code></pre> Parameters topics <code>\\FFI\\CData|null</code> rd_kafka_TopicCollection_t*"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_topiccollection_of_topic_names","title":"rd_kafka_TopicCollection_of_topic_names()","text":"<pre><code>public static rd_kafka_TopicCollection_of_topic_names ( \n    \\FFI\\CData|null $topics, \n    int|null $topics_cnt\n ): \\FFI\\CData|null\n</code></pre> <p>Creates a new TopicCollection for passing to rd_kafka_DescribeTopics. </p> Parameters topics <code>\\FFI\\CData|null</code> const char** - A list of topics. topics_cnt <code>int|null</code> size_t - Count of topics. Returns <code>\\FFI\\CData|null</code> rd_kafka_TopicCollection_t* - a newly allocated TopicCollection object. Must be freed using rd_kafka_TopicCollection_destroy when done. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ab9af9e28d53872823af6702d1b01d378 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_topicdescription_authorized_operations","title":"rd_kafka_TopicDescription_authorized_operations()","text":"<pre><code>public static rd_kafka_TopicDescription_authorized_operations ( \n    \\FFI\\CData|null $topicdesc, \n    \\FFI\\CData|null $cntp\n ): \\FFI\\CData|null\n</code></pre> <p>Gets the topic authorized ACL operations for the <code>topicdesc</code> topic. </p> RemarksThe lifetime of the returned memory is the same as the lifetime of the <code>topicdesc</code> object.  Parameters topicdesc <code>\\FFI\\CData|null</code> const rd_kafka_TopicDescription_t* - The topic description. cntp <code>\\FFI\\CData|null</code> size_t* - is updated with authorized ACL operations count. Returns <code>\\FFI\\CData|null</code> const rd_kafka_AclOperation_t* - The topic authorized operations. Is NULL if operations were not requested. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#af2d93ccb01cc15e96cb11a39718f11b8 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_topicdescription_error","title":"rd_kafka_TopicDescription_error()","text":"<pre><code>public static rd_kafka_TopicDescription_error ( \n    \\FFI\\CData|null $topicdesc\n ): \\FFI\\CData|null\n</code></pre> <p>Gets the error for the <code>topicdesc</code> topic. </p> RemarksThe lifetime of the returned memory is the same as the lifetime of the <code>topicdesc</code> object.  Parameters topicdesc <code>\\FFI\\CData|null</code> const rd_kafka_TopicDescription_t* - ) - The topic description. Returns <code>\\FFI\\CData|null</code> const rd_kafka_error_t* - The topic description error. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a122980e677b8673357e0ead8278d122e </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_topicdescription_is_internal","title":"rd_kafka_TopicDescription_is_internal()","text":"<pre><code>public static rd_kafka_TopicDescription_is_internal ( \n    \\FFI\\CData|null $topicdesc\n ): int|null\n</code></pre> <p>Gets if the <code>topicdesc</code> topic is internal. </p> Parameters topicdesc <code>\\FFI\\CData|null</code> const rd_kafka_TopicDescription_t* - ) - The topic description. Returns <code>int|null</code> int - 1 if the topic is internal to Kafka, 0 otherwise. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aec3f6b1edd182818266d79bf3a3d681f </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_topicdescription_name","title":"rd_kafka_TopicDescription_name()","text":"<pre><code>public static rd_kafka_TopicDescription_name ( \n    \\FFI\\CData|null $topicdesc\n ): string|null\n</code></pre> <p>Gets the topic name for the <code>topicdesc</code> topic. </p> RemarksThe lifetime of the returned memory is the same as the lifetime of the <code>topicdesc</code> object.  Parameters topicdesc <code>\\FFI\\CData|null</code> const rd_kafka_TopicDescription_t* - ) - The topic description. Returns <code>string|null</code> const char* - The topic name. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a490e028c8ed8fda61ae24da3a814322c </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_topicdescription_partitions","title":"rd_kafka_TopicDescription_partitions()","text":"<pre><code>public static rd_kafka_TopicDescription_partitions ( \n    \\FFI\\CData|null $topicdesc, \n    \\FFI\\CData|null $cntp\n ): \\FFI\\CData|null\n</code></pre> <p>Gets an array of partitions for the <code>topicdesc</code> topic. </p> RemarksThe lifetime of the returned memory is the same as the lifetime of the <code>topicdesc</code> object.  Parameters topicdesc <code>\\FFI\\CData|null</code> const rd_kafka_TopicDescription_t* - The topic description. cntp <code>\\FFI\\CData|null</code> size_t* - is updated to the number of partitions in the array. Returns <code>\\FFI\\CData|null</code> const rd_kafka_TopicPartitionInfo_t** - An array of TopicPartitionInfos. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a55b846a85b6ca8174d976e559c82f999 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_topicdescription_topic_id","title":"rd_kafka_TopicDescription_topic_id()","text":"<pre><code>public static rd_kafka_TopicDescription_topic_id ( \n    \\FFI\\CData|null $topicdesc\n ): \\FFI\\CData|null\n</code></pre> <p>Gets the topic id for the <code>topicdesc</code> topic. </p> RemarksThe lifetime of the returned memory is the same as the lifetime of the <code>topicdesc</code> object.  Parameters topicdesc <code>\\FFI\\CData|null</code> const rd_kafka_TopicDescription_t* - ) - The topic description. Returns <code>\\FFI\\CData|null</code> const rd_kafka_Uuid_t* - The topic id <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a557e353e835117478b865d085dededfd </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_topicpartitioninfo_isr","title":"rd_kafka_TopicPartitionInfo_isr()","text":"<pre><code>public static rd_kafka_TopicPartitionInfo_isr ( \n    \\FFI\\CData|null $partition, \n    \\FFI\\CData|null $cntp\n ): \\FFI\\CData|null\n</code></pre> <p>Gets the partition in-sync replicas for <code>partition</code>. </p> RemarksThe lifetime of the returned memory is the same as the lifetime of the <code>partition</code> object.  Parameters partition <code>\\FFI\\CData|null</code> const rd_kafka_TopicPartitionInfo_t* - The partition info. cntp <code>\\FFI\\CData|null</code> size_t* - is updated with in-sync replicas count. Returns <code>\\FFI\\CData|null</code> const rd_kafka_Node_t** - The in-sync replica nodes. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a1eb96b873cacfb0e1e418432e41d7a05 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_topicpartitioninfo_leader","title":"rd_kafka_TopicPartitionInfo_leader()","text":"<pre><code>public static rd_kafka_TopicPartitionInfo_leader ( \n    \\FFI\\CData|null $partition\n ): \\FFI\\CData|null\n</code></pre> <p>Gets the partition leader for <code>partition</code>. </p> RemarksThe lifetime of the returned memory is the same as the lifetime of the <code>partition</code> object.  Parameters partition <code>\\FFI\\CData|null</code> const rd_kafka_TopicPartitionInfo_t* - ) - The partition info. Returns <code>\\FFI\\CData|null</code> const rd_kafka_Node_t* - The partition leader. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a678305c429a8566a0b78d4298847ab03 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_topicpartitioninfo_partition","title":"rd_kafka_TopicPartitionInfo_partition()","text":"<pre><code>public static rd_kafka_TopicPartitionInfo_partition ( \n    \\FFI\\CData|null $partition\n ): int|null\n</code></pre> <p>Gets the partition id for <code>partition</code>. </p> Parameters partition <code>\\FFI\\CData|null</code> const rd_kafka_TopicPartitionInfo_t* - ) - The partition info. Returns <code>int|null</code> const int - The partition id. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#af75739639e889e477d6f1a98cea88b25 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_topicpartitioninfo_replicas","title":"rd_kafka_TopicPartitionInfo_replicas()","text":"<pre><code>public static rd_kafka_TopicPartitionInfo_replicas ( \n    \\FFI\\CData|null $partition, \n    \\FFI\\CData|null $cntp\n ): \\FFI\\CData|null\n</code></pre> <p>Gets the partition replicas for <code>partition</code>. </p> RemarksThe lifetime of the returned memory is the same as the lifetime of the <code>partition</code> object.  Parameters partition <code>\\FFI\\CData|null</code> const rd_kafka_TopicPartitionInfo_t* - The partition info. cntp <code>\\FFI\\CData|null</code> size_t* - is updated with partition replicas count. Returns <code>\\FFI\\CData|null</code> const rd_kafka_Node_t** - The partition replicas nodes. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a50e33ecb1e7714bee26986a7dcc7fe49 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_userscramcredentialalteration_destroy","title":"rd_kafka_UserScramCredentialAlteration_destroy()","text":"<pre><code>public static rd_kafka_UserScramCredentialAlteration_destroy ( \n    \\FFI\\CData|null $alteration\n ): void\n</code></pre> Parameters alteration <code>\\FFI\\CData|null</code> rd_kafka_UserScramCredentialAlteration_t*"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_userscramcredentialalteration_destroy_array","title":"rd_kafka_UserScramCredentialAlteration_destroy_array()","text":"<pre><code>public static rd_kafka_UserScramCredentialAlteration_destroy_array ( \n    \\FFI\\CData|null $alterations, \n    int|null $alteration_cnt\n ): void\n</code></pre> Parameters alterations <code>\\FFI\\CData|null</code> rd_kafka_UserScramCredentialAlteration_t** alteration_cnt <code>int|null</code> size_t"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_userscramcredentialdeletion_new","title":"rd_kafka_UserScramCredentialDeletion_new()","text":"<pre><code>public static rd_kafka_UserScramCredentialDeletion_new ( \n    string|null $username, \n    int $mechanism\n ): \\FFI\\CData|null\n</code></pre> <p>Allocates a new UserScramCredentialDeletion given its fields. </p> Parameters username <code>string|null</code> const char* - The username (not empty). mechanism <code>int</code> rd_kafka_ScramMechanism_t - SASL/SCRAM mechanism. Returns <code>\\FFI\\CData|null</code> rd_kafka_UserScramCredentialAlteration_t* - A newly created instance of rd_kafka_UserScramCredentialAlteration_t. Ownership belongs to the caller, use rd_kafka_UserScramCredentialAlteration_destroy to destroy. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a89e57d12d9415354fcbbf1d7b0072db2 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_userscramcredentialupsertion_new","title":"rd_kafka_UserScramCredentialUpsertion_new()","text":"<pre><code>public static rd_kafka_UserScramCredentialUpsertion_new ( \n    string|null $username, \n    int $mechanism, \n    int|null $iterations, \n    \\FFI\\CData|null $password, \n    int|null $password_size, \n    \\FFI\\CData|null $salt, \n    int|null $salt_size\n ): \\FFI\\CData|null\n</code></pre> <p>Allocates a new UserScramCredentialUpsertion given its fields. If salt isn't given a 64 B salt is generated using OpenSSL RAND_priv_bytes, if available. </p> RemarksA random salt is generated, when NULL, only if OpenSSL &gt;= 1.1.1. Otherwise it's a required param. Parameters username <code>string|null</code> const char* - The username (not empty). mechanism <code>int</code> rd_kafka_ScramMechanism_t - SASL/SCRAM mechanism. iterations <code>int|null</code> int32_t - SASL/SCRAM iterations. password <code>\\FFI\\CData|null</code> const unsigned char* - Password bytes (not empty). password_size <code>int|null</code> size_t - Size of <code>password</code> (greater than 0). salt <code>\\FFI\\CData|null</code> const unsigned char* - Salt bytes (optional). salt_size <code>int|null</code> size_t - Size of <code>salt</code> (optional). Returns <code>\\FFI\\CData|null</code> rd_kafka_UserScramCredentialAlteration_t* - A newly created instance of rd_kafka_UserScramCredentialAlteration_t. Ownership belongs to the caller, use rd_kafka_UserScramCredentialAlteration_destroy to destroy. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ae1707143331cd5b798d25cb8df33df5f </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_userscramcredentialsdescription_error","title":"rd_kafka_UserScramCredentialsDescription_error()","text":"<pre><code>public static rd_kafka_UserScramCredentialsDescription_error ( \n    \\FFI\\CData|null $description\n ): \\FFI\\CData|null\n</code></pre> Parameters description <code>\\FFI\\CData|null</code> const rd_kafka_UserScramCredentialsDescription_t* Returns <code>\\FFI\\CData|null</code> const rd_kafka_error_t*"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_userscramcredentialsdescription_scramcredentialinfo","title":"rd_kafka_UserScramCredentialsDescription_scramcredentialinfo()","text":"<pre><code>public static rd_kafka_UserScramCredentialsDescription_scramcredentialinfo ( \n    \\FFI\\CData|null $description, \n    int|null $idx\n ): \\FFI\\CData|null\n</code></pre> Parameters description <code>\\FFI\\CData|null</code> const rd_kafka_UserScramCredentialsDescription_t* idx <code>int|null</code> size_t Returns <code>\\FFI\\CData|null</code> const rd_kafka_ScramCredentialInfo_t*"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_userscramcredentialsdescription_scramcredentialinfo_count","title":"rd_kafka_UserScramCredentialsDescription_scramcredentialinfo_count()","text":"<pre><code>public static rd_kafka_UserScramCredentialsDescription_scramcredentialinfo_count ( \n    \\FFI\\CData|null $description\n ): int|null\n</code></pre> Parameters description <code>\\FFI\\CData|null</code> const rd_kafka_UserScramCredentialsDescription_t* Returns <code>int|null</code> size_t"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_userscramcredentialsdescription_user","title":"rd_kafka_UserScramCredentialsDescription_user()","text":"<pre><code>public static rd_kafka_UserScramCredentialsDescription_user ( \n    \\FFI\\CData|null $description\n ): string|null\n</code></pre> Parameters description <code>\\FFI\\CData|null</code> const rd_kafka_UserScramCredentialsDescription_t* Returns <code>string|null</code> const char*"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_uuid_base64str","title":"rd_kafka_Uuid_base64str()","text":"<pre><code>public static rd_kafka_Uuid_base64str ( \n    \\FFI\\CData|null $uuid\n ): string|null\n</code></pre> <p>Computes base64 encoding for the given uuid string. </p> Parameters uuid <code>\\FFI\\CData|null</code> const rd_kafka_Uuid_t* - ) - UUID for which base64 encoding is required. Returns <code>string|null</code> const char* - base64 encoded string for the given UUID or NULL in case of some issue with the conversion or the conversion is not supported. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a50639fc35e5e639ab5851857ed806b93 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_uuid_copy","title":"rd_kafka_Uuid_copy()","text":"<pre><code>public static rd_kafka_Uuid_copy ( \n    \\FFI\\CData|null $uuid\n ): \\FFI\\CData|null\n</code></pre> <p>Copies the given UUID. </p> RemarksMust be freed after use using rd_kafka_Uuid_destroy()  Parameters uuid <code>\\FFI\\CData|null</code> const rd_kafka_Uuid_t* - ) - UUID to be copied. Returns <code>\\FFI\\CData|null</code> rd_kafka_Uuid_t* - A newly allocated copy of the provided UUID. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#adb76dc69e22b2fd34b9dfb881f685a07 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_uuid_destroy","title":"rd_kafka_Uuid_destroy()","text":"<pre><code>public static rd_kafka_Uuid_destroy ( \n    \\FFI\\CData|null $uuid\n ): void\n</code></pre> <p>Destroy the provided uuid. </p> Parameters uuid <code>\\FFI\\CData|null</code> rd_kafka_Uuid_t* - ) - UUID <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a04e21c3278dc96745bfb232df69dbfce </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_uuid_least_significant_bits","title":"rd_kafka_Uuid_least_significant_bits()","text":"<pre><code>public static rd_kafka_Uuid_least_significant_bits ( \n    \\FFI\\CData|null $uuid\n ): int|null\n</code></pre> <p>Gets least significant 64 bits for the given UUID. </p> Parameters uuid <code>\\FFI\\CData|null</code> const rd_kafka_Uuid_t* - ) - UUID Returns <code>int|null</code> int64_t - least significant 64 bits for the given UUID. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#afda9d744c58d439823bd9e06f5fbf851 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_uuid_most_significant_bits","title":"rd_kafka_Uuid_most_significant_bits()","text":"<pre><code>public static rd_kafka_Uuid_most_significant_bits ( \n    \\FFI\\CData|null $uuid\n ): int|null\n</code></pre> <p>Gets most significant 64 bits for the given UUID. </p> Parameters uuid <code>\\FFI\\CData|null</code> const rd_kafka_Uuid_t* - ) - UUID Returns <code>int|null</code> int64_t - most significant 64 bits for the given UUID. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a443577282d2071374f20896ce2f97a91 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_uuid_new","title":"rd_kafka_Uuid_new()","text":"<pre><code>public static rd_kafka_Uuid_new ( \n    int|null $most_significant_bits, \n    int|null $least_significant_bits\n ): \\FFI\\CData|null\n</code></pre> <p>Creates a new UUID. </p> RemarksMust be freed after use using rd_kafka_Uuid_destroy()  Parameters most_significant_bits <code>int|null</code> int64_t - most significant 64 bits of the 128 bits UUID. least_significant_bits <code>int|null</code> int64_t - least significant 64 bits of the 128 bits UUID. Returns <code>\\FFI\\CData|null</code> rd_kafka_Uuid_t* - A newly allocated UUID. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a0462c0b4858b2c2df6506b123ee9358c </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_abort_transaction","title":"rd_kafka_abort_transaction()","text":"<pre><code>public static rd_kafka_abort_transaction ( \n    \\FFI\\CData|null $rk, \n    int|null $timeout_ms\n ): \\FFI\\CData|null\n</code></pre> <p>Aborts the ongoing transaction. </p> <pre>   This function should also be used to recover from non-fatal abortable\n   transaction errors.\n\nAny outstanding messages will be purged and fail with\n   RD_KAFKA_RESP_ERR__PURGE_INFLIGHT or RD_KAFKA_RESP_ERR__PURGE_QUEUE.\n   See rd_kafka_purge() for details.\n</pre> RemarksIt is strongly recommended to always pass -1 (remaining transaction time) as the <code>timeout_ms</code>. Using other values risk internal state desynchronization in case any of the underlying protocol requests fail.  This function will block until all outstanding messages are purged and the transaction abort request has been successfully handled by the transaction coordinator, or until <code>timeout_ms</code> expires, which ever comes first. On timeout the application may call the function again. If the application has enabled RD_KAFKA_EVENT_DR it must serve the event queue in a separate thread since rd_kafka_flush() will not serve delivery reports in this mode.  This call is resumable when a retriable timeout error is returned. Calling the function again will resume the operation that is progressing in the background. RemarksThe returned error object (if not NULL) must be destroyed with rd_kafka_error_destroy().  Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* - Producer instance. timeout_ms <code>int|null</code> int - The maximum time to block. On timeout the operation may continue in the background, depending on state, and it is okay to call this function again. Pass -1 to use the remaining transaction timeout, this is the recommended use. Returns <code>\\FFI\\CData|null</code> rd_kafka_error_t* - NULL on success or an error object on failure. Check whether the returned error object permits retrying by calling rd_kafka_error_is_retriable(), or whether a fatal error has been raised by calling rd_kafka_error_is_fatal(). Error codes: RD_KAFKA_RESP_ERR__STATE if not currently in a transaction, RD_KAFKA_RESP_ERR__TIMED_OUT if the transaction could not be complete commmitted within <code>timeout_ms</code>, this is a retriable error as the commit continues in the background, RD_KAFKA_RESP_ERR_INVALID_PRODUCER_EPOCH if the current producer transaction has been fenced by a newer producer instance, RD_KAFKA_RESP_ERR_TRANSACTIONAL_ID_AUTHORIZATION_FAILED if the producer is no longer authorized to perform transactional operations, RD_KAFKA_RESP_ERR__NOT_CONFIGURED if transactions have not been configured for the producer instance, RD_KAFKA_RESP_ERR__INVALID_ARG if <code>rk</code> is not a producer instance, Other error codes not listed here may be returned, depending on broker version. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a2e50d1043e1b16ed28ba6e372aa0909d </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_acl_result_error","title":"rd_kafka_acl_result_error()","text":"<pre><code>public static rd_kafka_acl_result_error ( \n    \\FFI\\CData|null $aclres\n ): \\FFI\\CData|null\n</code></pre> Parameters aclres <code>\\FFI\\CData|null</code> const rd_kafka_acl_result_t* - ) Returns <code>\\FFI\\CData|null</code> const rd_kafka_error_t* - the error object for the given acl result, or NULL on success. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aebde4f3d06cf6ae74b4be39bca9107bb </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_assign","title":"rd_kafka_assign()","text":"<pre><code>public static rd_kafka_assign ( \n    \\FFI\\CData|null $rk, \n    \\FFI\\CData|null $partitions\n ): int\n</code></pre> <p>Atomic assignment of partitions to consume. </p> <p>The new <code>partitions</code> will replace the existing assignment.</p> <p>A zero-length <code>partitions</code> will treat the partitions as a valid, albeit empty assignment, and maintain internal state, while a <code>NULL</code> value for <code>partitions</code> will reset and clear the internal state.</p> <p>When used from a rebalance callback, the application should pass the partition list passed to the callback (or a copy of it) even if the list is empty (i.e. should not pass NULL in this case) so as to maintain internal join state. This is not strictly required - the application may adjust the assignment provided by the group. However, this is rarely useful in practice.</p> Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* partitions <code>\\FFI\\CData|null</code> const rd_kafka_topic_partition_list_t* Returns <code>int</code> rd_kafka_resp_err_t - An error code indicating if the new assignment was applied or not. RD_KAFKA_RESP_ERR__FATAL is returned if the consumer has raised a fatal error. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a0566419eff2001f8371e3b50aa7d26e9 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_assignment","title":"rd_kafka_assignment()","text":"<pre><code>public static rd_kafka_assignment ( \n    \\FFI\\CData|null $rk, \n    \\FFI\\CData|null $partitions\n ): int\n</code></pre> <p>Returns the current partition assignment as set by rd_kafka_assign() or rd_kafka_incremental_assign(). </p> RemarksThe application is responsible for calling rd_kafka_topic_partition_list_destroy on the returned list.  This assignment represents the partitions assigned through the assign functions and not the partitions assigned to this consumer instance by the consumer group leader. They are usually the same following a rebalance but not necessarily since an application is free to assign any partitions.  Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* partitions <code>\\FFI\\CData|null</code> rd_kafka_topic_partition_list_t** Returns <code>int</code> rd_kafka_resp_err_t - An error code on failure, otherwise <code>partitions</code> is updated to point to a newly allocated partition list (possibly empty). <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a10a00cc624a46209fe1192cfc56cce59 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_assignment_lost","title":"rd_kafka_assignment_lost()","text":"<pre><code>public static rd_kafka_assignment_lost ( \n    \\FFI\\CData|null $rk\n ): int|null\n</code></pre> <p>Check whether the consumer considers the current assignment to have been lost involuntarily. This method is only applicable for use with a high level subscribing consumer. Assignments are revoked immediately when determined to have been lost, so this method is only useful when reacting to a RD_KAFKA_EVENT_REBALANCE event or from within a rebalance_cb. Partitions that have been lost may already be owned by other members in the group and therefore commiting offsets, for example, may fail. </p> RemarksCalling rd_kafka_assign(), rd_kafka_incremental_assign() or rd_kafka_incremental_unassign() resets this flag. Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* - ) Returns <code>int|null</code> int - Returns 1 if the current partition assignment is considered lost, 0 otherwise. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a5383a36bacd08e9ef52bfe29accb34a1 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_begin_transaction","title":"rd_kafka_begin_transaction()","text":"<pre><code>public static rd_kafka_begin_transaction ( \n    \\FFI\\CData|null $rk\n ): \\FFI\\CData|null\n</code></pre> <p>Begin a new transaction. </p> <p>rd_kafka_init_transactions() must have been called successfully (once) before this function is called.</p> <p>Upon successful return from this function the application has to perform at least one of the following operations within <code>transaction.timeout.ms</code> to avoid timing out the transaction on the broker:</p> <ul> <li>rd_kafka_produce() (et.al)</li> <li>rd_kafka_send_offsets_to_transaction()</li> <li>rd_kafka_commit_transaction()</li> <li>rd_kafka_abort_transaction()</li> </ul> <p>Any messages produced, offsets sent (rd_kafka_send_offsets_to_transaction()), etc, after the successful return of this function will be part of the transaction and committed or aborted atomatically.</p> <p>Finish the transaction by calling rd_kafka_commit_transaction() or abort the transaction by calling rd_kafka_abort_transaction().</p> RemarksWith the transactional producer, rd_kafka_produce(), rd_kafka_producev(), et.al, are only allowed during an on-going transaction, as started with this function. Any produce call outside an on-going transaction, or for a failed transaction, will fail.  The returned error object (if not NULL) must be destroyed with rd_kafka_error_destroy().  Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* - ) - Producer instance. Returns <code>\\FFI\\CData|null</code> rd_kafka_error_t* - NULL on success or an error object on failure. Check whether a fatal error has been raised by calling rd_kafka_error_is_fatal(). Error codes: RD_KAFKA_RESP_ERR__STATE if a transaction is already in progress or upon fatal error, RD_KAFKA_RESP_ERR__NOT_CONFIGURED if transactions have not been configured for the producer instance, RD_KAFKA_RESP_ERR__INVALID_ARG if <code>rk</code> is not a producer instance. Other error codes not listed here may be returned, depending on broker version. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a3c5338866b641957e9eeeaa9b60f5f9c </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_brokers_add","title":"rd_kafka_brokers_add()","text":"<pre><code>public static rd_kafka_brokers_add ( \n    \\FFI\\CData|null $rk, \n    string|null $brokerlist\n ): int|null\n</code></pre> <p>Adds one or more brokers to the kafka handle's list of initial bootstrap brokers. </p> <p>Additional brokers will be discovered automatically as soon as rdkafka connects to a broker by querying the broker metadata.</p> <p>If a broker name resolves to multiple addresses (and possibly address families) all will be used for connection attempts in round-robin fashion.</p> <p><code>brokerlist</code> is a ,-separated list of brokers in the format: <code>&lt;broker1&gt;</code>,&lt;broker2&gt;,.. Where each broker is in either the host or URL based format: <code>&lt;host&gt;</code>[:&lt;port&gt;] <code>&lt;proto&gt;</code>://&lt;host&gt;[:port] <code>&lt;proto&gt;</code> is either <code>PLAINTEXT</code>, <code>SSL</code>, <code>SASL</code>, <code>SASL_PLAINTEXT</code> The two formats can be mixed but ultimately the value of the <code>security.protocol</code> config property decides what brokers are allowed.</p> <p>Example: brokerlist = \"broker1:10000,broker2\" brokerlist = \"SSL://broker3:9000,ssl://broker2\"</p> RemarksBrokers may also be defined with the <code>metadata.broker.list</code> or <code>bootstrap.servers</code> configuration property (preferred method). Deprecated:Set bootstrap servers with the <code>bootstrap.servers</code> configuration property.  Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* brokerlist <code>string|null</code> const char* Returns <code>int|null</code> int - the number of brokers successfully added. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ab83da8da989fe41693d78d982c7ae6b7 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_clusterid","title":"rd_kafka_clusterid()","text":"<pre><code>public static rd_kafka_clusterid ( \n    \\FFI\\CData|null $rk, \n    int|null $timeout_ms\n ): \\FFI\\CData|null\n</code></pre> <p>Returns the ClusterId as reported in broker metadata. </p> RemarksRequires broker version &gt;=0.10.0 and api.version.request=true.  The application must free the returned pointer using rd_kafka_mem_free(). Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* - Client instance. timeout_ms <code>int|null</code> int - If there is no cached value from metadata retrieval then this specifies the maximum amount of time (in milliseconds) the call will block waiting for metadata to be retrieved. Use 0 for non-blocking calls. Returns <code>\\FFI\\CData|null</code> char* - a newly allocated string containing the ClusterId, or NULL if no ClusterId could be retrieved in the allotted timespan. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a261ba8c649756fbc7fbcd442ae481a18 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_commit","title":"rd_kafka_commit()","text":"<pre><code>public static rd_kafka_commit ( \n    \\FFI\\CData|null $rk, \n    \\FFI\\CData|null $offsets, \n    int|null $async\n ): int\n</code></pre> <p>Commit offsets on broker for the provided list of partitions. </p> <p><code>offsets</code> should contain <code>topic</code>, <code>partition</code>, <code>offset</code> and possibly <code>metadata</code>. The <code>offset</code> should be the offset where consumption will resume, i.e., the last processed offset + 1. If <code>offsets</code> is NULL the current partition assignment will be used instead.</p> <p>If <code>async</code> is false this operation will block until the broker offset commit is done, returning the resulting success or error code.</p> <p>If a rd_kafka_conf_set_offset_commit_cb() offset commit callback has been configured the callback will be enqueued for a future call to rd_kafka_poll(), rd_kafka_consumer_poll() or similar.</p> <p>FIXME: Update below documentation.</p> <p>RD_KAFKA_RESP_ERR_STALE_MEMBER_EPOCH is returned, when using <code>group.protocol=consumer</code>, if the commit failed because the member has switched to a new member epoch. This error code can be retried. Partition level error is also set in the <code>offsets</code>.</p> <p>RD_KAFKA_RESP_ERR_UNKNOWN_MEMBER_ID is returned, when using <code>group.protocol=consumer</code>, if the member has been removed from the consumer group This error code is permanent, uncommitted messages will be reprocessed by this or a different member and committed there. Partition level error is also set in the <code>offsets</code>. </p> Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* offsets <code>\\FFI\\CData|null</code> const rd_kafka_topic_partition_list_t* async <code>int|null</code> int Returns <code>int</code> rd_kafka_resp_err_t - An error code indiciating if the commit was successful, or successfully scheduled if asynchronous, or failed. RD_KAFKA_RESP_ERR__FATAL is returned if the consumer has raised a fatal error. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ab96539928328f14c3c9177ea0c896c87 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_commit_message","title":"rd_kafka_commit_message()","text":"<pre><code>public static rd_kafka_commit_message ( \n    \\FFI\\CData|null $rk, \n    \\FFI\\CData|null $rkmessage, \n    int|null $async\n ): int\n</code></pre> <p>Commit message's offset on broker for the message's partition. The committed offset is the message's offset + 1. </p> See alsord_kafka_commit  Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* rkmessage <code>\\FFI\\CData|null</code> const rd_kafka_message_t* async <code>int|null</code> int Returns <code>int</code> rd_kafka_resp_err_t <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a99fb25d50216e4e20d303bf8a4a62883 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_commit_queue","title":"rd_kafka_commit_queue()","text":"<pre><code>public static rd_kafka_commit_queue ( \n    \\FFI\\CData|null $rk, \n    \\FFI\\CData|null $offsets, \n    \\FFI\\CData|null $rkqu, \n    \\FFI\\CData|\\Closure $cb, \n    \\FFI\\CData|object|string|null $opaque\n ): int\n</code></pre> <p>Commit offsets on broker for the provided list of partitions. </p> <p>See rd_kafka_commit for <code>offsets</code> semantics.</p> <p>The result of the offset commit will be posted on the provided <code>rkqu</code> queue.</p> <p>If the application uses one of the poll APIs (rd_kafka_poll(), rd_kafka_consumer_poll(), rd_kafka_queue_poll(), ..) to serve the queue the <code>cb</code> callback is required.</p> <p>The <code>commit_opaque</code> argument is passed to the callback as <code>commit_opaque</code>, or if using the event API the callback is ignored and the offset commit result will be returned as an RD_KAFKA_EVENT_COMMIT event and the <code>commit_opaque</code> value will be available with rd_kafka_event_opaque().</p> <p>If <code>rkqu</code> is NULL a temporary queue will be created and the callback will be served by this call.</p> See alsord_kafka_commit()   rd_kafka_conf_set_offset_commit_cb()  Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* offsets <code>\\FFI\\CData|null</code> const rd_kafka_topic_partition_list_t* rkqu <code>\\FFI\\CData|null</code> rd_kafka_queue_t* cb <code>\\FFI\\CData|\\Closure</code> void()(rd_kafka_t, rd_kafka_resp_err_t, rd_kafka_topic_partition_list_t*, void*) opaque <code>\\FFI\\CData|object|string|null</code> void* Returns <code>int</code> rd_kafka_resp_err_t <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#af76a6a73baa9c2621536e3f6882a3c1a </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_commit_transaction","title":"rd_kafka_commit_transaction()","text":"<pre><code>public static rd_kafka_commit_transaction ( \n    \\FFI\\CData|null $rk, \n    int|null $timeout_ms\n ): \\FFI\\CData|null\n</code></pre> <p>Commit the current transaction (as started with rd_kafka_begin_transaction()). </p> <p>Any outstanding messages will be flushed (delivered) before actually committing the transaction.</p> <p>If any of the outstanding messages fail permanently the current transaction will enter the abortable error state and this function will return an abortable error, in this case the application must call rd_kafka_abort_transaction() before attempting a new transaction with rd_kafka_begin_transaction().</p> RemarksIt is strongly recommended to always pass -1 (remaining transaction time) as the <code>timeout_ms</code>. Using other values risk internal state desynchronization in case any of the underlying protocol requests fail.  This function will block until all outstanding messages are delivered and the transaction commit request has been successfully handled by the transaction coordinator, or until <code>timeout_ms</code> expires, which ever comes first. On timeout the application may call the function again.  Will automatically call rd_kafka_flush() to ensure all queued messages are delivered before attempting to commit the transaction. If the application has enabled RD_KAFKA_EVENT_DR it must serve the event queue in a separate thread since rd_kafka_flush() will not serve delivery reports in this mode.  This call is resumable when a retriable timeout error is returned. Calling the function again will resume the operation that is progressing in the background. RemarksThe returned error object (if not NULL) must be destroyed with rd_kafka_error_destroy().  Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* - Producer instance. timeout_ms <code>int|null</code> int - The maximum time to block. On timeout the operation may continue in the background, depending on state, and it is okay to call this function again. Pass -1 to use the remaining transaction timeout, this is the recommended use. Returns <code>\\FFI\\CData|null</code> rd_kafka_error_t* - NULL on success or an error object on failure. Check whether the returned error object permits retrying by calling rd_kafka_error_is_retriable(), or whether an abortable or fatal error has been raised by calling rd_kafka_error_txn_requires_abort() or rd_kafka_error_is_fatal() respectively. Error codes: RD_KAFKA_RESP_ERR__STATE if not currently in a transaction, RD_KAFKA_RESP_ERR__TIMED_OUT if the transaction could not be complete commmitted within <code>timeout_ms</code>, this is a retriable error as the commit continues in the background, RD_KAFKA_RESP_ERR_INVALID_PRODUCER_EPOCH if the current producer transaction has been fenced by a newer producer instance, RD_KAFKA_RESP_ERR_TRANSACTIONAL_ID_AUTHORIZATION_FAILED if the producer is no longer authorized to perform transactional operations, RD_KAFKA_RESP_ERR__NOT_CONFIGURED if transactions have not been configured for the producer instance, RD_KAFKA_RESP_ERR__INVALID_ARG if <code>rk</code> is not a producer instance, Other error codes not listed here may be returned, depending on broker version. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a63a2d72bf9ba444bcea457bf47c4642a </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_committed","title":"rd_kafka_committed()","text":"<pre><code>public static rd_kafka_committed ( \n    \\FFI\\CData|null $rk, \n    \\FFI\\CData|null $partitions, \n    int|null $timeout_ms\n ): int\n</code></pre> <p>Retrieve committed offsets for topics+partitions. </p> <p>The <code>offset</code> field of each requested partition will either be set to stored offset or to RD_KAFKA_OFFSET_INVALID in case there was no stored offset for that partition.</p> <p>Committed offsets will be returned according to the <code>isolation.level</code> configuration property, if set to <code>read_committed</code> (default) then only stable offsets for fully committed transactions will be returned, while <code>read_uncommitted</code> may return offsets for not yet committed transactions.</p> Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* partitions <code>\\FFI\\CData|null</code> rd_kafka_topic_partition_list_t* timeout_ms <code>int|null</code> int Returns <code>int</code> rd_kafka_resp_err_t - RD_KAFKA_RESP_ERR_NO_ERROR on success in which case the <code>offset</code> or <code>err</code> field of each <code>partitions\u2019</code> element is filled in with the stored offset, or a partition specific error. Else returns an error code. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a39846ae321a03c4679c9c659f18adf13 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_conf","title":"rd_kafka_conf()","text":"<pre><code>public static rd_kafka_conf ( \n    \\FFI\\CData|null $rk\n ): \\FFI\\CData|null\n</code></pre> Remarksthe returned object is read-only and its lifetime is the same as the rd_kafka_t object.  Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* - ) Returns <code>\\FFI\\CData|null</code> const rd_kafka_conf_t* - the configuration object used by an rd_kafka_t instance. For use with rd_kafka_conf_get(), et.al., to extract configuration properties from a running client. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a71e233cd19b13572772df2d43074a97d </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_conf_destroy","title":"rd_kafka_conf_destroy()","text":"<pre><code>public static rd_kafka_conf_destroy ( \n    \\FFI\\CData|null $conf\n ): void\n</code></pre> Parameters conf <code>\\FFI\\CData|null</code> rd_kafka_conf_t*"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_conf_dump","title":"rd_kafka_conf_dump()","text":"<pre><code>public static rd_kafka_conf_dump ( \n    \\FFI\\CData|null $conf, \n    \\FFI\\CData|null $cntp\n ): \\FFI\\CData|null\n</code></pre> <p>Dump the configuration properties and values of <code>conf</code> to an array with \"key\", \"value\" pairs. </p> <p>The number of entries in the array is returned in <code>*cntp</code>.</p> <p>The dump must be freed with <code>rd_kafka_conf_dump_free()</code>. </p> Parameters conf <code>\\FFI\\CData|null</code> rd_kafka_conf_t* cntp <code>\\FFI\\CData|null</code> size_t* Returns <code>\\FFI\\CData|null</code> const char** <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a6eba851c2af748de6921d708b47dc94c </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_conf_dump_free","title":"rd_kafka_conf_dump_free()","text":"<pre><code>public static rd_kafka_conf_dump_free ( \n    \\FFI\\CData|null $arr, \n    int|null $cnt\n ): void\n</code></pre> Parameters arr <code>\\FFI\\CData|null</code> const char** cnt <code>int|null</code> size_t"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_conf_dup","title":"rd_kafka_conf_dup()","text":"<pre><code>public static rd_kafka_conf_dup ( \n    \\FFI\\CData|null $conf\n ): \\FFI\\CData|null\n</code></pre> <p>Creates a copy/duplicate of configuration object <code>conf</code>. </p> RemarksInterceptors are NOT copied to the new configuration object.  See alsord_kafka_interceptor_f_on_conf_dup  Parameters conf <code>\\FFI\\CData|null</code> const rd_kafka_conf_t* - ) Returns <code>\\FFI\\CData|null</code> rd_kafka_conf_t* <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8cbfe15c6978ff09870e82cb524c673d </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_conf_dup_filter","title":"rd_kafka_conf_dup_filter()","text":"<pre><code>public static rd_kafka_conf_dup_filter ( \n    \\FFI\\CData|null $conf, \n    int|null $filter_cnt, \n    \\FFI\\CData|null $filter\n ): \\FFI\\CData|null\n</code></pre> Parameters conf <code>\\FFI\\CData|null</code> const rd_kafka_conf_t* filter_cnt <code>int|null</code> size_t filter <code>\\FFI\\CData|null</code> const char** Returns <code>\\FFI\\CData|null</code> rd_kafka_conf_t*"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_conf_enable_sasl_queue","title":"rd_kafka_conf_enable_sasl_queue()","text":"<pre><code>public static rd_kafka_conf_enable_sasl_queue ( \n    \\FFI\\CData|null $conf, \n    int|null $enable\n ): void\n</code></pre> <p>Enable/disable creation of a queue specific to SASL events and callbacks. </p> <p>For SASL mechanisms that trigger callbacks (currently OAUTHBEARER) this configuration API allows an application to get a dedicated queue for the SASL events/callbacks. After enabling the queue with this API the application can retrieve the queue by calling rd_kafka_queue_get_sasl() on the client instance. This queue may then be served directly by the application (with rd_kafka_queue_poll(), et.al) or forwarded to another queue, such as the background queue.</p> <p>A convenience function is available to automatically forward the SASL queue to librdkafka's background thread, see rd_kafka_sasl_background_callbacks_enable().</p> <p>By default (<code>enable</code> = 0) the main queue (as served by rd_kafka_poll(), et.al.) is used for SASL callbacks.</p> RemarksThe SASL queue is currently only used by the SASL OAUTHBEARER mechanism's token_refresh_cb(). See alsord_kafka_queue_get_sasl()   rd_kafka_sasl_background_callbacks_enable()  Parameters conf <code>\\FFI\\CData|null</code> rd_kafka_conf_t* enable <code>int|null</code> int <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ad01f5e5a40eaebf133db5a2858198fbd </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_conf_get","title":"rd_kafka_conf_get()","text":"<pre><code>public static rd_kafka_conf_get ( \n    \\FFI\\CData|null $conf, \n    string|null $name, \n    \\FFI\\CData|null $dest, \n    \\FFI\\CData|null $dest_size\n ): int\n</code></pre> <p>Retrieve configuration value for property <code>name</code>. </p> <p>If <code>dest</code> is non-NULL the value will be written to <code>dest</code> with at most <code>dest_size</code>.</p> <p><code>*dest_size</code> is updated to the full length of the value, thus if <code>*dest_size</code> initially is smaller than the full length the application may reallocate <code>dest</code> to fit the returned <code>*dest_size</code> and try again.</p> <p>If <code>dest</code> is NULL only the full length of the value is returned.</p> <p>Fallthrough: Topic-level configuration properties from the <code>default_topic_conf</code> may be retrieved using this interface.</p> Parameters conf <code>\\FFI\\CData|null</code> const rd_kafka_conf_t* name <code>string|null</code> const char* dest <code>\\FFI\\CData|null</code> char* dest_size <code>\\FFI\\CData|null</code> size_t* Returns <code>int</code> rd_kafka_conf_res_t - <code>RD_KAFKA_CONF_OK</code> if the property name matched, else <code>RD_KAFKA_CONF_UNKNOWN</code>. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#abe9f0f77e9145eb1a62c3258ac495b97 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_conf_get_default_topic_conf","title":"rd_kafka_conf_get_default_topic_conf()","text":"<pre><code>public static rd_kafka_conf_get_default_topic_conf ( \n    \\FFI\\CData|null $conf\n ): \\FFI\\CData|null\n</code></pre> <p>Gets the default topic configuration as previously set with rd_kafka_conf_set_default_topic_conf() or that was implicitly created by configuring a topic-level property on the global <code>conf</code> object. </p> WarningThe returned topic configuration object is owned by the <code>conf</code> object. It may be modified but not destroyed and its lifetime is the same as the <code>conf</code> object or the next call to rd_kafka_conf_set_default_topic_conf().  Parameters conf <code>\\FFI\\CData|null</code> rd_kafka_conf_t* - ) Returns <code>\\FFI\\CData|null</code> rd_kafka_topic_conf_t* - the <code>conf\u2019s</code> default topic configuration (if any), or NULL. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a622ed908e64c21ba53449216400109ee </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_conf_interceptor_add_on_conf_destroy","title":"rd_kafka_conf_interceptor_add_on_conf_destroy()","text":"<pre><code>public static rd_kafka_conf_interceptor_add_on_conf_destroy ( \n    \\FFI\\CData|null $conf, \n    string|null $ic_name, \n    \\FFI\\CData|\\Closure $on_conf_destroy, \n    \\FFI\\CData|object|string|null $ic_opaque\n ): int\n</code></pre> <p>Append an on_conf_destroy() interceptor. </p> RemarksMultiple on_conf_destroy() interceptors are allowed to be added to the same configuration object.  Parameters conf <code>\\FFI\\CData|null</code> rd_kafka_conf_t* - Configuration object. ic_name <code>string|null</code> const char* - Interceptor name, used in logging. on_conf_destroy <code>\\FFI\\CData|\\Closure</code> rd_kafka_resp_err_t(rd_kafka_interceptor_f_on_conf_destroy_t*)(void*) - Function pointer. ic_opaque <code>\\FFI\\CData|object|string|null</code> void* - Opaque value that will be passed to the function. Returns <code>int</code> rd_kafka_resp_err_t - RD_KAFKA_RESP_ERR_NO_ERROR <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a919ebd487a2717d6cbdf0d25102ea8ff </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_conf_interceptor_add_on_conf_dup","title":"rd_kafka_conf_interceptor_add_on_conf_dup()","text":"<pre><code>public static rd_kafka_conf_interceptor_add_on_conf_dup ( \n    \\FFI\\CData|null $conf, \n    string|null $ic_name, \n    \\FFI\\CData|\\Closure $on_conf_dup, \n    \\FFI\\CData|object|string|null $ic_opaque\n ): int\n</code></pre> <p>Append an on_conf_dup() interceptor. </p> Parameters conf <code>\\FFI\\CData|null</code> rd_kafka_conf_t* - Configuration object. ic_name <code>string|null</code> const char* - Interceptor name, used in logging. on_conf_dup <code>\\FFI\\CData|\\Closure</code> rd_kafka_resp_err_t(rd_kafka_interceptor_f_on_conf_dup_t*)(rd_kafka_conf_t*, const rd_kafka_conf_t*, size_t, const char**, void*) - Function pointer. ic_opaque <code>\\FFI\\CData|object|string|null</code> void* - Opaque value that will be passed to the function. Returns <code>int</code> rd_kafka_resp_err_t - RD_KAFKA_RESP_ERR_NO_ERROR on success or RD_KAFKA_RESP_ERR__CONFLICT if an existing interceptor with the same <code>ic_name</code> and function has already been added to <code>conf</code>. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a375ce703f6247377305dc6a5dfc84429 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_conf_interceptor_add_on_conf_set","title":"rd_kafka_conf_interceptor_add_on_conf_set()","text":"<pre><code>public static rd_kafka_conf_interceptor_add_on_conf_set ( \n    \\FFI\\CData|null $conf, \n    string|null $ic_name, \n    \\FFI\\CData|\\Closure $on_conf_set, \n    \\FFI\\CData|object|string|null $ic_opaque\n ): int\n</code></pre> <p>Append an on_conf_set() interceptor. </p> Parameters conf <code>\\FFI\\CData|null</code> rd_kafka_conf_t* - Configuration object. ic_name <code>string|null</code> const char* - Interceptor name, used in logging. on_conf_set <code>\\FFI\\CData|\\Closure</code> rd_kafka_conf_res_t(rd_kafka_interceptor_f_on_conf_set_t*)(rd_kafka_conf_t*, const char*, const char*, char*, size_t, void*) - Function pointer. ic_opaque <code>\\FFI\\CData|object|string|null</code> void* - Opaque value that will be passed to the function. Returns <code>int</code> rd_kafka_resp_err_t - RD_KAFKA_RESP_ERR_NO_ERROR on success or RD_KAFKA_RESP_ERR__CONFLICT if an existing interceptor with the same <code>ic_name</code> and function has already been added to <code>conf</code>. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a97bdeb12b99da10eff18767b3cadbfd2 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_conf_interceptor_add_on_new","title":"rd_kafka_conf_interceptor_add_on_new()","text":"<pre><code>public static rd_kafka_conf_interceptor_add_on_new ( \n    \\FFI\\CData|null $conf, \n    string|null $ic_name, \n    \\FFI\\CData|\\Closure $on_new, \n    \\FFI\\CData|object|string|null $ic_opaque\n ): int\n</code></pre> <p>Append an on_new() interceptor. </p> RemarksSince the on_new() interceptor is added to the configuration object it may be copied by rd_kafka_conf_dup(). An interceptor implementation must thus be able to handle the same interceptor,ic_opaque tuple to be used by multiple client instances.  An interceptor plugin should check the return value to make sure it has not already been added. Parameters conf <code>\\FFI\\CData|null</code> rd_kafka_conf_t* - Configuration object. ic_name <code>string|null</code> const char* - Interceptor name, used in logging. on_new <code>\\FFI\\CData|\\Closure</code> rd_kafka_resp_err_t(rd_kafka_interceptor_f_on_new_t*)(rd_kafka_t*, const rd_kafka_conf_t*, void*, char*, size_t) - Function pointer. ic_opaque <code>\\FFI\\CData|object|string|null</code> void* - Opaque value that will be passed to the function. Returns <code>int</code> rd_kafka_resp_err_t - RD_KAFKA_RESP_ERR_NO_ERROR on success or RD_KAFKA_RESP_ERR__CONFLICT if an existing interceptor with the same <code>ic_name</code> and function has already been added to <code>conf</code>. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a002ef1d350176725b6e9ba93548edf40 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_conf_new","title":"rd_kafka_conf_new()","text":"<pre><code>public static rd_kafka_conf_new (  ): \\FFI\\CData|null\n</code></pre> <p>Create configuration object. </p> <p>When providing your own configuration to the <code>rd_kafka_*_new_*</code>() calls the rd_kafka_conf_t objects needs to be created with this function which will set up the defaults. I.e.: </p> <pre><code>rd_kafka_conf_t *myconf;\nrd_kafka_conf_res_t res;\n\nmyconf = rd_kafka_conf_new();\nres = rd_kafka_conf_set(myconf, \"socket.timeout.ms\", \"600\",\n                        errstr, sizeof(errstr));\nif (res != RD_KAFKA_CONF_OK)\n   die(\"%s\\n\", errstr);\n\nrk = rd_kafka_new(..., myconf);</code></pre> <p>Please see CONFIGURATION.md for the default settings or use rd_kafka_conf_properties_show() to provide the information at runtime.</p> <p>The properties are identical to the Apache Kafka configuration properties whenever possible.</p> RemarksA successful call to rd_kafka_new() will assume ownership of the conf object and rd_kafka_conf_destroy() must not be called. See alsord_kafka_new(), rd_kafka_conf_set(), rd_kafka_conf_destroy()  Returns <code>\\FFI\\CData|null</code> rd_kafka_conf_t* - ) - A new rd_kafka_conf_t object with defaults set. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aa7459bd22e8cfa81aa8c2480a4a0304c </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_conf_properties_show","title":"rd_kafka_conf_properties_show()","text":"<pre><code>public static rd_kafka_conf_properties_show ( \n    \\FFI\\CData|null $fp\n ): void\n</code></pre> <p>Prints a table to <code>fp</code> of all supported configuration properties, their default values as well as a description. </p> RemarksAll properties and properties and values are shown, even those that have been disabled at build time due to missing dependencies.  Parameters fp <code>\\FFI\\CData|null</code> FILE* - ) <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aa52f3a5a08207e14386739fe336e57be </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_conf_set","title":"rd_kafka_conf_set()","text":"<pre><code>public static rd_kafka_conf_set ( \n    \\FFI\\CData|null $conf, \n    string|null $name, \n    string|null $value, \n    \\FFI\\CData|null $errstr, \n    int|null $errstr_size\n ): int\n</code></pre> <p>Sets a configuration property. </p> <p><code>conf</code> must have been previously created with rd_kafka_conf_new().</p> <p>Fallthrough: Topic-level configuration properties may be set using this interface in which case they are applied on the <code>default_topic_conf</code>. If no <code>default_topic_conf</code> has been set one will be created. Any subsequent rd_kafka_conf_set_default_topic_conf() calls will replace the current default topic configuration.</p> RemarksSetting properties or values that were disabled at build time due to missing dependencies will return RD_KAFKA_CONF_INVALID.  Parameters conf <code>\\FFI\\CData|null</code> rd_kafka_conf_t* name <code>string|null</code> const char* value <code>string|null</code> const char* errstr <code>\\FFI\\CData|null</code> char* errstr_size <code>int|null</code> size_t Returns <code>int</code> rd_kafka_conf_res_t - <code>rd_kafka_conf_res_t</code> to indicate success or failure. In case of failure <code>errstr</code> is updated to contain a human readable error string. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#abb1b319278333e8cdee9442da7f135e8 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_conf_set_background_event_cb","title":"rd_kafka_conf_set_background_event_cb()","text":"<pre><code>public static rd_kafka_conf_set_background_event_cb ( \n    \\FFI\\CData|null $conf, \n    \\FFI\\CData|\\Closure $event_cb\n ): void\n</code></pre> <p>Generic event callback to be used with the event API to trigger callbacks for <code>rd_kafka_event_t</code> objects from a background thread serving the background queue. </p> <p>How to use:</p> <ol> <li>First set the event callback on the configuration object with this function, followed by creating an rd_kafka_t instance with rd_kafka_new().</li> <li>Get the instance's background queue with rd_kafka_queue_get_background() and pass it as the reply/response queue to an API that takes an event queue, such as rd_kafka_CreateTopics().</li> <li>As the response event is ready and enqueued on the background queue the event callback will be triggered from the background thread.</li> <li>Prior to destroying the client instance, loose your reference to the background queue by calling rd_kafka_queue_destroy().</li> </ol> <p>The application must destroy the <code>rkev</code> passed to <code>event</code> cb using rd_kafka_event_destroy().</p> <p>The <code>event_cb</code> <code>opaque</code> argument is the opaque set with rd_kafka_conf_set_opaque().</p> RemarksThis callback is a specialized alternative to the poll-based event API described in the Event interface section.  The <code>event_cb</code> will be called spontaneously from a background thread completely managed by librdkafka. Take care to perform proper locking of application objects. WarningThe application MUST NOT call rd_kafka_destroy() from the event callback. See alsord_kafka_queue_get_background  Parameters conf <code>\\FFI\\CData|null</code> rd_kafka_conf_t* event_cb <code>\\FFI\\CData|\\Closure</code> void()(rd_kafka_t, rd_kafka_event_t*, void*) <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a5ce6c329ca692674b1c42460f9bab521 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_conf_set_closesocket_cb","title":"rd_kafka_conf_set_closesocket_cb()","text":"<pre><code>public static rd_kafka_conf_set_closesocket_cb ( \n    \\FFI\\CData|null $conf, \n    \\FFI\\CData|\\Closure $closesocket_cb\n ): void\n</code></pre> <p>Set close socket callback. </p> <p>Close a socket (optionally opened with socket_cb()).</p> <p>The callback's <code>opaque</code> argument is the opaque set with rd_kafka_conf_set_opaque().</p> RemarksThe callback will be called from an internal librdkafka thread.  Parameters conf <code>\\FFI\\CData|null</code> rd_kafka_conf_t* closesocket_cb <code>\\FFI\\CData|\\Closure</code> int()(int, void) <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ab55c7ddc46a354e3f57b5b209e5ec3c7 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_conf_set_connect_cb","title":"rd_kafka_conf_set_connect_cb()","text":"<pre><code>public static rd_kafka_conf_set_connect_cb ( \n    \\FFI\\CData|null $conf, \n    \\FFI\\CData|\\Closure $connect_cb\n ): void\n</code></pre> <p>Set connect callback. </p> <p>The connect callback is responsible for connecting socket <code>sockfd</code> to peer address <code>addr</code>. The <code>id</code> field contains the broker identifier.</p> <p><code>connect_cb</code> shall return 0 on success (socket connected) or an error number (errno) on error.</p> <p>The callback's <code>opaque</code> argument is the opaque set with rd_kafka_conf_set_opaque().</p> RemarksThe callback will be called from an internal librdkafka thread.  Parameters conf <code>\\FFI\\CData|null</code> rd_kafka_conf_t* connect_cb <code>\\FFI\\CData|\\Closure</code> int()(int, const struct sockaddr, int, const char*, void*) <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a53dd1b77019324170d0168617fdaf040 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_conf_set_consume_cb","title":"rd_kafka_conf_set_consume_cb()","text":"<pre><code>public static rd_kafka_conf_set_consume_cb ( \n    \\FFI\\CData|null $conf, \n    \\FFI\\CData|\\Closure $consume_cb\n ): void\n</code></pre> <p>Consumer: Set consume callback for use with rd_kafka_consumer_poll() </p> <p>The <code>consume_cb</code> <code>opaque</code> argument is the opaque set with rd_kafka_conf_set_opaque(). </p> Parameters conf <code>\\FFI\\CData|null</code> rd_kafka_conf_t* consume_cb <code>\\FFI\\CData|\\Closure</code> void()(rd_kafka_message_t, void*) <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a65eaf45e9b26bcb085f4651634ce06a5 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_conf_set_default_topic_conf","title":"rd_kafka_conf_set_default_topic_conf()","text":"<pre><code>public static rd_kafka_conf_set_default_topic_conf ( \n    \\FFI\\CData|null $conf, \n    \\FFI\\CData|null $tconf\n ): void\n</code></pre> <p>Sets the default topic configuration to use for automatically subscribed topics (e.g., through pattern-matched topics). The topic config object is not usable after this call. </p> WarningAny topic configuration settings that have been set on the global rd_kafka_conf_t object will be overwritten by this call since the implicitly created default topic config object is replaced by the user-supplied one. Deprecated:Set default topic level configuration on the global rd_kafka_conf_t object instead.  Parameters conf <code>\\FFI\\CData|null</code> rd_kafka_conf_t* tconf <code>\\FFI\\CData|null</code> rd_kafka_topic_conf_t* <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a138aa4881c8703dd6b69f22ddc454f63 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_conf_set_dr_cb","title":"rd_kafka_conf_set_dr_cb()","text":"<pre><code>public static rd_kafka_conf_set_dr_cb ( \n    \\FFI\\CData|null $conf, \n    \\FFI\\CData|\\Closure $dr_cb\n ): void\n</code></pre> Deprecated:See rd_kafka_conf_set_dr_msg_cb()  Parameters conf <code>\\FFI\\CData|null</code> rd_kafka_conf_t* dr_cb <code>\\FFI\\CData|\\Closure</code> void()(rd_kafka_t, void*, size_t, rd_kafka_resp_err_t, void*, void*) <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a075b15c4141784fdc271de217005a41f </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_conf_set_dr_msg_cb","title":"rd_kafka_conf_set_dr_msg_cb()","text":"<pre><code>public static rd_kafka_conf_set_dr_msg_cb ( \n    \\FFI\\CData|null $conf, \n    \\FFI\\CData|\\Closure $dr_msg_cb\n ): void\n</code></pre> <p>Producer: Set delivery report callback in provided <code>conf</code> object. </p> <p>The delivery report callback will be called once for each message accepted by rd_kafka_produce() (et.al) with <code>err</code> set to indicate the result of the produce request.</p> <p>The callback is called when a message is succesfully produced or if librdkafka encountered a permanent failure. Delivery errors occur when the retry count is exceeded, when the message.timeout.ms timeout is exceeded or there is a permanent error like RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART.</p> <p>An application must call rd_kafka_poll() at regular intervals to serve queued delivery report callbacks.</p> <p>The broker-assigned offset can be retrieved with <code>rkmessage-&gt;offset</code> and the timestamp can be retrieved using rd_kafka_message_timestamp().</p> <p>The <code>dr_msg_cb</code> <code>opaque</code> argument is the opaque set with rd_kafka_conf_set_opaque(). The per-message msg_opaque value is available in <code>rd_kafka_message_t._private</code>.</p> RemarksThe Idempotent Producer may return invalid timestamp (RD_KAFKA_TIMESTAMP_NOT_AVAILABLE), and and offset (RD_KAFKA_OFFSET_INVALID) for retried messages that were previously successfully delivered but not properly acknowledged.  Parameters conf <code>\\FFI\\CData|null</code> rd_kafka_conf_t* dr_msg_cb <code>\\FFI\\CData|\\Closure</code> void()(rd_kafka_t, const rd_kafka_message_t*, void*) <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ac1c9946aee26e10de2661fcf2242ea8a </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_conf_set_engine_callback_data","title":"rd_kafka_conf_set_engine_callback_data()","text":"<pre><code>public static rd_kafka_conf_set_engine_callback_data ( \n    \\FFI\\CData|null $conf, \n    \\FFI\\CData|object|string|null $callback_data\n ): void\n</code></pre> <p>Set callback_data for OpenSSL engine. </p> RemarksThe <code>ssl.engine.location</code> configuration must be set for this to have affect.  The memory pointed to by <code>value</code> must remain valid for the lifetime of the configuration object and any Kafka clients that use it.  Parameters conf <code>\\FFI\\CData|null</code> rd_kafka_conf_t* - Configuration object. callback_data <code>\\FFI\\CData|object|string|null</code> void* - passed to engine callbacks, e.g. <code>ENGINE_load_ssl_client_cert</code>. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a07871a230226c6acbdf3cd062545812b </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_conf_set_error_cb","title":"rd_kafka_conf_set_error_cb()","text":"<pre><code>public static rd_kafka_conf_set_error_cb ( \n    \\FFI\\CData|null $conf, \n    \\FFI\\CData|\\Closure $error_cb\n ): void\n</code></pre> <p>Set error callback in provided conf object. </p> <p>The error callback is used by librdkafka to signal warnings and errors back to the application.</p> <p>These errors should generally be considered informational and non-permanent, the client will try to recover automatically from all type of errors. Given that the client and cluster configuration is correct the application should treat these as temporary errors.</p> <p><code>error_cb</code> will be triggered with <code>err</code> set to RD_KAFKA_RESP_ERR__FATAL if a fatal error has been raised; in this case use rd_kafka_fatal_error() to retrieve the fatal error code and error string, and then begin terminating the client instance.</p> <p>If no <code>error_cb</code> is registered, or RD_KAFKA_EVENT_ERROR has not been set with rd_kafka_conf_set_events, then the errors will be logged instead.</p> <p>The callback's <code>opaque</code> argument is the opaque set with rd_kafka_conf_set_opaque(). </p> Parameters conf <code>\\FFI\\CData|null</code> rd_kafka_conf_t* error_cb <code>\\FFI\\CData|\\Closure</code> void()(rd_kafka_t, int, const char*, void*) <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ace721ef3b7c22d0c111ec747ef039a90 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_conf_set_events","title":"rd_kafka_conf_set_events()","text":"<pre><code>public static rd_kafka_conf_set_events ( \n    \\FFI\\CData|null $conf, \n    int|null $events\n ): void\n</code></pre> Parameters conf <code>\\FFI\\CData|null</code> rd_kafka_conf_t* events <code>int|null</code> int"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_conf_set_log_cb","title":"rd_kafka_conf_set_log_cb()","text":"<pre><code>public static rd_kafka_conf_set_log_cb ( \n    \\FFI\\CData|null $conf, \n    \\FFI\\CData|\\Closure $log_cb\n ): void\n</code></pre> <p>Set logger callback. </p> <p>The default is to print to stderr, but a syslog logger is also available, see rd_kafka_log_print and rd_kafka_log_syslog for the builtin alternatives. Alternatively the application may provide its own logger callback. Or pass <code>func</code> as NULL to disable logging.</p> <p>This is the configuration alternative to the deprecated rd_kafka_set_logger()</p> RemarksThe log_cb will be called spontaneously from librdkafka's internal threads unless logs have been forwarded to a poll queue through <code>rd_kafka_set_log_queue()</code>. An application MUST NOT call any librdkafka APIs or do any prolonged work in a non-forwarded <code>log_cb</code>.  Parameters conf <code>\\FFI\\CData|null</code> rd_kafka_conf_t* log_cb <code>\\FFI\\CData|\\Closure</code> void()(const rd_kafka_t, int, const char*, const char*) <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a06ade2ca41f32eb82c6f7e3d4acbe19f </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_conf_set_oauthbearer_token_refresh_cb","title":"rd_kafka_conf_set_oauthbearer_token_refresh_cb()","text":"<pre><code>public static rd_kafka_conf_set_oauthbearer_token_refresh_cb ( \n    \\FFI\\CData|null $conf, \n    \\FFI\\CData|\\Closure $oauthbearer_token_refresh_cb\n ): void\n</code></pre> <p>Set SASL/OAUTHBEARER token refresh callback in provided conf object. </p> <p>The SASL/OAUTHBEARER token refresh callback is triggered via rd_kafka_poll() whenever OAUTHBEARER is the SASL mechanism and a token needs to be retrieved, typically based on the configuration defined in <code>sasl.oauthbearer.config</code>.</p> <p>The callback should invoke rd_kafka_oauthbearer_set_token() or rd_kafka_oauthbearer_set_token_failure() to indicate success or failure, respectively.</p> <p>The refresh operation is eventable and may be received via rd_kafka_queue_poll() with an event type of <code>RD_KAFKA_EVENT_OAUTHBEARER_TOKEN_REFRESH</code>.</p> <p>Note that before any SASL/OAUTHBEARER broker connection can succeed the application must call rd_kafka_oauthbearer_set_token() once \u2013 either directly or, more typically, by invoking either rd_kafka_poll(), rd_kafka_consumer_poll(), rd_kafka_queue_poll(), etc, in order to cause retrieval of an initial token to occur.</p> <p>Alternatively, the application can enable the SASL queue by calling rd_kafka_conf_enable_sasl_queue() on the configuration object prior to creating the client instance, get the SASL queue with rd_kafka_queue_get_sasl(), and either serve the queue manually by calling rd_kafka_queue_poll(), or redirecting the queue to the background thread to have the queue served automatically. For the latter case the SASL queue must be forwarded to the background queue with rd_kafka_queue_forward(). A convenience function is available to automatically forward the SASL queue to librdkafka's background thread, see rd_kafka_sasl_background_callbacks_enable().</p> <p>An unsecured JWT refresh handler is provided by librdkafka for development and testing purposes, it is enabled by setting the <code>enable.sasl.oauthbearer.unsecure.jwt</code> property to true and is mutually exclusive to using a refresh callback.</p> See alsord_kafka_sasl_background_callbacks_enable()   rd_kafka_queue_get_sasl()  Parameters conf <code>\\FFI\\CData|null</code> rd_kafka_conf_t* - the configuration to mutate. oauthbearer_token_refresh_cb <code>\\FFI\\CData|\\Closure</code> void()(rd_kafka_t, const char*, void*) - the callback to set; callback function arguments: <code>rk</code> - Kafka handle <code>oauthbearer_config</code> - Value of configuration property sasl.oauthbearer.config. <code>opaque</code> - Application-provided opaque set via rd_kafka_conf_set_opaque() <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a988395722598f63396d7a1bedb22adaf </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_conf_set_offset_commit_cb","title":"rd_kafka_conf_set_offset_commit_cb()","text":"<pre><code>public static rd_kafka_conf_set_offset_commit_cb ( \n    \\FFI\\CData|null $conf, \n    \\FFI\\CData|\\Closure $offset_commit_cb\n ): void\n</code></pre> <p>Consumer: Set offset commit callback for use with consumer groups. </p> <p>The results of automatic or manual offset commits will be scheduled for this callback and is served by rd_kafka_consumer_poll().</p> <p>If no partitions had valid offsets to commit this callback will be called with <code>err</code> == RD_KAFKA_RESP_ERR__NO_OFFSET which is not to be considered an error.</p> <p>The <code>offsets</code> list contains per-partition information:</p> <ul> <li><code>offset:</code> committed offset (attempted)</li> <li><code>err:</code> commit error</li> </ul> <p>The callback's <code>opaque</code> argument is the opaque set with rd_kafka_conf_set_opaque(). </p> Parameters conf <code>\\FFI\\CData|null</code> rd_kafka_conf_t* offset_commit_cb <code>\\FFI\\CData|\\Closure</code> void()(rd_kafka_t, rd_kafka_resp_err_t, rd_kafka_topic_partition_list_t*, void*) <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a1ab8bb9e8d8cdd5906f9e060b506f2eb </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_conf_set_opaque","title":"rd_kafka_conf_set_opaque()","text":"<pre><code>public static rd_kafka_conf_set_opaque ( \n    \\FFI\\CData|null $conf, \n    \\FFI\\CData|object|string|null $opaque\n ): void\n</code></pre> <p>Sets the application's opaque pointer that will be passed to callbacks. </p> See alsord_kafka_opaque()  Parameters conf <code>\\FFI\\CData|null</code> rd_kafka_conf_t* opaque <code>\\FFI\\CData|object|string|null</code> void* <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a07cb7d91d9b7458a95ca6f1292763c24 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_conf_set_rebalance_cb","title":"rd_kafka_conf_set_rebalance_cb()","text":"<pre><code>public static rd_kafka_conf_set_rebalance_cb ( \n    \\FFI\\CData|null $conf, \n    \\FFI\\CData|\\Closure $rebalance_cb\n ): void\n</code></pre> <p>Consumer: Set rebalance callback for use with coordinated consumer group balancing. </p> <p>The <code>err</code> field is set to either RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS or RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS and 'partitions' contains the full partition set that was either assigned or revoked.</p> <p>Registering a <code>rebalance_cb</code> turns off librdkafka's automatic partition assignment/revocation and instead delegates that responsibility to the application's <code>rebalance_cb</code>.</p> <p>The rebalance callback is responsible for updating librdkafka's assignment set based on the two events: RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS and RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS but should also be able to handle arbitrary rebalancing failures where <code>err</code> is neither of those. </p> RemarksIn this latter case (arbitrary error), the application must call rd_kafka_assign(rk, NULL) to synchronize state. <p>For eager/non-cooperative <code>partition.assignment.strategy</code> assignors, such as <code>range</code> and <code>roundrobin</code>, the application must use rd_kafka_assign() to set or clear the entire assignment. For the cooperative assignors, such as <code>cooperative-sticky</code>, the application must use rd_kafka_incremental_assign() for RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS and rd_kafka_incremental_unassign() for RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS.</p> <p>Without a rebalance callback this is done automatically by librdkafka but registering a rebalance callback gives the application flexibility in performing other operations along with the assigning/revocation, such as fetching offsets from an alternate location (on assign) or manually committing offsets (on revoke).</p> <p>rebalance_cb is always triggered exactly once when a rebalance completes with a new assignment, even if that assignment is empty. If an eager/non-cooperative assignor is configured, there will eventually be exactly one corresponding call to rebalance_cb to revoke these partitions (even if empty), whether this is due to a group rebalance or lost partitions. In the cooperative case, rebalance_cb will never be called if the set of partitions being revoked is empty (whether or not lost).</p> <p>The callback's <code>opaque</code> argument is the opaque set with rd_kafka_conf_set_opaque().</p> RemarksThe <code>partitions</code> list is destroyed by librdkafka on return return from the rebalance_cb and must not be freed or saved by the application.  Be careful when modifying the <code>partitions</code> list. Changing this list should only be done to change the initial offsets for each partition. But a function like <code>rd_kafka_position()</code> might have unexpected effects for instance when a consumer gets assigned a partition it used to consume at an earlier rebalance. In this case, the list of partitions will be updated with the old offset for that partition. In this case, it is generally better to pass a copy of the list (see <code>rd_kafka_topic_partition_list_copy()</code>). The result of <code>rd_kafka_position()</code> is typically outdated in RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS. See alsord_kafka_assign()   rd_kafka_incremental_assign()   rd_kafka_incremental_unassign()   rd_kafka_assignment_lost()   rd_kafka_rebalance_protocol() <p>The following example shows the application's responsibilities: </p> <pre><code>static void rebalance_cb (rd_kafka_t *rk, rd_kafka_resp_err_t err,\n                          rd_kafka_topic_partition_list_t *partitions,\n                          void *opaque) {\n\nswitch (err)\n    {\n      case RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS:\n         // application may load offets from arbitrary external\n         // storage here and update \\p partitions\n         if (!strcmp(rd_kafka_rebalance_protocol(rk), \"COOPERATIVE\"))\n                 rd_kafka_incremental_assign(rk, partitions);\n         else // EAGER\n                 rd_kafka_assign(rk, partitions);\n         break;\n\n      case RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS:\n         if (manual_commits) // Optional explicit manual commit\n             rd_kafka_commit(rk, partitions, 0); // sync commit\n\n         if (!strcmp(rd_kafka_rebalance_protocol(rk), \"COOPERATIVE\"))\n                 rd_kafka_incremental_unassign(rk, partitions);\n         else // EAGER\n                 rd_kafka_assign(rk, NULL);\n         break;\n\n      default:\n         handle_unlikely_error(err);\n         rd_kafka_assign(rk, NULL); // sync state\n         break;\n     }\n}</code></pre> RemarksThe above example lacks error handling for assign calls, see the examples/ directory.  Parameters conf <code>\\FFI\\CData|null</code> rd_kafka_conf_t* rebalance_cb <code>\\FFI\\CData|\\Closure</code> void()(rd_kafka_t, rd_kafka_resp_err_t, rd_kafka_topic_partition_list_t*, void*) <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a10db731dc1a295bd9884e4f8cb199311 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_conf_set_resolve_cb","title":"rd_kafka_conf_set_resolve_cb()","text":"<pre><code>public static rd_kafka_conf_set_resolve_cb ( \n    \\FFI\\CData|null $conf, \n    \\FFI\\CData|\\Closure $resolve_cb\n ): void\n</code></pre> <p>Set address resolution callback. </p> <p>The callback is responsible for resolving the hostname <code>node</code> and the service <code>service</code> into a list of socket addresses as <code>getaddrinfo(3)</code> would. The <code>hints</code> and <code>res</code> parameters function as they do for <code>getaddrinfo(3)</code>. The callback's <code>opaque</code> argument is the opaque set with rd_kafka_conf_set_opaque().</p> <p>If the callback is invoked with a NULL <code>node</code>, <code>service</code>, and <code>hints</code>, the callback should instead free the addrinfo struct specified in <code>res</code>. In this case the callback must succeed; the return value will not be checked by the caller.</p> <p>The callback's return value is interpreted as the return value of <code><code>getaddrinfo(3)</code>.</code> </p> RemarksThe callback will be called from an internal librdkafka thread.  Parameters conf <code>\\FFI\\CData|null</code> rd_kafka_conf_t* resolve_cb <code>\\FFI\\CData|\\Closure</code> int()(const char, const char*, const struct addrinfo*, struct addrinfo**, void*) <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a12bbaef85d4168572eea006c5ce0d2eb </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_conf_set_socket_cb","title":"rd_kafka_conf_set_socket_cb()","text":"<pre><code>public static rd_kafka_conf_set_socket_cb ( \n    \\FFI\\CData|null $conf, \n    \\FFI\\CData|\\Closure $socket_cb\n ): void\n</code></pre> <p>Set socket callback. </p> <p>The socket callback is responsible for opening a socket according to the supplied <code>domain</code>, <code>type</code> and <code>protocol</code>. The socket shall be created with <code>CLOEXEC</code> set in a racefree fashion, if possible.</p> <p>The callback's <code>opaque</code> argument is the opaque set with rd_kafka_conf_set_opaque().</p> <p>Default:</p> <ul> <li>on linux: racefree CLOEXEC</li> <li>others : non-racefree CLOEXEC</li> </ul> RemarksThe callback will be called from an internal librdkafka thread.  Parameters conf <code>\\FFI\\CData|null</code> rd_kafka_conf_t* socket_cb <code>\\FFI\\CData|\\Closure</code> int()(int, int, int, void) <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a0467a6c20d5af69a29a63b530962ecbf </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_conf_set_ssl_cert","title":"rd_kafka_conf_set_ssl_cert()","text":"<pre><code>public static rd_kafka_conf_set_ssl_cert ( \n    \\FFI\\CData|null $conf, \n    int $cert_type, \n    int $cert_enc, \n    \\FFI\\CData|object|string|null $buffer, \n    int|null $size, \n    \\FFI\\CData|null $errstr, \n    int|null $errstr_size\n ): int\n</code></pre> <p>Set certificate/key <code>cert_type</code> from the <code>cert_enc</code> encoded memory at <code>buffer</code> of <code>size</code> bytes. </p> RemarksCalling this method multiple times with the same <code>cert_type</code> will replace the previous value.  Calling this method with <code>buffer</code> set to NULL will clear the configuration for <code>cert_type</code>.  The private key may require a password, which must be specified with the <code>ssl.key.password</code> configuration property prior to calling this function.  Private and public keys in PEM format may also be set with the <code>ssl.key.pem</code> and <code>ssl.certificate.pem</code> configuration properties.  CA certificate in PEM format may also be set with the <code>ssl.ca.pem</code> configuration property.  When librdkafka is linked to OpenSSL 3.0 and the certificate is encoded using an obsolete cipher, it might be necessary to set up an OpenSSL configuration file to load the \"legacy\" provider and set the OPENSSL_CONF environment variable. See https://github.com/openssl/openssl/blob/master/README-PROVIDERS.md for more information.  Parameters conf <code>\\FFI\\CData|null</code> rd_kafka_conf_t* - Configuration object. cert_type <code>int</code> rd_kafka_cert_type_t - Certificate or key type to configure. cert_enc <code>int</code> rd_kafka_cert_enc_t - Buffer <code>encoding</code> type. buffer <code>\\FFI\\CData|object|string|null</code> const void* - Memory pointer to encoded certificate or key. The memory is not referenced after this function returns. size <code>int|null</code> size_t - Size of memory at <code>buffer</code>. errstr <code>\\FFI\\CData|null</code> char* - Memory were a human-readable error string will be written on failure. errstr_size <code>int|null</code> size_t - Size of <code>errstr</code>, including space for nul-terminator. Returns <code>int</code> rd_kafka_conf_res_t - RD_KAFKA_CONF_OK on success or RD_KAFKA_CONF_INVALID if the memory in <code>buffer</code> is of incorrect encoding, or if librdkafka was not built with SSL support. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a55fa4d223e6214b7be94a87f9985177a </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_conf_set_ssl_cert_verify_cb","title":"rd_kafka_conf_set_ssl_cert_verify_cb()","text":"<pre><code>public static rd_kafka_conf_set_ssl_cert_verify_cb ( \n    \\FFI\\CData|null $conf, \n    \\FFI\\CData|\\Closure $ssl_cert_verify_cb\n ): int\n</code></pre> <p>Sets the verification callback of the broker certificate. </p> <p>The verification callback is triggered from internal librdkafka threads upon connecting to a broker. On each connection attempt the callback will be called for each certificate in the broker's certificate chain, starting at the root certification, as long as the application callback returns 1 (valid certificate). <code>broker_name</code> and <code>broker_id</code> correspond to the broker the connection is being made to. The <code>x509_error</code> argument indicates if OpenSSL's verification of the certificate succeed (0) or failed (an OpenSSL error code). The application may set the SSL context error code by returning 0 from the verify callback and providing a non-zero SSL context error code in <code>x509_error</code>. If the verify callback sets <code>x509_error</code> to 0, returns 1, and the original <code>x509_error</code> was non-zero, the error on the SSL context will be cleared. <code>x509_error</code> is always a valid pointer to an int.</p> <p><code>depth</code> is the depth of the current certificate in the chain, starting at the root certificate.</p> <p>The certificate itself is passed in binary DER format in <code>buf</code> of size <code>size</code>.</p> <p>The callback must return 1 if verification succeeds, or 0 if verification fails and then write a human-readable error message to <code>errstr</code> (limited to <code>errstr_size</code> bytes, including nul-term).</p> <p>The callback's <code>opaque</code> argument is the opaque set with rd_kafka_conf_set_opaque().</p> WarningThis callback will be called from internal librdkafka threads. RemarksSee &lt;openssl/x509_vfy.h&gt; in the OpenSSL source distribution for a list of <code>x509_error</code> codes.  Parameters conf <code>\\FFI\\CData|null</code> rd_kafka_conf_t* ssl_cert_verify_cb <code>\\FFI\\CData|\\Closure</code> int()(rd_kafka_t, const char*, int32_t, int*, int, const char*, size_t, char*, size_t, void*) Returns <code>int</code> rd_kafka_conf_res_t - RD_KAFKA_CONF_OK if SSL is supported in this build, else RD_KAFKA_CONF_INVALID. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ae0b29e178bc565c9b8b3d5dfc60c18c5 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_conf_set_stats_cb","title":"rd_kafka_conf_set_stats_cb()","text":"<pre><code>public static rd_kafka_conf_set_stats_cb ( \n    \\FFI\\CData|null $conf, \n    \\FFI\\CData|\\Closure $stats_cb\n ): void\n</code></pre> <p>Set statistics callback in provided conf object. </p> <p>The statistics callback is triggered from rd_kafka_poll() every <code>statistics.interval.ms</code> (needs to be configured separately). Function arguments:</p> <ul> <li><code>rk</code> - Kafka handle</li> <li><code>json</code> - String containing the statistics data in JSON format</li> <li><code>json_len</code> - Length of <code>json</code> string.</li> <li><code>opaque</code> - Application-provided opaque as set by rd_kafka_conf_set_opaque().</li> </ul> <p>For more information on the format of <code>json</code>, see https://github.com/confluentinc/librdkafka/wiki/Statistics</p> <p>If the application wishes to hold on to the <code>json</code> pointer and free it at a later time it must return 1 from the <code>stats_cb</code>. If the application returns 0 from the <code>stats_cb</code> then librdkafka will immediately free the <code>json</code> pointer.</p> <p>See STATISTICS.md for a full definition of the JSON object. </p> Parameters conf <code>\\FFI\\CData|null</code> rd_kafka_conf_t* stats_cb <code>\\FFI\\CData|\\Closure</code> int()(rd_kafka_t, char*, size_t, void*) <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a597d00432e3ca22174d18e7e348fb766 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_conf_set_throttle_cb","title":"rd_kafka_conf_set_throttle_cb()","text":"<pre><code>public static rd_kafka_conf_set_throttle_cb ( \n    \\FFI\\CData|null $conf, \n    \\FFI\\CData|\\Closure $throttle_cb\n ): void\n</code></pre> <p>Set throttle callback. </p> <p>The throttle callback is used to forward broker throttle times to the application for Produce and Fetch (consume) requests.</p> <p>Callbacks are triggered whenever a non-zero throttle time is returned by the broker, or when the throttle time drops back to zero.</p> <p>An application must call rd_kafka_poll() or rd_kafka_consumer_poll() at regular intervals to serve queued callbacks.</p> <p>The callback's <code>opaque</code> argument is the opaque set with rd_kafka_conf_set_opaque().</p> RemarksRequires broker version 0.9.0 or later.  Parameters conf <code>\\FFI\\CData|null</code> rd_kafka_conf_t* throttle_cb <code>\\FFI\\CData|\\Closure</code> void()(rd_kafka_t, const char*, int32_t, int, void*) <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a04160826ad039d42c10edec456163fa7 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_consume","title":"rd_kafka_consume()","text":"<pre><code>public static rd_kafka_consume ( \n    \\FFI\\CData|null $rkt, \n    int|null $partition, \n    int|null $timeout_ms\n ): \\FFI\\CData|null\n</code></pre> <p>Consume a single message from topic <code>rkt</code> and <code>partition</code>. </p> <p><code>timeout_ms</code> is maximum amount of time to wait for a message to be received. Consumer must have been previously started with <code>rd_kafka_consume_start()</code>.</p> <p>Errors (when returning NULL):</p> <ul> <li>ETIMEDOUT - <code>timeout_ms</code> was reached with no new messages fetched.</li> <li>ENOENT - <code>rkt</code> + <code>partition</code> is unknown. (no prior <code>rd_kafka_consume_start()</code> call)</li> </ul> <p>NOTE: The returned message's <code></code>..-&gt;err must be checked for errors. NOTE: <code></code>..-&gt;err <code>==</code> <code>RD_KAFKA_RESP_ERR__PARTITION_EOF</code> signals that the end of the partition has been reached, which should typically not be considered an error. The application should handle this case (e.g., ignore).</p> Remarkson_consume() interceptors may be called from this function prior to passing message to application.  Parameters rkt <code>\\FFI\\CData|null</code> rd_kafka_topic_t* partition <code>int|null</code> int32_t timeout_ms <code>int|null</code> int Returns <code>\\FFI\\CData|null</code> rd_kafka_message_t* - a message object on success or <code>NULL</code> on error. The message object must be destroyed with <code>rd_kafka_message_destroy()</code> when the application is done with it. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aa49d14e8b742365f9f25d35318ff0b7e </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_consume_batch","title":"rd_kafka_consume_batch()","text":"<pre><code>public static rd_kafka_consume_batch ( \n    \\FFI\\CData|null $rkt, \n    int|null $partition, \n    int|null $timeout_ms, \n    \\FFI\\CData|null $rkmessages, \n    int|null $rkmessages_size\n ): int|null\n</code></pre> <p>Consume up to <code>rkmessages_size</code> from topic <code>rkt</code> and <code>partition</code> putting a pointer to each message in the application provided array <code>rkmessages</code> (of size <code>rkmessages_size</code> entries). </p> <p><code>rd_kafka_consume_batch()</code> provides higher throughput performance than <code>rd_kafka_consume()</code>.</p> <p><code>timeout_ms</code> is the maximum amount of time to wait for all of <code>rkmessages_size</code> messages to be put into <code>rkmessages</code>. If no messages were available within the timeout period this function returns 0 and <code>rkmessages</code> remains untouched. This differs somewhat from <code>rd_kafka_consume()</code>.</p> <p>The message objects must be destroyed with <code>rd_kafka_message_destroy()</code> when the application is done with it.</p> See alsord_kafka_consume() Remarkson_consume() interceptors may be called from this function prior to passing message to application.  Parameters rkt <code>\\FFI\\CData|null</code> rd_kafka_topic_t* partition <code>int|null</code> int32_t timeout_ms <code>int|null</code> int rkmessages <code>\\FFI\\CData|null</code> rd_kafka_message_t** rkmessages_size <code>int|null</code> size_t Returns <code>int|null</code> ssize_t - the number of rkmessages added in <code>rkmessages</code>, or -1 on error (same error codes as for <code>rd_kafka_consume()</code>. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a53511739a2cf498b8d88287fef6873ce </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_consume_batch_queue","title":"rd_kafka_consume_batch_queue()","text":"<pre><code>public static rd_kafka_consume_batch_queue ( \n    \\FFI\\CData|null $rkqu, \n    int|null $timeout_ms, \n    \\FFI\\CData|null $rkmessages, \n    int|null $rkmessages_size\n ): int|null\n</code></pre> <p>Consume batch of messages from queue. </p> See alsord_kafka_consume_batch()  Parameters rkqu <code>\\FFI\\CData|null</code> rd_kafka_queue_t* timeout_ms <code>int|null</code> int rkmessages <code>\\FFI\\CData|null</code> rd_kafka_message_t** rkmessages_size <code>int|null</code> size_t Returns <code>int|null</code> ssize_t <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a3d949238471993b18537855aad28fa23 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_consume_callback","title":"rd_kafka_consume_callback()","text":"<pre><code>public static rd_kafka_consume_callback ( \n    \\FFI\\CData|null $rkt, \n    int|null $partition, \n    int|null $timeout_ms, \n    \\FFI\\CData|\\Closure $consume_cb, \n    \\FFI\\CData|object|string|null $opaque\n ): int|null\n</code></pre> <p>Consumes messages from topic <code>rkt</code> and <code>partition</code>, calling the provided callback for each consumed messsage. </p> <p><code>rd_kafka_consume_callback()</code> provides higher throughput performance than both <code>rd_kafka_consume()</code> and <code>rd_kafka_consume_batch()</code>.</p> <p><code>timeout_ms</code> is the maximum amount of time to wait for one or more messages to arrive.</p> <p>The provided <code>consume_cb</code> function is called for each message, the application MUST NOT call <code>rd_kafka_message_destroy()</code> on the provided <code>rkmessage</code>.</p> <p>The <code>commit_opaque</code> argument is passed to the <code>consume_cb</code> as <code>commit_opaque</code>.</p> See alsord_kafka_consume() Remarkson_consume() interceptors may be called from this function prior to passing message to application.  This function will return early if a transaction control message is received, these messages are not exposed to the application but still enqueued on the consumer queue to make sure their offsets are stored. Deprecated:This API is deprecated and subject for future removal. There is no new callback-based consume interface, use the poll/queue based alternatives.  Parameters rkt <code>\\FFI\\CData|null</code> rd_kafka_topic_t* partition <code>int|null</code> int32_t timeout_ms <code>int|null</code> int consume_cb <code>\\FFI\\CData|\\Closure</code> void()(rd_kafka_message_t, void*) opaque <code>\\FFI\\CData|object|string|null</code> void* Returns <code>int|null</code> int - the number of messages processed or -1 on error. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a570e099baed990e9966e5e9a65eb7b00 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_consume_callback_queue","title":"rd_kafka_consume_callback_queue()","text":"<pre><code>public static rd_kafka_consume_callback_queue ( \n    \\FFI\\CData|null $rkqu, \n    int|null $timeout_ms, \n    \\FFI\\CData|\\Closure $consume_cb, \n    \\FFI\\CData|object|string|null $opaque\n ): int|null\n</code></pre> <p>Consume multiple messages from queue with callback. </p> See alsord_kafka_consume_callback() Deprecated:This API is deprecated and subject for future removal. There is no new callback-based consume interface, use the poll/queue based alternatives.  Parameters rkqu <code>\\FFI\\CData|null</code> rd_kafka_queue_t* timeout_ms <code>int|null</code> int consume_cb <code>\\FFI\\CData|\\Closure</code> void()(rd_kafka_message_t, void*) opaque <code>\\FFI\\CData|object|string|null</code> void* Returns <code>int|null</code> int <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a4632ec35e579f9051164f7171940c243 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_consume_queue","title":"rd_kafka_consume_queue()","text":"<pre><code>public static rd_kafka_consume_queue ( \n    \\FFI\\CData|null $rkqu, \n    int|null $timeout_ms\n ): \\FFI\\CData|null\n</code></pre> <p>Consume from queue. </p> See alsord_kafka_consume()  Parameters rkqu <code>\\FFI\\CData|null</code> rd_kafka_queue_t* timeout_ms <code>int|null</code> int Returns <code>\\FFI\\CData|null</code> rd_kafka_message_t* <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8ff0b80fccb3a5bd31b1baaf20e4ca16 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_consume_start","title":"rd_kafka_consume_start()","text":"<pre><code>public static rd_kafka_consume_start ( \n    \\FFI\\CData|null $rkt, \n    int|null $partition, \n    int|null $offset\n ): int|null\n</code></pre> <p>Start consuming messages for topic <code>rkt</code> and <code>partition</code> at offset <code>offset</code> which may either be an absolute <code></code>(0..N) or one of the logical offsets: </p> <ul> <li>RD_KAFKA_OFFSET_BEGINNING</li> <li>RD_KAFKA_OFFSET_END</li> <li>RD_KAFKA_OFFSET_STORED</li> <li>RD_KAFKA_OFFSET_TAIL</li> </ul> <p>rdkafka will attempt to keep <code>queued.min.messages</code> (config property) messages in the local queue by repeatedly fetching batches of messages from the broker until the threshold is reached.</p> <p>The application shall use one of the <code>rd_kafka_consume*()</code> functions to consume messages from the local queue, each kafka message being represented as a <code>rd_kafka_message_t *</code> object.</p> <p><code>rd_kafka_consume_start()</code> must not be called multiple times for the same topic and partition without stopping consumption first with <code>rd_kafka_consume_stop()</code>.</p> <p>Use <code>rd_kafka_errno2err()</code> to convert sytem <code>errno</code> to <code>rd_kafka_resp_err_t</code> </p> Parameters rkt <code>\\FFI\\CData|null</code> rd_kafka_topic_t* partition <code>int|null</code> int32_t offset <code>int|null</code> int64_t Returns <code>int|null</code> int - 0 on success or -1 on error in which case errno is set accordingly:<ul> <li>EBUSY - Conflicts with an existing or previous subscription (RD_KAFKA_RESP_ERR__CONFLICT)</li> <li>EINVAL - Invalid offset, or incomplete configuration (lacking group.id) (RD_KAFKA_RESP_ERR__INVALID_ARG)</li> <li>ESRCH - requested <code>partition</code> is invalid. (RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION)</li> <li>ENOENT - topic is unknown in the Kafka cluster. (RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC)</li> </ul> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ae21dcd2d8c6195baf7f9f4952d7e12d4 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_consume_start_queue","title":"rd_kafka_consume_start_queue()","text":"<pre><code>public static rd_kafka_consume_start_queue ( \n    \\FFI\\CData|null $rkt, \n    int|null $partition, \n    int|null $offset, \n    \\FFI\\CData|null $rkqu\n ): int|null\n</code></pre> <p>Same as rd_kafka_consume_start() but re-routes incoming messages to the provided queue <code>rkqu</code> (which must have been previously allocated with <code>rd_kafka_queue_new()</code>. </p> <p>The application must use one of the <code>rd_kafka_consume_*_queue()</code> functions to receive fetched messages.</p> <p><code>rd_kafka_consume_start_queue()</code> must not be called multiple times for the same topic and partition without stopping consumption first with <code>rd_kafka_consume_stop()</code>. <code>rd_kafka_consume_start()</code> and <code>rd_kafka_consume_start_queue()</code> must not be combined for the same topic and partition. </p> Parameters rkt <code>\\FFI\\CData|null</code> rd_kafka_topic_t* partition <code>int|null</code> int32_t offset <code>int|null</code> int64_t rkqu <code>\\FFI\\CData|null</code> rd_kafka_queue_t* Returns <code>int|null</code> int <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8e952d7961169471f69c7ddc87041258 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_consume_stop","title":"rd_kafka_consume_stop()","text":"<pre><code>public static rd_kafka_consume_stop ( \n    \\FFI\\CData|null $rkt, \n    int|null $partition\n ): int|null\n</code></pre> <p>Stop consuming messages for topic <code>rkt</code> and <code>partition</code>, purging all messages currently in the local queue. </p> <p>NOTE: To enforce synchronisation this call will block until the internal fetcher has terminated and offsets are committed to configured storage method.</p> <p>The application needs to be stop all consumers before calling <code>rd_kafka_destroy()</code> on the main object handle.</p> Parameters rkt <code>\\FFI\\CData|null</code> rd_kafka_topic_t* partition <code>int|null</code> int32_t Returns <code>int|null</code> int - 0 on success or -1 on error (see <code>errno</code>). <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#acf07475e5e85e63fc5321a1087288cd4 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_consumer_close","title":"rd_kafka_consumer_close()","text":"<pre><code>public static rd_kafka_consumer_close ( \n    \\FFI\\CData|null $rk\n ): int\n</code></pre> <p>Close the consumer. </p> <p>This call will block until the consumer has revoked its assignment, calling the <code>rebalance_cb</code> if it is configured, committed offsets to broker, and left the consumer group (if applicable). The maximum blocking time is roughly limited to session.timeout.ms.</p> RemarksThe application still needs to call rd_kafka_destroy() after this call finishes to clean up the underlying handle resources.  Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* - ) Returns <code>int</code> rd_kafka_resp_err_t - An error code indicating if the consumer close was succesful or not. RD_KAFKA_RESP_ERR__FATAL is returned if the consumer has raised a fatal error. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a37b54d329e12d745889defe96e7d043d </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_consumer_close_queue","title":"rd_kafka_consumer_close_queue()","text":"<pre><code>public static rd_kafka_consumer_close_queue ( \n    \\FFI\\CData|null $rk, \n    \\FFI\\CData|null $rkqu\n ): \\FFI\\CData|null\n</code></pre> <p>Asynchronously close the consumer. </p> <p>Performs the same actions as rd_kafka_consumer_close() but in a background thread.</p> <p>Rebalance events/callbacks (etc) will be forwarded to the application-provided <code>rkqu</code>. The application must poll/serve this queue until rd_kafka_consumer_closed() returns true.</p> RemarksDepending on consumer group join state there may or may not be rebalance events emitted on <code>rkqu</code>. See alsord_kafka_consumer_closed()  Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* rkqu <code>\\FFI\\CData|null</code> rd_kafka_queue_t* Returns <code>\\FFI\\CData|null</code> rd_kafka_error_t* - an error object if the consumer close failed, else NULL. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a9dd5c18bdfed81c8847b259f0a8d498d </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_consumer_closed","title":"rd_kafka_consumer_closed()","text":"<pre><code>public static rd_kafka_consumer_closed ( \n    \\FFI\\CData|null $rk\n ): int|null\n</code></pre> <p>Should be used in conjunction with rd_kafka_consumer_close_queue() to know when the consumer has been closed.</p> See alsord_kafka_consumer_close_queue()  Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* - ) Returns <code>int|null</code> int - 1 if the consumer is closed, else 0. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a88197205c61ed98b99f6442551a5e94f </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_consumer_group_metadata","title":"rd_kafka_consumer_group_metadata()","text":"<pre><code>public static rd_kafka_consumer_group_metadata ( \n    \\FFI\\CData|null $rk\n ): \\FFI\\CData|null\n</code></pre> RemarksThe returned pointer must be freed by the application using rd_kafka_consumer_group_metadata_destroy(). See alsord_kafka_send_offsets_to_transaction()  Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* - ) Returns <code>\\FFI\\CData|null</code> rd_kafka_consumer_group_metadata_t* - the current consumer group metadata associated with this consumer, or NULL if <code>rk</code> is not a consumer configured with a <code>group.id</code>. This metadata object should be passed to the transactional producer\u2019s rd_kafka_send_offsets_to_transaction() API. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a167fe52efc68d470291bf17757b62c2e </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_consumer_group_metadata_destroy","title":"rd_kafka_consumer_group_metadata_destroy()","text":"<pre><code>public static rd_kafka_consumer_group_metadata_destroy ( \n    \\FFI\\CData|null $arg0\n ): void\n</code></pre> Parameters arg0 <code>\\FFI\\CData|null</code> rd_kafka_consumer_group_metadata_t*"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_consumer_group_metadata_generation_id","title":"rd_kafka_consumer_group_metadata_generation_id()","text":"<pre><code>public static rd_kafka_consumer_group_metadata_generation_id ( \n    \\FFI\\CData|null $group_metadata\n ): int|null\n</code></pre> <p>Get the generation id (classic protocol) or member epoch (consumer protocol) of a group metadata. </p> Parameters group_metadata <code>\\FFI\\CData|null</code> const rd_kafka_consumer_group_metadata_t* - ) - The group metadata. Returns <code>int|null</code> int32_t - The generation id or member epoch contained in the passed <code>group_metadata</code>. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a851a24b70797902f3600a4650b7f82f0 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_consumer_group_metadata_group_id","title":"rd_kafka_consumer_group_metadata_group_id()","text":"<pre><code>public static rd_kafka_consumer_group_metadata_group_id ( \n    \\FFI\\CData|null $group_metadata\n ): string|null\n</code></pre> <p>Get group id of a group metadata. </p> RemarksThe returned pointer has the same lifetime as <code>group_metadata</code>.  Parameters group_metadata <code>\\FFI\\CData|null</code> const rd_kafka_consumer_group_metadata_t* - ) - The group metadata. Returns <code>string|null</code> const char* - The group id contained in the passed <code>group_metadata</code>. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ab916ea76159290e3f1e644c40816a042 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_consumer_group_metadata_group_instance_id","title":"rd_kafka_consumer_group_metadata_group_instance_id()","text":"<pre><code>public static rd_kafka_consumer_group_metadata_group_instance_id ( \n    \\FFI\\CData|null $group_metadata\n ): string|null\n</code></pre> <p>Get group instance id of a group metadata. </p> RemarksThe returned pointer has the same lifetime as <code>group_metadata</code>.  Parameters group_metadata <code>\\FFI\\CData|null</code> const rd_kafka_consumer_group_metadata_t* - ) - The group metadata. Returns <code>string|null</code> const char* - The group instance id contained in the passed <code>group_metadata</code> or NULL. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ad74ae94a86e81db03afcd772fad96c45 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_consumer_group_metadata_member_id","title":"rd_kafka_consumer_group_metadata_member_id()","text":"<pre><code>public static rd_kafka_consumer_group_metadata_member_id ( \n    \\FFI\\CData|null $group_metadata\n ): string|null\n</code></pre> <p>Get member id of a group metadata. </p> RemarksThe returned pointer has the same lifetime as <code>group_metadata</code>.  Parameters group_metadata <code>\\FFI\\CData|null</code> const rd_kafka_consumer_group_metadata_t* - ) - The group metadata. Returns <code>string|null</code> const char* - The member id contained in the passed <code>group_metadata</code>. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a2d472b3e20962fd2027d6a99f85e5149 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_consumer_group_metadata_new","title":"rd_kafka_consumer_group_metadata_new()","text":"<pre><code>public static rd_kafka_consumer_group_metadata_new ( \n    string|null $group_id\n ): \\FFI\\CData|null\n</code></pre> <p>Create a new consumer group metadata object. This is typically only used for writing tests. </p> RemarksThe returned pointer must be freed by the application using rd_kafka_consumer_group_metadata_destroy().  Parameters group_id <code>string|null</code> const char* - ) - The group id. Returns <code>\\FFI\\CData|null</code> rd_kafka_consumer_group_metadata_t* <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a30dc0292d9f172832451905fd6c28b22 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_consumer_group_metadata_new_with_genid","title":"rd_kafka_consumer_group_metadata_new_with_genid()","text":"<pre><code>public static rd_kafka_consumer_group_metadata_new_with_genid ( \n    string|null $group_id, \n    int|null $generation_id, \n    string|null $member_id, \n    string|null $group_instance_id\n ): \\FFI\\CData|null\n</code></pre> <p>Create a new consumer group metadata object. This is typically only used for writing tests. </p> RemarksThe returned pointer must be freed by the application using rd_kafka_consumer_group_metadata_destroy().  Parameters group_id <code>string|null</code> const char* - The group id. generation_id <code>int|null</code> int32_t - The group generation id. member_id <code>string|null</code> const char* - The group member id. group_instance_id <code>string|null</code> const char* - The group instance id (may be NULL). Returns <code>\\FFI\\CData|null</code> rd_kafka_consumer_group_metadata_t* <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a679b7a0b807f69b72a4088bcee0e13c9 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_consumer_group_metadata_read","title":"rd_kafka_consumer_group_metadata_read()","text":"<pre><code>public static rd_kafka_consumer_group_metadata_read ( \n    \\FFI\\CData|null $cgmdp, \n    \\FFI\\CData|object|string|null $buffer, \n    int|null $size\n ): \\FFI\\CData|null\n</code></pre> <p>Reads serialized consumer group metadata and returns a consumer group metadata object. This is mainly for client binding use and not for application use. </p> RemarksThe serialized metadata format is private and is not compatible across different versions or even builds of librdkafka. It should only be used in the same process runtime and must only be passed to rd_kafka_consumer_group_metadata_read(). See alsord_kafka_consumer_group_metadata_write()  Parameters cgmdp <code>\\FFI\\CData|null</code> rd_kafka_consumer_group_metadata_t** - On success this pointer will be updated to point to a new consumer group metadata object which must be freed with rd_kafka_consumer_group_metadata_destroy(). buffer <code>\\FFI\\CData|object|string|null</code> const void* - Pointer to the serialized data. size <code>int|null</code> size_t - Size of the serialized data. Returns <code>\\FFI\\CData|null</code> rd_kafka_error_t* - NULL on success or an error object on failure. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ad3719a32498a270c04a48d64f2f301b3 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_consumer_group_metadata_write","title":"rd_kafka_consumer_group_metadata_write()","text":"<pre><code>public static rd_kafka_consumer_group_metadata_write ( \n    \\FFI\\CData|null $cgmd, \n    \\FFI\\CData|object|string|null $bufferp, \n    \\FFI\\CData|null $sizep\n ): \\FFI\\CData|null\n</code></pre> <p>Serialize the consumer group metadata to a binary format. This is mainly for client binding use and not for application use. </p> RemarksThe serialized metadata format is private and is not compatible across different versions or even builds of librdkafka. It should only be used in the same process runtime and must only be passed to rd_kafka_consumer_group_metadata_read(). See alsord_kafka_consumer_group_metadata_read()  Parameters cgmd <code>\\FFI\\CData|null</code> const rd_kafka_consumer_group_metadata_t* - Metadata to be serialized. bufferp <code>\\FFI\\CData|object|string|null</code> void** - On success this pointer will be updated to point to na allocated buffer containing the serialized metadata. The buffer must be freed with rd_kafka_mem_free(). sizep <code>\\FFI\\CData|null</code> size_t* - The pointed to size will be updated with the size of the serialized buffer. Returns <code>\\FFI\\CData|null</code> rd_kafka_error_t* - NULL on success or an error object on failure. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aef280384f33889a4dfe02d92186f5928 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_consumer_group_state_code","title":"rd_kafka_consumer_group_state_code()","text":"<pre><code>public static rd_kafka_consumer_group_state_code ( \n    string|null $name\n ): int\n</code></pre> <p>Returns a code for a state name. </p> Parameters name <code>string|null</code> const char* - ) - The state name. Returns <code>int</code> rd_kafka_consumer_group_state_t - The group state value corresponding to the provided group state name. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a5d7d4a9967f81749cf8bd2b898021d80 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_consumer_group_state_name","title":"rd_kafka_consumer_group_state_name()","text":"<pre><code>public static rd_kafka_consumer_group_state_name ( \n    int $state\n ): string|null\n</code></pre> <p>Returns a name for a state code. </p> Parameters state <code>int</code> rd_kafka_consumer_group_state_t - ) - The state value. Returns <code>string|null</code> const char* - The group state name corresponding to the provided group state value. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aa9e2cac6e414980eef365394d06014f4 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_consumer_group_type_code","title":"rd_kafka_consumer_group_type_code()","text":"<pre><code>public static rd_kafka_consumer_group_type_code ( \n    string|null $name\n ): int\n</code></pre> <p>Returns a code for a group type name. </p> RemarksThe comparison is case-insensitive. Parameters name <code>string|null</code> const char* - ) - The group type name. Returns <code>int</code> rd_kafka_consumer_group_type_t - The group type value corresponding to the provided group type name. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ac2557eeb2e89bce046100adbee25c3dc </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_consumer_group_type_name","title":"rd_kafka_consumer_group_type_name()","text":"<pre><code>public static rd_kafka_consumer_group_type_name ( \n    int $type\n ): string|null\n</code></pre> <p>Returns a name for a group type code. </p> Parameters type <code>int</code> rd_kafka_consumer_group_type_t - ) - The group type value. Returns <code>string|null</code> const char* - The group type name corresponding to the provided group type value. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aa1832cc57552f789d1e27faaa93943d1 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_consumer_poll","title":"rd_kafka_consumer_poll()","text":"<pre><code>public static rd_kafka_consumer_poll ( \n    \\FFI\\CData|null $rk, \n    int|null $timeout_ms\n ): \\FFI\\CData|null\n</code></pre> <p>Poll the consumer for messages or events. </p> <p>Will block for at most <code>timeout_ms</code> milliseconds.</p> RemarksAn application should make sure to call consumer_poll() at regular intervals, even if no messages are expected, to serve any queued callbacks waiting to be called. This is especially important when a rebalance_cb has been registered as it needs to be called and handled properly to synchronize internal consumer state. Remarkson_consume() interceptors may be called from this function prior to passing message to application.  When subscribing to topics the application must call poll at least every <code>max.poll.interval.ms</code> to remain a member of the consumer group. <p>Noteworthy errors returned in <code>-&gt;err:</code> </p> <ul> <li>RD_KAFKA_RESP_ERR__MAX_POLL_EXCEEDED - application failed to call poll within <code>max.poll.interval.ms</code>.</li> </ul> See alsord_kafka_message_t  Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* timeout_ms <code>int|null</code> int Returns <code>\\FFI\\CData|null</code> rd_kafka_message_t* - A message object which is a proper message if <code>-&gt;err</code> is RD_KAFKA_RESP_ERR_NO_ERROR, or an event or error for any other value. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a65cc6cb9bd72c4084f074af0361ceddf </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_controllerid","title":"rd_kafka_controllerid()","text":"<pre><code>public static rd_kafka_controllerid ( \n    \\FFI\\CData|null $rk, \n    int|null $timeout_ms\n ): int|null\n</code></pre> <p>Returns the current ControllerId as reported in broker metadata. </p> RemarksRequires broker version &gt;=0.10.0 and api.version.request=true. Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* - Client instance. timeout_ms <code>int|null</code> int - If there is no cached value from metadata retrieval then this specifies the maximum amount of time (in milliseconds) the call will block waiting for metadata to be retrieved. Use 0 for non-blocking calls. Returns <code>int|null</code> int32_t - the controller broker id (&gt;= 0), or -1 if no ControllerId could be retrieved in the allotted timespan. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#abcf5d443b9af5e6ac252dae1c94ea68f </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_default_topic_conf_dup","title":"rd_kafka_default_topic_conf_dup()","text":"<pre><code>public static rd_kafka_default_topic_conf_dup ( \n    \\FFI\\CData|null $rk\n ): \\FFI\\CData|null\n</code></pre> Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* Returns <code>\\FFI\\CData|null</code> rd_kafka_topic_conf_t*"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_destroy","title":"rd_kafka_destroy()","text":"<pre><code>public static rd_kafka_destroy ( \n    \\FFI\\CData|null $rk\n ): void\n</code></pre> <p>Destroy Kafka handle. </p> RemarksThis is a blocking operation.   rd_kafka_consumer_close() will be called from this function if the instance type is RD_KAFKA_CONSUMER, a <code>group.id</code> was configured, and the rd_kafka_consumer_close() was not explicitly called by the application. This in turn may trigger consumer callbacks, such as rebalance_cb. Use rd_kafka_destroy_flags() with RD_KAFKA_DESTROY_F_NO_CONSUMER_CLOSE to avoid this behaviour. See alsord_kafka_destroy_flags()  Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* - ) <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ac052e92621dcaa3a336dbf826e0d7794 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_destroy_flags","title":"rd_kafka_destroy_flags()","text":"<pre><code>public static rd_kafka_destroy_flags ( \n    \\FFI\\CData|null $rk, \n    int|null $flags\n ): void\n</code></pre> Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* flags <code>int|null</code> int"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_dump","title":"rd_kafka_dump()","text":"<pre><code>public static rd_kafka_dump ( \n    \\FFI\\CData|null $fp, \n    \\FFI\\CData|null $rk\n ): void\n</code></pre> <p>Dumps rdkafka's internal state for handle <code>rk</code> to stream <code>fp</code>. </p> <p>This is only useful for debugging rdkafka, showing state and statistics for brokers, topics, partitions, etc. </p> Parameters fp <code>\\FFI\\CData|null</code> FILE* rk <code>\\FFI\\CData|null</code> rd_kafka_t* <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a27a46f74ec4ccc9c0b36dbcf546908a1 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_err2name","title":"rd_kafka_err2name()","text":"<pre><code>public static rd_kafka_err2name ( \n    int $err\n ): string|null\n</code></pre> <p>Returns the error code name (enum name). </p> Parameters err <code>int</code> rd_kafka_resp_err_t - ) - Error code to translate Returns <code>string|null</code> const char* <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8d5f6f2775ec67b124abeb5dfada2d77 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_err2str","title":"rd_kafka_err2str()","text":"<pre><code>public static rd_kafka_err2str ( \n    int $err\n ): string|null\n</code></pre> <p>Returns a human readable representation of a kafka error. </p> Parameters err <code>int</code> rd_kafka_resp_err_t - ) - Error code to translate Returns <code>string|null</code> const char* <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ab7bfc925e8d63851511b88a1cee94d6d </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_errno","title":"rd_kafka_errno()","text":"<pre><code>public static rd_kafka_errno (  ): int|null\n</code></pre> <p>Returns the thread-local system errno. </p> <p>On most platforms this is the same as <code>errno</code> but in case of different runtimes between library and application (e.g., Windows static DLLs) this provides a means for exposing the errno librdkafka uses.</p> RemarksThe value is local to the current calling thread. Deprecated:Use rd_kafka_last_error() to retrieve the last error code set by the legacy librdkafka APIs.  Returns <code>int|null</code> int - ) <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8aa1b1a41d2fc0c487f519663609df4f </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_errno2err","title":"rd_kafka_errno2err()","text":"<pre><code>public static rd_kafka_errno2err ( \n    int|null $errnox\n ): int\n</code></pre> <p>Converts the system errno value <code>errnox</code> to a rd_kafka_resp_err_t error code upon failure from the following functions: </p> <ul> <li>rd_kafka_topic_new()</li> <li>rd_kafka_consume_start()</li> <li>rd_kafka_consume_stop()</li> <li>rd_kafka_consume()</li> <li>rd_kafka_consume_batch()</li> <li>rd_kafka_consume_callback()</li> <li>rd_kafka_consume_queue()</li> <li>rd_kafka_produce()</li> </ul> RemarksA better alternative is to call rd_kafka_last_error() immediately after any of the above functions return -1 or NULL. Deprecated:Use rd_kafka_last_error() to retrieve the last error code set by the legacy librdkafka APIs. See alsord_kafka_last_error()  Parameters errnox <code>int|null</code> int - ) - System errno value to convert Returns <code>int</code> rd_kafka_resp_err_t - Appropriate error code for <code>errnox</code> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#abeabf8589c657d7a3ec5a1411a7de91d </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_error_code","title":"rd_kafka_error_code()","text":"<pre><code>public static rd_kafka_error_code ( \n    \\FFI\\CData|null $error\n ): int\n</code></pre> Parameters error <code>\\FFI\\CData|null</code> const rd_kafka_error_t* - ) Returns <code>int</code> rd_kafka_resp_err_t - the error code for <code>error</code> or RD_KAFKA_RESP_ERR_NO_ERROR if <code>error</code> is NULL. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a6b4f430e5cc4f8b89ec23aaa5063b739 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_error_destroy","title":"rd_kafka_error_destroy()","text":"<pre><code>public static rd_kafka_error_destroy ( \n    \\FFI\\CData|null $error\n ): void\n</code></pre> <p>Free and destroy an error object. </p> RemarksAs a conveniance it is permitted to pass a NULL <code>error</code>.  Parameters error <code>\\FFI\\CData|null</code> rd_kafka_error_t* - ) <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a3090ec84b9a8aa910d11f81f555d04da </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_error_is_fatal","title":"rd_kafka_error_is_fatal()","text":"<pre><code>public static rd_kafka_error_is_fatal ( \n    \\FFI\\CData|null $error\n ): int|null\n</code></pre> Parameters error <code>\\FFI\\CData|null</code> const rd_kafka_error_t* - ) Returns <code>int|null</code> int - 1 if the error is a fatal error, indicating that the client instance is no longer usable, else 0 (also if <code>error</code> is NULL). <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a97ba623d3eadd7f6b64800c31e28b2d2 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_error_is_retriable","title":"rd_kafka_error_is_retriable()","text":"<pre><code>public static rd_kafka_error_is_retriable ( \n    \\FFI\\CData|null $error\n ): int|null\n</code></pre> Parameters error <code>\\FFI\\CData|null</code> const rd_kafka_error_t* - ) Returns <code>int|null</code> int - 1 if the operation may be retried, else 0 (also if <code>error</code> is NULL). <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#acc4ee1ecb953e1a409528a99ab0c5451 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_error_name","title":"rd_kafka_error_name()","text":"<pre><code>public static rd_kafka_error_name ( \n    \\FFI\\CData|null $error\n ): string|null\n</code></pre> RemarksThe lifetime of the returned pointer is the same as the error object. See alsord_kafka_err2name()  Parameters error <code>\\FFI\\CData|null</code> const rd_kafka_error_t* - ) Returns <code>string|null</code> const char* - the error code name for <code>error</code>, e.g, \u201cERR_UNKNOWN_MEMBER_ID\u201d, or an empty string if <code>error</code> is NULL. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a3b32c027854efbf7f52392019a15bc67 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_error_new","title":"rd_kafka_error_new()","text":"<pre><code>public static rd_kafka_error_new ( \n    int $code, \n    string|null $fmt, \n    mixed $args\n ): \\FFI\\CData|null\n</code></pre> <p>Create a new error object with error <code>code</code> and optional human readable error string in <code>fmt</code>. </p> <p>This method is mainly to be used for mocking errors in application test code.</p> <p>The returned object must be destroyed with rd_kafka_error_destroy(). </p> Parameters code <code>int</code> rd_kafka_resp_err_t fmt <code>string|null</code> const char* args <code>mixed</code> Returns <code>\\FFI\\CData|null</code> rd_kafka_error_t* <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#afd0d2df97ab446896ccf4ea87f709809 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_error_string","title":"rd_kafka_error_string()","text":"<pre><code>public static rd_kafka_error_string ( \n    \\FFI\\CData|null $error\n ): string|null\n</code></pre> RemarksThe lifetime of the returned pointer is the same as the error object.  Parameters error <code>\\FFI\\CData|null</code> const rd_kafka_error_t* - ) Returns <code>string|null</code> const char* - a human readable error string for <code>error</code>, or an empty string if <code>error</code> is NULL. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aea75812786d33b35175b3764e7a342df </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_error_txn_requires_abort","title":"rd_kafka_error_txn_requires_abort()","text":"<pre><code>public static rd_kafka_error_txn_requires_abort ( \n    \\FFI\\CData|null $error\n ): int|null\n</code></pre> RemarksThe return value of this method is only valid for errors returned by the transactional API.  Parameters error <code>\\FFI\\CData|null</code> const rd_kafka_error_t* - ) Returns <code>int|null</code> int - 1 if the error is an abortable transaction error in which case the application must call rd_kafka_abort_transaction() and start a new transaction with rd_kafka_begin_transaction() if it wishes to proceed with transactions. Else returns 0 (also if <code>error</code> is NULL). <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ab07a417d941737db523808dec1c488dd </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_event_alterconfigs_result","title":"rd_kafka_event_AlterConfigs_result()","text":"<pre><code>public static rd_kafka_event_AlterConfigs_result ( \n    \\FFI\\CData|null $rkev\n ): \\FFI\\CData|null\n</code></pre> <p>Get AlterConfigs result. </p> <p>Event types: RD_KAFKA_EVENT_ALTERCONFIGS_RESULT </p> Parameters rkev <code>\\FFI\\CData|null</code> rd_kafka_event_t* - ) Returns <code>\\FFI\\CData|null</code> const rd_kafka_AlterConfigs_result_t* - the result of a AlterConfigs request, or NULL if event is of different type. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a97d0666a40b2bd014d564de332eacf3f </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_event_alterconsumergroupoffsets_result","title":"rd_kafka_event_AlterConsumerGroupOffsets_result()","text":"<pre><code>public static rd_kafka_event_AlterConsumerGroupOffsets_result ( \n    \\FFI\\CData|null $rkev\n ): \\FFI\\CData|null\n</code></pre> <p>Get AlterConsumerGroupOffsets result. </p> RemarksThe lifetime of the returned memory is the same as the lifetime of the <code>rkev</code> object. <p>Event types: RD_KAFKA_EVENT_ALTERCONSUMERGROUPOFFSETS_RESULT </p> Parameters rkev <code>\\FFI\\CData|null</code> rd_kafka_event_t* - ) Returns <code>\\FFI\\CData|null</code> const rd_kafka_AlterConsumerGroupOffsets_result_t* - the result of a AlterConsumerGroupOffsets request, or NULL if event is of different type. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aac08437e5b1361291f93b7428b4b1275 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_event_alteruserscramcredentials_result","title":"rd_kafka_event_AlterUserScramCredentials_result()","text":"<pre><code>public static rd_kafka_event_AlterUserScramCredentials_result ( \n    \\FFI\\CData|null $rkev\n ): \\FFI\\CData|null\n</code></pre> <p>Get AlterUserScramCredentials result. </p> RemarksThe lifetime of the returned memory is the same as the lifetime of the <code>rkev</code> object. <p>Event types: RD_KAFKA_EVENT_ALTERUSERSCRAMCREDENTIALS_RESULT </p> Parameters rkev <code>\\FFI\\CData|null</code> rd_kafka_event_t* - ) Returns <code>\\FFI\\CData|null</code> const rd_kafka_AlterUserScramCredentials_result_t* - the result of a AlterUserScramCredentials request, or NULL if event is of different type. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#abb9995f278c3eaf8e4bc6caba254ba0a </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_event_createacls_result","title":"rd_kafka_event_CreateAcls_result()","text":"<pre><code>public static rd_kafka_event_CreateAcls_result ( \n    \\FFI\\CData|null $rkev\n ): \\FFI\\CData|null\n</code></pre> <p>Event types: RD_KAFKA_EVENT_CREATEACLS_RESULT </p> Parameters rkev <code>\\FFI\\CData|null</code> rd_kafka_event_t* - ) Returns <code>\\FFI\\CData|null</code> const rd_kafka_CreateAcls_result_t* - the result of a CreateAcls request, or NULL if event is of different type. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aa605a0d0500ccb783ed7da23670075d9 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_event_createpartitions_result","title":"rd_kafka_event_CreatePartitions_result()","text":"<pre><code>public static rd_kafka_event_CreatePartitions_result ( \n    \\FFI\\CData|null $rkev\n ): \\FFI\\CData|null\n</code></pre> <p>Get CreatePartitions result. </p> <p>Event types: RD_KAFKA_EVENT_CREATEPARTITIONS_RESULT </p> Parameters rkev <code>\\FFI\\CData|null</code> rd_kafka_event_t* - ) Returns <code>\\FFI\\CData|null</code> const rd_kafka_CreatePartitions_result_t* - the result of a CreatePartitions request, or NULL if event is of different type. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ab4f667a48124ac6be89a2b9bcd5f8d47 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_event_createtopics_result","title":"rd_kafka_event_CreateTopics_result()","text":"<pre><code>public static rd_kafka_event_CreateTopics_result ( \n    \\FFI\\CData|null $rkev\n ): \\FFI\\CData|null\n</code></pre> <p>Get CreateTopics result. </p> <p>Event types: RD_KAFKA_EVENT_CREATETOPICS_RESULT </p> Parameters rkev <code>\\FFI\\CData|null</code> rd_kafka_event_t* - ) Returns <code>\\FFI\\CData|null</code> const rd_kafka_CreateTopics_result_t* - the result of a CreateTopics request, or NULL if event is of different type. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a0aa821ae098ca3b88c1a7fdec25c645e </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_event_deleteacls_result","title":"rd_kafka_event_DeleteAcls_result()","text":"<pre><code>public static rd_kafka_event_DeleteAcls_result ( \n    \\FFI\\CData|null $rkev\n ): \\FFI\\CData|null\n</code></pre> <p>Event types: RD_KAFKA_EVENT_DELETEACLS_RESULT </p> Parameters rkev <code>\\FFI\\CData|null</code> rd_kafka_event_t* - ) Returns <code>\\FFI\\CData|null</code> const rd_kafka_DeleteAcls_result_t* - the result of a DeleteAcls request, or NULL if event is of different type. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a9b456786cd867418fd7f8e3cb5f25478 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_event_deleteconsumergroupoffsets_result","title":"rd_kafka_event_DeleteConsumerGroupOffsets_result()","text":"<pre><code>public static rd_kafka_event_DeleteConsumerGroupOffsets_result ( \n    \\FFI\\CData|null $rkev\n ): \\FFI\\CData|null\n</code></pre> <p>Get DeleteConsumerGroupOffsets result. </p> <p>Event types: RD_KAFKA_EVENT_DELETECONSUMERGROUPOFFSETS_RESULT </p> Parameters rkev <code>\\FFI\\CData|null</code> rd_kafka_event_t* - ) Returns <code>\\FFI\\CData|null</code> const rd_kafka_DeleteConsumerGroupOffsets_result_t* - the result of a DeleteConsumerGroupOffsets request, or NULL if event is of different type. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a36ec38fe2135740ac6b41a4141fbc566 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_event_deletegroups_result","title":"rd_kafka_event_DeleteGroups_result()","text":"<pre><code>public static rd_kafka_event_DeleteGroups_result ( \n    \\FFI\\CData|null $rkev\n ): \\FFI\\CData|null\n</code></pre> <p>Get DeleteGroups result. </p> <p>Event types: RD_KAFKA_EVENT_DELETEGROUPS_RESULT </p> Parameters rkev <code>\\FFI\\CData|null</code> rd_kafka_event_t* - ) Returns <code>\\FFI\\CData|null</code> const rd_kafka_DeleteGroups_result_t* - the result of a DeleteGroups request, or NULL if event is of different type. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ad417e30a46183425d3549acb0a2c7e9f </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_event_deleterecords_result","title":"rd_kafka_event_DeleteRecords_result()","text":"<pre><code>public static rd_kafka_event_DeleteRecords_result ( \n    \\FFI\\CData|null $rkev\n ): \\FFI\\CData|null\n</code></pre> <p>Event types: RD_KAFKA_EVENT_DELETERECORDS_RESULT </p> Parameters rkev <code>\\FFI\\CData|null</code> rd_kafka_event_t* - ) Returns <code>\\FFI\\CData|null</code> const rd_kafka_DeleteRecords_result_t* - the result of a DeleteRecords request, or NULL if event is of different type. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ad98fee7bec920114c73c1af90be53416 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_event_deletetopics_result","title":"rd_kafka_event_DeleteTopics_result()","text":"<pre><code>public static rd_kafka_event_DeleteTopics_result ( \n    \\FFI\\CData|null $rkev\n ): \\FFI\\CData|null\n</code></pre> <p>Get DeleteTopics result. </p> <p>Event types: RD_KAFKA_EVENT_DELETETOPICS_RESULT </p> Parameters rkev <code>\\FFI\\CData|null</code> rd_kafka_event_t* - ) Returns <code>\\FFI\\CData|null</code> const rd_kafka_DeleteTopics_result_t* - the result of a DeleteTopics request, or NULL if event is of different type. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a4cd8e837f75589842581110890740f65 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_event_describeacls_result","title":"rd_kafka_event_DescribeAcls_result()","text":"<pre><code>public static rd_kafka_event_DescribeAcls_result ( \n    \\FFI\\CData|null $rkev\n ): \\FFI\\CData|null\n</code></pre> <p>Event types: RD_KAFKA_EVENT_DESCRIBEACLS_RESULT </p> Parameters rkev <code>\\FFI\\CData|null</code> rd_kafka_event_t* - ) Returns <code>\\FFI\\CData|null</code> const rd_kafka_DescribeAcls_result_t* - the result of a DescribeAcls request, or NULL if event is of different type. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#adba2388c1eac2bb6d3e56fdaf4da0839 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_event_describecluster_result","title":"rd_kafka_event_DescribeCluster_result()","text":"<pre><code>public static rd_kafka_event_DescribeCluster_result ( \n    \\FFI\\CData|null $rkev\n ): \\FFI\\CData|null\n</code></pre> <p>Get DescribeCluster result. </p> RemarksThe lifetime of the returned memory is the same as the lifetime of the <code>rkev</code> object. <p>Event types: RD_KAFKA_EVENT_DESCRIBECLUSTER_RESULT </p> Parameters rkev <code>\\FFI\\CData|null</code> rd_kafka_event_t* - ) Returns <code>\\FFI\\CData|null</code> const rd_kafka_DescribeCluster_result_t* - the result of a DescribeCluster request, or NULL if event is of different type. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aeb5c6a8c359bc0f0a769f8e6efa72c44 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_event_describeconfigs_result","title":"rd_kafka_event_DescribeConfigs_result()","text":"<pre><code>public static rd_kafka_event_DescribeConfigs_result ( \n    \\FFI\\CData|null $rkev\n ): \\FFI\\CData|null\n</code></pre> <p>Get DescribeConfigs result. </p> <p>Event types: RD_KAFKA_EVENT_DESCRIBECONFIGS_RESULT </p> Parameters rkev <code>\\FFI\\CData|null</code> rd_kafka_event_t* - ) Returns <code>\\FFI\\CData|null</code> const rd_kafka_DescribeConfigs_result_t* - the result of a DescribeConfigs request, or NULL if event is of different type. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a0e1a04881f39aa850cd47b43583f5a90 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_event_describeconsumergroups_result","title":"rd_kafka_event_DescribeConsumerGroups_result()","text":"<pre><code>public static rd_kafka_event_DescribeConsumerGroups_result ( \n    \\FFI\\CData|null $rkev\n ): \\FFI\\CData|null\n</code></pre> <p>Get DescribeConsumerGroups result. </p> RemarksThe lifetime of the returned memory is the same as the lifetime of the <code>rkev</code> object. <p>Event types: RD_KAFKA_EVENT_DESCRIBECONSUMERGROUPS_RESULT </p> Parameters rkev <code>\\FFI\\CData|null</code> rd_kafka_event_t* - ) Returns <code>\\FFI\\CData|null</code> const rd_kafka_DescribeConsumerGroups_result_t* - the result of a DescribeConsumerGroups request, or NULL if event is of different type. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a1c6a620b55cb4c6acbc48c273d334b16 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_event_describetopics_result","title":"rd_kafka_event_DescribeTopics_result()","text":"<pre><code>public static rd_kafka_event_DescribeTopics_result ( \n    \\FFI\\CData|null $rkev\n ): \\FFI\\CData|null\n</code></pre> <p>Get DescribeTopics result. </p> RemarksThe lifetime of the returned memory is the same as the lifetime of the <code>rkev</code> object. <p>Event types: RD_KAFKA_EVENT_DESCRIBETOPICS_RESULT </p> Parameters rkev <code>\\FFI\\CData|null</code> rd_kafka_event_t* - ) Returns <code>\\FFI\\CData|null</code> const rd_kafka_DescribeTopics_result_t* - the result of a DescribeTopics request, or NULL if event is of different type. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a3bdad3fc99fb284859e6ef258efcae89 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_event_describeuserscramcredentials_result","title":"rd_kafka_event_DescribeUserScramCredentials_result()","text":"<pre><code>public static rd_kafka_event_DescribeUserScramCredentials_result ( \n    \\FFI\\CData|null $rkev\n ): \\FFI\\CData|null\n</code></pre> <p>Get DescribeUserScramCredentials result. </p> RemarksThe lifetime of the returned memory is the same as the lifetime of the <code>rkev</code> object. <p>Event types: RD_KAFKA_EVENT_DESCRIBEUSERSCRAMCREDENTIALS_RESULT </p> Parameters rkev <code>\\FFI\\CData|null</code> rd_kafka_event_t* - ) Returns <code>\\FFI\\CData|null</code> const rd_kafka_DescribeUserScramCredentials_result_t* - the result of a DescribeUserScramCredentials request, or NULL if event is of different type. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a69853c3d64324a45341b2a68b0e2026e </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_event_electleaders_result","title":"rd_kafka_event_ElectLeaders_result()","text":"<pre><code>public static rd_kafka_event_ElectLeaders_result ( \n    \\FFI\\CData|null $rkev\n ): \\FFI\\CData|null\n</code></pre> <p>Get ElectLeaders result. </p> RemarksThe lifetime of the returned memory is the same as the lifetime of the <code>rkev</code> object. <p>Event types: RD_KAFKA_EVENT_ELECTLEADERS_RESULT </p> Parameters rkev <code>\\FFI\\CData|null</code> rd_kafka_event_t* - ) Returns <code>\\FFI\\CData|null</code> const rd_kafka_ElectLeaders_result_t* - the result of a ElectLeaders request, or NULL if event is of different type. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#abf08b888315fc6bd49f397703b035233 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_event_incrementalalterconfigs_result","title":"rd_kafka_event_IncrementalAlterConfigs_result()","text":"<pre><code>public static rd_kafka_event_IncrementalAlterConfigs_result ( \n    \\FFI\\CData|null $rkev\n ): \\FFI\\CData|null\n</code></pre> <p>Get IncrementalAlterConfigs result. </p> <p>Event types: RD_KAFKA_EVENT_INCREMENTALALTERCONFIGS_RESULT </p> Parameters rkev <code>\\FFI\\CData|null</code> rd_kafka_event_t* - ) Returns <code>\\FFI\\CData|null</code> const rd_kafka_IncrementalAlterConfigs_result_t* - the result of a IncrementalAlterConfigs request, or NULL if event is of different type. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8e76c2d637218310d8868af31649b97a </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_event_listconsumergroupoffsets_result","title":"rd_kafka_event_ListConsumerGroupOffsets_result()","text":"<pre><code>public static rd_kafka_event_ListConsumerGroupOffsets_result ( \n    \\FFI\\CData|null $rkev\n ): \\FFI\\CData|null\n</code></pre> <p>Get ListConsumerGroupOffsets result. </p> RemarksThe lifetime of the returned memory is the same as the lifetime of the <code>rkev</code> object. <p>Event types: RD_KAFKA_EVENT_LISTCONSUMERGROUPOFFSETS_RESULT </p> Parameters rkev <code>\\FFI\\CData|null</code> rd_kafka_event_t* - ) Returns <code>\\FFI\\CData|null</code> const rd_kafka_ListConsumerGroupOffsets_result_t* - the result of a ListConsumerGroupOffsets request, or NULL if event is of different type. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ac24d4e077500b38974634f63758aae7e </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_event_listconsumergroups_result","title":"rd_kafka_event_ListConsumerGroups_result()","text":"<pre><code>public static rd_kafka_event_ListConsumerGroups_result ( \n    \\FFI\\CData|null $rkev\n ): \\FFI\\CData|null\n</code></pre> <p>Get ListConsumerGroups result. </p> RemarksThe lifetime of the returned memory is the same as the lifetime of the <code>rkev</code> object. <p>Event types: RD_KAFKA_EVENT_LISTCONSUMERGROUPS_RESULT </p> Parameters rkev <code>\\FFI\\CData|null</code> rd_kafka_event_t* - ) Returns <code>\\FFI\\CData|null</code> const rd_kafka_ListConsumerGroups_result_t* - the result of a ListConsumerGroups request, or NULL if event is of different type. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ae98a40da574c542788d195ac8a0413e6 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_event_listoffsets_result","title":"rd_kafka_event_ListOffsets_result()","text":"<pre><code>public static rd_kafka_event_ListOffsets_result ( \n    \\FFI\\CData|null $rkev\n ): \\FFI\\CData|null\n</code></pre> <p>Get ListOffsets result. </p> RemarksThe lifetime of the returned memory is the same as the lifetime of the <code>rkev</code> object. <p>Event types: RD_KAFKA_EVENT_LISTOFFSETS_RESULT </p> Parameters rkev <code>\\FFI\\CData|null</code> rd_kafka_event_t* - ) Returns <code>\\FFI\\CData|null</code> const rd_kafka_ListOffsets_result_t* - the result of a ListOffsets request, or NULL if event is of different type. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a3851a3f25c563e7e2f18c756772d84be </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_event_config_string","title":"rd_kafka_event_config_string()","text":"<pre><code>public static rd_kafka_event_config_string ( \n    \\FFI\\CData|null $rkev\n ): string|null\n</code></pre> <p>The returned memory is read-only and its lifetime is the same as the event object.</p> <p>Event types:</p> <ul> <li>RD_KAFKA_EVENT_OAUTHBEARER_TOKEN_REFRESH: value of sasl.oauthbearer.config </li> </ul> Parameters rkev <code>\\FFI\\CData|null</code> rd_kafka_event_t* - ) Returns <code>string|null</code> const char* - the associated configuration string for the event, or NULL if the configuration property is not set or if not applicable for the given event type. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a7e1534cd509d7b233ba4b3d2efea5278 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_event_debug_contexts","title":"rd_kafka_event_debug_contexts()","text":"<pre><code>public static rd_kafka_event_debug_contexts ( \n    \\FFI\\CData|null $rkev, \n    \\FFI\\CData|null $dst, \n    int|null $dstsize\n ): int|null\n</code></pre> <p>Extract log debug context from event. </p> <p>Event types:</p> <ul> <li>RD_KAFKA_EVENT_LOG</li> </ul> Parameters rkev <code>\\FFI\\CData|null</code> rd_kafka_event_t* - the event to extract data from. dst <code>\\FFI\\CData|null</code> char* - destination string for comma separated list. dstsize <code>int|null</code> size_t - size of provided dst buffer. Returns <code>int|null</code> int - 0 on success or -1 if unsupported event type. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a5c43c8164c856aeb3f3170808264458b </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_event_destroy","title":"rd_kafka_event_destroy()","text":"<pre><code>public static rd_kafka_event_destroy ( \n    \\FFI\\CData|null $rkev\n ): void\n</code></pre> <p>Destroy an event. </p> RemarksAny references to this event, such as extracted messages, will not be usable after this call.  As a convenience it is okay to pass <code>rkev</code> as NULL in which case no action is performed.  Parameters rkev <code>\\FFI\\CData|null</code> rd_kafka_event_t* - ) <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#af1835c85aa202caf629861f29f475099 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_event_error","title":"rd_kafka_event_error()","text":"<pre><code>public static rd_kafka_event_error ( \n    \\FFI\\CData|null $rkev\n ): int\n</code></pre> <p>Use rd_kafka_event_error_is_fatal() to detect if this is a fatal error.</p> <p>Event types:</p> <ul> <li>all </li> </ul> Parameters rkev <code>\\FFI\\CData|null</code> rd_kafka_event_t* - ) Returns <code>int</code> rd_kafka_resp_err_t - the error code for the event. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aa28b7d6bb4885843f9a8b9bafa0e15a5 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_event_error_is_fatal","title":"rd_kafka_event_error_is_fatal()","text":"<pre><code>public static rd_kafka_event_error_is_fatal ( \n    \\FFI\\CData|null $rkev\n ): int|null\n</code></pre> <p>Event types:</p> <ul> <li>RD_KAFKA_EVENT_ERROR</li> </ul> See alsord_kafka_fatal_error()  Parameters rkev <code>\\FFI\\CData|null</code> rd_kafka_event_t* - ) Returns <code>int|null</code> int - 1 if the error is a fatal error, else 0. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a1fe9d1e960a59774dbd5a0336927de7d </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_event_error_string","title":"rd_kafka_event_error_string()","text":"<pre><code>public static rd_kafka_event_error_string ( \n    \\FFI\\CData|null $rkev\n ): string|null\n</code></pre> <p>Event types:</p> <ul> <li>all </li> </ul> Parameters rkev <code>\\FFI\\CData|null</code> rd_kafka_event_t* - ) Returns <code>string|null</code> const char* - the error string (if any). An application should check that rd_kafka_event_error() returns non-zero before calling this function. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ad76a1b2d6c4f1727725b075678b88793 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_event_log","title":"rd_kafka_event_log()","text":"<pre><code>public static rd_kafka_event_log ( \n    \\FFI\\CData|null $rkev, \n    \\FFI\\CData|null $fac, \n    \\FFI\\CData|null $str, \n    \\FFI\\CData|null $level\n ): int|null\n</code></pre> <p>Extract log message from the event. </p> <p>Event types:</p> <ul> <li>RD_KAFKA_EVENT_LOG</li> </ul> Parameters rkev <code>\\FFI\\CData|null</code> rd_kafka_event_t* fac <code>\\FFI\\CData|null</code> const char** str <code>\\FFI\\CData|null</code> const char** level <code>\\FFI\\CData|null</code> int* Returns <code>int|null</code> int - 0 on success or -1 if unsupported event type. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a535efaa16772642d724bedca414c17c7 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_event_message_array","title":"rd_kafka_event_message_array()","text":"<pre><code>public static rd_kafka_event_message_array ( \n    \\FFI\\CData|null $rkev, \n    \\FFI\\CData|null $rkmessages, \n    int|null $size\n ): int|null\n</code></pre> <p>Extacts <code>size</code> message(s) from the event into the pre-allocated array <code>rkmessages</code>. </p> <p>Event types:</p> <ul> <li>RD_KAFKA_EVENT_FETCH (1 message)</li> <li>RD_KAFKA_EVENT_DR (&gt;=1 message(s))</li> </ul> Remarkson_consume() interceptor may be called from this function prior to passing message to application.  Parameters rkev <code>\\FFI\\CData|null</code> rd_kafka_event_t* rkmessages <code>\\FFI\\CData|null</code> const rd_kafka_message_t** size <code>int|null</code> size_t Returns <code>int|null</code> size_t - the number of messages extracted. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a18a17000ebe58eabcdafab37924442b8 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_event_message_count","title":"rd_kafka_event_message_count()","text":"<pre><code>public static rd_kafka_event_message_count ( \n    \\FFI\\CData|null $rkev\n ): int|null\n</code></pre> <p>Event types:</p> <ul> <li>RD_KAFKA_EVENT_FETCH (1 message)</li> <li>RD_KAFKA_EVENT_DR (&gt;=1 message(s)) </li> </ul> Parameters rkev <code>\\FFI\\CData|null</code> rd_kafka_event_t* - ) Returns <code>int|null</code> size_t - the number of remaining messages in the event. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a61d9d106c8956f379bb77d393b8acf90 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_event_message_next","title":"rd_kafka_event_message_next()","text":"<pre><code>public static rd_kafka_event_message_next ( \n    \\FFI\\CData|null $rkev\n ): \\FFI\\CData|null\n</code></pre> <p>Call repeatedly until it returns NULL.</p> <p>Event types:</p> <ul> <li>RD_KAFKA_EVENT_FETCH (1 message)</li> <li>RD_KAFKA_EVENT_DR (&gt;=1 message(s))</li> </ul> RemarksThe returned message(s) MUST NOT be freed with rd_kafka_message_destroy().  on_consume() interceptor may be called from this function prior to passing message to application.  Parameters rkev <code>\\FFI\\CData|null</code> rd_kafka_event_t* - ) Returns <code>\\FFI\\CData|null</code> const rd_kafka_message_t* - the next message from an event. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a3a855eb7bdf17f5797d4911362a5fc7c </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_event_name","title":"rd_kafka_event_name()","text":"<pre><code>public static rd_kafka_event_name ( \n    \\FFI\\CData|null $rkev\n ): string|null\n</code></pre> RemarksAs a convenience it is okay to pass <code>rkev</code> as NULL in which case the name for RD_KAFKA_EVENT_NONE is returned.  Parameters rkev <code>\\FFI\\CData|null</code> const rd_kafka_event_t* - ) Returns <code>string|null</code> const char* - the event type\u2019s name for the given event. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a608193d1fb486f78c79497c8c5b63866 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_event_opaque","title":"rd_kafka_event_opaque()","text":"<pre><code>public static rd_kafka_event_opaque ( \n    \\FFI\\CData|null $rkev\n ): \\FFI\\CData|object|string|null\n</code></pre> <p>Event types:</p> <ul> <li>RD_KAFKA_EVENT_OFFSET_COMMIT</li> <li>RD_KAFKA_EVENT_CREATETOPICS_RESULT</li> <li>RD_KAFKA_EVENT_DELETETOPICS_RESULT</li> <li>RD_KAFKA_EVENT_CREATEPARTITIONS_RESULT</li> <li>RD_KAFKA_EVENT_CREATEACLS_RESULT</li> <li>RD_KAFKA_EVENT_DESCRIBEACLS_RESULT</li> <li>RD_KAFKA_EVENT_DELETEACLS_RESULT</li> <li>RD_KAFKA_EVENT_ALTERCONFIGS_RESULT</li> <li>RD_KAFKA_EVENT_INCREMENTAL_ALTERCONFIGS_RESULT</li> <li>RD_KAFKA_EVENT_DESCRIBECONFIGS_RESULT</li> <li>RD_KAFKA_EVENT_DELETEGROUPS_RESULT</li> <li>RD_KAFKA_EVENT_DELETECONSUMERGROUPOFFSETS_RESULT</li> <li>RD_KAFKA_EVENT_DELETERECORDS_RESULT</li> <li>RD_KAFKA_EVENT_LISTCONSUMERGROUPS_RESULT</li> <li>RD_KAFKA_EVENT_DESCRIBECONSUMERGROUPS_RESULT</li> <li>RD_KAFKA_EVENT_LISTCONSUMERGROUPOFFSETS_RESULT</li> <li>RD_KAFKA_EVENT_ALTERCONSUMERGROUPOFFSETS_RESULT</li> <li>RD_KAFKA_EVENT_DESCRIBETOPICS_RESULT</li> <li>RD_KAFKA_EVENT_DESCRIBECLUSTER_RESULT</li> <li>RD_KAFKA_EVENT_LISTOFFSETS_RESULT</li> <li>RD_KAFKA_EVENT_ELECTLEADERS_RESULT </li> </ul> Parameters rkev <code>\\FFI\\CData|null</code> rd_kafka_event_t* - ) Returns <code>\\FFI\\CData|object|string|null</code> void* - the event opaque (if any) as passed to rd_kafka_commit() (et.al) or rd_kafka_AdminOptions_set_opaque(), depending on event type. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8650ed2a19108d490a65c9aff3e66525 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_event_stats","title":"rd_kafka_event_stats()","text":"<pre><code>public static rd_kafka_event_stats ( \n    \\FFI\\CData|null $rkev\n ): string|null\n</code></pre> <p>Extract stats from the event. </p> <p>Event types:</p> <ul> <li>RD_KAFKA_EVENT_STATS</li> </ul> Remarksthe returned string will be freed automatically along with the event object  Parameters rkev <code>\\FFI\\CData|null</code> rd_kafka_event_t* - ) Returns <code>string|null</code> const char* - stats json string. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ae8572e38ffb452f96d13a2d046fb71d9 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_event_topic_partition","title":"rd_kafka_event_topic_partition()","text":"<pre><code>public static rd_kafka_event_topic_partition ( \n    \\FFI\\CData|null $rkev\n ): \\FFI\\CData|null\n</code></pre> RemarksThe returned pointer MUST be freed with rd_kafka_topic_partition_destroy(). <p>Event types: RD_KAFKA_EVENT_ERROR (for partition level errors) </p> Parameters rkev <code>\\FFI\\CData|null</code> rd_kafka_event_t* - ) Returns <code>\\FFI\\CData|null</code> rd_kafka_topic_partition_t* - a newly allocated topic_partition container, if applicable for the event type, else NULL. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#abf4cce46d6e566dd35865c0451b76afe </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_event_topic_partition_list","title":"rd_kafka_event_topic_partition_list()","text":"<pre><code>public static rd_kafka_event_topic_partition_list ( \n    \\FFI\\CData|null $rkev\n ): \\FFI\\CData|null\n</code></pre> RemarksThe list MUST NOT be freed with rd_kafka_topic_partition_list_destroy() <p>Event types:</p> <ul> <li>RD_KAFKA_EVENT_REBALANCE</li> <li>RD_KAFKA_EVENT_OFFSET_COMMIT </li> </ul> Parameters rkev <code>\\FFI\\CData|null</code> rd_kafka_event_t* - ) Returns <code>\\FFI\\CData|null</code> rd_kafka_topic_partition_list_t* - the topic partition list from the event. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#abc8f98c9b35be497251fb8515e9e6633 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_event_type","title":"rd_kafka_event_type()","text":"<pre><code>public static rd_kafka_event_type ( \n    \\FFI\\CData|null $rkev\n ): int|null\n</code></pre> RemarksAs a convenience it is okay to pass <code>rkev</code> as NULL in which case RD_KAFKA_EVENT_NONE is returned.  Parameters rkev <code>\\FFI\\CData|null</code> const rd_kafka_event_t* - ) Returns <code>int|null</code> rd_kafka_event_type_t - the event type for the given event. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a108de3729a4aa609a72a458a9de02d1d </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_fatal_error","title":"rd_kafka_fatal_error()","text":"<pre><code>public static rd_kafka_fatal_error ( \n    \\FFI\\CData|null $rk, \n    \\FFI\\CData|null $errstr, \n    int|null $errstr_size\n ): int\n</code></pre> <p>Returns the first fatal error set on this client instance, or RD_KAFKA_RESP_ERR_NO_ERROR if no fatal error has occurred. </p> <p>This function is to be used with the Idempotent Producer and <code>error_cb</code> to detect fatal errors.</p> <p>Generally all errors raised by <code>error_cb</code> are to be considered informational and temporary, the client will try to recover from all errors in a graceful fashion (by retrying, etc).</p> <p>However, some errors should logically be considered fatal to retain consistency; in particular a set of errors that may occur when using the Idempotent Producer and the in-order or exactly-once producer guarantees can't be satisfied.</p> Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* - Client instance. errstr <code>\\FFI\\CData|null</code> char* - A human readable error string (nul-terminated) is written to this location that must be of at least <code>errstr_size</code> bytes. The <code>errstr</code> is only written to if there is a fatal error. - Writable size in <code>errstr</code>. errstr_size <code>int|null</code> size_t Returns <code>int</code> rd_kafka_resp_err_t - RD_KAFKA_RESP_ERR_NO_ERROR if no fatal error has been raised, else any other error code. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a44c976534da6f3877cc514826c71607c </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_flush","title":"rd_kafka_flush()","text":"<pre><code>public static rd_kafka_flush ( \n    \\FFI\\CData|null $rk, \n    int|null $timeout_ms\n ): int\n</code></pre> <p>Wait until all outstanding produce requests, et.al, are completed. This should typically be done prior to destroying a producer instance to make sure all queued and in-flight produce requests are completed before terminating. </p> RemarksThis function will call rd_kafka_poll() and thus trigger callbacks.  The <code>linger.ms</code> time will be ignored for the duration of the call, queued messages will be sent to the broker as soon as possible.  If RD_KAFKA_EVENT_DR has been enabled (through rd_kafka_conf_set_events()) this function will not call rd_kafka_poll() but instead wait for the librdkafka-handled message count to reach zero. This requires the application to serve the event queue in a separate thread. In this mode only messages are counted, not other types of queued events. See alsord_kafka_outq_len()  Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* timeout_ms <code>int|null</code> int Returns <code>int</code> rd_kafka_resp_err_t - RD_KAFKA_RESP_ERR__TIMED_OUT if <code>timeout_ms</code> was reached before all outstanding requests were completed, else RD_KAFKA_RESP_ERR_NO_ERROR <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aaff06c4372bce917c17f3c1a5d8b205d </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_get_debug_contexts","title":"rd_kafka_get_debug_contexts()","text":"<pre><code>public static rd_kafka_get_debug_contexts (  ): string|null\n</code></pre> <p>Retrieve supported debug contexts for use with the <code>\"debug\"</code> configuration property. (runtime) </p> Returns <code>string|null</code> const char* - ) - Comma-separated list of available debugging contexts. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#adece97d3cbdd6ca936df5b0663118c45 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_get_err_descs","title":"rd_kafka_get_err_descs()","text":"<pre><code>public static rd_kafka_get_err_descs ( \n    \\FFI\\CData|null $errdescs, \n    \\FFI\\CData|null $cntp\n ): void\n</code></pre> Parameters errdescs <code>\\FFI\\CData|null</code> const struct rd_kafka_err_desc** cntp <code>\\FFI\\CData|null</code> size_t*"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_get_watermark_offsets","title":"rd_kafka_get_watermark_offsets()","text":"<pre><code>public static rd_kafka_get_watermark_offsets ( \n    \\FFI\\CData|null $rk, \n    string|null $topic, \n    int|null $partition, \n    \\FFI\\CData|null $low, \n    \\FFI\\CData|null $high\n ): int\n</code></pre> <p>Get last known low (oldest/beginning) and high (newest/end) offsets for partition. </p> <p>The low offset is updated periodically (if statistics.interval.ms is set) while the high offset is updated on each fetched message set from the broker.</p> <p>If there is no cached offset (either low or high, or both) then RD_KAFKA_OFFSET_INVALID will be returned for the respective offset.</p> <p>Offsets are returned in <code>*low</code> and <code>*high</code> respectively.</p> RemarksShall only be used with an active consumer instance.  Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* topic <code>string|null</code> const char* partition <code>int|null</code> int32_t low <code>\\FFI\\CData|null</code> int64_t* high <code>\\FFI\\CData|null</code> int64_t* Returns <code>int</code> rd_kafka_resp_err_t - RD_KAFKA_RESP_ERR_NO_ERROR on success or an error code on failure. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ad1d338cebde98a76050e61301f631d82 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_group_list_destroy","title":"rd_kafka_group_list_destroy()","text":"<pre><code>public static rd_kafka_group_list_destroy ( \n    \\FFI\\CData|null $grplist\n ): void\n</code></pre> Parameters grplist <code>\\FFI\\CData|null</code> const struct rd_kafka_group_list*"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_group_result_error","title":"rd_kafka_group_result_error()","text":"<pre><code>public static rd_kafka_group_result_error ( \n    \\FFI\\CData|null $groupres\n ): \\FFI\\CData|null\n</code></pre> <p>Group result provides per-group operation result information. </p> Remarkslifetime of the returned error is the same as the <code>groupres</code>.  Parameters groupres <code>\\FFI\\CData|null</code> const rd_kafka_group_result_t* - ) Returns <code>\\FFI\\CData|null</code> const rd_kafka_error_t* - the error for the given group result, or NULL on success. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a97cda56301d566204aad9320e2b748ba </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_group_result_name","title":"rd_kafka_group_result_name()","text":"<pre><code>public static rd_kafka_group_result_name ( \n    \\FFI\\CData|null $groupres\n ): string|null\n</code></pre> Remarkslifetime of the returned string is the same as the <code>groupres</code>.  Parameters groupres <code>\\FFI\\CData|null</code> const rd_kafka_group_result_t* - ) Returns <code>string|null</code> const char* - the name of the group for the given group result. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a7f8f41cfe01a2b977e4a2d54644e765d </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_group_result_partitions","title":"rd_kafka_group_result_partitions()","text":"<pre><code>public static rd_kafka_group_result_partitions ( \n    \\FFI\\CData|null $groupres\n ): \\FFI\\CData|null\n</code></pre> Remarkslifetime of the returned list is the same as the <code>groupres</code>.  Parameters groupres <code>\\FFI\\CData|null</code> const rd_kafka_group_result_t* - ) Returns <code>\\FFI\\CData|null</code> const rd_kafka_topic_partition_list_t* - the partitions/offsets for the given group result, if applicable to the request type, else NULL. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a5c039926ae9dca773ebec2f9147f2fa1 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_handle_mock_cluster","title":"rd_kafka_handle_mock_cluster()","text":"<pre><code>public static rd_kafka_handle_mock_cluster ( \n    \\FFI\\CData|null $rk\n ): \\FFI\\CData|null\n</code></pre> Parameters rk <code>\\FFI\\CData|null</code> const rd_kafka_t* Returns <code>\\FFI\\CData|null</code> rd_kafka_mock_cluster_t*"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_header_add","title":"rd_kafka_header_add()","text":"<pre><code>public static rd_kafka_header_add ( \n    \\FFI\\CData|null $hdrs, \n    string|null $name, \n    int|null $name_size, \n    \\FFI\\CData|object|string|null $value, \n    int|null $value_size\n ): int\n</code></pre> <p>Add header with name <code>name</code> and value <code>val</code> (copied) of size <code>size</code> (not including null-terminator). </p> Parameters hdrs <code>\\FFI\\CData|null</code> rd_kafka_headers_t* - Headers list. name <code>string|null</code> const char* - Header name. name_size <code>int|null</code> ssize_t - Header name size (not including the null-terminator). If -1 the <code>name</code> length is automatically acquired using strlen(). value <code>\\FFI\\CData|object|string|null</code> const void* - Pointer to header value, or NULL (set size to 0 or -1). value_size <code>int|null</code> ssize_t - Size of header value. If -1 the <code>value</code> is assumed to be a null-terminated string and the length is automatically acquired using strlen(). Returns <code>int</code> rd_kafka_resp_err_t - RD_KAFKA_RESP_ERR__READ_ONLY if the headers are read-only, else RD_KAFKA_RESP_ERR_NO_ERROR. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ad86e25f9787e647588fc2067705de10e </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_header_cnt","title":"rd_kafka_header_cnt()","text":"<pre><code>public static rd_kafka_header_cnt ( \n    \\FFI\\CData|null $hdrs\n ): int|null\n</code></pre> <p>Returns the number of header key/value pairs. </p> Parameters hdrs <code>\\FFI\\CData|null</code> const rd_kafka_headers_t* - ) - Headers to count Returns <code>int|null</code> size_t <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#af8ce5228eef3ea0a9209965902b6fcdd </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_header_get","title":"rd_kafka_header_get()","text":"<pre><code>public static rd_kafka_header_get ( \n    \\FFI\\CData|null $hdrs, \n    int|null $idx, \n    string|null $name, \n    \\FFI\\CData|object|string|null $valuep, \n    \\FFI\\CData|null $sizep\n ): int\n</code></pre> <p>Iterator for headers matching <code>name</code>. </p> <pre>   Same semantics as rd_kafka_header_get_last()\n</pre> Parameters hdrs <code>\\FFI\\CData|null</code> const rd_kafka_headers_t* - Headers to iterate. idx <code>int|null</code> size_t - Iterator index, start at 0 and increment by one for each call as long as RD_KAFKA_RESP_ERR_NO_ERROR is returned. name <code>string|null</code> const char* - Header name to match. valuep <code>\\FFI\\CData|object|string|null</code> const void** - (out) Set to a (null-terminated) const pointer to the value (may be NULL). sizep <code>\\FFI\\CData|null</code> size_t* - (out) Set to the value\u2019s size (not including null-terminator). Returns <code>int</code> rd_kafka_resp_err_t <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a5cf2d5ce4869203aaa9e18ad2c763bbf </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_header_get_all","title":"rd_kafka_header_get_all()","text":"<pre><code>public static rd_kafka_header_get_all ( \n    \\FFI\\CData|null $hdrs, \n    int|null $idx, \n    \\FFI\\CData|null $namep, \n    \\FFI\\CData|object|string|null $valuep, \n    \\FFI\\CData|null $sizep\n ): int\n</code></pre> <p>Iterator for all headers. </p> <pre>   Same semantics as rd_kafka_header_get()\n</pre> See alsord_kafka_header_get()  Parameters hdrs <code>\\FFI\\CData|null</code> const rd_kafka_headers_t* idx <code>int|null</code> size_t namep <code>\\FFI\\CData|null</code> const char** valuep <code>\\FFI\\CData|object|string|null</code> const void** sizep <code>\\FFI\\CData|null</code> size_t* Returns <code>int</code> rd_kafka_resp_err_t <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a3a39136e1d13591f668158c0fa20961b </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_header_get_last","title":"rd_kafka_header_get_last()","text":"<pre><code>public static rd_kafka_header_get_last ( \n    \\FFI\\CData|null $hdrs, \n    string|null $name, \n    \\FFI\\CData|object|string|null $valuep, \n    \\FFI\\CData|null $sizep\n ): int\n</code></pre> <p>Find last header in list <code>hdrs</code> matching <code>name</code>. </p> RemarksThe returned pointer in <code>valuep</code> includes a trailing null-terminator that is not accounted for in <code>sizep</code>.   The returned pointer is only valid as long as the headers list and the header item is valid.  Parameters hdrs <code>\\FFI\\CData|null</code> const rd_kafka_headers_t* - Headers list. name <code>string|null</code> const char* - Header to find (last match). valuep <code>\\FFI\\CData|object|string|null</code> const void** - (out) Set to a (null-terminated) const pointer to the value (may be NULL). sizep <code>\\FFI\\CData|null</code> size_t* - (out) Set to the value\u2019s size (not including null-terminator). Returns <code>int</code> rd_kafka_resp_err_t - RD_KAFKA_RESP_ERR_NO_ERROR if an entry was found, else RD_KAFKA_RESP_ERR__NOENT. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a6cb8628d390cd89a6d9daada8c70161a </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_header_remove","title":"rd_kafka_header_remove()","text":"<pre><code>public static rd_kafka_header_remove ( \n    \\FFI\\CData|null $hdrs, \n    string|null $name\n ): int\n</code></pre> <p>Remove all headers for the given key (if any). </p> Parameters hdrs <code>\\FFI\\CData|null</code> rd_kafka_headers_t* name <code>string|null</code> const char* Returns <code>int</code> rd_kafka_resp_err_t - RD_KAFKA_RESP_ERR__READ_ONLY if the headers are read-only, RD_KAFKA_RESP_ERR__NOENT if no matching headers were found, else RD_KAFKA_RESP_ERR_NO_ERROR if headers were removed. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8a8d23d274cf233b6b4b0a345c0180c1 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_headers_copy","title":"rd_kafka_headers_copy()","text":"<pre><code>public static rd_kafka_headers_copy ( \n    \\FFI\\CData|null $src\n ): \\FFI\\CData|null\n</code></pre> Parameters src <code>\\FFI\\CData|null</code> const rd_kafka_headers_t* Returns <code>\\FFI\\CData|null</code> rd_kafka_headers_t*"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_headers_destroy","title":"rd_kafka_headers_destroy()","text":"<pre><code>public static rd_kafka_headers_destroy ( \n    \\FFI\\CData|null $hdrs\n ): void\n</code></pre> Parameters hdrs <code>\\FFI\\CData|null</code> rd_kafka_headers_t*"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_headers_new","title":"rd_kafka_headers_new()","text":"<pre><code>public static rd_kafka_headers_new ( \n    int|null $initial_count\n ): \\FFI\\CData|null\n</code></pre> <p>Create a new headers list. </p> Parameters initial_count <code>int|null</code> size_t - ) - Preallocate space for this number of headers. Any number of headers may be added, updated and removed regardless of the initial count. Returns <code>\\FFI\\CData|null</code> rd_kafka_headers_t* <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a9fdd55ee90816f38324f5d0af1b4fc1f </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_incremental_assign","title":"rd_kafka_incremental_assign()","text":"<pre><code>public static rd_kafka_incremental_assign ( \n    \\FFI\\CData|null $rk, \n    \\FFI\\CData|null $partitions\n ): \\FFI\\CData|null\n</code></pre> <p>Incrementally add <code>partitions</code> to the current assignment. </p> <p>If a COOPERATIVE assignor (i.e. incremental rebalancing) is being used, this method should be used in a rebalance callback to adjust the current assignment appropriately in the case where the rebalance type is RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS. The application must pass the partition list passed to the callback (or a copy of it), even if the list is empty. <code>partitions</code> must not be NULL. This method may also be used outside the context of a rebalance callback.</p> RemarksThe returned error object (if not NULL) must be destroyed with rd_kafka_error_destroy().  Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* partitions <code>\\FFI\\CData|null</code> const rd_kafka_topic_partition_list_t* Returns <code>\\FFI\\CData|null</code> rd_kafka_error_t* - NULL on success, or an error object if the operation was unsuccessful. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a3bd9f42cf76b2a8cf2f4a4343abe8556 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_incremental_unassign","title":"rd_kafka_incremental_unassign()","text":"<pre><code>public static rd_kafka_incremental_unassign ( \n    \\FFI\\CData|null $rk, \n    \\FFI\\CData|null $partitions\n ): \\FFI\\CData|null\n</code></pre> <p>Incrementally remove <code>partitions</code> from the current assignment. </p> <p>If a COOPERATIVE assignor (i.e. incremental rebalancing) is being used, this method should be used in a rebalance callback to adjust the current assignment appropriately in the case where the rebalance type is RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS. The application must pass the partition list passed to the callback (or a copy of it), even if the list is empty. <code>partitions</code> must not be NULL. This method may also be used outside the context of a rebalance callback.</p> RemarksThe returned error object (if not NULL) must be destroyed with rd_kafka_error_destroy().  Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* partitions <code>\\FFI\\CData|null</code> const rd_kafka_topic_partition_list_t* Returns <code>\\FFI\\CData|null</code> rd_kafka_error_t* - NULL on success, or an error object if the operation was unsuccessful. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a27f7bd18e42ed44f33932c2f9b6a4192 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_init_transactions","title":"rd_kafka_init_transactions()","text":"<pre><code>public static rd_kafka_init_transactions ( \n    \\FFI\\CData|null $rk, \n    int|null $timeout_ms\n ): \\FFI\\CData|null\n</code></pre> <p>Initialize transactions for the producer instance. </p> <p>This function ensures any transactions initiated by previous instances of the producer with the same <code>transactional.id</code> are completed. If the previous instance failed with a transaction in progress the previous transaction will be aborted. This function needs to be called before any other transactional or produce functions are called when the <code>transactional.id</code> is configured.</p> <p>If the last transaction had begun completion (following transaction commit) but not yet finished, this function will await the previous transaction's completion.</p> <p>When any previous transactions have been fenced this function will acquire the internal producer id and epoch, used in all future transactional messages issued by this producer instance.</p> RemarksThis function may block up to <code>timeout_ms</code> milliseconds.  This call is resumable when a retriable timeout error is returned. Calling the function again will resume the operation that is progressing in the background. RemarksThe returned error object (if not NULL) must be destroyed with rd_kafka_error_destroy().  Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* - Producer instance. timeout_ms <code>int|null</code> int - The maximum time to block. On timeout the operation may continue in the background, depending on state, and it is okay to call init_transactions() again. If an infinite timeout (-1) is passed, the timeout will be adjusted to 2 * <code>transaction.timeout.ms</code>. Returns <code>\\FFI\\CData|null</code> rd_kafka_error_t* - NULL on success or an error object on failure. Check whether the returned error object permits retrying by calling rd_kafka_error_is_retriable(), or whether a fatal error has been raised by calling rd_kafka_error_is_fatal(). Error codes: RD_KAFKA_RESP_ERR__TIMED_OUT if the transaction coordinator could be not be contacted within <code>timeout_ms</code> (retriable), RD_KAFKA_RESP_ERR_COORDINATOR_NOT_AVAILABLE if the transaction coordinator is not available (retriable), RD_KAFKA_RESP_ERR_CONCURRENT_TRANSACTIONS if a previous transaction would not complete within <code>timeout_ms</code> (retriable), RD_KAFKA_RESP_ERR__STATE if transactions have already been started or upon fatal error, RD_KAFKA_RESP_ERR__UNSUPPORTED_FEATURE if the broker(s) do not support transactions (&lt;Apache Kafka 0.11), this also raises a fatal error, RD_KAFKA_RESP_ERR_INVALID_TRANSACTION_TIMEOUT if the configured <code>transaction.timeout.ms</code> is outside the broker-configured range, this also raises a fatal error, RD_KAFKA_RESP_ERR__NOT_CONFIGURED if transactions have not been configured for the producer instance, RD_KAFKA_RESP_ERR__INVALID_ARG if <code>rk</code> is not a producer instance, or <code>timeout_ms</code> is out of range. Other error codes not listed here may be returned, depending on broker version. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#abf3e48791cf53ac2c7e30a17ce896f74 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_interceptor_add_on_acknowledgement","title":"rd_kafka_interceptor_add_on_acknowledgement()","text":"<pre><code>public static rd_kafka_interceptor_add_on_acknowledgement ( \n    \\FFI\\CData|null $rk, \n    string|null $ic_name, \n    \\FFI\\CData|\\Closure $on_acknowledgement, \n    \\FFI\\CData|object|string|null $ic_opaque\n ): int\n</code></pre> <p>Append an on_acknowledgement() interceptor. </p> Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* - Client instance. ic_name <code>string|null</code> const char* - Interceptor name, used in logging. on_acknowledgement <code>\\FFI\\CData|\\Closure</code> rd_kafka_resp_err_t(rd_kafka_interceptor_f_on_acknowledgement_t*)(rd_kafka_t*, rd_kafka_message_t*, void*) - Function pointer. ic_opaque <code>\\FFI\\CData|object|string|null</code> void* - Opaque value that will be passed to the function. Returns <code>int</code> rd_kafka_resp_err_t - RD_KAFKA_RESP_ERR_NO_ERROR on success or RD_KAFKA_RESP_ERR__CONFLICT if an existing interceptor with the same <code>ic_name</code> and function has already been added to <code>conf</code>. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#abaf475ab47fff47ab796be1cecbbd370 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_interceptor_add_on_broker_state_change","title":"rd_kafka_interceptor_add_on_broker_state_change()","text":"<pre><code>public static rd_kafka_interceptor_add_on_broker_state_change ( \n    \\FFI\\CData|null $rk, \n    string|null $ic_name, \n    \\FFI\\CData|\\Closure $on_broker_state_change, \n    \\FFI\\CData|object|string|null $ic_opaque\n ): int\n</code></pre> <p>Append an on_broker_state_change() interceptor. </p> Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* - Client instance. ic_name <code>string|null</code> const char* - Interceptor name, used in logging. on_broker_state_change <code>\\FFI\\CData|\\Closure</code> rd_kafka_resp_err_t(rd_kafka_interceptor_f_on_broker_state_change_t*)(rd_kafka_t*, int32_t, const char*, const char*, int, const char*, void*) ic_opaque <code>\\FFI\\CData|object|string|null</code> void* - Opaque value that will be passed to the function. Returns <code>int</code> rd_kafka_resp_err_t - RD_KAFKA_RESP_ERR_NO_ERROR on success or RD_KAFKA_RESP_ERR__CONFLICT if an existing interceptor with the same <code>ic_name</code> and function has already been added to <code>conf</code>. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a2b53e29ee63067884bc8962e8637e82b </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_interceptor_add_on_commit","title":"rd_kafka_interceptor_add_on_commit()","text":"<pre><code>public static rd_kafka_interceptor_add_on_commit ( \n    \\FFI\\CData|null $rk, \n    string|null $ic_name, \n    \\FFI\\CData|\\Closure $on_commit, \n    \\FFI\\CData|object|string|null $ic_opaque\n ): int\n</code></pre> <p>Append an on_commit() interceptor. </p> Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* - Client instance. ic_name <code>string|null</code> const char* - Interceptor name, used in logging. on_commit <code>\\FFI\\CData|\\Closure</code> rd_kafka_resp_err_t(rd_kafka_interceptor_f_on_commit_t*)(rd_kafka_t*, const rd_kafka_topic_partition_list_t*, rd_kafka_resp_err_t, void*) ic_opaque <code>\\FFI\\CData|object|string|null</code> void* - Opaque value that will be passed to the function. Returns <code>int</code> rd_kafka_resp_err_t - RD_KAFKA_RESP_ERR_NO_ERROR on success or RD_KAFKA_RESP_ERR__CONFLICT if an existing interceptor with the same <code>ic_name</code> and function has already been added to <code>conf</code>. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a0d3e29337dbf11762b5a7e492b77b781 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_interceptor_add_on_consume","title":"rd_kafka_interceptor_add_on_consume()","text":"<pre><code>public static rd_kafka_interceptor_add_on_consume ( \n    \\FFI\\CData|null $rk, \n    string|null $ic_name, \n    \\FFI\\CData|\\Closure $on_consume, \n    \\FFI\\CData|object|string|null $ic_opaque\n ): int\n</code></pre> <p>Append an on_consume() interceptor. </p> Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* - Client instance. ic_name <code>string|null</code> const char* - Interceptor name, used in logging. on_consume <code>\\FFI\\CData|\\Closure</code> rd_kafka_resp_err_t(rd_kafka_interceptor_f_on_consume_t*)(rd_kafka_t*, rd_kafka_message_t*, void*) - Function pointer. ic_opaque <code>\\FFI\\CData|object|string|null</code> void* - Opaque value that will be passed to the function. Returns <code>int</code> rd_kafka_resp_err_t - RD_KAFKA_RESP_ERR_NO_ERROR on success or RD_KAFKA_RESP_ERR__CONFLICT if an existing interceptor with the same <code>ic_name</code> and function has already been added to <code>conf</code>. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a0e722a9930897bba81b33de5fe95b6ed </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_interceptor_add_on_destroy","title":"rd_kafka_interceptor_add_on_destroy()","text":"<pre><code>public static rd_kafka_interceptor_add_on_destroy ( \n    \\FFI\\CData|null $rk, \n    string|null $ic_name, \n    \\FFI\\CData|\\Closure $on_destroy, \n    \\FFI\\CData|object|string|null $ic_opaque\n ): int\n</code></pre> <p>Append an on_destroy() interceptor. </p> Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* - Client instance. ic_name <code>string|null</code> const char* - Interceptor name, used in logging. on_destroy <code>\\FFI\\CData|\\Closure</code> rd_kafka_resp_err_t(rd_kafka_interceptor_f_on_destroy_t*)(rd_kafka_t*, void*) - Function pointer. ic_opaque <code>\\FFI\\CData|object|string|null</code> void* - Opaque value that will be passed to the function. Returns <code>int</code> rd_kafka_resp_err_t - RD_KAFKA_RESP_ERR_NO_ERROR on success or RD_KAFKA_RESP_ERR__CONFLICT if an existing interceptor with the same <code>ic_name</code> and function has already been added to <code>conf</code>. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a11b835cb99dc1cfa03c52465b9837a47 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_interceptor_add_on_request_sent","title":"rd_kafka_interceptor_add_on_request_sent()","text":"<pre><code>public static rd_kafka_interceptor_add_on_request_sent ( \n    \\FFI\\CData|null $rk, \n    string|null $ic_name, \n    \\FFI\\CData|\\Closure $on_request_sent, \n    \\FFI\\CData|object|string|null $ic_opaque\n ): int\n</code></pre> <p>Append an on_request_sent() interceptor. </p> Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* - Client instance. ic_name <code>string|null</code> const char* - Interceptor name, used in logging. on_request_sent <code>\\FFI\\CData|\\Closure</code> rd_kafka_resp_err_t(rd_kafka_interceptor_f_on_request_sent_t*)(rd_kafka_t*, int, const char*, int32_t, int16_t, int16_t, int32_t, size_t, void*) ic_opaque <code>\\FFI\\CData|object|string|null</code> void* - Opaque value that will be passed to the function. Returns <code>int</code> rd_kafka_resp_err_t - RD_KAFKA_RESP_ERR_NO_ERROR on success or RD_KAFKA_RESP_ERR__CONFLICT if an existing interceptor with the same <code>ic_name</code> and function has already been added to <code>conf</code>. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a444032455f98839bef2fb76d15f663c3 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_interceptor_add_on_response_received","title":"rd_kafka_interceptor_add_on_response_received()","text":"<pre><code>public static rd_kafka_interceptor_add_on_response_received ( \n    \\FFI\\CData|null $rk, \n    string|null $ic_name, \n    \\FFI\\CData|\\Closure $on_response_received, \n    \\FFI\\CData|object|string|null $ic_opaque\n ): int\n</code></pre> <p>Append an on_response_received() interceptor. </p> Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* - Client instance. ic_name <code>string|null</code> const char* - Interceptor name, used in logging. on_response_received <code>\\FFI\\CData|\\Closure</code> rd_kafka_resp_err_t(rd_kafka_interceptor_f_on_response_received_t*)(rd_kafka_t*, int, const char*, int32_t, int16_t, int16_t, int32_t, size_t, int64_t, rd_kafka_resp_err_t, void*) ic_opaque <code>\\FFI\\CData|object|string|null</code> void* - Opaque value that will be passed to the function. Returns <code>int</code> rd_kafka_resp_err_t - RD_KAFKA_RESP_ERR_NO_ERROR on success or RD_KAFKA_RESP_ERR__CONFLICT if an existing interceptor with the same <code>ic_name</code> and function has already been added to <code>conf</code>. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a809061ceda162f8d8ad9663cabf66b3d </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_interceptor_add_on_send","title":"rd_kafka_interceptor_add_on_send()","text":"<pre><code>public static rd_kafka_interceptor_add_on_send ( \n    \\FFI\\CData|null $rk, \n    string|null $ic_name, \n    \\FFI\\CData|\\Closure $on_send, \n    \\FFI\\CData|object|string|null $ic_opaque\n ): int\n</code></pre> <p>Append an on_send() interceptor. </p> Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* - Client instance. ic_name <code>string|null</code> const char* - Interceptor name, used in logging. on_send <code>\\FFI\\CData|\\Closure</code> rd_kafka_resp_err_t(rd_kafka_interceptor_f_on_send_t*)(rd_kafka_t*, rd_kafka_message_t*, void*) - Function pointer. ic_opaque <code>\\FFI\\CData|object|string|null</code> void* - Opaque value that will be passed to the function. Returns <code>int</code> rd_kafka_resp_err_t - RD_KAFKA_RESP_ERR_NO_ERROR on success or RD_KAFKA_RESP_ERR__CONFLICT if an existing intercepted with the same <code>ic_name</code> and function has already been added to <code>conf</code>. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#af6fb1b8884444c63b6930a7bd6122cb6 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_interceptor_add_on_thread_exit","title":"rd_kafka_interceptor_add_on_thread_exit()","text":"<pre><code>public static rd_kafka_interceptor_add_on_thread_exit ( \n    \\FFI\\CData|null $rk, \n    string|null $ic_name, \n    \\FFI\\CData|\\Closure $on_thread_exit, \n    \\FFI\\CData|object|string|null $ic_opaque\n ): int\n</code></pre> <p>Append an on_thread_exit() interceptor. </p> Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* - Client instance. ic_name <code>string|null</code> const char* - Interceptor name, used in logging. on_thread_exit <code>\\FFI\\CData|\\Closure</code> rd_kafka_resp_err_t(rd_kafka_interceptor_f_on_thread_exit_t*)(rd_kafka_t*, rd_kafka_thread_type_t, const char*, void*) ic_opaque <code>\\FFI\\CData|object|string|null</code> void* - Opaque value that will be passed to the function. Returns <code>int</code> rd_kafka_resp_err_t - RD_KAFKA_RESP_ERR_NO_ERROR on success or RD_KAFKA_RESP_ERR__CONFLICT if an existing interceptor with the same <code>ic_name</code> and function has already been added to <code>conf</code>. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a876a95f3d989ad7cbff048e3449674e6 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_interceptor_add_on_thread_start","title":"rd_kafka_interceptor_add_on_thread_start()","text":"<pre><code>public static rd_kafka_interceptor_add_on_thread_start ( \n    \\FFI\\CData|null $rk, \n    string|null $ic_name, \n    \\FFI\\CData|\\Closure $on_thread_start, \n    \\FFI\\CData|object|string|null $ic_opaque\n ): int\n</code></pre> <p>Append an on_thread_start() interceptor. </p> Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* - Client instance. ic_name <code>string|null</code> const char* - Interceptor name, used in logging. on_thread_start <code>\\FFI\\CData|\\Closure</code> rd_kafka_resp_err_t(rd_kafka_interceptor_f_on_thread_start_t*)(rd_kafka_t*, rd_kafka_thread_type_t, const char*, void*) ic_opaque <code>\\FFI\\CData|object|string|null</code> void* - Opaque value that will be passed to the function. Returns <code>int</code> rd_kafka_resp_err_t - RD_KAFKA_RESP_ERR_NO_ERROR on success or RD_KAFKA_RESP_ERR__CONFLICT if an existing interceptor with the same <code>ic_name</code> and function has already been added to <code>conf</code>. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aa46a3bd81acc3861979f43b63f7ea1c8 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_interceptor_f_on_acknowledgement_t","title":"rd_kafka_interceptor_f_on_acknowledgement_t()","text":"<pre><code>public static rd_kafka_interceptor_f_on_acknowledgement_t ( \n    \\FFI\\CData|null $rk, \n    \\FFI\\CData|null $rkmessage, \n    \\FFI\\CData|object|string|null $ic_opaque\n ): int\n</code></pre> <p>on_acknowledgement() is called to inform interceptors that a message was succesfully delivered or permanently failed delivery. The interceptor chain is called from internal librdkafka background threads, or rd_kafka_produce*() if the partitioner failed. </p> RemarksThis interceptor is only used by producer instances.  The <code>rkmessage</code> object is NOT mutable and MUST NOT be modified by the interceptor. WarningThe on_acknowledgement() method may be called from internal librdkafka threads. An on_acknowledgement() interceptor MUST NOT call any librdkafka API's associated with the <code>rk</code>, or perform any blocking or prolonged work. Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* - The client instance. rkmessage <code>\\FFI\\CData|null</code> rd_kafka_message_t* - The message being produced. Immutable. ic_opaque <code>\\FFI\\CData|object|string|null</code> void* - The interceptor\u2019s opaque pointer specified in ..add..(). Returns <code>int</code> rd_kafka_resp_err_t - an error code on failure, the error is logged but otherwise ignored. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aa654a84f20567004ab1df85f97f0ebf2 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_interceptor_f_on_broker_state_change_t","title":"rd_kafka_interceptor_f_on_broker_state_change_t()","text":"<pre><code>public static rd_kafka_interceptor_f_on_broker_state_change_t ( \n    \\FFI\\CData|null $rk, \n    int|null $broker_id, \n    string|null $secproto, \n    string|null $name, \n    int|null $port, \n    string|null $state, \n    \\FFI\\CData|object|string|null $ic_opaque\n ): int\n</code></pre> <p>on_broker_state_change() is called just after a broker has been created or its state has been changed. </p> Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* - The client instance. broker_id <code>int|null</code> int32_t - The broker id (-1 is used for bootstrap brokers). secproto <code>string|null</code> const char* - The security protocol. name <code>string|null</code> const char* - The original name of the broker. port <code>int|null</code> int - The port of the broker. state <code>string|null</code> const char* - Broker state name. ic_opaque <code>\\FFI\\CData|object|string|null</code> void* - The interceptor\u2019s opaque pointer specified in ..add..(). Returns <code>int</code> rd_kafka_resp_err_t - an error code on failure, the error is logged but otherwise ignored. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a50cb62229f969ac9d25d58c8d65950b9 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_interceptor_f_on_commit_t","title":"rd_kafka_interceptor_f_on_commit_t()","text":"<pre><code>public static rd_kafka_interceptor_f_on_commit_t ( \n    \\FFI\\CData|null $rk, \n    \\FFI\\CData|null $offsets, \n    int $err, \n    \\FFI\\CData|object|string|null $ic_opaque\n ): int\n</code></pre> <p>on_commit() is called on completed or failed offset commit. It is called from internal librdkafka threads. </p> RemarksThis interceptor is only used by consumer instances. WarningThe on_commit() interceptor is called from internal librdkafka threads. An on_commit() interceptor MUST NOT call any librdkafka API's associated with the <code>rk</code>, or perform any blocking or prolonged work. Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* - The client instance. offsets <code>\\FFI\\CData|null</code> const rd_kafka_topic_partition_list_t* - List of topic+partition+offset+error that were committed. The error message of each partition should be checked for error. err <code>int</code> rd_kafka_resp_err_t - The commit error, if any. ic_opaque <code>\\FFI\\CData|object|string|null</code> void* - The interceptor\u2019s opaque pointer specified in ..add..(). Returns <code>int</code> rd_kafka_resp_err_t - an error code on failure, the error is logged but otherwise ignored. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a89c817cb2dd1a7b6a414a2f62c01fdcf </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_interceptor_f_on_conf_destroy_t","title":"rd_kafka_interceptor_f_on_conf_destroy_t()","text":"<pre><code>public static rd_kafka_interceptor_f_on_conf_destroy_t ( \n    \\FFI\\CData|object|string|null $ic_opaque\n ): int\n</code></pre> <p>on_conf_destroy() is called from rd_kafka_*_conf_destroy() in the order the interceptors were added. </p> Parameters ic_opaque <code>\\FFI\\CData|object|string|null</code> void* - The interceptor\u2019s opaque pointer specified in ..add..(). Returns <code>int</code> rd_kafka_resp_err_t <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#afd1b354fab7374b77cf5e43c8a04c479 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_interceptor_f_on_conf_dup_t","title":"rd_kafka_interceptor_f_on_conf_dup_t()","text":"<pre><code>public static rd_kafka_interceptor_f_on_conf_dup_t ( \n    \\FFI\\CData|null $new_conf, \n    \\FFI\\CData|null $old_conf, \n    int|null $filter_cnt, \n    \\FFI\\CData|null $filter, \n    \\FFI\\CData|object|string|null $ic_opaque\n ): int\n</code></pre> <p>on_conf_dup() is called from rd_kafka_conf_dup() in the order the interceptors were added and is used to let an interceptor re-register its conf interecptors with a new opaque value. The on_conf_dup() method is called prior to the configuration from <code>old_conf</code> being copied to <code>new_conf</code>. </p> RemarksNo on_conf_* interceptors are copied to the new configuration object on rd_kafka_conf_dup().  Parameters new_conf <code>\\FFI\\CData|null</code> rd_kafka_conf_t* - New configuration object. old_conf <code>\\FFI\\CData|null</code> const rd_kafka_conf_t* - Old configuration object to copy properties from. filter_cnt <code>int|null</code> size_t - Number of property names to filter in <code>filter</code>. - Property names to filter out (ignore) when setting up <code>new_conf</code>. filter <code>\\FFI\\CData|null</code> const char** ic_opaque <code>\\FFI\\CData|object|string|null</code> void* - The interceptor\u2019s opaque pointer specified in ..add..(). Returns <code>int</code> rd_kafka_resp_err_t - RD_KAFKA_RESP_ERR_NO_ERROR on success or an error code on failure (which is logged but otherwise ignored). <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a166d8f2aea67064516b7995869af2411 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_interceptor_f_on_conf_set_t","title":"rd_kafka_interceptor_f_on_conf_set_t()","text":"<pre><code>public static rd_kafka_interceptor_f_on_conf_set_t ( \n    \\FFI\\CData|null $conf, \n    string|null $name, \n    string|null $val, \n    \\FFI\\CData|null $errstr, \n    int|null $errstr_size, \n    \\FFI\\CData|object|string|null $ic_opaque\n ): int\n</code></pre> <p>on_conf_set() is called from rd_kafka_*_conf_set() in the order the interceptors were added. </p> Parameters conf <code>\\FFI\\CData|null</code> rd_kafka_conf_t* - Configuration object. name <code>string|null</code> const char* - The configuration property to set. val <code>string|null</code> const char* - The configuration value to set, or NULL for reverting to default in which case the previous value should be freed. errstr <code>\\FFI\\CData|null</code> char* - A human readable error string in case the interceptor fails. errstr_size <code>int|null</code> size_t - Maximum space (including \\0) in <code>errstr</code>. ic_opaque <code>\\FFI\\CData|object|string|null</code> void* - The interceptor\u2019s opaque pointer specified in ..add..(). Returns <code>int</code> rd_kafka_conf_res_t - RD_KAFKA_CONF_OK if the property was known and successfully handled by the interceptor, RD_KAFKA_CONF_INVALID if the property was handled by the interceptor but the value was invalid, or RD_KAFKA_CONF_UNKNOWN if the interceptor did not handle this property, in which case the property is passed on on the interceptor in the chain, finally ending up at the built-in configuration handler. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a6c1f90ab0ce78b28daa9ee27a682da10 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_interceptor_f_on_consume_t","title":"rd_kafka_interceptor_f_on_consume_t()","text":"<pre><code>public static rd_kafka_interceptor_f_on_consume_t ( \n    \\FFI\\CData|null $rk, \n    \\FFI\\CData|null $rkmessage, \n    \\FFI\\CData|object|string|null $ic_opaque\n ): int\n</code></pre> <p>on_consume() is called just prior to passing the message to the application in rd_kafka_consumer_poll(), rd_kafka_consume*(), the event interface, etc. </p> RemarksThis interceptor is only used by consumer instances.  The <code>rkmessage</code> object is NOT mutable and MUST NOT be modified by the interceptor. Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* - The client instance. rkmessage <code>\\FFI\\CData|null</code> rd_kafka_message_t* - The message being consumed. Immutable. ic_opaque <code>\\FFI\\CData|object|string|null</code> void* - The interceptor\u2019s opaque pointer specified in ..add..(). Returns <code>int</code> rd_kafka_resp_err_t - an error code on failure, the error is logged but otherwise ignored. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ae31db94674004860fa545f3745497cfe </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_interceptor_f_on_destroy_t","title":"rd_kafka_interceptor_f_on_destroy_t()","text":"<pre><code>public static rd_kafka_interceptor_f_on_destroy_t ( \n    \\FFI\\CData|null $rk, \n    \\FFI\\CData|object|string|null $ic_opaque\n ): int\n</code></pre> <p>on_destroy() is called from rd_kafka_destroy() or (rd_kafka_new() if rd_kafka_new() fails during initialization). </p> Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* - The client instance. ic_opaque <code>\\FFI\\CData|object|string|null</code> void* - The interceptor\u2019s opaque pointer specified in ..add..(). Returns <code>int</code> rd_kafka_resp_err_t <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aaea78073e1a749ee0a8eaedf2f7c21d4 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_interceptor_f_on_new_t","title":"rd_kafka_interceptor_f_on_new_t()","text":"<pre><code>public static rd_kafka_interceptor_f_on_new_t ( \n    \\FFI\\CData|null $rk, \n    \\FFI\\CData|null $conf, \n    \\FFI\\CData|object|string|null $ic_opaque, \n    \\FFI\\CData|null $errstr, \n    int|null $errstr_size\n ): int\n</code></pre> <p>on_new() is called from rd_kafka_new() prior toreturning the newly created client instance to the application. </p> WarningThe <code>rk</code> client instance will not be fully set up when this interceptor is called and the interceptor MUST NOT call any other rk-specific APIs than rd_kafka_interceptor_add..().  Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* - The client instance. conf <code>\\FFI\\CData|null</code> const rd_kafka_conf_t* - The client instance\u2019s final configuration. ic_opaque <code>\\FFI\\CData|object|string|null</code> void* - The interceptor\u2019s opaque pointer specified in ..add..(). errstr <code>\\FFI\\CData|null</code> char* - A human readable error string in case the interceptor fails. errstr_size <code>int|null</code> size_t - Maximum space (including \\0) in <code>errstr</code>. Returns <code>int</code> rd_kafka_resp_err_t - an error code on failure, the error is logged but otherwise ignored. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a1dd51e3656e61b4a8d4475a3e0deaa10 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_interceptor_f_on_request_sent_t","title":"rd_kafka_interceptor_f_on_request_sent_t()","text":"<pre><code>public static rd_kafka_interceptor_f_on_request_sent_t ( \n    \\FFI\\CData|null $rk, \n    int|null $sockfd, \n    string|null $brokername, \n    int|null $brokerid, \n    int|null $ApiKey, \n    int|null $ApiVersion, \n    int|null $CorrId, \n    int|null $size, \n    \\FFI\\CData|object|string|null $ic_opaque\n ): int\n</code></pre> <p>on_request_sent() is called when a request has been fully written to a broker TCP connections socket. </p> WarningThe on_request_sent() interceptor is called from internal librdkafka broker threads. An on_request_sent() interceptor MUST NOT call any librdkafka API's associated with the <code>rk</code>, or perform any blocking or prolonged work. Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* - The client instance. sockfd <code>int|null</code> int - Socket file descriptor. brokername <code>string|null</code> const char* - Broker request is being sent to. brokerid <code>int|null</code> int32_t - Broker request is being sent to. ApiKey <code>int|null</code> int16_t - Kafka protocol request type. ApiVersion <code>int|null</code> int16_t - Kafka protocol request type version. CorrId <code>int|null</code> int32_t - Kafka protocol request correlation id. size <code>int|null</code> size_t - Size of request. ic_opaque <code>\\FFI\\CData|object|string|null</code> void* - The interceptor\u2019s opaque pointer specified in ..add..(). Returns <code>int</code> rd_kafka_resp_err_t - an error code on failure, the error is logged but otherwise ignored. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a0b7f9b39e862802a6ccbac07bf848064 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_interceptor_f_on_response_received_t","title":"rd_kafka_interceptor_f_on_response_received_t()","text":"<pre><code>public static rd_kafka_interceptor_f_on_response_received_t ( \n    \\FFI\\CData|null $rk, \n    int|null $sockfd, \n    string|null $brokername, \n    int|null $brokerid, \n    int|null $ApiKey, \n    int|null $ApiVersion, \n    int|null $CorrId, \n    int|null $size, \n    int|null $rtt, \n    int $err, \n    \\FFI\\CData|object|string|null $ic_opaque\n ): int\n</code></pre> <p>on_response_received() is called when a protocol response has been fully received from a broker TCP connection socket but before the response payload is parsed. </p> WarningThe on_response_received() interceptor is called from internal librdkafka broker threads. An on_response_received() interceptor MUST NOT call any librdkafka API's associated with the <code>rk</code>, or perform any blocking or prolonged work. Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* - The client instance. sockfd <code>int|null</code> int - Socket file descriptor (always -1). brokername <code>string|null</code> const char* - Broker response was received from, possibly empty string on error. brokerid <code>int|null</code> int32_t - Broker response was received from. ApiKey <code>int|null</code> int16_t - Kafka protocol request type or -1 on error. ApiVersion <code>int|null</code> int16_t - Kafka protocol request type version or -1 on error. CorrId <code>int|null</code> int32_t - Kafka protocol request correlation id, possibly -1 on error. size <code>int|null</code> size_t - Size of response, possibly 0 on error. rtt <code>int|null</code> int64_t - Request round-trip-time in microseconds, possibly -1 on error. err <code>int</code> rd_kafka_resp_err_t - Receive error. ic_opaque <code>\\FFI\\CData|object|string|null</code> void* - The interceptor\u2019s opaque pointer specified in ..add..(). Returns <code>int</code> rd_kafka_resp_err_t - an error code on failure, the error is logged but otherwise ignored. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8e6b3f288085b2495cec22bc912265b9 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_interceptor_f_on_send_t","title":"rd_kafka_interceptor_f_on_send_t()","text":"<pre><code>public static rd_kafka_interceptor_f_on_send_t ( \n    \\FFI\\CData|null $rk, \n    \\FFI\\CData|null $rkmessage, \n    \\FFI\\CData|object|string|null $ic_opaque\n ): int\n</code></pre> <p>on_send() is called from rd_kafka_produce*() (et.al) prior to the partitioner being called. </p> RemarksThis interceptor is only used by producer instances.  The <code>rkmessage</code> object is NOT mutable and MUST NOT be modified by the interceptor.  If the partitioner fails or an unknown partition was specified, the on_acknowledgement() interceptor chain will be called from within the rd_kafka_produce*() call to maintain send-acknowledgement symmetry. Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* - The client instance. rkmessage <code>\\FFI\\CData|null</code> rd_kafka_message_t* - The message being produced. Immutable. ic_opaque <code>\\FFI\\CData|object|string|null</code> void* - The interceptor\u2019s opaque pointer specified in ..add..(). Returns <code>int</code> rd_kafka_resp_err_t - an error code on failure, the error is logged but otherwise ignored. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a39c970fa80d4681d93332d3af4df5916 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_interceptor_f_on_thread_exit_t","title":"rd_kafka_interceptor_f_on_thread_exit_t()","text":"<pre><code>public static rd_kafka_interceptor_f_on_thread_exit_t ( \n    \\FFI\\CData|null $rk, \n    int $thread_type, \n    string|null $thread_name, \n    \\FFI\\CData|object|string|null $ic_opaque\n ): int\n</code></pre> <p>on_thread_exit() is called just prior to a librdkafka-managed thread exiting from the exiting thread itself. </p> RemarksDepending on the thread type, librdkafka may execute additional code on the thread after on_thread_exit() returns. WarningThe on_thread_exit() interceptor is called from internal librdkafka threads. An on_thread_exit() interceptor MUST NOT call any librdkafka API's associated with the <code>rk</code>, or perform any blocking or prolonged work. Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* - The client instance. thread_type <code>int</code> rd_kafka_thread_type_t - Thread type.n thread_name <code>string|null</code> const char* - Human-readable thread name, may not be unique. ic_opaque <code>\\FFI\\CData|object|string|null</code> void* - The interceptor\u2019s opaque pointer specified in ..add..(). Returns <code>int</code> rd_kafka_resp_err_t - an error code on failure, the error is logged but otherwise ignored. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ae89a2054959ba519c3851889ee69576c </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_interceptor_f_on_thread_start_t","title":"rd_kafka_interceptor_f_on_thread_start_t()","text":"<pre><code>public static rd_kafka_interceptor_f_on_thread_start_t ( \n    \\FFI\\CData|null $rk, \n    int $thread_type, \n    string|null $thread_name, \n    \\FFI\\CData|object|string|null $ic_opaque\n ): int\n</code></pre> <p>on_thread_start() is called from a newly created librdkafka-managed thread. </p> WarningThe on_thread_start() interceptor is called from internal librdkafka threads. An on_thread_start() interceptor MUST NOT call any librdkafka API's associated with the <code>rk</code>, or perform any blocking or prolonged work. Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* - The client instance. thread_type <code>int</code> rd_kafka_thread_type_t - Thread type. thread_name <code>string|null</code> const char* - Human-readable thread name, may not be unique. ic_opaque <code>\\FFI\\CData|object|string|null</code> void* - The interceptor\u2019s opaque pointer specified in ..add..(). Returns <code>int</code> rd_kafka_resp_err_t - an error code on failure, the error is logged but otherwise ignored. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aa882b123107dd0fecca114dea26a4c18 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_last_error","title":"rd_kafka_last_error()","text":"<pre><code>public static rd_kafka_last_error (  ): int\n</code></pre> <p>Returns the last error code generated by a legacy API call in the current thread. </p> <p>The legacy APIs are the ones using errno to propagate error value, namely:</p> <ul> <li>rd_kafka_topic_new()</li> <li>rd_kafka_consume_start()</li> <li>rd_kafka_consume_stop()</li> <li>rd_kafka_consume()</li> <li>rd_kafka_consume_batch()</li> <li>rd_kafka_consume_callback()</li> <li>rd_kafka_consume_queue()</li> <li>rd_kafka_produce()</li> </ul> <p>The main use for this function is to avoid converting system <code>errno</code> values to rd_kafka_resp_err_t codes for legacy APIs.</p> RemarksThe last error is stored per-thread, if multiple rd_kafka_t handles are used in the same application thread the developer needs to make sure rd_kafka_last_error() is called immediately after a failed API call.  errno propagation from librdkafka is not safe on Windows and should not be used, use rd_kafka_last_error() instead.  Returns <code>int</code> rd_kafka_resp_err_t - ) <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ae7b90c323d460e0276d79f6ab69e93b7 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_list_groups","title":"rd_kafka_list_groups()","text":"<pre><code>public static rd_kafka_list_groups ( \n    \\FFI\\CData|null $rk, \n    string|null $group, \n    \\FFI\\CData|null $grplistp, \n    int|null $timeout_ms\n ): int\n</code></pre> <p>List and describe client groups in cluster. </p> <p><code>group</code> is an optional group name to describe, otherwise (<code>NULL</code>) all groups are returned.</p> <p><code>timeout_ms</code> is the (approximate) maximum time to wait for response from brokers and must be a positive value.</p> <p>The <code>grplistp</code> remains untouched if any error code is returned, with the exception of RD_KAFKA_RESP_ERR__PARTIAL which behaves as RD_KAFKA_RESP_ERR__NO_ERROR (success) but with an incomplete group list.</p> See alsoUse rd_kafka_group_list_destroy() to release list memory. Deprecated:Use rd_kafka_ListConsumerGroups() and rd_kafka_DescribeConsumerGroups() instead.  Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* group <code>string|null</code> const char* grplistp <code>\\FFI\\CData|null</code> const struct rd_kafka_group_list** timeout_ms <code>int|null</code> int Returns <code>int</code> rd_kafka_resp_err_t - <code>RD_KAFKA_RESP_ERR__NO_ERROR</code> on success and <code>grplistp</code> is updated to point to a newly allocated list of groups. <code>RD_KAFKA_RESP_ERR__PARTIAL</code> if not all brokers responded in time but at least one group is returned in <code>grplistlp</code>. <code>RD_KAFKA_RESP_ERR__TIMED_OUT</code> if no groups were returned in the given timeframe but not all brokers have yet responded, or if the list of brokers in the cluster could not be obtained within the given timeframe. <code>RD_KAFKA_RESP_ERR__TRANSPORT</code> if no brokers were found. Other error codes may also be returned from the request layer. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a6cfc79819453ecd4aa94fbae6dbbea0a </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_log_print","title":"rd_kafka_log_print()","text":"<pre><code>public static rd_kafka_log_print ( \n    \\FFI\\CData|null $rk, \n    int|null $level, \n    string|null $fac, \n    string|null $buf\n ): void\n</code></pre> Parameters rk <code>\\FFI\\CData|null</code> const rd_kafka_t* level <code>int|null</code> int fac <code>string|null</code> const char* buf <code>string|null</code> const char*"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_log_syslog","title":"rd_kafka_log_syslog()","text":"<pre><code>public static rd_kafka_log_syslog ( \n    \\FFI\\CData|null $rk, \n    int|null $level, \n    string|null $fac, \n    string|null $buf\n ): void\n</code></pre> <p>Builtin log sink: print to syslog. </p> RemarksThis logger is only available if librdkafka was built with syslog support.  Parameters rk <code>\\FFI\\CData|null</code> const rd_kafka_t* level <code>int|null</code> int fac <code>string|null</code> const char* buf <code>string|null</code> const char* <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a748d5eaca75f94bb4ff4217ae824385d </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_mem_calloc","title":"rd_kafka_mem_calloc()","text":"<pre><code>public static rd_kafka_mem_calloc ( \n    \\FFI\\CData|null $rk, \n    int|null $num, \n    int|null $size\n ): \\FFI\\CData|object|string|null\n</code></pre> <p>Allocate and zero memory using the same allocator librdkafka uses. </p> <p>This is typically an abstraction for the calloc(3) call and makes sure the application can use the same memory allocator as librdkafka for allocating pointers that are used by librdkafka.</p> <p><code>rk</code> can be set to return memory allocated by a specific <code>rk</code> instance otherwise pass NULL for <code>rk</code>.</p> RemarksMemory allocated by rd_kafka_mem_calloc() must be freed using rd_kafka_mem_free()  Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* num <code>int|null</code> size_t size <code>int|null</code> size_t Returns <code>\\FFI\\CData|object|string|null</code> void* <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a74216ba5f5d1c1d8ec7936c225a73286 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_mem_free","title":"rd_kafka_mem_free()","text":"<pre><code>public static rd_kafka_mem_free ( \n    \\FFI\\CData|null $rk, \n    \\FFI\\CData|object|string|null $ptr\n ): void\n</code></pre> <p>Free pointer returned by librdkafka. </p> <p>This is typically an abstraction for the free(3) call and makes sure the application can use the same memory allocator as librdkafka for freeing pointers returned by librdkafka.</p> <p>In standard setups it is usually not necessary to use this interface rather than the free(3) functione.</p> <p><code>rk</code> must be set for memory returned by APIs that take an <code>rk</code> argument, for other APIs pass NULL for <code>rk</code>.</p> Remarksrd_kafka_mem_free() must only be used for pointers returned by APIs that explicitly mention using this function for freeing.  Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* ptr <code>\\FFI\\CData|object|string|null</code> void* <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a50178b3d3266c9eeb0b5981377833572 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_mem_malloc","title":"rd_kafka_mem_malloc()","text":"<pre><code>public static rd_kafka_mem_malloc ( \n    \\FFI\\CData|null $rk, \n    int|null $size\n ): \\FFI\\CData|object|string|null\n</code></pre> <p>Allocate memory using the same allocator librdkafka uses. </p> <p>This is typically an abstraction for the malloc(3) call and makes sure the application can use the same memory allocator as librdkafka for allocating pointers that are used by librdkafka.</p> <p><code>rk</code> can be set to return memory allocated by a specific <code>rk</code> instance otherwise pass NULL for <code>rk</code>.</p> RemarksMemory allocated by rd_kafka_mem_malloc() must be freed using rd_kafka_mem_free()  Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* size <code>int|null</code> size_t Returns <code>\\FFI\\CData|object|string|null</code> void* <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a60f3ac40bed72542f68c93fa1bc16d3e </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_memberid","title":"rd_kafka_memberid()","text":"<pre><code>public static rd_kafka_memberid ( \n    \\FFI\\CData|null $rk\n ): \\FFI\\CData|null\n</code></pre> <p>Returns this client's broker-assigned group member id. </p> RemarksThis currently requires the high-level KafkaConsumer Parameters rk <code>\\FFI\\CData|null</code> const rd_kafka_t* - ) Returns <code>\\FFI\\CData|null</code> char* - An allocated string containing the current broker-assigned group member id, or NULL if not available. The application must free the string with <code>free()</code> or rd_kafka_mem_free() <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a856d7ecba1aa64e5c89ac92b445cdda6 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_message_broker_id","title":"rd_kafka_message_broker_id()","text":"<pre><code>public static rd_kafka_message_broker_id ( \n    \\FFI\\CData|null $rkmessage\n ): int|null\n</code></pre> <p>Returns the broker id of the broker the message was produced to or fetched from. </p> Parameters rkmessage <code>\\FFI\\CData|null</code> const rd_kafka_message_t* - ) Returns <code>int|null</code> int32_t - a broker id if known, else -1. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aa3ea50bbfa8d7fce4de91a34b1377b52 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_message_destroy","title":"rd_kafka_message_destroy()","text":"<pre><code>public static rd_kafka_message_destroy ( \n    \\FFI\\CData|null $rkmessage\n ): void\n</code></pre> Parameters rkmessage <code>\\FFI\\CData|null</code> rd_kafka_message_t*"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_message_detach_headers","title":"rd_kafka_message_detach_headers()","text":"<pre><code>public static rd_kafka_message_detach_headers ( \n    \\FFI\\CData|null $rkmessage, \n    \\FFI\\CData|null $hdrsp\n ): int\n</code></pre> <p>Get the message header list and detach the list from the message making the application the owner of the headers. The application must eventually destroy the headers using rd_kafka_headers_destroy(). The message's headers will be set to NULL. </p> <p>Otherwise same semantics as rd_kafka_message_headers()</p> See alsord_kafka_message_headers  Parameters rkmessage <code>\\FFI\\CData|null</code> rd_kafka_message_t* hdrsp <code>\\FFI\\CData|null</code> rd_kafka_headers_t** Returns <code>int</code> rd_kafka_resp_err_t <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#af89ef912d3c1ff66ea612fda27c0a643 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_message_errstr","title":"rd_kafka_message_errstr()","text":"<pre><code>public static rd_kafka_message_errstr ( \n    \\FFI\\CData|null $rkmessage\n ): string|null\n</code></pre> <p>Returns the error string for an errored rd_kafka_message_t or NULL if there was no error. </p> RemarksThis function MUST NOT be used with the producer.  Parameters rkmessage <code>\\FFI\\CData|null</code> const rd_kafka_message_t* - ) Returns <code>string|null</code> const char* <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a5908f68997a5bc42695cff2a703618dd </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_message_headers","title":"rd_kafka_message_headers()","text":"<pre><code>public static rd_kafka_message_headers ( \n    \\FFI\\CData|null $rkmessage, \n    \\FFI\\CData|null $hdrsp\n ): int\n</code></pre> <p>Get the message header list. </p> <p>The returned pointer in <code>*hdrsp</code> is associated with the <code>rkmessage</code> and must not be used after destruction of the message object or the header list is replaced with rd_kafka_message_set_headers().</p> RemarksHeaders require broker version 0.11.0.0 or later.  As an optimization the raw protocol headers are parsed on the first call to this function.  Parameters rkmessage <code>\\FFI\\CData|null</code> const rd_kafka_message_t* hdrsp <code>\\FFI\\CData|null</code> rd_kafka_headers_t** Returns <code>int</code> rd_kafka_resp_err_t - RD_KAFKA_RESP_ERR_NO_ERROR if headers were returned, RD_KAFKA_RESP_ERR__NOENT if the message has no headers, or another error code if the headers could not be parsed. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aaccd9ee7e1c73b89d86ed41db3b86e68 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_message_latency","title":"rd_kafka_message_latency()","text":"<pre><code>public static rd_kafka_message_latency ( \n    \\FFI\\CData|null $rkmessage\n ): int|null\n</code></pre> <p>Returns the latency for a produced message measured from the produce() call. </p> Parameters rkmessage <code>\\FFI\\CData|null</code> const rd_kafka_message_t* - ) Returns <code>int|null</code> int64_t - the latency in microseconds, or -1 if not available. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aba20435b42efef7a3c38dee3fb58c27b </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_message_leader_epoch","title":"rd_kafka_message_leader_epoch()","text":"<pre><code>public static rd_kafka_message_leader_epoch ( \n    \\FFI\\CData|null $rkmessage\n ): int|null\n</code></pre> RemarksThis API must only be used on consumed messages without error.   Requires broker version &gt;= 2.10 (KIP-320).  Parameters rkmessage <code>\\FFI\\CData|null</code> const rd_kafka_message_t* - ) Returns <code>int|null</code> int32_t - the message\u2019s partition leader epoch at the time the message was fetched and if known, else -1. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ad9afdf40e60628338c3efcacba4727a2 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_message_produce_errstr","title":"rd_kafka_message_produce_errstr()","text":"<pre><code>public static rd_kafka_message_produce_errstr ( \n    \\FFI\\CData|null $rkmessage\n ): string|null\n</code></pre> <p>Returns the error string for an errored produced rd_kafka_message_t or NULL if there was no error. </p> RemarksThis function MUST used with the producer.  Parameters rkmessage <code>\\FFI\\CData|null</code> const rd_kafka_message_t* - ) Returns <code>string|null</code> const char* <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a308971e7560a146d2af791d7915b38a0 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_message_set_headers","title":"rd_kafka_message_set_headers()","text":"<pre><code>public static rd_kafka_message_set_headers ( \n    \\FFI\\CData|null $rkmessage, \n    \\FFI\\CData|null $hdrs\n ): void\n</code></pre> <p>Replace the message's current headers with a new list. </p> RemarksThe existing headers object, if any, will be destroyed.  Parameters rkmessage <code>\\FFI\\CData|null</code> rd_kafka_message_t* - The message to set headers. hdrs <code>\\FFI\\CData|null</code> rd_kafka_headers_t* - New header list. The message object assumes ownership of the list, the list will be destroyed automatically with the message object. The new headers list may be updated until the message object is passed or returned to librdkafka. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a99e46233e57fc4f5783d8ae374584bbe </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_message_status","title":"rd_kafka_message_status()","text":"<pre><code>public static rd_kafka_message_status ( \n    \\FFI\\CData|null $rkmessage\n ): int\n</code></pre> <p>Returns the message's persistence status in the topic log. </p> RemarksThe message status is not available in on_acknowledgement interceptors.  Parameters rkmessage <code>\\FFI\\CData|null</code> const rd_kafka_message_t* - ) Returns <code>int</code> rd_kafka_msg_status_t <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#af259b9c4216b74d4f750d93ff6396ce5 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_message_timestamp","title":"rd_kafka_message_timestamp()","text":"<pre><code>public static rd_kafka_message_timestamp ( \n    \\FFI\\CData|null $rkmessage, \n    \\FFI\\CData|null $tstype\n ): int|null\n</code></pre> <p>Returns the message timestamp for a consumed message. </p> <p>The timestamp is the number of milliseconds since the epoch (UTC).</p> <p><code>tstype</code> (if not NULL) is updated to indicate the type of timestamp.</p> RemarksMessage timestamps require broker version 0.10.0 or later.  Parameters rkmessage <code>\\FFI\\CData|null</code> const rd_kafka_message_t* tstype <code>\\FFI\\CData|null</code> rd_kafka_timestamp_type_t* Returns <code>int|null</code> int64_t - message timestamp, or -1 if not available. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a4371deba4afe6941cc5f9e80df5ca3e7 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_metadata","title":"rd_kafka_metadata()","text":"<pre><code>public static rd_kafka_metadata ( \n    \\FFI\\CData|null $rk, \n    int|null $all_topics, \n    \\FFI\\CData|null $only_rkt, \n    \\FFI\\CData|null $metadatap, \n    int|null $timeout_ms\n ): int\n</code></pre> <p>Request Metadata from broker. </p> <p>Parameters:</p> <ul> <li><code>all_topics</code> if non-zero: request info about all topics in cluster, if zero: only request info about locally known topics.</li> <li><code>only_rkt</code> only request info about this topic</li> <li><code>metadatap</code> pointer to hold metadata result. The <code>*metadatap</code> pointer must be released with rd_kafka_metadata_destroy().</li> <li><code>timeout_ms</code> maximum response time before failing.</li> </ul> RemarksConsumer: If <code>all_topics</code> is non-zero the Metadata response information may trigger a re-join if any subscribed topics have changed partition count or existence state. Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* all_topics <code>int|null</code> int only_rkt <code>\\FFI\\CData|null</code> rd_kafka_topic_t* metadatap <code>\\FFI\\CData|null</code> const struct rd_kafka_metadata** timeout_ms <code>int|null</code> int Returns <code>int</code> rd_kafka_resp_err_t - RD_KAFKA_RESP_ERR_NO_ERROR on success (in which case *metadatap) will be set, else RD_KAFKA_RESP_ERR__TIMED_OUT on timeout or other error code on error. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a84bba4a4b13fdb515f1a22d6fd4f7344 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_metadata_destroy","title":"rd_kafka_metadata_destroy()","text":"<pre><code>public static rd_kafka_metadata_destroy ( \n    \\FFI\\CData|\\Closure $metadata\n ): void\n</code></pre> Parameters metadata <code>\\FFI\\CData|\\Closure</code> rd_kafka_resp_err_t(rd_kafka_metadata*)(rd_kafka_t*, int, rd_kafka_topic_t*, const struct rd_kafka_metadata**, int)"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_mock_broker_error_stack_cnt","title":"rd_kafka_mock_broker_error_stack_cnt()","text":"<pre><code>public static rd_kafka_mock_broker_error_stack_cnt ( \n    \\FFI\\CData|null $mcluster, \n    int|null $broker_id, \n    int|null $ApiKey, \n    \\FFI\\CData|null $cntp\n ): int\n</code></pre> Parameters mcluster <code>\\FFI\\CData|null</code> rd_kafka_mock_cluster_t* broker_id <code>int|null</code> int32_t ApiKey <code>int|null</code> int16_t cntp <code>\\FFI\\CData|null</code> size_t* Returns <code>int</code> rd_kafka_resp_err_t"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_mock_broker_push_request_error_rtts","title":"rd_kafka_mock_broker_push_request_error_rtts()","text":"<pre><code>public static rd_kafka_mock_broker_push_request_error_rtts ( \n    \\FFI\\CData|null $mcluster, \n    int|null $broker_id, \n    int|null $ApiKey, \n    int|null $cnt, \n    mixed $args\n ): int\n</code></pre> Parameters mcluster <code>\\FFI\\CData|null</code> rd_kafka_mock_cluster_t* broker_id <code>int|null</code> int32_t ApiKey <code>int|null</code> int16_t cnt <code>int|null</code> size_t args <code>mixed</code> Returns <code>int</code> rd_kafka_resp_err_t"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_mock_broker_push_request_errors","title":"rd_kafka_mock_broker_push_request_errors()","text":"<pre><code>public static rd_kafka_mock_broker_push_request_errors ( \n    \\FFI\\CData|null $mcluster, \n    int|null $broker_id, \n    int|null $ApiKey, \n    int|null $cnt, \n    mixed $args\n ): int\n</code></pre> Parameters mcluster <code>\\FFI\\CData|null</code> rd_kafka_mock_cluster_t* broker_id <code>int|null</code> int32_t ApiKey <code>int|null</code> int16_t cnt <code>int|null</code> size_t args <code>mixed</code> Returns <code>int</code> rd_kafka_resp_err_t"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_mock_broker_set_down","title":"rd_kafka_mock_broker_set_down()","text":"<pre><code>public static rd_kafka_mock_broker_set_down ( \n    \\FFI\\CData|null $mcluster, \n    int|null $broker_id\n ): int\n</code></pre> Parameters mcluster <code>\\FFI\\CData|null</code> rd_kafka_mock_cluster_t* broker_id <code>int|null</code> int32_t Returns <code>int</code> rd_kafka_resp_err_t"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_mock_broker_set_rack","title":"rd_kafka_mock_broker_set_rack()","text":"<pre><code>public static rd_kafka_mock_broker_set_rack ( \n    \\FFI\\CData|null $mcluster, \n    int|null $broker_id, \n    string|null $rack\n ): int\n</code></pre> Parameters mcluster <code>\\FFI\\CData|null</code> rd_kafka_mock_cluster_t* broker_id <code>int|null</code> int32_t rack <code>string|null</code> const char* Returns <code>int</code> rd_kafka_resp_err_t"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_mock_broker_set_rtt","title":"rd_kafka_mock_broker_set_rtt()","text":"<pre><code>public static rd_kafka_mock_broker_set_rtt ( \n    \\FFI\\CData|null $mcluster, \n    int|null $broker_id, \n    int|null $rtt_ms\n ): int\n</code></pre> Parameters mcluster <code>\\FFI\\CData|null</code> rd_kafka_mock_cluster_t* broker_id <code>int|null</code> int32_t rtt_ms <code>int|null</code> int Returns <code>int</code> rd_kafka_resp_err_t"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_mock_broker_set_up","title":"rd_kafka_mock_broker_set_up()","text":"<pre><code>public static rd_kafka_mock_broker_set_up ( \n    \\FFI\\CData|null $mcluster, \n    int|null $broker_id\n ): int\n</code></pre> Parameters mcluster <code>\\FFI\\CData|null</code> rd_kafka_mock_cluster_t* broker_id <code>int|null</code> int32_t Returns <code>int</code> rd_kafka_resp_err_t"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_mock_cgrp_consumer_target_assignment","title":"rd_kafka_mock_cgrp_consumer_target_assignment()","text":"<pre><code>public static rd_kafka_mock_cgrp_consumer_target_assignment ( \n    \\FFI\\CData|null $mcluster, \n    string|null $group_id, \n    \\FFI\\CData|null $target_assignment\n ): void\n</code></pre> Parameters mcluster <code>\\FFI\\CData|null</code> rd_kafka_mock_cluster_t* group_id <code>string|null</code> const char* target_assignment <code>\\FFI\\CData|null</code> rd_kafka_mock_cgrp_consumer_target_assignment_t*"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_mock_cgrp_consumer_target_assignment_destroy","title":"rd_kafka_mock_cgrp_consumer_target_assignment_destroy()","text":"<pre><code>public static rd_kafka_mock_cgrp_consumer_target_assignment_destroy ( \n    \\FFI\\CData|null $target_assignment\n ): void\n</code></pre> Parameters target_assignment <code>\\FFI\\CData|null</code> rd_kafka_mock_cgrp_consumer_target_assignment_t*"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_mock_cgrp_consumer_target_assignment_new","title":"rd_kafka_mock_cgrp_consumer_target_assignment_new()","text":"<pre><code>public static rd_kafka_mock_cgrp_consumer_target_assignment_new ( \n    \\FFI\\CData|null $member_ids, \n    int|null $member_cnt, \n    \\FFI\\CData|null $assignment\n ): \\FFI\\CData|null\n</code></pre> Parameters member_ids <code>\\FFI\\CData|null</code> char** member_cnt <code>int|null</code> int assignment <code>\\FFI\\CData|null</code> rd_kafka_topic_partition_list_t** Returns <code>\\FFI\\CData|null</code> rd_kafka_mock_cgrp_consumer_target_assignment_t*"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_mock_clear_request_errors","title":"rd_kafka_mock_clear_request_errors()","text":"<pre><code>public static rd_kafka_mock_clear_request_errors ( \n    \\FFI\\CData|null $mcluster, \n    int|null $ApiKey\n ): void\n</code></pre> Parameters mcluster <code>\\FFI\\CData|null</code> rd_kafka_mock_cluster_t* ApiKey <code>int|null</code> int16_t"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_mock_clear_requests","title":"rd_kafka_mock_clear_requests()","text":"<pre><code>public static rd_kafka_mock_clear_requests ( \n    \\FFI\\CData|null $mcluster\n ): void\n</code></pre> Parameters mcluster <code>\\FFI\\CData|null</code> rd_kafka_mock_cluster_t*"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_mock_cluster_bootstraps","title":"rd_kafka_mock_cluster_bootstraps()","text":"<pre><code>public static rd_kafka_mock_cluster_bootstraps ( \n    \\FFI\\CData|null $mcluster\n ): string|null\n</code></pre> Parameters mcluster <code>\\FFI\\CData|null</code> const rd_kafka_mock_cluster_t* Returns <code>string|null</code> const char*"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_mock_cluster_destroy","title":"rd_kafka_mock_cluster_destroy()","text":"<pre><code>public static rd_kafka_mock_cluster_destroy ( \n    \\FFI\\CData|null $mcluster\n ): void\n</code></pre> Parameters mcluster <code>\\FFI\\CData|null</code> rd_kafka_mock_cluster_t*"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_mock_cluster_handle","title":"rd_kafka_mock_cluster_handle()","text":"<pre><code>public static rd_kafka_mock_cluster_handle ( \n    \\FFI\\CData|null $mcluster\n ): \\FFI\\CData|null\n</code></pre> Parameters mcluster <code>\\FFI\\CData|null</code> const rd_kafka_mock_cluster_t* Returns <code>\\FFI\\CData|null</code> rd_kafka_t*"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_mock_cluster_new","title":"rd_kafka_mock_cluster_new()","text":"<pre><code>public static rd_kafka_mock_cluster_new ( \n    \\FFI\\CData|null $rk, \n    int|null $broker_cnt\n ): \\FFI\\CData|null\n</code></pre> Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* broker_cnt <code>int|null</code> int Returns <code>\\FFI\\CData|null</code> rd_kafka_mock_cluster_t*"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_mock_coordinator_set","title":"rd_kafka_mock_coordinator_set()","text":"<pre><code>public static rd_kafka_mock_coordinator_set ( \n    \\FFI\\CData|null $mcluster, \n    string|null $key_type, \n    string|null $key, \n    int|null $broker_id\n ): int\n</code></pre> Parameters mcluster <code>\\FFI\\CData|null</code> rd_kafka_mock_cluster_t* key_type <code>string|null</code> const char* key <code>string|null</code> const char* broker_id <code>int|null</code> int32_t Returns <code>int</code> rd_kafka_resp_err_t"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_mock_get_requests","title":"rd_kafka_mock_get_requests()","text":"<pre><code>public static rd_kafka_mock_get_requests ( \n    \\FFI\\CData|null $mcluster, \n    \\FFI\\CData|null $cntp\n ): \\FFI\\CData|null\n</code></pre> Parameters mcluster <code>\\FFI\\CData|null</code> rd_kafka_mock_cluster_t* cntp <code>\\FFI\\CData|null</code> size_t* Returns <code>\\FFI\\CData|null</code> rd_kafka_mock_request_t**"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_mock_group_initial_rebalance_delay_ms","title":"rd_kafka_mock_group_initial_rebalance_delay_ms()","text":"<pre><code>public static rd_kafka_mock_group_initial_rebalance_delay_ms ( \n    \\FFI\\CData|null $mcluster, \n    int|null $delay_ms\n ): void\n</code></pre> Parameters mcluster <code>\\FFI\\CData|null</code> rd_kafka_mock_cluster_t* delay_ms <code>int|null</code> int32_t"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_mock_partition_push_leader_response","title":"rd_kafka_mock_partition_push_leader_response()","text":"<pre><code>public static rd_kafka_mock_partition_push_leader_response ( \n    \\FFI\\CData|null $mcluster, \n    string|null $topic, \n    int|null $partition, \n    int|null $leader_id, \n    int|null $leader_epoch\n ): int\n</code></pre> Parameters mcluster <code>\\FFI\\CData|null</code> rd_kafka_mock_cluster_t* topic <code>string|null</code> const char* partition <code>int|null</code> int leader_id <code>int|null</code> int32_t leader_epoch <code>int|null</code> int32_t Returns <code>int</code> rd_kafka_resp_err_t"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_mock_partition_set_follower","title":"rd_kafka_mock_partition_set_follower()","text":"<pre><code>public static rd_kafka_mock_partition_set_follower ( \n    \\FFI\\CData|null $mcluster, \n    string|null $topic, \n    int|null $partition, \n    int|null $broker_id\n ): int\n</code></pre> Parameters mcluster <code>\\FFI\\CData|null</code> rd_kafka_mock_cluster_t* topic <code>string|null</code> const char* partition <code>int|null</code> int32_t broker_id <code>int|null</code> int32_t Returns <code>int</code> rd_kafka_resp_err_t"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_mock_partition_set_follower_wmarks","title":"rd_kafka_mock_partition_set_follower_wmarks()","text":"<pre><code>public static rd_kafka_mock_partition_set_follower_wmarks ( \n    \\FFI\\CData|null $mcluster, \n    string|null $topic, \n    int|null $partition, \n    int|null $lo, \n    int|null $hi\n ): int\n</code></pre> Parameters mcluster <code>\\FFI\\CData|null</code> rd_kafka_mock_cluster_t* topic <code>string|null</code> const char* partition <code>int|null</code> int32_t lo <code>int|null</code> int64_t hi <code>int|null</code> int64_t Returns <code>int</code> rd_kafka_resp_err_t"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_mock_partition_set_leader","title":"rd_kafka_mock_partition_set_leader()","text":"<pre><code>public static rd_kafka_mock_partition_set_leader ( \n    \\FFI\\CData|null $mcluster, \n    string|null $topic, \n    int|null $partition, \n    int|null $broker_id\n ): int\n</code></pre> Parameters mcluster <code>\\FFI\\CData|null</code> rd_kafka_mock_cluster_t* topic <code>string|null</code> const char* partition <code>int|null</code> int32_t broker_id <code>int|null</code> int32_t Returns <code>int</code> rd_kafka_resp_err_t"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_mock_push_request_errors","title":"rd_kafka_mock_push_request_errors()","text":"<pre><code>public static rd_kafka_mock_push_request_errors ( \n    \\FFI\\CData|null $mcluster, \n    int|null $ApiKey, \n    int|null $cnt, \n    mixed $args\n ): void\n</code></pre> Parameters mcluster <code>\\FFI\\CData|null</code> rd_kafka_mock_cluster_t* ApiKey <code>int|null</code> int16_t cnt <code>int|null</code> size_t args <code>mixed</code>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_mock_push_request_errors_array","title":"rd_kafka_mock_push_request_errors_array()","text":"<pre><code>public static rd_kafka_mock_push_request_errors_array ( \n    \\FFI\\CData|null $mcluster, \n    int|null $ApiKey, \n    int|null $cnt, \n    \\FFI\\CData|null $errors\n ): void\n</code></pre> Parameters mcluster <code>\\FFI\\CData|null</code> rd_kafka_mock_cluster_t* ApiKey <code>int|null</code> int16_t cnt <code>int|null</code> size_t errors <code>\\FFI\\CData|null</code> const rd_kafka_resp_err_t*"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_mock_request_api_key","title":"rd_kafka_mock_request_api_key()","text":"<pre><code>public static rd_kafka_mock_request_api_key ( \n    \\FFI\\CData|null $mreq\n ): int|null\n</code></pre> Parameters mreq <code>\\FFI\\CData|null</code> rd_kafka_mock_request_t* Returns <code>int|null</code> int16_t"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_mock_request_destroy","title":"rd_kafka_mock_request_destroy()","text":"<pre><code>public static rd_kafka_mock_request_destroy ( \n    \\FFI\\CData|null $mreq\n ): void\n</code></pre> Parameters mreq <code>\\FFI\\CData|null</code> rd_kafka_mock_request_t*"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_mock_request_destroy_array","title":"rd_kafka_mock_request_destroy_array()","text":"<pre><code>public static rd_kafka_mock_request_destroy_array ( \n    \\FFI\\CData|null $mreqs, \n    int|null $mreq_cnt\n ): void\n</code></pre> Parameters mreqs <code>\\FFI\\CData|null</code> rd_kafka_mock_request_t** mreq_cnt <code>int|null</code> size_t"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_mock_request_id","title":"rd_kafka_mock_request_id()","text":"<pre><code>public static rd_kafka_mock_request_id ( \n    \\FFI\\CData|null $mreq\n ): int|null\n</code></pre> Parameters mreq <code>\\FFI\\CData|null</code> rd_kafka_mock_request_t* Returns <code>int|null</code> int32_t"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_mock_request_timestamp","title":"rd_kafka_mock_request_timestamp()","text":"<pre><code>public static rd_kafka_mock_request_timestamp ( \n    \\FFI\\CData|null $mreq\n ): int|null\n</code></pre> Parameters mreq <code>\\FFI\\CData|null</code> rd_kafka_mock_request_t* Returns <code>int|null</code> int64_t"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_mock_set_apiversion","title":"rd_kafka_mock_set_apiversion()","text":"<pre><code>public static rd_kafka_mock_set_apiversion ( \n    \\FFI\\CData|null $mcluster, \n    int|null $ApiKey, \n    int|null $MinVersion, \n    int|null $MaxVersion\n ): int\n</code></pre> Parameters mcluster <code>\\FFI\\CData|null</code> rd_kafka_mock_cluster_t* ApiKey <code>int|null</code> int16_t MinVersion <code>int|null</code> int16_t MaxVersion <code>int|null</code> int16_t Returns <code>int</code> rd_kafka_resp_err_t"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_mock_set_group_consumer_heartbeat_interval_ms","title":"rd_kafka_mock_set_group_consumer_heartbeat_interval_ms()","text":"<pre><code>public static rd_kafka_mock_set_group_consumer_heartbeat_interval_ms ( \n    \\FFI\\CData|null $mcluster, \n    int|null $group_consumer_heartbeat_interval_ms\n ): void\n</code></pre> Parameters mcluster <code>\\FFI\\CData|null</code> rd_kafka_mock_cluster_t* group_consumer_heartbeat_interval_ms <code>int|null</code> int"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_mock_set_group_consumer_session_timeout_ms","title":"rd_kafka_mock_set_group_consumer_session_timeout_ms()","text":"<pre><code>public static rd_kafka_mock_set_group_consumer_session_timeout_ms ( \n    \\FFI\\CData|null $mcluster, \n    int|null $group_consumer_session_timeout_ms\n ): void\n</code></pre> Parameters mcluster <code>\\FFI\\CData|null</code> rd_kafka_mock_cluster_t* group_consumer_session_timeout_ms <code>int|null</code> int"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_mock_start_request_tracking","title":"rd_kafka_mock_start_request_tracking()","text":"<pre><code>public static rd_kafka_mock_start_request_tracking ( \n    \\FFI\\CData|null $mcluster\n ): void\n</code></pre> Parameters mcluster <code>\\FFI\\CData|null</code> rd_kafka_mock_cluster_t*"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_mock_stop_request_tracking","title":"rd_kafka_mock_stop_request_tracking()","text":"<pre><code>public static rd_kafka_mock_stop_request_tracking ( \n    \\FFI\\CData|null $mcluster\n ): void\n</code></pre> Parameters mcluster <code>\\FFI\\CData|null</code> rd_kafka_mock_cluster_t*"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_mock_telemetry_set_push_interval","title":"rd_kafka_mock_telemetry_set_push_interval()","text":"<pre><code>public static rd_kafka_mock_telemetry_set_push_interval ( \n    \\FFI\\CData|null $mcluster, \n    int|null $push_interval_ms\n ): int\n</code></pre> Parameters mcluster <code>\\FFI\\CData|null</code> rd_kafka_mock_cluster_t* push_interval_ms <code>int|null</code> int64_t Returns <code>int</code> rd_kafka_resp_err_t"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_mock_telemetry_set_requested_metrics","title":"rd_kafka_mock_telemetry_set_requested_metrics()","text":"<pre><code>public static rd_kafka_mock_telemetry_set_requested_metrics ( \n    \\FFI\\CData|null $mcluster, \n    \\FFI\\CData|null $metrics, \n    int|null $metrics_cnt\n ): int\n</code></pre> Parameters mcluster <code>\\FFI\\CData|null</code> rd_kafka_mock_cluster_t* metrics <code>\\FFI\\CData|null</code> char** metrics_cnt <code>int|null</code> size_t Returns <code>int</code> rd_kafka_resp_err_t"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_mock_topic_create","title":"rd_kafka_mock_topic_create()","text":"<pre><code>public static rd_kafka_mock_topic_create ( \n    \\FFI\\CData|null $mcluster, \n    string|null $topic, \n    int|null $partition_cnt, \n    int|null $replication_factor\n ): int\n</code></pre> Parameters mcluster <code>\\FFI\\CData|null</code> rd_kafka_mock_cluster_t* topic <code>string|null</code> const char* partition_cnt <code>int|null</code> int replication_factor <code>int|null</code> int Returns <code>int</code> rd_kafka_resp_err_t"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_mock_topic_set_error","title":"rd_kafka_mock_topic_set_error()","text":"<pre><code>public static rd_kafka_mock_topic_set_error ( \n    \\FFI\\CData|null $mcluster, \n    string|null $topic, \n    int $err\n ): void\n</code></pre> Parameters mcluster <code>\\FFI\\CData|null</code> rd_kafka_mock_cluster_t* topic <code>string|null</code> const char* err <code>int</code> rd_kafka_resp_err_t"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_msg_partitioner_consistent","title":"rd_kafka_msg_partitioner_consistent()","text":"<pre><code>public static rd_kafka_msg_partitioner_consistent ( \n    \\FFI\\CData|null $rkt, \n    \\FFI\\CData|object|string|null $key, \n    int|null $keylen, \n    int|null $partition_cnt, \n    \\FFI\\CData|object|string|null $opaque, \n    \\FFI\\CData|object|string|null $msg_opaque\n ): int|null\n</code></pre> <p>Consistent partitioner. </p> <p>Uses consistent hashing to map identical keys onto identical partitions.</p> <p>The <code>rkt_opaque</code> argument is the opaque set by rd_kafka_topic_conf_set_opaque(). The <code>msg_opaque</code> argument is the per-message opaque passed to produce().</p> Parameters rkt <code>\\FFI\\CData|null</code> const rd_kafka_topic_t* key <code>\\FFI\\CData|object|string|null</code> const void* keylen <code>int|null</code> size_t partition_cnt <code>int|null</code> int32_t opaque <code>\\FFI\\CData|object|string|null</code> void* msg_opaque <code>\\FFI\\CData|object|string|null</code> void* Returns <code>int|null</code> int32_t - a \u201crandom\u201d partition between 0 and <code>partition_cnt</code> - 1 based on the CRC value of the key <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aac74a45b5ce46035782198f683b22363 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_msg_partitioner_consistent_random","title":"rd_kafka_msg_partitioner_consistent_random()","text":"<pre><code>public static rd_kafka_msg_partitioner_consistent_random ( \n    \\FFI\\CData|null $rkt, \n    \\FFI\\CData|object|string|null $key, \n    int|null $keylen, \n    int|null $partition_cnt, \n    \\FFI\\CData|object|string|null $opaque, \n    \\FFI\\CData|object|string|null $msg_opaque\n ): int|null\n</code></pre> <p>Consistent-Random partitioner. </p> <p>This is the default partitioner. Uses consistent hashing to map identical keys onto identical partitions, and messages without keys will be assigned via the random partitioner.</p> <p>The <code>rkt_opaque</code> argument is the opaque set by rd_kafka_topic_conf_set_opaque(). The <code>msg_opaque</code> argument is the per-message opaque passed to produce().</p> Parameters rkt <code>\\FFI\\CData|null</code> const rd_kafka_topic_t* key <code>\\FFI\\CData|object|string|null</code> const void* keylen <code>int|null</code> size_t partition_cnt <code>int|null</code> int32_t opaque <code>\\FFI\\CData|object|string|null</code> void* msg_opaque <code>\\FFI\\CData|object|string|null</code> void* Returns <code>int|null</code> int32_t - a \u201crandom\u201d partition between 0 and <code>partition_cnt</code> - 1 based on the CRC value of the key (if provided) <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aed746103dc635aa591658f98a1707e57 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_msg_partitioner_fnv1a","title":"rd_kafka_msg_partitioner_fnv1a()","text":"<pre><code>public static rd_kafka_msg_partitioner_fnv1a ( \n    \\FFI\\CData|null $rkt, \n    \\FFI\\CData|object|string|null $key, \n    int|null $keylen, \n    int|null $partition_cnt, \n    \\FFI\\CData|object|string|null $rkt_opaque, \n    \\FFI\\CData|object|string|null $msg_opaque\n ): int|null\n</code></pre> <p>FNV-1a partitioner. </p> <p>Uses consistent hashing to map identical keys onto identical partitions using FNV-1a hashing.</p> <p>The <code>rkt_opaque</code> argument is the opaque set by rd_kafka_topic_conf_set_opaque(). The <code>msg_opaque</code> argument is the per-message opaque passed to produce().</p> Parameters rkt <code>\\FFI\\CData|null</code> const rd_kafka_topic_t* key <code>\\FFI\\CData|object|string|null</code> const void* keylen <code>int|null</code> size_t partition_cnt <code>int|null</code> int32_t rkt_opaque <code>\\FFI\\CData|object|string|null</code> void* msg_opaque <code>\\FFI\\CData|object|string|null</code> void* Returns <code>int|null</code> int32_t - a partition between 0 and <code>partition_cnt</code> - 1. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#abf216e03c718df36bb37e1affbc8c8f7 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_msg_partitioner_fnv1a_random","title":"rd_kafka_msg_partitioner_fnv1a_random()","text":"<pre><code>public static rd_kafka_msg_partitioner_fnv1a_random ( \n    \\FFI\\CData|null $rkt, \n    \\FFI\\CData|object|string|null $key, \n    int|null $keylen, \n    int|null $partition_cnt, \n    \\FFI\\CData|object|string|null $rkt_opaque, \n    \\FFI\\CData|object|string|null $msg_opaque\n ): int|null\n</code></pre> <p>Consistent-Random FNV-1a partitioner. </p> <p>Uses consistent hashing to map identical keys onto identical partitions using FNV-1a hashing. Messages without keys will be assigned via the random partitioner.</p> <p>The <code>rkt_opaque</code> argument is the opaque set by rd_kafka_topic_conf_set_opaque(). The <code>msg_opaque</code> argument is the per-message opaque passed to produce().</p> Parameters rkt <code>\\FFI\\CData|null</code> const rd_kafka_topic_t* key <code>\\FFI\\CData|object|string|null</code> const void* keylen <code>int|null</code> size_t partition_cnt <code>int|null</code> int32_t rkt_opaque <code>\\FFI\\CData|object|string|null</code> void* msg_opaque <code>\\FFI\\CData|object|string|null</code> void* Returns <code>int|null</code> int32_t - a partition between 0 and <code>partition_cnt</code> - 1. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ac6bbf5fabd7def78d9d0677af2d383b0 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_msg_partitioner_murmur2","title":"rd_kafka_msg_partitioner_murmur2()","text":"<pre><code>public static rd_kafka_msg_partitioner_murmur2 ( \n    \\FFI\\CData|null $rkt, \n    \\FFI\\CData|object|string|null $key, \n    int|null $keylen, \n    int|null $partition_cnt, \n    \\FFI\\CData|object|string|null $rkt_opaque, \n    \\FFI\\CData|object|string|null $msg_opaque\n ): int|null\n</code></pre> <p>Murmur2 partitioner (Java compatible). </p> <p>Uses consistent hashing to map identical keys onto identical partitions using Java-compatible Murmur2 hashing.</p> <p>The <code>rkt_opaque</code> argument is the opaque set by rd_kafka_topic_conf_set_opaque(). The <code>msg_opaque</code> argument is the per-message opaque passed to produce().</p> Parameters rkt <code>\\FFI\\CData|null</code> const rd_kafka_topic_t* key <code>\\FFI\\CData|object|string|null</code> const void* keylen <code>int|null</code> size_t partition_cnt <code>int|null</code> int32_t rkt_opaque <code>\\FFI\\CData|object|string|null</code> void* msg_opaque <code>\\FFI\\CData|object|string|null</code> void* Returns <code>int|null</code> int32_t - a partition between 0 and <code>partition_cnt</code> - 1. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a009f294dc88a214850760216d3fe2d5f </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_msg_partitioner_murmur2_random","title":"rd_kafka_msg_partitioner_murmur2_random()","text":"<pre><code>public static rd_kafka_msg_partitioner_murmur2_random ( \n    \\FFI\\CData|null $rkt, \n    \\FFI\\CData|object|string|null $key, \n    int|null $keylen, \n    int|null $partition_cnt, \n    \\FFI\\CData|object|string|null $rkt_opaque, \n    \\FFI\\CData|object|string|null $msg_opaque\n ): int|null\n</code></pre> <p>Consistent-Random Murmur2 partitioner (Java compatible). </p> <p>Uses consistent hashing to map identical keys onto identical partitions using Java-compatible Murmur2 hashing. Messages without keys will be assigned via the random partitioner.</p> <p>The <code>rkt_opaque</code> argument is the opaque set by rd_kafka_topic_conf_set_opaque(). The <code>msg_opaque</code> argument is the per-message opaque passed to produce().</p> Parameters rkt <code>\\FFI\\CData|null</code> const rd_kafka_topic_t* key <code>\\FFI\\CData|object|string|null</code> const void* keylen <code>int|null</code> size_t partition_cnt <code>int|null</code> int32_t rkt_opaque <code>\\FFI\\CData|object|string|null</code> void* msg_opaque <code>\\FFI\\CData|object|string|null</code> void* Returns <code>int|null</code> int32_t - a partition between 0 and <code>partition_cnt</code> - 1. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ab5dab15f3d0a293db43338f17544e26a </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_msg_partitioner_random","title":"rd_kafka_msg_partitioner_random()","text":"<pre><code>public static rd_kafka_msg_partitioner_random ( \n    \\FFI\\CData|null $rkt, \n    \\FFI\\CData|object|string|null $key, \n    int|null $keylen, \n    int|null $partition_cnt, \n    \\FFI\\CData|object|string|null $opaque, \n    \\FFI\\CData|object|string|null $msg_opaque\n ): int|null\n</code></pre> <p>Random partitioner. </p> <p>Will try not to return unavailable partitions.</p> <p>The <code>rkt_opaque</code> argument is the opaque set by rd_kafka_topic_conf_set_opaque(). The <code>msg_opaque</code> argument is the per-message opaque passed to produce().</p> Parameters rkt <code>\\FFI\\CData|null</code> const rd_kafka_topic_t* key <code>\\FFI\\CData|object|string|null</code> const void* keylen <code>int|null</code> size_t partition_cnt <code>int|null</code> int32_t opaque <code>\\FFI\\CData|object|string|null</code> void* msg_opaque <code>\\FFI\\CData|object|string|null</code> void* Returns <code>int|null</code> int32_t - a random partition between 0 and <code>partition_cnt</code> - 1. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a58ba8a3d1b491ecc32fe29e56d4142aa </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_name","title":"rd_kafka_name()","text":"<pre><code>public static rd_kafka_name ( \n    \\FFI\\CData|null $rk\n ): string|null\n</code></pre> Parameters rk <code>\\FFI\\CData|null</code> const rd_kafka_t* Returns <code>string|null</code> const char*"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_new","title":"rd_kafka_new()","text":"<pre><code>public static rd_kafka_new ( \n    int $type, \n    \\FFI\\CData|null $conf, \n    \\FFI\\CData|null $errstr, \n    int|null $errstr_size\n ): \\FFI\\CData|null\n</code></pre> <p>Creates a new Kafka handle and starts its operation according to the specified <code>type</code> (<code>RD_KAFKA_CONSUMER</code> or <code>RD_KAFKA_PRODUCER</code>). </p> <p><code>conf</code> is an optional struct created with <code>rd_kafka_conf_new()</code> that will be used instead of the default configuration. The <code>conf</code> object is freed by this function on success and must not be used or destroyed by the application subsequently. See <code>rd_kafka_conf_set()</code> et.al for more information.</p> <p><code>errstr</code> must be a pointer to memory of at least size <code>errstr_size</code> where <code>rd_kafka_new()</code> may write a human readable error message in case the creation of a new handle fails. In which case the function returns NULL.</p> RemarksRD_KAFKA_CONSUMER: When a new <code>RD_KAFKA_CONSUMER</code> rd_kafka_t handle is created it may either operate in the legacy simple consumer mode using the rd_kafka_consume_start() interface, or the High-level KafkaConsumer API.   An application must only use one of these groups of APIs on a given rd_kafka_t RD_KAFKA_CONSUMER handle. See alsoTo destroy the Kafka handle, use rd_kafka_destroy().  Parameters type <code>int</code> rd_kafka_type_t conf <code>\\FFI\\CData|null</code> rd_kafka_conf_t* errstr <code>\\FFI\\CData|null</code> char* errstr_size <code>int|null</code> size_t Returns <code>\\FFI\\CData|null</code> rd_kafka_t* - The Kafka handle on success or NULL on error (see <code>errstr</code>) <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a63d5cd86ab1f77772b2be170e1c09c24 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_oauthbearer_set_token","title":"rd_kafka_oauthbearer_set_token()","text":"<pre><code>public static rd_kafka_oauthbearer_set_token ( \n    \\FFI\\CData|null $rk, \n    string|null $token_value, \n    int|null $md_lifetime_ms, \n    string|null $md_principal_name, \n    \\FFI\\CData|null $extensions, \n    int|null $extension_size, \n    \\FFI\\CData|null $errstr, \n    int|null $errstr_size\n ): int\n</code></pre> <p>Set SASL/OAUTHBEARER token and metadata. </p> <p>The SASL/OAUTHBEARER token refresh callback or event handler should invoke this method upon success. The extension keys must not include the reserved key \"`auth`\", and all extension keys and values must conform to the required format as per https://tools.ietf.org/html/rfc7628#section-3.1: </p> <pre>key            = 1*(ALPHA)\nvalue          = *(VCHAR / SP / HTAB / CR / LF )\n</pre> See alsord_kafka_oauthbearer_set_token_failure   rd_kafka_conf_set_oauthbearer_token_refresh_cb  Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* - Client instance. token_value <code>string|null</code> const char* - the mandatory token value to set, often (but not necessarily) a JWS compact serialization as per https://tools.ietf.org/html/rfc7515#section-3.1. md_lifetime_ms <code>int|null</code> int64_t - when the token expires, in terms of the number of milliseconds since the epoch. md_principal_name <code>string|null</code> const char* - the mandatory Kafka principal name associated with the token. extensions <code>\\FFI\\CData|null</code> const char** - optional SASL extensions key-value array with <code>extensions_size</code> elements (number of keys * 2), where [i] is the key and [i+1] is the key\u2019s value, to be communicated to the broker as additional key-value pairs during the initial client response as per https://tools.ietf.org/html/rfc7628#section-3.1. The key-value pairs are copied. extension_size <code>int|null</code> size_t - the number of SASL extension keys plus values, which must be a non-negative multiple of 2. errstr <code>\\FFI\\CData|null</code> char* - A human readable error string (nul-terminated) is written to this location that must be of at least <code>errstr_size</code> bytes. The <code>errstr</code> is only written in case of error. - Writable size in <code>errstr</code>. errstr_size <code>int|null</code> size_t Returns <code>int</code> rd_kafka_resp_err_t - <code>RD_KAFKA_RESP_ERR_NO_ERROR</code> on success, otherwise <code>errstr</code> set and: <code>RD_KAFKA_RESP_ERR__INVALID_ARG</code> if any of the arguments are invalid; <code>RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED</code> if SASL/OAUTHBEARER is not supported by this build; <code>RD_KAFKA_RESP_ERR__STATE</code> if SASL/OAUTHBEARER is supported but is not configured as the client\u2019s authentication mechanism. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a16d208d8ccfeee3d7084402ae24b641f </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_oauthbearer_set_token_failure","title":"rd_kafka_oauthbearer_set_token_failure()","text":"<pre><code>public static rd_kafka_oauthbearer_set_token_failure ( \n    \\FFI\\CData|null $rk, \n    string|null $errstr\n ): int\n</code></pre> <p>SASL/OAUTHBEARER token refresh failure indicator. </p> <p>The SASL/OAUTHBEARER token refresh callback or event handler should invoke this method upon failure.</p> See alsord_kafka_oauthbearer_set_token   rd_kafka_conf_set_oauthbearer_token_refresh_cb  Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* - Client instance. errstr <code>string|null</code> const char* - mandatory human readable error reason for failing to acquire a token. Returns <code>int</code> rd_kafka_resp_err_t - <code>RD_KAFKA_RESP_ERR_NO_ERROR</code> on success, otherwise: <code>RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED</code> if SASL/OAUTHBEARER is not supported by this build; <code>RD_KAFKA_RESP_ERR__STATE</code> if SASL/OAUTHBEARER is supported but is not configured as the client\u2019s authentication mechanism, <code>RD_KAFKA_RESP_ERR__INVALID_ARG</code> if no error string is supplied. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a5a88c547172a961cea4c854f01740ce8 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_offset_store","title":"rd_kafka_offset_store()","text":"<pre><code>public static rd_kafka_offset_store ( \n    \\FFI\\CData|null $rkt, \n    int|null $partition, \n    int|null $offset\n ): int\n</code></pre> <p>Store offset <code>offset</code> + 1 for topic <code>rkt</code> partition <code>partition</code>. </p> <p>The <code>offset</code> + 1 will be committed (written) to broker (or file) according to <code><code>auto.commit.interval.ms</code></code> or manual offset-less commit()</p> Deprecated:This API lacks support for partition leader epochs, which makes it at risk for unclean leader election log truncation issues. Use rd_kafka_offsets_store() and rd_kafka_offset_store_message() instead. WarningThis method may only be called for partitions that are currently assigned. Non-assigned partitions will fail with RD_KAFKA_RESP_ERR__STATE. Since v1.9.0.  Avoid storing offsets after calling rd_kafka_seek() (et.al) as this may later interfere with resuming a paused partition, instead store offsets prior to calling seek. Remarks<code><code>enable.auto.offset.store</code></code> must be set to \"false\" when using this API. Parameters rkt <code>\\FFI\\CData|null</code> rd_kafka_topic_t* partition <code>int|null</code> int32_t offset <code>int|null</code> int64_t Returns <code>int</code> rd_kafka_resp_err_t - RD_KAFKA_RESP_ERR_NO_ERROR on success or an error code on error. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a784186db1d2cb6ceebcd5606d38db4c4 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_offset_store_message","title":"rd_kafka_offset_store_message()","text":"<pre><code>public static rd_kafka_offset_store_message ( \n    \\FFI\\CData|null $rkmessage\n ): \\FFI\\CData|null\n</code></pre> <p>Store offset +1 for the consumed message. </p> <p>The message offset + 1 will be committed to broker according to <code><code>auto.commit.interval.ms</code></code> or manual offset-less commit()</p> WarningThis method may only be called for partitions that are currently assigned. Non-assigned partitions will fail with RD_KAFKA_RESP_ERR__STATE. Since v1.9.0.  Avoid storing offsets after calling rd_kafka_seek() (et.al) as this may later interfere with resuming a paused partition, instead store offsets prior to calling seek. Remarks<code><code>enable.auto.offset.store</code></code> must be set to \"false\" when using this API. Parameters rkmessage <code>\\FFI\\CData|null</code> rd_kafka_message_t* - ) Returns <code>\\FFI\\CData|null</code> rd_kafka_error_t* - NULL on success or an error object on failure. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a85d589ef6cb2d6a1d34e5594949bc9ee </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_offsets_for_times","title":"rd_kafka_offsets_for_times()","text":"<pre><code>public static rd_kafka_offsets_for_times ( \n    \\FFI\\CData|null $rk, \n    \\FFI\\CData|null $offsets, \n    int|null $timeout_ms\n ): int\n</code></pre> <p>Look up the offsets for the given partitions by timestamp. </p> <p>The returned offset for each partition is the earliest offset whose timestamp is greater than or equal to the given timestamp in the corresponding partition.</p> <p>The timestamps to query are represented as <code>offset</code> in <code>offsets</code> on input, and <code>offset</code> will contain the offset on output.</p> <p>The function will block for at most <code>timeout_ms</code> milliseconds.</p> RemarksDuplicate Topic+Partitions are not supported.   Per-partition errors may be returned in <code>rd_kafka_topic_partition_t.err</code> Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* offsets <code>\\FFI\\CData|null</code> rd_kafka_topic_partition_list_t* timeout_ms <code>int|null</code> int Returns <code>int</code> rd_kafka_resp_err_t - RD_KAFKA_RESP_ERR_NO_ERROR if offsets were be queried (do note that per-partition errors might be set), RD_KAFKA_RESP_ERR__TIMED_OUT if not all offsets could be fetched within <code>timeout_ms</code>, RD_KAFKA_RESP_ERR__INVALID_ARG if the <code>offsets</code> list is empty, RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION if all partitions are unknown, RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE if unable to query leaders for the given partitions. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ae308aaf534807cfd4c71e423fc214929 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_offsets_store","title":"rd_kafka_offsets_store()","text":"<pre><code>public static rd_kafka_offsets_store ( \n    \\FFI\\CData|null $rk, \n    \\FFI\\CData|null $offsets\n ): int\n</code></pre> <p>Store offsets for next auto-commit for one or more partitions. </p> <p>The offset will be committed (written) to the offset store according to <code><code>auto.commit.interval.ms</code></code> or manual offset-less commit().</p> <p>Per-partition success/error status propagated through each partition's <code></code>.err for all return values (even NO_ERROR) except INVALID_ARG.</p> WarningThis method may only be called for partitions that are currently assigned. Non-assigned partitions will fail with RD_KAFKA_RESP_ERR__STATE. Since v1.9.0.  Avoid storing offsets after calling rd_kafka_seek() (et.al) as this may later interfere with resuming a paused partition, instead store offsets prior to calling seek. RemarksThe <code></code>.offset field is stored as is, it will NOT be + 1. <code><code>enable.auto.offset.store</code></code> must be set to \"false\" when using this API.  The leader epoch, if set, will be used to fence outdated partition leaders. See rd_kafka_topic_partition_set_leader_epoch(). Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* offsets <code>\\FFI\\CData|null</code> rd_kafka_topic_partition_list_t* Returns <code>int</code> rd_kafka_resp_err_t - RD_KAFKA_RESP_ERR_NO_ERROR on (partial) success, or RD_KAFKA_RESP_ERR__INVALID_ARG if <code>enable.auto.offset.store</code> is true, or RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION or RD_KAFKA_RESP_ERR__STATE if none of the offsets could be stored. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a047b1e21236fba30898c7c563c2c6777 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_opaque","title":"rd_kafka_opaque()","text":"<pre><code>public static rd_kafka_opaque ( \n    \\FFI\\CData|null $rk\n ): \\FFI\\CData|object|string|null\n</code></pre> Parameters rk <code>\\FFI\\CData|null</code> const rd_kafka_t* Returns <code>\\FFI\\CData|object|string|null</code> void*"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_outq_len","title":"rd_kafka_outq_len()","text":"<pre><code>public static rd_kafka_outq_len ( \n    \\FFI\\CData|null $rk\n ): int|null\n</code></pre> <p>Returns the current out queue length. </p> <p>The out queue length is the sum of:</p> <ul> <li>number of messages waiting to be sent to, or acknowledged by, the broker.</li> <li>number of delivery reports (e.g., dr_msg_cb) waiting to be served by rd_kafka_poll() or rd_kafka_flush().</li> <li>number of callbacks (e.g., error_cb, stats_cb, etc) waiting to be served by rd_kafka_poll(), rd_kafka_consumer_poll() or rd_kafka_flush().</li> <li>number of events waiting to be served by background_event_cb() in the background queue (see rd_kafka_conf_set_background_event_cb).</li> </ul> <p>An application should wait for the return value of this function to reach zero before terminating to make sure outstanding messages, requests (such as offset commits), callbacks and events are fully processed. See rd_kafka_flush().</p> See alsord_kafka_flush()  Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* - ) Returns <code>int|null</code> int - number of messages and events waiting in queues. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ad4b3b7659cf9a79d3353810d6b625bb7 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_pause_partitions","title":"rd_kafka_pause_partitions()","text":"<pre><code>public static rd_kafka_pause_partitions ( \n    \\FFI\\CData|null $rk, \n    \\FFI\\CData|null $partitions\n ): int\n</code></pre> <p>Pause producing or consumption for the provided list of partitions. </p> <p>Success or error is returned per-partition <code>err</code> in the <code>partitions</code> list.</p> Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* partitions <code>\\FFI\\CData|null</code> rd_kafka_topic_partition_list_t* Returns <code>int</code> rd_kafka_resp_err_t - RD_KAFKA_RESP_ERR_NO_ERROR <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a293cb2aac290c157702d3b82f5c14fce </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_plugin_f_conf_init_t","title":"rd_kafka_plugin_f_conf_init_t()","text":"<pre><code>public static rd_kafka_plugin_f_conf_init_t ( \n    \\FFI\\CData|null $conf, \n    \\FFI\\CData|object|string|null $plug_opaquep, \n    \\FFI\\CData|null $errstr, \n    int|null $errstr_size\n ): int\n</code></pre> <p>Plugin's configuration initializer method called each time the library is referenced from configuration (even if previously loaded by another client instance). </p> RemarksThis method MUST be implemented by plugins and have the symbol name <code>conf_init</code> RemarksA plugin may add an on_conf_destroy() interceptor to clean up plugin-specific resources created in the plugin's conf_init() method. Parameters conf <code>\\FFI\\CData|null</code> rd_kafka_conf_t* - Configuration set up to this point. plug_opaquep <code>\\FFI\\CData|object|string|null</code> void** - Plugin can set this pointer to a per-configuration opaque pointer. errstr <code>\\FFI\\CData|null</code> char* - String buffer of size <code>errstr_size</code> where plugin must write a human readable error string in the case the initializer fails (returns non-zero). - Maximum space (including \\0) in <code>errstr</code>. errstr_size <code>int|null</code> size_t Returns <code>int</code> rd_kafka_resp_err_t - RD_KAFKA_RESP_ERR_NO_ERROR on success or an error code on error. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a6d98d642466324e3b188accb2623387f </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_poll","title":"rd_kafka_poll()","text":"<pre><code>public static rd_kafka_poll ( \n    \\FFI\\CData|null $rk, \n    int|null $timeout_ms\n ): int|null\n</code></pre> <p>Polls the provided kafka handle for events. </p> <p>Events will cause application-provided callbacks to be called.</p> <p>The <code>timeout_ms</code> argument specifies the maximum amount of time (in milliseconds) that the call will block waiting for events. For non-blocking calls, provide 0 as <code>timeout_ms</code>. To wait indefinitely for an event, provide -1.</p> RemarksAn application should make sure to call poll() at regular intervals to serve any queued callbacks waiting to be called.   If your producer doesn't have any callback set (in particular via rd_kafka_conf_set_dr_msg_cb or rd_kafka_conf_set_error_cb) you might choose not to call poll(), though this is not recommended. <p>Events:</p> <ul> <li>delivery report callbacks (if dr_cb/dr_msg_cb is configured) [producer]</li> <li>error callbacks (rd_kafka_conf_set_error_cb()) [all]</li> <li>stats callbacks (rd_kafka_conf_set_stats_cb()) [all]</li> <li>throttle callbacks (rd_kafka_conf_set_throttle_cb()) [all]</li> <li>OAUTHBEARER token refresh callbacks (rd_kafka_conf_set_oauthbearer_token_refresh_cb()) [all]</li> </ul> Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* timeout_ms <code>int|null</code> int Returns <code>int|null</code> int - the number of events served. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ad50c431e3a29d14da534db49bd0682a4 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_poll_set_consumer","title":"rd_kafka_poll_set_consumer()","text":"<pre><code>public static rd_kafka_poll_set_consumer ( \n    \\FFI\\CData|null $rk\n ): int\n</code></pre> <p>Redirect the main (rd_kafka_poll()) queue to the KafkaConsumer's queue (rd_kafka_consumer_poll()). </p> WarningIt is not permitted to call rd_kafka_poll() after directing the main queue with rd_kafka_poll_set_consumer().  Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* - ) Returns <code>int</code> rd_kafka_resp_err_t <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a9bfa0a1dd3f866cbf0c82fc089bd7904 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_position","title":"rd_kafka_position()","text":"<pre><code>public static rd_kafka_position ( \n    \\FFI\\CData|null $rk, \n    \\FFI\\CData|null $partitions\n ): int\n</code></pre> <p>Retrieve current positions (offsets) for topics+partitions. </p> <p>The <code>offset</code> field of each requested partition will be set to the offset of the last consumed message + 1, or RD_KAFKA_OFFSET_INVALID in case there was no previous message.</p> RemarksIn this context the last consumed message is the offset consumed by the current librdkafka instance and, in case of rebalancing, not necessarily the last message fetched from the partition. Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* partitions <code>\\FFI\\CData|null</code> rd_kafka_topic_partition_list_t* Returns <code>int</code> rd_kafka_resp_err_t - RD_KAFKA_RESP_ERR_NO_ERROR on success in which case the <code>offset</code> or <code>err</code> field of each <code>partitions\u2019</code> element is filled in with the stored offset, or a partition specific error. Else returns an error code. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a6e9e36bd9e6bf84a9f3092fcbfa3a9ac </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_produce","title":"rd_kafka_produce()","text":"<pre><code>public static rd_kafka_produce ( \n    \\FFI\\CData|null $rkt, \n    int|null $partition, \n    int|null $msgflags, \n    \\FFI\\CData|object|string|null $payload, \n    int|null $len, \n    \\FFI\\CData|object|string|null $key, \n    int|null $keylen, \n    \\FFI\\CData|object|string|null $msg_opaque\n ): int|null\n</code></pre> <p>Produce and send a single message to broker. </p> <p><code>rkt</code> is the target topic which must have been previously created with <code>rd_kafka_topic_new()</code>.</p> <p><code>rd_kafka_produce()</code> is an asynchronous non-blocking API. See <code>rd_kafka_conf_set_dr_msg_cb</code> on how to setup a callback to be called once the delivery status (success or failure) is known. The delivery report is triggered by the application calling <code>rd_kafka_poll()</code> (at regular intervals) or <code>rd_kafka_flush()</code> (at termination).</p> <p>Since producing is asynchronous, you should call <code>rd_kafka_flush()</code> before you destroy the producer. Otherwise, any outstanding messages will be silently discarded.</p> <p>When temporary errors occur, librdkafka automatically retries to produce the messages. Retries are triggered after retry.backoff.ms and when the leader broker for the given partition is available. Otherwise, librdkafka falls back to polling the topic metadata to monitor when a new leader is elected (see the topic.metadata.refresh.fast.interval.ms and topic.metadata.refresh.interval.ms configurations) and then performs a retry. A delivery error will occur if the message could not be produced within message.timeout.ms.</p> <p>See the \"Message reliability\" chapter in INTRODUCTION.md for more information.</p> <p><code>partition</code> is the target partition, either:</p> <ul> <li>RD_KAFKA_PARTITION_UA (unassigned) for automatic partitioning using the topic's partitioner function, or</li> <li>a fixed partition (0..N)</li> </ul> <p><code>msgflags</code> is zero or more of the following flags OR:ed together: RD_KAFKA_MSG_F_BLOCK - block <code>produce*</code>() call if <code>queue.buffering.max.messages</code> or <code>queue.buffering.max.kbytes</code> are exceeded. Messages are considered in-queue from the point they are accepted by produce() until their corresponding delivery report callback/event returns. It is thus a requirement to call rd_kafka_poll() (or equiv.) from a separate thread when F_BLOCK is used. See WARNING on <code>RD_KAFKA_MSG_F_BLOCK</code> above.</p> <p>RD_KAFKA_MSG_F_FREE - rdkafka will free(3) <code>payload</code> when it is done with it. RD_KAFKA_MSG_F_COPY - the <code>payload</code> data will be copied and the <code>payload</code> pointer will not be used by rdkafka after the call returns. RD_KAFKA_MSG_F_PARTITION - produce_batch() will honour per-message partition, either set manually or by the configured partitioner.</p> <p>.._F_FREE and .._F_COPY are mutually exclusive. If neither of these are set, the caller must ensure that the memory backing <code>payload</code> remains valid and is not modified or reused until the delivery callback is invoked. Other buffers passed to <code>rd_kafka_produce()</code> don't have this restriction on reuse, i.e. the memory backing the key or the topic name may be reused as soon as <code>rd_kafka_produce()</code> returns.</p> <p>If the function returns -1 and RD_KAFKA_MSG_F_FREE was specified, then the memory associated with the payload is still the caller's responsibility.</p> <p><code>payload</code> is the message payload of size <code>len</code> bytes.</p> <p><code>key</code> is an optional message key of size <code>keylen</code> bytes, if non-NULL it will be passed to the topic partitioner as well as be sent with the message to the broker and passed on to the consumer.</p> <p><code>msg_opaque</code> is an optional application-provided per-message opaque pointer that will provided in the message's delivery report callback (<code>dr_msg_cb</code> or <code>dr_cb</code>) and the <code>rd_kafka_message_t</code> <code>_private</code> field.</p> Remarkson_send() and on_acknowledgement() interceptors may be called from this function. on_acknowledgement() will only be called if the message fails partitioning.  If the producer is transactional (<code>transactional.id</code> is configured) producing is only allowed during an on-going transaction, namely after rd_kafka_begin_transaction() has been called. See alsoUse rd_kafka_errno2err() to convert <code>errno</code> to rdkafka error code.  Parameters rkt <code>\\FFI\\CData|null</code> rd_kafka_topic_t* partition <code>int|null</code> int32_t msgflags <code>int|null</code> int payload <code>\\FFI\\CData|object|string|null</code> void* len <code>int|null</code> size_t key <code>\\FFI\\CData|object|string|null</code> const void* keylen <code>int|null</code> size_t msg_opaque <code>\\FFI\\CData|object|string|null</code> void* Returns <code>int|null</code> int - 0 on success or -1 on error in which case errno is set accordingly:<ul> <li>ENOBUFS - maximum number of outstanding messages has been reached: \"queue.buffering.max.messages\" (RD_KAFKA_RESP_ERR__QUEUE_FULL)</li> <li>EMSGSIZE - message is larger than configured max size: \"messages.max.bytes\". (RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE)</li> <li>ESRCH - requested <code>partition</code> is unknown in the Kafka cluster. (RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION)</li> <li>ENOENT - topic is unknown in the Kafka cluster. (RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC)</li> <li>ECANCELED - fatal error has been raised on producer, see rd_kafka_fatal_error(), (RD_KAFKA_RESP_ERR__FATAL).</li> <li>ENOEXEC - transactional state forbids producing (RD_KAFKA_RESP_ERR__STATE)</li> </ul> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ae24d8ebf1ea15ed8ea0ea40f74662736 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_produce_batch","title":"rd_kafka_produce_batch()","text":"<pre><code>public static rd_kafka_produce_batch ( \n    \\FFI\\CData|null $rkt, \n    int|null $partition, \n    int|null $msgflags, \n    \\FFI\\CData|null $rkmessages, \n    int|null $message_cnt\n ): int|null\n</code></pre> <p>Produce multiple messages. </p> <p>If partition is RD_KAFKA_PARTITION_UA the configured partitioner will be run for each message (slower), otherwise the messages will be enqueued to the specified partition directly (faster).</p> <p>The messages are provided in the array <code>rkmessages</code> of count <code>message_cnt</code> elements. The <code>partition</code> and <code>msgflags</code> are used for all provided messages.</p> <p>Honoured <code>rkmessages</code>[] fields are:</p> <ul> <li>payload,len Message payload and length</li> <li>key,key_len Optional message key</li> <li>_private Message opaque pointer (msg_opaque)</li> <li>err Will be set according to success or failure, see rd_kafka_produce() for possible error codes. Application only needs to check for errors if return value != <code>message_cnt</code>.</li> </ul> RemarksIf <code>RD_KAFKA_MSG_F_PARTITION</code> is set in <code>msgflags</code>, the <code></code>.partition field of the <code>rkmessages</code> is used instead of <code>partition</code>. RemarksThis interface does NOT support setting message headers on the provided <code>rkmessages</code>.  Parameters rkt <code>\\FFI\\CData|null</code> rd_kafka_topic_t* partition <code>int|null</code> int32_t msgflags <code>int|null</code> int rkmessages <code>\\FFI\\CData|null</code> rd_kafka_message_t* message_cnt <code>int|null</code> int Returns <code>int|null</code> int - the number of messages succesfully enqueued for producing. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a7ad15c71f228c47946500a0e5c6f88ed </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_producev","title":"rd_kafka_producev()","text":"<pre><code>public static rd_kafka_producev ( \n    \\FFI\\CData|null $rk, \n    mixed $args\n ): int\n</code></pre> <p>Produce and send a single message to broker. </p> <p>The message is defined by a va-arg list using <code>rd_kafka_vtype_t</code> tag tuples which must be terminated with a single <code>RD_KAFKA_V_END</code>.</p> See alsord_kafka_produce, rd_kafka_produceva, RD_KAFKA_V_END  Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* args <code>mixed</code> Returns <code>int</code> rd_kafka_resp_err_t - <code>RD_KAFKA_RESP_ERR_NO_ERROR</code> on success, else an error code as described in rd_kafka_produce(). <code>RD_KAFKA_RESP_ERR__CONFLICT</code> is returned if _V_HEADER and _V_HEADERS are mixed. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ac3a111ec3e6729609d498fec7b619efc </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_produceva","title":"rd_kafka_produceva()","text":"<pre><code>public static rd_kafka_produceva ( \n    \\FFI\\CData|null $rk, \n    \\FFI\\CData|null $vus, \n    int|null $cnt\n ): \\FFI\\CData|null\n</code></pre> <p>Produce and send a single message to broker. </p> <p>The message is defined by an array of <code>rd_kafka_vu_t</code> of count <code>cnt</code>.</p> See alsord_kafka_produce, rd_kafka_producev, RD_KAFKA_V_END  Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* vus <code>\\FFI\\CData|null</code> const rd_kafka_vu_t* cnt <code>int|null</code> size_t Returns <code>\\FFI\\CData|null</code> rd_kafka_error_t* - an error object on failure or NULL on success. See rd_kafka_producev() for specific error codes. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a267a7eabf933733e542902533141bd47 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_purge","title":"rd_kafka_purge()","text":"<pre><code>public static rd_kafka_purge ( \n    \\FFI\\CData|null $rk, \n    int|null $purge_flags\n ): int\n</code></pre> <p>Purge messages currently handled by the producer instance. </p> <p>The application will need to call rd_kafka_poll() or rd_kafka_flush() afterwards to serve the delivery report callbacks of the purged messages.</p> <p>Messages purged from internal queues fail with the delivery report error code set to RD_KAFKA_RESP_ERR__PURGE_QUEUE, while purged messages that are in-flight to or from the broker will fail with the error code set to RD_KAFKA_RESP_ERR__PURGE_INFLIGHT.</p> WarningPurging messages that are in-flight to or from the broker will ignore any subsequent acknowledgement for these messages received from the broker, effectively making it impossible for the application to know if the messages were successfully produced or not. This may result in duplicate messages if the application retries these messages at a later time. RemarksThis call may block for a short time while background thread queues are purged. Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* - Client instance. purge_flags <code>int|null</code> int - Tells which messages to purge and how. Returns <code>int</code> rd_kafka_resp_err_t - RD_KAFKA_RESP_ERR_NO_ERROR on success, RD_KAFKA_RESP_ERR__INVALID_ARG if the <code>purge</code> flags are invalid or unknown, RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED if called on a non-producer client instance. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a59c28026ebf7a67df5954879ebab4707 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_query_watermark_offsets","title":"rd_kafka_query_watermark_offsets()","text":"<pre><code>public static rd_kafka_query_watermark_offsets ( \n    \\FFI\\CData|null $rk, \n    string|null $topic, \n    int|null $partition, \n    \\FFI\\CData|null $low, \n    \\FFI\\CData|null $high, \n    int|null $timeout_ms\n ): int\n</code></pre> <p>Query broker for low (oldest/beginning) and high (newest/end) offsets for partition. </p> <p>Offsets are returned in <code>*low</code> and <code>*high</code> respectively.</p> Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* topic <code>string|null</code> const char* partition <code>int|null</code> int32_t low <code>\\FFI\\CData|null</code> int64_t* high <code>\\FFI\\CData|null</code> int64_t* timeout_ms <code>int|null</code> int Returns <code>int</code> rd_kafka_resp_err_t - RD_KAFKA_RESP_ERR_NO_ERROR on success or an error code on failure. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a4550ff7d014f08406666124573f70495 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_queue_cb_event_enable","title":"rd_kafka_queue_cb_event_enable()","text":"<pre><code>public static rd_kafka_queue_cb_event_enable ( \n    \\FFI\\CData|null $rkqu, \n    \\FFI\\CData|\\Closure $event_cb, \n    \\FFI\\CData|object|string|null $opaque\n ): void\n</code></pre> <p>Enable callback event triggering for queue. </p> <p>The callback will be called from an internal librdkafka thread when a new element is enqueued on a previously empty queue.</p> <p>To remove event triggering call with <code>event_cb</code> = NULL.</p> <p>The <code>qev_opaque</code> is passed to the callback's <code>qev_opaque</code> argument.</p> RemarksIO and callback event triggering are mutually exclusive.   Since the callback may be triggered from internal librdkafka threads, the application must not perform any pro-longed work in the callback, or call any librdkafka APIs (for the same rd_kafka_t handle).  Parameters rkqu <code>\\FFI\\CData|null</code> rd_kafka_queue_t* event_cb <code>\\FFI\\CData|\\Closure</code> void()(rd_kafka_t, void*) opaque <code>\\FFI\\CData|object|string|null</code> void* <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a411b31dede8e2d1f6a921ae4fb98413a </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_queue_destroy","title":"rd_kafka_queue_destroy()","text":"<pre><code>public static rd_kafka_queue_destroy ( \n    \\FFI\\CData|null $rkqu\n ): void\n</code></pre> <p>Destroy a queue, purging all of its enqueued messages. </p> Parameters rkqu <code>\\FFI\\CData|null</code> rd_kafka_queue_t* - ) <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a9421b3d450f1489cf46f68d49c5ea61e </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_queue_forward","title":"rd_kafka_queue_forward()","text":"<pre><code>public static rd_kafka_queue_forward ( \n    \\FFI\\CData|null $src, \n    \\FFI\\CData|null $dst\n ): void\n</code></pre> <p>Forward/re-route queue <code>src</code> to <code>dst</code>. If <code>dst</code> is <code>NULL</code> the forwarding is removed. </p> <p>The internal refcounts for both queues are increased.</p> RemarksRegardless of whether <code>dst</code> is NULL or not, after calling this function, <code>src</code> will not forward it's fetch queue to the consumer queue.  Parameters src <code>\\FFI\\CData|null</code> rd_kafka_queue_t* dst <code>\\FFI\\CData|null</code> rd_kafka_queue_t* <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a5e2e5571d14636d289f963a270b8e338 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_queue_get_background","title":"rd_kafka_queue_get_background()","text":"<pre><code>public static rd_kafka_queue_get_background ( \n    \\FFI\\CData|null $rk\n ): \\FFI\\CData|null\n</code></pre> <p>The background thread queue provides the application with an automatically polled queue that triggers the event callback in a background thread, this background thread is completely managed by librdkafka.</p> <p>The background thread queue is automatically created if a generic event handler callback is configured with rd_kafka_conf_set_background_event_cb() or if rd_kafka_queue_get_background() is called.</p> <p>The background queue is polled and served by librdkafka and MUST NOT be polled, forwarded, or otherwise managed by the application, it may only be used as the destination queue passed to queue-enabled APIs, such as the Admin API.</p> <p>Use rd_kafka_queue_destroy() to loose the reference.</p> WarningThe background queue MUST NOT be read from (polled, consumed, etc), or forwarded from.  Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* - ) Returns <code>\\FFI\\CData|null</code> rd_kafka_queue_t* - a reference to the background thread queue, or NULL if the background queue is not enabled. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a2ba0f4fa322165d33d7cd240a1a90c83 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_queue_get_consumer","title":"rd_kafka_queue_get_consumer()","text":"<pre><code>public static rd_kafka_queue_get_consumer ( \n    \\FFI\\CData|null $rk\n ): \\FFI\\CData|null\n</code></pre> <p>Use rd_kafka_queue_destroy() to loose the reference.</p> Remarksrd_kafka_queue_destroy() MUST be called on this queue prior to calling rd_kafka_consumer_close().   Polling the returned queue counts as a consumer poll, and will reset the timer for max.poll.interval.ms. If this queue is forwarded to a \"destq\", polling destq also counts as a consumer poll (this works for any number of forwards). However, even if this queue is unforwarded or forwarded elsewhere, polling destq will continue to count as a consumer poll.  Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* - ) Returns <code>\\FFI\\CData|null</code> rd_kafka_queue_t* - a reference to the librdkafka consumer queue. This is the queue served by rd_kafka_consumer_poll(). <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#acacdb55ae7cb6abfbde89621e512b078 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_queue_get_main","title":"rd_kafka_queue_get_main()","text":"<pre><code>public static rd_kafka_queue_get_main ( \n    \\FFI\\CData|null $rk\n ): \\FFI\\CData|null\n</code></pre> <p>Use rd_kafka_queue_destroy() to loose the reference. </p> Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* - ) Returns <code>\\FFI\\CData|null</code> rd_kafka_queue_t* - a reference to the main librdkafka event queue. This is the queue served by rd_kafka_poll(). <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a7f3d675ee029a52bf85fb28f83c38863 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_queue_get_partition","title":"rd_kafka_queue_get_partition()","text":"<pre><code>public static rd_kafka_queue_get_partition ( \n    \\FFI\\CData|null $rk, \n    string|null $topic, \n    int|null $partition\n ): \\FFI\\CData|null\n</code></pre> <p>Use rd_kafka_queue_destroy() to loose the reference.</p> Remarksrd_kafka_queue_destroy() MUST be called on this queue  This function only works on consumers.  Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* topic <code>string|null</code> const char* partition <code>int|null</code> int32_t Returns <code>\\FFI\\CData|null</code> rd_kafka_queue_t* - a reference to the partition\u2019s queue, or NULL if partition is invalid. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ad5319a26efb9f843c6029f7dd54b742d </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_queue_get_sasl","title":"rd_kafka_queue_get_sasl()","text":"<pre><code>public static rd_kafka_queue_get_sasl ( \n    \\FFI\\CData|null $rk\n ): \\FFI\\CData|null\n</code></pre> <p>Use rd_kafka_queue_destroy() to loose the reference.</p> See alsord_kafka_sasl_background_callbacks_enable()  Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* - ) Returns <code>\\FFI\\CData|null</code> rd_kafka_queue_t* - a reference to the SASL callback queue, if a SASL mechanism with callbacks is configured (currently only OAUTHBEARER), else returns NULL. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a56d2a479cb1e2fb540db1f25f45b7ece </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_queue_io_event_enable","title":"rd_kafka_queue_io_event_enable()","text":"<pre><code>public static rd_kafka_queue_io_event_enable ( \n    \\FFI\\CData|null $rkqu, \n    int|null $fd, \n    \\FFI\\CData|object|string|null $payload, \n    int|null $size\n ): void\n</code></pre> <p>Enable IO event triggering for queue. </p> <p>To ease integration with IO based polling loops this API allows an application to create a separate file-descriptor that librdkafka will write <code>payload</code> (of size <code>size</code>) to whenever a new element is enqueued on a previously empty queue.</p> <p>To remove event triggering call with <code>fd</code> = -1.</p> <p>librdkafka will maintain a copy of the <code>payload</code>.</p> RemarksIO and callback event triggering are mutually exclusive.   When using forwarded queues the IO event must only be enabled on the final forwarded-to (destination) queue.   The file-descriptor/socket must be set to non-blocking.  Parameters rkqu <code>\\FFI\\CData|null</code> rd_kafka_queue_t* fd <code>int|null</code> int payload <code>\\FFI\\CData|object|string|null</code> const void* size <code>int|null</code> size_t <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#acbdd13ab480f6320b2842981eebce784 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_queue_length","title":"rd_kafka_queue_length()","text":"<pre><code>public static rd_kafka_queue_length ( \n    \\FFI\\CData|null $rkqu\n ): int|null\n</code></pre> Parameters rkqu <code>\\FFI\\CData|null</code> rd_kafka_queue_t* - ) Returns <code>int|null</code> size_t - the current number of elements in queue. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8f24368f4ff0e042907773f532f62e57 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_queue_new","title":"rd_kafka_queue_new()","text":"<pre><code>public static rd_kafka_queue_new ( \n    \\FFI\\CData|null $rk\n ): \\FFI\\CData|null\n</code></pre> <p>Create a new message queue. </p> <p>See rd_kafka_consume_start_queue(), rd_kafka_consume_queue(), et.al. </p> Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* - ) Returns <code>\\FFI\\CData|null</code> rd_kafka_queue_t* <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a2b59178eb7e88d40510a89f3f2d98b44 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_queue_poll","title":"rd_kafka_queue_poll()","text":"<pre><code>public static rd_kafka_queue_poll ( \n    \\FFI\\CData|null $rkqu, \n    int|null $timeout_ms\n ): \\FFI\\CData|null\n</code></pre> <p>Poll a queue for an event for max <code>timeout_ms</code>. </p> RemarksUse rd_kafka_event_destroy() to free the event. See alsord_kafka_conf_set_background_event_cb()  Parameters rkqu <code>\\FFI\\CData|null</code> rd_kafka_queue_t* timeout_ms <code>int|null</code> int Returns <code>\\FFI\\CData|null</code> rd_kafka_event_t* - an event, or NULL. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a2f147ed1c554c9048893fb1adde86dfa </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_queue_poll_callback","title":"rd_kafka_queue_poll_callback()","text":"<pre><code>public static rd_kafka_queue_poll_callback ( \n    \\FFI\\CData|null $rkqu, \n    int|null $timeout_ms\n ): int|null\n</code></pre> <p>Poll a queue for events served through callbacks for max <code>timeout_ms</code>. </p> RemarksThis API must only be used for queues with callbacks registered for all expected event types. E.g., not a message queue.  Also see rd_kafka_conf_set_background_event_cb() for triggering event callbacks from a librdkafka-managed background thread. See alsord_kafka_conf_set_background_event_cb()  Parameters rkqu <code>\\FFI\\CData|null</code> rd_kafka_queue_t* timeout_ms <code>int|null</code> int Returns <code>int|null</code> int - the number of events served. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a13d80084f20a2800e863b97e465ce98e </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_queue_yield","title":"rd_kafka_queue_yield()","text":"<pre><code>public static rd_kafka_queue_yield ( \n    \\FFI\\CData|null $rkqu\n ): void\n</code></pre> <p>Cancels the current rd_kafka_queue_poll() on <code>rkqu</code>. </p> <p>An application may use this from another thread to force an immediate return to the calling code (caller of rd_kafka_queue_poll()). Must not be used from signal handlers since that may cause deadlocks. </p> Parameters rkqu <code>\\FFI\\CData|null</code> rd_kafka_queue_t* - ) <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#af3f15671034a8a5c6d9a3b33cc1b6f3f </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_rebalance_protocol","title":"rd_kafka_rebalance_protocol()","text":"<pre><code>public static rd_kafka_rebalance_protocol ( \n    \\FFI\\CData|null $rk\n ): string|null\n</code></pre> <p>The rebalance protocol currently in use. This will be \"NONE\" if the consumer has not (yet) joined a group, else it will match the rebalance protocol (\"EAGER\", \"COOPERATIVE\") of the configured and selected assignor(s). All configured assignors must have the same protocol type, meaning online migration of a consumer group from using one protocol to another (in particular upgading from EAGER to COOPERATIVE) without a restart is not currently supported. </p> Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* - ) Returns <code>string|null</code> const char* - NULL on error, or one of \u201cNONE\u201d, \u201cEAGER\u201d, \u201cCOOPERATIVE\u201d on success. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a57d367712406848d59cdaae97ab29354 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_resume_partitions","title":"rd_kafka_resume_partitions()","text":"<pre><code>public static rd_kafka_resume_partitions ( \n    \\FFI\\CData|null $rk, \n    \\FFI\\CData|null $partitions\n ): int\n</code></pre> <p>Resume producing consumption for the provided list of partitions. </p> <p>Success or error is returned per-partition <code>err</code> in the <code>partitions</code> list.</p> Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* partitions <code>\\FFI\\CData|null</code> rd_kafka_topic_partition_list_t* Returns <code>int</code> rd_kafka_resp_err_t - RD_KAFKA_RESP_ERR_NO_ERROR <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ad05819f26887a916ad2047d96a7b4bf2 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_sasl_background_callbacks_enable","title":"rd_kafka_sasl_background_callbacks_enable()","text":"<pre><code>public static rd_kafka_sasl_background_callbacks_enable ( \n    \\FFI\\CData|null $rk\n ): \\FFI\\CData|null\n</code></pre> <p>Enable SASL OAUTHBEARER refresh callbacks on the librdkafka background thread. </p> <p>This serves as an alternative for applications that do not call rd_kafka_poll() (et.al.) at regular intervals (or not at all), as a means of automatically trigger the refresh callbacks, which are needed to initiate connections to the brokers in the case a custom OAUTHBEARER refresh callback is configured.</p> See alsord_kafka_queue_get_sasl()   rd_kafka_conf_set_oauthbearer_token_refresh_cb()  Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* - ) Returns <code>\\FFI\\CData|null</code> rd_kafka_error_t* - NULL on success or an error object on error. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a383a661dc45191bccb3a2b50adbbfcdb </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_sasl_set_credentials","title":"rd_kafka_sasl_set_credentials()","text":"<pre><code>public static rd_kafka_sasl_set_credentials ( \n    \\FFI\\CData|null $rk, \n    string|null $username, \n    string|null $password\n ): \\FFI\\CData|null\n</code></pre> <p>Sets SASL credentials used for SASL PLAIN and SCRAM mechanisms by this Kafka client. </p> <p>This function sets or resets the SASL username and password credentials used by this Kafka client. The new credentials will be used the next time this client needs to authenticate to a broker. This function will not disconnect existing connections that might have been made using the old credentials.</p> RemarksThis function only applies to the SASL PLAIN and SCRAM mechanisms. Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* username <code>string|null</code> const char* password <code>string|null</code> const char* Returns <code>\\FFI\\CData|null</code> rd_kafka_error_t* - NULL on success or an error object on error. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8bdca34710185cec1e42e500decbeb2d </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_seek","title":"rd_kafka_seek()","text":"<pre><code>public static rd_kafka_seek ( \n    \\FFI\\CData|null $rkt, \n    int|null $partition, \n    int|null $offset, \n    int|null $timeout_ms\n ): int\n</code></pre> <p>Seek consumer for topic+partition to <code>offset</code> which is either an absolute or logical offset. </p> <p>If <code>timeout_ms</code> is specified (not 0) the seek call will wait this long for the consumer to update its fetcher state for the given partition with the new offset. This guarantees that no previously fetched messages for the old offset (or fetch position) will be passed to the application.</p> <p>If the timeout is reached the internal state will be unknown to the caller and this function returns <code>RD_KAFKA_RESP_ERR__TIMED_OUT</code>.</p> <p>If <code>timeout_ms</code> is 0 it will initiate the seek but return immediately without any error reporting (e.g., async).</p> <p>This call will purge all pre-fetched messages for the given partition, which may be up to <code>queued.max.message.kbytes</code> in size. Repeated use of seek may thus lead to increased network usage as messages are re-fetched from the broker.</p> RemarksSeek must only be performed for already assigned/consumed partitions, use rd_kafka_assign() (et.al) to set the initial starting offset for a new assignmenmt. Deprecated:Use rd_kafka_seek_partitions().  Parameters rkt <code>\\FFI\\CData|null</code> rd_kafka_topic_t* partition <code>int|null</code> int32_t offset <code>int|null</code> int64_t timeout_ms <code>int|null</code> int Returns <code>int</code> rd_kafka_resp_err_t - <code>RD_KAFKA_RESP_ERR__NO_ERROR</code> on success else an error code. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a6667b162931982e9827e3d86ad22ec7d </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_seek_partitions","title":"rd_kafka_seek_partitions()","text":"<pre><code>public static rd_kafka_seek_partitions ( \n    \\FFI\\CData|null $rk, \n    \\FFI\\CData|null $partitions, \n    int|null $timeout_ms\n ): \\FFI\\CData|null\n</code></pre> <p>Seek consumer for partitions in <code>partitions</code> to the per-partition offset in the <code></code>.offset field of <code>partitions</code>. </p> <p>The offset may be either absolute (&gt;= 0) or a logical offset.</p> <p>If <code>timeout_ms</code> is specified (not 0) the seek call will wait this long for the consumer to update its fetcher state for the given partition with the new offset. This guarantees that no previously fetched messages for the old offset (or fetch position) will be passed to the application.</p> <p>If the timeout is reached the internal state will be unknown to the caller and this function returns <code>RD_KAFKA_RESP_ERR__TIMED_OUT</code>.</p> <p>If <code>timeout_ms</code> is 0 it will initiate the seek but return immediately without any error reporting (e.g., async).</p> <p>This call will purge all pre-fetched messages for the given partition, which may be up to <code>queued.max.message.kbytes</code> in size. Repeated use of seek may thus lead to increased network usage as messages are re-fetched from the broker.</p> <p>Individual partition errors are reported in the per-partition <code></code>.err field of <code>partitions</code>.</p> RemarksSeek must only be performed for already assigned/consumed partitions, use rd_kafka_assign() (et.al) to set the initial starting offset for a new assignmenmt. Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* partitions <code>\\FFI\\CData|null</code> rd_kafka_topic_partition_list_t* timeout_ms <code>int|null</code> int Returns <code>\\FFI\\CData|null</code> rd_kafka_error_t* - NULL on success or an error object on failure. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a7821331324eaab995d4a2baf42b78df5 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_send_offsets_to_transaction","title":"rd_kafka_send_offsets_to_transaction()","text":"<pre><code>public static rd_kafka_send_offsets_to_transaction ( \n    \\FFI\\CData|null $rk, \n    \\FFI\\CData|null $offsets, \n    \\FFI\\CData|null $cgmetadata, \n    int|null $timeout_ms\n ): \\FFI\\CData|null\n</code></pre> <p>Sends a list of topic partition offsets to the consumer group coordinator for <code>cgmetadata</code>, and marks the offsets as part part of the current transaction. These offsets will be considered committed only if the transaction is committed successfully. </p> <p>The offsets should be the next message your application will consume, i.e., the last processed message's offset + 1 for each partition. Either track the offsets manually during processing or use rd_kafka_position() (on the consumer) to get the current offsets for the partitions assigned to the consumer.</p> <p>Use this method at the end of a consume-transform-produce loop prior to committing the transaction with rd_kafka_commit_transaction().</p> RemarksThis function must be called on the transactional producer instance, not the consumer.  The consumer must disable auto commits (set <code>enable.auto.commit</code> to false on the consumer).  Logical and invalid offsets (such as RD_KAFKA_OFFSET_INVALID) in <code>offsets</code> will be ignored, if there are no valid offsets in <code>offsets</code> the function will return NULL and no action will be taken.  This call is retriable but not resumable, which means a new request with a new set of provided offsets and group metadata will be sent to the transaction coordinator if the call is retried.  It is highly recommended to retry the call (upon retriable error) with identical <code>offsets</code> and <code>cgmetadata</code> parameters. Failure to do so risks inconsistent state between what is actually included in the transaction and what the application thinks is included in the transaction. RemarksThe returned error object (if not NULL) must be destroyed with rd_kafka_error_destroy().  Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* - Producer instance. offsets <code>\\FFI\\CData|null</code> const rd_kafka_topic_partition_list_t* - List of offsets to commit to the consumer group upon successful commit of the transaction. Offsets should be the next message to consume, e.g., last processed message + 1. cgmetadata <code>\\FFI\\CData|null</code> const rd_kafka_consumer_group_metadata_t* - The current consumer group metadata as returned by rd_kafka_consumer_group_metadata() on the consumer instance the provided offsets were consumed from. timeout_ms <code>int|null</code> int - Maximum time allowed to register the offsets on the broker. Returns <code>\\FFI\\CData|null</code> rd_kafka_error_t* - NULL on success or an error object on failure. Check whether the returned error object permits retrying by calling rd_kafka_error_is_retriable(), or whether an abortable or fatal error has been raised by calling rd_kafka_error_txn_requires_abort() or rd_kafka_error_is_fatal() respectively. Error codes: RD_KAFKA_RESP_ERR__STATE if not currently in a transaction, RD_KAFKA_RESP_ERR_INVALID_PRODUCER_EPOCH if the current producer transaction has been fenced by a newer producer instance, RD_KAFKA_RESP_ERR_TRANSACTIONAL_ID_AUTHORIZATION_FAILED if the producer is no longer authorized to perform transactional operations, RD_KAFKA_RESP_ERR_GROUP_AUTHORIZATION_FAILED if the producer is not authorized to write the consumer offsets to the group coordinator, RD_KAFKA_RESP_ERR__NOT_CONFIGURED if transactions have not been configured for the producer instance, RD_KAFKA_RESP_ERR__INVALID_ARG if <code>rk</code> is not a producer instance, or if the <code>consumer_group_id</code> or <code>offsets</code> are empty. Other error codes not listed here may be returned, depending on broker version. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a288b31742a707ca14cf07312fbcca881 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_set_log_level","title":"rd_kafka_set_log_level()","text":"<pre><code>public static rd_kafka_set_log_level ( \n    \\FFI\\CData|null $rk, \n    int|null $level\n ): void\n</code></pre> <p>Specifies the maximum logging level emitted by internal kafka logging and debugging. </p> Deprecated:Set the <code>\"log_level\"</code> configuration property instead. RemarksIf the <code>\"debug\"</code> configuration property is set the log level is automatically adjusted to <code>LOG_DEBUG</code> (7).  Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* level <code>int|null</code> int <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#acadeefced6bb60acd27e7a0dad553aa4 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_set_log_queue","title":"rd_kafka_set_log_queue()","text":"<pre><code>public static rd_kafka_set_log_queue ( \n    \\FFI\\CData|null $rk, \n    \\FFI\\CData|null $rkqu\n ): int\n</code></pre> <p>Forward librdkafka logs (and debug) to the specified queue for serving with one of the ..poll() calls. </p> <p>This allows an application to serve log callbacks (<code>log_cb</code>) in its thread of choice.</p> RemarksThe configuration property <code>log.queue</code> MUST also be set to true.  librdkafka maintains its own reference to the provided queue. Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* - Client instance. rkqu <code>\\FFI\\CData|null</code> rd_kafka_queue_t* - Queue to forward logs to. If the value is NULL the logs are forwarded to the main queue. Returns <code>int</code> rd_kafka_resp_err_t - RD_KAFKA_RESP_ERR_NO_ERROR on success or an error code on error, eg RD_KAFKA_RESP_ERR__NOT_CONFIGURED when log.queue is not set to true. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a5c8a3be2f797560b2a39bf56dbd7622d </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_set_logger","title":"rd_kafka_set_logger()","text":"<pre><code>public static rd_kafka_set_logger ( \n    \\FFI\\CData|null $rk, \n    \\FFI\\CData|\\Closure $func\n ): void\n</code></pre> <p>Set logger function. </p> <p>The default is to print to stderr, but a syslog logger is also available, see rd_kafka_log_(print|syslog) for the builtin alternatives. Alternatively the application may provide its own logger callback. Or pass 'func' as NULL to disable logging.</p> Deprecated:Use rd_kafka_conf_set_log_cb() Remarks<code>rk</code> may be passed as NULL in the callback.  Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* func <code>\\FFI\\CData|\\Closure</code> void()(const rd_kafka_t, int, const char*, const char*) <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a9e4af9adee414af74c7817403f7c4a53 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_subscribe","title":"rd_kafka_subscribe()","text":"<pre><code>public static rd_kafka_subscribe ( \n    \\FFI\\CData|null $rk, \n    \\FFI\\CData|null $topics\n ): int\n</code></pre> <p>Subscribe to topic set using balanced consumer groups. </p> <p>Wildcard (regex) topics are supported: any topic name in the <code>topics</code> list that is prefixed with <code>\"^\"</code> will be regex-matched to the full list of topics in the cluster and matching topics will be added to the subscription list.</p> <p>The full topic list is retrieved every <code>topic.metadata.refresh.interval.ms</code> to pick up new or delete topics that match the subscription. If there is any change to the matched topics the consumer will immediately rejoin the group with the updated set of subscribed topics.</p> <p>Regex and full topic names can be mixed in <code>topics</code>.</p> RemarksOnly the <code></code>.topic field is used in the supplied <code>topics</code> list, all other fields are ignored.  subscribe() is an asynchronous method which returns immediately: background threads will (re)join the group, wait for group rebalance, issue any registered rebalance_cb, assign() the assigned partitions, and then start fetching messages. This cycle may take up to <code>session.timeout.ms</code> * 2 or more to complete.  After this call returns a consumer error will be returned by rd_kafka_consumer_poll (et.al) for each unavailable topic in the <code>topics</code>. The error will be RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART for non-existent topics, and RD_KAFKA_RESP_ERR_TOPIC_AUTHORIZATION_FAILED for unauthorized topics. The consumer error will be raised through rd_kafka_consumer_poll() (et.al.) with the <code>rd_kafka_message_t.err</code> field set to one of the error codes mentioned above. The subscribe function itself is asynchronous and will not return an error on unavailable topics. Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* topics <code>\\FFI\\CData|null</code> const rd_kafka_topic_partition_list_t* Returns <code>int</code> rd_kafka_resp_err_t - RD_KAFKA_RESP_ERR_NO_ERROR on success or RD_KAFKA_RESP_ERR__INVALID_ARG if list is empty, contains invalid topics or regexes or duplicate entries, RD_KAFKA_RESP_ERR__FATAL if the consumer has raised a fatal error. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a0ebe15e9d0f39ccc84e9686f0fcf46f1 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_subscription","title":"rd_kafka_subscription()","text":"<pre><code>public static rd_kafka_subscription ( \n    \\FFI\\CData|null $rk, \n    \\FFI\\CData|null $topics\n ): int\n</code></pre> <p>Returns the current topic subscription. </p> RemarksThe application is responsible for calling rd_kafka_topic_partition_list_destroy on the returned list.  Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* topics <code>\\FFI\\CData|null</code> rd_kafka_topic_partition_list_t** Returns <code>int</code> rd_kafka_resp_err_t - An error code on failure, otherwise <code>topic</code> is updated to point to a newly allocated topic list (possibly empty). <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ab66a2c014db2e652aa12466b137a6200 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_test_fatal_error","title":"rd_kafka_test_fatal_error()","text":"<pre><code>public static rd_kafka_test_fatal_error ( \n    \\FFI\\CData|null $rk, \n    int $err, \n    string|null $reason\n ): int\n</code></pre> <p>Trigger a fatal error for testing purposes. </p> <p>Since there is no practical way to trigger real fatal errors in the idempotent producer, this method allows an application to trigger fabricated fatal errors in tests to check its error handling code.</p> Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* - Client instance. err <code>int</code> rd_kafka_resp_err_t - The underlying error code. reason <code>string|null</code> const char* - A human readable error reason. Will be prefixed with \u201ctest_fatal_error: \u201d to differentiate from real fatal errors. Returns <code>int</code> rd_kafka_resp_err_t - RD_KAFKA_RESP_ERR_NO_ERROR if a fatal error was triggered, or RD_KAFKA_RESP_ERR__PREV_IN_PROGRESS if a previous fatal error has already been triggered. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a2e603ee9942480165be3c48f006a7171 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_thread_cnt","title":"rd_kafka_thread_cnt()","text":"<pre><code>public static rd_kafka_thread_cnt (  ): int|null\n</code></pre> <p>Retrieve the current number of threads in use by librdkafka. </p> <p>Used by regression tests. </p> Returns <code>int|null</code> int - ) <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a0901699375c972b807ba5255773f017f </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_topic_conf_destroy","title":"rd_kafka_topic_conf_destroy()","text":"<pre><code>public static rd_kafka_topic_conf_destroy ( \n    \\FFI\\CData|null $topic_conf\n ): void\n</code></pre> Parameters topic_conf <code>\\FFI\\CData|null</code> rd_kafka_topic_conf_t*"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_topic_conf_dump","title":"rd_kafka_topic_conf_dump()","text":"<pre><code>public static rd_kafka_topic_conf_dump ( \n    \\FFI\\CData|null $conf, \n    \\FFI\\CData|null $cntp\n ): \\FFI\\CData|null\n</code></pre> <p>Dump the topic configuration properties and values of <code>conf</code> to an array with \"key\", \"value\" pairs. </p> <p>The number of entries in the array is returned in <code>*cntp</code>.</p> <p>The dump must be freed with <code>rd_kafka_conf_dump_free()</code>. </p> Parameters conf <code>\\FFI\\CData|null</code> rd_kafka_topic_conf_t* cntp <code>\\FFI\\CData|null</code> size_t* Returns <code>\\FFI\\CData|null</code> const char** <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a40a7a88bd5ac81b21c45d1fdd4d9e696 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_topic_conf_dup","title":"rd_kafka_topic_conf_dup()","text":"<pre><code>public static rd_kafka_topic_conf_dup ( \n    \\FFI\\CData|null $conf\n ): \\FFI\\CData|null\n</code></pre> Parameters conf <code>\\FFI\\CData|null</code> const rd_kafka_topic_conf_t* Returns <code>\\FFI\\CData|null</code> rd_kafka_topic_conf_t*"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_topic_conf_get","title":"rd_kafka_topic_conf_get()","text":"<pre><code>public static rd_kafka_topic_conf_get ( \n    \\FFI\\CData|null $conf, \n    string|null $name, \n    \\FFI\\CData|null $dest, \n    \\FFI\\CData|null $dest_size\n ): int\n</code></pre> <p>Retrieve topic configuration value for property <code>name</code>. </p> See alsord_kafka_conf_get()  Parameters conf <code>\\FFI\\CData|null</code> const rd_kafka_topic_conf_t* name <code>string|null</code> const char* dest <code>\\FFI\\CData|null</code> char* dest_size <code>\\FFI\\CData|null</code> size_t* Returns <code>int</code> rd_kafka_conf_res_t <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a56939e7f77106b9e810d59289443e25d </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_topic_conf_new","title":"rd_kafka_topic_conf_new()","text":"<pre><code>public static rd_kafka_topic_conf_new (  ): \\FFI\\CData|null\n</code></pre> <p>Create topic configuration object. </p> See alsoSame semantics as for rd_kafka_conf_new().  Returns <code>\\FFI\\CData|null</code> rd_kafka_topic_conf_t* - ) <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a1a7032f87e7d868b80e38d0fd0ad119e </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_topic_conf_set","title":"rd_kafka_topic_conf_set()","text":"<pre><code>public static rd_kafka_topic_conf_set ( \n    \\FFI\\CData|null $conf, \n    string|null $name, \n    string|null $value, \n    \\FFI\\CData|null $errstr, \n    int|null $errstr_size\n ): int\n</code></pre> <p>Sets a single rd_kafka_topic_conf_t value by property name. </p> <p><code>topic_conf</code> should have been previously set up with <code>rd_kafka_topic_conf_new()</code>.</p> Parameters conf <code>\\FFI\\CData|null</code> rd_kafka_topic_conf_t* name <code>string|null</code> const char* value <code>string|null</code> const char* errstr <code>\\FFI\\CData|null</code> char* errstr_size <code>int|null</code> size_t Returns <code>int</code> rd_kafka_conf_res_t - rd_kafka_conf_res_t to indicate success or failure. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ac91b47f7733b324bf4159427e90ccd01 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_topic_conf_set_msg_order_cmp","title":"rd_kafka_topic_conf_set_msg_order_cmp()","text":"<pre><code>public static rd_kafka_topic_conf_set_msg_order_cmp ( \n    \\FFI\\CData|null $topic_conf, \n    \\FFI\\CData|\\Closure $msg_order_cmp\n ): void\n</code></pre> <p>Producer: Set message queueing order comparator callback. </p> <p>The callback may be called in any thread at any time, it may be called multiple times for the same message.</p> <p>Ordering comparator function constraints:</p> <ul> <li>MUST be stable sort (same input gives same output).</li> <li>MUST NOT call any rd_kafka_*() functions.</li> <li>MUST NOT block or execute for prolonged periods of time.</li> </ul> <p>The comparator shall compare the two messages and return:</p> <ul> <li>&lt; 0 if message <code>a</code> should be inserted before message <code>b</code>.</li> <li>&gt;=0 if message <code>a</code> should be inserted after message <code>b</code>.</li> </ul> RemarksInsert sorting will be used to enqueue the message in the correct queue position, this comes at a cost of O(n).  If <code>queuing.strategy=fifo</code> new messages are enqueued to the tail of the queue regardless of msg_order_cmp, but retried messages are still affected by msg_order_cmp. WarningTHIS IS AN EXPERIMENTAL API, SUBJECT TO CHANGE OR REMOVAL, DO NOT USE IN PRODUCTION.  Parameters topic_conf <code>\\FFI\\CData|null</code> rd_kafka_topic_conf_t* msg_order_cmp <code>\\FFI\\CData|\\Closure</code> int()(const rd_kafka_message_t, const rd_kafka_message_t*) <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a760cee234c441d32f9421874a74e06d4 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_topic_conf_set_opaque","title":"rd_kafka_topic_conf_set_opaque()","text":"<pre><code>public static rd_kafka_topic_conf_set_opaque ( \n    \\FFI\\CData|null $conf, \n    \\FFI\\CData|object|string|null $opaque\n ): void\n</code></pre> <p>Sets the application's opaque pointer that will be passed to all topic callbacks as the <code>rkt_opaque</code> argument. </p> See alsord_kafka_topic_opaque()  Parameters conf <code>\\FFI\\CData|null</code> rd_kafka_topic_conf_t* opaque <code>\\FFI\\CData|object|string|null</code> void* <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a227d943335cad18b55f8cf8024ba9943 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_topic_conf_set_partitioner_cb","title":"rd_kafka_topic_conf_set_partitioner_cb()","text":"<pre><code>public static rd_kafka_topic_conf_set_partitioner_cb ( \n    \\FFI\\CData|null $topic_conf, \n    \\FFI\\CData|\\Closure $partitioner\n ): void\n</code></pre> <p>Producer: Set partitioner callback in provided topic conf object. </p> <p>The partitioner may be called in any thread at any time, it may be called multiple times for the same message/key.</p> <p>The callback's <code>rkt_opaque</code> argument is the opaque set by rd_kafka_topic_conf_set_opaque(). The callback's <code>msg_opaque</code> argument is the per-message opaque passed to produce().</p> <p>Partitioner function constraints:</p> <ul> <li>MUST NOT call any rd_kafka_*() functions except: rd_kafka_topic_partition_available()</li> <li>MUST NOT block or execute for prolonged periods of time.</li> <li>MUST return a value between 0 and partition_cnt-1, or the special <code>RD_KAFKA_PARTITION_UA</code> value if partitioning could not be performed. </li> </ul> Parameters topic_conf <code>\\FFI\\CData|null</code> rd_kafka_topic_conf_t* partitioner <code>\\FFI\\CData|\\Closure</code> int32_t()(const rd_kafka_topic_t, const void*, size_t, int32_t, void*, void*) <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#abfc790b5e36c56ea6d79fdc32c57becf </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_topic_destroy","title":"rd_kafka_topic_destroy()","text":"<pre><code>public static rd_kafka_topic_destroy ( \n    \\FFI\\CData|null $rkt\n ): void\n</code></pre> <p>Loose application's topic handle refcount as previously created with <code>rd_kafka_topic_new()</code>. </p> RemarksSince topic objects are refcounted (both internally and for the app) the topic object might not actually be destroyed by this call, but the application must consider the object destroyed.  Parameters rkt <code>\\FFI\\CData|null</code> rd_kafka_topic_t* - ) <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a91f46cd29d4f9abacd3ee3633c01d8ff </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_topic_name","title":"rd_kafka_topic_name()","text":"<pre><code>public static rd_kafka_topic_name ( \n    \\FFI\\CData|null $rkt\n ): string|null\n</code></pre> Parameters rkt <code>\\FFI\\CData|null</code> const rd_kafka_topic_t* Returns <code>string|null</code> const char*"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_topic_new","title":"rd_kafka_topic_new()","text":"<pre><code>public static rd_kafka_topic_new ( \n    \\FFI\\CData|null $rk, \n    string|null $topic, \n    \\FFI\\CData|null $conf\n ): \\FFI\\CData|null\n</code></pre> <p>Creates a new topic handle for topic named <code>topic</code>. </p> <p><code>conf</code> is an optional configuration for the topic created with <code>rd_kafka_topic_conf_new()</code> that will be used instead of the default topic configuration. The <code>conf</code> object is freed by this function and must not be used or destroyed by the application subsequently. See <code>rd_kafka_topic_conf_set()</code> et.al for more information.</p> <p>Topic handles are refcounted internally and calling rd_kafka_topic_new() again with the same topic name will return the previous topic handle without updating the original handle's configuration. Applications must eventually call rd_kafka_topic_destroy() for each succesfull call to rd_kafka_topic_new() to clear up resources.</p> See alsord_kafka_topic_destroy()  Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* topic <code>string|null</code> const char* conf <code>\\FFI\\CData|null</code> rd_kafka_topic_conf_t* Returns <code>\\FFI\\CData|null</code> rd_kafka_topic_t* - the new topic handle or NULL on error (use rd_kafka_errno2err() to convert system <code>errno</code> to an rd_kafka_resp_err_t error code. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ab1dcba74a35e8f3bfe3270ff600581d8 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_topic_opaque","title":"rd_kafka_topic_opaque()","text":"<pre><code>public static rd_kafka_topic_opaque ( \n    \\FFI\\CData|null $rkt\n ): \\FFI\\CData|object|string|null\n</code></pre> Parameters rkt <code>\\FFI\\CData|null</code> const rd_kafka_topic_t* Returns <code>\\FFI\\CData|object|string|null</code> void*"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_topic_partition_available","title":"rd_kafka_topic_partition_available()","text":"<pre><code>public static rd_kafka_topic_partition_available ( \n    \\FFI\\CData|null $rkt, \n    int|null $partition\n ): int|null\n</code></pre> <p>Check if partition is available (has a leader broker). </p> WarningThis function must only be called from inside a partitioner function  Parameters rkt <code>\\FFI\\CData|null</code> const rd_kafka_topic_t* partition <code>int|null</code> int32_t Returns <code>int|null</code> int - 1 if the partition is available, else 0. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ad24c6cc7f37271e292f8105c64d77758 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_topic_partition_destroy","title":"rd_kafka_topic_partition_destroy()","text":"<pre><code>public static rd_kafka_topic_partition_destroy ( \n    \\FFI\\CData|null $rktpar\n ): void\n</code></pre> <p>Destroy a rd_kafka_topic_partition_t. </p> RemarksThis must not be called for elements in a topic partition list.  Parameters rktpar <code>\\FFI\\CData|null</code> rd_kafka_topic_partition_t* - ) <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ac5a7b02e3af816cfacbcfa6468c40c9a </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_topic_partition_get_leader_epoch","title":"rd_kafka_topic_partition_get_leader_epoch()","text":"<pre><code>public static rd_kafka_topic_partition_get_leader_epoch ( \n    \\FFI\\CData|null $rktpar\n ): int|null\n</code></pre> RemarksSee KIP-320 for more information.  Parameters rktpar <code>\\FFI\\CData|null</code> const rd_kafka_topic_partition_t* - ) - Partition object. Returns <code>int|null</code> int32_t - the offset leader epoch, if relevant and known, else -1. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ad8ae250ddb522b220b64e0b1627ad8b8 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_topic_partition_list_add","title":"rd_kafka_topic_partition_list_add()","text":"<pre><code>public static rd_kafka_topic_partition_list_add ( \n    \\FFI\\CData|null $rktparlist, \n    string|null $topic, \n    int|null $partition\n ): \\FFI\\CData|null\n</code></pre> <p>Add topic+partition to list. </p> Parameters rktparlist <code>\\FFI\\CData|null</code> rd_kafka_topic_partition_list_t* - List to extend topic <code>string|null</code> const char* - Topic name (copied) partition <code>int|null</code> int32_t - Partition id Returns <code>\\FFI\\CData|null</code> rd_kafka_topic_partition_t* - The object which can be used to fill in additionals fields. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a123ce30e08b31d4ff0fcf6ebe876173d </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_topic_partition_list_add_range","title":"rd_kafka_topic_partition_list_add_range()","text":"<pre><code>public static rd_kafka_topic_partition_list_add_range ( \n    \\FFI\\CData|null $rktparlist, \n    string|null $topic, \n    int|null $start, \n    int|null $stop\n ): void\n</code></pre> <p>Add range of partitions from <code>start</code> to <code>stop</code> inclusive. </p> Parameters rktparlist <code>\\FFI\\CData|null</code> rd_kafka_topic_partition_list_t* - List to extend topic <code>string|null</code> const char* - Topic name (copied) start <code>int|null</code> int32_t - Start partition of range stop <code>int|null</code> int32_t - Last partition of range (inclusive) <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a6365695de425e7866ddd0c59d704111b </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_topic_partition_list_copy","title":"rd_kafka_topic_partition_list_copy()","text":"<pre><code>public static rd_kafka_topic_partition_list_copy ( \n    \\FFI\\CData|null $src\n ): \\FFI\\CData|null\n</code></pre> <p>Make a copy of an existing list. </p> Parameters src <code>\\FFI\\CData|null</code> const rd_kafka_topic_partition_list_t* - ) - The existing list to copy. Returns <code>\\FFI\\CData|null</code> rd_kafka_topic_partition_list_t* - A new list fully populated to be identical to <code>src</code> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a66fd3f8c00ffbd0ea740a638dd0a95f7 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_topic_partition_list_del","title":"rd_kafka_topic_partition_list_del()","text":"<pre><code>public static rd_kafka_topic_partition_list_del ( \n    \\FFI\\CData|null $rktparlist, \n    string|null $topic, \n    int|null $partition\n ): int|null\n</code></pre> <p>Delete partition from list. </p> RemarksAny held indices to elems[] are unusable after this call returns 1.  Parameters rktparlist <code>\\FFI\\CData|null</code> rd_kafka_topic_partition_list_t* - List to modify topic <code>string|null</code> const char* - Topic name to match partition <code>int|null</code> int32_t - Partition to match Returns <code>int|null</code> int - 1 if partition was found (and removed), else 0. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a94a8195aa5f0195d020494bced858a97 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_topic_partition_list_del_by_idx","title":"rd_kafka_topic_partition_list_del_by_idx()","text":"<pre><code>public static rd_kafka_topic_partition_list_del_by_idx ( \n    \\FFI\\CData|null $rktparlist, \n    int|null $idx\n ): int|null\n</code></pre> <p>Delete partition from list by elems[] index. </p> See alsord_kafka_topic_partition_list_del()  Parameters rktparlist <code>\\FFI\\CData|null</code> rd_kafka_topic_partition_list_t* idx <code>int|null</code> int Returns <code>int|null</code> int - 1 if partition was found (and removed), else 0. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8476ebf3c2f54ddee53e0863feb85463 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_topic_partition_list_destroy","title":"rd_kafka_topic_partition_list_destroy()","text":"<pre><code>public static rd_kafka_topic_partition_list_destroy ( \n    \\FFI\\CData|null $rkparlist\n ): void\n</code></pre> Parameters rkparlist <code>\\FFI\\CData|null</code> rd_kafka_topic_partition_list_t*"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_topic_partition_list_find","title":"rd_kafka_topic_partition_list_find()","text":"<pre><code>public static rd_kafka_topic_partition_list_find ( \n    \\FFI\\CData|null $rktparlist, \n    string|null $topic, \n    int|null $partition\n ): \\FFI\\CData|null\n</code></pre> <p>Find element by <code>topic</code> and <code>partition</code>. </p> Parameters rktparlist <code>\\FFI\\CData|null</code> rd_kafka_topic_partition_list_t* topic <code>string|null</code> const char* partition <code>int|null</code> int32_t Returns <code>\\FFI\\CData|null</code> rd_kafka_topic_partition_t* - a pointer to the first matching element, or NULL if not found. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a122c284913412e8e043fe7b51aebc0d7 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_topic_partition_list_new","title":"rd_kafka_topic_partition_list_new()","text":"<pre><code>public static rd_kafka_topic_partition_list_new ( \n    int|null $size\n ): \\FFI\\CData|null\n</code></pre> <p>Create a new list/vector Topic+Partition container. </p> RemarksUse rd_kafka_topic_partition_list_destroy() to free all resources in use by a list and the list itself.  See alsord_kafka_topic_partition_list_add()  Parameters size <code>int|null</code> int - ) - Initial allocated size used when the expected number of elements is known or can be estimated. Avoids reallocation and possibly relocation of the elems array. Returns <code>\\FFI\\CData|null</code> rd_kafka_topic_partition_list_t* - A newly allocated Topic+Partition list. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#afb87d24333b6ad5a7415b06882f06b2a </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_topic_partition_list_set_offset","title":"rd_kafka_topic_partition_list_set_offset()","text":"<pre><code>public static rd_kafka_topic_partition_list_set_offset ( \n    \\FFI\\CData|null $rktparlist, \n    string|null $topic, \n    int|null $partition, \n    int|null $offset\n ): int\n</code></pre> <p>Set offset to <code>offset</code> for <code>topic</code> and <code>partition</code>. </p> Parameters rktparlist <code>\\FFI\\CData|null</code> rd_kafka_topic_partition_list_t* topic <code>string|null</code> const char* partition <code>int|null</code> int32_t offset <code>int|null</code> int64_t Returns <code>int</code> rd_kafka_resp_err_t - RD_KAFKA_RESP_ERR_NO_ERROR on success or RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION if <code>partition</code> was not found in the list. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a102b340b901babb247d2c0a8580a094d </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_topic_partition_list_sort","title":"rd_kafka_topic_partition_list_sort()","text":"<pre><code>public static rd_kafka_topic_partition_list_sort ( \n    \\FFI\\CData|null $rktparlist, \n    \\FFI\\CData|\\Closure $cmp, \n    \\FFI\\CData|object|string|null $opaque\n ): void\n</code></pre> <p>Sort list using comparator <code>cmp</code>. </p> <p>If <code>cmp</code> is NULL the default comparator will be used that sorts by ascending topic name and partition.</p> <p><code>cmp_opaque</code> is provided as the <code>cmp_opaque</code> argument to <code>cmp</code>. </p> Parameters rktparlist <code>\\FFI\\CData|null</code> rd_kafka_topic_partition_list_t* cmp <code>\\FFI\\CData|\\Closure</code> int()(const void, const void*, void*) opaque <code>\\FFI\\CData|object|string|null</code> void* <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#af56e41c6cb82d6ded5cd973976cd62df </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_topic_partition_result_error","title":"rd_kafka_topic_partition_result_error()","text":"<pre><code>public static rd_kafka_topic_partition_result_error ( \n    \\FFI\\CData|null $partition_result\n ): \\FFI\\CData|null\n</code></pre> Remarkslifetime of the returned string is the same as the <code>partition_result</code>.  Parameters partition_result <code>\\FFI\\CData|null</code> const rd_kafka_topic_partition_result_t* - ) Returns <code>\\FFI\\CData|null</code> const rd_kafka_error_t* - the error object from the topic partition result object. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a6d6090e9f0cfe26744aa1c4489e4515c </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_topic_partition_result_partition","title":"rd_kafka_topic_partition_result_partition()","text":"<pre><code>public static rd_kafka_topic_partition_result_partition ( \n    \\FFI\\CData|null $partition_result\n ): \\FFI\\CData|null\n</code></pre> <p>Topic Partition Result provides per-topic+partition operation result Consists of TopicPartition object and error object. </p> Remarkslifetime of the returned string is the same as the <code>partition_result</code>. The error object is set inside the topic partition object. For the detailed error information, use rd_kafka_topic_partition_result_error()  Parameters partition_result <code>\\FFI\\CData|null</code> const rd_kafka_topic_partition_result_t* - ) Returns <code>\\FFI\\CData|null</code> const rd_kafka_topic_partition_t* - the topic partition object from the topic partition result object. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a6b516428ccc72a544681f16c130a8dd9 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_topic_partition_set_leader_epoch","title":"rd_kafka_topic_partition_set_leader_epoch()","text":"<pre><code>public static rd_kafka_topic_partition_set_leader_epoch ( \n    \\FFI\\CData|null $rktpar, \n    int|null $leader_epoch\n ): void\n</code></pre> <p>Sets the offset leader epoch (use -1 to clear). </p> RemarksSee KIP-320 for more information.  Parameters rktpar <code>\\FFI\\CData|null</code> rd_kafka_topic_partition_t* - Partition object. leader_epoch <code>int|null</code> int32_t - Offset leader epoch, use -1 to reset. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ab70804a35d1a6e8c21f276d75ef8ea6e </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_topic_result_error","title":"rd_kafka_topic_result_error()","text":"<pre><code>public static rd_kafka_topic_result_error ( \n    \\FFI\\CData|null $topicres\n ): int\n</code></pre> <p>Topic result provides per-topic operation result information. </p> Parameters topicres <code>\\FFI\\CData|null</code> const rd_kafka_topic_result_t* - ) Returns <code>int</code> rd_kafka_resp_err_t - the error code for the given topic result. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a962bb4f4bcd8cf12a9aa9ef361ed7526 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_topic_result_error_string","title":"rd_kafka_topic_result_error_string()","text":"<pre><code>public static rd_kafka_topic_result_error_string ( \n    \\FFI\\CData|null $topicres\n ): string|null\n</code></pre> Remarkslifetime of the returned string is the same as the <code>topicres</code>.  Parameters topicres <code>\\FFI\\CData|null</code> const rd_kafka_topic_result_t* - ) Returns <code>string|null</code> const char* - the human readable error string for the given topic result, or NULL if there was no error. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a1e6596b6138eff2342da6e5c56ce9133 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_topic_result_name","title":"rd_kafka_topic_result_name()","text":"<pre><code>public static rd_kafka_topic_result_name ( \n    \\FFI\\CData|null $topicres\n ): string|null\n</code></pre> Remarkslifetime of the returned string is the same as the <code>topicres</code>.  Parameters topicres <code>\\FFI\\CData|null</code> const rd_kafka_topic_result_t* - ) Returns <code>string|null</code> const char* - the name of the topic for the given topic result. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a4073e9165eda071afc6f2af6a824e967 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_type","title":"rd_kafka_type()","text":"<pre><code>public static rd_kafka_type ( \n    \\FFI\\CData|null $rk\n ): int\n</code></pre> Parameters rk <code>\\FFI\\CData|null</code> const rd_kafka_t* Returns <code>int</code> rd_kafka_type_t"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_unittest","title":"rd_kafka_unittest()","text":"<pre><code>public static rd_kafka_unittest (  ): int|null\n</code></pre> <p>Run librdkafka's built-in unit-tests. </p> Returns <code>int|null</code> int - ) - the number of failures, or 0 if all tests passed. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ab932d463be030a5e83ebfc5186ff20b8 </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_unsubscribe","title":"rd_kafka_unsubscribe()","text":"<pre><code>public static rd_kafka_unsubscribe ( \n    \\FFI\\CData|null $rk\n ): int\n</code></pre> Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* Returns <code>int</code> rd_kafka_resp_err_t"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_version","title":"rd_kafka_version()","text":"<pre><code>public static rd_kafka_version (  ): int|null\n</code></pre> <p>Returns the librdkafka version as integer. </p> See alsoSee RD_KAFKA_VERSION for how to parse the integer format.   Use rd_kafka_version_str() to retreive the version as a string.  Returns <code>int|null</code> int - ) - Version integer. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a83e363606ef2da2e91b7429b229dbc8e </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_version_str","title":"rd_kafka_version_str()","text":"<pre><code>public static rd_kafka_version_str (  ): string|null\n</code></pre> <p>Returns the librdkafka version as string. </p> Returns <code>string|null</code> const char* - ) - Version string <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a0cc60434083686fd8e379a905652d34a </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_wait_destroyed","title":"rd_kafka_wait_destroyed()","text":"<pre><code>public static rd_kafka_wait_destroyed ( \n    int|null $timeout_ms\n ): int|null\n</code></pre> <p>Wait for all rd_kafka_t objects to be destroyed. </p> <p>Returns 0 if all kafka objects are now destroyed, or -1 if the timeout was reached.</p> RemarksThis function is deprecated.  Parameters timeout_ms <code>int|null</code> int - ) Returns <code>int|null</code> int <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aa90f2c92a382dbd0a090d40caa73356d </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_yield","title":"rd_kafka_yield()","text":"<pre><code>public static rd_kafka_yield ( \n    \\FFI\\CData|null $rk\n ): void\n</code></pre> <p>Cancels the current callback dispatcher (rd_kafka_poll(), rd_kafka_consume_callback(), etc). </p> <p>A callback may use this to force an immediate return to the calling code (caller of e.g. rd_kafka_poll()) without processing any further events.</p> RemarksThis function MUST ONLY be called from within a librdkafka callback.  Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* - ) <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a111628df6c84716c4b550f8509ac6a6d </li> </ul>"},{"location":"api/RdKafka/FFI/Library/#requiremethod","title":"requireMethod()","text":"<pre><code>public static requireMethod ( \n    string $name\n ): void\n</code></pre> <p>Method must be supported by current binding version otherwise an exception is thrown.</p> Parameters name <code>string</code>"},{"location":"api/RdKafka/FFI/Library/#requireversion","title":"requireVersion()","text":"<pre><code>public static requireVersion ( \n    string $operator, \n    string $version\n ): void\n</code></pre> <p>Version must match the current binding otherwise an exception is thrown.</p> Parameters operator <code>string</code> version <code>string</code>"},{"location":"api/RdKafka/FFI/Library/#type","title":"type()","text":"<pre><code>public static type ( \n    string|\\FFI\\CType $type\n ): \\FFI\\CType\n</code></pre> Parameters type <code>string|\\FFI\\CType</code> Returns <code>\\FFI\\CType</code>"},{"location":"api/RdKafka/FFI/Library/#versionmatches","title":"versionMatches()","text":"<pre><code>public static versionMatches ( \n    string $operator, \n    string $version\n ): bool\n</code></pre> <p>Whether version matches the current binding version</p> Parameters operator <code>string</code> version <code>string</code> Returns <code>bool</code>"},{"location":"api/RdKafka/FFI/Library/#test-coverage","title":"Test Coverage \ud83d\udc9b","text":"<ul> <li>\ud83d\udc9b  Lines: 81.82% (72 / 88)</li> <li>\ud83e\udde1  Methods: 61.11% (11 / 18)</li> </ul>"},{"location":"api/RdKafka/FFI/LogCallbackProxy/","title":"Class LogCallbackProxy","text":"<p>Class \\RdKafka\\FFI\\LogCallbackProxy</p> <ul> <li>extends \\RdKafka\\FFI\\CallbackProxy</li> </ul>"},{"location":"api/RdKafka/FFI/LogCallbackProxy/#methods","title":"Methods","text":""},{"location":"api/RdKafka/FFI/LogCallbackProxy/#__invoke","title":"__invoke()","text":"<pre><code>public __invoke ( \n    \\FFI\\CData $rdkafka, \n    int $level, \n    string $facility, \n    string $message\n ): void\n</code></pre> Parameters rdkafka <code>\\FFI\\CData</code> level <code>int</code> facility <code>string</code> message <code>string</code>"},{"location":"api/RdKafka/FFI/LogCallbackProxy/#test-coverage","title":"Test Coverage \ud83d\udc9a","text":"<ul> <li>\ud83d\udc9a  Lines: 100% (6 / 6)</li> <li>\ud83d\udc9a  Methods: 100% (1 / 1)</li> </ul>"},{"location":"api/RdKafka/FFI/Methods/","title":"Trait Methods","text":"<p>Trait \\RdKafka\\FFI\\Methods</p> <p>Description of librdkafka methods and constants is extracted from the official documentation.</p> <p>See also</p> <ul> <li> https://docs.confluent.io/current/clients/librdkafka/rdkafka_8h.html </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#methods","title":"Methods","text":""},{"location":"api/RdKafka/FFI/Methods/#getffi","title":"getFFI()","text":"<pre><code>public static getFFI (  ): \\FFI\n</code></pre> Returns <code>\\FFI</code>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_version","title":"rd_kafka_version()","text":"<pre><code>public static rd_kafka_version (  ): int|null\n</code></pre> <p>Returns the librdkafka version as integer. </p> See alsoSee RD_KAFKA_VERSION for how to parse the integer format.   Use rd_kafka_version_str() to retreive the version as a string.  Returns <code>int|null</code> int - ) - Version integer. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a83e363606ef2da2e91b7429b229dbc8e </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_version_str","title":"rd_kafka_version_str()","text":"<pre><code>public static rd_kafka_version_str (  ): string|null\n</code></pre> <p>Returns the librdkafka version as string. </p> Returns <code>string|null</code> const char* - ) - Version string <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a0cc60434083686fd8e379a905652d34a </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_get_debug_contexts","title":"rd_kafka_get_debug_contexts()","text":"<pre><code>public static rd_kafka_get_debug_contexts (  ): string|null\n</code></pre> <p>Retrieve supported debug contexts for use with the <code>\"debug\"</code> configuration property. (runtime) </p> Returns <code>string|null</code> const char* - ) - Comma-separated list of available debugging contexts. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#adece97d3cbdd6ca936df5b0663118c45 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_get_err_descs","title":"rd_kafka_get_err_descs()","text":"<pre><code>public static rd_kafka_get_err_descs ( \n    \\FFI\\CData|null $errdescs, \n    \\FFI\\CData|null $cntp\n ): void\n</code></pre> Parameters errdescs <code>\\FFI\\CData|null</code> const struct rd_kafka_err_desc** cntp <code>\\FFI\\CData|null</code> size_t*"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_err2str","title":"rd_kafka_err2str()","text":"<pre><code>public static rd_kafka_err2str ( \n    int $err\n ): string|null\n</code></pre> <p>Returns a human readable representation of a kafka error. </p> Parameters err <code>int</code> rd_kafka_resp_err_t - ) - Error code to translate Returns <code>string|null</code> const char* <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ab7bfc925e8d63851511b88a1cee94d6d </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_err2name","title":"rd_kafka_err2name()","text":"<pre><code>public static rd_kafka_err2name ( \n    int $err\n ): string|null\n</code></pre> <p>Returns the error code name (enum name). </p> Parameters err <code>int</code> rd_kafka_resp_err_t - ) - Error code to translate Returns <code>string|null</code> const char* <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8d5f6f2775ec67b124abeb5dfada2d77 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_last_error","title":"rd_kafka_last_error()","text":"<pre><code>public static rd_kafka_last_error (  ): int\n</code></pre> <p>Returns the last error code generated by a legacy API call in the current thread. </p> <p>The legacy APIs are the ones using errno to propagate error value, namely:</p> <ul> <li>rd_kafka_topic_new()</li> <li>rd_kafka_consume_start()</li> <li>rd_kafka_consume_stop()</li> <li>rd_kafka_consume()</li> <li>rd_kafka_consume_batch()</li> <li>rd_kafka_consume_callback()</li> <li>rd_kafka_consume_queue()</li> <li>rd_kafka_produce()</li> </ul> <p>The main use for this function is to avoid converting system <code>errno</code> values to rd_kafka_resp_err_t codes for legacy APIs.</p> RemarksThe last error is stored per-thread, if multiple rd_kafka_t handles are used in the same application thread the developer needs to make sure rd_kafka_last_error() is called immediately after a failed API call.  errno propagation from librdkafka is not safe on Windows and should not be used, use rd_kafka_last_error() instead.  Returns <code>int</code> rd_kafka_resp_err_t - ) <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ae7b90c323d460e0276d79f6ab69e93b7 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_errno2err","title":"rd_kafka_errno2err()","text":"<pre><code>public static rd_kafka_errno2err ( \n    int|null $errnox\n ): int\n</code></pre> <p>Converts the system errno value <code>errnox</code> to a rd_kafka_resp_err_t error code upon failure from the following functions: </p> <ul> <li>rd_kafka_topic_new()</li> <li>rd_kafka_consume_start()</li> <li>rd_kafka_consume_stop()</li> <li>rd_kafka_consume()</li> <li>rd_kafka_consume_batch()</li> <li>rd_kafka_consume_callback()</li> <li>rd_kafka_consume_queue()</li> <li>rd_kafka_produce()</li> </ul> RemarksA better alternative is to call rd_kafka_last_error() immediately after any of the above functions return -1 or NULL. Deprecated:Use rd_kafka_last_error() to retrieve the last error code set by the legacy librdkafka APIs. See alsord_kafka_last_error()  Parameters errnox <code>int|null</code> int - ) - System errno value to convert Returns <code>int</code> rd_kafka_resp_err_t - Appropriate error code for <code>errnox</code> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#abeabf8589c657d7a3ec5a1411a7de91d </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_errno","title":"rd_kafka_errno()","text":"<pre><code>public static rd_kafka_errno (  ): int|null\n</code></pre> <p>Returns the thread-local system errno. </p> <p>On most platforms this is the same as <code>errno</code> but in case of different runtimes between library and application (e.g., Windows static DLLs) this provides a means for exposing the errno librdkafka uses.</p> RemarksThe value is local to the current calling thread. Deprecated:Use rd_kafka_last_error() to retrieve the last error code set by the legacy librdkafka APIs.  Returns <code>int|null</code> int - ) <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8aa1b1a41d2fc0c487f519663609df4f </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_fatal_error","title":"rd_kafka_fatal_error()","text":"<pre><code>public static rd_kafka_fatal_error ( \n    \\FFI\\CData|null $rk, \n    \\FFI\\CData|null $errstr, \n    int|null $errstr_size\n ): int\n</code></pre> <p>Returns the first fatal error set on this client instance, or RD_KAFKA_RESP_ERR_NO_ERROR if no fatal error has occurred. </p> <p>This function is to be used with the Idempotent Producer and <code>error_cb</code> to detect fatal errors.</p> <p>Generally all errors raised by <code>error_cb</code> are to be considered informational and temporary, the client will try to recover from all errors in a graceful fashion (by retrying, etc).</p> <p>However, some errors should logically be considered fatal to retain consistency; in particular a set of errors that may occur when using the Idempotent Producer and the in-order or exactly-once producer guarantees can't be satisfied.</p> Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* - Client instance. errstr <code>\\FFI\\CData|null</code> char* - A human readable error string (nul-terminated) is written to this location that must be of at least <code>errstr_size</code> bytes. The <code>errstr</code> is only written to if there is a fatal error. - Writable size in <code>errstr</code>. errstr_size <code>int|null</code> size_t Returns <code>int</code> rd_kafka_resp_err_t - RD_KAFKA_RESP_ERR_NO_ERROR if no fatal error has been raised, else any other error code. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a44c976534da6f3877cc514826c71607c </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_test_fatal_error","title":"rd_kafka_test_fatal_error()","text":"<pre><code>public static rd_kafka_test_fatal_error ( \n    \\FFI\\CData|null $rk, \n    int $err, \n    string|null $reason\n ): int\n</code></pre> <p>Trigger a fatal error for testing purposes. </p> <p>Since there is no practical way to trigger real fatal errors in the idempotent producer, this method allows an application to trigger fabricated fatal errors in tests to check its error handling code.</p> Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* - Client instance. err <code>int</code> rd_kafka_resp_err_t - The underlying error code. reason <code>string|null</code> const char* - A human readable error reason. Will be prefixed with \u201ctest_fatal_error: \u201d to differentiate from real fatal errors. Returns <code>int</code> rd_kafka_resp_err_t - RD_KAFKA_RESP_ERR_NO_ERROR if a fatal error was triggered, or RD_KAFKA_RESP_ERR__PREV_IN_PROGRESS if a previous fatal error has already been triggered. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a2e603ee9942480165be3c48f006a7171 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_topic_partition_destroy","title":"rd_kafka_topic_partition_destroy()","text":"<pre><code>public static rd_kafka_topic_partition_destroy ( \n    \\FFI\\CData|null $rktpar\n ): void\n</code></pre> <p>Destroy a rd_kafka_topic_partition_t. </p> RemarksThis must not be called for elements in a topic partition list.  Parameters rktpar <code>\\FFI\\CData|null</code> rd_kafka_topic_partition_t* - ) <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ac5a7b02e3af816cfacbcfa6468c40c9a </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_topic_partition_list_new","title":"rd_kafka_topic_partition_list_new()","text":"<pre><code>public static rd_kafka_topic_partition_list_new ( \n    int|null $size\n ): \\FFI\\CData|null\n</code></pre> <p>Create a new list/vector Topic+Partition container. </p> RemarksUse rd_kafka_topic_partition_list_destroy() to free all resources in use by a list and the list itself.  See alsord_kafka_topic_partition_list_add()  Parameters size <code>int|null</code> int - ) - Initial allocated size used when the expected number of elements is known or can be estimated. Avoids reallocation and possibly relocation of the elems array. Returns <code>\\FFI\\CData|null</code> rd_kafka_topic_partition_list_t* - A newly allocated Topic+Partition list. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#afb87d24333b6ad5a7415b06882f06b2a </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_topic_partition_list_destroy","title":"rd_kafka_topic_partition_list_destroy()","text":"<pre><code>public static rd_kafka_topic_partition_list_destroy ( \n    \\FFI\\CData|null $rkparlist\n ): void\n</code></pre> Parameters rkparlist <code>\\FFI\\CData|null</code> rd_kafka_topic_partition_list_t*"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_topic_partition_list_add","title":"rd_kafka_topic_partition_list_add()","text":"<pre><code>public static rd_kafka_topic_partition_list_add ( \n    \\FFI\\CData|null $rktparlist, \n    string|null $topic, \n    int|null $partition\n ): \\FFI\\CData|null\n</code></pre> <p>Add topic+partition to list. </p> Parameters rktparlist <code>\\FFI\\CData|null</code> rd_kafka_topic_partition_list_t* - List to extend topic <code>string|null</code> const char* - Topic name (copied) partition <code>int|null</code> int32_t - Partition id Returns <code>\\FFI\\CData|null</code> rd_kafka_topic_partition_t* - The object which can be used to fill in additionals fields. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a123ce30e08b31d4ff0fcf6ebe876173d </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_topic_partition_list_add_range","title":"rd_kafka_topic_partition_list_add_range()","text":"<pre><code>public static rd_kafka_topic_partition_list_add_range ( \n    \\FFI\\CData|null $rktparlist, \n    string|null $topic, \n    int|null $start, \n    int|null $stop\n ): void\n</code></pre> <p>Add range of partitions from <code>start</code> to <code>stop</code> inclusive. </p> Parameters rktparlist <code>\\FFI\\CData|null</code> rd_kafka_topic_partition_list_t* - List to extend topic <code>string|null</code> const char* - Topic name (copied) start <code>int|null</code> int32_t - Start partition of range stop <code>int|null</code> int32_t - Last partition of range (inclusive) <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a6365695de425e7866ddd0c59d704111b </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_topic_partition_list_del","title":"rd_kafka_topic_partition_list_del()","text":"<pre><code>public static rd_kafka_topic_partition_list_del ( \n    \\FFI\\CData|null $rktparlist, \n    string|null $topic, \n    int|null $partition\n ): int|null\n</code></pre> <p>Delete partition from list. </p> RemarksAny held indices to elems[] are unusable after this call returns 1.  Parameters rktparlist <code>\\FFI\\CData|null</code> rd_kafka_topic_partition_list_t* - List to modify topic <code>string|null</code> const char* - Topic name to match partition <code>int|null</code> int32_t - Partition to match Returns <code>int|null</code> int - 1 if partition was found (and removed), else 0. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a94a8195aa5f0195d020494bced858a97 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_topic_partition_list_del_by_idx","title":"rd_kafka_topic_partition_list_del_by_idx()","text":"<pre><code>public static rd_kafka_topic_partition_list_del_by_idx ( \n    \\FFI\\CData|null $rktparlist, \n    int|null $idx\n ): int|null\n</code></pre> <p>Delete partition from list by elems[] index. </p> See alsord_kafka_topic_partition_list_del()  Parameters rktparlist <code>\\FFI\\CData|null</code> rd_kafka_topic_partition_list_t* idx <code>int|null</code> int Returns <code>int|null</code> int - 1 if partition was found (and removed), else 0. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8476ebf3c2f54ddee53e0863feb85463 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_topic_partition_list_copy","title":"rd_kafka_topic_partition_list_copy()","text":"<pre><code>public static rd_kafka_topic_partition_list_copy ( \n    \\FFI\\CData|null $src\n ): \\FFI\\CData|null\n</code></pre> <p>Make a copy of an existing list. </p> Parameters src <code>\\FFI\\CData|null</code> const rd_kafka_topic_partition_list_t* - ) - The existing list to copy. Returns <code>\\FFI\\CData|null</code> rd_kafka_topic_partition_list_t* - A new list fully populated to be identical to <code>src</code> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a66fd3f8c00ffbd0ea740a638dd0a95f7 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_topic_partition_list_set_offset","title":"rd_kafka_topic_partition_list_set_offset()","text":"<pre><code>public static rd_kafka_topic_partition_list_set_offset ( \n    \\FFI\\CData|null $rktparlist, \n    string|null $topic, \n    int|null $partition, \n    int|null $offset\n ): int\n</code></pre> <p>Set offset to <code>offset</code> for <code>topic</code> and <code>partition</code>. </p> Parameters rktparlist <code>\\FFI\\CData|null</code> rd_kafka_topic_partition_list_t* topic <code>string|null</code> const char* partition <code>int|null</code> int32_t offset <code>int|null</code> int64_t Returns <code>int</code> rd_kafka_resp_err_t - RD_KAFKA_RESP_ERR_NO_ERROR on success or RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION if <code>partition</code> was not found in the list. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a102b340b901babb247d2c0a8580a094d </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_topic_partition_list_find","title":"rd_kafka_topic_partition_list_find()","text":"<pre><code>public static rd_kafka_topic_partition_list_find ( \n    \\FFI\\CData|null $rktparlist, \n    string|null $topic, \n    int|null $partition\n ): \\FFI\\CData|null\n</code></pre> <p>Find element by <code>topic</code> and <code>partition</code>. </p> Parameters rktparlist <code>\\FFI\\CData|null</code> rd_kafka_topic_partition_list_t* topic <code>string|null</code> const char* partition <code>int|null</code> int32_t Returns <code>\\FFI\\CData|null</code> rd_kafka_topic_partition_t* - a pointer to the first matching element, or NULL if not found. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a122c284913412e8e043fe7b51aebc0d7 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_topic_partition_list_sort","title":"rd_kafka_topic_partition_list_sort()","text":"<pre><code>public static rd_kafka_topic_partition_list_sort ( \n    \\FFI\\CData|null $rktparlist, \n    \\FFI\\CData|\\Closure $cmp, \n    \\FFI\\CData|object|string|null $opaque\n ): void\n</code></pre> <p>Sort list using comparator <code>cmp</code>. </p> <p>If <code>cmp</code> is NULL the default comparator will be used that sorts by ascending topic name and partition.</p> <p><code>cmp_opaque</code> is provided as the <code>cmp_opaque</code> argument to <code>cmp</code>. </p> Parameters rktparlist <code>\\FFI\\CData|null</code> rd_kafka_topic_partition_list_t* cmp <code>\\FFI\\CData|\\Closure</code> int()(const void, const void*, void*) opaque <code>\\FFI\\CData|object|string|null</code> void* <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#af56e41c6cb82d6ded5cd973976cd62df </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_headers_new","title":"rd_kafka_headers_new()","text":"<pre><code>public static rd_kafka_headers_new ( \n    int|null $initial_count\n ): \\FFI\\CData|null\n</code></pre> <p>Create a new headers list. </p> Parameters initial_count <code>int|null</code> size_t - ) - Preallocate space for this number of headers. Any number of headers may be added, updated and removed regardless of the initial count. Returns <code>\\FFI\\CData|null</code> rd_kafka_headers_t* <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a9fdd55ee90816f38324f5d0af1b4fc1f </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_headers_destroy","title":"rd_kafka_headers_destroy()","text":"<pre><code>public static rd_kafka_headers_destroy ( \n    \\FFI\\CData|null $hdrs\n ): void\n</code></pre> Parameters hdrs <code>\\FFI\\CData|null</code> rd_kafka_headers_t*"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_headers_copy","title":"rd_kafka_headers_copy()","text":"<pre><code>public static rd_kafka_headers_copy ( \n    \\FFI\\CData|null $src\n ): \\FFI\\CData|null\n</code></pre> Parameters src <code>\\FFI\\CData|null</code> const rd_kafka_headers_t* Returns <code>\\FFI\\CData|null</code> rd_kafka_headers_t*"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_header_add","title":"rd_kafka_header_add()","text":"<pre><code>public static rd_kafka_header_add ( \n    \\FFI\\CData|null $hdrs, \n    string|null $name, \n    int|null $name_size, \n    \\FFI\\CData|object|string|null $value, \n    int|null $value_size\n ): int\n</code></pre> <p>Add header with name <code>name</code> and value <code>val</code> (copied) of size <code>size</code> (not including null-terminator). </p> Parameters hdrs <code>\\FFI\\CData|null</code> rd_kafka_headers_t* - Headers list. name <code>string|null</code> const char* - Header name. name_size <code>int|null</code> ssize_t - Header name size (not including the null-terminator). If -1 the <code>name</code> length is automatically acquired using strlen(). value <code>\\FFI\\CData|object|string|null</code> const void* - Pointer to header value, or NULL (set size to 0 or -1). value_size <code>int|null</code> ssize_t - Size of header value. If -1 the <code>value</code> is assumed to be a null-terminated string and the length is automatically acquired using strlen(). Returns <code>int</code> rd_kafka_resp_err_t - RD_KAFKA_RESP_ERR__READ_ONLY if the headers are read-only, else RD_KAFKA_RESP_ERR_NO_ERROR. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ad86e25f9787e647588fc2067705de10e </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_header_remove","title":"rd_kafka_header_remove()","text":"<pre><code>public static rd_kafka_header_remove ( \n    \\FFI\\CData|null $hdrs, \n    string|null $name\n ): int\n</code></pre> <p>Remove all headers for the given key (if any). </p> Parameters hdrs <code>\\FFI\\CData|null</code> rd_kafka_headers_t* name <code>string|null</code> const char* Returns <code>int</code> rd_kafka_resp_err_t - RD_KAFKA_RESP_ERR__READ_ONLY if the headers are read-only, RD_KAFKA_RESP_ERR__NOENT if no matching headers were found, else RD_KAFKA_RESP_ERR_NO_ERROR if headers were removed. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8a8d23d274cf233b6b4b0a345c0180c1 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_header_get_last","title":"rd_kafka_header_get_last()","text":"<pre><code>public static rd_kafka_header_get_last ( \n    \\FFI\\CData|null $hdrs, \n    string|null $name, \n    \\FFI\\CData|object|string|null $valuep, \n    \\FFI\\CData|null $sizep\n ): int\n</code></pre> <p>Find last header in list <code>hdrs</code> matching <code>name</code>. </p> RemarksThe returned pointer in <code>valuep</code> includes a trailing null-terminator that is not accounted for in <code>sizep</code>.   The returned pointer is only valid as long as the headers list and the header item is valid.  Parameters hdrs <code>\\FFI\\CData|null</code> const rd_kafka_headers_t* - Headers list. name <code>string|null</code> const char* - Header to find (last match). valuep <code>\\FFI\\CData|object|string|null</code> const void** - (out) Set to a (null-terminated) const pointer to the value (may be NULL). sizep <code>\\FFI\\CData|null</code> size_t* - (out) Set to the value\u2019s size (not including null-terminator). Returns <code>int</code> rd_kafka_resp_err_t - RD_KAFKA_RESP_ERR_NO_ERROR if an entry was found, else RD_KAFKA_RESP_ERR__NOENT. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a6cb8628d390cd89a6d9daada8c70161a </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_header_get","title":"rd_kafka_header_get()","text":"<pre><code>public static rd_kafka_header_get ( \n    \\FFI\\CData|null $hdrs, \n    int|null $idx, \n    string|null $name, \n    \\FFI\\CData|object|string|null $valuep, \n    \\FFI\\CData|null $sizep\n ): int\n</code></pre> <p>Iterator for headers matching <code>name</code>. </p> <pre>   Same semantics as rd_kafka_header_get_last()\n</pre> Parameters hdrs <code>\\FFI\\CData|null</code> const rd_kafka_headers_t* - Headers to iterate. idx <code>int|null</code> size_t - Iterator index, start at 0 and increment by one for each call as long as RD_KAFKA_RESP_ERR_NO_ERROR is returned. name <code>string|null</code> const char* - Header name to match. valuep <code>\\FFI\\CData|object|string|null</code> const void** - (out) Set to a (null-terminated) const pointer to the value (may be NULL). sizep <code>\\FFI\\CData|null</code> size_t* - (out) Set to the value\u2019s size (not including null-terminator). Returns <code>int</code> rd_kafka_resp_err_t <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a5cf2d5ce4869203aaa9e18ad2c763bbf </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_header_get_all","title":"rd_kafka_header_get_all()","text":"<pre><code>public static rd_kafka_header_get_all ( \n    \\FFI\\CData|null $hdrs, \n    int|null $idx, \n    \\FFI\\CData|null $namep, \n    \\FFI\\CData|object|string|null $valuep, \n    \\FFI\\CData|null $sizep\n ): int\n</code></pre> <p>Iterator for all headers. </p> <pre>   Same semantics as rd_kafka_header_get()\n</pre> See alsord_kafka_header_get()  Parameters hdrs <code>\\FFI\\CData|null</code> const rd_kafka_headers_t* idx <code>int|null</code> size_t namep <code>\\FFI\\CData|null</code> const char** valuep <code>\\FFI\\CData|object|string|null</code> const void** sizep <code>\\FFI\\CData|null</code> size_t* Returns <code>int</code> rd_kafka_resp_err_t <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a3a39136e1d13591f668158c0fa20961b </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_message_destroy","title":"rd_kafka_message_destroy()","text":"<pre><code>public static rd_kafka_message_destroy ( \n    \\FFI\\CData|null $rkmessage\n ): void\n</code></pre> Parameters rkmessage <code>\\FFI\\CData|null</code> rd_kafka_message_t*"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_message_timestamp","title":"rd_kafka_message_timestamp()","text":"<pre><code>public static rd_kafka_message_timestamp ( \n    \\FFI\\CData|null $rkmessage, \n    \\FFI\\CData|null $tstype\n ): int|null\n</code></pre> <p>Returns the message timestamp for a consumed message. </p> <p>The timestamp is the number of milliseconds since the epoch (UTC).</p> <p><code>tstype</code> (if not NULL) is updated to indicate the type of timestamp.</p> RemarksMessage timestamps require broker version 0.10.0 or later.  Parameters rkmessage <code>\\FFI\\CData|null</code> const rd_kafka_message_t* tstype <code>\\FFI\\CData|null</code> rd_kafka_timestamp_type_t* Returns <code>int|null</code> int64_t - message timestamp, or -1 if not available. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a4371deba4afe6941cc5f9e80df5ca3e7 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_message_latency","title":"rd_kafka_message_latency()","text":"<pre><code>public static rd_kafka_message_latency ( \n    \\FFI\\CData|null $rkmessage\n ): int|null\n</code></pre> <p>Returns the latency for a produced message measured from the produce() call. </p> Parameters rkmessage <code>\\FFI\\CData|null</code> const rd_kafka_message_t* - ) Returns <code>int|null</code> int64_t - the latency in microseconds, or -1 if not available. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aba20435b42efef7a3c38dee3fb58c27b </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_message_headers","title":"rd_kafka_message_headers()","text":"<pre><code>public static rd_kafka_message_headers ( \n    \\FFI\\CData|null $rkmessage, \n    \\FFI\\CData|null $hdrsp\n ): int\n</code></pre> <p>Get the message header list. </p> <p>The returned pointer in <code>*hdrsp</code> is associated with the <code>rkmessage</code> and must not be used after destruction of the message object or the header list is replaced with rd_kafka_message_set_headers().</p> RemarksHeaders require broker version 0.11.0.0 or later.  As an optimization the raw protocol headers are parsed on the first call to this function.  Parameters rkmessage <code>\\FFI\\CData|null</code> const rd_kafka_message_t* hdrsp <code>\\FFI\\CData|null</code> rd_kafka_headers_t** Returns <code>int</code> rd_kafka_resp_err_t - RD_KAFKA_RESP_ERR_NO_ERROR if headers were returned, RD_KAFKA_RESP_ERR__NOENT if the message has no headers, or another error code if the headers could not be parsed. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aaccd9ee7e1c73b89d86ed41db3b86e68 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_message_detach_headers","title":"rd_kafka_message_detach_headers()","text":"<pre><code>public static rd_kafka_message_detach_headers ( \n    \\FFI\\CData|null $rkmessage, \n    \\FFI\\CData|null $hdrsp\n ): int\n</code></pre> <p>Get the message header list and detach the list from the message making the application the owner of the headers. The application must eventually destroy the headers using rd_kafka_headers_destroy(). The message's headers will be set to NULL. </p> <p>Otherwise same semantics as rd_kafka_message_headers()</p> See alsord_kafka_message_headers  Parameters rkmessage <code>\\FFI\\CData|null</code> rd_kafka_message_t* hdrsp <code>\\FFI\\CData|null</code> rd_kafka_headers_t** Returns <code>int</code> rd_kafka_resp_err_t <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#af89ef912d3c1ff66ea612fda27c0a643 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_message_set_headers","title":"rd_kafka_message_set_headers()","text":"<pre><code>public static rd_kafka_message_set_headers ( \n    \\FFI\\CData|null $rkmessage, \n    \\FFI\\CData|null $hdrs\n ): void\n</code></pre> <p>Replace the message's current headers with a new list. </p> RemarksThe existing headers object, if any, will be destroyed.  Parameters rkmessage <code>\\FFI\\CData|null</code> rd_kafka_message_t* - The message to set headers. hdrs <code>\\FFI\\CData|null</code> rd_kafka_headers_t* - New header list. The message object assumes ownership of the list, the list will be destroyed automatically with the message object. The new headers list may be updated until the message object is passed or returned to librdkafka. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a99e46233e57fc4f5783d8ae374584bbe </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_header_cnt","title":"rd_kafka_header_cnt()","text":"<pre><code>public static rd_kafka_header_cnt ( \n    \\FFI\\CData|null $hdrs\n ): int|null\n</code></pre> <p>Returns the number of header key/value pairs. </p> Parameters hdrs <code>\\FFI\\CData|null</code> const rd_kafka_headers_t* - ) - Headers to count Returns <code>int|null</code> size_t <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#af8ce5228eef3ea0a9209965902b6fcdd </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_message_status","title":"rd_kafka_message_status()","text":"<pre><code>public static rd_kafka_message_status ( \n    \\FFI\\CData|null $rkmessage\n ): int\n</code></pre> <p>Returns the message's persistence status in the topic log. </p> RemarksThe message status is not available in on_acknowledgement interceptors.  Parameters rkmessage <code>\\FFI\\CData|null</code> const rd_kafka_message_t* - ) Returns <code>int</code> rd_kafka_msg_status_t <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#af259b9c4216b74d4f750d93ff6396ce5 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_conf_new","title":"rd_kafka_conf_new()","text":"<pre><code>public static rd_kafka_conf_new (  ): \\FFI\\CData|null\n</code></pre> <p>Create configuration object. </p> <p>When providing your own configuration to the <code>rd_kafka_*_new_*</code>() calls the rd_kafka_conf_t objects needs to be created with this function which will set up the defaults. I.e.: </p> <pre><code>rd_kafka_conf_t *myconf;\nrd_kafka_conf_res_t res;\n\nmyconf = rd_kafka_conf_new();\nres = rd_kafka_conf_set(myconf, \"socket.timeout.ms\", \"600\",\n                        errstr, sizeof(errstr));\nif (res != RD_KAFKA_CONF_OK)\n   die(\"%s\\n\", errstr);\n\nrk = rd_kafka_new(..., myconf);</code></pre> <p>Please see CONFIGURATION.md for the default settings or use rd_kafka_conf_properties_show() to provide the information at runtime.</p> <p>The properties are identical to the Apache Kafka configuration properties whenever possible.</p> RemarksA successful call to rd_kafka_new() will assume ownership of the conf object and rd_kafka_conf_destroy() must not be called. See alsord_kafka_new(), rd_kafka_conf_set(), rd_kafka_conf_destroy()  Returns <code>\\FFI\\CData|null</code> rd_kafka_conf_t* - ) - A new rd_kafka_conf_t object with defaults set. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aa7459bd22e8cfa81aa8c2480a4a0304c </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_conf_destroy","title":"rd_kafka_conf_destroy()","text":"<pre><code>public static rd_kafka_conf_destroy ( \n    \\FFI\\CData|null $conf\n ): void\n</code></pre> Parameters conf <code>\\FFI\\CData|null</code> rd_kafka_conf_t*"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_conf_dup","title":"rd_kafka_conf_dup()","text":"<pre><code>public static rd_kafka_conf_dup ( \n    \\FFI\\CData|null $conf\n ): \\FFI\\CData|null\n</code></pre> <p>Creates a copy/duplicate of configuration object <code>conf</code>. </p> RemarksInterceptors are NOT copied to the new configuration object.  See alsord_kafka_interceptor_f_on_conf_dup  Parameters conf <code>\\FFI\\CData|null</code> const rd_kafka_conf_t* - ) Returns <code>\\FFI\\CData|null</code> rd_kafka_conf_t* <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8cbfe15c6978ff09870e82cb524c673d </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_conf_dup_filter","title":"rd_kafka_conf_dup_filter()","text":"<pre><code>public static rd_kafka_conf_dup_filter ( \n    \\FFI\\CData|null $conf, \n    int|null $filter_cnt, \n    \\FFI\\CData|null $filter\n ): \\FFI\\CData|null\n</code></pre> Parameters conf <code>\\FFI\\CData|null</code> const rd_kafka_conf_t* filter_cnt <code>int|null</code> size_t filter <code>\\FFI\\CData|null</code> const char** Returns <code>\\FFI\\CData|null</code> rd_kafka_conf_t*"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_conf_set","title":"rd_kafka_conf_set()","text":"<pre><code>public static rd_kafka_conf_set ( \n    \\FFI\\CData|null $conf, \n    string|null $name, \n    string|null $value, \n    \\FFI\\CData|null $errstr, \n    int|null $errstr_size\n ): int\n</code></pre> <p>Sets a configuration property. </p> <p><code>conf</code> must have been previously created with rd_kafka_conf_new().</p> <p>Fallthrough: Topic-level configuration properties may be set using this interface in which case they are applied on the <code>default_topic_conf</code>. If no <code>default_topic_conf</code> has been set one will be created. Any subsequent rd_kafka_conf_set_default_topic_conf() calls will replace the current default topic configuration.</p> RemarksSetting properties or values that were disabled at build time due to missing dependencies will return RD_KAFKA_CONF_INVALID.  Parameters conf <code>\\FFI\\CData|null</code> rd_kafka_conf_t* name <code>string|null</code> const char* value <code>string|null</code> const char* errstr <code>\\FFI\\CData|null</code> char* errstr_size <code>int|null</code> size_t Returns <code>int</code> rd_kafka_conf_res_t - <code>rd_kafka_conf_res_t</code> to indicate success or failure. In case of failure <code>errstr</code> is updated to contain a human readable error string. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#abb1b319278333e8cdee9442da7f135e8 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_conf_set_events","title":"rd_kafka_conf_set_events()","text":"<pre><code>public static rd_kafka_conf_set_events ( \n    \\FFI\\CData|null $conf, \n    int|null $events\n ): void\n</code></pre> Parameters conf <code>\\FFI\\CData|null</code> rd_kafka_conf_t* events <code>int|null</code> int"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_conf_set_background_event_cb","title":"rd_kafka_conf_set_background_event_cb()","text":"<pre><code>public static rd_kafka_conf_set_background_event_cb ( \n    \\FFI\\CData|null $conf, \n    \\FFI\\CData|\\Closure $event_cb\n ): void\n</code></pre> <p>Generic event callback to be used with the event API to trigger callbacks for <code>rd_kafka_event_t</code> objects from a background thread serving the background queue. </p> <p>How to use:</p> <ol> <li>First set the event callback on the configuration object with this function, followed by creating an rd_kafka_t instance with rd_kafka_new().</li> <li>Get the instance's background queue with rd_kafka_queue_get_background() and pass it as the reply/response queue to an API that takes an event queue, such as rd_kafka_CreateTopics().</li> <li>As the response event is ready and enqueued on the background queue the event callback will be triggered from the background thread.</li> <li>Prior to destroying the client instance, loose your reference to the background queue by calling rd_kafka_queue_destroy().</li> </ol> <p>The application must destroy the <code>rkev</code> passed to <code>event</code> cb using rd_kafka_event_destroy().</p> <p>The <code>event_cb</code> <code>opaque</code> argument is the opaque set with rd_kafka_conf_set_opaque().</p> RemarksThis callback is a specialized alternative to the poll-based event API described in the Event interface section.  The <code>event_cb</code> will be called spontaneously from a background thread completely managed by librdkafka. Take care to perform proper locking of application objects. WarningThe application MUST NOT call rd_kafka_destroy() from the event callback. See alsord_kafka_queue_get_background  Parameters conf <code>\\FFI\\CData|null</code> rd_kafka_conf_t* event_cb <code>\\FFI\\CData|\\Closure</code> void()(rd_kafka_t, rd_kafka_event_t*, void*) <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a5ce6c329ca692674b1c42460f9bab521 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_conf_set_dr_cb","title":"rd_kafka_conf_set_dr_cb()","text":"<pre><code>public static rd_kafka_conf_set_dr_cb ( \n    \\FFI\\CData|null $conf, \n    \\FFI\\CData|\\Closure $dr_cb\n ): void\n</code></pre> Deprecated:See rd_kafka_conf_set_dr_msg_cb()  Parameters conf <code>\\FFI\\CData|null</code> rd_kafka_conf_t* dr_cb <code>\\FFI\\CData|\\Closure</code> void()(rd_kafka_t, void*, size_t, rd_kafka_resp_err_t, void*, void*) <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a075b15c4141784fdc271de217005a41f </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_conf_set_dr_msg_cb","title":"rd_kafka_conf_set_dr_msg_cb()","text":"<pre><code>public static rd_kafka_conf_set_dr_msg_cb ( \n    \\FFI\\CData|null $conf, \n    \\FFI\\CData|\\Closure $dr_msg_cb\n ): void\n</code></pre> <p>Producer: Set delivery report callback in provided <code>conf</code> object. </p> <p>The delivery report callback will be called once for each message accepted by rd_kafka_produce() (et.al) with <code>err</code> set to indicate the result of the produce request.</p> <p>The callback is called when a message is succesfully produced or if librdkafka encountered a permanent failure. Delivery errors occur when the retry count is exceeded, when the message.timeout.ms timeout is exceeded or there is a permanent error like RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART.</p> <p>An application must call rd_kafka_poll() at regular intervals to serve queued delivery report callbacks.</p> <p>The broker-assigned offset can be retrieved with <code>rkmessage-&gt;offset</code> and the timestamp can be retrieved using rd_kafka_message_timestamp().</p> <p>The <code>dr_msg_cb</code> <code>opaque</code> argument is the opaque set with rd_kafka_conf_set_opaque(). The per-message msg_opaque value is available in <code>rd_kafka_message_t._private</code>.</p> RemarksThe Idempotent Producer may return invalid timestamp (RD_KAFKA_TIMESTAMP_NOT_AVAILABLE), and and offset (RD_KAFKA_OFFSET_INVALID) for retried messages that were previously successfully delivered but not properly acknowledged.  Parameters conf <code>\\FFI\\CData|null</code> rd_kafka_conf_t* dr_msg_cb <code>\\FFI\\CData|\\Closure</code> void()(rd_kafka_t, const rd_kafka_message_t*, void*) <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ac1c9946aee26e10de2661fcf2242ea8a </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_conf_set_consume_cb","title":"rd_kafka_conf_set_consume_cb()","text":"<pre><code>public static rd_kafka_conf_set_consume_cb ( \n    \\FFI\\CData|null $conf, \n    \\FFI\\CData|\\Closure $consume_cb\n ): void\n</code></pre> <p>Consumer: Set consume callback for use with rd_kafka_consumer_poll() </p> <p>The <code>consume_cb</code> <code>opaque</code> argument is the opaque set with rd_kafka_conf_set_opaque(). </p> Parameters conf <code>\\FFI\\CData|null</code> rd_kafka_conf_t* consume_cb <code>\\FFI\\CData|\\Closure</code> void()(rd_kafka_message_t, void*) <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a65eaf45e9b26bcb085f4651634ce06a5 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_conf_set_rebalance_cb","title":"rd_kafka_conf_set_rebalance_cb()","text":"<pre><code>public static rd_kafka_conf_set_rebalance_cb ( \n    \\FFI\\CData|null $conf, \n    \\FFI\\CData|\\Closure $rebalance_cb\n ): void\n</code></pre> <p>Consumer: Set rebalance callback for use with coordinated consumer group balancing. </p> <p>The <code>err</code> field is set to either RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS or RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS and 'partitions' contains the full partition set that was either assigned or revoked.</p> <p>Registering a <code>rebalance_cb</code> turns off librdkafka's automatic partition assignment/revocation and instead delegates that responsibility to the application's <code>rebalance_cb</code>.</p> <p>The rebalance callback is responsible for updating librdkafka's assignment set based on the two events: RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS and RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS but should also be able to handle arbitrary rebalancing failures where <code>err</code> is neither of those. </p> RemarksIn this latter case (arbitrary error), the application must call rd_kafka_assign(rk, NULL) to synchronize state. <p>For eager/non-cooperative <code>partition.assignment.strategy</code> assignors, such as <code>range</code> and <code>roundrobin</code>, the application must use rd_kafka_assign() to set or clear the entire assignment. For the cooperative assignors, such as <code>cooperative-sticky</code>, the application must use rd_kafka_incremental_assign() for RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS and rd_kafka_incremental_unassign() for RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS.</p> <p>Without a rebalance callback this is done automatically by librdkafka but registering a rebalance callback gives the application flexibility in performing other operations along with the assigning/revocation, such as fetching offsets from an alternate location (on assign) or manually committing offsets (on revoke).</p> <p>rebalance_cb is always triggered exactly once when a rebalance completes with a new assignment, even if that assignment is empty. If an eager/non-cooperative assignor is configured, there will eventually be exactly one corresponding call to rebalance_cb to revoke these partitions (even if empty), whether this is due to a group rebalance or lost partitions. In the cooperative case, rebalance_cb will never be called if the set of partitions being revoked is empty (whether or not lost).</p> <p>The callback's <code>opaque</code> argument is the opaque set with rd_kafka_conf_set_opaque().</p> RemarksThe <code>partitions</code> list is destroyed by librdkafka on return return from the rebalance_cb and must not be freed or saved by the application.  Be careful when modifying the <code>partitions</code> list. Changing this list should only be done to change the initial offsets for each partition. But a function like <code>rd_kafka_position()</code> might have unexpected effects for instance when a consumer gets assigned a partition it used to consume at an earlier rebalance. In this case, the list of partitions will be updated with the old offset for that partition. In this case, it is generally better to pass a copy of the list (see <code>rd_kafka_topic_partition_list_copy()</code>). The result of <code>rd_kafka_position()</code> is typically outdated in RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS. See alsord_kafka_assign()   rd_kafka_incremental_assign()   rd_kafka_incremental_unassign()   rd_kafka_assignment_lost()   rd_kafka_rebalance_protocol() <p>The following example shows the application's responsibilities: </p> <pre><code>static void rebalance_cb (rd_kafka_t *rk, rd_kafka_resp_err_t err,\n                          rd_kafka_topic_partition_list_t *partitions,\n                          void *opaque) {\n\nswitch (err)\n    {\n      case RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS:\n         // application may load offets from arbitrary external\n         // storage here and update \\p partitions\n         if (!strcmp(rd_kafka_rebalance_protocol(rk), \"COOPERATIVE\"))\n                 rd_kafka_incremental_assign(rk, partitions);\n         else // EAGER\n                 rd_kafka_assign(rk, partitions);\n         break;\n\n      case RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS:\n         if (manual_commits) // Optional explicit manual commit\n             rd_kafka_commit(rk, partitions, 0); // sync commit\n\n         if (!strcmp(rd_kafka_rebalance_protocol(rk), \"COOPERATIVE\"))\n                 rd_kafka_incremental_unassign(rk, partitions);\n         else // EAGER\n                 rd_kafka_assign(rk, NULL);\n         break;\n\n      default:\n         handle_unlikely_error(err);\n         rd_kafka_assign(rk, NULL); // sync state\n         break;\n     }\n}</code></pre> RemarksThe above example lacks error handling for assign calls, see the examples/ directory.  Parameters conf <code>\\FFI\\CData|null</code> rd_kafka_conf_t* rebalance_cb <code>\\FFI\\CData|\\Closure</code> void()(rd_kafka_t, rd_kafka_resp_err_t, rd_kafka_topic_partition_list_t*, void*) <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a10db731dc1a295bd9884e4f8cb199311 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_conf_set_offset_commit_cb","title":"rd_kafka_conf_set_offset_commit_cb()","text":"<pre><code>public static rd_kafka_conf_set_offset_commit_cb ( \n    \\FFI\\CData|null $conf, \n    \\FFI\\CData|\\Closure $offset_commit_cb\n ): void\n</code></pre> <p>Consumer: Set offset commit callback for use with consumer groups. </p> <p>The results of automatic or manual offset commits will be scheduled for this callback and is served by rd_kafka_consumer_poll().</p> <p>If no partitions had valid offsets to commit this callback will be called with <code>err</code> == RD_KAFKA_RESP_ERR__NO_OFFSET which is not to be considered an error.</p> <p>The <code>offsets</code> list contains per-partition information:</p> <ul> <li><code>offset:</code> committed offset (attempted)</li> <li><code>err:</code> commit error</li> </ul> <p>The callback's <code>opaque</code> argument is the opaque set with rd_kafka_conf_set_opaque(). </p> Parameters conf <code>\\FFI\\CData|null</code> rd_kafka_conf_t* offset_commit_cb <code>\\FFI\\CData|\\Closure</code> void()(rd_kafka_t, rd_kafka_resp_err_t, rd_kafka_topic_partition_list_t*, void*) <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a1ab8bb9e8d8cdd5906f9e060b506f2eb </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_conf_set_error_cb","title":"rd_kafka_conf_set_error_cb()","text":"<pre><code>public static rd_kafka_conf_set_error_cb ( \n    \\FFI\\CData|null $conf, \n    \\FFI\\CData|\\Closure $error_cb\n ): void\n</code></pre> <p>Set error callback in provided conf object. </p> <p>The error callback is used by librdkafka to signal warnings and errors back to the application.</p> <p>These errors should generally be considered informational and non-permanent, the client will try to recover automatically from all type of errors. Given that the client and cluster configuration is correct the application should treat these as temporary errors.</p> <p><code>error_cb</code> will be triggered with <code>err</code> set to RD_KAFKA_RESP_ERR__FATAL if a fatal error has been raised; in this case use rd_kafka_fatal_error() to retrieve the fatal error code and error string, and then begin terminating the client instance.</p> <p>If no <code>error_cb</code> is registered, or RD_KAFKA_EVENT_ERROR has not been set with rd_kafka_conf_set_events, then the errors will be logged instead.</p> <p>The callback's <code>opaque</code> argument is the opaque set with rd_kafka_conf_set_opaque(). </p> Parameters conf <code>\\FFI\\CData|null</code> rd_kafka_conf_t* error_cb <code>\\FFI\\CData|\\Closure</code> void()(rd_kafka_t, int, const char*, void*) <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ace721ef3b7c22d0c111ec747ef039a90 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_conf_set_throttle_cb","title":"rd_kafka_conf_set_throttle_cb()","text":"<pre><code>public static rd_kafka_conf_set_throttle_cb ( \n    \\FFI\\CData|null $conf, \n    \\FFI\\CData|\\Closure $throttle_cb\n ): void\n</code></pre> <p>Set throttle callback. </p> <p>The throttle callback is used to forward broker throttle times to the application for Produce and Fetch (consume) requests.</p> <p>Callbacks are triggered whenever a non-zero throttle time is returned by the broker, or when the throttle time drops back to zero.</p> <p>An application must call rd_kafka_poll() or rd_kafka_consumer_poll() at regular intervals to serve queued callbacks.</p> <p>The callback's <code>opaque</code> argument is the opaque set with rd_kafka_conf_set_opaque().</p> RemarksRequires broker version 0.9.0 or later.  Parameters conf <code>\\FFI\\CData|null</code> rd_kafka_conf_t* throttle_cb <code>\\FFI\\CData|\\Closure</code> void()(rd_kafka_t, const char*, int32_t, int, void*) <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a04160826ad039d42c10edec456163fa7 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_conf_set_log_cb","title":"rd_kafka_conf_set_log_cb()","text":"<pre><code>public static rd_kafka_conf_set_log_cb ( \n    \\FFI\\CData|null $conf, \n    \\FFI\\CData|\\Closure $log_cb\n ): void\n</code></pre> <p>Set logger callback. </p> <p>The default is to print to stderr, but a syslog logger is also available, see rd_kafka_log_print and rd_kafka_log_syslog for the builtin alternatives. Alternatively the application may provide its own logger callback. Or pass <code>func</code> as NULL to disable logging.</p> <p>This is the configuration alternative to the deprecated rd_kafka_set_logger()</p> RemarksThe log_cb will be called spontaneously from librdkafka's internal threads unless logs have been forwarded to a poll queue through <code>rd_kafka_set_log_queue()</code>. An application MUST NOT call any librdkafka APIs or do any prolonged work in a non-forwarded <code>log_cb</code>.  Parameters conf <code>\\FFI\\CData|null</code> rd_kafka_conf_t* log_cb <code>\\FFI\\CData|\\Closure</code> void()(const rd_kafka_t, int, const char*, const char*) <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a06ade2ca41f32eb82c6f7e3d4acbe19f </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_conf_set_stats_cb","title":"rd_kafka_conf_set_stats_cb()","text":"<pre><code>public static rd_kafka_conf_set_stats_cb ( \n    \\FFI\\CData|null $conf, \n    \\FFI\\CData|\\Closure $stats_cb\n ): void\n</code></pre> <p>Set statistics callback in provided conf object. </p> <p>The statistics callback is triggered from rd_kafka_poll() every <code>statistics.interval.ms</code> (needs to be configured separately). Function arguments:</p> <ul> <li><code>rk</code> - Kafka handle</li> <li><code>json</code> - String containing the statistics data in JSON format</li> <li><code>json_len</code> - Length of <code>json</code> string.</li> <li><code>opaque</code> - Application-provided opaque as set by rd_kafka_conf_set_opaque().</li> </ul> <p>For more information on the format of <code>json</code>, see https://github.com/confluentinc/librdkafka/wiki/Statistics</p> <p>If the application wishes to hold on to the <code>json</code> pointer and free it at a later time it must return 1 from the <code>stats_cb</code>. If the application returns 0 from the <code>stats_cb</code> then librdkafka will immediately free the <code>json</code> pointer.</p> <p>See STATISTICS.md for a full definition of the JSON object. </p> Parameters conf <code>\\FFI\\CData|null</code> rd_kafka_conf_t* stats_cb <code>\\FFI\\CData|\\Closure</code> int()(rd_kafka_t, char*, size_t, void*) <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a597d00432e3ca22174d18e7e348fb766 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_conf_set_socket_cb","title":"rd_kafka_conf_set_socket_cb()","text":"<pre><code>public static rd_kafka_conf_set_socket_cb ( \n    \\FFI\\CData|null $conf, \n    \\FFI\\CData|\\Closure $socket_cb\n ): void\n</code></pre> <p>Set socket callback. </p> <p>The socket callback is responsible for opening a socket according to the supplied <code>domain</code>, <code>type</code> and <code>protocol</code>. The socket shall be created with <code>CLOEXEC</code> set in a racefree fashion, if possible.</p> <p>The callback's <code>opaque</code> argument is the opaque set with rd_kafka_conf_set_opaque().</p> <p>Default:</p> <ul> <li>on linux: racefree CLOEXEC</li> <li>others : non-racefree CLOEXEC</li> </ul> RemarksThe callback will be called from an internal librdkafka thread.  Parameters conf <code>\\FFI\\CData|null</code> rd_kafka_conf_t* socket_cb <code>\\FFI\\CData|\\Closure</code> int()(int, int, int, void) <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a0467a6c20d5af69a29a63b530962ecbf </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_conf_set_connect_cb","title":"rd_kafka_conf_set_connect_cb()","text":"<pre><code>public static rd_kafka_conf_set_connect_cb ( \n    \\FFI\\CData|null $conf, \n    \\FFI\\CData|\\Closure $connect_cb\n ): void\n</code></pre> <p>Set connect callback. </p> <p>The connect callback is responsible for connecting socket <code>sockfd</code> to peer address <code>addr</code>. The <code>id</code> field contains the broker identifier.</p> <p><code>connect_cb</code> shall return 0 on success (socket connected) or an error number (errno) on error.</p> <p>The callback's <code>opaque</code> argument is the opaque set with rd_kafka_conf_set_opaque().</p> RemarksThe callback will be called from an internal librdkafka thread.  Parameters conf <code>\\FFI\\CData|null</code> rd_kafka_conf_t* connect_cb <code>\\FFI\\CData|\\Closure</code> int()(int, const struct sockaddr, int, const char*, void*) <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a53dd1b77019324170d0168617fdaf040 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_conf_set_closesocket_cb","title":"rd_kafka_conf_set_closesocket_cb()","text":"<pre><code>public static rd_kafka_conf_set_closesocket_cb ( \n    \\FFI\\CData|null $conf, \n    \\FFI\\CData|\\Closure $closesocket_cb\n ): void\n</code></pre> <p>Set close socket callback. </p> <p>Close a socket (optionally opened with socket_cb()).</p> <p>The callback's <code>opaque</code> argument is the opaque set with rd_kafka_conf_set_opaque().</p> RemarksThe callback will be called from an internal librdkafka thread.  Parameters conf <code>\\FFI\\CData|null</code> rd_kafka_conf_t* closesocket_cb <code>\\FFI\\CData|\\Closure</code> int()(int, void) <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ab55c7ddc46a354e3f57b5b209e5ec3c7 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_conf_set_opaque","title":"rd_kafka_conf_set_opaque()","text":"<pre><code>public static rd_kafka_conf_set_opaque ( \n    \\FFI\\CData|null $conf, \n    \\FFI\\CData|object|string|null $opaque\n ): void\n</code></pre> <p>Sets the application's opaque pointer that will be passed to callbacks. </p> See alsord_kafka_opaque()  Parameters conf <code>\\FFI\\CData|null</code> rd_kafka_conf_t* opaque <code>\\FFI\\CData|object|string|null</code> void* <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a07cb7d91d9b7458a95ca6f1292763c24 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_opaque","title":"rd_kafka_opaque()","text":"<pre><code>public static rd_kafka_opaque ( \n    \\FFI\\CData|null $rk\n ): \\FFI\\CData|object|string|null\n</code></pre> Parameters rk <code>\\FFI\\CData|null</code> const rd_kafka_t* Returns <code>\\FFI\\CData|object|string|null</code> void*"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_conf_set_default_topic_conf","title":"rd_kafka_conf_set_default_topic_conf()","text":"<pre><code>public static rd_kafka_conf_set_default_topic_conf ( \n    \\FFI\\CData|null $conf, \n    \\FFI\\CData|null $tconf\n ): void\n</code></pre> <p>Sets the default topic configuration to use for automatically subscribed topics (e.g., through pattern-matched topics). The topic config object is not usable after this call. </p> WarningAny topic configuration settings that have been set on the global rd_kafka_conf_t object will be overwritten by this call since the implicitly created default topic config object is replaced by the user-supplied one. Deprecated:Set default topic level configuration on the global rd_kafka_conf_t object instead.  Parameters conf <code>\\FFI\\CData|null</code> rd_kafka_conf_t* tconf <code>\\FFI\\CData|null</code> rd_kafka_topic_conf_t* <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a138aa4881c8703dd6b69f22ddc454f63 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_conf_get","title":"rd_kafka_conf_get()","text":"<pre><code>public static rd_kafka_conf_get ( \n    \\FFI\\CData|null $conf, \n    string|null $name, \n    \\FFI\\CData|null $dest, \n    \\FFI\\CData|null $dest_size\n ): int\n</code></pre> <p>Retrieve configuration value for property <code>name</code>. </p> <p>If <code>dest</code> is non-NULL the value will be written to <code>dest</code> with at most <code>dest_size</code>.</p> <p><code>*dest_size</code> is updated to the full length of the value, thus if <code>*dest_size</code> initially is smaller than the full length the application may reallocate <code>dest</code> to fit the returned <code>*dest_size</code> and try again.</p> <p>If <code>dest</code> is NULL only the full length of the value is returned.</p> <p>Fallthrough: Topic-level configuration properties from the <code>default_topic_conf</code> may be retrieved using this interface.</p> Parameters conf <code>\\FFI\\CData|null</code> const rd_kafka_conf_t* name <code>string|null</code> const char* dest <code>\\FFI\\CData|null</code> char* dest_size <code>\\FFI\\CData|null</code> size_t* Returns <code>int</code> rd_kafka_conf_res_t - <code>RD_KAFKA_CONF_OK</code> if the property name matched, else <code>RD_KAFKA_CONF_UNKNOWN</code>. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#abe9f0f77e9145eb1a62c3258ac495b97 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_topic_conf_get","title":"rd_kafka_topic_conf_get()","text":"<pre><code>public static rd_kafka_topic_conf_get ( \n    \\FFI\\CData|null $conf, \n    string|null $name, \n    \\FFI\\CData|null $dest, \n    \\FFI\\CData|null $dest_size\n ): int\n</code></pre> <p>Retrieve topic configuration value for property <code>name</code>. </p> See alsord_kafka_conf_get()  Parameters conf <code>\\FFI\\CData|null</code> const rd_kafka_topic_conf_t* name <code>string|null</code> const char* dest <code>\\FFI\\CData|null</code> char* dest_size <code>\\FFI\\CData|null</code> size_t* Returns <code>int</code> rd_kafka_conf_res_t <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a56939e7f77106b9e810d59289443e25d </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_conf_dump","title":"rd_kafka_conf_dump()","text":"<pre><code>public static rd_kafka_conf_dump ( \n    \\FFI\\CData|null $conf, \n    \\FFI\\CData|null $cntp\n ): \\FFI\\CData|null\n</code></pre> <p>Dump the configuration properties and values of <code>conf</code> to an array with \"key\", \"value\" pairs. </p> <p>The number of entries in the array is returned in <code>*cntp</code>.</p> <p>The dump must be freed with <code>rd_kafka_conf_dump_free()</code>. </p> Parameters conf <code>\\FFI\\CData|null</code> rd_kafka_conf_t* cntp <code>\\FFI\\CData|null</code> size_t* Returns <code>\\FFI\\CData|null</code> const char** <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a6eba851c2af748de6921d708b47dc94c </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_topic_conf_dump","title":"rd_kafka_topic_conf_dump()","text":"<pre><code>public static rd_kafka_topic_conf_dump ( \n    \\FFI\\CData|null $conf, \n    \\FFI\\CData|null $cntp\n ): \\FFI\\CData|null\n</code></pre> <p>Dump the topic configuration properties and values of <code>conf</code> to an array with \"key\", \"value\" pairs. </p> <p>The number of entries in the array is returned in <code>*cntp</code>.</p> <p>The dump must be freed with <code>rd_kafka_conf_dump_free()</code>. </p> Parameters conf <code>\\FFI\\CData|null</code> rd_kafka_topic_conf_t* cntp <code>\\FFI\\CData|null</code> size_t* Returns <code>\\FFI\\CData|null</code> const char** <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a40a7a88bd5ac81b21c45d1fdd4d9e696 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_conf_dump_free","title":"rd_kafka_conf_dump_free()","text":"<pre><code>public static rd_kafka_conf_dump_free ( \n    \\FFI\\CData|null $arr, \n    int|null $cnt\n ): void\n</code></pre> Parameters arr <code>\\FFI\\CData|null</code> const char** cnt <code>int|null</code> size_t"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_conf_properties_show","title":"rd_kafka_conf_properties_show()","text":"<pre><code>public static rd_kafka_conf_properties_show ( \n    \\FFI\\CData|null $fp\n ): void\n</code></pre> <p>Prints a table to <code>fp</code> of all supported configuration properties, their default values as well as a description. </p> RemarksAll properties and properties and values are shown, even those that have been disabled at build time due to missing dependencies.  Parameters fp <code>\\FFI\\CData|null</code> FILE* - ) <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aa52f3a5a08207e14386739fe336e57be </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_topic_conf_new","title":"rd_kafka_topic_conf_new()","text":"<pre><code>public static rd_kafka_topic_conf_new (  ): \\FFI\\CData|null\n</code></pre> <p>Create topic configuration object. </p> See alsoSame semantics as for rd_kafka_conf_new().  Returns <code>\\FFI\\CData|null</code> rd_kafka_topic_conf_t* - ) <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a1a7032f87e7d868b80e38d0fd0ad119e </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_topic_conf_dup","title":"rd_kafka_topic_conf_dup()","text":"<pre><code>public static rd_kafka_topic_conf_dup ( \n    \\FFI\\CData|null $conf\n ): \\FFI\\CData|null\n</code></pre> Parameters conf <code>\\FFI\\CData|null</code> const rd_kafka_topic_conf_t* Returns <code>\\FFI\\CData|null</code> rd_kafka_topic_conf_t*"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_default_topic_conf_dup","title":"rd_kafka_default_topic_conf_dup()","text":"<pre><code>public static rd_kafka_default_topic_conf_dup ( \n    \\FFI\\CData|null $rk\n ): \\FFI\\CData|null\n</code></pre> Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* Returns <code>\\FFI\\CData|null</code> rd_kafka_topic_conf_t*"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_topic_conf_destroy","title":"rd_kafka_topic_conf_destroy()","text":"<pre><code>public static rd_kafka_topic_conf_destroy ( \n    \\FFI\\CData|null $topic_conf\n ): void\n</code></pre> Parameters topic_conf <code>\\FFI\\CData|null</code> rd_kafka_topic_conf_t*"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_topic_conf_set","title":"rd_kafka_topic_conf_set()","text":"<pre><code>public static rd_kafka_topic_conf_set ( \n    \\FFI\\CData|null $conf, \n    string|null $name, \n    string|null $value, \n    \\FFI\\CData|null $errstr, \n    int|null $errstr_size\n ): int\n</code></pre> <p>Sets a single rd_kafka_topic_conf_t value by property name. </p> <p><code>topic_conf</code> should have been previously set up with <code>rd_kafka_topic_conf_new()</code>.</p> Parameters conf <code>\\FFI\\CData|null</code> rd_kafka_topic_conf_t* name <code>string|null</code> const char* value <code>string|null</code> const char* errstr <code>\\FFI\\CData|null</code> char* errstr_size <code>int|null</code> size_t Returns <code>int</code> rd_kafka_conf_res_t - rd_kafka_conf_res_t to indicate success or failure. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ac91b47f7733b324bf4159427e90ccd01 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_topic_conf_set_opaque","title":"rd_kafka_topic_conf_set_opaque()","text":"<pre><code>public static rd_kafka_topic_conf_set_opaque ( \n    \\FFI\\CData|null $conf, \n    \\FFI\\CData|object|string|null $opaque\n ): void\n</code></pre> <p>Sets the application's opaque pointer that will be passed to all topic callbacks as the <code>rkt_opaque</code> argument. </p> See alsord_kafka_topic_opaque()  Parameters conf <code>\\FFI\\CData|null</code> rd_kafka_topic_conf_t* opaque <code>\\FFI\\CData|object|string|null</code> void* <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a227d943335cad18b55f8cf8024ba9943 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_topic_conf_set_partitioner_cb","title":"rd_kafka_topic_conf_set_partitioner_cb()","text":"<pre><code>public static rd_kafka_topic_conf_set_partitioner_cb ( \n    \\FFI\\CData|null $topic_conf, \n    \\FFI\\CData|\\Closure $partitioner\n ): void\n</code></pre> <p>Producer: Set partitioner callback in provided topic conf object. </p> <p>The partitioner may be called in any thread at any time, it may be called multiple times for the same message/key.</p> <p>The callback's <code>rkt_opaque</code> argument is the opaque set by rd_kafka_topic_conf_set_opaque(). The callback's <code>msg_opaque</code> argument is the per-message opaque passed to produce().</p> <p>Partitioner function constraints:</p> <ul> <li>MUST NOT call any rd_kafka_*() functions except: rd_kafka_topic_partition_available()</li> <li>MUST NOT block or execute for prolonged periods of time.</li> <li>MUST return a value between 0 and partition_cnt-1, or the special <code>RD_KAFKA_PARTITION_UA</code> value if partitioning could not be performed. </li> </ul> Parameters topic_conf <code>\\FFI\\CData|null</code> rd_kafka_topic_conf_t* partitioner <code>\\FFI\\CData|\\Closure</code> int32_t()(const rd_kafka_topic_t, const void*, size_t, int32_t, void*, void*) <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#abfc790b5e36c56ea6d79fdc32c57becf </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_topic_conf_set_msg_order_cmp","title":"rd_kafka_topic_conf_set_msg_order_cmp()","text":"<pre><code>public static rd_kafka_topic_conf_set_msg_order_cmp ( \n    \\FFI\\CData|null $topic_conf, \n    \\FFI\\CData|\\Closure $msg_order_cmp\n ): void\n</code></pre> <p>Producer: Set message queueing order comparator callback. </p> <p>The callback may be called in any thread at any time, it may be called multiple times for the same message.</p> <p>Ordering comparator function constraints:</p> <ul> <li>MUST be stable sort (same input gives same output).</li> <li>MUST NOT call any rd_kafka_*() functions.</li> <li>MUST NOT block or execute for prolonged periods of time.</li> </ul> <p>The comparator shall compare the two messages and return:</p> <ul> <li>&lt; 0 if message <code>a</code> should be inserted before message <code>b</code>.</li> <li>&gt;=0 if message <code>a</code> should be inserted after message <code>b</code>.</li> </ul> RemarksInsert sorting will be used to enqueue the message in the correct queue position, this comes at a cost of O(n).  If <code>queuing.strategy=fifo</code> new messages are enqueued to the tail of the queue regardless of msg_order_cmp, but retried messages are still affected by msg_order_cmp. WarningTHIS IS AN EXPERIMENTAL API, SUBJECT TO CHANGE OR REMOVAL, DO NOT USE IN PRODUCTION.  Parameters topic_conf <code>\\FFI\\CData|null</code> rd_kafka_topic_conf_t* msg_order_cmp <code>\\FFI\\CData|\\Closure</code> int()(const rd_kafka_message_t, const rd_kafka_message_t*) <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a760cee234c441d32f9421874a74e06d4 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_topic_partition_available","title":"rd_kafka_topic_partition_available()","text":"<pre><code>public static rd_kafka_topic_partition_available ( \n    \\FFI\\CData|null $rkt, \n    int|null $partition\n ): int|null\n</code></pre> <p>Check if partition is available (has a leader broker). </p> WarningThis function must only be called from inside a partitioner function  Parameters rkt <code>\\FFI\\CData|null</code> const rd_kafka_topic_t* partition <code>int|null</code> int32_t Returns <code>int|null</code> int - 1 if the partition is available, else 0. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ad24c6cc7f37271e292f8105c64d77758 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_msg_partitioner_random","title":"rd_kafka_msg_partitioner_random()","text":"<pre><code>public static rd_kafka_msg_partitioner_random ( \n    \\FFI\\CData|null $rkt, \n    \\FFI\\CData|object|string|null $key, \n    int|null $keylen, \n    int|null $partition_cnt, \n    \\FFI\\CData|object|string|null $opaque, \n    \\FFI\\CData|object|string|null $msg_opaque\n ): int|null\n</code></pre> <p>Random partitioner. </p> <p>Will try not to return unavailable partitions.</p> <p>The <code>rkt_opaque</code> argument is the opaque set by rd_kafka_topic_conf_set_opaque(). The <code>msg_opaque</code> argument is the per-message opaque passed to produce().</p> Parameters rkt <code>\\FFI\\CData|null</code> const rd_kafka_topic_t* key <code>\\FFI\\CData|object|string|null</code> const void* keylen <code>int|null</code> size_t partition_cnt <code>int|null</code> int32_t opaque <code>\\FFI\\CData|object|string|null</code> void* msg_opaque <code>\\FFI\\CData|object|string|null</code> void* Returns <code>int|null</code> int32_t - a random partition between 0 and <code>partition_cnt</code> - 1. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a58ba8a3d1b491ecc32fe29e56d4142aa </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_msg_partitioner_consistent","title":"rd_kafka_msg_partitioner_consistent()","text":"<pre><code>public static rd_kafka_msg_partitioner_consistent ( \n    \\FFI\\CData|null $rkt, \n    \\FFI\\CData|object|string|null $key, \n    int|null $keylen, \n    int|null $partition_cnt, \n    \\FFI\\CData|object|string|null $opaque, \n    \\FFI\\CData|object|string|null $msg_opaque\n ): int|null\n</code></pre> <p>Consistent partitioner. </p> <p>Uses consistent hashing to map identical keys onto identical partitions.</p> <p>The <code>rkt_opaque</code> argument is the opaque set by rd_kafka_topic_conf_set_opaque(). The <code>msg_opaque</code> argument is the per-message opaque passed to produce().</p> Parameters rkt <code>\\FFI\\CData|null</code> const rd_kafka_topic_t* key <code>\\FFI\\CData|object|string|null</code> const void* keylen <code>int|null</code> size_t partition_cnt <code>int|null</code> int32_t opaque <code>\\FFI\\CData|object|string|null</code> void* msg_opaque <code>\\FFI\\CData|object|string|null</code> void* Returns <code>int|null</code> int32_t - a \u201crandom\u201d partition between 0 and <code>partition_cnt</code> - 1 based on the CRC value of the key <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aac74a45b5ce46035782198f683b22363 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_msg_partitioner_consistent_random","title":"rd_kafka_msg_partitioner_consistent_random()","text":"<pre><code>public static rd_kafka_msg_partitioner_consistent_random ( \n    \\FFI\\CData|null $rkt, \n    \\FFI\\CData|object|string|null $key, \n    int|null $keylen, \n    int|null $partition_cnt, \n    \\FFI\\CData|object|string|null $opaque, \n    \\FFI\\CData|object|string|null $msg_opaque\n ): int|null\n</code></pre> <p>Consistent-Random partitioner. </p> <p>This is the default partitioner. Uses consistent hashing to map identical keys onto identical partitions, and messages without keys will be assigned via the random partitioner.</p> <p>The <code>rkt_opaque</code> argument is the opaque set by rd_kafka_topic_conf_set_opaque(). The <code>msg_opaque</code> argument is the per-message opaque passed to produce().</p> Parameters rkt <code>\\FFI\\CData|null</code> const rd_kafka_topic_t* key <code>\\FFI\\CData|object|string|null</code> const void* keylen <code>int|null</code> size_t partition_cnt <code>int|null</code> int32_t opaque <code>\\FFI\\CData|object|string|null</code> void* msg_opaque <code>\\FFI\\CData|object|string|null</code> void* Returns <code>int|null</code> int32_t - a \u201crandom\u201d partition between 0 and <code>partition_cnt</code> - 1 based on the CRC value of the key (if provided) <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aed746103dc635aa591658f98a1707e57 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_msg_partitioner_murmur2","title":"rd_kafka_msg_partitioner_murmur2()","text":"<pre><code>public static rd_kafka_msg_partitioner_murmur2 ( \n    \\FFI\\CData|null $rkt, \n    \\FFI\\CData|object|string|null $key, \n    int|null $keylen, \n    int|null $partition_cnt, \n    \\FFI\\CData|object|string|null $rkt_opaque, \n    \\FFI\\CData|object|string|null $msg_opaque\n ): int|null\n</code></pre> <p>Murmur2 partitioner (Java compatible). </p> <p>Uses consistent hashing to map identical keys onto identical partitions using Java-compatible Murmur2 hashing.</p> <p>The <code>rkt_opaque</code> argument is the opaque set by rd_kafka_topic_conf_set_opaque(). The <code>msg_opaque</code> argument is the per-message opaque passed to produce().</p> Parameters rkt <code>\\FFI\\CData|null</code> const rd_kafka_topic_t* key <code>\\FFI\\CData|object|string|null</code> const void* keylen <code>int|null</code> size_t partition_cnt <code>int|null</code> int32_t rkt_opaque <code>\\FFI\\CData|object|string|null</code> void* msg_opaque <code>\\FFI\\CData|object|string|null</code> void* Returns <code>int|null</code> int32_t - a partition between 0 and <code>partition_cnt</code> - 1. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a009f294dc88a214850760216d3fe2d5f </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_msg_partitioner_murmur2_random","title":"rd_kafka_msg_partitioner_murmur2_random()","text":"<pre><code>public static rd_kafka_msg_partitioner_murmur2_random ( \n    \\FFI\\CData|null $rkt, \n    \\FFI\\CData|object|string|null $key, \n    int|null $keylen, \n    int|null $partition_cnt, \n    \\FFI\\CData|object|string|null $rkt_opaque, \n    \\FFI\\CData|object|string|null $msg_opaque\n ): int|null\n</code></pre> <p>Consistent-Random Murmur2 partitioner (Java compatible). </p> <p>Uses consistent hashing to map identical keys onto identical partitions using Java-compatible Murmur2 hashing. Messages without keys will be assigned via the random partitioner.</p> <p>The <code>rkt_opaque</code> argument is the opaque set by rd_kafka_topic_conf_set_opaque(). The <code>msg_opaque</code> argument is the per-message opaque passed to produce().</p> Parameters rkt <code>\\FFI\\CData|null</code> const rd_kafka_topic_t* key <code>\\FFI\\CData|object|string|null</code> const void* keylen <code>int|null</code> size_t partition_cnt <code>int|null</code> int32_t rkt_opaque <code>\\FFI\\CData|object|string|null</code> void* msg_opaque <code>\\FFI\\CData|object|string|null</code> void* Returns <code>int|null</code> int32_t - a partition between 0 and <code>partition_cnt</code> - 1. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ab5dab15f3d0a293db43338f17544e26a </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_new","title":"rd_kafka_new()","text":"<pre><code>public static rd_kafka_new ( \n    int $type, \n    \\FFI\\CData|null $conf, \n    \\FFI\\CData|null $errstr, \n    int|null $errstr_size\n ): \\FFI\\CData|null\n</code></pre> <p>Creates a new Kafka handle and starts its operation according to the specified <code>type</code> (<code>RD_KAFKA_CONSUMER</code> or <code>RD_KAFKA_PRODUCER</code>). </p> <p><code>conf</code> is an optional struct created with <code>rd_kafka_conf_new()</code> that will be used instead of the default configuration. The <code>conf</code> object is freed by this function on success and must not be used or destroyed by the application subsequently. See <code>rd_kafka_conf_set()</code> et.al for more information.</p> <p><code>errstr</code> must be a pointer to memory of at least size <code>errstr_size</code> where <code>rd_kafka_new()</code> may write a human readable error message in case the creation of a new handle fails. In which case the function returns NULL.</p> RemarksRD_KAFKA_CONSUMER: When a new <code>RD_KAFKA_CONSUMER</code> rd_kafka_t handle is created it may either operate in the legacy simple consumer mode using the rd_kafka_consume_start() interface, or the High-level KafkaConsumer API.   An application must only use one of these groups of APIs on a given rd_kafka_t RD_KAFKA_CONSUMER handle. See alsoTo destroy the Kafka handle, use rd_kafka_destroy().  Parameters type <code>int</code> rd_kafka_type_t conf <code>\\FFI\\CData|null</code> rd_kafka_conf_t* errstr <code>\\FFI\\CData|null</code> char* errstr_size <code>int|null</code> size_t Returns <code>\\FFI\\CData|null</code> rd_kafka_t* - The Kafka handle on success or NULL on error (see <code>errstr</code>) <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a63d5cd86ab1f77772b2be170e1c09c24 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_destroy","title":"rd_kafka_destroy()","text":"<pre><code>public static rd_kafka_destroy ( \n    \\FFI\\CData|null $rk\n ): void\n</code></pre> <p>Destroy Kafka handle. </p> RemarksThis is a blocking operation.   rd_kafka_consumer_close() will be called from this function if the instance type is RD_KAFKA_CONSUMER, a <code>group.id</code> was configured, and the rd_kafka_consumer_close() was not explicitly called by the application. This in turn may trigger consumer callbacks, such as rebalance_cb. Use rd_kafka_destroy_flags() with RD_KAFKA_DESTROY_F_NO_CONSUMER_CLOSE to avoid this behaviour. See alsord_kafka_destroy_flags()  Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* - ) <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ac052e92621dcaa3a336dbf826e0d7794 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_destroy_flags","title":"rd_kafka_destroy_flags()","text":"<pre><code>public static rd_kafka_destroy_flags ( \n    \\FFI\\CData|null $rk, \n    int|null $flags\n ): void\n</code></pre> Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* flags <code>int|null</code> int"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_name","title":"rd_kafka_name()","text":"<pre><code>public static rd_kafka_name ( \n    \\FFI\\CData|null $rk\n ): string|null\n</code></pre> Parameters rk <code>\\FFI\\CData|null</code> const rd_kafka_t* Returns <code>string|null</code> const char*"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_type","title":"rd_kafka_type()","text":"<pre><code>public static rd_kafka_type ( \n    \\FFI\\CData|null $rk\n ): int\n</code></pre> Parameters rk <code>\\FFI\\CData|null</code> const rd_kafka_t* Returns <code>int</code> rd_kafka_type_t"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_memberid","title":"rd_kafka_memberid()","text":"<pre><code>public static rd_kafka_memberid ( \n    \\FFI\\CData|null $rk\n ): \\FFI\\CData|null\n</code></pre> <p>Returns this client's broker-assigned group member id. </p> RemarksThis currently requires the high-level KafkaConsumer Parameters rk <code>\\FFI\\CData|null</code> const rd_kafka_t* - ) Returns <code>\\FFI\\CData|null</code> char* - An allocated string containing the current broker-assigned group member id, or NULL if not available. The application must free the string with <code>free()</code> or rd_kafka_mem_free() <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a856d7ecba1aa64e5c89ac92b445cdda6 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_clusterid","title":"rd_kafka_clusterid()","text":"<pre><code>public static rd_kafka_clusterid ( \n    \\FFI\\CData|null $rk, \n    int|null $timeout_ms\n ): \\FFI\\CData|null\n</code></pre> <p>Returns the ClusterId as reported in broker metadata. </p> RemarksRequires broker version &gt;=0.10.0 and api.version.request=true.  The application must free the returned pointer using rd_kafka_mem_free(). Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* - Client instance. timeout_ms <code>int|null</code> int - If there is no cached value from metadata retrieval then this specifies the maximum amount of time (in milliseconds) the call will block waiting for metadata to be retrieved. Use 0 for non-blocking calls. Returns <code>\\FFI\\CData|null</code> char* - a newly allocated string containing the ClusterId, or NULL if no ClusterId could be retrieved in the allotted timespan. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a261ba8c649756fbc7fbcd442ae481a18 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_controllerid","title":"rd_kafka_controllerid()","text":"<pre><code>public static rd_kafka_controllerid ( \n    \\FFI\\CData|null $rk, \n    int|null $timeout_ms\n ): int|null\n</code></pre> <p>Returns the current ControllerId as reported in broker metadata. </p> RemarksRequires broker version &gt;=0.10.0 and api.version.request=true. Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* - Client instance. timeout_ms <code>int|null</code> int - If there is no cached value from metadata retrieval then this specifies the maximum amount of time (in milliseconds) the call will block waiting for metadata to be retrieved. Use 0 for non-blocking calls. Returns <code>int|null</code> int32_t - the controller broker id (&gt;= 0), or -1 if no ControllerId could be retrieved in the allotted timespan. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#abcf5d443b9af5e6ac252dae1c94ea68f </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_topic_new","title":"rd_kafka_topic_new()","text":"<pre><code>public static rd_kafka_topic_new ( \n    \\FFI\\CData|null $rk, \n    string|null $topic, \n    \\FFI\\CData|null $conf\n ): \\FFI\\CData|null\n</code></pre> <p>Creates a new topic handle for topic named <code>topic</code>. </p> <p><code>conf</code> is an optional configuration for the topic created with <code>rd_kafka_topic_conf_new()</code> that will be used instead of the default topic configuration. The <code>conf</code> object is freed by this function and must not be used or destroyed by the application subsequently. See <code>rd_kafka_topic_conf_set()</code> et.al for more information.</p> <p>Topic handles are refcounted internally and calling rd_kafka_topic_new() again with the same topic name will return the previous topic handle without updating the original handle's configuration. Applications must eventually call rd_kafka_topic_destroy() for each succesfull call to rd_kafka_topic_new() to clear up resources.</p> See alsord_kafka_topic_destroy()  Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* topic <code>string|null</code> const char* conf <code>\\FFI\\CData|null</code> rd_kafka_topic_conf_t* Returns <code>\\FFI\\CData|null</code> rd_kafka_topic_t* - the new topic handle or NULL on error (use rd_kafka_errno2err() to convert system <code>errno</code> to an rd_kafka_resp_err_t error code. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ab1dcba74a35e8f3bfe3270ff600581d8 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_topic_destroy","title":"rd_kafka_topic_destroy()","text":"<pre><code>public static rd_kafka_topic_destroy ( \n    \\FFI\\CData|null $rkt\n ): void\n</code></pre> <p>Loose application's topic handle refcount as previously created with <code>rd_kafka_topic_new()</code>. </p> RemarksSince topic objects are refcounted (both internally and for the app) the topic object might not actually be destroyed by this call, but the application must consider the object destroyed.  Parameters rkt <code>\\FFI\\CData|null</code> rd_kafka_topic_t* - ) <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a91f46cd29d4f9abacd3ee3633c01d8ff </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_topic_name","title":"rd_kafka_topic_name()","text":"<pre><code>public static rd_kafka_topic_name ( \n    \\FFI\\CData|null $rkt\n ): string|null\n</code></pre> Parameters rkt <code>\\FFI\\CData|null</code> const rd_kafka_topic_t* Returns <code>string|null</code> const char*"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_topic_opaque","title":"rd_kafka_topic_opaque()","text":"<pre><code>public static rd_kafka_topic_opaque ( \n    \\FFI\\CData|null $rkt\n ): \\FFI\\CData|object|string|null\n</code></pre> Parameters rkt <code>\\FFI\\CData|null</code> const rd_kafka_topic_t* Returns <code>\\FFI\\CData|object|string|null</code> void*"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_poll","title":"rd_kafka_poll()","text":"<pre><code>public static rd_kafka_poll ( \n    \\FFI\\CData|null $rk, \n    int|null $timeout_ms\n ): int|null\n</code></pre> <p>Polls the provided kafka handle for events. </p> <p>Events will cause application-provided callbacks to be called.</p> <p>The <code>timeout_ms</code> argument specifies the maximum amount of time (in milliseconds) that the call will block waiting for events. For non-blocking calls, provide 0 as <code>timeout_ms</code>. To wait indefinitely for an event, provide -1.</p> RemarksAn application should make sure to call poll() at regular intervals to serve any queued callbacks waiting to be called.   If your producer doesn't have any callback set (in particular via rd_kafka_conf_set_dr_msg_cb or rd_kafka_conf_set_error_cb) you might choose not to call poll(), though this is not recommended. <p>Events:</p> <ul> <li>delivery report callbacks (if dr_cb/dr_msg_cb is configured) [producer]</li> <li>error callbacks (rd_kafka_conf_set_error_cb()) [all]</li> <li>stats callbacks (rd_kafka_conf_set_stats_cb()) [all]</li> <li>throttle callbacks (rd_kafka_conf_set_throttle_cb()) [all]</li> <li>OAUTHBEARER token refresh callbacks (rd_kafka_conf_set_oauthbearer_token_refresh_cb()) [all]</li> </ul> Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* timeout_ms <code>int|null</code> int Returns <code>int|null</code> int - the number of events served. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ad50c431e3a29d14da534db49bd0682a4 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_yield","title":"rd_kafka_yield()","text":"<pre><code>public static rd_kafka_yield ( \n    \\FFI\\CData|null $rk\n ): void\n</code></pre> <p>Cancels the current callback dispatcher (rd_kafka_poll(), rd_kafka_consume_callback(), etc). </p> <p>A callback may use this to force an immediate return to the calling code (caller of e.g. rd_kafka_poll()) without processing any further events.</p> RemarksThis function MUST ONLY be called from within a librdkafka callback.  Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* - ) <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a111628df6c84716c4b550f8509ac6a6d </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_pause_partitions","title":"rd_kafka_pause_partitions()","text":"<pre><code>public static rd_kafka_pause_partitions ( \n    \\FFI\\CData|null $rk, \n    \\FFI\\CData|null $partitions\n ): int\n</code></pre> <p>Pause producing or consumption for the provided list of partitions. </p> <p>Success or error is returned per-partition <code>err</code> in the <code>partitions</code> list.</p> Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* partitions <code>\\FFI\\CData|null</code> rd_kafka_topic_partition_list_t* Returns <code>int</code> rd_kafka_resp_err_t - RD_KAFKA_RESP_ERR_NO_ERROR <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a293cb2aac290c157702d3b82f5c14fce </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_resume_partitions","title":"rd_kafka_resume_partitions()","text":"<pre><code>public static rd_kafka_resume_partitions ( \n    \\FFI\\CData|null $rk, \n    \\FFI\\CData|null $partitions\n ): int\n</code></pre> <p>Resume producing consumption for the provided list of partitions. </p> <p>Success or error is returned per-partition <code>err</code> in the <code>partitions</code> list.</p> Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* partitions <code>\\FFI\\CData|null</code> rd_kafka_topic_partition_list_t* Returns <code>int</code> rd_kafka_resp_err_t - RD_KAFKA_RESP_ERR_NO_ERROR <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ad05819f26887a916ad2047d96a7b4bf2 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_query_watermark_offsets","title":"rd_kafka_query_watermark_offsets()","text":"<pre><code>public static rd_kafka_query_watermark_offsets ( \n    \\FFI\\CData|null $rk, \n    string|null $topic, \n    int|null $partition, \n    \\FFI\\CData|null $low, \n    \\FFI\\CData|null $high, \n    int|null $timeout_ms\n ): int\n</code></pre> <p>Query broker for low (oldest/beginning) and high (newest/end) offsets for partition. </p> <p>Offsets are returned in <code>*low</code> and <code>*high</code> respectively.</p> Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* topic <code>string|null</code> const char* partition <code>int|null</code> int32_t low <code>\\FFI\\CData|null</code> int64_t* high <code>\\FFI\\CData|null</code> int64_t* timeout_ms <code>int|null</code> int Returns <code>int</code> rd_kafka_resp_err_t - RD_KAFKA_RESP_ERR_NO_ERROR on success or an error code on failure. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a4550ff7d014f08406666124573f70495 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_get_watermark_offsets","title":"rd_kafka_get_watermark_offsets()","text":"<pre><code>public static rd_kafka_get_watermark_offsets ( \n    \\FFI\\CData|null $rk, \n    string|null $topic, \n    int|null $partition, \n    \\FFI\\CData|null $low, \n    \\FFI\\CData|null $high\n ): int\n</code></pre> <p>Get last known low (oldest/beginning) and high (newest/end) offsets for partition. </p> <p>The low offset is updated periodically (if statistics.interval.ms is set) while the high offset is updated on each fetched message set from the broker.</p> <p>If there is no cached offset (either low or high, or both) then RD_KAFKA_OFFSET_INVALID will be returned for the respective offset.</p> <p>Offsets are returned in <code>*low</code> and <code>*high</code> respectively.</p> RemarksShall only be used with an active consumer instance.  Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* topic <code>string|null</code> const char* partition <code>int|null</code> int32_t low <code>\\FFI\\CData|null</code> int64_t* high <code>\\FFI\\CData|null</code> int64_t* Returns <code>int</code> rd_kafka_resp_err_t - RD_KAFKA_RESP_ERR_NO_ERROR on success or an error code on failure. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ad1d338cebde98a76050e61301f631d82 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_offsets_for_times","title":"rd_kafka_offsets_for_times()","text":"<pre><code>public static rd_kafka_offsets_for_times ( \n    \\FFI\\CData|null $rk, \n    \\FFI\\CData|null $offsets, \n    int|null $timeout_ms\n ): int\n</code></pre> <p>Look up the offsets for the given partitions by timestamp. </p> <p>The returned offset for each partition is the earliest offset whose timestamp is greater than or equal to the given timestamp in the corresponding partition.</p> <p>The timestamps to query are represented as <code>offset</code> in <code>offsets</code> on input, and <code>offset</code> will contain the offset on output.</p> <p>The function will block for at most <code>timeout_ms</code> milliseconds.</p> RemarksDuplicate Topic+Partitions are not supported.   Per-partition errors may be returned in <code>rd_kafka_topic_partition_t.err</code> Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* offsets <code>\\FFI\\CData|null</code> rd_kafka_topic_partition_list_t* timeout_ms <code>int|null</code> int Returns <code>int</code> rd_kafka_resp_err_t - RD_KAFKA_RESP_ERR_NO_ERROR if offsets were be queried (do note that per-partition errors might be set), RD_KAFKA_RESP_ERR__TIMED_OUT if not all offsets could be fetched within <code>timeout_ms</code>, RD_KAFKA_RESP_ERR__INVALID_ARG if the <code>offsets</code> list is empty, RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION if all partitions are unknown, RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE if unable to query leaders for the given partitions. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ae308aaf534807cfd4c71e423fc214929 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_mem_free","title":"rd_kafka_mem_free()","text":"<pre><code>public static rd_kafka_mem_free ( \n    \\FFI\\CData|null $rk, \n    \\FFI\\CData|object|string|null $ptr\n ): void\n</code></pre> <p>Free pointer returned by librdkafka. </p> <p>This is typically an abstraction for the free(3) call and makes sure the application can use the same memory allocator as librdkafka for freeing pointers returned by librdkafka.</p> <p>In standard setups it is usually not necessary to use this interface rather than the free(3) functione.</p> <p><code>rk</code> must be set for memory returned by APIs that take an <code>rk</code> argument, for other APIs pass NULL for <code>rk</code>.</p> Remarksrd_kafka_mem_free() must only be used for pointers returned by APIs that explicitly mention using this function for freeing.  Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* ptr <code>\\FFI\\CData|object|string|null</code> void* <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a50178b3d3266c9eeb0b5981377833572 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_queue_new","title":"rd_kafka_queue_new()","text":"<pre><code>public static rd_kafka_queue_new ( \n    \\FFI\\CData|null $rk\n ): \\FFI\\CData|null\n</code></pre> <p>Create a new message queue. </p> <p>See rd_kafka_consume_start_queue(), rd_kafka_consume_queue(), et.al. </p> Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* - ) Returns <code>\\FFI\\CData|null</code> rd_kafka_queue_t* <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a2b59178eb7e88d40510a89f3f2d98b44 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_queue_destroy","title":"rd_kafka_queue_destroy()","text":"<pre><code>public static rd_kafka_queue_destroy ( \n    \\FFI\\CData|null $rkqu\n ): void\n</code></pre> <p>Destroy a queue, purging all of its enqueued messages. </p> Parameters rkqu <code>\\FFI\\CData|null</code> rd_kafka_queue_t* - ) <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a9421b3d450f1489cf46f68d49c5ea61e </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_queue_get_main","title":"rd_kafka_queue_get_main()","text":"<pre><code>public static rd_kafka_queue_get_main ( \n    \\FFI\\CData|null $rk\n ): \\FFI\\CData|null\n</code></pre> <p>Use rd_kafka_queue_destroy() to loose the reference. </p> Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* - ) Returns <code>\\FFI\\CData|null</code> rd_kafka_queue_t* - a reference to the main librdkafka event queue. This is the queue served by rd_kafka_poll(). <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a7f3d675ee029a52bf85fb28f83c38863 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_queue_get_consumer","title":"rd_kafka_queue_get_consumer()","text":"<pre><code>public static rd_kafka_queue_get_consumer ( \n    \\FFI\\CData|null $rk\n ): \\FFI\\CData|null\n</code></pre> <p>Use rd_kafka_queue_destroy() to loose the reference.</p> Remarksrd_kafka_queue_destroy() MUST be called on this queue prior to calling rd_kafka_consumer_close().   Polling the returned queue counts as a consumer poll, and will reset the timer for max.poll.interval.ms. If this queue is forwarded to a \"destq\", polling destq also counts as a consumer poll (this works for any number of forwards). However, even if this queue is unforwarded or forwarded elsewhere, polling destq will continue to count as a consumer poll.  Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* - ) Returns <code>\\FFI\\CData|null</code> rd_kafka_queue_t* - a reference to the librdkafka consumer queue. This is the queue served by rd_kafka_consumer_poll(). <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#acacdb55ae7cb6abfbde89621e512b078 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_queue_get_partition","title":"rd_kafka_queue_get_partition()","text":"<pre><code>public static rd_kafka_queue_get_partition ( \n    \\FFI\\CData|null $rk, \n    string|null $topic, \n    int|null $partition\n ): \\FFI\\CData|null\n</code></pre> <p>Use rd_kafka_queue_destroy() to loose the reference.</p> Remarksrd_kafka_queue_destroy() MUST be called on this queue  This function only works on consumers.  Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* topic <code>string|null</code> const char* partition <code>int|null</code> int32_t Returns <code>\\FFI\\CData|null</code> rd_kafka_queue_t* - a reference to the partition\u2019s queue, or NULL if partition is invalid. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ad5319a26efb9f843c6029f7dd54b742d </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_queue_get_background","title":"rd_kafka_queue_get_background()","text":"<pre><code>public static rd_kafka_queue_get_background ( \n    \\FFI\\CData|null $rk\n ): \\FFI\\CData|null\n</code></pre> <p>The background thread queue provides the application with an automatically polled queue that triggers the event callback in a background thread, this background thread is completely managed by librdkafka.</p> <p>The background thread queue is automatically created if a generic event handler callback is configured with rd_kafka_conf_set_background_event_cb() or if rd_kafka_queue_get_background() is called.</p> <p>The background queue is polled and served by librdkafka and MUST NOT be polled, forwarded, or otherwise managed by the application, it may only be used as the destination queue passed to queue-enabled APIs, such as the Admin API.</p> <p>Use rd_kafka_queue_destroy() to loose the reference.</p> WarningThe background queue MUST NOT be read from (polled, consumed, etc), or forwarded from.  Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* - ) Returns <code>\\FFI\\CData|null</code> rd_kafka_queue_t* - a reference to the background thread queue, or NULL if the background queue is not enabled. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a2ba0f4fa322165d33d7cd240a1a90c83 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_queue_forward","title":"rd_kafka_queue_forward()","text":"<pre><code>public static rd_kafka_queue_forward ( \n    \\FFI\\CData|null $src, \n    \\FFI\\CData|null $dst\n ): void\n</code></pre> <p>Forward/re-route queue <code>src</code> to <code>dst</code>. If <code>dst</code> is <code>NULL</code> the forwarding is removed. </p> <p>The internal refcounts for both queues are increased.</p> RemarksRegardless of whether <code>dst</code> is NULL or not, after calling this function, <code>src</code> will not forward it's fetch queue to the consumer queue.  Parameters src <code>\\FFI\\CData|null</code> rd_kafka_queue_t* dst <code>\\FFI\\CData|null</code> rd_kafka_queue_t* <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a5e2e5571d14636d289f963a270b8e338 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_set_log_queue","title":"rd_kafka_set_log_queue()","text":"<pre><code>public static rd_kafka_set_log_queue ( \n    \\FFI\\CData|null $rk, \n    \\FFI\\CData|null $rkqu\n ): int\n</code></pre> <p>Forward librdkafka logs (and debug) to the specified queue for serving with one of the ..poll() calls. </p> <p>This allows an application to serve log callbacks (<code>log_cb</code>) in its thread of choice.</p> RemarksThe configuration property <code>log.queue</code> MUST also be set to true.  librdkafka maintains its own reference to the provided queue. Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* - Client instance. rkqu <code>\\FFI\\CData|null</code> rd_kafka_queue_t* - Queue to forward logs to. If the value is NULL the logs are forwarded to the main queue. Returns <code>int</code> rd_kafka_resp_err_t - RD_KAFKA_RESP_ERR_NO_ERROR on success or an error code on error, eg RD_KAFKA_RESP_ERR__NOT_CONFIGURED when log.queue is not set to true. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a5c8a3be2f797560b2a39bf56dbd7622d </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_queue_length","title":"rd_kafka_queue_length()","text":"<pre><code>public static rd_kafka_queue_length ( \n    \\FFI\\CData|null $rkqu\n ): int|null\n</code></pre> Parameters rkqu <code>\\FFI\\CData|null</code> rd_kafka_queue_t* - ) Returns <code>int|null</code> size_t - the current number of elements in queue. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8f24368f4ff0e042907773f532f62e57 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_queue_io_event_enable","title":"rd_kafka_queue_io_event_enable()","text":"<pre><code>public static rd_kafka_queue_io_event_enable ( \n    \\FFI\\CData|null $rkqu, \n    int|null $fd, \n    \\FFI\\CData|object|string|null $payload, \n    int|null $size\n ): void\n</code></pre> <p>Enable IO event triggering for queue. </p> <p>To ease integration with IO based polling loops this API allows an application to create a separate file-descriptor that librdkafka will write <code>payload</code> (of size <code>size</code>) to whenever a new element is enqueued on a previously empty queue.</p> <p>To remove event triggering call with <code>fd</code> = -1.</p> <p>librdkafka will maintain a copy of the <code>payload</code>.</p> RemarksIO and callback event triggering are mutually exclusive.   When using forwarded queues the IO event must only be enabled on the final forwarded-to (destination) queue.   The file-descriptor/socket must be set to non-blocking.  Parameters rkqu <code>\\FFI\\CData|null</code> rd_kafka_queue_t* fd <code>int|null</code> int payload <code>\\FFI\\CData|object|string|null</code> const void* size <code>int|null</code> size_t <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#acbdd13ab480f6320b2842981eebce784 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_queue_cb_event_enable","title":"rd_kafka_queue_cb_event_enable()","text":"<pre><code>public static rd_kafka_queue_cb_event_enable ( \n    \\FFI\\CData|null $rkqu, \n    \\FFI\\CData|\\Closure $event_cb, \n    \\FFI\\CData|object|string|null $opaque\n ): void\n</code></pre> <p>Enable callback event triggering for queue. </p> <p>The callback will be called from an internal librdkafka thread when a new element is enqueued on a previously empty queue.</p> <p>To remove event triggering call with <code>event_cb</code> = NULL.</p> <p>The <code>qev_opaque</code> is passed to the callback's <code>qev_opaque</code> argument.</p> RemarksIO and callback event triggering are mutually exclusive.   Since the callback may be triggered from internal librdkafka threads, the application must not perform any pro-longed work in the callback, or call any librdkafka APIs (for the same rd_kafka_t handle).  Parameters rkqu <code>\\FFI\\CData|null</code> rd_kafka_queue_t* event_cb <code>\\FFI\\CData|\\Closure</code> void()(rd_kafka_t, void*) opaque <code>\\FFI\\CData|object|string|null</code> void* <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a411b31dede8e2d1f6a921ae4fb98413a </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_consume_start","title":"rd_kafka_consume_start()","text":"<pre><code>public static rd_kafka_consume_start ( \n    \\FFI\\CData|null $rkt, \n    int|null $partition, \n    int|null $offset\n ): int|null\n</code></pre> <p>Start consuming messages for topic <code>rkt</code> and <code>partition</code> at offset <code>offset</code> which may either be an absolute <code></code>(0..N) or one of the logical offsets: </p> <ul> <li>RD_KAFKA_OFFSET_BEGINNING</li> <li>RD_KAFKA_OFFSET_END</li> <li>RD_KAFKA_OFFSET_STORED</li> <li>RD_KAFKA_OFFSET_TAIL</li> </ul> <p>rdkafka will attempt to keep <code>queued.min.messages</code> (config property) messages in the local queue by repeatedly fetching batches of messages from the broker until the threshold is reached.</p> <p>The application shall use one of the <code>rd_kafka_consume*()</code> functions to consume messages from the local queue, each kafka message being represented as a <code>rd_kafka_message_t *</code> object.</p> <p><code>rd_kafka_consume_start()</code> must not be called multiple times for the same topic and partition without stopping consumption first with <code>rd_kafka_consume_stop()</code>.</p> <p>Use <code>rd_kafka_errno2err()</code> to convert sytem <code>errno</code> to <code>rd_kafka_resp_err_t</code> </p> Parameters rkt <code>\\FFI\\CData|null</code> rd_kafka_topic_t* partition <code>int|null</code> int32_t offset <code>int|null</code> int64_t Returns <code>int|null</code> int - 0 on success or -1 on error in which case errno is set accordingly:<ul> <li>EBUSY - Conflicts with an existing or previous subscription (RD_KAFKA_RESP_ERR__CONFLICT)</li> <li>EINVAL - Invalid offset, or incomplete configuration (lacking group.id) (RD_KAFKA_RESP_ERR__INVALID_ARG)</li> <li>ESRCH - requested <code>partition</code> is invalid. (RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION)</li> <li>ENOENT - topic is unknown in the Kafka cluster. (RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC)</li> </ul> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ae21dcd2d8c6195baf7f9f4952d7e12d4 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_consume_start_queue","title":"rd_kafka_consume_start_queue()","text":"<pre><code>public static rd_kafka_consume_start_queue ( \n    \\FFI\\CData|null $rkt, \n    int|null $partition, \n    int|null $offset, \n    \\FFI\\CData|null $rkqu\n ): int|null\n</code></pre> <p>Same as rd_kafka_consume_start() but re-routes incoming messages to the provided queue <code>rkqu</code> (which must have been previously allocated with <code>rd_kafka_queue_new()</code>. </p> <p>The application must use one of the <code>rd_kafka_consume_*_queue()</code> functions to receive fetched messages.</p> <p><code>rd_kafka_consume_start_queue()</code> must not be called multiple times for the same topic and partition without stopping consumption first with <code>rd_kafka_consume_stop()</code>. <code>rd_kafka_consume_start()</code> and <code>rd_kafka_consume_start_queue()</code> must not be combined for the same topic and partition. </p> Parameters rkt <code>\\FFI\\CData|null</code> rd_kafka_topic_t* partition <code>int|null</code> int32_t offset <code>int|null</code> int64_t rkqu <code>\\FFI\\CData|null</code> rd_kafka_queue_t* Returns <code>int|null</code> int <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8e952d7961169471f69c7ddc87041258 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_consume_stop","title":"rd_kafka_consume_stop()","text":"<pre><code>public static rd_kafka_consume_stop ( \n    \\FFI\\CData|null $rkt, \n    int|null $partition\n ): int|null\n</code></pre> <p>Stop consuming messages for topic <code>rkt</code> and <code>partition</code>, purging all messages currently in the local queue. </p> <p>NOTE: To enforce synchronisation this call will block until the internal fetcher has terminated and offsets are committed to configured storage method.</p> <p>The application needs to be stop all consumers before calling <code>rd_kafka_destroy()</code> on the main object handle.</p> Parameters rkt <code>\\FFI\\CData|null</code> rd_kafka_topic_t* partition <code>int|null</code> int32_t Returns <code>int|null</code> int - 0 on success or -1 on error (see <code>errno</code>). <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#acf07475e5e85e63fc5321a1087288cd4 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_seek","title":"rd_kafka_seek()","text":"<pre><code>public static rd_kafka_seek ( \n    \\FFI\\CData|null $rkt, \n    int|null $partition, \n    int|null $offset, \n    int|null $timeout_ms\n ): int\n</code></pre> <p>Seek consumer for topic+partition to <code>offset</code> which is either an absolute or logical offset. </p> <p>If <code>timeout_ms</code> is specified (not 0) the seek call will wait this long for the consumer to update its fetcher state for the given partition with the new offset. This guarantees that no previously fetched messages for the old offset (or fetch position) will be passed to the application.</p> <p>If the timeout is reached the internal state will be unknown to the caller and this function returns <code>RD_KAFKA_RESP_ERR__TIMED_OUT</code>.</p> <p>If <code>timeout_ms</code> is 0 it will initiate the seek but return immediately without any error reporting (e.g., async).</p> <p>This call will purge all pre-fetched messages for the given partition, which may be up to <code>queued.max.message.kbytes</code> in size. Repeated use of seek may thus lead to increased network usage as messages are re-fetched from the broker.</p> RemarksSeek must only be performed for already assigned/consumed partitions, use rd_kafka_assign() (et.al) to set the initial starting offset for a new assignmenmt. Deprecated:Use rd_kafka_seek_partitions().  Parameters rkt <code>\\FFI\\CData|null</code> rd_kafka_topic_t* partition <code>int|null</code> int32_t offset <code>int|null</code> int64_t timeout_ms <code>int|null</code> int Returns <code>int</code> rd_kafka_resp_err_t - <code>RD_KAFKA_RESP_ERR__NO_ERROR</code> on success else an error code. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a6667b162931982e9827e3d86ad22ec7d </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_consume","title":"rd_kafka_consume()","text":"<pre><code>public static rd_kafka_consume ( \n    \\FFI\\CData|null $rkt, \n    int|null $partition, \n    int|null $timeout_ms\n ): \\FFI\\CData|null\n</code></pre> <p>Consume a single message from topic <code>rkt</code> and <code>partition</code>. </p> <p><code>timeout_ms</code> is maximum amount of time to wait for a message to be received. Consumer must have been previously started with <code>rd_kafka_consume_start()</code>.</p> <p>Errors (when returning NULL):</p> <ul> <li>ETIMEDOUT - <code>timeout_ms</code> was reached with no new messages fetched.</li> <li>ENOENT - <code>rkt</code> + <code>partition</code> is unknown. (no prior <code>rd_kafka_consume_start()</code> call)</li> </ul> <p>NOTE: The returned message's <code></code>..-&gt;err must be checked for errors. NOTE: <code></code>..-&gt;err <code>==</code> <code>RD_KAFKA_RESP_ERR__PARTITION_EOF</code> signals that the end of the partition has been reached, which should typically not be considered an error. The application should handle this case (e.g., ignore).</p> Remarkson_consume() interceptors may be called from this function prior to passing message to application.  Parameters rkt <code>\\FFI\\CData|null</code> rd_kafka_topic_t* partition <code>int|null</code> int32_t timeout_ms <code>int|null</code> int Returns <code>\\FFI\\CData|null</code> rd_kafka_message_t* - a message object on success or <code>NULL</code> on error. The message object must be destroyed with <code>rd_kafka_message_destroy()</code> when the application is done with it. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aa49d14e8b742365f9f25d35318ff0b7e </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_consume_batch","title":"rd_kafka_consume_batch()","text":"<pre><code>public static rd_kafka_consume_batch ( \n    \\FFI\\CData|null $rkt, \n    int|null $partition, \n    int|null $timeout_ms, \n    \\FFI\\CData|null $rkmessages, \n    int|null $rkmessages_size\n ): int|null\n</code></pre> <p>Consume up to <code>rkmessages_size</code> from topic <code>rkt</code> and <code>partition</code> putting a pointer to each message in the application provided array <code>rkmessages</code> (of size <code>rkmessages_size</code> entries). </p> <p><code>rd_kafka_consume_batch()</code> provides higher throughput performance than <code>rd_kafka_consume()</code>.</p> <p><code>timeout_ms</code> is the maximum amount of time to wait for all of <code>rkmessages_size</code> messages to be put into <code>rkmessages</code>. If no messages were available within the timeout period this function returns 0 and <code>rkmessages</code> remains untouched. This differs somewhat from <code>rd_kafka_consume()</code>.</p> <p>The message objects must be destroyed with <code>rd_kafka_message_destroy()</code> when the application is done with it.</p> See alsord_kafka_consume() Remarkson_consume() interceptors may be called from this function prior to passing message to application.  Parameters rkt <code>\\FFI\\CData|null</code> rd_kafka_topic_t* partition <code>int|null</code> int32_t timeout_ms <code>int|null</code> int rkmessages <code>\\FFI\\CData|null</code> rd_kafka_message_t** rkmessages_size <code>int|null</code> size_t Returns <code>int|null</code> ssize_t - the number of rkmessages added in <code>rkmessages</code>, or -1 on error (same error codes as for <code>rd_kafka_consume()</code>. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a53511739a2cf498b8d88287fef6873ce </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_consume_callback","title":"rd_kafka_consume_callback()","text":"<pre><code>public static rd_kafka_consume_callback ( \n    \\FFI\\CData|null $rkt, \n    int|null $partition, \n    int|null $timeout_ms, \n    \\FFI\\CData|\\Closure $consume_cb, \n    \\FFI\\CData|object|string|null $opaque\n ): int|null\n</code></pre> <p>Consumes messages from topic <code>rkt</code> and <code>partition</code>, calling the provided callback for each consumed messsage. </p> <p><code>rd_kafka_consume_callback()</code> provides higher throughput performance than both <code>rd_kafka_consume()</code> and <code>rd_kafka_consume_batch()</code>.</p> <p><code>timeout_ms</code> is the maximum amount of time to wait for one or more messages to arrive.</p> <p>The provided <code>consume_cb</code> function is called for each message, the application MUST NOT call <code>rd_kafka_message_destroy()</code> on the provided <code>rkmessage</code>.</p> <p>The <code>commit_opaque</code> argument is passed to the <code>consume_cb</code> as <code>commit_opaque</code>.</p> See alsord_kafka_consume() Remarkson_consume() interceptors may be called from this function prior to passing message to application.  This function will return early if a transaction control message is received, these messages are not exposed to the application but still enqueued on the consumer queue to make sure their offsets are stored. Deprecated:This API is deprecated and subject for future removal. There is no new callback-based consume interface, use the poll/queue based alternatives.  Parameters rkt <code>\\FFI\\CData|null</code> rd_kafka_topic_t* partition <code>int|null</code> int32_t timeout_ms <code>int|null</code> int consume_cb <code>\\FFI\\CData|\\Closure</code> void()(rd_kafka_message_t, void*) opaque <code>\\FFI\\CData|object|string|null</code> void* Returns <code>int|null</code> int - the number of messages processed or -1 on error. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a570e099baed990e9966e5e9a65eb7b00 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_consume_queue","title":"rd_kafka_consume_queue()","text":"<pre><code>public static rd_kafka_consume_queue ( \n    \\FFI\\CData|null $rkqu, \n    int|null $timeout_ms\n ): \\FFI\\CData|null\n</code></pre> <p>Consume from queue. </p> See alsord_kafka_consume()  Parameters rkqu <code>\\FFI\\CData|null</code> rd_kafka_queue_t* timeout_ms <code>int|null</code> int Returns <code>\\FFI\\CData|null</code> rd_kafka_message_t* <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8ff0b80fccb3a5bd31b1baaf20e4ca16 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_consume_batch_queue","title":"rd_kafka_consume_batch_queue()","text":"<pre><code>public static rd_kafka_consume_batch_queue ( \n    \\FFI\\CData|null $rkqu, \n    int|null $timeout_ms, \n    \\FFI\\CData|null $rkmessages, \n    int|null $rkmessages_size\n ): int|null\n</code></pre> <p>Consume batch of messages from queue. </p> See alsord_kafka_consume_batch()  Parameters rkqu <code>\\FFI\\CData|null</code> rd_kafka_queue_t* timeout_ms <code>int|null</code> int rkmessages <code>\\FFI\\CData|null</code> rd_kafka_message_t** rkmessages_size <code>int|null</code> size_t Returns <code>int|null</code> ssize_t <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a3d949238471993b18537855aad28fa23 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_consume_callback_queue","title":"rd_kafka_consume_callback_queue()","text":"<pre><code>public static rd_kafka_consume_callback_queue ( \n    \\FFI\\CData|null $rkqu, \n    int|null $timeout_ms, \n    \\FFI\\CData|\\Closure $consume_cb, \n    \\FFI\\CData|object|string|null $opaque\n ): int|null\n</code></pre> <p>Consume multiple messages from queue with callback. </p> See alsord_kafka_consume_callback() Deprecated:This API is deprecated and subject for future removal. There is no new callback-based consume interface, use the poll/queue based alternatives.  Parameters rkqu <code>\\FFI\\CData|null</code> rd_kafka_queue_t* timeout_ms <code>int|null</code> int consume_cb <code>\\FFI\\CData|\\Closure</code> void()(rd_kafka_message_t, void*) opaque <code>\\FFI\\CData|object|string|null</code> void* Returns <code>int|null</code> int <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a4632ec35e579f9051164f7171940c243 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_offset_store","title":"rd_kafka_offset_store()","text":"<pre><code>public static rd_kafka_offset_store ( \n    \\FFI\\CData|null $rkt, \n    int|null $partition, \n    int|null $offset\n ): int\n</code></pre> <p>Store offset <code>offset</code> + 1 for topic <code>rkt</code> partition <code>partition</code>. </p> <p>The <code>offset</code> + 1 will be committed (written) to broker (or file) according to <code><code>auto.commit.interval.ms</code></code> or manual offset-less commit()</p> Deprecated:This API lacks support for partition leader epochs, which makes it at risk for unclean leader election log truncation issues. Use rd_kafka_offsets_store() and rd_kafka_offset_store_message() instead. WarningThis method may only be called for partitions that are currently assigned. Non-assigned partitions will fail with RD_KAFKA_RESP_ERR__STATE. Since v1.9.0.  Avoid storing offsets after calling rd_kafka_seek() (et.al) as this may later interfere with resuming a paused partition, instead store offsets prior to calling seek. Remarks<code><code>enable.auto.offset.store</code></code> must be set to \"false\" when using this API. Parameters rkt <code>\\FFI\\CData|null</code> rd_kafka_topic_t* partition <code>int|null</code> int32_t offset <code>int|null</code> int64_t Returns <code>int</code> rd_kafka_resp_err_t - RD_KAFKA_RESP_ERR_NO_ERROR on success or an error code on error. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a784186db1d2cb6ceebcd5606d38db4c4 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_offsets_store","title":"rd_kafka_offsets_store()","text":"<pre><code>public static rd_kafka_offsets_store ( \n    \\FFI\\CData|null $rk, \n    \\FFI\\CData|null $offsets\n ): int\n</code></pre> <p>Store offsets for next auto-commit for one or more partitions. </p> <p>The offset will be committed (written) to the offset store according to <code><code>auto.commit.interval.ms</code></code> or manual offset-less commit().</p> <p>Per-partition success/error status propagated through each partition's <code></code>.err for all return values (even NO_ERROR) except INVALID_ARG.</p> WarningThis method may only be called for partitions that are currently assigned. Non-assigned partitions will fail with RD_KAFKA_RESP_ERR__STATE. Since v1.9.0.  Avoid storing offsets after calling rd_kafka_seek() (et.al) as this may later interfere with resuming a paused partition, instead store offsets prior to calling seek. RemarksThe <code></code>.offset field is stored as is, it will NOT be + 1. <code><code>enable.auto.offset.store</code></code> must be set to \"false\" when using this API.  The leader epoch, if set, will be used to fence outdated partition leaders. See rd_kafka_topic_partition_set_leader_epoch(). Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* offsets <code>\\FFI\\CData|null</code> rd_kafka_topic_partition_list_t* Returns <code>int</code> rd_kafka_resp_err_t - RD_KAFKA_RESP_ERR_NO_ERROR on (partial) success, or RD_KAFKA_RESP_ERR__INVALID_ARG if <code>enable.auto.offset.store</code> is true, or RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION or RD_KAFKA_RESP_ERR__STATE if none of the offsets could be stored. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a047b1e21236fba30898c7c563c2c6777 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_subscribe","title":"rd_kafka_subscribe()","text":"<pre><code>public static rd_kafka_subscribe ( \n    \\FFI\\CData|null $rk, \n    \\FFI\\CData|null $topics\n ): int\n</code></pre> <p>Subscribe to topic set using balanced consumer groups. </p> <p>Wildcard (regex) topics are supported: any topic name in the <code>topics</code> list that is prefixed with <code>\"^\"</code> will be regex-matched to the full list of topics in the cluster and matching topics will be added to the subscription list.</p> <p>The full topic list is retrieved every <code>topic.metadata.refresh.interval.ms</code> to pick up new or delete topics that match the subscription. If there is any change to the matched topics the consumer will immediately rejoin the group with the updated set of subscribed topics.</p> <p>Regex and full topic names can be mixed in <code>topics</code>.</p> RemarksOnly the <code></code>.topic field is used in the supplied <code>topics</code> list, all other fields are ignored.  subscribe() is an asynchronous method which returns immediately: background threads will (re)join the group, wait for group rebalance, issue any registered rebalance_cb, assign() the assigned partitions, and then start fetching messages. This cycle may take up to <code>session.timeout.ms</code> * 2 or more to complete.  After this call returns a consumer error will be returned by rd_kafka_consumer_poll (et.al) for each unavailable topic in the <code>topics</code>. The error will be RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART for non-existent topics, and RD_KAFKA_RESP_ERR_TOPIC_AUTHORIZATION_FAILED for unauthorized topics. The consumer error will be raised through rd_kafka_consumer_poll() (et.al.) with the <code>rd_kafka_message_t.err</code> field set to one of the error codes mentioned above. The subscribe function itself is asynchronous and will not return an error on unavailable topics. Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* topics <code>\\FFI\\CData|null</code> const rd_kafka_topic_partition_list_t* Returns <code>int</code> rd_kafka_resp_err_t - RD_KAFKA_RESP_ERR_NO_ERROR on success or RD_KAFKA_RESP_ERR__INVALID_ARG if list is empty, contains invalid topics or regexes or duplicate entries, RD_KAFKA_RESP_ERR__FATAL if the consumer has raised a fatal error. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a0ebe15e9d0f39ccc84e9686f0fcf46f1 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_unsubscribe","title":"rd_kafka_unsubscribe()","text":"<pre><code>public static rd_kafka_unsubscribe ( \n    \\FFI\\CData|null $rk\n ): int\n</code></pre> Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* Returns <code>int</code> rd_kafka_resp_err_t"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_subscription","title":"rd_kafka_subscription()","text":"<pre><code>public static rd_kafka_subscription ( \n    \\FFI\\CData|null $rk, \n    \\FFI\\CData|null $topics\n ): int\n</code></pre> <p>Returns the current topic subscription. </p> RemarksThe application is responsible for calling rd_kafka_topic_partition_list_destroy on the returned list.  Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* topics <code>\\FFI\\CData|null</code> rd_kafka_topic_partition_list_t** Returns <code>int</code> rd_kafka_resp_err_t - An error code on failure, otherwise <code>topic</code> is updated to point to a newly allocated topic list (possibly empty). <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ab66a2c014db2e652aa12466b137a6200 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_consumer_poll","title":"rd_kafka_consumer_poll()","text":"<pre><code>public static rd_kafka_consumer_poll ( \n    \\FFI\\CData|null $rk, \n    int|null $timeout_ms\n ): \\FFI\\CData|null\n</code></pre> <p>Poll the consumer for messages or events. </p> <p>Will block for at most <code>timeout_ms</code> milliseconds.</p> RemarksAn application should make sure to call consumer_poll() at regular intervals, even if no messages are expected, to serve any queued callbacks waiting to be called. This is especially important when a rebalance_cb has been registered as it needs to be called and handled properly to synchronize internal consumer state. Remarkson_consume() interceptors may be called from this function prior to passing message to application.  When subscribing to topics the application must call poll at least every <code>max.poll.interval.ms</code> to remain a member of the consumer group. <p>Noteworthy errors returned in <code>-&gt;err:</code> </p> <ul> <li>RD_KAFKA_RESP_ERR__MAX_POLL_EXCEEDED - application failed to call poll within <code>max.poll.interval.ms</code>.</li> </ul> See alsord_kafka_message_t  Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* timeout_ms <code>int|null</code> int Returns <code>\\FFI\\CData|null</code> rd_kafka_message_t* - A message object which is a proper message if <code>-&gt;err</code> is RD_KAFKA_RESP_ERR_NO_ERROR, or an event or error for any other value. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a65cc6cb9bd72c4084f074af0361ceddf </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_consumer_close","title":"rd_kafka_consumer_close()","text":"<pre><code>public static rd_kafka_consumer_close ( \n    \\FFI\\CData|null $rk\n ): int\n</code></pre> <p>Close the consumer. </p> <p>This call will block until the consumer has revoked its assignment, calling the <code>rebalance_cb</code> if it is configured, committed offsets to broker, and left the consumer group (if applicable). The maximum blocking time is roughly limited to session.timeout.ms.</p> RemarksThe application still needs to call rd_kafka_destroy() after this call finishes to clean up the underlying handle resources.  Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* - ) Returns <code>int</code> rd_kafka_resp_err_t - An error code indicating if the consumer close was succesful or not. RD_KAFKA_RESP_ERR__FATAL is returned if the consumer has raised a fatal error. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a37b54d329e12d745889defe96e7d043d </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_assign","title":"rd_kafka_assign()","text":"<pre><code>public static rd_kafka_assign ( \n    \\FFI\\CData|null $rk, \n    \\FFI\\CData|null $partitions\n ): int\n</code></pre> <p>Atomic assignment of partitions to consume. </p> <p>The new <code>partitions</code> will replace the existing assignment.</p> <p>A zero-length <code>partitions</code> will treat the partitions as a valid, albeit empty assignment, and maintain internal state, while a <code>NULL</code> value for <code>partitions</code> will reset and clear the internal state.</p> <p>When used from a rebalance callback, the application should pass the partition list passed to the callback (or a copy of it) even if the list is empty (i.e. should not pass NULL in this case) so as to maintain internal join state. This is not strictly required - the application may adjust the assignment provided by the group. However, this is rarely useful in practice.</p> Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* partitions <code>\\FFI\\CData|null</code> const rd_kafka_topic_partition_list_t* Returns <code>int</code> rd_kafka_resp_err_t - An error code indicating if the new assignment was applied or not. RD_KAFKA_RESP_ERR__FATAL is returned if the consumer has raised a fatal error. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a0566419eff2001f8371e3b50aa7d26e9 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_assignment","title":"rd_kafka_assignment()","text":"<pre><code>public static rd_kafka_assignment ( \n    \\FFI\\CData|null $rk, \n    \\FFI\\CData|null $partitions\n ): int\n</code></pre> <p>Returns the current partition assignment as set by rd_kafka_assign() or rd_kafka_incremental_assign(). </p> RemarksThe application is responsible for calling rd_kafka_topic_partition_list_destroy on the returned list.  This assignment represents the partitions assigned through the assign functions and not the partitions assigned to this consumer instance by the consumer group leader. They are usually the same following a rebalance but not necessarily since an application is free to assign any partitions.  Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* partitions <code>\\FFI\\CData|null</code> rd_kafka_topic_partition_list_t** Returns <code>int</code> rd_kafka_resp_err_t - An error code on failure, otherwise <code>partitions</code> is updated to point to a newly allocated partition list (possibly empty). <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a10a00cc624a46209fe1192cfc56cce59 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_commit","title":"rd_kafka_commit()","text":"<pre><code>public static rd_kafka_commit ( \n    \\FFI\\CData|null $rk, \n    \\FFI\\CData|null $offsets, \n    int|null $async\n ): int\n</code></pre> <p>Commit offsets on broker for the provided list of partitions. </p> <p><code>offsets</code> should contain <code>topic</code>, <code>partition</code>, <code>offset</code> and possibly <code>metadata</code>. The <code>offset</code> should be the offset where consumption will resume, i.e., the last processed offset + 1. If <code>offsets</code> is NULL the current partition assignment will be used instead.</p> <p>If <code>async</code> is false this operation will block until the broker offset commit is done, returning the resulting success or error code.</p> <p>If a rd_kafka_conf_set_offset_commit_cb() offset commit callback has been configured the callback will be enqueued for a future call to rd_kafka_poll(), rd_kafka_consumer_poll() or similar.</p> <p>FIXME: Update below documentation.</p> <p>RD_KAFKA_RESP_ERR_STALE_MEMBER_EPOCH is returned, when using <code>group.protocol=consumer</code>, if the commit failed because the member has switched to a new member epoch. This error code can be retried. Partition level error is also set in the <code>offsets</code>.</p> <p>RD_KAFKA_RESP_ERR_UNKNOWN_MEMBER_ID is returned, when using <code>group.protocol=consumer</code>, if the member has been removed from the consumer group This error code is permanent, uncommitted messages will be reprocessed by this or a different member and committed there. Partition level error is also set in the <code>offsets</code>. </p> Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* offsets <code>\\FFI\\CData|null</code> const rd_kafka_topic_partition_list_t* async <code>int|null</code> int Returns <code>int</code> rd_kafka_resp_err_t - An error code indiciating if the commit was successful, or successfully scheduled if asynchronous, or failed. RD_KAFKA_RESP_ERR__FATAL is returned if the consumer has raised a fatal error. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ab96539928328f14c3c9177ea0c896c87 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_commit_message","title":"rd_kafka_commit_message()","text":"<pre><code>public static rd_kafka_commit_message ( \n    \\FFI\\CData|null $rk, \n    \\FFI\\CData|null $rkmessage, \n    int|null $async\n ): int\n</code></pre> <p>Commit message's offset on broker for the message's partition. The committed offset is the message's offset + 1. </p> See alsord_kafka_commit  Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* rkmessage <code>\\FFI\\CData|null</code> const rd_kafka_message_t* async <code>int|null</code> int Returns <code>int</code> rd_kafka_resp_err_t <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a99fb25d50216e4e20d303bf8a4a62883 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_commit_queue","title":"rd_kafka_commit_queue()","text":"<pre><code>public static rd_kafka_commit_queue ( \n    \\FFI\\CData|null $rk, \n    \\FFI\\CData|null $offsets, \n    \\FFI\\CData|null $rkqu, \n    \\FFI\\CData|\\Closure $cb, \n    \\FFI\\CData|object|string|null $opaque\n ): int\n</code></pre> <p>Commit offsets on broker for the provided list of partitions. </p> <p>See rd_kafka_commit for <code>offsets</code> semantics.</p> <p>The result of the offset commit will be posted on the provided <code>rkqu</code> queue.</p> <p>If the application uses one of the poll APIs (rd_kafka_poll(), rd_kafka_consumer_poll(), rd_kafka_queue_poll(), ..) to serve the queue the <code>cb</code> callback is required.</p> <p>The <code>commit_opaque</code> argument is passed to the callback as <code>commit_opaque</code>, or if using the event API the callback is ignored and the offset commit result will be returned as an RD_KAFKA_EVENT_COMMIT event and the <code>commit_opaque</code> value will be available with rd_kafka_event_opaque().</p> <p>If <code>rkqu</code> is NULL a temporary queue will be created and the callback will be served by this call.</p> See alsord_kafka_commit()   rd_kafka_conf_set_offset_commit_cb()  Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* offsets <code>\\FFI\\CData|null</code> const rd_kafka_topic_partition_list_t* rkqu <code>\\FFI\\CData|null</code> rd_kafka_queue_t* cb <code>\\FFI\\CData|\\Closure</code> void()(rd_kafka_t, rd_kafka_resp_err_t, rd_kafka_topic_partition_list_t*, void*) opaque <code>\\FFI\\CData|object|string|null</code> void* Returns <code>int</code> rd_kafka_resp_err_t <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#af76a6a73baa9c2621536e3f6882a3c1a </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_committed","title":"rd_kafka_committed()","text":"<pre><code>public static rd_kafka_committed ( \n    \\FFI\\CData|null $rk, \n    \\FFI\\CData|null $partitions, \n    int|null $timeout_ms\n ): int\n</code></pre> <p>Retrieve committed offsets for topics+partitions. </p> <p>The <code>offset</code> field of each requested partition will either be set to stored offset or to RD_KAFKA_OFFSET_INVALID in case there was no stored offset for that partition.</p> <p>Committed offsets will be returned according to the <code>isolation.level</code> configuration property, if set to <code>read_committed</code> (default) then only stable offsets for fully committed transactions will be returned, while <code>read_uncommitted</code> may return offsets for not yet committed transactions.</p> Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* partitions <code>\\FFI\\CData|null</code> rd_kafka_topic_partition_list_t* timeout_ms <code>int|null</code> int Returns <code>int</code> rd_kafka_resp_err_t - RD_KAFKA_RESP_ERR_NO_ERROR on success in which case the <code>offset</code> or <code>err</code> field of each <code>partitions\u2019</code> element is filled in with the stored offset, or a partition specific error. Else returns an error code. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a39846ae321a03c4679c9c659f18adf13 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_position","title":"rd_kafka_position()","text":"<pre><code>public static rd_kafka_position ( \n    \\FFI\\CData|null $rk, \n    \\FFI\\CData|null $partitions\n ): int\n</code></pre> <p>Retrieve current positions (offsets) for topics+partitions. </p> <p>The <code>offset</code> field of each requested partition will be set to the offset of the last consumed message + 1, or RD_KAFKA_OFFSET_INVALID in case there was no previous message.</p> RemarksIn this context the last consumed message is the offset consumed by the current librdkafka instance and, in case of rebalancing, not necessarily the last message fetched from the partition. Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* partitions <code>\\FFI\\CData|null</code> rd_kafka_topic_partition_list_t* Returns <code>int</code> rd_kafka_resp_err_t - RD_KAFKA_RESP_ERR_NO_ERROR on success in which case the <code>offset</code> or <code>err</code> field of each <code>partitions\u2019</code> element is filled in with the stored offset, or a partition specific error. Else returns an error code. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a6e9e36bd9e6bf84a9f3092fcbfa3a9ac </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_produce","title":"rd_kafka_produce()","text":"<pre><code>public static rd_kafka_produce ( \n    \\FFI\\CData|null $rkt, \n    int|null $partition, \n    int|null $msgflags, \n    \\FFI\\CData|object|string|null $payload, \n    int|null $len, \n    \\FFI\\CData|object|string|null $key, \n    int|null $keylen, \n    \\FFI\\CData|object|string|null $msg_opaque\n ): int|null\n</code></pre> <p>Produce and send a single message to broker. </p> <p><code>rkt</code> is the target topic which must have been previously created with <code>rd_kafka_topic_new()</code>.</p> <p><code>rd_kafka_produce()</code> is an asynchronous non-blocking API. See <code>rd_kafka_conf_set_dr_msg_cb</code> on how to setup a callback to be called once the delivery status (success or failure) is known. The delivery report is triggered by the application calling <code>rd_kafka_poll()</code> (at regular intervals) or <code>rd_kafka_flush()</code> (at termination).</p> <p>Since producing is asynchronous, you should call <code>rd_kafka_flush()</code> before you destroy the producer. Otherwise, any outstanding messages will be silently discarded.</p> <p>When temporary errors occur, librdkafka automatically retries to produce the messages. Retries are triggered after retry.backoff.ms and when the leader broker for the given partition is available. Otherwise, librdkafka falls back to polling the topic metadata to monitor when a new leader is elected (see the topic.metadata.refresh.fast.interval.ms and topic.metadata.refresh.interval.ms configurations) and then performs a retry. A delivery error will occur if the message could not be produced within message.timeout.ms.</p> <p>See the \"Message reliability\" chapter in INTRODUCTION.md for more information.</p> <p><code>partition</code> is the target partition, either:</p> <ul> <li>RD_KAFKA_PARTITION_UA (unassigned) for automatic partitioning using the topic's partitioner function, or</li> <li>a fixed partition (0..N)</li> </ul> <p><code>msgflags</code> is zero or more of the following flags OR:ed together: RD_KAFKA_MSG_F_BLOCK - block <code>produce*</code>() call if <code>queue.buffering.max.messages</code> or <code>queue.buffering.max.kbytes</code> are exceeded. Messages are considered in-queue from the point they are accepted by produce() until their corresponding delivery report callback/event returns. It is thus a requirement to call rd_kafka_poll() (or equiv.) from a separate thread when F_BLOCK is used. See WARNING on <code>RD_KAFKA_MSG_F_BLOCK</code> above.</p> <p>RD_KAFKA_MSG_F_FREE - rdkafka will free(3) <code>payload</code> when it is done with it. RD_KAFKA_MSG_F_COPY - the <code>payload</code> data will be copied and the <code>payload</code> pointer will not be used by rdkafka after the call returns. RD_KAFKA_MSG_F_PARTITION - produce_batch() will honour per-message partition, either set manually or by the configured partitioner.</p> <p>.._F_FREE and .._F_COPY are mutually exclusive. If neither of these are set, the caller must ensure that the memory backing <code>payload</code> remains valid and is not modified or reused until the delivery callback is invoked. Other buffers passed to <code>rd_kafka_produce()</code> don't have this restriction on reuse, i.e. the memory backing the key or the topic name may be reused as soon as <code>rd_kafka_produce()</code> returns.</p> <p>If the function returns -1 and RD_KAFKA_MSG_F_FREE was specified, then the memory associated with the payload is still the caller's responsibility.</p> <p><code>payload</code> is the message payload of size <code>len</code> bytes.</p> <p><code>key</code> is an optional message key of size <code>keylen</code> bytes, if non-NULL it will be passed to the topic partitioner as well as be sent with the message to the broker and passed on to the consumer.</p> <p><code>msg_opaque</code> is an optional application-provided per-message opaque pointer that will provided in the message's delivery report callback (<code>dr_msg_cb</code> or <code>dr_cb</code>) and the <code>rd_kafka_message_t</code> <code>_private</code> field.</p> Remarkson_send() and on_acknowledgement() interceptors may be called from this function. on_acknowledgement() will only be called if the message fails partitioning.  If the producer is transactional (<code>transactional.id</code> is configured) producing is only allowed during an on-going transaction, namely after rd_kafka_begin_transaction() has been called. See alsoUse rd_kafka_errno2err() to convert <code>errno</code> to rdkafka error code.  Parameters rkt <code>\\FFI\\CData|null</code> rd_kafka_topic_t* partition <code>int|null</code> int32_t msgflags <code>int|null</code> int payload <code>\\FFI\\CData|object|string|null</code> void* len <code>int|null</code> size_t key <code>\\FFI\\CData|object|string|null</code> const void* keylen <code>int|null</code> size_t msg_opaque <code>\\FFI\\CData|object|string|null</code> void* Returns <code>int|null</code> int - 0 on success or -1 on error in which case errno is set accordingly:<ul> <li>ENOBUFS - maximum number of outstanding messages has been reached: \"queue.buffering.max.messages\" (RD_KAFKA_RESP_ERR__QUEUE_FULL)</li> <li>EMSGSIZE - message is larger than configured max size: \"messages.max.bytes\". (RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE)</li> <li>ESRCH - requested <code>partition</code> is unknown in the Kafka cluster. (RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION)</li> <li>ENOENT - topic is unknown in the Kafka cluster. (RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC)</li> <li>ECANCELED - fatal error has been raised on producer, see rd_kafka_fatal_error(), (RD_KAFKA_RESP_ERR__FATAL).</li> <li>ENOEXEC - transactional state forbids producing (RD_KAFKA_RESP_ERR__STATE)</li> </ul> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ae24d8ebf1ea15ed8ea0ea40f74662736 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_producev","title":"rd_kafka_producev()","text":"<pre><code>public static rd_kafka_producev ( \n    \\FFI\\CData|null $rk, \n    mixed $args\n ): int\n</code></pre> <p>Produce and send a single message to broker. </p> <p>The message is defined by a va-arg list using <code>rd_kafka_vtype_t</code> tag tuples which must be terminated with a single <code>RD_KAFKA_V_END</code>.</p> See alsord_kafka_produce, rd_kafka_produceva, RD_KAFKA_V_END  Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* args <code>mixed</code> Returns <code>int</code> rd_kafka_resp_err_t - <code>RD_KAFKA_RESP_ERR_NO_ERROR</code> on success, else an error code as described in rd_kafka_produce(). <code>RD_KAFKA_RESP_ERR__CONFLICT</code> is returned if _V_HEADER and _V_HEADERS are mixed. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ac3a111ec3e6729609d498fec7b619efc </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_produce_batch","title":"rd_kafka_produce_batch()","text":"<pre><code>public static rd_kafka_produce_batch ( \n    \\FFI\\CData|null $rkt, \n    int|null $partition, \n    int|null $msgflags, \n    \\FFI\\CData|null $rkmessages, \n    int|null $message_cnt\n ): int|null\n</code></pre> <p>Produce multiple messages. </p> <p>If partition is RD_KAFKA_PARTITION_UA the configured partitioner will be run for each message (slower), otherwise the messages will be enqueued to the specified partition directly (faster).</p> <p>The messages are provided in the array <code>rkmessages</code> of count <code>message_cnt</code> elements. The <code>partition</code> and <code>msgflags</code> are used for all provided messages.</p> <p>Honoured <code>rkmessages</code>[] fields are:</p> <ul> <li>payload,len Message payload and length</li> <li>key,key_len Optional message key</li> <li>_private Message opaque pointer (msg_opaque)</li> <li>err Will be set according to success or failure, see rd_kafka_produce() for possible error codes. Application only needs to check for errors if return value != <code>message_cnt</code>.</li> </ul> RemarksIf <code>RD_KAFKA_MSG_F_PARTITION</code> is set in <code>msgflags</code>, the <code></code>.partition field of the <code>rkmessages</code> is used instead of <code>partition</code>. RemarksThis interface does NOT support setting message headers on the provided <code>rkmessages</code>.  Parameters rkt <code>\\FFI\\CData|null</code> rd_kafka_topic_t* partition <code>int|null</code> int32_t msgflags <code>int|null</code> int rkmessages <code>\\FFI\\CData|null</code> rd_kafka_message_t* message_cnt <code>int|null</code> int Returns <code>int|null</code> int - the number of messages succesfully enqueued for producing. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a7ad15c71f228c47946500a0e5c6f88ed </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_flush","title":"rd_kafka_flush()","text":"<pre><code>public static rd_kafka_flush ( \n    \\FFI\\CData|null $rk, \n    int|null $timeout_ms\n ): int\n</code></pre> <p>Wait until all outstanding produce requests, et.al, are completed. This should typically be done prior to destroying a producer instance to make sure all queued and in-flight produce requests are completed before terminating. </p> RemarksThis function will call rd_kafka_poll() and thus trigger callbacks.  The <code>linger.ms</code> time will be ignored for the duration of the call, queued messages will be sent to the broker as soon as possible.  If RD_KAFKA_EVENT_DR has been enabled (through rd_kafka_conf_set_events()) this function will not call rd_kafka_poll() but instead wait for the librdkafka-handled message count to reach zero. This requires the application to serve the event queue in a separate thread. In this mode only messages are counted, not other types of queued events. See alsord_kafka_outq_len()  Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* timeout_ms <code>int|null</code> int Returns <code>int</code> rd_kafka_resp_err_t - RD_KAFKA_RESP_ERR__TIMED_OUT if <code>timeout_ms</code> was reached before all outstanding requests were completed, else RD_KAFKA_RESP_ERR_NO_ERROR <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aaff06c4372bce917c17f3c1a5d8b205d </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_purge","title":"rd_kafka_purge()","text":"<pre><code>public static rd_kafka_purge ( \n    \\FFI\\CData|null $rk, \n    int|null $purge_flags\n ): int\n</code></pre> <p>Purge messages currently handled by the producer instance. </p> <p>The application will need to call rd_kafka_poll() or rd_kafka_flush() afterwards to serve the delivery report callbacks of the purged messages.</p> <p>Messages purged from internal queues fail with the delivery report error code set to RD_KAFKA_RESP_ERR__PURGE_QUEUE, while purged messages that are in-flight to or from the broker will fail with the error code set to RD_KAFKA_RESP_ERR__PURGE_INFLIGHT.</p> WarningPurging messages that are in-flight to or from the broker will ignore any subsequent acknowledgement for these messages received from the broker, effectively making it impossible for the application to know if the messages were successfully produced or not. This may result in duplicate messages if the application retries these messages at a later time. RemarksThis call may block for a short time while background thread queues are purged. Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* - Client instance. purge_flags <code>int|null</code> int - Tells which messages to purge and how. Returns <code>int</code> rd_kafka_resp_err_t - RD_KAFKA_RESP_ERR_NO_ERROR on success, RD_KAFKA_RESP_ERR__INVALID_ARG if the <code>purge</code> flags are invalid or unknown, RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED if called on a non-producer client instance. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a59c28026ebf7a67df5954879ebab4707 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_metadata","title":"rd_kafka_metadata()","text":"<pre><code>public static rd_kafka_metadata ( \n    \\FFI\\CData|null $rk, \n    int|null $all_topics, \n    \\FFI\\CData|null $only_rkt, \n    \\FFI\\CData|null $metadatap, \n    int|null $timeout_ms\n ): int\n</code></pre> <p>Request Metadata from broker. </p> <p>Parameters:</p> <ul> <li><code>all_topics</code> if non-zero: request info about all topics in cluster, if zero: only request info about locally known topics.</li> <li><code>only_rkt</code> only request info about this topic</li> <li><code>metadatap</code> pointer to hold metadata result. The <code>*metadatap</code> pointer must be released with rd_kafka_metadata_destroy().</li> <li><code>timeout_ms</code> maximum response time before failing.</li> </ul> RemarksConsumer: If <code>all_topics</code> is non-zero the Metadata response information may trigger a re-join if any subscribed topics have changed partition count or existence state. Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* all_topics <code>int|null</code> int only_rkt <code>\\FFI\\CData|null</code> rd_kafka_topic_t* metadatap <code>\\FFI\\CData|null</code> const struct rd_kafka_metadata** timeout_ms <code>int|null</code> int Returns <code>int</code> rd_kafka_resp_err_t - RD_KAFKA_RESP_ERR_NO_ERROR on success (in which case *metadatap) will be set, else RD_KAFKA_RESP_ERR__TIMED_OUT on timeout or other error code on error. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a84bba4a4b13fdb515f1a22d6fd4f7344 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_metadata_destroy","title":"rd_kafka_metadata_destroy()","text":"<pre><code>public static rd_kafka_metadata_destroy ( \n    \\FFI\\CData|\\Closure $metadata\n ): void\n</code></pre> Parameters metadata <code>\\FFI\\CData|\\Closure</code> rd_kafka_resp_err_t(rd_kafka_metadata*)(rd_kafka_t*, int, rd_kafka_topic_t*, const struct rd_kafka_metadata**, int)"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_list_groups","title":"rd_kafka_list_groups()","text":"<pre><code>public static rd_kafka_list_groups ( \n    \\FFI\\CData|null $rk, \n    string|null $group, \n    \\FFI\\CData|null $grplistp, \n    int|null $timeout_ms\n ): int\n</code></pre> <p>List and describe client groups in cluster. </p> <p><code>group</code> is an optional group name to describe, otherwise (<code>NULL</code>) all groups are returned.</p> <p><code>timeout_ms</code> is the (approximate) maximum time to wait for response from brokers and must be a positive value.</p> <p>The <code>grplistp</code> remains untouched if any error code is returned, with the exception of RD_KAFKA_RESP_ERR__PARTIAL which behaves as RD_KAFKA_RESP_ERR__NO_ERROR (success) but with an incomplete group list.</p> See alsoUse rd_kafka_group_list_destroy() to release list memory. Deprecated:Use rd_kafka_ListConsumerGroups() and rd_kafka_DescribeConsumerGroups() instead.  Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* group <code>string|null</code> const char* grplistp <code>\\FFI\\CData|null</code> const struct rd_kafka_group_list** timeout_ms <code>int|null</code> int Returns <code>int</code> rd_kafka_resp_err_t - <code>RD_KAFKA_RESP_ERR__NO_ERROR</code> on success and <code>grplistp</code> is updated to point to a newly allocated list of groups. <code>RD_KAFKA_RESP_ERR__PARTIAL</code> if not all brokers responded in time but at least one group is returned in <code>grplistlp</code>. <code>RD_KAFKA_RESP_ERR__TIMED_OUT</code> if no groups were returned in the given timeframe but not all brokers have yet responded, or if the list of brokers in the cluster could not be obtained within the given timeframe. <code>RD_KAFKA_RESP_ERR__TRANSPORT</code> if no brokers were found. Other error codes may also be returned from the request layer. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a6cfc79819453ecd4aa94fbae6dbbea0a </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_group_list_destroy","title":"rd_kafka_group_list_destroy()","text":"<pre><code>public static rd_kafka_group_list_destroy ( \n    \\FFI\\CData|null $grplist\n ): void\n</code></pre> Parameters grplist <code>\\FFI\\CData|null</code> const struct rd_kafka_group_list*"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_brokers_add","title":"rd_kafka_brokers_add()","text":"<pre><code>public static rd_kafka_brokers_add ( \n    \\FFI\\CData|null $rk, \n    string|null $brokerlist\n ): int|null\n</code></pre> <p>Adds one or more brokers to the kafka handle's list of initial bootstrap brokers. </p> <p>Additional brokers will be discovered automatically as soon as rdkafka connects to a broker by querying the broker metadata.</p> <p>If a broker name resolves to multiple addresses (and possibly address families) all will be used for connection attempts in round-robin fashion.</p> <p><code>brokerlist</code> is a ,-separated list of brokers in the format: <code>&lt;broker1&gt;</code>,&lt;broker2&gt;,.. Where each broker is in either the host or URL based format: <code>&lt;host&gt;</code>[:&lt;port&gt;] <code>&lt;proto&gt;</code>://&lt;host&gt;[:port] <code>&lt;proto&gt;</code> is either <code>PLAINTEXT</code>, <code>SSL</code>, <code>SASL</code>, <code>SASL_PLAINTEXT</code> The two formats can be mixed but ultimately the value of the <code>security.protocol</code> config property decides what brokers are allowed.</p> <p>Example: brokerlist = \"broker1:10000,broker2\" brokerlist = \"SSL://broker3:9000,ssl://broker2\"</p> RemarksBrokers may also be defined with the <code>metadata.broker.list</code> or <code>bootstrap.servers</code> configuration property (preferred method). Deprecated:Set bootstrap servers with the <code>bootstrap.servers</code> configuration property.  Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* brokerlist <code>string|null</code> const char* Returns <code>int|null</code> int - the number of brokers successfully added. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ab83da8da989fe41693d78d982c7ae6b7 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_set_logger","title":"rd_kafka_set_logger()","text":"<pre><code>public static rd_kafka_set_logger ( \n    \\FFI\\CData|null $rk, \n    \\FFI\\CData|\\Closure $func\n ): void\n</code></pre> <p>Set logger function. </p> <p>The default is to print to stderr, but a syslog logger is also available, see rd_kafka_log_(print|syslog) for the builtin alternatives. Alternatively the application may provide its own logger callback. Or pass 'func' as NULL to disable logging.</p> Deprecated:Use rd_kafka_conf_set_log_cb() Remarks<code>rk</code> may be passed as NULL in the callback.  Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* func <code>\\FFI\\CData|\\Closure</code> void()(const rd_kafka_t, int, const char*, const char*) <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a9e4af9adee414af74c7817403f7c4a53 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_set_log_level","title":"rd_kafka_set_log_level()","text":"<pre><code>public static rd_kafka_set_log_level ( \n    \\FFI\\CData|null $rk, \n    int|null $level\n ): void\n</code></pre> <p>Specifies the maximum logging level emitted by internal kafka logging and debugging. </p> Deprecated:Set the <code>\"log_level\"</code> configuration property instead. RemarksIf the <code>\"debug\"</code> configuration property is set the log level is automatically adjusted to <code>LOG_DEBUG</code> (7).  Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* level <code>int|null</code> int <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#acadeefced6bb60acd27e7a0dad553aa4 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_log_print","title":"rd_kafka_log_print()","text":"<pre><code>public static rd_kafka_log_print ( \n    \\FFI\\CData|null $rk, \n    int|null $level, \n    string|null $fac, \n    string|null $buf\n ): void\n</code></pre> Parameters rk <code>\\FFI\\CData|null</code> const rd_kafka_t* level <code>int|null</code> int fac <code>string|null</code> const char* buf <code>string|null</code> const char*"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_log_syslog","title":"rd_kafka_log_syslog()","text":"<pre><code>public static rd_kafka_log_syslog ( \n    \\FFI\\CData|null $rk, \n    int|null $level, \n    string|null $fac, \n    string|null $buf\n ): void\n</code></pre> <p>Builtin log sink: print to syslog. </p> RemarksThis logger is only available if librdkafka was built with syslog support.  Parameters rk <code>\\FFI\\CData|null</code> const rd_kafka_t* level <code>int|null</code> int fac <code>string|null</code> const char* buf <code>string|null</code> const char* <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a748d5eaca75f94bb4ff4217ae824385d </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_outq_len","title":"rd_kafka_outq_len()","text":"<pre><code>public static rd_kafka_outq_len ( \n    \\FFI\\CData|null $rk\n ): int|null\n</code></pre> <p>Returns the current out queue length. </p> <p>The out queue length is the sum of:</p> <ul> <li>number of messages waiting to be sent to, or acknowledged by, the broker.</li> <li>number of delivery reports (e.g., dr_msg_cb) waiting to be served by rd_kafka_poll() or rd_kafka_flush().</li> <li>number of callbacks (e.g., error_cb, stats_cb, etc) waiting to be served by rd_kafka_poll(), rd_kafka_consumer_poll() or rd_kafka_flush().</li> <li>number of events waiting to be served by background_event_cb() in the background queue (see rd_kafka_conf_set_background_event_cb).</li> </ul> <p>An application should wait for the return value of this function to reach zero before terminating to make sure outstanding messages, requests (such as offset commits), callbacks and events are fully processed. See rd_kafka_flush().</p> See alsord_kafka_flush()  Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* - ) Returns <code>int|null</code> int - number of messages and events waiting in queues. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ad4b3b7659cf9a79d3353810d6b625bb7 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_dump","title":"rd_kafka_dump()","text":"<pre><code>public static rd_kafka_dump ( \n    \\FFI\\CData|null $fp, \n    \\FFI\\CData|null $rk\n ): void\n</code></pre> <p>Dumps rdkafka's internal state for handle <code>rk</code> to stream <code>fp</code>. </p> <p>This is only useful for debugging rdkafka, showing state and statistics for brokers, topics, partitions, etc. </p> Parameters fp <code>\\FFI\\CData|null</code> FILE* rk <code>\\FFI\\CData|null</code> rd_kafka_t* <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a27a46f74ec4ccc9c0b36dbcf546908a1 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_thread_cnt","title":"rd_kafka_thread_cnt()","text":"<pre><code>public static rd_kafka_thread_cnt (  ): int|null\n</code></pre> <p>Retrieve the current number of threads in use by librdkafka. </p> <p>Used by regression tests. </p> Returns <code>int|null</code> int - ) <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a0901699375c972b807ba5255773f017f </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_wait_destroyed","title":"rd_kafka_wait_destroyed()","text":"<pre><code>public static rd_kafka_wait_destroyed ( \n    int|null $timeout_ms\n ): int|null\n</code></pre> <p>Wait for all rd_kafka_t objects to be destroyed. </p> <p>Returns 0 if all kafka objects are now destroyed, or -1 if the timeout was reached.</p> RemarksThis function is deprecated.  Parameters timeout_ms <code>int|null</code> int - ) Returns <code>int|null</code> int <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aa90f2c92a382dbd0a090d40caa73356d </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_unittest","title":"rd_kafka_unittest()","text":"<pre><code>public static rd_kafka_unittest (  ): int|null\n</code></pre> <p>Run librdkafka's built-in unit-tests. </p> Returns <code>int|null</code> int - ) - the number of failures, or 0 if all tests passed. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ab932d463be030a5e83ebfc5186ff20b8 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_poll_set_consumer","title":"rd_kafka_poll_set_consumer()","text":"<pre><code>public static rd_kafka_poll_set_consumer ( \n    \\FFI\\CData|null $rk\n ): int\n</code></pre> <p>Redirect the main (rd_kafka_poll()) queue to the KafkaConsumer's queue (rd_kafka_consumer_poll()). </p> WarningIt is not permitted to call rd_kafka_poll() after directing the main queue with rd_kafka_poll_set_consumer().  Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* - ) Returns <code>int</code> rd_kafka_resp_err_t <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a9bfa0a1dd3f866cbf0c82fc089bd7904 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_event_type","title":"rd_kafka_event_type()","text":"<pre><code>public static rd_kafka_event_type ( \n    \\FFI\\CData|null $rkev\n ): int|null\n</code></pre> RemarksAs a convenience it is okay to pass <code>rkev</code> as NULL in which case RD_KAFKA_EVENT_NONE is returned.  Parameters rkev <code>\\FFI\\CData|null</code> const rd_kafka_event_t* - ) Returns <code>int|null</code> rd_kafka_event_type_t - the event type for the given event. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a108de3729a4aa609a72a458a9de02d1d </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_event_name","title":"rd_kafka_event_name()","text":"<pre><code>public static rd_kafka_event_name ( \n    \\FFI\\CData|null $rkev\n ): string|null\n</code></pre> RemarksAs a convenience it is okay to pass <code>rkev</code> as NULL in which case the name for RD_KAFKA_EVENT_NONE is returned.  Parameters rkev <code>\\FFI\\CData|null</code> const rd_kafka_event_t* - ) Returns <code>string|null</code> const char* - the event type\u2019s name for the given event. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a608193d1fb486f78c79497c8c5b63866 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_event_destroy","title":"rd_kafka_event_destroy()","text":"<pre><code>public static rd_kafka_event_destroy ( \n    \\FFI\\CData|null $rkev\n ): void\n</code></pre> <p>Destroy an event. </p> RemarksAny references to this event, such as extracted messages, will not be usable after this call.  As a convenience it is okay to pass <code>rkev</code> as NULL in which case no action is performed.  Parameters rkev <code>\\FFI\\CData|null</code> rd_kafka_event_t* - ) <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#af1835c85aa202caf629861f29f475099 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_event_message_next","title":"rd_kafka_event_message_next()","text":"<pre><code>public static rd_kafka_event_message_next ( \n    \\FFI\\CData|null $rkev\n ): \\FFI\\CData|null\n</code></pre> <p>Call repeatedly until it returns NULL.</p> <p>Event types:</p> <ul> <li>RD_KAFKA_EVENT_FETCH (1 message)</li> <li>RD_KAFKA_EVENT_DR (&gt;=1 message(s))</li> </ul> RemarksThe returned message(s) MUST NOT be freed with rd_kafka_message_destroy().  on_consume() interceptor may be called from this function prior to passing message to application.  Parameters rkev <code>\\FFI\\CData|null</code> rd_kafka_event_t* - ) Returns <code>\\FFI\\CData|null</code> const rd_kafka_message_t* - the next message from an event. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a3a855eb7bdf17f5797d4911362a5fc7c </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_event_message_array","title":"rd_kafka_event_message_array()","text":"<pre><code>public static rd_kafka_event_message_array ( \n    \\FFI\\CData|null $rkev, \n    \\FFI\\CData|null $rkmessages, \n    int|null $size\n ): int|null\n</code></pre> <p>Extacts <code>size</code> message(s) from the event into the pre-allocated array <code>rkmessages</code>. </p> <p>Event types:</p> <ul> <li>RD_KAFKA_EVENT_FETCH (1 message)</li> <li>RD_KAFKA_EVENT_DR (&gt;=1 message(s))</li> </ul> Remarkson_consume() interceptor may be called from this function prior to passing message to application.  Parameters rkev <code>\\FFI\\CData|null</code> rd_kafka_event_t* rkmessages <code>\\FFI\\CData|null</code> const rd_kafka_message_t** size <code>int|null</code> size_t Returns <code>int|null</code> size_t - the number of messages extracted. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a18a17000ebe58eabcdafab37924442b8 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_event_message_count","title":"rd_kafka_event_message_count()","text":"<pre><code>public static rd_kafka_event_message_count ( \n    \\FFI\\CData|null $rkev\n ): int|null\n</code></pre> <p>Event types:</p> <ul> <li>RD_KAFKA_EVENT_FETCH (1 message)</li> <li>RD_KAFKA_EVENT_DR (&gt;=1 message(s)) </li> </ul> Parameters rkev <code>\\FFI\\CData|null</code> rd_kafka_event_t* - ) Returns <code>int|null</code> size_t - the number of remaining messages in the event. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a61d9d106c8956f379bb77d393b8acf90 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_event_error","title":"rd_kafka_event_error()","text":"<pre><code>public static rd_kafka_event_error ( \n    \\FFI\\CData|null $rkev\n ): int\n</code></pre> <p>Use rd_kafka_event_error_is_fatal() to detect if this is a fatal error.</p> <p>Event types:</p> <ul> <li>all </li> </ul> Parameters rkev <code>\\FFI\\CData|null</code> rd_kafka_event_t* - ) Returns <code>int</code> rd_kafka_resp_err_t - the error code for the event. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aa28b7d6bb4885843f9a8b9bafa0e15a5 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_event_error_string","title":"rd_kafka_event_error_string()","text":"<pre><code>public static rd_kafka_event_error_string ( \n    \\FFI\\CData|null $rkev\n ): string|null\n</code></pre> <p>Event types:</p> <ul> <li>all </li> </ul> Parameters rkev <code>\\FFI\\CData|null</code> rd_kafka_event_t* - ) Returns <code>string|null</code> const char* - the error string (if any). An application should check that rd_kafka_event_error() returns non-zero before calling this function. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ad76a1b2d6c4f1727725b075678b88793 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_event_error_is_fatal","title":"rd_kafka_event_error_is_fatal()","text":"<pre><code>public static rd_kafka_event_error_is_fatal ( \n    \\FFI\\CData|null $rkev\n ): int|null\n</code></pre> <p>Event types:</p> <ul> <li>RD_KAFKA_EVENT_ERROR</li> </ul> See alsord_kafka_fatal_error()  Parameters rkev <code>\\FFI\\CData|null</code> rd_kafka_event_t* - ) Returns <code>int|null</code> int - 1 if the error is a fatal error, else 0. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a1fe9d1e960a59774dbd5a0336927de7d </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_event_opaque","title":"rd_kafka_event_opaque()","text":"<pre><code>public static rd_kafka_event_opaque ( \n    \\FFI\\CData|null $rkev\n ): \\FFI\\CData|object|string|null\n</code></pre> <p>Event types:</p> <ul> <li>RD_KAFKA_EVENT_OFFSET_COMMIT</li> <li>RD_KAFKA_EVENT_CREATETOPICS_RESULT</li> <li>RD_KAFKA_EVENT_DELETETOPICS_RESULT</li> <li>RD_KAFKA_EVENT_CREATEPARTITIONS_RESULT</li> <li>RD_KAFKA_EVENT_CREATEACLS_RESULT</li> <li>RD_KAFKA_EVENT_DESCRIBEACLS_RESULT</li> <li>RD_KAFKA_EVENT_DELETEACLS_RESULT</li> <li>RD_KAFKA_EVENT_ALTERCONFIGS_RESULT</li> <li>RD_KAFKA_EVENT_INCREMENTAL_ALTERCONFIGS_RESULT</li> <li>RD_KAFKA_EVENT_DESCRIBECONFIGS_RESULT</li> <li>RD_KAFKA_EVENT_DELETEGROUPS_RESULT</li> <li>RD_KAFKA_EVENT_DELETECONSUMERGROUPOFFSETS_RESULT</li> <li>RD_KAFKA_EVENT_DELETERECORDS_RESULT</li> <li>RD_KAFKA_EVENT_LISTCONSUMERGROUPS_RESULT</li> <li>RD_KAFKA_EVENT_DESCRIBECONSUMERGROUPS_RESULT</li> <li>RD_KAFKA_EVENT_LISTCONSUMERGROUPOFFSETS_RESULT</li> <li>RD_KAFKA_EVENT_ALTERCONSUMERGROUPOFFSETS_RESULT</li> <li>RD_KAFKA_EVENT_DESCRIBETOPICS_RESULT</li> <li>RD_KAFKA_EVENT_DESCRIBECLUSTER_RESULT</li> <li>RD_KAFKA_EVENT_LISTOFFSETS_RESULT</li> <li>RD_KAFKA_EVENT_ELECTLEADERS_RESULT </li> </ul> Parameters rkev <code>\\FFI\\CData|null</code> rd_kafka_event_t* - ) Returns <code>\\FFI\\CData|object|string|null</code> void* - the event opaque (if any) as passed to rd_kafka_commit() (et.al) or rd_kafka_AdminOptions_set_opaque(), depending on event type. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8650ed2a19108d490a65c9aff3e66525 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_event_log","title":"rd_kafka_event_log()","text":"<pre><code>public static rd_kafka_event_log ( \n    \\FFI\\CData|null $rkev, \n    \\FFI\\CData|null $fac, \n    \\FFI\\CData|null $str, \n    \\FFI\\CData|null $level\n ): int|null\n</code></pre> <p>Extract log message from the event. </p> <p>Event types:</p> <ul> <li>RD_KAFKA_EVENT_LOG</li> </ul> Parameters rkev <code>\\FFI\\CData|null</code> rd_kafka_event_t* fac <code>\\FFI\\CData|null</code> const char** str <code>\\FFI\\CData|null</code> const char** level <code>\\FFI\\CData|null</code> int* Returns <code>int|null</code> int - 0 on success or -1 if unsupported event type. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a535efaa16772642d724bedca414c17c7 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_event_stats","title":"rd_kafka_event_stats()","text":"<pre><code>public static rd_kafka_event_stats ( \n    \\FFI\\CData|null $rkev\n ): string|null\n</code></pre> <p>Extract stats from the event. </p> <p>Event types:</p> <ul> <li>RD_KAFKA_EVENT_STATS</li> </ul> Remarksthe returned string will be freed automatically along with the event object  Parameters rkev <code>\\FFI\\CData|null</code> rd_kafka_event_t* - ) Returns <code>string|null</code> const char* - stats json string. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ae8572e38ffb452f96d13a2d046fb71d9 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_event_topic_partition_list","title":"rd_kafka_event_topic_partition_list()","text":"<pre><code>public static rd_kafka_event_topic_partition_list ( \n    \\FFI\\CData|null $rkev\n ): \\FFI\\CData|null\n</code></pre> RemarksThe list MUST NOT be freed with rd_kafka_topic_partition_list_destroy() <p>Event types:</p> <ul> <li>RD_KAFKA_EVENT_REBALANCE</li> <li>RD_KAFKA_EVENT_OFFSET_COMMIT </li> </ul> Parameters rkev <code>\\FFI\\CData|null</code> rd_kafka_event_t* - ) Returns <code>\\FFI\\CData|null</code> rd_kafka_topic_partition_list_t* - the topic partition list from the event. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#abc8f98c9b35be497251fb8515e9e6633 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_event_topic_partition","title":"rd_kafka_event_topic_partition()","text":"<pre><code>public static rd_kafka_event_topic_partition ( \n    \\FFI\\CData|null $rkev\n ): \\FFI\\CData|null\n</code></pre> RemarksThe returned pointer MUST be freed with rd_kafka_topic_partition_destroy(). <p>Event types: RD_KAFKA_EVENT_ERROR (for partition level errors) </p> Parameters rkev <code>\\FFI\\CData|null</code> rd_kafka_event_t* - ) Returns <code>\\FFI\\CData|null</code> rd_kafka_topic_partition_t* - a newly allocated topic_partition container, if applicable for the event type, else NULL. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#abf4cce46d6e566dd35865c0451b76afe </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_event_createtopics_result","title":"rd_kafka_event_CreateTopics_result()","text":"<pre><code>public static rd_kafka_event_CreateTopics_result ( \n    \\FFI\\CData|null $rkev\n ): \\FFI\\CData|null\n</code></pre> <p>Get CreateTopics result. </p> <p>Event types: RD_KAFKA_EVENT_CREATETOPICS_RESULT </p> Parameters rkev <code>\\FFI\\CData|null</code> rd_kafka_event_t* - ) Returns <code>\\FFI\\CData|null</code> const rd_kafka_CreateTopics_result_t* - the result of a CreateTopics request, or NULL if event is of different type. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a0aa821ae098ca3b88c1a7fdec25c645e </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_event_deletetopics_result","title":"rd_kafka_event_DeleteTopics_result()","text":"<pre><code>public static rd_kafka_event_DeleteTopics_result ( \n    \\FFI\\CData|null $rkev\n ): \\FFI\\CData|null\n</code></pre> <p>Get DeleteTopics result. </p> <p>Event types: RD_KAFKA_EVENT_DELETETOPICS_RESULT </p> Parameters rkev <code>\\FFI\\CData|null</code> rd_kafka_event_t* - ) Returns <code>\\FFI\\CData|null</code> const rd_kafka_DeleteTopics_result_t* - the result of a DeleteTopics request, or NULL if event is of different type. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a4cd8e837f75589842581110890740f65 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_event_createpartitions_result","title":"rd_kafka_event_CreatePartitions_result()","text":"<pre><code>public static rd_kafka_event_CreatePartitions_result ( \n    \\FFI\\CData|null $rkev\n ): \\FFI\\CData|null\n</code></pre> <p>Get CreatePartitions result. </p> <p>Event types: RD_KAFKA_EVENT_CREATEPARTITIONS_RESULT </p> Parameters rkev <code>\\FFI\\CData|null</code> rd_kafka_event_t* - ) Returns <code>\\FFI\\CData|null</code> const rd_kafka_CreatePartitions_result_t* - the result of a CreatePartitions request, or NULL if event is of different type. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ab4f667a48124ac6be89a2b9bcd5f8d47 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_event_alterconfigs_result","title":"rd_kafka_event_AlterConfigs_result()","text":"<pre><code>public static rd_kafka_event_AlterConfigs_result ( \n    \\FFI\\CData|null $rkev\n ): \\FFI\\CData|null\n</code></pre> <p>Get AlterConfigs result. </p> <p>Event types: RD_KAFKA_EVENT_ALTERCONFIGS_RESULT </p> Parameters rkev <code>\\FFI\\CData|null</code> rd_kafka_event_t* - ) Returns <code>\\FFI\\CData|null</code> const rd_kafka_AlterConfigs_result_t* - the result of a AlterConfigs request, or NULL if event is of different type. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a97d0666a40b2bd014d564de332eacf3f </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_event_describeconfigs_result","title":"rd_kafka_event_DescribeConfigs_result()","text":"<pre><code>public static rd_kafka_event_DescribeConfigs_result ( \n    \\FFI\\CData|null $rkev\n ): \\FFI\\CData|null\n</code></pre> <p>Get DescribeConfigs result. </p> <p>Event types: RD_KAFKA_EVENT_DESCRIBECONFIGS_RESULT </p> Parameters rkev <code>\\FFI\\CData|null</code> rd_kafka_event_t* - ) Returns <code>\\FFI\\CData|null</code> const rd_kafka_DescribeConfigs_result_t* - the result of a DescribeConfigs request, or NULL if event is of different type. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a0e1a04881f39aa850cd47b43583f5a90 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_queue_poll","title":"rd_kafka_queue_poll()","text":"<pre><code>public static rd_kafka_queue_poll ( \n    \\FFI\\CData|null $rkqu, \n    int|null $timeout_ms\n ): \\FFI\\CData|null\n</code></pre> <p>Poll a queue for an event for max <code>timeout_ms</code>. </p> RemarksUse rd_kafka_event_destroy() to free the event. See alsord_kafka_conf_set_background_event_cb()  Parameters rkqu <code>\\FFI\\CData|null</code> rd_kafka_queue_t* timeout_ms <code>int|null</code> int Returns <code>\\FFI\\CData|null</code> rd_kafka_event_t* - an event, or NULL. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a2f147ed1c554c9048893fb1adde86dfa </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_queue_poll_callback","title":"rd_kafka_queue_poll_callback()","text":"<pre><code>public static rd_kafka_queue_poll_callback ( \n    \\FFI\\CData|null $rkqu, \n    int|null $timeout_ms\n ): int|null\n</code></pre> <p>Poll a queue for events served through callbacks for max <code>timeout_ms</code>. </p> RemarksThis API must only be used for queues with callbacks registered for all expected event types. E.g., not a message queue.  Also see rd_kafka_conf_set_background_event_cb() for triggering event callbacks from a librdkafka-managed background thread. See alsord_kafka_conf_set_background_event_cb()  Parameters rkqu <code>\\FFI\\CData|null</code> rd_kafka_queue_t* timeout_ms <code>int|null</code> int Returns <code>int|null</code> int - the number of events served. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a13d80084f20a2800e863b97e465ce98e </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_plugin_f_conf_init_t","title":"rd_kafka_plugin_f_conf_init_t()","text":"<pre><code>public static rd_kafka_plugin_f_conf_init_t ( \n    \\FFI\\CData|null $conf, \n    \\FFI\\CData|object|string|null $plug_opaquep, \n    \\FFI\\CData|null $errstr, \n    int|null $errstr_size\n ): int\n</code></pre> <p>Plugin's configuration initializer method called each time the library is referenced from configuration (even if previously loaded by another client instance). </p> RemarksThis method MUST be implemented by plugins and have the symbol name <code>conf_init</code> RemarksA plugin may add an on_conf_destroy() interceptor to clean up plugin-specific resources created in the plugin's conf_init() method. Parameters conf <code>\\FFI\\CData|null</code> rd_kafka_conf_t* - Configuration set up to this point. plug_opaquep <code>\\FFI\\CData|object|string|null</code> void** - Plugin can set this pointer to a per-configuration opaque pointer. errstr <code>\\FFI\\CData|null</code> char* - String buffer of size <code>errstr_size</code> where plugin must write a human readable error string in the case the initializer fails (returns non-zero). - Maximum space (including \\0) in <code>errstr</code>. errstr_size <code>int|null</code> size_t Returns <code>int</code> rd_kafka_resp_err_t - RD_KAFKA_RESP_ERR_NO_ERROR on success or an error code on error. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a6d98d642466324e3b188accb2623387f </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_interceptor_f_on_conf_set_t","title":"rd_kafka_interceptor_f_on_conf_set_t()","text":"<pre><code>public static rd_kafka_interceptor_f_on_conf_set_t ( \n    \\FFI\\CData|null $conf, \n    string|null $name, \n    string|null $val, \n    \\FFI\\CData|null $errstr, \n    int|null $errstr_size, \n    \\FFI\\CData|object|string|null $ic_opaque\n ): int\n</code></pre> <p>on_conf_set() is called from rd_kafka_*_conf_set() in the order the interceptors were added. </p> Parameters conf <code>\\FFI\\CData|null</code> rd_kafka_conf_t* - Configuration object. name <code>string|null</code> const char* - The configuration property to set. val <code>string|null</code> const char* - The configuration value to set, or NULL for reverting to default in which case the previous value should be freed. errstr <code>\\FFI\\CData|null</code> char* - A human readable error string in case the interceptor fails. errstr_size <code>int|null</code> size_t - Maximum space (including \\0) in <code>errstr</code>. ic_opaque <code>\\FFI\\CData|object|string|null</code> void* - The interceptor\u2019s opaque pointer specified in ..add..(). Returns <code>int</code> rd_kafka_conf_res_t - RD_KAFKA_CONF_OK if the property was known and successfully handled by the interceptor, RD_KAFKA_CONF_INVALID if the property was handled by the interceptor but the value was invalid, or RD_KAFKA_CONF_UNKNOWN if the interceptor did not handle this property, in which case the property is passed on on the interceptor in the chain, finally ending up at the built-in configuration handler. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a6c1f90ab0ce78b28daa9ee27a682da10 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_interceptor_f_on_conf_dup_t","title":"rd_kafka_interceptor_f_on_conf_dup_t()","text":"<pre><code>public static rd_kafka_interceptor_f_on_conf_dup_t ( \n    \\FFI\\CData|null $new_conf, \n    \\FFI\\CData|null $old_conf, \n    int|null $filter_cnt, \n    \\FFI\\CData|null $filter, \n    \\FFI\\CData|object|string|null $ic_opaque\n ): int\n</code></pre> <p>on_conf_dup() is called from rd_kafka_conf_dup() in the order the interceptors were added and is used to let an interceptor re-register its conf interecptors with a new opaque value. The on_conf_dup() method is called prior to the configuration from <code>old_conf</code> being copied to <code>new_conf</code>. </p> RemarksNo on_conf_* interceptors are copied to the new configuration object on rd_kafka_conf_dup().  Parameters new_conf <code>\\FFI\\CData|null</code> rd_kafka_conf_t* - New configuration object. old_conf <code>\\FFI\\CData|null</code> const rd_kafka_conf_t* - Old configuration object to copy properties from. filter_cnt <code>int|null</code> size_t - Number of property names to filter in <code>filter</code>. - Property names to filter out (ignore) when setting up <code>new_conf</code>. filter <code>\\FFI\\CData|null</code> const char** ic_opaque <code>\\FFI\\CData|object|string|null</code> void* - The interceptor\u2019s opaque pointer specified in ..add..(). Returns <code>int</code> rd_kafka_resp_err_t - RD_KAFKA_RESP_ERR_NO_ERROR on success or an error code on failure (which is logged but otherwise ignored). <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a166d8f2aea67064516b7995869af2411 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_interceptor_f_on_conf_destroy_t","title":"rd_kafka_interceptor_f_on_conf_destroy_t()","text":"<pre><code>public static rd_kafka_interceptor_f_on_conf_destroy_t ( \n    \\FFI\\CData|object|string|null $ic_opaque\n ): int\n</code></pre> <p>on_conf_destroy() is called from rd_kafka_*_conf_destroy() in the order the interceptors were added. </p> Parameters ic_opaque <code>\\FFI\\CData|object|string|null</code> void* - The interceptor\u2019s opaque pointer specified in ..add..(). Returns <code>int</code> rd_kafka_resp_err_t <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#afd1b354fab7374b77cf5e43c8a04c479 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_interceptor_f_on_new_t","title":"rd_kafka_interceptor_f_on_new_t()","text":"<pre><code>public static rd_kafka_interceptor_f_on_new_t ( \n    \\FFI\\CData|null $rk, \n    \\FFI\\CData|null $conf, \n    \\FFI\\CData|object|string|null $ic_opaque, \n    \\FFI\\CData|null $errstr, \n    int|null $errstr_size\n ): int\n</code></pre> <p>on_new() is called from rd_kafka_new() prior toreturning the newly created client instance to the application. </p> WarningThe <code>rk</code> client instance will not be fully set up when this interceptor is called and the interceptor MUST NOT call any other rk-specific APIs than rd_kafka_interceptor_add..().  Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* - The client instance. conf <code>\\FFI\\CData|null</code> const rd_kafka_conf_t* - The client instance\u2019s final configuration. ic_opaque <code>\\FFI\\CData|object|string|null</code> void* - The interceptor\u2019s opaque pointer specified in ..add..(). errstr <code>\\FFI\\CData|null</code> char* - A human readable error string in case the interceptor fails. errstr_size <code>int|null</code> size_t - Maximum space (including \\0) in <code>errstr</code>. Returns <code>int</code> rd_kafka_resp_err_t - an error code on failure, the error is logged but otherwise ignored. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a1dd51e3656e61b4a8d4475a3e0deaa10 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_interceptor_f_on_destroy_t","title":"rd_kafka_interceptor_f_on_destroy_t()","text":"<pre><code>public static rd_kafka_interceptor_f_on_destroy_t ( \n    \\FFI\\CData|null $rk, \n    \\FFI\\CData|object|string|null $ic_opaque\n ): int\n</code></pre> <p>on_destroy() is called from rd_kafka_destroy() or (rd_kafka_new() if rd_kafka_new() fails during initialization). </p> Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* - The client instance. ic_opaque <code>\\FFI\\CData|object|string|null</code> void* - The interceptor\u2019s opaque pointer specified in ..add..(). Returns <code>int</code> rd_kafka_resp_err_t <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aaea78073e1a749ee0a8eaedf2f7c21d4 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_interceptor_f_on_send_t","title":"rd_kafka_interceptor_f_on_send_t()","text":"<pre><code>public static rd_kafka_interceptor_f_on_send_t ( \n    \\FFI\\CData|null $rk, \n    \\FFI\\CData|null $rkmessage, \n    \\FFI\\CData|object|string|null $ic_opaque\n ): int\n</code></pre> <p>on_send() is called from rd_kafka_produce*() (et.al) prior to the partitioner being called. </p> RemarksThis interceptor is only used by producer instances.  The <code>rkmessage</code> object is NOT mutable and MUST NOT be modified by the interceptor.  If the partitioner fails or an unknown partition was specified, the on_acknowledgement() interceptor chain will be called from within the rd_kafka_produce*() call to maintain send-acknowledgement symmetry. Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* - The client instance. rkmessage <code>\\FFI\\CData|null</code> rd_kafka_message_t* - The message being produced. Immutable. ic_opaque <code>\\FFI\\CData|object|string|null</code> void* - The interceptor\u2019s opaque pointer specified in ..add..(). Returns <code>int</code> rd_kafka_resp_err_t - an error code on failure, the error is logged but otherwise ignored. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a39c970fa80d4681d93332d3af4df5916 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_interceptor_f_on_acknowledgement_t","title":"rd_kafka_interceptor_f_on_acknowledgement_t()","text":"<pre><code>public static rd_kafka_interceptor_f_on_acknowledgement_t ( \n    \\FFI\\CData|null $rk, \n    \\FFI\\CData|null $rkmessage, \n    \\FFI\\CData|object|string|null $ic_opaque\n ): int\n</code></pre> <p>on_acknowledgement() is called to inform interceptors that a message was succesfully delivered or permanently failed delivery. The interceptor chain is called from internal librdkafka background threads, or rd_kafka_produce*() if the partitioner failed. </p> RemarksThis interceptor is only used by producer instances.  The <code>rkmessage</code> object is NOT mutable and MUST NOT be modified by the interceptor. WarningThe on_acknowledgement() method may be called from internal librdkafka threads. An on_acknowledgement() interceptor MUST NOT call any librdkafka API's associated with the <code>rk</code>, or perform any blocking or prolonged work. Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* - The client instance. rkmessage <code>\\FFI\\CData|null</code> rd_kafka_message_t* - The message being produced. Immutable. ic_opaque <code>\\FFI\\CData|object|string|null</code> void* - The interceptor\u2019s opaque pointer specified in ..add..(). Returns <code>int</code> rd_kafka_resp_err_t - an error code on failure, the error is logged but otherwise ignored. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aa654a84f20567004ab1df85f97f0ebf2 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_interceptor_f_on_consume_t","title":"rd_kafka_interceptor_f_on_consume_t()","text":"<pre><code>public static rd_kafka_interceptor_f_on_consume_t ( \n    \\FFI\\CData|null $rk, \n    \\FFI\\CData|null $rkmessage, \n    \\FFI\\CData|object|string|null $ic_opaque\n ): int\n</code></pre> <p>on_consume() is called just prior to passing the message to the application in rd_kafka_consumer_poll(), rd_kafka_consume*(), the event interface, etc. </p> RemarksThis interceptor is only used by consumer instances.  The <code>rkmessage</code> object is NOT mutable and MUST NOT be modified by the interceptor. Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* - The client instance. rkmessage <code>\\FFI\\CData|null</code> rd_kafka_message_t* - The message being consumed. Immutable. ic_opaque <code>\\FFI\\CData|object|string|null</code> void* - The interceptor\u2019s opaque pointer specified in ..add..(). Returns <code>int</code> rd_kafka_resp_err_t - an error code on failure, the error is logged but otherwise ignored. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ae31db94674004860fa545f3745497cfe </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_interceptor_f_on_commit_t","title":"rd_kafka_interceptor_f_on_commit_t()","text":"<pre><code>public static rd_kafka_interceptor_f_on_commit_t ( \n    \\FFI\\CData|null $rk, \n    \\FFI\\CData|null $offsets, \n    int $err, \n    \\FFI\\CData|object|string|null $ic_opaque\n ): int\n</code></pre> <p>on_commit() is called on completed or failed offset commit. It is called from internal librdkafka threads. </p> RemarksThis interceptor is only used by consumer instances. WarningThe on_commit() interceptor is called from internal librdkafka threads. An on_commit() interceptor MUST NOT call any librdkafka API's associated with the <code>rk</code>, or perform any blocking or prolonged work. Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* - The client instance. offsets <code>\\FFI\\CData|null</code> const rd_kafka_topic_partition_list_t* - List of topic+partition+offset+error that were committed. The error message of each partition should be checked for error. err <code>int</code> rd_kafka_resp_err_t - The commit error, if any. ic_opaque <code>\\FFI\\CData|object|string|null</code> void* - The interceptor\u2019s opaque pointer specified in ..add..(). Returns <code>int</code> rd_kafka_resp_err_t - an error code on failure, the error is logged but otherwise ignored. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a89c817cb2dd1a7b6a414a2f62c01fdcf </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_interceptor_f_on_request_sent_t","title":"rd_kafka_interceptor_f_on_request_sent_t()","text":"<pre><code>public static rd_kafka_interceptor_f_on_request_sent_t ( \n    \\FFI\\CData|null $rk, \n    int|null $sockfd, \n    string|null $brokername, \n    int|null $brokerid, \n    int|null $ApiKey, \n    int|null $ApiVersion, \n    int|null $CorrId, \n    int|null $size, \n    \\FFI\\CData|object|string|null $ic_opaque\n ): int\n</code></pre> <p>on_request_sent() is called when a request has been fully written to a broker TCP connections socket. </p> WarningThe on_request_sent() interceptor is called from internal librdkafka broker threads. An on_request_sent() interceptor MUST NOT call any librdkafka API's associated with the <code>rk</code>, or perform any blocking or prolonged work. Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* - The client instance. sockfd <code>int|null</code> int - Socket file descriptor. brokername <code>string|null</code> const char* - Broker request is being sent to. brokerid <code>int|null</code> int32_t - Broker request is being sent to. ApiKey <code>int|null</code> int16_t - Kafka protocol request type. ApiVersion <code>int|null</code> int16_t - Kafka protocol request type version. CorrId <code>int|null</code> int32_t - Kafka protocol request correlation id. size <code>int|null</code> size_t - Size of request. ic_opaque <code>\\FFI\\CData|object|string|null</code> void* - The interceptor\u2019s opaque pointer specified in ..add..(). Returns <code>int</code> rd_kafka_resp_err_t - an error code on failure, the error is logged but otherwise ignored. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a0b7f9b39e862802a6ccbac07bf848064 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_conf_interceptor_add_on_conf_set","title":"rd_kafka_conf_interceptor_add_on_conf_set()","text":"<pre><code>public static rd_kafka_conf_interceptor_add_on_conf_set ( \n    \\FFI\\CData|null $conf, \n    string|null $ic_name, \n    \\FFI\\CData|\\Closure $on_conf_set, \n    \\FFI\\CData|object|string|null $ic_opaque\n ): int\n</code></pre> <p>Append an on_conf_set() interceptor. </p> Parameters conf <code>\\FFI\\CData|null</code> rd_kafka_conf_t* - Configuration object. ic_name <code>string|null</code> const char* - Interceptor name, used in logging. on_conf_set <code>\\FFI\\CData|\\Closure</code> rd_kafka_conf_res_t(rd_kafka_interceptor_f_on_conf_set_t*)(rd_kafka_conf_t*, const char*, const char*, char*, size_t, void*) - Function pointer. ic_opaque <code>\\FFI\\CData|object|string|null</code> void* - Opaque value that will be passed to the function. Returns <code>int</code> rd_kafka_resp_err_t - RD_KAFKA_RESP_ERR_NO_ERROR on success or RD_KAFKA_RESP_ERR__CONFLICT if an existing interceptor with the same <code>ic_name</code> and function has already been added to <code>conf</code>. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a97bdeb12b99da10eff18767b3cadbfd2 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_conf_interceptor_add_on_conf_dup","title":"rd_kafka_conf_interceptor_add_on_conf_dup()","text":"<pre><code>public static rd_kafka_conf_interceptor_add_on_conf_dup ( \n    \\FFI\\CData|null $conf, \n    string|null $ic_name, \n    \\FFI\\CData|\\Closure $on_conf_dup, \n    \\FFI\\CData|object|string|null $ic_opaque\n ): int\n</code></pre> <p>Append an on_conf_dup() interceptor. </p> Parameters conf <code>\\FFI\\CData|null</code> rd_kafka_conf_t* - Configuration object. ic_name <code>string|null</code> const char* - Interceptor name, used in logging. on_conf_dup <code>\\FFI\\CData|\\Closure</code> rd_kafka_resp_err_t(rd_kafka_interceptor_f_on_conf_dup_t*)(rd_kafka_conf_t*, const rd_kafka_conf_t*, size_t, const char**, void*) - Function pointer. ic_opaque <code>\\FFI\\CData|object|string|null</code> void* - Opaque value that will be passed to the function. Returns <code>int</code> rd_kafka_resp_err_t - RD_KAFKA_RESP_ERR_NO_ERROR on success or RD_KAFKA_RESP_ERR__CONFLICT if an existing interceptor with the same <code>ic_name</code> and function has already been added to <code>conf</code>. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a375ce703f6247377305dc6a5dfc84429 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_conf_interceptor_add_on_conf_destroy","title":"rd_kafka_conf_interceptor_add_on_conf_destroy()","text":"<pre><code>public static rd_kafka_conf_interceptor_add_on_conf_destroy ( \n    \\FFI\\CData|null $conf, \n    string|null $ic_name, \n    \\FFI\\CData|\\Closure $on_conf_destroy, \n    \\FFI\\CData|object|string|null $ic_opaque\n ): int\n</code></pre> <p>Append an on_conf_destroy() interceptor. </p> RemarksMultiple on_conf_destroy() interceptors are allowed to be added to the same configuration object.  Parameters conf <code>\\FFI\\CData|null</code> rd_kafka_conf_t* - Configuration object. ic_name <code>string|null</code> const char* - Interceptor name, used in logging. on_conf_destroy <code>\\FFI\\CData|\\Closure</code> rd_kafka_resp_err_t(rd_kafka_interceptor_f_on_conf_destroy_t*)(void*) - Function pointer. ic_opaque <code>\\FFI\\CData|object|string|null</code> void* - Opaque value that will be passed to the function. Returns <code>int</code> rd_kafka_resp_err_t - RD_KAFKA_RESP_ERR_NO_ERROR <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a919ebd487a2717d6cbdf0d25102ea8ff </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_conf_interceptor_add_on_new","title":"rd_kafka_conf_interceptor_add_on_new()","text":"<pre><code>public static rd_kafka_conf_interceptor_add_on_new ( \n    \\FFI\\CData|null $conf, \n    string|null $ic_name, \n    \\FFI\\CData|\\Closure $on_new, \n    \\FFI\\CData|object|string|null $ic_opaque\n ): int\n</code></pre> <p>Append an on_new() interceptor. </p> RemarksSince the on_new() interceptor is added to the configuration object it may be copied by rd_kafka_conf_dup(). An interceptor implementation must thus be able to handle the same interceptor,ic_opaque tuple to be used by multiple client instances.  An interceptor plugin should check the return value to make sure it has not already been added. Parameters conf <code>\\FFI\\CData|null</code> rd_kafka_conf_t* - Configuration object. ic_name <code>string|null</code> const char* - Interceptor name, used in logging. on_new <code>\\FFI\\CData|\\Closure</code> rd_kafka_resp_err_t(rd_kafka_interceptor_f_on_new_t*)(rd_kafka_t*, const rd_kafka_conf_t*, void*, char*, size_t) - Function pointer. ic_opaque <code>\\FFI\\CData|object|string|null</code> void* - Opaque value that will be passed to the function. Returns <code>int</code> rd_kafka_resp_err_t - RD_KAFKA_RESP_ERR_NO_ERROR on success or RD_KAFKA_RESP_ERR__CONFLICT if an existing interceptor with the same <code>ic_name</code> and function has already been added to <code>conf</code>. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a002ef1d350176725b6e9ba93548edf40 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_interceptor_add_on_destroy","title":"rd_kafka_interceptor_add_on_destroy()","text":"<pre><code>public static rd_kafka_interceptor_add_on_destroy ( \n    \\FFI\\CData|null $rk, \n    string|null $ic_name, \n    \\FFI\\CData|\\Closure $on_destroy, \n    \\FFI\\CData|object|string|null $ic_opaque\n ): int\n</code></pre> <p>Append an on_destroy() interceptor. </p> Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* - Client instance. ic_name <code>string|null</code> const char* - Interceptor name, used in logging. on_destroy <code>\\FFI\\CData|\\Closure</code> rd_kafka_resp_err_t(rd_kafka_interceptor_f_on_destroy_t*)(rd_kafka_t*, void*) - Function pointer. ic_opaque <code>\\FFI\\CData|object|string|null</code> void* - Opaque value that will be passed to the function. Returns <code>int</code> rd_kafka_resp_err_t - RD_KAFKA_RESP_ERR_NO_ERROR on success or RD_KAFKA_RESP_ERR__CONFLICT if an existing interceptor with the same <code>ic_name</code> and function has already been added to <code>conf</code>. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a11b835cb99dc1cfa03c52465b9837a47 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_interceptor_add_on_send","title":"rd_kafka_interceptor_add_on_send()","text":"<pre><code>public static rd_kafka_interceptor_add_on_send ( \n    \\FFI\\CData|null $rk, \n    string|null $ic_name, \n    \\FFI\\CData|\\Closure $on_send, \n    \\FFI\\CData|object|string|null $ic_opaque\n ): int\n</code></pre> <p>Append an on_send() interceptor. </p> Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* - Client instance. ic_name <code>string|null</code> const char* - Interceptor name, used in logging. on_send <code>\\FFI\\CData|\\Closure</code> rd_kafka_resp_err_t(rd_kafka_interceptor_f_on_send_t*)(rd_kafka_t*, rd_kafka_message_t*, void*) - Function pointer. ic_opaque <code>\\FFI\\CData|object|string|null</code> void* - Opaque value that will be passed to the function. Returns <code>int</code> rd_kafka_resp_err_t - RD_KAFKA_RESP_ERR_NO_ERROR on success or RD_KAFKA_RESP_ERR__CONFLICT if an existing intercepted with the same <code>ic_name</code> and function has already been added to <code>conf</code>. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#af6fb1b8884444c63b6930a7bd6122cb6 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_interceptor_add_on_acknowledgement","title":"rd_kafka_interceptor_add_on_acknowledgement()","text":"<pre><code>public static rd_kafka_interceptor_add_on_acknowledgement ( \n    \\FFI\\CData|null $rk, \n    string|null $ic_name, \n    \\FFI\\CData|\\Closure $on_acknowledgement, \n    \\FFI\\CData|object|string|null $ic_opaque\n ): int\n</code></pre> <p>Append an on_acknowledgement() interceptor. </p> Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* - Client instance. ic_name <code>string|null</code> const char* - Interceptor name, used in logging. on_acknowledgement <code>\\FFI\\CData|\\Closure</code> rd_kafka_resp_err_t(rd_kafka_interceptor_f_on_acknowledgement_t*)(rd_kafka_t*, rd_kafka_message_t*, void*) - Function pointer. ic_opaque <code>\\FFI\\CData|object|string|null</code> void* - Opaque value that will be passed to the function. Returns <code>int</code> rd_kafka_resp_err_t - RD_KAFKA_RESP_ERR_NO_ERROR on success or RD_KAFKA_RESP_ERR__CONFLICT if an existing interceptor with the same <code>ic_name</code> and function has already been added to <code>conf</code>. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#abaf475ab47fff47ab796be1cecbbd370 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_interceptor_add_on_consume","title":"rd_kafka_interceptor_add_on_consume()","text":"<pre><code>public static rd_kafka_interceptor_add_on_consume ( \n    \\FFI\\CData|null $rk, \n    string|null $ic_name, \n    \\FFI\\CData|\\Closure $on_consume, \n    \\FFI\\CData|object|string|null $ic_opaque\n ): int\n</code></pre> <p>Append an on_consume() interceptor. </p> Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* - Client instance. ic_name <code>string|null</code> const char* - Interceptor name, used in logging. on_consume <code>\\FFI\\CData|\\Closure</code> rd_kafka_resp_err_t(rd_kafka_interceptor_f_on_consume_t*)(rd_kafka_t*, rd_kafka_message_t*, void*) - Function pointer. ic_opaque <code>\\FFI\\CData|object|string|null</code> void* - Opaque value that will be passed to the function. Returns <code>int</code> rd_kafka_resp_err_t - RD_KAFKA_RESP_ERR_NO_ERROR on success or RD_KAFKA_RESP_ERR__CONFLICT if an existing interceptor with the same <code>ic_name</code> and function has already been added to <code>conf</code>. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a0e722a9930897bba81b33de5fe95b6ed </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_interceptor_add_on_commit","title":"rd_kafka_interceptor_add_on_commit()","text":"<pre><code>public static rd_kafka_interceptor_add_on_commit ( \n    \\FFI\\CData|null $rk, \n    string|null $ic_name, \n    \\FFI\\CData|\\Closure $on_commit, \n    \\FFI\\CData|object|string|null $ic_opaque\n ): int\n</code></pre> <p>Append an on_commit() interceptor. </p> Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* - Client instance. ic_name <code>string|null</code> const char* - Interceptor name, used in logging. on_commit <code>\\FFI\\CData|\\Closure</code> rd_kafka_resp_err_t(rd_kafka_interceptor_f_on_commit_t*)(rd_kafka_t*, const rd_kafka_topic_partition_list_t*, rd_kafka_resp_err_t, void*) ic_opaque <code>\\FFI\\CData|object|string|null</code> void* - Opaque value that will be passed to the function. Returns <code>int</code> rd_kafka_resp_err_t - RD_KAFKA_RESP_ERR_NO_ERROR on success or RD_KAFKA_RESP_ERR__CONFLICT if an existing interceptor with the same <code>ic_name</code> and function has already been added to <code>conf</code>. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a0d3e29337dbf11762b5a7e492b77b781 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_interceptor_add_on_request_sent","title":"rd_kafka_interceptor_add_on_request_sent()","text":"<pre><code>public static rd_kafka_interceptor_add_on_request_sent ( \n    \\FFI\\CData|null $rk, \n    string|null $ic_name, \n    \\FFI\\CData|\\Closure $on_request_sent, \n    \\FFI\\CData|object|string|null $ic_opaque\n ): int\n</code></pre> <p>Append an on_request_sent() interceptor. </p> Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* - Client instance. ic_name <code>string|null</code> const char* - Interceptor name, used in logging. on_request_sent <code>\\FFI\\CData|\\Closure</code> rd_kafka_resp_err_t(rd_kafka_interceptor_f_on_request_sent_t*)(rd_kafka_t*, int, const char*, int32_t, int16_t, int16_t, int32_t, size_t, void*) ic_opaque <code>\\FFI\\CData|object|string|null</code> void* - Opaque value that will be passed to the function. Returns <code>int</code> rd_kafka_resp_err_t - RD_KAFKA_RESP_ERR_NO_ERROR on success or RD_KAFKA_RESP_ERR__CONFLICT if an existing interceptor with the same <code>ic_name</code> and function has already been added to <code>conf</code>. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a444032455f98839bef2fb76d15f663c3 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_topic_result_error","title":"rd_kafka_topic_result_error()","text":"<pre><code>public static rd_kafka_topic_result_error ( \n    \\FFI\\CData|null $topicres\n ): int\n</code></pre> <p>Topic result provides per-topic operation result information. </p> Parameters topicres <code>\\FFI\\CData|null</code> const rd_kafka_topic_result_t* - ) Returns <code>int</code> rd_kafka_resp_err_t - the error code for the given topic result. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a962bb4f4bcd8cf12a9aa9ef361ed7526 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_topic_result_error_string","title":"rd_kafka_topic_result_error_string()","text":"<pre><code>public static rd_kafka_topic_result_error_string ( \n    \\FFI\\CData|null $topicres\n ): string|null\n</code></pre> Remarkslifetime of the returned string is the same as the <code>topicres</code>.  Parameters topicres <code>\\FFI\\CData|null</code> const rd_kafka_topic_result_t* - ) Returns <code>string|null</code> const char* - the human readable error string for the given topic result, or NULL if there was no error. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a1e6596b6138eff2342da6e5c56ce9133 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_topic_result_name","title":"rd_kafka_topic_result_name()","text":"<pre><code>public static rd_kafka_topic_result_name ( \n    \\FFI\\CData|null $topicres\n ): string|null\n</code></pre> Remarkslifetime of the returned string is the same as the <code>topicres</code>.  Parameters topicres <code>\\FFI\\CData|null</code> const rd_kafka_topic_result_t* - ) Returns <code>string|null</code> const char* - the name of the topic for the given topic result. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a4073e9165eda071afc6f2af6a824e967 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_adminoptions_new","title":"rd_kafka_AdminOptions_new()","text":"<pre><code>public static rd_kafka_AdminOptions_new ( \n    \\FFI\\CData|null $rk, \n    int $for_api\n ): \\FFI\\CData|null\n</code></pre> <p>Create a new AdminOptions object. </p> <pre>   The options object is not modified by the Admin API request APIs,\n   (e.g. CreateTopics) and may be reused for multiple calls.\n\n</pre> Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* - Client instance. for_api <code>int</code> rd_kafka_admin_op_t - Specifies what Admin API this AdminOptions object will be used for, which will enforce what AdminOptions_set_..() calls may be used based on the API, causing unsupported set..() calls to fail. Specifying RD_KAFKA_ADMIN_OP_ANY disables the enforcement allowing any option to be set, even if the option is not used in a future call to an Admin API method. Returns <code>\\FFI\\CData|null</code> rd_kafka_AdminOptions_t* - a new AdminOptions object (which must be freed with rd_kafka_AdminOptions_destroy()), or NULL if <code>for_api</code> was set to an unknown API op type. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a685d10a84d9c230ea81545b280925483 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_adminoptions_destroy","title":"rd_kafka_AdminOptions_destroy()","text":"<pre><code>public static rd_kafka_AdminOptions_destroy ( \n    \\FFI\\CData|null $options\n ): void\n</code></pre> Parameters options <code>\\FFI\\CData|null</code> rd_kafka_AdminOptions_t*"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_adminoptions_set_request_timeout","title":"rd_kafka_AdminOptions_set_request_timeout()","text":"<pre><code>public static rd_kafka_AdminOptions_set_request_timeout ( \n    \\FFI\\CData|null $options, \n    int|null $timeout_ms, \n    \\FFI\\CData|null $errstr, \n    int|null $errstr_size\n ): int\n</code></pre> <p>Sets the overall request timeout, including broker lookup, request transmission, operation time on broker, and response. </p> RemarksThis option is valid for all Admin API requests.  Parameters options <code>\\FFI\\CData|null</code> rd_kafka_AdminOptions_t* - Admin options. timeout_ms <code>int|null</code> int - Timeout in milliseconds. Defaults to <code>socket.timeout.ms</code>. errstr <code>\\FFI\\CData|null</code> char* - A human readable error string (nul-terminated) is written to this location that must be of at least <code>errstr_size</code> bytes. The <code>errstr</code> is only written in case of error. - Writable size in <code>errstr</code>. errstr_size <code>int|null</code> size_t Returns <code>int</code> rd_kafka_resp_err_t - RD_KAFKA_RESP_ERR_NO_ERROR on success, or RD_KAFKA_RESP_ERR__INVALID_ARG if timeout was out of range in which case an error string will be written <code>errstr</code>. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a9988b9e9984f7c884e11176beac17d62 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_adminoptions_set_operation_timeout","title":"rd_kafka_AdminOptions_set_operation_timeout()","text":"<pre><code>public static rd_kafka_AdminOptions_set_operation_timeout ( \n    \\FFI\\CData|null $options, \n    int|null $timeout_ms, \n    \\FFI\\CData|null $errstr, \n    int|null $errstr_size\n ): int\n</code></pre> <p>Sets the broker's operation timeout, such as the timeout for CreateTopics to complete the creation of topics on the controller before returning a result to the application. </p> <p>CreateTopics: values &lt;= 0 will return immediately after triggering topic creation, while &gt; 0 will wait this long for topic creation to propagate in cluster. Default: 60 seconds.</p> <p>DeleteTopics: same semantics as CreateTopics. CreatePartitions: same semantics as CreateTopics.</p> RemarksThis option is valid for CreateTopics, DeleteTopics, CreatePartitions, and DeleteRecords.  Parameters options <code>\\FFI\\CData|null</code> rd_kafka_AdminOptions_t* - Admin options. timeout_ms <code>int|null</code> int - Timeout in milliseconds. errstr <code>\\FFI\\CData|null</code> char* - A human readable error string (nul-terminated) is written to this location that must be of at least <code>errstr_size</code> bytes. The <code>errstr</code> is only written in case of error. - Writable size in <code>errstr</code>. errstr_size <code>int|null</code> size_t Returns <code>int</code> rd_kafka_resp_err_t - RD_KAFKA_RESP_ERR_NO_ERROR on success, or RD_KAFKA_RESP_ERR__INVALID_ARG if timeout was out of range in which case an error string will be written <code>errstr</code>. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a708390fc4e94ea64a98009d294116d4c </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_adminoptions_set_validate_only","title":"rd_kafka_AdminOptions_set_validate_only()","text":"<pre><code>public static rd_kafka_AdminOptions_set_validate_only ( \n    \\FFI\\CData|null $options, \n    int|null $true_or_false, \n    \\FFI\\CData|null $errstr, \n    int|null $errstr_size\n ): int\n</code></pre> <p>Tell broker to only validate the request, without performing the requested operation (create topics, etc). </p> RemarksThis option is valid for CreateTopics, CreatePartitions, AlterConfigs.  Parameters options <code>\\FFI\\CData|null</code> rd_kafka_AdminOptions_t* - Admin options. true_or_false <code>int|null</code> int - Defaults to false. errstr <code>\\FFI\\CData|null</code> char* - A human readable error string (nul-terminated) is written to this location that must be of at least <code>errstr_size</code> bytes. The <code>errstr</code> is only written in case of error. - Writable size in <code>errstr</code>. errstr_size <code>int|null</code> size_t Returns <code>int</code> rd_kafka_resp_err_t - RD_KAFKA_RESP_ERR_NO_ERROR on success or an error code on failure in which case an error string will be written <code>errstr</code>. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ae94b1b0da81e43a4e928eea01952fb37 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_adminoptions_set_broker","title":"rd_kafka_AdminOptions_set_broker()","text":"<pre><code>public static rd_kafka_AdminOptions_set_broker ( \n    \\FFI\\CData|null $options, \n    int|null $broker_id, \n    \\FFI\\CData|null $errstr, \n    int|null $errstr_size\n ): int\n</code></pre> <p>Override what broker the Admin request will be sent to. </p> <p>By default, Admin requests are sent to the controller broker, with the following exceptions:</p> <ul> <li>AlterConfigs with a BROKER resource are sent to the broker id set as the resource name.</li> <li>IncrementalAlterConfigs with a BROKER resource are sent to the broker id set as the resource name.</li> <li>DescribeConfigs with a BROKER resource are sent to the broker id set as the resource name.</li> </ul> RemarksThis API should typically not be used, but serves as a workaround if new resource types are to the broker that the client does not know where to send.  Parameters options <code>\\FFI\\CData|null</code> rd_kafka_AdminOptions_t* - Admin Options. broker_id <code>int|null</code> int32_t - The broker to send the request to. errstr <code>\\FFI\\CData|null</code> char* - A human readable error string (nul-terminated) is written to this location that must be of at least <code>errstr_size</code> bytes. The <code>errstr</code> is only written in case of error. - Writable size in <code>errstr</code>. errstr_size <code>int|null</code> size_t Returns <code>int</code> rd_kafka_resp_err_t - RD_KAFKA_RESP_ERR_NO_ERROR on success or an error code on failure in which case an error string will be written <code>errstr</code>. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ae4a84f4fb6aaac8e09e186a7245a9727 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_adminoptions_set_opaque","title":"rd_kafka_AdminOptions_set_opaque()","text":"<pre><code>public static rd_kafka_AdminOptions_set_opaque ( \n    \\FFI\\CData|null $options, \n    \\FFI\\CData|object|string|null $opaque\n ): void\n</code></pre> Parameters options <code>\\FFI\\CData|null</code> rd_kafka_AdminOptions_t* opaque <code>\\FFI\\CData|object|string|null</code> void*"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_newtopic_new","title":"rd_kafka_NewTopic_new()","text":"<pre><code>public static rd_kafka_NewTopic_new ( \n    string|null $topic, \n    int|null $num_partitions, \n    int|null $replication_factor, \n    \\FFI\\CData|null $errstr, \n    int|null $errstr_size\n ): \\FFI\\CData|null\n</code></pre> <p>Create a new NewTopic object. This object is later passed to rd_kafka_CreateTopics(). </p> Parameters topic <code>string|null</code> const char* - Topic name to create. num_partitions <code>int|null</code> int - Number of partitions in topic, or -1 to use the broker\u2019s default partition count (&gt;= 2.4.0). replication_factor <code>int|null</code> int - Default replication factor for the topic\u2019s partitions, or -1 to use the broker\u2019s default replication factor (&gt;= 2.4.0) or if set_replica_assignment() will be used. errstr <code>\\FFI\\CData|null</code> char* - A human readable error string (nul-terminated) is written to this location that must be of at least <code>errstr_size</code> bytes. The <code>errstr</code> is only written in case of error. - Writable size in <code>errstr</code>. errstr_size <code>int|null</code> size_t Returns <code>\\FFI\\CData|null</code> rd_kafka_NewTopic_t* - a new allocated NewTopic object, or NULL if the input parameters are invalid. Use rd_kafka_NewTopic_destroy() to free object when done. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a9f172cd394d605c9fabca3959e101f8b </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_newtopic_destroy","title":"rd_kafka_NewTopic_destroy()","text":"<pre><code>public static rd_kafka_NewTopic_destroy ( \n    \\FFI\\CData|null $new_topic\n ): void\n</code></pre> Parameters new_topic <code>\\FFI\\CData|null</code> rd_kafka_NewTopic_t*"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_newtopic_destroy_array","title":"rd_kafka_NewTopic_destroy_array()","text":"<pre><code>public static rd_kafka_NewTopic_destroy_array ( \n    \\FFI\\CData|null $new_topics, \n    int|null $new_topic_cnt\n ): void\n</code></pre> Parameters new_topics <code>\\FFI\\CData|null</code> rd_kafka_NewTopic_t** new_topic_cnt <code>int|null</code> size_t"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_newtopic_set_replica_assignment","title":"rd_kafka_NewTopic_set_replica_assignment()","text":"<pre><code>public static rd_kafka_NewTopic_set_replica_assignment ( \n    \\FFI\\CData|null $new_topic, \n    int|null $partition, \n    \\FFI\\CData|null $broker_ids, \n    int|null $broker_id_cnt, \n    \\FFI\\CData|null $errstr, \n    int|null $errstr_size\n ): int\n</code></pre> <p>Set the replica (broker) assignment for <code>partition</code> to the replica set in <code>broker_ids</code> (of <code>broker_id_cnt</code> elements). </p> RemarksWhen this method is used, rd_kafka_NewTopic_new() must have been called with a <code>replication_factor</code> of -1.  An application must either set the replica assignment for all new partitions, or none.  If called, this function must be called consecutively for each partition, starting at 0.  Use rd_kafka_metadata() to retrieve the list of brokers in the cluster. See alsord_kafka_AdminOptions_set_validate_only()  Parameters new_topic <code>\\FFI\\CData|null</code> rd_kafka_NewTopic_t* partition <code>int|null</code> int32_t broker_ids <code>\\FFI\\CData|null</code> int32_t* broker_id_cnt <code>int|null</code> size_t errstr <code>\\FFI\\CData|null</code> char* errstr_size <code>int|null</code> size_t Returns <code>int</code> rd_kafka_resp_err_t - RD_KAFKA_RESP_ERR_NO_ERROR on success, or an error code if the arguments were invalid. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ade3dabb32c5e0ed5edcbc038a9345144 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_newtopic_set_config","title":"rd_kafka_NewTopic_set_config()","text":"<pre><code>public static rd_kafka_NewTopic_set_config ( \n    \\FFI\\CData|null $new_topic, \n    string|null $name, \n    string|null $value\n ): int\n</code></pre> <p>Set (broker-side) topic configuration name/value pair. </p> RemarksThe name and value are not validated by the client, the validation takes place on the broker. See alsord_kafka_AdminOptions_set_validate_only()   http://kafka.apache.org/documentation.html#topicconfigs  Parameters new_topic <code>\\FFI\\CData|null</code> rd_kafka_NewTopic_t* name <code>string|null</code> const char* value <code>string|null</code> const char* Returns <code>int</code> rd_kafka_resp_err_t - RD_KAFKA_RESP_ERR_NO_ERROR on success, or an error code if the arguments were invalid. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a29ae721839f76830e7f7b8ba5df64bed </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_createtopics","title":"rd_kafka_CreateTopics()","text":"<pre><code>public static rd_kafka_CreateTopics ( \n    \\FFI\\CData|null $rk, \n    \\FFI\\CData|null $new_topics, \n    int|null $new_topic_cnt, \n    \\FFI\\CData|null $options, \n    \\FFI\\CData|null $rkqu\n ): void\n</code></pre> <p>Create topics in cluster as specified by the <code>new_topics</code> array of size <code>new_topic_cnt</code> elements. </p> <p>Supported admin options:</p> <ul> <li>rd_kafka_AdminOptions_set_validate_only() - default false</li> <li>rd_kafka_AdminOptions_set_operation_timeout() - default 60 seconds</li> <li>rd_kafka_AdminOptions_set_request_timeout() - default socket.timeout.ms</li> </ul> RemarksThe result event type emitted on the supplied queue is of type <code>RD_KAFKA_EVENT_CREATETOPICS_RESULT</code> Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* - Client instance. new_topics <code>\\FFI\\CData|null</code> rd_kafka_NewTopic_t** - Array of new topics to create. new_topic_cnt <code>int|null</code> size_t - Number of elements in <code>new_topics</code> array. options <code>\\FFI\\CData|null</code> const rd_kafka_AdminOptions_t* - Optional admin options, or NULL for defaults. rkqu <code>\\FFI\\CData|null</code> rd_kafka_queue_t* - Queue to emit result on. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a6988b48e1a255fbb2badd6c6e11692f3 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_createtopics_result_topics","title":"rd_kafka_CreateTopics_result_topics()","text":"<pre><code>public static rd_kafka_CreateTopics_result_topics ( \n    \\FFI\\CData|null $result, \n    \\FFI\\CData|null $cntp\n ): \\FFI\\CData|null\n</code></pre> <p>Get an array of topic results from a CreateTopics result. </p> <p>The returned <code>topics</code> life-time is the same as the <code>result</code> object.</p> Parameters result <code>\\FFI\\CData|null</code> const rd_kafka_CreateTopics_result_t* - Result to get topics from. cntp <code>\\FFI\\CData|null</code> size_t* - Updated to the number of elements in the array. Returns <code>\\FFI\\CData|null</code> const rd_kafka_topic_result_t** <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a49451d78d3c7e5bd23367624c03897ea </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_deletetopic_new","title":"rd_kafka_DeleteTopic_new()","text":"<pre><code>public static rd_kafka_DeleteTopic_new ( \n    string|null $topic\n ): \\FFI\\CData|null\n</code></pre> <p>Create a new DeleteTopic object. This object is later passed to rd_kafka_DeleteTopics(). </p> Parameters topic <code>string|null</code> const char* - ) - Topic name to delete. Returns <code>\\FFI\\CData|null</code> rd_kafka_DeleteTopic_t* - a new allocated DeleteTopic object. Use rd_kafka_DeleteTopic_destroy() to free object when done. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a1e0a19934a857ca8b59ddbe8dbe24b0e </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_deletetopic_destroy","title":"rd_kafka_DeleteTopic_destroy()","text":"<pre><code>public static rd_kafka_DeleteTopic_destroy ( \n    \\FFI\\CData|null $del_topic\n ): void\n</code></pre> Parameters del_topic <code>\\FFI\\CData|null</code> rd_kafka_DeleteTopic_t*"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_deletetopic_destroy_array","title":"rd_kafka_DeleteTopic_destroy_array()","text":"<pre><code>public static rd_kafka_DeleteTopic_destroy_array ( \n    \\FFI\\CData|null $del_topics, \n    int|null $del_topic_cnt\n ): void\n</code></pre> Parameters del_topics <code>\\FFI\\CData|null</code> rd_kafka_DeleteTopic_t** del_topic_cnt <code>int|null</code> size_t"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_deletetopics","title":"rd_kafka_DeleteTopics()","text":"<pre><code>public static rd_kafka_DeleteTopics ( \n    \\FFI\\CData|null $rk, \n    \\FFI\\CData|null $del_topics, \n    int|null $del_topic_cnt, \n    \\FFI\\CData|null $options, \n    \\FFI\\CData|null $rkqu\n ): void\n</code></pre> <p>Delete topics from cluster as specified by the <code>topics</code> array of size <code>topic_cnt</code> elements. </p> RemarksThe result event type emitted on the supplied queue is of type <code>RD_KAFKA_EVENT_DELETETOPICS_RESULT</code> Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* - Client instance. del_topics <code>\\FFI\\CData|null</code> rd_kafka_DeleteTopic_t** - Array of topics to delete. del_topic_cnt <code>int|null</code> size_t - Number of elements in <code>topics</code> array. options <code>\\FFI\\CData|null</code> const rd_kafka_AdminOptions_t* - Optional admin options, or NULL for defaults. rkqu <code>\\FFI\\CData|null</code> rd_kafka_queue_t* - Queue to emit result on. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ae6f7fd92bb32f14c30bbcd22cbda2b4a </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_deletetopics_result_topics","title":"rd_kafka_DeleteTopics_result_topics()","text":"<pre><code>public static rd_kafka_DeleteTopics_result_topics ( \n    \\FFI\\CData|null $result, \n    \\FFI\\CData|null $cntp\n ): \\FFI\\CData|null\n</code></pre> <p>Get an array of topic results from a DeleteTopics result. </p> <p>The returned <code>topics</code> life-time is the same as the <code>result</code> object.</p> Parameters result <code>\\FFI\\CData|null</code> const rd_kafka_DeleteTopics_result_t* - Result to get topic results from. cntp <code>\\FFI\\CData|null</code> size_t* - is updated to the number of elements in the array. Returns <code>\\FFI\\CData|null</code> const rd_kafka_topic_result_t** <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aef97d0923f7e8cec4fbec9866d32614a </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_newpartitions_new","title":"rd_kafka_NewPartitions_new()","text":"<pre><code>public static rd_kafka_NewPartitions_new ( \n    string|null $topic, \n    int|null $new_total_cnt, \n    \\FFI\\CData|null $errstr, \n    int|null $errstr_size\n ): \\FFI\\CData|null\n</code></pre> <p>Create a new NewPartitions. This object is later passed to rd_kafka_CreatePartitions() to increase the number of partitions to <code>new_total_cnt</code> for an existing topic. </p> Parameters topic <code>string|null</code> const char* - Topic name to create more partitions for. new_total_cnt <code>int|null</code> size_t - Increase the topic\u2019s partition count to this value. errstr <code>\\FFI\\CData|null</code> char* - A human readable error string (nul-terminated) is written to this location that must be of at least <code>errstr_size</code> bytes. The <code>errstr</code> is only written in case of error. - Writable size in <code>errstr</code>. errstr_size <code>int|null</code> size_t Returns <code>\\FFI\\CData|null</code> rd_kafka_NewPartitions_t* - a new allocated NewPartitions object, or NULL if the input parameters are invalid. Use rd_kafka_NewPartitions_destroy() to free object when done. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#abdda69e9215a7e41d5b97cb7ed0c6bd3 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_newpartitions_destroy","title":"rd_kafka_NewPartitions_destroy()","text":"<pre><code>public static rd_kafka_NewPartitions_destroy ( \n    \\FFI\\CData|null $new_parts\n ): void\n</code></pre> Parameters new_parts <code>\\FFI\\CData|null</code> rd_kafka_NewPartitions_t*"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_newpartitions_destroy_array","title":"rd_kafka_NewPartitions_destroy_array()","text":"<pre><code>public static rd_kafka_NewPartitions_destroy_array ( \n    \\FFI\\CData|null $new_parts, \n    int|null $new_parts_cnt\n ): void\n</code></pre> Parameters new_parts <code>\\FFI\\CData|null</code> rd_kafka_NewPartitions_t** new_parts_cnt <code>int|null</code> size_t"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_newpartitions_set_replica_assignment","title":"rd_kafka_NewPartitions_set_replica_assignment()","text":"<pre><code>public static rd_kafka_NewPartitions_set_replica_assignment ( \n    \\FFI\\CData|null $new_parts, \n    int|null $new_partition_idx, \n    \\FFI\\CData|null $broker_ids, \n    int|null $broker_id_cnt, \n    \\FFI\\CData|null $errstr, \n    int|null $errstr_size\n ): int\n</code></pre> <p>Set the replica (broker id) assignment for <code>new_partition_idx</code> to the replica set in <code>broker_ids</code> (of <code>broker_id_cnt</code> elements). </p> RemarksAn application must either set the replica assignment for all new partitions, or none.  If called, this function must be called consecutively for each new partition being created, where <code>new_partition_idx</code> 0 is the first new partition, 1 is the second, and so on. <code>broker_id_cnt</code> should match the topic's replication factor.  Use rd_kafka_metadata() to retrieve the list of brokers in the cluster. See alsord_kafka_AdminOptions_set_validate_only()  Parameters new_parts <code>\\FFI\\CData|null</code> rd_kafka_NewPartitions_t* new_partition_idx <code>int|null</code> int32_t broker_ids <code>\\FFI\\CData|null</code> int32_t* broker_id_cnt <code>int|null</code> size_t errstr <code>\\FFI\\CData|null</code> char* errstr_size <code>int|null</code> size_t Returns <code>int</code> rd_kafka_resp_err_t - RD_KAFKA_RESP_ERR_NO_ERROR on success, or an error code if the arguments were invalid. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a6b38e8b7f3357844a7ef9b31cdc4af3c </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_createpartitions","title":"rd_kafka_CreatePartitions()","text":"<pre><code>public static rd_kafka_CreatePartitions ( \n    \\FFI\\CData|null $rk, \n    \\FFI\\CData|null $new_parts, \n    int|null $new_parts_cnt, \n    \\FFI\\CData|null $options, \n    \\FFI\\CData|null $rkqu\n ): void\n</code></pre> <p>Create additional partitions for the given topics, as specified by the <code>new_parts</code> array of size <code>new_parts_cnt</code> elements. </p> <p>Supported admin options:</p> <ul> <li>rd_kafka_AdminOptions_set_validate_only() - default false</li> <li>rd_kafka_AdminOptions_set_operation_timeout() - default 60 seconds</li> <li>rd_kafka_AdminOptions_set_request_timeout() - default socket.timeout.ms</li> </ul> RemarksThe result event type emitted on the supplied queue is of type <code>RD_KAFKA_EVENT_CREATEPARTITIONS_RESULT</code> Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* - Client instance. new_parts <code>\\FFI\\CData|null</code> rd_kafka_NewPartitions_t** - Array of topics for which new partitions are to be created. new_parts_cnt <code>int|null</code> size_t - Number of elements in <code>new_parts</code> array. options <code>\\FFI\\CData|null</code> const rd_kafka_AdminOptions_t* - Optional admin options, or NULL for defaults. rkqu <code>\\FFI\\CData|null</code> rd_kafka_queue_t* - Queue to emit result on. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a1bed8947475ee683033d7988f0b09378 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_createpartitions_result_topics","title":"rd_kafka_CreatePartitions_result_topics()","text":"<pre><code>public static rd_kafka_CreatePartitions_result_topics ( \n    \\FFI\\CData|null $result, \n    \\FFI\\CData|null $cntp\n ): \\FFI\\CData|null\n</code></pre> <p>Get an array of topic results from a CreatePartitions result. </p> <p>The returned <code>topics</code> life-time is the same as the <code>result</code> object.</p> Parameters result <code>\\FFI\\CData|null</code> const rd_kafka_CreatePartitions_result_t* - Result o get topic results from. cntp <code>\\FFI\\CData|null</code> size_t* - is updated to the number of elements in the array. Returns <code>\\FFI\\CData|null</code> const rd_kafka_topic_result_t** <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a2c2b415181b4e4d633d40a63ac01d681 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_configsource_name","title":"rd_kafka_ConfigSource_name()","text":"<pre><code>public static rd_kafka_ConfigSource_name ( \n    int $confsource\n ): string|null\n</code></pre> Parameters confsource <code>int</code> rd_kafka_ConfigSource_t - ) Returns <code>string|null</code> const char* - a string representation of the <code>confsource</code>. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ad946f1e500a4ce28ed9378d495586076 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_configentry_name","title":"rd_kafka_ConfigEntry_name()","text":"<pre><code>public static rd_kafka_ConfigEntry_name ( \n    \\FFI\\CData|null $entry\n ): string|null\n</code></pre> Parameters entry <code>\\FFI\\CData|null</code> const rd_kafka_ConfigEntry_t* - ) Returns <code>string|null</code> const char* - the configuration property name <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ad68d560b00fdbad3a1e994bc423791f6 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_configentry_value","title":"rd_kafka_ConfigEntry_value()","text":"<pre><code>public static rd_kafka_ConfigEntry_value ( \n    \\FFI\\CData|null $entry\n ): string|null\n</code></pre> Parameters entry <code>\\FFI\\CData|null</code> const rd_kafka_ConfigEntry_t* - ) Returns <code>string|null</code> const char* - the configuration value, may be NULL for sensitive or unset properties. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a744ffc08e0ad1a86e62fa4d4da956770 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_configentry_source","title":"rd_kafka_ConfigEntry_source()","text":"<pre><code>public static rd_kafka_ConfigEntry_source ( \n    \\FFI\\CData|null $entry\n ): int\n</code></pre> Parameters entry <code>\\FFI\\CData|null</code> const rd_kafka_ConfigEntry_t* - ) Returns <code>int</code> rd_kafka_ConfigSource_t - the config source. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aff8550b61387790dad381a6c1129d1b3 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_configentry_is_read_only","title":"rd_kafka_ConfigEntry_is_read_only()","text":"<pre><code>public static rd_kafka_ConfigEntry_is_read_only ( \n    \\FFI\\CData|null $entry\n ): int|null\n</code></pre> RemarksShall only be used on a DescribeConfigs result, otherwise returns -1.  Parameters entry <code>\\FFI\\CData|null</code> const rd_kafka_ConfigEntry_t* - ) Returns <code>int|null</code> int - 1 if the config property is read-only on the broker, else 0. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aa7474dc1258cceb041491d2b75e96bcb </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_configentry_is_default","title":"rd_kafka_ConfigEntry_is_default()","text":"<pre><code>public static rd_kafka_ConfigEntry_is_default ( \n    \\FFI\\CData|null $entry\n ): int|null\n</code></pre> RemarksShall only be used on a DescribeConfigs result, otherwise returns -1.  Parameters entry <code>\\FFI\\CData|null</code> const rd_kafka_ConfigEntry_t* - ) Returns <code>int|null</code> int - 1 if the config property is set to its default value on the broker, else 0. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#abd5a9f49896cff71788bae6cbd60fed9 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_configentry_is_sensitive","title":"rd_kafka_ConfigEntry_is_sensitive()","text":"<pre><code>public static rd_kafka_ConfigEntry_is_sensitive ( \n    \\FFI\\CData|null $entry\n ): int|null\n</code></pre> RemarksAn application should take care not to include the value of sensitive configuration entries in its output.   Shall only be used on a DescribeConfigs result, otherwise returns -1.  Parameters entry <code>\\FFI\\CData|null</code> const rd_kafka_ConfigEntry_t* - ) Returns <code>int|null</code> int - 1 if the config property contains sensitive information (such as security configuration), else 0. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a7cca5d473790759cb59b5fefdc992a02 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_configentry_is_synonym","title":"rd_kafka_ConfigEntry_is_synonym()","text":"<pre><code>public static rd_kafka_ConfigEntry_is_synonym ( \n    \\FFI\\CData|null $entry\n ): int|null\n</code></pre> Parameters entry <code>\\FFI\\CData|null</code> const rd_kafka_ConfigEntry_t* - ) Returns <code>int|null</code> int - 1 if this entry is a synonym, else 0. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a1a4c6d3323beb8546fb9c0f7d13b2abb </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_configentry_synonyms","title":"rd_kafka_ConfigEntry_synonyms()","text":"<pre><code>public static rd_kafka_ConfigEntry_synonyms ( \n    \\FFI\\CData|null $entry, \n    \\FFI\\CData|null $cntp\n ): \\FFI\\CData|null\n</code></pre> RemarksThe lifetime of the returned entry is the same as <code>conf</code> .   Shall only be used on a DescribeConfigs result, otherwise returns NULL.  Parameters entry <code>\\FFI\\CData|null</code> const rd_kafka_ConfigEntry_t* - Entry to get synonyms for. cntp <code>\\FFI\\CData|null</code> size_t* - is updated to the number of elements in the array. Returns <code>\\FFI\\CData|null</code> const rd_kafka_ConfigEntry_t** - the synonym config entry array. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8a9e60a1274f1889a6d20d8ac6ffb948 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_resourcetype_name","title":"rd_kafka_ResourceType_name()","text":"<pre><code>public static rd_kafka_ResourceType_name ( \n    int $restype\n ): string|null\n</code></pre> Parameters restype <code>int</code> rd_kafka_ResourceType_t - ) Returns <code>string|null</code> const char* - a string representation of the <code>restype</code> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ac026f797b199338b30a684087d2365f8 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_configresource_new","title":"rd_kafka_ConfigResource_new()","text":"<pre><code>public static rd_kafka_ConfigResource_new ( \n    int $restype, \n    string|null $resname\n ): \\FFI\\CData|null\n</code></pre> <p>Create new ConfigResource object. </p> Parameters restype <code>int</code> rd_kafka_ResourceType_t - The resource type (e.g., RD_KAFKA_RESOURCE_TOPIC) resname <code>string|null</code> const char* - The resource name (e.g., the topic name) Returns <code>\\FFI\\CData|null</code> rd_kafka_ConfigResource_t* - a newly allocated object <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#adedb3f1f695c5e5a90ee03fbdc7f6e4a </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_configresource_destroy","title":"rd_kafka_ConfigResource_destroy()","text":"<pre><code>public static rd_kafka_ConfigResource_destroy ( \n    \\FFI\\CData|null $config\n ): void\n</code></pre> Parameters config <code>\\FFI\\CData|null</code> rd_kafka_ConfigResource_t*"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_configresource_destroy_array","title":"rd_kafka_ConfigResource_destroy_array()","text":"<pre><code>public static rd_kafka_ConfigResource_destroy_array ( \n    \\FFI\\CData|null $config, \n    int|null $config_cnt\n ): void\n</code></pre> Parameters config <code>\\FFI\\CData|null</code> rd_kafka_ConfigResource_t** config_cnt <code>int|null</code> size_t"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_configresource_set_config","title":"rd_kafka_ConfigResource_set_config()","text":"<pre><code>public static rd_kafka_ConfigResource_set_config ( \n    \\FFI\\CData|null $config, \n    string|null $name, \n    string|null $value\n ): int\n</code></pre> <p>Set configuration name value pair. </p> <p>This will overwrite the current value.</p> Parameters config <code>\\FFI\\CData|null</code> rd_kafka_ConfigResource_t* - ConfigResource to set config property on. name <code>string|null</code> const char* - Configuration name, depends on resource type. value <code>string|null</code> const char* - Configuration value, depends on resource type and <code>name</code>. Set to <code>NULL</code> to revert configuration value to default. Returns <code>int</code> rd_kafka_resp_err_t - RD_KAFKA_RESP_ERR_NO_ERROR if config was added to resource, or RD_KAFKA_RESP_ERR__INVALID_ARG on invalid input. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#afbc1ffd0a5a938e6a9998365903010e5 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_configresource_configs","title":"rd_kafka_ConfigResource_configs()","text":"<pre><code>public static rd_kafka_ConfigResource_configs ( \n    \\FFI\\CData|null $config, \n    \\FFI\\CData|null $cntp\n ): \\FFI\\CData|null\n</code></pre> <p>Get an array of config entries from a ConfigResource object. </p> <p>The returned object life-times are the same as the <code>config</code> object.</p> Parameters config <code>\\FFI\\CData|null</code> const rd_kafka_ConfigResource_t* - ConfigResource to get configs from. cntp <code>\\FFI\\CData|null</code> size_t* - is updated to the number of elements in the array. Returns <code>\\FFI\\CData|null</code> const rd_kafka_ConfigEntry_t** <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a5e95b289deaebe43f7a73874e8428f4d </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_configresource_type","title":"rd_kafka_ConfigResource_type()","text":"<pre><code>public static rd_kafka_ConfigResource_type ( \n    \\FFI\\CData|null $config\n ): int\n</code></pre> Parameters config <code>\\FFI\\CData|null</code> const rd_kafka_ConfigResource_t* - ) Returns <code>int</code> rd_kafka_ResourceType_t - the ResourceType for <code>config</code> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#afb2a6e896b74d2f07246ede8269eb8f6 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_configresource_name","title":"rd_kafka_ConfigResource_name()","text":"<pre><code>public static rd_kafka_ConfigResource_name ( \n    \\FFI\\CData|null $config\n ): string|null\n</code></pre> Parameters config <code>\\FFI\\CData|null</code> const rd_kafka_ConfigResource_t* - ) Returns <code>string|null</code> const char* - the name for <code>config</code> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#af70880e690cb45ff728a331e7e40baac </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_configresource_error","title":"rd_kafka_ConfigResource_error()","text":"<pre><code>public static rd_kafka_ConfigResource_error ( \n    \\FFI\\CData|null $config\n ): int\n</code></pre> Parameters config <code>\\FFI\\CData|null</code> const rd_kafka_ConfigResource_t* - ) Returns <code>int</code> rd_kafka_resp_err_t - the error for this resource from an AlterConfigs request <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a6a4c8cf9e53472c30c6b1dd78e3ba560 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_configresource_error_string","title":"rd_kafka_ConfigResource_error_string()","text":"<pre><code>public static rd_kafka_ConfigResource_error_string ( \n    \\FFI\\CData|null $config\n ): string|null\n</code></pre> Parameters config <code>\\FFI\\CData|null</code> const rd_kafka_ConfigResource_t* - ) Returns <code>string|null</code> const char* - the error string for this resource from an AlterConfigs request, or NULL if no error. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a077c4a83e8b7fcf23057dad5a2af812f </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_alterconfigs","title":"rd_kafka_AlterConfigs()","text":"<pre><code>public static rd_kafka_AlterConfigs ( \n    \\FFI\\CData|null $rk, \n    \\FFI\\CData|null $configs, \n    int|null $config_cnt, \n    \\FFI\\CData|null $options, \n    \\FFI\\CData|null $rkqu\n ): void\n</code></pre> <p>Update the configuration for the specified resources. Updates are not transactional so they may succeed for a subset of the provided resources while the others fail. The configuration for a particular resource is updated atomically, replacing values using the provided ConfigEntrys and reverting unspecified ConfigEntrys to their default values. </p> RemarksRequires broker version &gt;=0.11.0.0 WarningAlterConfigs will replace all existing configuration for the provided resources with the new configuration given, reverting all other configuration to their default values. RemarksMultiple resources and resource types may be set, but at most one resource of type <code>RD_KAFKA_RESOURCE_BROKER</code> is allowed per call since these resource requests must be sent to the broker specified in the resource. Deprecated:Use rd_kafka_IncrementalAlterConfigs(). Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* configs <code>\\FFI\\CData|null</code> rd_kafka_ConfigResource_t** config_cnt <code>int|null</code> size_t options <code>\\FFI\\CData|null</code> const rd_kafka_AdminOptions_t* rkqu <code>\\FFI\\CData|null</code> rd_kafka_queue_t* <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ade8d161dfb86a94179d286f36ec5b28e </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_alterconfigs_result_resources","title":"rd_kafka_AlterConfigs_result_resources()","text":"<pre><code>public static rd_kafka_AlterConfigs_result_resources ( \n    \\FFI\\CData|null $result, \n    \\FFI\\CData|null $cntp\n ): \\FFI\\CData|null\n</code></pre> <p>Get an array of resource results from a AlterConfigs result. </p> <p>Use <code>rd_kafka_ConfigResource_error()</code> and <code>rd_kafka_ConfigResource_error_string()</code> to extract per-resource error results on the returned array elements.</p> <p>The returned object life-times are the same as the <code>result</code> object.</p> Parameters result <code>\\FFI\\CData|null</code> const rd_kafka_AlterConfigs_result_t* - Result object to get resource results from. cntp <code>\\FFI\\CData|null</code> size_t* - is updated to the number of elements in the array. Returns <code>\\FFI\\CData|null</code> const rd_kafka_ConfigResource_t** - an array of ConfigResource elements, or NULL if not available. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a7a8a2fdf3473111a84e14bcb0a88ef05 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_describeconfigs","title":"rd_kafka_DescribeConfigs()","text":"<pre><code>public static rd_kafka_DescribeConfigs ( \n    \\FFI\\CData|null $rk, \n    \\FFI\\CData|null $configs, \n    int|null $config_cnt, \n    \\FFI\\CData|null $options, \n    \\FFI\\CData|null $rkqu\n ): void\n</code></pre> <p>Get configuration for the specified resources in <code>configs</code>. </p> <p>The returned configuration includes default values and the rd_kafka_ConfigEntry_is_default() or rd_kafka_ConfigEntry_source() methods may be used to distinguish them from user supplied values.</p> <p>The value of config entries where rd_kafka_ConfigEntry_is_sensitive() is true will always be NULL to avoid disclosing sensitive information, such as security settings.</p> <p>Configuration entries where rd_kafka_ConfigEntry_is_read_only() is true can't be updated (with rd_kafka_AlterConfigs()).</p> <p>Synonym configuration entries are returned if the broker supports it (broker version &gt;= 1.1.0). See rd_kafka_ConfigEntry_synonyms().</p> RemarksRequires broker version &gt;=0.11.0.0  Multiple resources and resource types may be requested, but at most one resource of type <code>RD_KAFKA_RESOURCE_BROKER</code> is allowed per call since these resource requests must be sent to the broker specified in the resource.  Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* configs <code>\\FFI\\CData|null</code> rd_kafka_ConfigResource_t** config_cnt <code>int|null</code> size_t options <code>\\FFI\\CData|null</code> const rd_kafka_AdminOptions_t* rkqu <code>\\FFI\\CData|null</code> rd_kafka_queue_t* <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ac6c5d7be2cd16c6875ddc946c9918df2 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_describeconfigs_result_resources","title":"rd_kafka_DescribeConfigs_result_resources()","text":"<pre><code>public static rd_kafka_DescribeConfigs_result_resources ( \n    \\FFI\\CData|null $result, \n    \\FFI\\CData|null $cntp\n ): \\FFI\\CData|null\n</code></pre> <p>Get an array of resource results from a DescribeConfigs result. </p> <p>The returned <code>resources</code> life-time is the same as the <code>result</code> object.</p> Parameters result <code>\\FFI\\CData|null</code> const rd_kafka_DescribeConfigs_result_t* - Result object to get resource results from. cntp <code>\\FFI\\CData|null</code> size_t* - is updated to the number of elements in the array. Returns <code>\\FFI\\CData|null</code> const rd_kafka_ConfigResource_t** <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a1f8eb6562e32b2638d75ca22161ab185 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_conf","title":"rd_kafka_conf()","text":"<pre><code>public static rd_kafka_conf ( \n    \\FFI\\CData|null $rk\n ): \\FFI\\CData|null\n</code></pre> Remarksthe returned object is read-only and its lifetime is the same as the rd_kafka_t object.  Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* - ) Returns <code>\\FFI\\CData|null</code> const rd_kafka_conf_t* - the configuration object used by an rd_kafka_t instance. For use with rd_kafka_conf_get(), et.al., to extract configuration properties from a running client. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a71e233cd19b13572772df2d43074a97d </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_conf_set_oauthbearer_token_refresh_cb","title":"rd_kafka_conf_set_oauthbearer_token_refresh_cb()","text":"<pre><code>public static rd_kafka_conf_set_oauthbearer_token_refresh_cb ( \n    \\FFI\\CData|null $conf, \n    \\FFI\\CData|\\Closure $oauthbearer_token_refresh_cb\n ): void\n</code></pre> <p>Set SASL/OAUTHBEARER token refresh callback in provided conf object. </p> <p>The SASL/OAUTHBEARER token refresh callback is triggered via rd_kafka_poll() whenever OAUTHBEARER is the SASL mechanism and a token needs to be retrieved, typically based on the configuration defined in <code>sasl.oauthbearer.config</code>.</p> <p>The callback should invoke rd_kafka_oauthbearer_set_token() or rd_kafka_oauthbearer_set_token_failure() to indicate success or failure, respectively.</p> <p>The refresh operation is eventable and may be received via rd_kafka_queue_poll() with an event type of <code>RD_KAFKA_EVENT_OAUTHBEARER_TOKEN_REFRESH</code>.</p> <p>Note that before any SASL/OAUTHBEARER broker connection can succeed the application must call rd_kafka_oauthbearer_set_token() once \u2013 either directly or, more typically, by invoking either rd_kafka_poll(), rd_kafka_consumer_poll(), rd_kafka_queue_poll(), etc, in order to cause retrieval of an initial token to occur.</p> <p>Alternatively, the application can enable the SASL queue by calling rd_kafka_conf_enable_sasl_queue() on the configuration object prior to creating the client instance, get the SASL queue with rd_kafka_queue_get_sasl(), and either serve the queue manually by calling rd_kafka_queue_poll(), or redirecting the queue to the background thread to have the queue served automatically. For the latter case the SASL queue must be forwarded to the background queue with rd_kafka_queue_forward(). A convenience function is available to automatically forward the SASL queue to librdkafka's background thread, see rd_kafka_sasl_background_callbacks_enable().</p> <p>An unsecured JWT refresh handler is provided by librdkafka for development and testing purposes, it is enabled by setting the <code>enable.sasl.oauthbearer.unsecure.jwt</code> property to true and is mutually exclusive to using a refresh callback.</p> See alsord_kafka_sasl_background_callbacks_enable()   rd_kafka_queue_get_sasl()  Parameters conf <code>\\FFI\\CData|null</code> rd_kafka_conf_t* - the configuration to mutate. oauthbearer_token_refresh_cb <code>\\FFI\\CData|\\Closure</code> void()(rd_kafka_t, const char*, void*) - the callback to set; callback function arguments: <code>rk</code> - Kafka handle <code>oauthbearer_config</code> - Value of configuration property sasl.oauthbearer.config. <code>opaque</code> - Application-provided opaque set via rd_kafka_conf_set_opaque() <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a988395722598f63396d7a1bedb22adaf </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_conf_set_ssl_cert_verify_cb","title":"rd_kafka_conf_set_ssl_cert_verify_cb()","text":"<pre><code>public static rd_kafka_conf_set_ssl_cert_verify_cb ( \n    \\FFI\\CData|null $conf, \n    \\FFI\\CData|\\Closure $ssl_cert_verify_cb\n ): int\n</code></pre> <p>Sets the verification callback of the broker certificate. </p> <p>The verification callback is triggered from internal librdkafka threads upon connecting to a broker. On each connection attempt the callback will be called for each certificate in the broker's certificate chain, starting at the root certification, as long as the application callback returns 1 (valid certificate). <code>broker_name</code> and <code>broker_id</code> correspond to the broker the connection is being made to. The <code>x509_error</code> argument indicates if OpenSSL's verification of the certificate succeed (0) or failed (an OpenSSL error code). The application may set the SSL context error code by returning 0 from the verify callback and providing a non-zero SSL context error code in <code>x509_error</code>. If the verify callback sets <code>x509_error</code> to 0, returns 1, and the original <code>x509_error</code> was non-zero, the error on the SSL context will be cleared. <code>x509_error</code> is always a valid pointer to an int.</p> <p><code>depth</code> is the depth of the current certificate in the chain, starting at the root certificate.</p> <p>The certificate itself is passed in binary DER format in <code>buf</code> of size <code>size</code>.</p> <p>The callback must return 1 if verification succeeds, or 0 if verification fails and then write a human-readable error message to <code>errstr</code> (limited to <code>errstr_size</code> bytes, including nul-term).</p> <p>The callback's <code>opaque</code> argument is the opaque set with rd_kafka_conf_set_opaque().</p> WarningThis callback will be called from internal librdkafka threads. RemarksSee &lt;openssl/x509_vfy.h&gt; in the OpenSSL source distribution for a list of <code>x509_error</code> codes.  Parameters conf <code>\\FFI\\CData|null</code> rd_kafka_conf_t* ssl_cert_verify_cb <code>\\FFI\\CData|\\Closure</code> int()(rd_kafka_t, const char*, int32_t, int*, int, const char*, size_t, char*, size_t, void*) Returns <code>int</code> rd_kafka_conf_res_t - RD_KAFKA_CONF_OK if SSL is supported in this build, else RD_KAFKA_CONF_INVALID. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ae0b29e178bc565c9b8b3d5dfc60c18c5 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_conf_set_ssl_cert","title":"rd_kafka_conf_set_ssl_cert()","text":"<pre><code>public static rd_kafka_conf_set_ssl_cert ( \n    \\FFI\\CData|null $conf, \n    int $cert_type, \n    int $cert_enc, \n    \\FFI\\CData|object|string|null $buffer, \n    int|null $size, \n    \\FFI\\CData|null $errstr, \n    int|null $errstr_size\n ): int\n</code></pre> <p>Set certificate/key <code>cert_type</code> from the <code>cert_enc</code> encoded memory at <code>buffer</code> of <code>size</code> bytes. </p> RemarksCalling this method multiple times with the same <code>cert_type</code> will replace the previous value.  Calling this method with <code>buffer</code> set to NULL will clear the configuration for <code>cert_type</code>.  The private key may require a password, which must be specified with the <code>ssl.key.password</code> configuration property prior to calling this function.  Private and public keys in PEM format may also be set with the <code>ssl.key.pem</code> and <code>ssl.certificate.pem</code> configuration properties.  CA certificate in PEM format may also be set with the <code>ssl.ca.pem</code> configuration property.  When librdkafka is linked to OpenSSL 3.0 and the certificate is encoded using an obsolete cipher, it might be necessary to set up an OpenSSL configuration file to load the \"legacy\" provider and set the OPENSSL_CONF environment variable. See https://github.com/openssl/openssl/blob/master/README-PROVIDERS.md for more information.  Parameters conf <code>\\FFI\\CData|null</code> rd_kafka_conf_t* - Configuration object. cert_type <code>int</code> rd_kafka_cert_type_t - Certificate or key type to configure. cert_enc <code>int</code> rd_kafka_cert_enc_t - Buffer <code>encoding</code> type. buffer <code>\\FFI\\CData|object|string|null</code> const void* - Memory pointer to encoded certificate or key. The memory is not referenced after this function returns. size <code>int|null</code> size_t - Size of memory at <code>buffer</code>. errstr <code>\\FFI\\CData|null</code> char* - Memory were a human-readable error string will be written on failure. errstr_size <code>int|null</code> size_t - Size of <code>errstr</code>, including space for nul-terminator. Returns <code>int</code> rd_kafka_conf_res_t - RD_KAFKA_CONF_OK on success or RD_KAFKA_CONF_INVALID if the memory in <code>buffer</code> is of incorrect encoding, or if librdkafka was not built with SSL support. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a55fa4d223e6214b7be94a87f9985177a </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_event_config_string","title":"rd_kafka_event_config_string()","text":"<pre><code>public static rd_kafka_event_config_string ( \n    \\FFI\\CData|null $rkev\n ): string|null\n</code></pre> <p>The returned memory is read-only and its lifetime is the same as the event object.</p> <p>Event types:</p> <ul> <li>RD_KAFKA_EVENT_OAUTHBEARER_TOKEN_REFRESH: value of sasl.oauthbearer.config </li> </ul> Parameters rkev <code>\\FFI\\CData|null</code> rd_kafka_event_t* - ) Returns <code>string|null</code> const char* - the associated configuration string for the event, or NULL if the configuration property is not set or if not applicable for the given event type. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a7e1534cd509d7b233ba4b3d2efea5278 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_oauthbearer_set_token","title":"rd_kafka_oauthbearer_set_token()","text":"<pre><code>public static rd_kafka_oauthbearer_set_token ( \n    \\FFI\\CData|null $rk, \n    string|null $token_value, \n    int|null $md_lifetime_ms, \n    string|null $md_principal_name, \n    \\FFI\\CData|null $extensions, \n    int|null $extension_size, \n    \\FFI\\CData|null $errstr, \n    int|null $errstr_size\n ): int\n</code></pre> <p>Set SASL/OAUTHBEARER token and metadata. </p> <p>The SASL/OAUTHBEARER token refresh callback or event handler should invoke this method upon success. The extension keys must not include the reserved key \"`auth`\", and all extension keys and values must conform to the required format as per https://tools.ietf.org/html/rfc7628#section-3.1: </p> <pre>key            = 1*(ALPHA)\nvalue          = *(VCHAR / SP / HTAB / CR / LF )\n</pre> See alsord_kafka_oauthbearer_set_token_failure   rd_kafka_conf_set_oauthbearer_token_refresh_cb  Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* - Client instance. token_value <code>string|null</code> const char* - the mandatory token value to set, often (but not necessarily) a JWS compact serialization as per https://tools.ietf.org/html/rfc7515#section-3.1. md_lifetime_ms <code>int|null</code> int64_t - when the token expires, in terms of the number of milliseconds since the epoch. md_principal_name <code>string|null</code> const char* - the mandatory Kafka principal name associated with the token. extensions <code>\\FFI\\CData|null</code> const char** - optional SASL extensions key-value array with <code>extensions_size</code> elements (number of keys * 2), where [i] is the key and [i+1] is the key\u2019s value, to be communicated to the broker as additional key-value pairs during the initial client response as per https://tools.ietf.org/html/rfc7628#section-3.1. The key-value pairs are copied. extension_size <code>int|null</code> size_t - the number of SASL extension keys plus values, which must be a non-negative multiple of 2. errstr <code>\\FFI\\CData|null</code> char* - A human readable error string (nul-terminated) is written to this location that must be of at least <code>errstr_size</code> bytes. The <code>errstr</code> is only written in case of error. - Writable size in <code>errstr</code>. errstr_size <code>int|null</code> size_t Returns <code>int</code> rd_kafka_resp_err_t - <code>RD_KAFKA_RESP_ERR_NO_ERROR</code> on success, otherwise <code>errstr</code> set and: <code>RD_KAFKA_RESP_ERR__INVALID_ARG</code> if any of the arguments are invalid; <code>RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED</code> if SASL/OAUTHBEARER is not supported by this build; <code>RD_KAFKA_RESP_ERR__STATE</code> if SASL/OAUTHBEARER is supported but is not configured as the client\u2019s authentication mechanism. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a16d208d8ccfeee3d7084402ae24b641f </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_oauthbearer_set_token_failure","title":"rd_kafka_oauthbearer_set_token_failure()","text":"<pre><code>public static rd_kafka_oauthbearer_set_token_failure ( \n    \\FFI\\CData|null $rk, \n    string|null $errstr\n ): int\n</code></pre> <p>SASL/OAUTHBEARER token refresh failure indicator. </p> <p>The SASL/OAUTHBEARER token refresh callback or event handler should invoke this method upon failure.</p> See alsord_kafka_oauthbearer_set_token   rd_kafka_conf_set_oauthbearer_token_refresh_cb  Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* - Client instance. errstr <code>string|null</code> const char* - mandatory human readable error reason for failing to acquire a token. Returns <code>int</code> rd_kafka_resp_err_t - <code>RD_KAFKA_RESP_ERR_NO_ERROR</code> on success, otherwise: <code>RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED</code> if SASL/OAUTHBEARER is not supported by this build; <code>RD_KAFKA_RESP_ERR__STATE</code> if SASL/OAUTHBEARER is supported but is not configured as the client\u2019s authentication mechanism, <code>RD_KAFKA_RESP_ERR__INVALID_ARG</code> if no error string is supplied. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a5a88c547172a961cea4c854f01740ce8 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_interceptor_f_on_thread_start_t","title":"rd_kafka_interceptor_f_on_thread_start_t()","text":"<pre><code>public static rd_kafka_interceptor_f_on_thread_start_t ( \n    \\FFI\\CData|null $rk, \n    int $thread_type, \n    string|null $thread_name, \n    \\FFI\\CData|object|string|null $ic_opaque\n ): int\n</code></pre> <p>on_thread_start() is called from a newly created librdkafka-managed thread. </p> WarningThe on_thread_start() interceptor is called from internal librdkafka threads. An on_thread_start() interceptor MUST NOT call any librdkafka API's associated with the <code>rk</code>, or perform any blocking or prolonged work. Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* - The client instance. thread_type <code>int</code> rd_kafka_thread_type_t - Thread type. thread_name <code>string|null</code> const char* - Human-readable thread name, may not be unique. ic_opaque <code>\\FFI\\CData|object|string|null</code> void* - The interceptor\u2019s opaque pointer specified in ..add..(). Returns <code>int</code> rd_kafka_resp_err_t - an error code on failure, the error is logged but otherwise ignored. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aa882b123107dd0fecca114dea26a4c18 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_interceptor_f_on_thread_exit_t","title":"rd_kafka_interceptor_f_on_thread_exit_t()","text":"<pre><code>public static rd_kafka_interceptor_f_on_thread_exit_t ( \n    \\FFI\\CData|null $rk, \n    int $thread_type, \n    string|null $thread_name, \n    \\FFI\\CData|object|string|null $ic_opaque\n ): int\n</code></pre> <p>on_thread_exit() is called just prior to a librdkafka-managed thread exiting from the exiting thread itself. </p> RemarksDepending on the thread type, librdkafka may execute additional code on the thread after on_thread_exit() returns. WarningThe on_thread_exit() interceptor is called from internal librdkafka threads. An on_thread_exit() interceptor MUST NOT call any librdkafka API's associated with the <code>rk</code>, or perform any blocking or prolonged work. Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* - The client instance. thread_type <code>int</code> rd_kafka_thread_type_t - Thread type.n thread_name <code>string|null</code> const char* - Human-readable thread name, may not be unique. ic_opaque <code>\\FFI\\CData|object|string|null</code> void* - The interceptor\u2019s opaque pointer specified in ..add..(). Returns <code>int</code> rd_kafka_resp_err_t - an error code on failure, the error is logged but otherwise ignored. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ae89a2054959ba519c3851889ee69576c </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_interceptor_add_on_thread_start","title":"rd_kafka_interceptor_add_on_thread_start()","text":"<pre><code>public static rd_kafka_interceptor_add_on_thread_start ( \n    \\FFI\\CData|null $rk, \n    string|null $ic_name, \n    \\FFI\\CData|\\Closure $on_thread_start, \n    \\FFI\\CData|object|string|null $ic_opaque\n ): int\n</code></pre> <p>Append an on_thread_start() interceptor. </p> Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* - Client instance. ic_name <code>string|null</code> const char* - Interceptor name, used in logging. on_thread_start <code>\\FFI\\CData|\\Closure</code> rd_kafka_resp_err_t(rd_kafka_interceptor_f_on_thread_start_t*)(rd_kafka_t*, rd_kafka_thread_type_t, const char*, void*) ic_opaque <code>\\FFI\\CData|object|string|null</code> void* - Opaque value that will be passed to the function. Returns <code>int</code> rd_kafka_resp_err_t - RD_KAFKA_RESP_ERR_NO_ERROR on success or RD_KAFKA_RESP_ERR__CONFLICT if an existing interceptor with the same <code>ic_name</code> and function has already been added to <code>conf</code>. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aa46a3bd81acc3861979f43b63f7ea1c8 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_interceptor_add_on_thread_exit","title":"rd_kafka_interceptor_add_on_thread_exit()","text":"<pre><code>public static rd_kafka_interceptor_add_on_thread_exit ( \n    \\FFI\\CData|null $rk, \n    string|null $ic_name, \n    \\FFI\\CData|\\Closure $on_thread_exit, \n    \\FFI\\CData|object|string|null $ic_opaque\n ): int\n</code></pre> <p>Append an on_thread_exit() interceptor. </p> Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* - Client instance. ic_name <code>string|null</code> const char* - Interceptor name, used in logging. on_thread_exit <code>\\FFI\\CData|\\Closure</code> rd_kafka_resp_err_t(rd_kafka_interceptor_f_on_thread_exit_t*)(rd_kafka_t*, rd_kafka_thread_type_t, const char*, void*) ic_opaque <code>\\FFI\\CData|object|string|null</code> void* - Opaque value that will be passed to the function. Returns <code>int</code> rd_kafka_resp_err_t - RD_KAFKA_RESP_ERR_NO_ERROR on success or RD_KAFKA_RESP_ERR__CONFLICT if an existing interceptor with the same <code>ic_name</code> and function has already been added to <code>conf</code>. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a876a95f3d989ad7cbff048e3449674e6 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_mock_cluster_new","title":"rd_kafka_mock_cluster_new()","text":"<pre><code>public static rd_kafka_mock_cluster_new ( \n    \\FFI\\CData|null $rk, \n    int|null $broker_cnt\n ): \\FFI\\CData|null\n</code></pre> Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* broker_cnt <code>int|null</code> int Returns <code>\\FFI\\CData|null</code> rd_kafka_mock_cluster_t*"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_mock_cluster_destroy","title":"rd_kafka_mock_cluster_destroy()","text":"<pre><code>public static rd_kafka_mock_cluster_destroy ( \n    \\FFI\\CData|null $mcluster\n ): void\n</code></pre> Parameters mcluster <code>\\FFI\\CData|null</code> rd_kafka_mock_cluster_t*"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_mock_cluster_handle","title":"rd_kafka_mock_cluster_handle()","text":"<pre><code>public static rd_kafka_mock_cluster_handle ( \n    \\FFI\\CData|null $mcluster\n ): \\FFI\\CData|null\n</code></pre> Parameters mcluster <code>\\FFI\\CData|null</code> const rd_kafka_mock_cluster_t* Returns <code>\\FFI\\CData|null</code> rd_kafka_t*"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_mock_cluster_bootstraps","title":"rd_kafka_mock_cluster_bootstraps()","text":"<pre><code>public static rd_kafka_mock_cluster_bootstraps ( \n    \\FFI\\CData|null $mcluster\n ): string|null\n</code></pre> Parameters mcluster <code>\\FFI\\CData|null</code> const rd_kafka_mock_cluster_t* Returns <code>string|null</code> const char*"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_mock_push_request_errors","title":"rd_kafka_mock_push_request_errors()","text":"<pre><code>public static rd_kafka_mock_push_request_errors ( \n    \\FFI\\CData|null $mcluster, \n    int|null $ApiKey, \n    int|null $cnt, \n    mixed $args\n ): void\n</code></pre> Parameters mcluster <code>\\FFI\\CData|null</code> rd_kafka_mock_cluster_t* ApiKey <code>int|null</code> int16_t cnt <code>int|null</code> size_t args <code>mixed</code>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_mock_topic_set_error","title":"rd_kafka_mock_topic_set_error()","text":"<pre><code>public static rd_kafka_mock_topic_set_error ( \n    \\FFI\\CData|null $mcluster, \n    string|null $topic, \n    int $err\n ): void\n</code></pre> Parameters mcluster <code>\\FFI\\CData|null</code> rd_kafka_mock_cluster_t* topic <code>string|null</code> const char* err <code>int</code> rd_kafka_resp_err_t"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_mock_partition_set_leader","title":"rd_kafka_mock_partition_set_leader()","text":"<pre><code>public static rd_kafka_mock_partition_set_leader ( \n    \\FFI\\CData|null $mcluster, \n    string|null $topic, \n    int|null $partition, \n    int|null $broker_id\n ): int\n</code></pre> Parameters mcluster <code>\\FFI\\CData|null</code> rd_kafka_mock_cluster_t* topic <code>string|null</code> const char* partition <code>int|null</code> int32_t broker_id <code>int|null</code> int32_t Returns <code>int</code> rd_kafka_resp_err_t"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_mock_partition_set_follower","title":"rd_kafka_mock_partition_set_follower()","text":"<pre><code>public static rd_kafka_mock_partition_set_follower ( \n    \\FFI\\CData|null $mcluster, \n    string|null $topic, \n    int|null $partition, \n    int|null $broker_id\n ): int\n</code></pre> Parameters mcluster <code>\\FFI\\CData|null</code> rd_kafka_mock_cluster_t* topic <code>string|null</code> const char* partition <code>int|null</code> int32_t broker_id <code>int|null</code> int32_t Returns <code>int</code> rd_kafka_resp_err_t"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_mock_partition_set_follower_wmarks","title":"rd_kafka_mock_partition_set_follower_wmarks()","text":"<pre><code>public static rd_kafka_mock_partition_set_follower_wmarks ( \n    \\FFI\\CData|null $mcluster, \n    string|null $topic, \n    int|null $partition, \n    int|null $lo, \n    int|null $hi\n ): int\n</code></pre> Parameters mcluster <code>\\FFI\\CData|null</code> rd_kafka_mock_cluster_t* topic <code>string|null</code> const char* partition <code>int|null</code> int32_t lo <code>int|null</code> int64_t hi <code>int|null</code> int64_t Returns <code>int</code> rd_kafka_resp_err_t"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_mock_broker_set_rack","title":"rd_kafka_mock_broker_set_rack()","text":"<pre><code>public static rd_kafka_mock_broker_set_rack ( \n    \\FFI\\CData|null $mcluster, \n    int|null $broker_id, \n    string|null $rack\n ): int\n</code></pre> Parameters mcluster <code>\\FFI\\CData|null</code> rd_kafka_mock_cluster_t* broker_id <code>int|null</code> int32_t rack <code>string|null</code> const char* Returns <code>int</code> rd_kafka_resp_err_t"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_error_code","title":"rd_kafka_error_code()","text":"<pre><code>public static rd_kafka_error_code ( \n    \\FFI\\CData|null $error\n ): int\n</code></pre> Parameters error <code>\\FFI\\CData|null</code> const rd_kafka_error_t* - ) Returns <code>int</code> rd_kafka_resp_err_t - the error code for <code>error</code> or RD_KAFKA_RESP_ERR_NO_ERROR if <code>error</code> is NULL. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a6b4f430e5cc4f8b89ec23aaa5063b739 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_error_name","title":"rd_kafka_error_name()","text":"<pre><code>public static rd_kafka_error_name ( \n    \\FFI\\CData|null $error\n ): string|null\n</code></pre> RemarksThe lifetime of the returned pointer is the same as the error object. See alsord_kafka_err2name()  Parameters error <code>\\FFI\\CData|null</code> const rd_kafka_error_t* - ) Returns <code>string|null</code> const char* - the error code name for <code>error</code>, e.g, \u201cERR_UNKNOWN_MEMBER_ID\u201d, or an empty string if <code>error</code> is NULL. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a3b32c027854efbf7f52392019a15bc67 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_error_string","title":"rd_kafka_error_string()","text":"<pre><code>public static rd_kafka_error_string ( \n    \\FFI\\CData|null $error\n ): string|null\n</code></pre> RemarksThe lifetime of the returned pointer is the same as the error object.  Parameters error <code>\\FFI\\CData|null</code> const rd_kafka_error_t* - ) Returns <code>string|null</code> const char* - a human readable error string for <code>error</code>, or an empty string if <code>error</code> is NULL. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aea75812786d33b35175b3764e7a342df </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_error_is_fatal","title":"rd_kafka_error_is_fatal()","text":"<pre><code>public static rd_kafka_error_is_fatal ( \n    \\FFI\\CData|null $error\n ): int|null\n</code></pre> Parameters error <code>\\FFI\\CData|null</code> const rd_kafka_error_t* - ) Returns <code>int|null</code> int - 1 if the error is a fatal error, indicating that the client instance is no longer usable, else 0 (also if <code>error</code> is NULL). <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a97ba623d3eadd7f6b64800c31e28b2d2 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_error_is_retriable","title":"rd_kafka_error_is_retriable()","text":"<pre><code>public static rd_kafka_error_is_retriable ( \n    \\FFI\\CData|null $error\n ): int|null\n</code></pre> Parameters error <code>\\FFI\\CData|null</code> const rd_kafka_error_t* - ) Returns <code>int|null</code> int - 1 if the operation may be retried, else 0 (also if <code>error</code> is NULL). <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#acc4ee1ecb953e1a409528a99ab0c5451 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_error_txn_requires_abort","title":"rd_kafka_error_txn_requires_abort()","text":"<pre><code>public static rd_kafka_error_txn_requires_abort ( \n    \\FFI\\CData|null $error\n ): int|null\n</code></pre> RemarksThe return value of this method is only valid for errors returned by the transactional API.  Parameters error <code>\\FFI\\CData|null</code> const rd_kafka_error_t* - ) Returns <code>int|null</code> int - 1 if the error is an abortable transaction error in which case the application must call rd_kafka_abort_transaction() and start a new transaction with rd_kafka_begin_transaction() if it wishes to proceed with transactions. Else returns 0 (also if <code>error</code> is NULL). <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ab07a417d941737db523808dec1c488dd </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_error_destroy","title":"rd_kafka_error_destroy()","text":"<pre><code>public static rd_kafka_error_destroy ( \n    \\FFI\\CData|null $error\n ): void\n</code></pre> <p>Free and destroy an error object. </p> RemarksAs a conveniance it is permitted to pass a NULL <code>error</code>.  Parameters error <code>\\FFI\\CData|null</code> rd_kafka_error_t* - ) <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a3090ec84b9a8aa910d11f81f555d04da </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_error_new","title":"rd_kafka_error_new()","text":"<pre><code>public static rd_kafka_error_new ( \n    int $code, \n    string|null $fmt, \n    mixed $args\n ): \\FFI\\CData|null\n</code></pre> <p>Create a new error object with error <code>code</code> and optional human readable error string in <code>fmt</code>. </p> <p>This method is mainly to be used for mocking errors in application test code.</p> <p>The returned object must be destroyed with rd_kafka_error_destroy(). </p> Parameters code <code>int</code> rd_kafka_resp_err_t fmt <code>string|null</code> const char* args <code>mixed</code> Returns <code>\\FFI\\CData|null</code> rd_kafka_error_t* <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#afd0d2df97ab446896ccf4ea87f709809 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_msg_partitioner_fnv1a","title":"rd_kafka_msg_partitioner_fnv1a()","text":"<pre><code>public static rd_kafka_msg_partitioner_fnv1a ( \n    \\FFI\\CData|null $rkt, \n    \\FFI\\CData|object|string|null $key, \n    int|null $keylen, \n    int|null $partition_cnt, \n    \\FFI\\CData|object|string|null $rkt_opaque, \n    \\FFI\\CData|object|string|null $msg_opaque\n ): int|null\n</code></pre> <p>FNV-1a partitioner. </p> <p>Uses consistent hashing to map identical keys onto identical partitions using FNV-1a hashing.</p> <p>The <code>rkt_opaque</code> argument is the opaque set by rd_kafka_topic_conf_set_opaque(). The <code>msg_opaque</code> argument is the per-message opaque passed to produce().</p> Parameters rkt <code>\\FFI\\CData|null</code> const rd_kafka_topic_t* key <code>\\FFI\\CData|object|string|null</code> const void* keylen <code>int|null</code> size_t partition_cnt <code>int|null</code> int32_t rkt_opaque <code>\\FFI\\CData|object|string|null</code> void* msg_opaque <code>\\FFI\\CData|object|string|null</code> void* Returns <code>int|null</code> int32_t - a partition between 0 and <code>partition_cnt</code> - 1. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#abf216e03c718df36bb37e1affbc8c8f7 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_msg_partitioner_fnv1a_random","title":"rd_kafka_msg_partitioner_fnv1a_random()","text":"<pre><code>public static rd_kafka_msg_partitioner_fnv1a_random ( \n    \\FFI\\CData|null $rkt, \n    \\FFI\\CData|object|string|null $key, \n    int|null $keylen, \n    int|null $partition_cnt, \n    \\FFI\\CData|object|string|null $rkt_opaque, \n    \\FFI\\CData|object|string|null $msg_opaque\n ): int|null\n</code></pre> <p>Consistent-Random FNV-1a partitioner. </p> <p>Uses consistent hashing to map identical keys onto identical partitions using FNV-1a hashing. Messages without keys will be assigned via the random partitioner.</p> <p>The <code>rkt_opaque</code> argument is the opaque set by rd_kafka_topic_conf_set_opaque(). The <code>msg_opaque</code> argument is the per-message opaque passed to produce().</p> Parameters rkt <code>\\FFI\\CData|null</code> const rd_kafka_topic_t* key <code>\\FFI\\CData|object|string|null</code> const void* keylen <code>int|null</code> size_t partition_cnt <code>int|null</code> int32_t rkt_opaque <code>\\FFI\\CData|object|string|null</code> void* msg_opaque <code>\\FFI\\CData|object|string|null</code> void* Returns <code>int|null</code> int32_t - a partition between 0 and <code>partition_cnt</code> - 1. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ac6bbf5fabd7def78d9d0677af2d383b0 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_consumer_group_metadata","title":"rd_kafka_consumer_group_metadata()","text":"<pre><code>public static rd_kafka_consumer_group_metadata ( \n    \\FFI\\CData|null $rk\n ): \\FFI\\CData|null\n</code></pre> RemarksThe returned pointer must be freed by the application using rd_kafka_consumer_group_metadata_destroy(). See alsord_kafka_send_offsets_to_transaction()  Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* - ) Returns <code>\\FFI\\CData|null</code> rd_kafka_consumer_group_metadata_t* - the current consumer group metadata associated with this consumer, or NULL if <code>rk</code> is not a consumer configured with a <code>group.id</code>. This metadata object should be passed to the transactional producer\u2019s rd_kafka_send_offsets_to_transaction() API. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a167fe52efc68d470291bf17757b62c2e </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_consumer_group_metadata_new","title":"rd_kafka_consumer_group_metadata_new()","text":"<pre><code>public static rd_kafka_consumer_group_metadata_new ( \n    string|null $group_id\n ): \\FFI\\CData|null\n</code></pre> <p>Create a new consumer group metadata object. This is typically only used for writing tests. </p> RemarksThe returned pointer must be freed by the application using rd_kafka_consumer_group_metadata_destroy().  Parameters group_id <code>string|null</code> const char* - ) - The group id. Returns <code>\\FFI\\CData|null</code> rd_kafka_consumer_group_metadata_t* <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a30dc0292d9f172832451905fd6c28b22 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_consumer_group_metadata_destroy","title":"rd_kafka_consumer_group_metadata_destroy()","text":"<pre><code>public static rd_kafka_consumer_group_metadata_destroy ( \n    \\FFI\\CData|null $arg0\n ): void\n</code></pre> Parameters arg0 <code>\\FFI\\CData|null</code> rd_kafka_consumer_group_metadata_t*"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_consumer_group_metadata_write","title":"rd_kafka_consumer_group_metadata_write()","text":"<pre><code>public static rd_kafka_consumer_group_metadata_write ( \n    \\FFI\\CData|null $cgmd, \n    \\FFI\\CData|object|string|null $bufferp, \n    \\FFI\\CData|null $sizep\n ): \\FFI\\CData|null\n</code></pre> <p>Serialize the consumer group metadata to a binary format. This is mainly for client binding use and not for application use. </p> RemarksThe serialized metadata format is private and is not compatible across different versions or even builds of librdkafka. It should only be used in the same process runtime and must only be passed to rd_kafka_consumer_group_metadata_read(). See alsord_kafka_consumer_group_metadata_read()  Parameters cgmd <code>\\FFI\\CData|null</code> const rd_kafka_consumer_group_metadata_t* - Metadata to be serialized. bufferp <code>\\FFI\\CData|object|string|null</code> void** - On success this pointer will be updated to point to na allocated buffer containing the serialized metadata. The buffer must be freed with rd_kafka_mem_free(). sizep <code>\\FFI\\CData|null</code> size_t* - The pointed to size will be updated with the size of the serialized buffer. Returns <code>\\FFI\\CData|null</code> rd_kafka_error_t* - NULL on success or an error object on failure. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aef280384f33889a4dfe02d92186f5928 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_consumer_group_metadata_read","title":"rd_kafka_consumer_group_metadata_read()","text":"<pre><code>public static rd_kafka_consumer_group_metadata_read ( \n    \\FFI\\CData|null $cgmdp, \n    \\FFI\\CData|object|string|null $buffer, \n    int|null $size\n ): \\FFI\\CData|null\n</code></pre> <p>Reads serialized consumer group metadata and returns a consumer group metadata object. This is mainly for client binding use and not for application use. </p> RemarksThe serialized metadata format is private and is not compatible across different versions or even builds of librdkafka. It should only be used in the same process runtime and must only be passed to rd_kafka_consumer_group_metadata_read(). See alsord_kafka_consumer_group_metadata_write()  Parameters cgmdp <code>\\FFI\\CData|null</code> rd_kafka_consumer_group_metadata_t** - On success this pointer will be updated to point to a new consumer group metadata object which must be freed with rd_kafka_consumer_group_metadata_destroy(). buffer <code>\\FFI\\CData|object|string|null</code> const void* - Pointer to the serialized data. size <code>int|null</code> size_t - Size of the serialized data. Returns <code>\\FFI\\CData|null</code> rd_kafka_error_t* - NULL on success or an error object on failure. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ad3719a32498a270c04a48d64f2f301b3 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_init_transactions","title":"rd_kafka_init_transactions()","text":"<pre><code>public static rd_kafka_init_transactions ( \n    \\FFI\\CData|null $rk, \n    int|null $timeout_ms\n ): \\FFI\\CData|null\n</code></pre> <p>Initialize transactions for the producer instance. </p> <p>This function ensures any transactions initiated by previous instances of the producer with the same <code>transactional.id</code> are completed. If the previous instance failed with a transaction in progress the previous transaction will be aborted. This function needs to be called before any other transactional or produce functions are called when the <code>transactional.id</code> is configured.</p> <p>If the last transaction had begun completion (following transaction commit) but not yet finished, this function will await the previous transaction's completion.</p> <p>When any previous transactions have been fenced this function will acquire the internal producer id and epoch, used in all future transactional messages issued by this producer instance.</p> RemarksThis function may block up to <code>timeout_ms</code> milliseconds.  This call is resumable when a retriable timeout error is returned. Calling the function again will resume the operation that is progressing in the background. RemarksThe returned error object (if not NULL) must be destroyed with rd_kafka_error_destroy().  Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* - Producer instance. timeout_ms <code>int|null</code> int - The maximum time to block. On timeout the operation may continue in the background, depending on state, and it is okay to call init_transactions() again. If an infinite timeout (-1) is passed, the timeout will be adjusted to 2 * <code>transaction.timeout.ms</code>. Returns <code>\\FFI\\CData|null</code> rd_kafka_error_t* - NULL on success or an error object on failure. Check whether the returned error object permits retrying by calling rd_kafka_error_is_retriable(), or whether a fatal error has been raised by calling rd_kafka_error_is_fatal(). Error codes: RD_KAFKA_RESP_ERR__TIMED_OUT if the transaction coordinator could be not be contacted within <code>timeout_ms</code> (retriable), RD_KAFKA_RESP_ERR_COORDINATOR_NOT_AVAILABLE if the transaction coordinator is not available (retriable), RD_KAFKA_RESP_ERR_CONCURRENT_TRANSACTIONS if a previous transaction would not complete within <code>timeout_ms</code> (retriable), RD_KAFKA_RESP_ERR__STATE if transactions have already been started or upon fatal error, RD_KAFKA_RESP_ERR__UNSUPPORTED_FEATURE if the broker(s) do not support transactions (&lt;Apache Kafka 0.11), this also raises a fatal error, RD_KAFKA_RESP_ERR_INVALID_TRANSACTION_TIMEOUT if the configured <code>transaction.timeout.ms</code> is outside the broker-configured range, this also raises a fatal error, RD_KAFKA_RESP_ERR__NOT_CONFIGURED if transactions have not been configured for the producer instance, RD_KAFKA_RESP_ERR__INVALID_ARG if <code>rk</code> is not a producer instance, or <code>timeout_ms</code> is out of range. Other error codes not listed here may be returned, depending on broker version. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#abf3e48791cf53ac2c7e30a17ce896f74 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_begin_transaction","title":"rd_kafka_begin_transaction()","text":"<pre><code>public static rd_kafka_begin_transaction ( \n    \\FFI\\CData|null $rk\n ): \\FFI\\CData|null\n</code></pre> <p>Begin a new transaction. </p> <p>rd_kafka_init_transactions() must have been called successfully (once) before this function is called.</p> <p>Upon successful return from this function the application has to perform at least one of the following operations within <code>transaction.timeout.ms</code> to avoid timing out the transaction on the broker:</p> <ul> <li>rd_kafka_produce() (et.al)</li> <li>rd_kafka_send_offsets_to_transaction()</li> <li>rd_kafka_commit_transaction()</li> <li>rd_kafka_abort_transaction()</li> </ul> <p>Any messages produced, offsets sent (rd_kafka_send_offsets_to_transaction()), etc, after the successful return of this function will be part of the transaction and committed or aborted atomatically.</p> <p>Finish the transaction by calling rd_kafka_commit_transaction() or abort the transaction by calling rd_kafka_abort_transaction().</p> RemarksWith the transactional producer, rd_kafka_produce(), rd_kafka_producev(), et.al, are only allowed during an on-going transaction, as started with this function. Any produce call outside an on-going transaction, or for a failed transaction, will fail.  The returned error object (if not NULL) must be destroyed with rd_kafka_error_destroy().  Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* - ) - Producer instance. Returns <code>\\FFI\\CData|null</code> rd_kafka_error_t* - NULL on success or an error object on failure. Check whether a fatal error has been raised by calling rd_kafka_error_is_fatal(). Error codes: RD_KAFKA_RESP_ERR__STATE if a transaction is already in progress or upon fatal error, RD_KAFKA_RESP_ERR__NOT_CONFIGURED if transactions have not been configured for the producer instance, RD_KAFKA_RESP_ERR__INVALID_ARG if <code>rk</code> is not a producer instance. Other error codes not listed here may be returned, depending on broker version. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a3c5338866b641957e9eeeaa9b60f5f9c </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_send_offsets_to_transaction","title":"rd_kafka_send_offsets_to_transaction()","text":"<pre><code>public static rd_kafka_send_offsets_to_transaction ( \n    \\FFI\\CData|null $rk, \n    \\FFI\\CData|null $offsets, \n    \\FFI\\CData|null $cgmetadata, \n    int|null $timeout_ms\n ): \\FFI\\CData|null\n</code></pre> <p>Sends a list of topic partition offsets to the consumer group coordinator for <code>cgmetadata</code>, and marks the offsets as part part of the current transaction. These offsets will be considered committed only if the transaction is committed successfully. </p> <p>The offsets should be the next message your application will consume, i.e., the last processed message's offset + 1 for each partition. Either track the offsets manually during processing or use rd_kafka_position() (on the consumer) to get the current offsets for the partitions assigned to the consumer.</p> <p>Use this method at the end of a consume-transform-produce loop prior to committing the transaction with rd_kafka_commit_transaction().</p> RemarksThis function must be called on the transactional producer instance, not the consumer.  The consumer must disable auto commits (set <code>enable.auto.commit</code> to false on the consumer).  Logical and invalid offsets (such as RD_KAFKA_OFFSET_INVALID) in <code>offsets</code> will be ignored, if there are no valid offsets in <code>offsets</code> the function will return NULL and no action will be taken.  This call is retriable but not resumable, which means a new request with a new set of provided offsets and group metadata will be sent to the transaction coordinator if the call is retried.  It is highly recommended to retry the call (upon retriable error) with identical <code>offsets</code> and <code>cgmetadata</code> parameters. Failure to do so risks inconsistent state between what is actually included in the transaction and what the application thinks is included in the transaction. RemarksThe returned error object (if not NULL) must be destroyed with rd_kafka_error_destroy().  Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* - Producer instance. offsets <code>\\FFI\\CData|null</code> const rd_kafka_topic_partition_list_t* - List of offsets to commit to the consumer group upon successful commit of the transaction. Offsets should be the next message to consume, e.g., last processed message + 1. cgmetadata <code>\\FFI\\CData|null</code> const rd_kafka_consumer_group_metadata_t* - The current consumer group metadata as returned by rd_kafka_consumer_group_metadata() on the consumer instance the provided offsets were consumed from. timeout_ms <code>int|null</code> int - Maximum time allowed to register the offsets on the broker. Returns <code>\\FFI\\CData|null</code> rd_kafka_error_t* - NULL on success or an error object on failure. Check whether the returned error object permits retrying by calling rd_kafka_error_is_retriable(), or whether an abortable or fatal error has been raised by calling rd_kafka_error_txn_requires_abort() or rd_kafka_error_is_fatal() respectively. Error codes: RD_KAFKA_RESP_ERR__STATE if not currently in a transaction, RD_KAFKA_RESP_ERR_INVALID_PRODUCER_EPOCH if the current producer transaction has been fenced by a newer producer instance, RD_KAFKA_RESP_ERR_TRANSACTIONAL_ID_AUTHORIZATION_FAILED if the producer is no longer authorized to perform transactional operations, RD_KAFKA_RESP_ERR_GROUP_AUTHORIZATION_FAILED if the producer is not authorized to write the consumer offsets to the group coordinator, RD_KAFKA_RESP_ERR__NOT_CONFIGURED if transactions have not been configured for the producer instance, RD_KAFKA_RESP_ERR__INVALID_ARG if <code>rk</code> is not a producer instance, or if the <code>consumer_group_id</code> or <code>offsets</code> are empty. Other error codes not listed here may be returned, depending on broker version. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a288b31742a707ca14cf07312fbcca881 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_commit_transaction","title":"rd_kafka_commit_transaction()","text":"<pre><code>public static rd_kafka_commit_transaction ( \n    \\FFI\\CData|null $rk, \n    int|null $timeout_ms\n ): \\FFI\\CData|null\n</code></pre> <p>Commit the current transaction (as started with rd_kafka_begin_transaction()). </p> <p>Any outstanding messages will be flushed (delivered) before actually committing the transaction.</p> <p>If any of the outstanding messages fail permanently the current transaction will enter the abortable error state and this function will return an abortable error, in this case the application must call rd_kafka_abort_transaction() before attempting a new transaction with rd_kafka_begin_transaction().</p> RemarksIt is strongly recommended to always pass -1 (remaining transaction time) as the <code>timeout_ms</code>. Using other values risk internal state desynchronization in case any of the underlying protocol requests fail.  This function will block until all outstanding messages are delivered and the transaction commit request has been successfully handled by the transaction coordinator, or until <code>timeout_ms</code> expires, which ever comes first. On timeout the application may call the function again.  Will automatically call rd_kafka_flush() to ensure all queued messages are delivered before attempting to commit the transaction. If the application has enabled RD_KAFKA_EVENT_DR it must serve the event queue in a separate thread since rd_kafka_flush() will not serve delivery reports in this mode.  This call is resumable when a retriable timeout error is returned. Calling the function again will resume the operation that is progressing in the background. RemarksThe returned error object (if not NULL) must be destroyed with rd_kafka_error_destroy().  Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* - Producer instance. timeout_ms <code>int|null</code> int - The maximum time to block. On timeout the operation may continue in the background, depending on state, and it is okay to call this function again. Pass -1 to use the remaining transaction timeout, this is the recommended use. Returns <code>\\FFI\\CData|null</code> rd_kafka_error_t* - NULL on success or an error object on failure. Check whether the returned error object permits retrying by calling rd_kafka_error_is_retriable(), or whether an abortable or fatal error has been raised by calling rd_kafka_error_txn_requires_abort() or rd_kafka_error_is_fatal() respectively. Error codes: RD_KAFKA_RESP_ERR__STATE if not currently in a transaction, RD_KAFKA_RESP_ERR__TIMED_OUT if the transaction could not be complete commmitted within <code>timeout_ms</code>, this is a retriable error as the commit continues in the background, RD_KAFKA_RESP_ERR_INVALID_PRODUCER_EPOCH if the current producer transaction has been fenced by a newer producer instance, RD_KAFKA_RESP_ERR_TRANSACTIONAL_ID_AUTHORIZATION_FAILED if the producer is no longer authorized to perform transactional operations, RD_KAFKA_RESP_ERR__NOT_CONFIGURED if transactions have not been configured for the producer instance, RD_KAFKA_RESP_ERR__INVALID_ARG if <code>rk</code> is not a producer instance, Other error codes not listed here may be returned, depending on broker version. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a63a2d72bf9ba444bcea457bf47c4642a </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_abort_transaction","title":"rd_kafka_abort_transaction()","text":"<pre><code>public static rd_kafka_abort_transaction ( \n    \\FFI\\CData|null $rk, \n    int|null $timeout_ms\n ): \\FFI\\CData|null\n</code></pre> <p>Aborts the ongoing transaction. </p> <pre>   This function should also be used to recover from non-fatal abortable\n   transaction errors.\n\nAny outstanding messages will be purged and fail with\n   RD_KAFKA_RESP_ERR__PURGE_INFLIGHT or RD_KAFKA_RESP_ERR__PURGE_QUEUE.\n   See rd_kafka_purge() for details.\n</pre> RemarksIt is strongly recommended to always pass -1 (remaining transaction time) as the <code>timeout_ms</code>. Using other values risk internal state desynchronization in case any of the underlying protocol requests fail.  This function will block until all outstanding messages are purged and the transaction abort request has been successfully handled by the transaction coordinator, or until <code>timeout_ms</code> expires, which ever comes first. On timeout the application may call the function again. If the application has enabled RD_KAFKA_EVENT_DR it must serve the event queue in a separate thread since rd_kafka_flush() will not serve delivery reports in this mode.  This call is resumable when a retriable timeout error is returned. Calling the function again will resume the operation that is progressing in the background. RemarksThe returned error object (if not NULL) must be destroyed with rd_kafka_error_destroy().  Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* - Producer instance. timeout_ms <code>int|null</code> int - The maximum time to block. On timeout the operation may continue in the background, depending on state, and it is okay to call this function again. Pass -1 to use the remaining transaction timeout, this is the recommended use. Returns <code>\\FFI\\CData|null</code> rd_kafka_error_t* - NULL on success or an error object on failure. Check whether the returned error object permits retrying by calling rd_kafka_error_is_retriable(), or whether a fatal error has been raised by calling rd_kafka_error_is_fatal(). Error codes: RD_KAFKA_RESP_ERR__STATE if not currently in a transaction, RD_KAFKA_RESP_ERR__TIMED_OUT if the transaction could not be complete commmitted within <code>timeout_ms</code>, this is a retriable error as the commit continues in the background, RD_KAFKA_RESP_ERR_INVALID_PRODUCER_EPOCH if the current producer transaction has been fenced by a newer producer instance, RD_KAFKA_RESP_ERR_TRANSACTIONAL_ID_AUTHORIZATION_FAILED if the producer is no longer authorized to perform transactional operations, RD_KAFKA_RESP_ERR__NOT_CONFIGURED if transactions have not been configured for the producer instance, RD_KAFKA_RESP_ERR__INVALID_ARG if <code>rk</code> is not a producer instance, Other error codes not listed here may be returned, depending on broker version. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a2e50d1043e1b16ed28ba6e372aa0909d </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_handle_mock_cluster","title":"rd_kafka_handle_mock_cluster()","text":"<pre><code>public static rd_kafka_handle_mock_cluster ( \n    \\FFI\\CData|null $rk\n ): \\FFI\\CData|null\n</code></pre> Parameters rk <code>\\FFI\\CData|null</code> const rd_kafka_t* Returns <code>\\FFI\\CData|null</code> rd_kafka_mock_cluster_t*"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_mock_topic_create","title":"rd_kafka_mock_topic_create()","text":"<pre><code>public static rd_kafka_mock_topic_create ( \n    \\FFI\\CData|null $mcluster, \n    string|null $topic, \n    int|null $partition_cnt, \n    int|null $replication_factor\n ): int\n</code></pre> Parameters mcluster <code>\\FFI\\CData|null</code> rd_kafka_mock_cluster_t* topic <code>string|null</code> const char* partition_cnt <code>int|null</code> int replication_factor <code>int|null</code> int Returns <code>int</code> rd_kafka_resp_err_t"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_mock_broker_set_down","title":"rd_kafka_mock_broker_set_down()","text":"<pre><code>public static rd_kafka_mock_broker_set_down ( \n    \\FFI\\CData|null $mcluster, \n    int|null $broker_id\n ): int\n</code></pre> Parameters mcluster <code>\\FFI\\CData|null</code> rd_kafka_mock_cluster_t* broker_id <code>int|null</code> int32_t Returns <code>int</code> rd_kafka_resp_err_t"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_mock_broker_set_up","title":"rd_kafka_mock_broker_set_up()","text":"<pre><code>public static rd_kafka_mock_broker_set_up ( \n    \\FFI\\CData|null $mcluster, \n    int|null $broker_id\n ): int\n</code></pre> Parameters mcluster <code>\\FFI\\CData|null</code> rd_kafka_mock_cluster_t* broker_id <code>int|null</code> int32_t Returns <code>int</code> rd_kafka_resp_err_t"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_mock_coordinator_set","title":"rd_kafka_mock_coordinator_set()","text":"<pre><code>public static rd_kafka_mock_coordinator_set ( \n    \\FFI\\CData|null $mcluster, \n    string|null $key_type, \n    string|null $key, \n    int|null $broker_id\n ): int\n</code></pre> Parameters mcluster <code>\\FFI\\CData|null</code> rd_kafka_mock_cluster_t* key_type <code>string|null</code> const char* key <code>string|null</code> const char* broker_id <code>int|null</code> int32_t Returns <code>int</code> rd_kafka_resp_err_t"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_mock_set_apiversion","title":"rd_kafka_mock_set_apiversion()","text":"<pre><code>public static rd_kafka_mock_set_apiversion ( \n    \\FFI\\CData|null $mcluster, \n    int|null $ApiKey, \n    int|null $MinVersion, \n    int|null $MaxVersion\n ): int\n</code></pre> Parameters mcluster <code>\\FFI\\CData|null</code> rd_kafka_mock_cluster_t* ApiKey <code>int|null</code> int16_t MinVersion <code>int|null</code> int16_t MaxVersion <code>int|null</code> int16_t Returns <code>int</code> rd_kafka_resp_err_t"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_mock_broker_set_rtt","title":"rd_kafka_mock_broker_set_rtt()","text":"<pre><code>public static rd_kafka_mock_broker_set_rtt ( \n    \\FFI\\CData|null $mcluster, \n    int|null $broker_id, \n    int|null $rtt_ms\n ): int\n</code></pre> Parameters mcluster <code>\\FFI\\CData|null</code> rd_kafka_mock_cluster_t* broker_id <code>int|null</code> int32_t rtt_ms <code>int|null</code> int Returns <code>int</code> rd_kafka_resp_err_t"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_message_errstr","title":"rd_kafka_message_errstr()","text":"<pre><code>public static rd_kafka_message_errstr ( \n    \\FFI\\CData|null $rkmessage\n ): string|null\n</code></pre> <p>Returns the error string for an errored rd_kafka_message_t or NULL if there was no error. </p> RemarksThis function MUST NOT be used with the producer.  Parameters rkmessage <code>\\FFI\\CData|null</code> const rd_kafka_message_t* - ) Returns <code>string|null</code> const char* <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a5908f68997a5bc42695cff2a703618dd </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_message_broker_id","title":"rd_kafka_message_broker_id()","text":"<pre><code>public static rd_kafka_message_broker_id ( \n    \\FFI\\CData|null $rkmessage\n ): int|null\n</code></pre> <p>Returns the broker id of the broker the message was produced to or fetched from. </p> Parameters rkmessage <code>\\FFI\\CData|null</code> const rd_kafka_message_t* - ) Returns <code>int|null</code> int32_t - a broker id if known, else -1. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aa3ea50bbfa8d7fce4de91a34b1377b52 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_produceva","title":"rd_kafka_produceva()","text":"<pre><code>public static rd_kafka_produceva ( \n    \\FFI\\CData|null $rk, \n    \\FFI\\CData|null $vus, \n    int|null $cnt\n ): \\FFI\\CData|null\n</code></pre> <p>Produce and send a single message to broker. </p> <p>The message is defined by an array of <code>rd_kafka_vu_t</code> of count <code>cnt</code>.</p> See alsord_kafka_produce, rd_kafka_producev, RD_KAFKA_V_END  Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* vus <code>\\FFI\\CData|null</code> const rd_kafka_vu_t* cnt <code>int|null</code> size_t Returns <code>\\FFI\\CData|null</code> rd_kafka_error_t* - an error object on failure or NULL on success. See rd_kafka_producev() for specific error codes. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a267a7eabf933733e542902533141bd47 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_event_debug_contexts","title":"rd_kafka_event_debug_contexts()","text":"<pre><code>public static rd_kafka_event_debug_contexts ( \n    \\FFI\\CData|null $rkev, \n    \\FFI\\CData|null $dst, \n    int|null $dstsize\n ): int|null\n</code></pre> <p>Extract log debug context from event. </p> <p>Event types:</p> <ul> <li>RD_KAFKA_EVENT_LOG</li> </ul> Parameters rkev <code>\\FFI\\CData|null</code> rd_kafka_event_t* - the event to extract data from. dst <code>\\FFI\\CData|null</code> char* - destination string for comma separated list. dstsize <code>int|null</code> size_t - size of provided dst buffer. Returns <code>int|null</code> int - 0 on success or -1 if unsupported event type. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a5c43c8164c856aeb3f3170808264458b </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_mock_broker_push_request_errors","title":"rd_kafka_mock_broker_push_request_errors()","text":"<pre><code>public static rd_kafka_mock_broker_push_request_errors ( \n    \\FFI\\CData|null $mcluster, \n    int|null $broker_id, \n    int|null $ApiKey, \n    int|null $cnt, \n    mixed $args\n ): int\n</code></pre> Parameters mcluster <code>\\FFI\\CData|null</code> rd_kafka_mock_cluster_t* broker_id <code>int|null</code> int32_t ApiKey <code>int|null</code> int16_t cnt <code>int|null</code> size_t args <code>mixed</code> Returns <code>int</code> rd_kafka_resp_err_t"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_conf_get_default_topic_conf","title":"rd_kafka_conf_get_default_topic_conf()","text":"<pre><code>public static rd_kafka_conf_get_default_topic_conf ( \n    \\FFI\\CData|null $conf\n ): \\FFI\\CData|null\n</code></pre> <p>Gets the default topic configuration as previously set with rd_kafka_conf_set_default_topic_conf() or that was implicitly created by configuring a topic-level property on the global <code>conf</code> object. </p> WarningThe returned topic configuration object is owned by the <code>conf</code> object. It may be modified but not destroyed and its lifetime is the same as the <code>conf</code> object or the next call to rd_kafka_conf_set_default_topic_conf().  Parameters conf <code>\\FFI\\CData|null</code> rd_kafka_conf_t* - ) Returns <code>\\FFI\\CData|null</code> rd_kafka_topic_conf_t* - the <code>conf\u2019s</code> default topic configuration (if any), or NULL. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a622ed908e64c21ba53449216400109ee </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_queue_yield","title":"rd_kafka_queue_yield()","text":"<pre><code>public static rd_kafka_queue_yield ( \n    \\FFI\\CData|null $rkqu\n ): void\n</code></pre> <p>Cancels the current rd_kafka_queue_poll() on <code>rkqu</code>. </p> <p>An application may use this from another thread to force an immediate return to the calling code (caller of rd_kafka_queue_poll()). Must not be used from signal handlers since that may cause deadlocks. </p> Parameters rkqu <code>\\FFI\\CData|null</code> rd_kafka_queue_t* - ) <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#af3f15671034a8a5c6d9a3b33cc1b6f3f </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_seek_partitions","title":"rd_kafka_seek_partitions()","text":"<pre><code>public static rd_kafka_seek_partitions ( \n    \\FFI\\CData|null $rk, \n    \\FFI\\CData|null $partitions, \n    int|null $timeout_ms\n ): \\FFI\\CData|null\n</code></pre> <p>Seek consumer for partitions in <code>partitions</code> to the per-partition offset in the <code></code>.offset field of <code>partitions</code>. </p> <p>The offset may be either absolute (&gt;= 0) or a logical offset.</p> <p>If <code>timeout_ms</code> is specified (not 0) the seek call will wait this long for the consumer to update its fetcher state for the given partition with the new offset. This guarantees that no previously fetched messages for the old offset (or fetch position) will be passed to the application.</p> <p>If the timeout is reached the internal state will be unknown to the caller and this function returns <code>RD_KAFKA_RESP_ERR__TIMED_OUT</code>.</p> <p>If <code>timeout_ms</code> is 0 it will initiate the seek but return immediately without any error reporting (e.g., async).</p> <p>This call will purge all pre-fetched messages for the given partition, which may be up to <code>queued.max.message.kbytes</code> in size. Repeated use of seek may thus lead to increased network usage as messages are re-fetched from the broker.</p> <p>Individual partition errors are reported in the per-partition <code></code>.err field of <code>partitions</code>.</p> RemarksSeek must only be performed for already assigned/consumed partitions, use rd_kafka_assign() (et.al) to set the initial starting offset for a new assignmenmt. Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* partitions <code>\\FFI\\CData|null</code> rd_kafka_topic_partition_list_t* timeout_ms <code>int|null</code> int Returns <code>\\FFI\\CData|null</code> rd_kafka_error_t* - NULL on success or an error object on failure. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a7821331324eaab995d4a2baf42b78df5 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_incremental_assign","title":"rd_kafka_incremental_assign()","text":"<pre><code>public static rd_kafka_incremental_assign ( \n    \\FFI\\CData|null $rk, \n    \\FFI\\CData|null $partitions\n ): \\FFI\\CData|null\n</code></pre> <p>Incrementally add <code>partitions</code> to the current assignment. </p> <p>If a COOPERATIVE assignor (i.e. incremental rebalancing) is being used, this method should be used in a rebalance callback to adjust the current assignment appropriately in the case where the rebalance type is RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS. The application must pass the partition list passed to the callback (or a copy of it), even if the list is empty. <code>partitions</code> must not be NULL. This method may also be used outside the context of a rebalance callback.</p> RemarksThe returned error object (if not NULL) must be destroyed with rd_kafka_error_destroy().  Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* partitions <code>\\FFI\\CData|null</code> const rd_kafka_topic_partition_list_t* Returns <code>\\FFI\\CData|null</code> rd_kafka_error_t* - NULL on success, or an error object if the operation was unsuccessful. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a3bd9f42cf76b2a8cf2f4a4343abe8556 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_incremental_unassign","title":"rd_kafka_incremental_unassign()","text":"<pre><code>public static rd_kafka_incremental_unassign ( \n    \\FFI\\CData|null $rk, \n    \\FFI\\CData|null $partitions\n ): \\FFI\\CData|null\n</code></pre> <p>Incrementally remove <code>partitions</code> from the current assignment. </p> <p>If a COOPERATIVE assignor (i.e. incremental rebalancing) is being used, this method should be used in a rebalance callback to adjust the current assignment appropriately in the case where the rebalance type is RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS. The application must pass the partition list passed to the callback (or a copy of it), even if the list is empty. <code>partitions</code> must not be NULL. This method may also be used outside the context of a rebalance callback.</p> RemarksThe returned error object (if not NULL) must be destroyed with rd_kafka_error_destroy().  Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* partitions <code>\\FFI\\CData|null</code> const rd_kafka_topic_partition_list_t* Returns <code>\\FFI\\CData|null</code> rd_kafka_error_t* - NULL on success, or an error object if the operation was unsuccessful. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a27f7bd18e42ed44f33932c2f9b6a4192 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_rebalance_protocol","title":"rd_kafka_rebalance_protocol()","text":"<pre><code>public static rd_kafka_rebalance_protocol ( \n    \\FFI\\CData|null $rk\n ): string|null\n</code></pre> <p>The rebalance protocol currently in use. This will be \"NONE\" if the consumer has not (yet) joined a group, else it will match the rebalance protocol (\"EAGER\", \"COOPERATIVE\") of the configured and selected assignor(s). All configured assignors must have the same protocol type, meaning online migration of a consumer group from using one protocol to another (in particular upgading from EAGER to COOPERATIVE) without a restart is not currently supported. </p> Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* - ) Returns <code>string|null</code> const char* - NULL on error, or one of \u201cNONE\u201d, \u201cEAGER\u201d, \u201cCOOPERATIVE\u201d on success. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a57d367712406848d59cdaae97ab29354 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_assignment_lost","title":"rd_kafka_assignment_lost()","text":"<pre><code>public static rd_kafka_assignment_lost ( \n    \\FFI\\CData|null $rk\n ): int|null\n</code></pre> <p>Check whether the consumer considers the current assignment to have been lost involuntarily. This method is only applicable for use with a high level subscribing consumer. Assignments are revoked immediately when determined to have been lost, so this method is only useful when reacting to a RD_KAFKA_EVENT_REBALANCE event or from within a rebalance_cb. Partitions that have been lost may already be owned by other members in the group and therefore commiting offsets, for example, may fail. </p> RemarksCalling rd_kafka_assign(), rd_kafka_incremental_assign() or rd_kafka_incremental_unassign() resets this flag. Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* - ) Returns <code>int|null</code> int - Returns 1 if the current partition assignment is considered lost, 0 otherwise. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a5383a36bacd08e9ef52bfe29accb34a1 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_consumer_group_metadata_new_with_genid","title":"rd_kafka_consumer_group_metadata_new_with_genid()","text":"<pre><code>public static rd_kafka_consumer_group_metadata_new_with_genid ( \n    string|null $group_id, \n    int|null $generation_id, \n    string|null $member_id, \n    string|null $group_instance_id\n ): \\FFI\\CData|null\n</code></pre> <p>Create a new consumer group metadata object. This is typically only used for writing tests. </p> RemarksThe returned pointer must be freed by the application using rd_kafka_consumer_group_metadata_destroy().  Parameters group_id <code>string|null</code> const char* - The group id. generation_id <code>int|null</code> int32_t - The group generation id. member_id <code>string|null</code> const char* - The group member id. group_instance_id <code>string|null</code> const char* - The group instance id (may be NULL). Returns <code>\\FFI\\CData|null</code> rd_kafka_consumer_group_metadata_t* <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a679b7a0b807f69b72a4088bcee0e13c9 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_event_deleterecords_result","title":"rd_kafka_event_DeleteRecords_result()","text":"<pre><code>public static rd_kafka_event_DeleteRecords_result ( \n    \\FFI\\CData|null $rkev\n ): \\FFI\\CData|null\n</code></pre> <p>Event types: RD_KAFKA_EVENT_DELETERECORDS_RESULT </p> Parameters rkev <code>\\FFI\\CData|null</code> rd_kafka_event_t* - ) Returns <code>\\FFI\\CData|null</code> const rd_kafka_DeleteRecords_result_t* - the result of a DeleteRecords request, or NULL if event is of different type. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ad98fee7bec920114c73c1af90be53416 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_event_deletegroups_result","title":"rd_kafka_event_DeleteGroups_result()","text":"<pre><code>public static rd_kafka_event_DeleteGroups_result ( \n    \\FFI\\CData|null $rkev\n ): \\FFI\\CData|null\n</code></pre> <p>Get DeleteGroups result. </p> <p>Event types: RD_KAFKA_EVENT_DELETEGROUPS_RESULT </p> Parameters rkev <code>\\FFI\\CData|null</code> rd_kafka_event_t* - ) Returns <code>\\FFI\\CData|null</code> const rd_kafka_DeleteGroups_result_t* - the result of a DeleteGroups request, or NULL if event is of different type. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ad417e30a46183425d3549acb0a2c7e9f </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_event_deleteconsumergroupoffsets_result","title":"rd_kafka_event_DeleteConsumerGroupOffsets_result()","text":"<pre><code>public static rd_kafka_event_DeleteConsumerGroupOffsets_result ( \n    \\FFI\\CData|null $rkev\n ): \\FFI\\CData|null\n</code></pre> <p>Get DeleteConsumerGroupOffsets result. </p> <p>Event types: RD_KAFKA_EVENT_DELETECONSUMERGROUPOFFSETS_RESULT </p> Parameters rkev <code>\\FFI\\CData|null</code> rd_kafka_event_t* - ) Returns <code>\\FFI\\CData|null</code> const rd_kafka_DeleteConsumerGroupOffsets_result_t* - the result of a DeleteConsumerGroupOffsets request, or NULL if event is of different type. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a36ec38fe2135740ac6b41a4141fbc566 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_group_result_error","title":"rd_kafka_group_result_error()","text":"<pre><code>public static rd_kafka_group_result_error ( \n    \\FFI\\CData|null $groupres\n ): \\FFI\\CData|null\n</code></pre> <p>Group result provides per-group operation result information. </p> Remarkslifetime of the returned error is the same as the <code>groupres</code>.  Parameters groupres <code>\\FFI\\CData|null</code> const rd_kafka_group_result_t* - ) Returns <code>\\FFI\\CData|null</code> const rd_kafka_error_t* - the error for the given group result, or NULL on success. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a97cda56301d566204aad9320e2b748ba </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_group_result_name","title":"rd_kafka_group_result_name()","text":"<pre><code>public static rd_kafka_group_result_name ( \n    \\FFI\\CData|null $groupres\n ): string|null\n</code></pre> Remarkslifetime of the returned string is the same as the <code>groupres</code>.  Parameters groupres <code>\\FFI\\CData|null</code> const rd_kafka_group_result_t* - ) Returns <code>string|null</code> const char* - the name of the group for the given group result. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a7f8f41cfe01a2b977e4a2d54644e765d </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_group_result_partitions","title":"rd_kafka_group_result_partitions()","text":"<pre><code>public static rd_kafka_group_result_partitions ( \n    \\FFI\\CData|null $groupres\n ): \\FFI\\CData|null\n</code></pre> Remarkslifetime of the returned list is the same as the <code>groupres</code>.  Parameters groupres <code>\\FFI\\CData|null</code> const rd_kafka_group_result_t* - ) Returns <code>\\FFI\\CData|null</code> const rd_kafka_topic_partition_list_t* - the partitions/offsets for the given group result, if applicable to the request type, else NULL. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a5c039926ae9dca773ebec2f9147f2fa1 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_deleterecords_new","title":"rd_kafka_DeleteRecords_new()","text":"<pre><code>public static rd_kafka_DeleteRecords_new ( \n    \\FFI\\CData|null $before_offsets\n ): \\FFI\\CData|null\n</code></pre> <p>Create a new DeleteRecords object. This object is later passed to rd_kafka_DeleteRecords(). </p> <p><code>before_offsets</code> must contain <code>topic</code>, <code>partition</code>, and <code>offset</code> is the offset before which the messages will be deleted (exclusive). Set <code>offset</code> to RD_KAFKA_OFFSET_END (high-watermark) in order to delete all data in the partition.</p> Parameters before_offsets <code>\\FFI\\CData|null</code> const rd_kafka_topic_partition_list_t* - ) - For each partition delete all messages up to but not including the specified offset. Returns <code>\\FFI\\CData|null</code> rd_kafka_DeleteRecords_t* - a new allocated DeleteRecords object. Use rd_kafka_DeleteRecords_destroy() to free object when done. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#adbbe46dc5bfe86a3ead89c130b13d9f8 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_deleterecords_destroy","title":"rd_kafka_DeleteRecords_destroy()","text":"<pre><code>public static rd_kafka_DeleteRecords_destroy ( \n    \\FFI\\CData|null $del_records\n ): void\n</code></pre> Parameters del_records <code>\\FFI\\CData|null</code> rd_kafka_DeleteRecords_t*"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_deleterecords_destroy_array","title":"rd_kafka_DeleteRecords_destroy_array()","text":"<pre><code>public static rd_kafka_DeleteRecords_destroy_array ( \n    \\FFI\\CData|null $del_records, \n    int|null $del_record_cnt\n ): void\n</code></pre> Parameters del_records <code>\\FFI\\CData|null</code> rd_kafka_DeleteRecords_t** del_record_cnt <code>int|null</code> size_t"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_deleterecords","title":"rd_kafka_DeleteRecords()","text":"<pre><code>public static rd_kafka_DeleteRecords ( \n    \\FFI\\CData|null $rk, \n    \\FFI\\CData|null $del_records, \n    int|null $del_record_cnt, \n    \\FFI\\CData|null $options, \n    \\FFI\\CData|null $rkqu\n ): void\n</code></pre> <p>Delete records (messages) in topic partitions older than the offsets provided. </p> <p>Supported admin options:</p> <ul> <li>rd_kafka_AdminOptions_set_operation_timeout() - default 60 seconds. Controls how long the brokers will wait for records to be deleted.</li> <li>rd_kafka_AdminOptions_set_request_timeout() - default socket.timeout.ms. Controls how long <code>rdkafka</code> will wait for the request to complete.</li> </ul> RemarksThe result event type emitted on the supplied queue is of type <code>RD_KAFKA_EVENT_DELETERECORDS_RESULT</code> Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* - Client instance. del_records <code>\\FFI\\CData|null</code> rd_kafka_DeleteRecords_t** - The offsets to delete (up to). Currently only one DeleteRecords_t (but containing multiple offsets) is supported. del_record_cnt <code>int|null</code> size_t - The number of elements in del_records, must be 1. options <code>\\FFI\\CData|null</code> const rd_kafka_AdminOptions_t* - Optional admin options, or NULL for defaults. rkqu <code>\\FFI\\CData|null</code> rd_kafka_queue_t* - Queue to emit result on. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aad06345d1b4cd13e56d7253b889b2349 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_deleterecords_result_offsets","title":"rd_kafka_DeleteRecords_result_offsets()","text":"<pre><code>public static rd_kafka_DeleteRecords_result_offsets ( \n    \\FFI\\CData|null $result\n ): \\FFI\\CData|null\n</code></pre> <p>Get a list of topic and partition results from a DeleteRecords result. The returned objects will contain <code>topic</code>, <code>partition</code>, <code>offset</code> and <code>err</code>. <code>offset</code> will be set to the post-deletion low-watermark (smallest available offset of all live replicas). <code>err</code> will be set per-partition if deletion failed. </p> <p>The returned object's life-time is the same as the <code>result</code> object. </p> Parameters result <code>\\FFI\\CData|null</code> const rd_kafka_DeleteRecords_result_t* - ) Returns <code>\\FFI\\CData|null</code> const rd_kafka_topic_partition_list_t* <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ac894a0e005db1fa671c1802ba3563b69 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_deletegroup_new","title":"rd_kafka_DeleteGroup_new()","text":"<pre><code>public static rd_kafka_DeleteGroup_new ( \n    string|null $group\n ): \\FFI\\CData|null\n</code></pre> <p>Create a new DeleteGroup object. This object is later passed to rd_kafka_DeleteGroups(). </p> Parameters group <code>string|null</code> const char* - ) - Name of group to delete. Returns <code>\\FFI\\CData|null</code> rd_kafka_DeleteGroup_t* - a new allocated DeleteGroup object. Use rd_kafka_DeleteGroup_destroy() to free object when done. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a6c3bb6e2b05f40bed55ffdfe2b4daa59 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_deletegroup_destroy","title":"rd_kafka_DeleteGroup_destroy()","text":"<pre><code>public static rd_kafka_DeleteGroup_destroy ( \n    \\FFI\\CData|null $del_group\n ): void\n</code></pre> Parameters del_group <code>\\FFI\\CData|null</code> rd_kafka_DeleteGroup_t*"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_deletegroup_destroy_array","title":"rd_kafka_DeleteGroup_destroy_array()","text":"<pre><code>public static rd_kafka_DeleteGroup_destroy_array ( \n    \\FFI\\CData|null $del_groups, \n    int|null $del_group_cnt\n ): void\n</code></pre> Parameters del_groups <code>\\FFI\\CData|null</code> rd_kafka_DeleteGroup_t** del_group_cnt <code>int|null</code> size_t"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_deletegroups","title":"rd_kafka_DeleteGroups()","text":"<pre><code>public static rd_kafka_DeleteGroups ( \n    \\FFI\\CData|null $rk, \n    \\FFI\\CData|null $del_groups, \n    int|null $del_group_cnt, \n    \\FFI\\CData|null $options, \n    \\FFI\\CData|null $rkqu\n ): void\n</code></pre> <p>Delete groups from cluster as specified by the <code>del_groups</code> array of size <code>del_group_cnt</code> elements. </p> RemarksThe result event type emitted on the supplied queue is of type <code>RD_KAFKA_EVENT_DELETEGROUPS_RESULT</code>  This function in called deleteConsumerGroups in the Java client.  Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* - Client instance. del_groups <code>\\FFI\\CData|null</code> rd_kafka_DeleteGroup_t** - Array of groups to delete. del_group_cnt <code>int|null</code> size_t - Number of elements in <code>del_groups</code> array. options <code>\\FFI\\CData|null</code> const rd_kafka_AdminOptions_t* - Optional admin options, or NULL for defaults. rkqu <code>\\FFI\\CData|null</code> rd_kafka_queue_t* - Queue to emit result on. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#af929e4f20999b43d7bd3724502c1b27a </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_deletegroups_result_groups","title":"rd_kafka_DeleteGroups_result_groups()","text":"<pre><code>public static rd_kafka_DeleteGroups_result_groups ( \n    \\FFI\\CData|null $result, \n    \\FFI\\CData|null $cntp\n ): \\FFI\\CData|null\n</code></pre> <p>Get an array of group results from a DeleteGroups result. </p> <p>The returned groups life-time is the same as the <code>result</code> object.</p> Parameters result <code>\\FFI\\CData|null</code> const rd_kafka_DeleteGroups_result_t* - Result to get group results from. cntp <code>\\FFI\\CData|null</code> size_t* - is updated to the number of elements in the array. Returns <code>\\FFI\\CData|null</code> const rd_kafka_group_result_t** <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a20097b0ced17760c9aa624552dbf47e7 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_deleteconsumergroupoffsets_new","title":"rd_kafka_DeleteConsumerGroupOffsets_new()","text":"<pre><code>public static rd_kafka_DeleteConsumerGroupOffsets_new ( \n    string|null $group, \n    \\FFI\\CData|null $partitions\n ): \\FFI\\CData|null\n</code></pre> <p>Create a new DeleteConsumerGroupOffsets object. This object is later passed to rd_kafka_DeleteConsumerGroupOffsets(). </p> Parameters group <code>string|null</code> const char* - Consumer group id. partitions <code>\\FFI\\CData|null</code> const rd_kafka_topic_partition_list_t* - Partitions to delete committed offsets for. Only the topic and partition fields are used. Returns <code>\\FFI\\CData|null</code> rd_kafka_DeleteConsumerGroupOffsets_t* - a new allocated DeleteConsumerGroupOffsets object. Use rd_kafka_DeleteConsumerGroupOffsets_destroy() to free object when done. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8bb6df9dd6ce4e86dea385f90151d81f </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_deleteconsumergroupoffsets_destroy","title":"rd_kafka_DeleteConsumerGroupOffsets_destroy()","text":"<pre><code>public static rd_kafka_DeleteConsumerGroupOffsets_destroy ( \n    \\FFI\\CData|null $del_grpoffsets\n ): void\n</code></pre> Parameters del_grpoffsets <code>\\FFI\\CData|null</code> rd_kafka_DeleteConsumerGroupOffsets_t*"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_deleteconsumergroupoffsets_destroy_array","title":"rd_kafka_DeleteConsumerGroupOffsets_destroy_array()","text":"<pre><code>public static rd_kafka_DeleteConsumerGroupOffsets_destroy_array ( \n    \\FFI\\CData|null $del_grpoffsets, \n    int|null $del_grpoffset_cnt\n ): void\n</code></pre> Parameters del_grpoffsets <code>\\FFI\\CData|null</code> rd_kafka_DeleteConsumerGroupOffsets_t** del_grpoffset_cnt <code>int|null</code> size_t"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_deleteconsumergroupoffsets","title":"rd_kafka_DeleteConsumerGroupOffsets()","text":"<pre><code>public static rd_kafka_DeleteConsumerGroupOffsets ( \n    \\FFI\\CData|null $rk, \n    \\FFI\\CData|null $del_grpoffsets, \n    int|null $del_grpoffsets_cnt, \n    \\FFI\\CData|null $options, \n    \\FFI\\CData|null $rkqu\n ): void\n</code></pre> <p>Delete committed offsets for a set of partitions in a consumer group. This will succeed at the partition level only if the group is not actively subscribed to the corresponding topic. </p> RemarksThe result event type emitted on the supplied queue is of type <code>RD_KAFKA_EVENT_DELETECONSUMERGROUPOFFSETS_RESULT</code>  The current implementation only supports one group per invocation.  Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* - Client instance. del_grpoffsets <code>\\FFI\\CData|null</code> rd_kafka_DeleteConsumerGroupOffsets_t** - Array of group committed offsets to delete. MUST only be one single element. del_grpoffsets_cnt <code>int|null</code> size_t - Number of elements in <code>del_grpoffsets</code> array. MUST always be 1. options <code>\\FFI\\CData|null</code> const rd_kafka_AdminOptions_t* - Optional admin options, or NULL for defaults. rkqu <code>\\FFI\\CData|null</code> rd_kafka_queue_t* - Queue to emit result on. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#afa8e8de419157cf97a083b9355d3385f </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_deleteconsumergroupoffsets_result_groups","title":"rd_kafka_DeleteConsumerGroupOffsets_result_groups()","text":"<pre><code>public static rd_kafka_DeleteConsumerGroupOffsets_result_groups ( \n    \\FFI\\CData|null $result, \n    \\FFI\\CData|null $cntp\n ): \\FFI\\CData|null\n</code></pre> <p>Get an array of results from a DeleteConsumerGroupOffsets result. </p> <p>The returned groups life-time is the same as the <code>result</code> object.</p> Parameters result <code>\\FFI\\CData|null</code> const rd_kafka_DeleteConsumerGroupOffsets_result_t* - Result to get group results from. cntp <code>\\FFI\\CData|null</code> size_t* - is updated to the number of elements in the array. Returns <code>\\FFI\\CData|null</code> const rd_kafka_group_result_t** <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a014654eaec7601933e6ec5d5613ef4b0 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_mock_clear_request_errors","title":"rd_kafka_mock_clear_request_errors()","text":"<pre><code>public static rd_kafka_mock_clear_request_errors ( \n    \\FFI\\CData|null $mcluster, \n    int|null $ApiKey\n ): void\n</code></pre> Parameters mcluster <code>\\FFI\\CData|null</code> rd_kafka_mock_cluster_t* ApiKey <code>int|null</code> int16_t"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_mock_push_request_errors_array","title":"rd_kafka_mock_push_request_errors_array()","text":"<pre><code>public static rd_kafka_mock_push_request_errors_array ( \n    \\FFI\\CData|null $mcluster, \n    int|null $ApiKey, \n    int|null $cnt, \n    \\FFI\\CData|null $errors\n ): void\n</code></pre> Parameters mcluster <code>\\FFI\\CData|null</code> rd_kafka_mock_cluster_t* ApiKey <code>int|null</code> int16_t cnt <code>int|null</code> size_t errors <code>\\FFI\\CData|null</code> const rd_kafka_resp_err_t*"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_interceptor_f_on_response_received_t","title":"rd_kafka_interceptor_f_on_response_received_t()","text":"<pre><code>public static rd_kafka_interceptor_f_on_response_received_t ( \n    \\FFI\\CData|null $rk, \n    int|null $sockfd, \n    string|null $brokername, \n    int|null $brokerid, \n    int|null $ApiKey, \n    int|null $ApiVersion, \n    int|null $CorrId, \n    int|null $size, \n    int|null $rtt, \n    int $err, \n    \\FFI\\CData|object|string|null $ic_opaque\n ): int\n</code></pre> <p>on_response_received() is called when a protocol response has been fully received from a broker TCP connection socket but before the response payload is parsed. </p> WarningThe on_response_received() interceptor is called from internal librdkafka broker threads. An on_response_received() interceptor MUST NOT call any librdkafka API's associated with the <code>rk</code>, or perform any blocking or prolonged work. Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* - The client instance. sockfd <code>int|null</code> int - Socket file descriptor (always -1). brokername <code>string|null</code> const char* - Broker response was received from, possibly empty string on error. brokerid <code>int|null</code> int32_t - Broker response was received from. ApiKey <code>int|null</code> int16_t - Kafka protocol request type or -1 on error. ApiVersion <code>int|null</code> int16_t - Kafka protocol request type version or -1 on error. CorrId <code>int|null</code> int32_t - Kafka protocol request correlation id, possibly -1 on error. size <code>int|null</code> size_t - Size of response, possibly 0 on error. rtt <code>int|null</code> int64_t - Request round-trip-time in microseconds, possibly -1 on error. err <code>int</code> rd_kafka_resp_err_t - Receive error. ic_opaque <code>\\FFI\\CData|object|string|null</code> void* - The interceptor\u2019s opaque pointer specified in ..add..(). Returns <code>int</code> rd_kafka_resp_err_t - an error code on failure, the error is logged but otherwise ignored. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8e6b3f288085b2495cec22bc912265b9 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_interceptor_add_on_response_received","title":"rd_kafka_interceptor_add_on_response_received()","text":"<pre><code>public static rd_kafka_interceptor_add_on_response_received ( \n    \\FFI\\CData|null $rk, \n    string|null $ic_name, \n    \\FFI\\CData|\\Closure $on_response_received, \n    \\FFI\\CData|object|string|null $ic_opaque\n ): int\n</code></pre> <p>Append an on_response_received() interceptor. </p> Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* - Client instance. ic_name <code>string|null</code> const char* - Interceptor name, used in logging. on_response_received <code>\\FFI\\CData|\\Closure</code> rd_kafka_resp_err_t(rd_kafka_interceptor_f_on_response_received_t*)(rd_kafka_t*, int, const char*, int32_t, int16_t, int16_t, int32_t, size_t, int64_t, rd_kafka_resp_err_t, void*) ic_opaque <code>\\FFI\\CData|object|string|null</code> void* - Opaque value that will be passed to the function. Returns <code>int</code> rd_kafka_resp_err_t - RD_KAFKA_RESP_ERR_NO_ERROR on success or RD_KAFKA_RESP_ERR__CONFLICT if an existing interceptor with the same <code>ic_name</code> and function has already been added to <code>conf</code>. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a809061ceda162f8d8ad9663cabf66b3d </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_conf_set_engine_callback_data","title":"rd_kafka_conf_set_engine_callback_data()","text":"<pre><code>public static rd_kafka_conf_set_engine_callback_data ( \n    \\FFI\\CData|null $conf, \n    \\FFI\\CData|object|string|null $callback_data\n ): void\n</code></pre> <p>Set callback_data for OpenSSL engine. </p> RemarksThe <code>ssl.engine.location</code> configuration must be set for this to have affect.  The memory pointed to by <code>value</code> must remain valid for the lifetime of the configuration object and any Kafka clients that use it.  Parameters conf <code>\\FFI\\CData|null</code> rd_kafka_conf_t* - Configuration object. callback_data <code>\\FFI\\CData|object|string|null</code> void* - passed to engine callbacks, e.g. <code>ENGINE_load_ssl_client_cert</code>. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a07871a230226c6acbdf3cd062545812b </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_mem_calloc","title":"rd_kafka_mem_calloc()","text":"<pre><code>public static rd_kafka_mem_calloc ( \n    \\FFI\\CData|null $rk, \n    int|null $num, \n    int|null $size\n ): \\FFI\\CData|object|string|null\n</code></pre> <p>Allocate and zero memory using the same allocator librdkafka uses. </p> <p>This is typically an abstraction for the calloc(3) call and makes sure the application can use the same memory allocator as librdkafka for allocating pointers that are used by librdkafka.</p> <p><code>rk</code> can be set to return memory allocated by a specific <code>rk</code> instance otherwise pass NULL for <code>rk</code>.</p> RemarksMemory allocated by rd_kafka_mem_calloc() must be freed using rd_kafka_mem_free()  Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* num <code>int|null</code> size_t size <code>int|null</code> size_t Returns <code>\\FFI\\CData|object|string|null</code> void* <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a74216ba5f5d1c1d8ec7936c225a73286 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_mem_malloc","title":"rd_kafka_mem_malloc()","text":"<pre><code>public static rd_kafka_mem_malloc ( \n    \\FFI\\CData|null $rk, \n    int|null $size\n ): \\FFI\\CData|object|string|null\n</code></pre> <p>Allocate memory using the same allocator librdkafka uses. </p> <p>This is typically an abstraction for the malloc(3) call and makes sure the application can use the same memory allocator as librdkafka for allocating pointers that are used by librdkafka.</p> <p><code>rk</code> can be set to return memory allocated by a specific <code>rk</code> instance otherwise pass NULL for <code>rk</code>.</p> RemarksMemory allocated by rd_kafka_mem_malloc() must be freed using rd_kafka_mem_free()  Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* size <code>int|null</code> size_t Returns <code>\\FFI\\CData|object|string|null</code> void* <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a60f3ac40bed72542f68c93fa1bc16d3e </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_mock_broker_push_request_error_rtts","title":"rd_kafka_mock_broker_push_request_error_rtts()","text":"<pre><code>public static rd_kafka_mock_broker_push_request_error_rtts ( \n    \\FFI\\CData|null $mcluster, \n    int|null $broker_id, \n    int|null $ApiKey, \n    int|null $cnt, \n    mixed $args\n ): int\n</code></pre> Parameters mcluster <code>\\FFI\\CData|null</code> rd_kafka_mock_cluster_t* broker_id <code>int|null</code> int32_t ApiKey <code>int|null</code> int16_t cnt <code>int|null</code> size_t args <code>mixed</code> Returns <code>int</code> rd_kafka_resp_err_t"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_conf_enable_sasl_queue","title":"rd_kafka_conf_enable_sasl_queue()","text":"<pre><code>public static rd_kafka_conf_enable_sasl_queue ( \n    \\FFI\\CData|null $conf, \n    int|null $enable\n ): void\n</code></pre> <p>Enable/disable creation of a queue specific to SASL events and callbacks. </p> <p>For SASL mechanisms that trigger callbacks (currently OAUTHBEARER) this configuration API allows an application to get a dedicated queue for the SASL events/callbacks. After enabling the queue with this API the application can retrieve the queue by calling rd_kafka_queue_get_sasl() on the client instance. This queue may then be served directly by the application (with rd_kafka_queue_poll(), et.al) or forwarded to another queue, such as the background queue.</p> <p>A convenience function is available to automatically forward the SASL queue to librdkafka's background thread, see rd_kafka_sasl_background_callbacks_enable().</p> <p>By default (<code>enable</code> = 0) the main queue (as served by rd_kafka_poll(), et.al.) is used for SASL callbacks.</p> RemarksThe SASL queue is currently only used by the SASL OAUTHBEARER mechanism's token_refresh_cb(). See alsord_kafka_queue_get_sasl()   rd_kafka_sasl_background_callbacks_enable()  Parameters conf <code>\\FFI\\CData|null</code> rd_kafka_conf_t* enable <code>int|null</code> int <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ad01f5e5a40eaebf133db5a2858198fbd </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_queue_get_sasl","title":"rd_kafka_queue_get_sasl()","text":"<pre><code>public static rd_kafka_queue_get_sasl ( \n    \\FFI\\CData|null $rk\n ): \\FFI\\CData|null\n</code></pre> <p>Use rd_kafka_queue_destroy() to loose the reference.</p> See alsord_kafka_sasl_background_callbacks_enable()  Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* - ) Returns <code>\\FFI\\CData|null</code> rd_kafka_queue_t* - a reference to the SASL callback queue, if a SASL mechanism with callbacks is configured (currently only OAUTHBEARER), else returns NULL. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a56d2a479cb1e2fb540db1f25f45b7ece </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_sasl_background_callbacks_enable","title":"rd_kafka_sasl_background_callbacks_enable()","text":"<pre><code>public static rd_kafka_sasl_background_callbacks_enable ( \n    \\FFI\\CData|null $rk\n ): \\FFI\\CData|null\n</code></pre> <p>Enable SASL OAUTHBEARER refresh callbacks on the librdkafka background thread. </p> <p>This serves as an alternative for applications that do not call rd_kafka_poll() (et.al.) at regular intervals (or not at all), as a means of automatically trigger the refresh callbacks, which are needed to initiate connections to the brokers in the case a custom OAUTHBEARER refresh callback is configured.</p> See alsord_kafka_queue_get_sasl()   rd_kafka_conf_set_oauthbearer_token_refresh_cb()  Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* - ) Returns <code>\\FFI\\CData|null</code> rd_kafka_error_t* - NULL on success or an error object on error. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a383a661dc45191bccb3a2b50adbbfcdb </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_consumer_close_queue","title":"rd_kafka_consumer_close_queue()","text":"<pre><code>public static rd_kafka_consumer_close_queue ( \n    \\FFI\\CData|null $rk, \n    \\FFI\\CData|null $rkqu\n ): \\FFI\\CData|null\n</code></pre> <p>Asynchronously close the consumer. </p> <p>Performs the same actions as rd_kafka_consumer_close() but in a background thread.</p> <p>Rebalance events/callbacks (etc) will be forwarded to the application-provided <code>rkqu</code>. The application must poll/serve this queue until rd_kafka_consumer_closed() returns true.</p> RemarksDepending on consumer group join state there may or may not be rebalance events emitted on <code>rkqu</code>. See alsord_kafka_consumer_closed()  Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* rkqu <code>\\FFI\\CData|null</code> rd_kafka_queue_t* Returns <code>\\FFI\\CData|null</code> rd_kafka_error_t* - an error object if the consumer close failed, else NULL. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a9dd5c18bdfed81c8847b259f0a8d498d </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_consumer_closed","title":"rd_kafka_consumer_closed()","text":"<pre><code>public static rd_kafka_consumer_closed ( \n    \\FFI\\CData|null $rk\n ): int|null\n</code></pre> <p>Should be used in conjunction with rd_kafka_consumer_close_queue() to know when the consumer has been closed.</p> See alsord_kafka_consumer_close_queue()  Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* - ) Returns <code>int|null</code> int - 1 if the consumer is closed, else 0. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a88197205c61ed98b99f6442551a5e94f </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_event_createacls_result","title":"rd_kafka_event_CreateAcls_result()","text":"<pre><code>public static rd_kafka_event_CreateAcls_result ( \n    \\FFI\\CData|null $rkev\n ): \\FFI\\CData|null\n</code></pre> <p>Event types: RD_KAFKA_EVENT_CREATEACLS_RESULT </p> Parameters rkev <code>\\FFI\\CData|null</code> rd_kafka_event_t* - ) Returns <code>\\FFI\\CData|null</code> const rd_kafka_CreateAcls_result_t* - the result of a CreateAcls request, or NULL if event is of different type. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aa605a0d0500ccb783ed7da23670075d9 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_event_describeacls_result","title":"rd_kafka_event_DescribeAcls_result()","text":"<pre><code>public static rd_kafka_event_DescribeAcls_result ( \n    \\FFI\\CData|null $rkev\n ): \\FFI\\CData|null\n</code></pre> <p>Event types: RD_KAFKA_EVENT_DESCRIBEACLS_RESULT </p> Parameters rkev <code>\\FFI\\CData|null</code> rd_kafka_event_t* - ) Returns <code>\\FFI\\CData|null</code> const rd_kafka_DescribeAcls_result_t* - the result of a DescribeAcls request, or NULL if event is of different type. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#adba2388c1eac2bb6d3e56fdaf4da0839 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_event_deleteacls_result","title":"rd_kafka_event_DeleteAcls_result()","text":"<pre><code>public static rd_kafka_event_DeleteAcls_result ( \n    \\FFI\\CData|null $rkev\n ): \\FFI\\CData|null\n</code></pre> <p>Event types: RD_KAFKA_EVENT_DELETEACLS_RESULT </p> Parameters rkev <code>\\FFI\\CData|null</code> rd_kafka_event_t* - ) Returns <code>\\FFI\\CData|null</code> const rd_kafka_DeleteAcls_result_t* - the result of a DeleteAcls request, or NULL if event is of different type. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a9b456786cd867418fd7f8e3cb5f25478 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_resourcepatterntype_name","title":"rd_kafka_ResourcePatternType_name()","text":"<pre><code>public static rd_kafka_ResourcePatternType_name ( \n    int $resource_pattern_type\n ): string|null\n</code></pre> Parameters resource_pattern_type <code>int</code> rd_kafka_ResourcePatternType_t - ) Returns <code>string|null</code> const char* - a string representation of the <code>resource_pattern_type</code> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a488574082a549170e09adb67faca2f46 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_acl_result_error","title":"rd_kafka_acl_result_error()","text":"<pre><code>public static rd_kafka_acl_result_error ( \n    \\FFI\\CData|null $aclres\n ): \\FFI\\CData|null\n</code></pre> Parameters aclres <code>\\FFI\\CData|null</code> const rd_kafka_acl_result_t* - ) Returns <code>\\FFI\\CData|null</code> const rd_kafka_error_t* - the error object for the given acl result, or NULL on success. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aebde4f3d06cf6ae74b4be39bca9107bb </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_acloperation_name","title":"rd_kafka_AclOperation_name()","text":"<pre><code>public static rd_kafka_AclOperation_name ( \n    int $acl_operation\n ): string|null\n</code></pre> Parameters acl_operation <code>int</code> rd_kafka_AclOperation_t - ) Returns <code>string|null</code> const char* - a string representation of the <code>acl_operation</code> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#afeab00c55bf43b5152ecef5167baa227 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_aclpermissiontype_name","title":"rd_kafka_AclPermissionType_name()","text":"<pre><code>public static rd_kafka_AclPermissionType_name ( \n    int $acl_permission_type\n ): string|null\n</code></pre> Parameters acl_permission_type <code>int</code> rd_kafka_AclPermissionType_t - ) Returns <code>string|null</code> const char* - a string representation of the <code>acl_permission_type</code> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a9df29768d60a17013bb4e2860378f248 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_aclbinding_new","title":"rd_kafka_AclBinding_new()","text":"<pre><code>public static rd_kafka_AclBinding_new ( \n    int $restype, \n    string|null $name, \n    int $resource_pattern_type, \n    string|null $principal, \n    string|null $host, \n    int $operation, \n    int $permission_type, \n    \\FFI\\CData|null $errstr, \n    int|null $errstr_size\n ): \\FFI\\CData|null\n</code></pre> <p>Create a new AclBinding object. This object is later passed to rd_kafka_CreateAcls(). </p> Parameters restype <code>int</code> rd_kafka_ResourceType_t - The ResourceType. name <code>string|null</code> const char* - The resource name. resource_pattern_type <code>int</code> rd_kafka_ResourcePatternType_t - The pattern type. principal <code>string|null</code> const char* - A principal, following the kafka specification. host <code>string|null</code> const char* - An hostname or ip. operation <code>int</code> rd_kafka_AclOperation_t - A Kafka operation. permission_type <code>int</code> rd_kafka_AclPermissionType_t - A Kafka permission type. errstr <code>\\FFI\\CData|null</code> char* - An error string for returning errors or NULL to not use it. errstr_size <code>int|null</code> size_t - The <code>errstr</code> size or 0 to not use it. Returns <code>\\FFI\\CData|null</code> rd_kafka_AclBinding_t* - a new allocated AclBinding object, or NULL if the input parameters are invalid. Use rd_kafka_AclBinding_destroy() to free object when done. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a3475335e39b68c6033c87e05f5a4c5fa </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_aclbindingfilter_new","title":"rd_kafka_AclBindingFilter_new()","text":"<pre><code>public static rd_kafka_AclBindingFilter_new ( \n    int $restype, \n    string|null $name, \n    int $resource_pattern_type, \n    string|null $principal, \n    string|null $host, \n    int $operation, \n    int $permission_type, \n    \\FFI\\CData|null $errstr, \n    int|null $errstr_size\n ): \\FFI\\CData|null\n</code></pre> <p>Create a new AclBindingFilter object. This object is later passed to rd_kafka_DescribeAcls() or rd_kafka_DeletesAcls() in order to filter the acls to retrieve or to delete. Use the same rd_kafka_AclBinding functions to query or destroy it. </p> Parameters restype <code>int</code> rd_kafka_ResourceType_t - The ResourceType or <code>RD_KAFKA_RESOURCE_ANY</code> if not filtering by this field. name <code>string|null</code> const char* - The resource name or NULL if not filtering by this field. resource_pattern_type <code>int</code> rd_kafka_ResourcePatternType_t - The pattern type or <code>RD_KAFKA_RESOURCE_PATTERN_ANY</code> if not filtering by this field. principal <code>string|null</code> const char* - A principal or NULL if not filtering by this field. host <code>string|null</code> const char* - An hostname or ip or NULL if not filtering by this field. operation <code>int</code> rd_kafka_AclOperation_t - A Kafka operation or <code>RD_KAFKA_ACL_OPERATION_ANY</code> if not filtering by this field. permission_type <code>int</code> rd_kafka_AclPermissionType_t - A Kafka permission type or <code>RD_KAFKA_ACL_PERMISSION_TYPE_ANY</code> if not filtering by this field. errstr <code>\\FFI\\CData|null</code> char* - An error string for returning errors or NULL to not use it. errstr_size <code>int|null</code> size_t - The <code>errstr</code> size or 0 to not use it. Returns <code>\\FFI\\CData|null</code> rd_kafka_AclBindingFilter_t* - a new allocated AclBindingFilter object, or NULL if the input parameters are invalid. Use rd_kafka_AclBinding_destroy() to free object when done. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a20003b0ae6aeb68f02f3929c5c797372 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_aclbinding_restype","title":"rd_kafka_AclBinding_restype()","text":"<pre><code>public static rd_kafka_AclBinding_restype ( \n    \\FFI\\CData|null $acl\n ): int\n</code></pre> Parameters acl <code>\\FFI\\CData|null</code> const rd_kafka_AclBinding_t* - ) Returns <code>int</code> rd_kafka_ResourceType_t - the resource type for the given acl binding. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#af576f429f52ace1379cf9d2a4c453d8c </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_aclbinding_name","title":"rd_kafka_AclBinding_name()","text":"<pre><code>public static rd_kafka_AclBinding_name ( \n    \\FFI\\CData|null $acl\n ): string|null\n</code></pre> Remarkslifetime of the returned string is the same as the <code>acl</code>.  Parameters acl <code>\\FFI\\CData|null</code> const rd_kafka_AclBinding_t* - ) Returns <code>string|null</code> const char* - the resource name for the given acl binding. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#acb03634b4456326f3592b79584c551ea </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_aclbinding_principal","title":"rd_kafka_AclBinding_principal()","text":"<pre><code>public static rd_kafka_AclBinding_principal ( \n    \\FFI\\CData|null $acl\n ): string|null\n</code></pre> Remarkslifetime of the returned string is the same as the <code>acl</code>.  Parameters acl <code>\\FFI\\CData|null</code> const rd_kafka_AclBinding_t* - ) Returns <code>string|null</code> const char* - the principal for the given acl binding. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ad99b0868262484fc46b7c36b7db2173b </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_aclbinding_host","title":"rd_kafka_AclBinding_host()","text":"<pre><code>public static rd_kafka_AclBinding_host ( \n    \\FFI\\CData|null $acl\n ): string|null\n</code></pre> Remarkslifetime of the returned string is the same as the <code>acl</code>.  Parameters acl <code>\\FFI\\CData|null</code> const rd_kafka_AclBinding_t* - ) Returns <code>string|null</code> const char* - the host for the given acl binding. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8c242229f6b0b8faeb078fc814261fa7 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_aclbinding_operation","title":"rd_kafka_AclBinding_operation()","text":"<pre><code>public static rd_kafka_AclBinding_operation ( \n    \\FFI\\CData|null $acl\n ): int\n</code></pre> Parameters acl <code>\\FFI\\CData|null</code> const rd_kafka_AclBinding_t* - ) Returns <code>int</code> rd_kafka_AclOperation_t - the acl operation for the given acl binding. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ab4c620d7a3155c7f8cbf5556b99c2b7d </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_aclbinding_permission_type","title":"rd_kafka_AclBinding_permission_type()","text":"<pre><code>public static rd_kafka_AclBinding_permission_type ( \n    \\FFI\\CData|null $acl\n ): int\n</code></pre> Parameters acl <code>\\FFI\\CData|null</code> const rd_kafka_AclBinding_t* - ) Returns <code>int</code> rd_kafka_AclPermissionType_t - the permission type for the given acl binding. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aadb093357b1ed866ae99c710bd5e44f3 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_aclbinding_resource_pattern_type","title":"rd_kafka_AclBinding_resource_pattern_type()","text":"<pre><code>public static rd_kafka_AclBinding_resource_pattern_type ( \n    \\FFI\\CData|null $acl\n ): int\n</code></pre> Parameters acl <code>\\FFI\\CData|null</code> const rd_kafka_AclBinding_t* - ) Returns <code>int</code> rd_kafka_ResourcePatternType_t - the resource pattern type for the given acl binding. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a7c24d7c8312ea58cfdd18f8bc06fc5c8 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_aclbinding_error","title":"rd_kafka_AclBinding_error()","text":"<pre><code>public static rd_kafka_AclBinding_error ( \n    \\FFI\\CData|null $acl\n ): \\FFI\\CData|null\n</code></pre> Parameters acl <code>\\FFI\\CData|null</code> const rd_kafka_AclBinding_t* - ) Returns <code>\\FFI\\CData|null</code> const rd_kafka_error_t* - the error object for the given acl binding, or NULL on success. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a047abe192b6445a37cbab1f1be355f3d </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_aclbinding_destroy","title":"rd_kafka_AclBinding_destroy()","text":"<pre><code>public static rd_kafka_AclBinding_destroy ( \n    \\FFI\\CData|null $acl_binding\n ): void\n</code></pre> Parameters acl_binding <code>\\FFI\\CData|null</code> rd_kafka_AclBinding_t*"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_aclbinding_destroy_array","title":"rd_kafka_AclBinding_destroy_array()","text":"<pre><code>public static rd_kafka_AclBinding_destroy_array ( \n    \\FFI\\CData|null $acl_bindings, \n    int|null $acl_bindings_cnt\n ): void\n</code></pre> Parameters acl_bindings <code>\\FFI\\CData|null</code> rd_kafka_AclBinding_t** acl_bindings_cnt <code>int|null</code> size_t"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_createacls_result_acls","title":"rd_kafka_CreateAcls_result_acls()","text":"<pre><code>public static rd_kafka_CreateAcls_result_acls ( \n    \\FFI\\CData|null $result, \n    \\FFI\\CData|null $cntp\n ): \\FFI\\CData|null\n</code></pre> <p>Get an array of acl results from a CreateAcls result. </p> <p>The returned <code>acl</code> result life-time is the same as the <code>result</code> object. </p> Parameters result <code>\\FFI\\CData|null</code> const rd_kafka_CreateAcls_result_t* - CreateAcls result to get acl results from. cntp <code>\\FFI\\CData|null</code> size_t* - is updated to the number of elements in the array. Returns <code>\\FFI\\CData|null</code> const rd_kafka_acl_result_t** <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#abfcceea2bb29d6fd800f11224f0f4238 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_createacls","title":"rd_kafka_CreateAcls()","text":"<pre><code>public static rd_kafka_CreateAcls ( \n    \\FFI\\CData|null $rk, \n    \\FFI\\CData|null $new_acls, \n    int|null $new_acls_cnt, \n    \\FFI\\CData|null $options, \n    \\FFI\\CData|null $rkqu\n ): void\n</code></pre> <p>Create acls as specified by the <code>new_acls</code> array of size <code>new_topic_cnt</code> elements. </p> <p>Supported admin options:</p> <ul> <li>rd_kafka_AdminOptions_set_request_timeout() - default socket.timeout.ms</li> </ul> RemarksThe result event type emitted on the supplied queue is of type <code>RD_KAFKA_EVENT_CREATEACLS_RESULT</code> Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* - Client instance. new_acls <code>\\FFI\\CData|null</code> rd_kafka_AclBinding_t** - Array of new acls to create. new_acls_cnt <code>int|null</code> size_t - Number of elements in <code>new_acls</code> array. options <code>\\FFI\\CData|null</code> const rd_kafka_AdminOptions_t* - Optional admin options, or NULL for defaults. rkqu <code>\\FFI\\CData|null</code> rd_kafka_queue_t* - Queue to emit result on. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a028d1a0ff870bcea561d3cf474aa7265 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_describeacls_result_acls","title":"rd_kafka_DescribeAcls_result_acls()","text":"<pre><code>public static rd_kafka_DescribeAcls_result_acls ( \n    \\FFI\\CData|null $result, \n    \\FFI\\CData|null $cntp\n ): \\FFI\\CData|null\n</code></pre> <p>Get an array of resource results from a DescribeAcls result. </p> <p>DescribeAcls - describe access control lists.</p> <p>The returned <code>resources</code> life-time is the same as the <code>result</code> object. </p> Parameters result <code>\\FFI\\CData|null</code> const rd_kafka_DescribeAcls_result_t* - DescribeAcls result to get acls from. cntp <code>\\FFI\\CData|null</code> size_t* - is updated to the number of elements in the array. Returns <code>\\FFI\\CData|null</code> const rd_kafka_AclBinding_t** <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aa5d797f84a5dcf3c069636c1dc408934 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_describeacls","title":"rd_kafka_DescribeAcls()","text":"<pre><code>public static rd_kafka_DescribeAcls ( \n    \\FFI\\CData|null $rk, \n    \\FFI\\CData|null $acl_filter, \n    \\FFI\\CData|null $options, \n    \\FFI\\CData|null $rkqu\n ): void\n</code></pre> <p>Describe acls matching the filter provided in <code>acl_filter</code>. </p> <p>Supported admin options:</p> <ul> <li>rd_kafka_AdminOptions_set_operation_timeout() - default 0</li> </ul> RemarksThe result event type emitted on the supplied queue is of type <code>RD_KAFKA_EVENT_DESCRIBEACLS_RESULT</code> Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* - Client instance. acl_filter <code>\\FFI\\CData|null</code> rd_kafka_AclBindingFilter_t* - Filter for the returned acls. options <code>\\FFI\\CData|null</code> const rd_kafka_AdminOptions_t* - Optional admin options, or NULL for defaults. rkqu <code>\\FFI\\CData|null</code> rd_kafka_queue_t* - Queue to emit result on. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a7dcf8b0d43014b7412d9a5059006194b </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_deleteacls_result_responses","title":"rd_kafka_DeleteAcls_result_responses()","text":"<pre><code>public static rd_kafka_DeleteAcls_result_responses ( \n    \\FFI\\CData|null $result, \n    \\FFI\\CData|null $cntp\n ): \\FFI\\CData|null\n</code></pre> <p>Get an array of DeleteAcls result responses from a DeleteAcls result. </p> <p>The returned <code>responses</code> life-time is the same as the <code>result</code> object. </p> Parameters result <code>\\FFI\\CData|null</code> const rd_kafka_DeleteAcls_result_t* - DeleteAcls result to get responses from. cntp <code>\\FFI\\CData|null</code> size_t* - is updated to the number of elements in the array. Returns <code>\\FFI\\CData|null</code> const rd_kafka_DeleteAcls_result_response_t** <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#af22ab28bfc36ac13ee043e95b0741dc0 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_deleteacls_result_response_error","title":"rd_kafka_DeleteAcls_result_response_error()","text":"<pre><code>public static rd_kafka_DeleteAcls_result_response_error ( \n    \\FFI\\CData|null $result_response\n ): \\FFI\\CData|null\n</code></pre> Parameters result_response <code>\\FFI\\CData|null</code> const rd_kafka_DeleteAcls_result_response_t* - ) Returns <code>\\FFI\\CData|null</code> const rd_kafka_error_t* - the error object for the given DeleteAcls result response, or NULL on success. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a519cf227ea6f1cadd19a767d430209c1 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_deleteacls_result_response_matching_acls","title":"rd_kafka_DeleteAcls_result_response_matching_acls()","text":"<pre><code>public static rd_kafka_DeleteAcls_result_response_matching_acls ( \n    \\FFI\\CData|null $result_response, \n    \\FFI\\CData|null $matching_acls_cntp\n ): \\FFI\\CData|null\n</code></pre> Remarkslifetime of the returned acl bindings is the same as the <code>result_response</code>.  Parameters result_response <code>\\FFI\\CData|null</code> const rd_kafka_DeleteAcls_result_response_t* matching_acls_cntp <code>\\FFI\\CData|null</code> size_t* Returns <code>\\FFI\\CData|null</code> const rd_kafka_AclBinding_t** - the matching acls array for the given DeleteAcls result response. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a157a9b9ab67703b3e531a67f7a8da7de </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_deleteacls","title":"rd_kafka_DeleteAcls()","text":"<pre><code>public static rd_kafka_DeleteAcls ( \n    \\FFI\\CData|null $rk, \n    \\FFI\\CData|null $del_acls, \n    int|null $del_acls_cnt, \n    \\FFI\\CData|null $options, \n    \\FFI\\CData|null $rkqu\n ): void\n</code></pre> <p>Delete acls matching the filteres provided in <code>del_acls</code> array of size <code>del_acls_cnt</code>. </p> <p>Supported admin options:</p> <ul> <li>rd_kafka_AdminOptions_set_operation_timeout() - default 0</li> </ul> RemarksThe result event type emitted on the supplied queue is of type <code>RD_KAFKA_EVENT_DELETEACLS_RESULT</code> Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* - Client instance. del_acls <code>\\FFI\\CData|null</code> rd_kafka_AclBindingFilter_t** - Filters for the acls to delete. del_acls_cnt <code>int|null</code> size_t - Number of elements in <code>del_acls</code> array. options <code>\\FFI\\CData|null</code> const rd_kafka_AdminOptions_t* - Optional admin options, or NULL for defaults. rkqu <code>\\FFI\\CData|null</code> rd_kafka_queue_t* - Queue to emit result on. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a6118e40b9abfff686a61dc5e093468ef </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_conf_set_resolve_cb","title":"rd_kafka_conf_set_resolve_cb()","text":"<pre><code>public static rd_kafka_conf_set_resolve_cb ( \n    \\FFI\\CData|null $conf, \n    \\FFI\\CData|\\Closure $resolve_cb\n ): void\n</code></pre> <p>Set address resolution callback. </p> <p>The callback is responsible for resolving the hostname <code>node</code> and the service <code>service</code> into a list of socket addresses as <code>getaddrinfo(3)</code> would. The <code>hints</code> and <code>res</code> parameters function as they do for <code>getaddrinfo(3)</code>. The callback's <code>opaque</code> argument is the opaque set with rd_kafka_conf_set_opaque().</p> <p>If the callback is invoked with a NULL <code>node</code>, <code>service</code>, and <code>hints</code>, the callback should instead free the addrinfo struct specified in <code>res</code>. In this case the callback must succeed; the return value will not be checked by the caller.</p> <p>The callback's return value is interpreted as the return value of <code><code>getaddrinfo(3)</code>.</code> </p> RemarksThe callback will be called from an internal librdkafka thread.  Parameters conf <code>\\FFI\\CData|null</code> rd_kafka_conf_t* resolve_cb <code>\\FFI\\CData|\\Closure</code> int()(const char, const char*, const struct addrinfo*, struct addrinfo**, void*) <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a12bbaef85d4168572eea006c5ce0d2eb </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_sasl_set_credentials","title":"rd_kafka_sasl_set_credentials()","text":"<pre><code>public static rd_kafka_sasl_set_credentials ( \n    \\FFI\\CData|null $rk, \n    string|null $username, \n    string|null $password\n ): \\FFI\\CData|null\n</code></pre> <p>Sets SASL credentials used for SASL PLAIN and SCRAM mechanisms by this Kafka client. </p> <p>This function sets or resets the SASL username and password credentials used by this Kafka client. The new credentials will be used the next time this client needs to authenticate to a broker. This function will not disconnect existing connections that might have been made using the old credentials.</p> RemarksThis function only applies to the SASL PLAIN and SCRAM mechanisms. Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* username <code>string|null</code> const char* password <code>string|null</code> const char* Returns <code>\\FFI\\CData|null</code> rd_kafka_error_t* - NULL on success or an error object on error. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8bdca34710185cec1e42e500decbeb2d </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_node_id","title":"rd_kafka_Node_id()","text":"<pre><code>public static rd_kafka_Node_id ( \n    \\FFI\\CData|null $node\n ): int|null\n</code></pre> <p>Get the id of <code>node</code>. </p> Parameters node <code>\\FFI\\CData|null</code> const rd_kafka_Node_t* - ) - The Node instance. Returns <code>int|null</code> int - The node id. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ac0f59992ab0e0ae07b80163afa0ea685 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_node_host","title":"rd_kafka_Node_host()","text":"<pre><code>public static rd_kafka_Node_host ( \n    \\FFI\\CData|null $node\n ): string|null\n</code></pre> <p>Get the host of <code>node</code>. </p> RemarksThe lifetime of the returned memory is the same as the lifetime of the <code>node</code> object.  Parameters node <code>\\FFI\\CData|null</code> const rd_kafka_Node_t* - ) - The Node instance. Returns <code>string|null</code> const char* - The node host. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a4916477d9d4a0e76d05dd4b203d92b3b </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_node_port","title":"rd_kafka_Node_port()","text":"<pre><code>public static rd_kafka_Node_port ( \n    \\FFI\\CData|null $node\n ): int|null\n</code></pre> <p>Get the port of <code>node</code>. </p> Parameters node <code>\\FFI\\CData|null</code> const rd_kafka_Node_t* - ) - The Node instance. Returns <code>int|null</code> uint16_t - The node port. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#abc3ff57cdfc63f694d7200e91570ab3a </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_consumer_group_state_name","title":"rd_kafka_consumer_group_state_name()","text":"<pre><code>public static rd_kafka_consumer_group_state_name ( \n    int $state\n ): string|null\n</code></pre> <p>Returns a name for a state code. </p> Parameters state <code>int</code> rd_kafka_consumer_group_state_t - ) - The state value. Returns <code>string|null</code> const char* - The group state name corresponding to the provided group state value. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aa9e2cac6e414980eef365394d06014f4 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_consumer_group_state_code","title":"rd_kafka_consumer_group_state_code()","text":"<pre><code>public static rd_kafka_consumer_group_state_code ( \n    string|null $name\n ): int\n</code></pre> <p>Returns a code for a state name. </p> Parameters name <code>string|null</code> const char* - ) - The state name. Returns <code>int</code> rd_kafka_consumer_group_state_t - The group state value corresponding to the provided group state name. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a5d7d4a9967f81749cf8bd2b898021d80 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_event_listconsumergroups_result","title":"rd_kafka_event_ListConsumerGroups_result()","text":"<pre><code>public static rd_kafka_event_ListConsumerGroups_result ( \n    \\FFI\\CData|null $rkev\n ): \\FFI\\CData|null\n</code></pre> <p>Get ListConsumerGroups result. </p> RemarksThe lifetime of the returned memory is the same as the lifetime of the <code>rkev</code> object. <p>Event types: RD_KAFKA_EVENT_LISTCONSUMERGROUPS_RESULT </p> Parameters rkev <code>\\FFI\\CData|null</code> rd_kafka_event_t* - ) Returns <code>\\FFI\\CData|null</code> const rd_kafka_ListConsumerGroups_result_t* - the result of a ListConsumerGroups request, or NULL if event is of different type. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ae98a40da574c542788d195ac8a0413e6 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_event_describeconsumergroups_result","title":"rd_kafka_event_DescribeConsumerGroups_result()","text":"<pre><code>public static rd_kafka_event_DescribeConsumerGroups_result ( \n    \\FFI\\CData|null $rkev\n ): \\FFI\\CData|null\n</code></pre> <p>Get DescribeConsumerGroups result. </p> RemarksThe lifetime of the returned memory is the same as the lifetime of the <code>rkev</code> object. <p>Event types: RD_KAFKA_EVENT_DESCRIBECONSUMERGROUPS_RESULT </p> Parameters rkev <code>\\FFI\\CData|null</code> rd_kafka_event_t* - ) Returns <code>\\FFI\\CData|null</code> const rd_kafka_DescribeConsumerGroups_result_t* - the result of a DescribeConsumerGroups request, or NULL if event is of different type. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a1c6a620b55cb4c6acbc48c273d334b16 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_event_alterconsumergroupoffsets_result","title":"rd_kafka_event_AlterConsumerGroupOffsets_result()","text":"<pre><code>public static rd_kafka_event_AlterConsumerGroupOffsets_result ( \n    \\FFI\\CData|null $rkev\n ): \\FFI\\CData|null\n</code></pre> <p>Get AlterConsumerGroupOffsets result. </p> RemarksThe lifetime of the returned memory is the same as the lifetime of the <code>rkev</code> object. <p>Event types: RD_KAFKA_EVENT_ALTERCONSUMERGROUPOFFSETS_RESULT </p> Parameters rkev <code>\\FFI\\CData|null</code> rd_kafka_event_t* - ) Returns <code>\\FFI\\CData|null</code> const rd_kafka_AlterConsumerGroupOffsets_result_t* - the result of a AlterConsumerGroupOffsets request, or NULL if event is of different type. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aac08437e5b1361291f93b7428b4b1275 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_event_listconsumergroupoffsets_result","title":"rd_kafka_event_ListConsumerGroupOffsets_result()","text":"<pre><code>public static rd_kafka_event_ListConsumerGroupOffsets_result ( \n    \\FFI\\CData|null $rkev\n ): \\FFI\\CData|null\n</code></pre> <p>Get ListConsumerGroupOffsets result. </p> RemarksThe lifetime of the returned memory is the same as the lifetime of the <code>rkev</code> object. <p>Event types: RD_KAFKA_EVENT_LISTCONSUMERGROUPOFFSETS_RESULT </p> Parameters rkev <code>\\FFI\\CData|null</code> rd_kafka_event_t* - ) Returns <code>\\FFI\\CData|null</code> const rd_kafka_ListConsumerGroupOffsets_result_t* - the result of a ListConsumerGroupOffsets request, or NULL if event is of different type. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ac24d4e077500b38974634f63758aae7e </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_interceptor_f_on_broker_state_change_t","title":"rd_kafka_interceptor_f_on_broker_state_change_t()","text":"<pre><code>public static rd_kafka_interceptor_f_on_broker_state_change_t ( \n    \\FFI\\CData|null $rk, \n    int|null $broker_id, \n    string|null $secproto, \n    string|null $name, \n    int|null $port, \n    string|null $state, \n    \\FFI\\CData|object|string|null $ic_opaque\n ): int\n</code></pre> <p>on_broker_state_change() is called just after a broker has been created or its state has been changed. </p> Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* - The client instance. broker_id <code>int|null</code> int32_t - The broker id (-1 is used for bootstrap brokers). secproto <code>string|null</code> const char* - The security protocol. name <code>string|null</code> const char* - The original name of the broker. port <code>int|null</code> int - The port of the broker. state <code>string|null</code> const char* - Broker state name. ic_opaque <code>\\FFI\\CData|object|string|null</code> void* - The interceptor\u2019s opaque pointer specified in ..add..(). Returns <code>int</code> rd_kafka_resp_err_t - an error code on failure, the error is logged but otherwise ignored. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a50cb62229f969ac9d25d58c8d65950b9 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_interceptor_add_on_broker_state_change","title":"rd_kafka_interceptor_add_on_broker_state_change()","text":"<pre><code>public static rd_kafka_interceptor_add_on_broker_state_change ( \n    \\FFI\\CData|null $rk, \n    string|null $ic_name, \n    \\FFI\\CData|\\Closure $on_broker_state_change, \n    \\FFI\\CData|object|string|null $ic_opaque\n ): int\n</code></pre> <p>Append an on_broker_state_change() interceptor. </p> Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* - Client instance. ic_name <code>string|null</code> const char* - Interceptor name, used in logging. on_broker_state_change <code>\\FFI\\CData|\\Closure</code> rd_kafka_resp_err_t(rd_kafka_interceptor_f_on_broker_state_change_t*)(rd_kafka_t*, int32_t, const char*, const char*, int, const char*, void*) ic_opaque <code>\\FFI\\CData|object|string|null</code> void* - Opaque value that will be passed to the function. Returns <code>int</code> rd_kafka_resp_err_t - RD_KAFKA_RESP_ERR_NO_ERROR on success or RD_KAFKA_RESP_ERR__CONFLICT if an existing interceptor with the same <code>ic_name</code> and function has already been added to <code>conf</code>. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a2b53e29ee63067884bc8962e8637e82b </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_adminoptions_set_require_stable_offsets","title":"rd_kafka_AdminOptions_set_require_stable_offsets()","text":"<pre><code>public static rd_kafka_AdminOptions_set_require_stable_offsets ( \n    \\FFI\\CData|null $options, \n    int|null $true_or_false\n ): \\FFI\\CData|null\n</code></pre> <p>Whether broker should return stable offsets (transaction-committed). </p> RemarksThis option is valid for ListConsumerGroupOffsets.  Parameters options <code>\\FFI\\CData|null</code> rd_kafka_AdminOptions_t* - Admin options. true_or_false <code>int|null</code> int - Defaults to false. Returns <code>\\FFI\\CData|null</code> rd_kafka_error_t* - NULL on success, a new error instance that must be released with rd_kafka_error_destroy() in case of error. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a378186db06498feeb35e03a3345fc562 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_adminoptions_set_match_consumer_group_states","title":"rd_kafka_AdminOptions_set_match_consumer_group_states()","text":"<pre><code>public static rd_kafka_AdminOptions_set_match_consumer_group_states ( \n    \\FFI\\CData|null $options, \n    \\FFI\\CData|null $consumer_group_states, \n    int|null $consumer_group_states_cnt\n ): \\FFI\\CData|null\n</code></pre> <p>Set consumer groups states to query for. </p> RemarksThis option is valid for ListConsumerGroups.  Parameters options <code>\\FFI\\CData|null</code> rd_kafka_AdminOptions_t* - Admin options. consumer_group_states <code>\\FFI\\CData|null</code> const rd_kafka_consumer_group_state_t* - Array of consumer group states. consumer_group_states_cnt <code>int|null</code> size_t - Size of the <code>consumer_group_states</code> array. Returns <code>\\FFI\\CData|null</code> rd_kafka_error_t* - NULL on success, a new error instance that must be released with rd_kafka_error_destroy() in case of error. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a907d23eac09352f32321e9d0140caab1 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_listconsumergroups","title":"rd_kafka_ListConsumerGroups()","text":"<pre><code>public static rd_kafka_ListConsumerGroups ( \n    \\FFI\\CData|null $rk, \n    \\FFI\\CData|null $options, \n    \\FFI\\CData|null $rkqu\n ): void\n</code></pre> <p>List the consumer groups available in the cluster. </p> RemarksThe result event type emitted on the supplied queue is of type <code>RD_KAFKA_EVENT_LISTCONSUMERGROUPS_RESULT</code> Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* - Client instance. options <code>\\FFI\\CData|null</code> const rd_kafka_AdminOptions_t* - Optional admin options, or NULL for defaults. rkqu <code>\\FFI\\CData|null</code> rd_kafka_queue_t* - Queue to emit result on. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ad386f553c1b0a103bd4f891f48a516c2 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_consumergrouplisting_group_id","title":"rd_kafka_ConsumerGroupListing_group_id()","text":"<pre><code>public static rd_kafka_ConsumerGroupListing_group_id ( \n    \\FFI\\CData|null $grplist\n ): string|null\n</code></pre> <p>Gets the group id for the <code>grplist</code> group. </p> RemarksThe lifetime of the returned memory is the same as the lifetime of the <code>grplist</code> object.  Parameters grplist <code>\\FFI\\CData|null</code> const rd_kafka_ConsumerGroupListing_t* - ) - The group listing. Returns <code>string|null</code> const char* - The group id. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a6527936dcb6222ed4ec34693aacdea24 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_consumergrouplisting_is_simple_consumer_group","title":"rd_kafka_ConsumerGroupListing_is_simple_consumer_group()","text":"<pre><code>public static rd_kafka_ConsumerGroupListing_is_simple_consumer_group ( \n    \\FFI\\CData|null $grplist\n ): int|null\n</code></pre> <p>Is the <code>grplist</code> group a simple consumer group. </p> Parameters grplist <code>\\FFI\\CData|null</code> const rd_kafka_ConsumerGroupListing_t* - ) - The group listing. Returns <code>int|null</code> int - 1 if the group is a simple consumer group, else 0. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ab41e0d25c3a013426d97d0bceb22e91d </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_consumergrouplisting_state","title":"rd_kafka_ConsumerGroupListing_state()","text":"<pre><code>public static rd_kafka_ConsumerGroupListing_state ( \n    \\FFI\\CData|null $grplist\n ): int\n</code></pre> <p>Gets state for the <code>grplist</code> group. </p> Parameters grplist <code>\\FFI\\CData|null</code> const rd_kafka_ConsumerGroupListing_t* - ) - The group listing. Returns <code>int</code> rd_kafka_consumer_group_state_t - A group state. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a050b8eb40679af7564533793b42954e3 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_listconsumergroups_result_valid","title":"rd_kafka_ListConsumerGroups_result_valid()","text":"<pre><code>public static rd_kafka_ListConsumerGroups_result_valid ( \n    \\FFI\\CData|null $result, \n    \\FFI\\CData|null $cntp\n ): \\FFI\\CData|null\n</code></pre> <p>Get an array of valid list groups from a ListConsumerGroups result. </p> <p>The returned groups life-time is the same as the <code>result</code> object.</p> RemarksThe lifetime of the returned memory is the same as the lifetime of the <code>result</code> object.  Parameters result <code>\\FFI\\CData|null</code> const rd_kafka_ListConsumerGroups_result_t* - Result to get group results from. cntp <code>\\FFI\\CData|null</code> size_t* - is updated to the number of elements in the array. Returns <code>\\FFI\\CData|null</code> const rd_kafka_ConsumerGroupListing_t** <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a3a0b27d2db47bd67106a02c9ac211ae6 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_listconsumergroups_result_errors","title":"rd_kafka_ListConsumerGroups_result_errors()","text":"<pre><code>public static rd_kafka_ListConsumerGroups_result_errors ( \n    \\FFI\\CData|null $result, \n    \\FFI\\CData|null $cntp\n ): \\FFI\\CData|null\n</code></pre> <p>Get an array of errors from a ListConsumerGroups call result. </p> <p>The returned errors life-time is the same as the <code>result</code> object.</p> RemarksThe lifetime of the returned memory is the same as the lifetime of the <code>result</code> object.  Parameters result <code>\\FFI\\CData|null</code> const rd_kafka_ListConsumerGroups_result_t* - ListConsumerGroups result. cntp <code>\\FFI\\CData|null</code> size_t* - Is updated to the number of elements in the array. Returns <code>\\FFI\\CData|null</code> const rd_kafka_error_t** - Array of errors in <code>result</code>. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a0d1251b00ea55f8bd652c7a056c11425 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_describeconsumergroups","title":"rd_kafka_DescribeConsumerGroups()","text":"<pre><code>public static rd_kafka_DescribeConsumerGroups ( \n    \\FFI\\CData|null $rk, \n    \\FFI\\CData|null $groups, \n    int|null $groups_cnt, \n    \\FFI\\CData|null $options, \n    \\FFI\\CData|null $rkqu\n ): void\n</code></pre> <p>Describe groups from cluster as specified by the <code>groups</code> array of size <code>groups_cnt</code> elements. </p> RemarksThe result event type emitted on the supplied queue is of type <code>RD_KAFKA_EVENT_DESCRIBECONSUMERGROUPS_RESULT</code> Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* - Client instance. groups <code>\\FFI\\CData|null</code> const char** - Array of groups to describe. groups_cnt <code>int|null</code> size_t - Number of elements in <code>groups</code> array. options <code>\\FFI\\CData|null</code> const rd_kafka_AdminOptions_t* - Optional admin options, or NULL for defaults. Valid options:<ul> <li>include_authorized_operations </li> </ul> rkqu <code>\\FFI\\CData|null</code> rd_kafka_queue_t* - Queue to emit result on. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a3c473e95da2231aaaeca990a6ff45ad1 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_describeconsumergroups_result_groups","title":"rd_kafka_DescribeConsumerGroups_result_groups()","text":"<pre><code>public static rd_kafka_DescribeConsumerGroups_result_groups ( \n    \\FFI\\CData|null $result, \n    \\FFI\\CData|null $cntp\n ): \\FFI\\CData|null\n</code></pre> <p>Get an array of group results from a DescribeConsumerGroups result. </p> <p>The returned groups life-time is the same as the <code>result</code> object.</p> RemarksThe lifetime of the returned memory is the same as the lifetime of the <code>result</code> object.  Parameters result <code>\\FFI\\CData|null</code> const rd_kafka_DescribeConsumerGroups_result_t* - Result to get group results from. cntp <code>\\FFI\\CData|null</code> size_t* - is updated to the number of elements in the array. Returns <code>\\FFI\\CData|null</code> const rd_kafka_ConsumerGroupDescription_t** <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a7105546ec6af24791fbb0da90f0d2384 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_consumergroupdescription_group_id","title":"rd_kafka_ConsumerGroupDescription_group_id()","text":"<pre><code>public static rd_kafka_ConsumerGroupDescription_group_id ( \n    \\FFI\\CData|null $grpdesc\n ): string|null\n</code></pre> <p>Gets the group id for the <code>grpdesc</code> group. </p> RemarksThe lifetime of the returned memory is the same as the lifetime of the <code>grpdesc</code> object.  Parameters grpdesc <code>\\FFI\\CData|null</code> const rd_kafka_ConsumerGroupDescription_t* - ) - The group description. Returns <code>string|null</code> const char* - The group id. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a1ac25283379d2cdcd7def61763ea1183 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_consumergroupdescription_error","title":"rd_kafka_ConsumerGroupDescription_error()","text":"<pre><code>public static rd_kafka_ConsumerGroupDescription_error ( \n    \\FFI\\CData|null $grpdesc\n ): \\FFI\\CData|null\n</code></pre> <p>Gets the error for the <code>grpdesc</code> group. </p> RemarksThe lifetime of the returned memory is the same as the lifetime of the <code>grpdesc</code> object.  Parameters grpdesc <code>\\FFI\\CData|null</code> const rd_kafka_ConsumerGroupDescription_t* - ) - The group description. Returns <code>\\FFI\\CData|null</code> const rd_kafka_error_t* - The group description error. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a809554b4c1ba1d54d9daffc72e056d9d </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_consumergroupdescription_is_simple_consumer_group","title":"rd_kafka_ConsumerGroupDescription_is_simple_consumer_group()","text":"<pre><code>public static rd_kafka_ConsumerGroupDescription_is_simple_consumer_group ( \n    \\FFI\\CData|null $grpdesc\n ): int|null\n</code></pre> <p>Is the <code>grpdesc</code> group a simple consumer group. </p> Parameters grpdesc <code>\\FFI\\CData|null</code> const rd_kafka_ConsumerGroupDescription_t* - ) - The group description. Returns <code>int|null</code> int - 1 if the group is a simple consumer group, else 0. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aa142302fb0912b8350254f22d1ebf0cf </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_consumergroupdescription_partition_assignor","title":"rd_kafka_ConsumerGroupDescription_partition_assignor()","text":"<pre><code>public static rd_kafka_ConsumerGroupDescription_partition_assignor ( \n    \\FFI\\CData|null $grpdesc\n ): string|null\n</code></pre> <p>Gets the partition assignor for the <code>grpdesc</code> group. </p> RemarksThe lifetime of the returned memory is the same as the lifetime of the <code>grpdesc</code> object.  Parameters grpdesc <code>\\FFI\\CData|null</code> const rd_kafka_ConsumerGroupDescription_t* - ) - The group description. Returns <code>string|null</code> const char* - The partition assignor. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a28ae221b77d6ea9b605b902f92a8022d </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_consumergroupdescription_state","title":"rd_kafka_ConsumerGroupDescription_state()","text":"<pre><code>public static rd_kafka_ConsumerGroupDescription_state ( \n    \\FFI\\CData|null $grpdesc\n ): int\n</code></pre> <p>Gets state for the <code>grpdesc</code> group. </p> Parameters grpdesc <code>\\FFI\\CData|null</code> const rd_kafka_ConsumerGroupDescription_t* - ) - The group description. Returns <code>int</code> rd_kafka_consumer_group_state_t - A group state. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#acc29475b069d8299cbc20b558fb2bb19 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_consumergroupdescription_coordinator","title":"rd_kafka_ConsumerGroupDescription_coordinator()","text":"<pre><code>public static rd_kafka_ConsumerGroupDescription_coordinator ( \n    \\FFI\\CData|null $grpdesc\n ): \\FFI\\CData|null\n</code></pre> <p>Gets the coordinator for the <code>grpdesc</code> group. </p> RemarksThe lifetime of the returned memory is the same as the lifetime of the <code>grpdesc</code> object.  Parameters grpdesc <code>\\FFI\\CData|null</code> const rd_kafka_ConsumerGroupDescription_t* - ) - The group description. Returns <code>\\FFI\\CData|null</code> const rd_kafka_Node_t* - The group coordinator. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a63c98664bac3c9cda112e0bda18a4328 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_consumergroupdescription_member_count","title":"rd_kafka_ConsumerGroupDescription_member_count()","text":"<pre><code>public static rd_kafka_ConsumerGroupDescription_member_count ( \n    \\FFI\\CData|null $grpdesc\n ): int|null\n</code></pre> <p>Gets the members count of <code>grpdesc</code> group. </p> Parameters grpdesc <code>\\FFI\\CData|null</code> const rd_kafka_ConsumerGroupDescription_t* - ) - The group description. Returns <code>int|null</code> size_t - The member count. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aa508c92d434adb9027cdec9022b10acf </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_consumergroupdescription_member","title":"rd_kafka_ConsumerGroupDescription_member()","text":"<pre><code>public static rd_kafka_ConsumerGroupDescription_member ( \n    \\FFI\\CData|null $grpdesc, \n    int|null $idx\n ): \\FFI\\CData|null\n</code></pre> <p>Gets a member of <code>grpdesc</code> group. </p> RemarksThe lifetime of the returned memory is the same as the lifetime of the <code>grpdesc</code> object.  Parameters grpdesc <code>\\FFI\\CData|null</code> const rd_kafka_ConsumerGroupDescription_t* - The group description. idx <code>int|null</code> size_t - The member idx. Returns <code>\\FFI\\CData|null</code> const rd_kafka_MemberDescription_t* - A member at index <code>idx</code>, or NULL if <code>idx</code> is out of range. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a7bdfd0d42f52fb3d8d58aca660ef36b0 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_memberdescription_client_id","title":"rd_kafka_MemberDescription_client_id()","text":"<pre><code>public static rd_kafka_MemberDescription_client_id ( \n    \\FFI\\CData|null $member\n ): string|null\n</code></pre> <p>Gets client id of <code>member</code>. </p> RemarksThe lifetime of the returned memory is the same as the lifetime of the <code>member</code> object.  Parameters member <code>\\FFI\\CData|null</code> const rd_kafka_MemberDescription_t* - ) - The group member. Returns <code>string|null</code> const char* - The client id. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#af51b7bb5ba85029cf61512e0d577752b </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_memberdescription_group_instance_id","title":"rd_kafka_MemberDescription_group_instance_id()","text":"<pre><code>public static rd_kafka_MemberDescription_group_instance_id ( \n    \\FFI\\CData|null $member\n ): string|null\n</code></pre> <p>Gets group instance id of <code>member</code>. </p> RemarksThe lifetime of the returned memory is the same as the lifetime of the <code>member</code> object.  Parameters member <code>\\FFI\\CData|null</code> const rd_kafka_MemberDescription_t* - ) - The group member. Returns <code>string|null</code> const char* - The group instance id, or NULL if not available. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ac4a5a27065d4aac5c9cf68cb518a40d3 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_memberdescription_consumer_id","title":"rd_kafka_MemberDescription_consumer_id()","text":"<pre><code>public static rd_kafka_MemberDescription_consumer_id ( \n    \\FFI\\CData|null $member\n ): string|null\n</code></pre> <p>Gets consumer id of <code>member</code>. </p> RemarksThe lifetime of the returned memory is the same as the lifetime of the <code>member</code> object.  Parameters member <code>\\FFI\\CData|null</code> const rd_kafka_MemberDescription_t* - ) - The group member. Returns <code>string|null</code> const char* - The consumer id. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a870f35c37cb290231adb1ef8d4fa7454 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_memberdescription_host","title":"rd_kafka_MemberDescription_host()","text":"<pre><code>public static rd_kafka_MemberDescription_host ( \n    \\FFI\\CData|null $member\n ): string|null\n</code></pre> <p>Gets host of <code>member</code>. </p> RemarksThe lifetime of the returned memory is the same as the lifetime of the <code>member</code> object.  Parameters member <code>\\FFI\\CData|null</code> const rd_kafka_MemberDescription_t* - ) - The group member. Returns <code>string|null</code> const char* - The host. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a74681ac4652977e239f18d7e13a40dfe </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_memberdescription_assignment","title":"rd_kafka_MemberDescription_assignment()","text":"<pre><code>public static rd_kafka_MemberDescription_assignment ( \n    \\FFI\\CData|null $member\n ): \\FFI\\CData|null\n</code></pre> <p>Gets assignment of <code>member</code>. </p> RemarksThe lifetime of the returned memory is the same as the lifetime of the <code>member</code> object.  Parameters member <code>\\FFI\\CData|null</code> const rd_kafka_MemberDescription_t* - ) - The group member. Returns <code>\\FFI\\CData|null</code> const rd_kafka_MemberAssignment_t* - The member assignment. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a9c5094e0d39a8d6f96e08355ef11c549 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_memberassignment_partitions","title":"rd_kafka_MemberAssignment_partitions()","text":"<pre><code>public static rd_kafka_MemberAssignment_partitions ( \n    \\FFI\\CData|null $assignment\n ): \\FFI\\CData|null\n</code></pre> <p>Gets assigned partitions of a member <code>assignment</code>. </p> RemarksThe lifetime of the returned memory is the same as the lifetime of the <code>assignment</code> object.  Parameters assignment <code>\\FFI\\CData|null</code> const rd_kafka_MemberAssignment_t* - ) - The group member assignment. Returns <code>\\FFI\\CData|null</code> const rd_kafka_topic_partition_list_t* - The assigned partitions. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a5da333973857cb6e128a856399a9a21f </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_listconsumergroupoffsets_new","title":"rd_kafka_ListConsumerGroupOffsets_new()","text":"<pre><code>public static rd_kafka_ListConsumerGroupOffsets_new ( \n    string|null $group_id, \n    \\FFI\\CData|null $partitions\n ): \\FFI\\CData|null\n</code></pre> <p>Create a new ListConsumerGroupOffsets object. This object is later passed to rd_kafka_ListConsumerGroupOffsets(). </p> Parameters group_id <code>string|null</code> const char* - Consumer group id. partitions <code>\\FFI\\CData|null</code> const rd_kafka_topic_partition_list_t* - Partitions to list committed offsets for. Only the topic and partition fields are used. Returns <code>\\FFI\\CData|null</code> rd_kafka_ListConsumerGroupOffsets_t* - a new allocated ListConsumerGroupOffsets object. Use rd_kafka_ListConsumerGroupOffsets_destroy() to free object when done. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#af96cc3e1031d498fdf46f5590d8a7ea2 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_listconsumergroupoffsets_destroy","title":"rd_kafka_ListConsumerGroupOffsets_destroy()","text":"<pre><code>public static rd_kafka_ListConsumerGroupOffsets_destroy ( \n    \\FFI\\CData|null $list_grpoffsets\n ): void\n</code></pre> Parameters list_grpoffsets <code>\\FFI\\CData|null</code> rd_kafka_ListConsumerGroupOffsets_t*"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_listconsumergroupoffsets_destroy_array","title":"rd_kafka_ListConsumerGroupOffsets_destroy_array()","text":"<pre><code>public static rd_kafka_ListConsumerGroupOffsets_destroy_array ( \n    \\FFI\\CData|null $list_grpoffsets, \n    int|null $list_grpoffset_cnt\n ): void\n</code></pre> Parameters list_grpoffsets <code>\\FFI\\CData|null</code> rd_kafka_ListConsumerGroupOffsets_t** list_grpoffset_cnt <code>int|null</code> size_t"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_listconsumergroupoffsets","title":"rd_kafka_ListConsumerGroupOffsets()","text":"<pre><code>public static rd_kafka_ListConsumerGroupOffsets ( \n    \\FFI\\CData|null $rk, \n    \\FFI\\CData|null $list_grpoffsets, \n    int|null $list_grpoffsets_cnt, \n    \\FFI\\CData|null $options, \n    \\FFI\\CData|null $rkqu\n ): void\n</code></pre> <p>List committed offsets for a set of partitions in a consumer group. </p> RemarksThe result event type emitted on the supplied queue is of type <code>RD_KAFKA_EVENT_LISTCONSUMERGROUPOFFSETS_RESULT</code>  The current implementation only supports one group per invocation.  Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* - Client instance. list_grpoffsets <code>\\FFI\\CData|null</code> rd_kafka_ListConsumerGroupOffsets_t** - Array of group committed offsets to list. MUST only be one single element. list_grpoffsets_cnt <code>int|null</code> size_t - Number of elements in <code>list_grpoffsets</code> array. MUST always be 1. options <code>\\FFI\\CData|null</code> const rd_kafka_AdminOptions_t* - Optional admin options, or NULL for defaults. rkqu <code>\\FFI\\CData|null</code> rd_kafka_queue_t* - Queue to emit result on. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ab51163573f8a19f0ec240428fd8fca3e </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_listconsumergroupoffsets_result_groups","title":"rd_kafka_ListConsumerGroupOffsets_result_groups()","text":"<pre><code>public static rd_kafka_ListConsumerGroupOffsets_result_groups ( \n    \\FFI\\CData|null $result, \n    \\FFI\\CData|null $cntp\n ): \\FFI\\CData|null\n</code></pre> <p>Get an array of results from a ListConsumerGroupOffsets result. </p> <p>The returned groups life-time is the same as the <code>result</code> object.</p> RemarksThe lifetime of the returned memory is the same as the lifetime of the <code>result</code> object.  Parameters result <code>\\FFI\\CData|null</code> const rd_kafka_ListConsumerGroupOffsets_result_t* - Result to get group results from. cntp <code>\\FFI\\CData|null</code> size_t* - is updated to the number of elements in the array. Returns <code>\\FFI\\CData|null</code> const rd_kafka_group_result_t** <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a0b4b3b9c5388038f4aac0e939f56854d </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_alterconsumergroupoffsets_new","title":"rd_kafka_AlterConsumerGroupOffsets_new()","text":"<pre><code>public static rd_kafka_AlterConsumerGroupOffsets_new ( \n    string|null $group_id, \n    \\FFI\\CData|null $partitions\n ): \\FFI\\CData|null\n</code></pre> <p>Create a new AlterConsumerGroupOffsets object. This object is later passed to rd_kafka_AlterConsumerGroupOffsets(). </p> Parameters group_id <code>string|null</code> const char* - Consumer group id. partitions <code>\\FFI\\CData|null</code> const rd_kafka_topic_partition_list_t* - Partitions to alter committed offsets for. Only the topic and partition fields are used. Returns <code>\\FFI\\CData|null</code> rd_kafka_AlterConsumerGroupOffsets_t* - a new allocated AlterConsumerGroupOffsets object. Use rd_kafka_AlterConsumerGroupOffsets_destroy() to free object when done. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aa04df04ed898431c1d85e57e9dfb020e </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_alterconsumergroupoffsets_destroy","title":"rd_kafka_AlterConsumerGroupOffsets_destroy()","text":"<pre><code>public static rd_kafka_AlterConsumerGroupOffsets_destroy ( \n    \\FFI\\CData|null $alter_grpoffsets\n ): void\n</code></pre> Parameters alter_grpoffsets <code>\\FFI\\CData|null</code> rd_kafka_AlterConsumerGroupOffsets_t*"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_alterconsumergroupoffsets_destroy_array","title":"rd_kafka_AlterConsumerGroupOffsets_destroy_array()","text":"<pre><code>public static rd_kafka_AlterConsumerGroupOffsets_destroy_array ( \n    \\FFI\\CData|null $alter_grpoffsets, \n    int|null $alter_grpoffset_cnt\n ): void\n</code></pre> Parameters alter_grpoffsets <code>\\FFI\\CData|null</code> rd_kafka_AlterConsumerGroupOffsets_t** alter_grpoffset_cnt <code>int|null</code> size_t"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_alterconsumergroupoffsets","title":"rd_kafka_AlterConsumerGroupOffsets()","text":"<pre><code>public static rd_kafka_AlterConsumerGroupOffsets ( \n    \\FFI\\CData|null $rk, \n    \\FFI\\CData|null $alter_grpoffsets, \n    int|null $alter_grpoffsets_cnt, \n    \\FFI\\CData|null $options, \n    \\FFI\\CData|null $rkqu\n ): void\n</code></pre> <p>Alter committed offsets for a set of partitions in a consumer group. This will succeed at the partition level only if the group is not actively subscribed to the corresponding topic. </p> RemarksThe result event type emitted on the supplied queue is of type <code>RD_KAFKA_EVENT_ALTERCONSUMERGROUPOFFSETS_RESULT</code>  The current implementation only supports one group per invocation.  Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* - Client instance. alter_grpoffsets <code>\\FFI\\CData|null</code> rd_kafka_AlterConsumerGroupOffsets_t** - Array of group committed offsets to alter. MUST only be one single element. alter_grpoffsets_cnt <code>int|null</code> size_t - Number of elements in <code>alter_grpoffsets</code> array. MUST always be 1. options <code>\\FFI\\CData|null</code> const rd_kafka_AdminOptions_t* - Optional admin options, or NULL for defaults. rkqu <code>\\FFI\\CData|null</code> rd_kafka_queue_t* - Queue to emit result on. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a3bebec377020469583f6c8e2f0b06ec8 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_alterconsumergroupoffsets_result_groups","title":"rd_kafka_AlterConsumerGroupOffsets_result_groups()","text":"<pre><code>public static rd_kafka_AlterConsumerGroupOffsets_result_groups ( \n    \\FFI\\CData|null $result, \n    \\FFI\\CData|null $cntp\n ): \\FFI\\CData|null\n</code></pre> <p>Get an array of results from a AlterConsumerGroupOffsets result. </p> <p>The returned groups life-time is the same as the <code>result</code> object.</p> RemarksThe lifetime of the returned memory is the same as the lifetime of the <code>result</code> object.  Parameters result <code>\\FFI\\CData|null</code> const rd_kafka_AlterConsumerGroupOffsets_result_t* - Result to get group results from. cntp <code>\\FFI\\CData|null</code> size_t* - is updated to the number of elements in the array. Returns <code>\\FFI\\CData|null</code> const rd_kafka_group_result_t** <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a7eff1952f24e1d5f2bde678165886731 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_mock_broker_error_stack_cnt","title":"rd_kafka_mock_broker_error_stack_cnt()","text":"<pre><code>public static rd_kafka_mock_broker_error_stack_cnt ( \n    \\FFI\\CData|null $mcluster, \n    int|null $broker_id, \n    int|null $ApiKey, \n    \\FFI\\CData|null $cntp\n ): int\n</code></pre> Parameters mcluster <code>\\FFI\\CData|null</code> rd_kafka_mock_cluster_t* broker_id <code>int|null</code> int32_t ApiKey <code>int|null</code> int16_t cntp <code>\\FFI\\CData|null</code> size_t* Returns <code>int</code> rd_kafka_resp_err_t"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_topic_partition_set_leader_epoch","title":"rd_kafka_topic_partition_set_leader_epoch()","text":"<pre><code>public static rd_kafka_topic_partition_set_leader_epoch ( \n    \\FFI\\CData|null $rktpar, \n    int|null $leader_epoch\n ): void\n</code></pre> <p>Sets the offset leader epoch (use -1 to clear). </p> RemarksSee KIP-320 for more information.  Parameters rktpar <code>\\FFI\\CData|null</code> rd_kafka_topic_partition_t* - Partition object. leader_epoch <code>int|null</code> int32_t - Offset leader epoch, use -1 to reset. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ab70804a35d1a6e8c21f276d75ef8ea6e </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_topic_partition_get_leader_epoch","title":"rd_kafka_topic_partition_get_leader_epoch()","text":"<pre><code>public static rd_kafka_topic_partition_get_leader_epoch ( \n    \\FFI\\CData|null $rktpar\n ): int|null\n</code></pre> RemarksSee KIP-320 for more information.  Parameters rktpar <code>\\FFI\\CData|null</code> const rd_kafka_topic_partition_t* - ) - Partition object. Returns <code>int|null</code> int32_t - the offset leader epoch, if relevant and known, else -1. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ad8ae250ddb522b220b64e0b1627ad8b8 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_message_leader_epoch","title":"rd_kafka_message_leader_epoch()","text":"<pre><code>public static rd_kafka_message_leader_epoch ( \n    \\FFI\\CData|null $rkmessage\n ): int|null\n</code></pre> RemarksThis API must only be used on consumed messages without error.   Requires broker version &gt;= 2.10 (KIP-320).  Parameters rkmessage <code>\\FFI\\CData|null</code> const rd_kafka_message_t* - ) Returns <code>int|null</code> int32_t - the message\u2019s partition leader epoch at the time the message was fetched and if known, else -1. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ad9afdf40e60628338c3efcacba4727a2 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_offset_store_message","title":"rd_kafka_offset_store_message()","text":"<pre><code>public static rd_kafka_offset_store_message ( \n    \\FFI\\CData|null $rkmessage\n ): \\FFI\\CData|null\n</code></pre> <p>Store offset +1 for the consumed message. </p> <p>The message offset + 1 will be committed to broker according to <code><code>auto.commit.interval.ms</code></code> or manual offset-less commit()</p> WarningThis method may only be called for partitions that are currently assigned. Non-assigned partitions will fail with RD_KAFKA_RESP_ERR__STATE. Since v1.9.0.  Avoid storing offsets after calling rd_kafka_seek() (et.al) as this may later interfere with resuming a paused partition, instead store offsets prior to calling seek. Remarks<code><code>enable.auto.offset.store</code></code> must be set to \"false\" when using this API. Parameters rkmessage <code>\\FFI\\CData|null</code> rd_kafka_message_t* - ) Returns <code>\\FFI\\CData|null</code> rd_kafka_error_t* - NULL on success or an error object on failure. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a85d589ef6cb2d6a1d34e5594949bc9ee </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_event_incrementalalterconfigs_result","title":"rd_kafka_event_IncrementalAlterConfigs_result()","text":"<pre><code>public static rd_kafka_event_IncrementalAlterConfigs_result ( \n    \\FFI\\CData|null $rkev\n ): \\FFI\\CData|null\n</code></pre> <p>Get IncrementalAlterConfigs result. </p> <p>Event types: RD_KAFKA_EVENT_INCREMENTALALTERCONFIGS_RESULT </p> Parameters rkev <code>\\FFI\\CData|null</code> rd_kafka_event_t* - ) Returns <code>\\FFI\\CData|null</code> const rd_kafka_IncrementalAlterConfigs_result_t* - the result of a IncrementalAlterConfigs request, or NULL if event is of different type. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8e76c2d637218310d8868af31649b97a </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_event_describeuserscramcredentials_result","title":"rd_kafka_event_DescribeUserScramCredentials_result()","text":"<pre><code>public static rd_kafka_event_DescribeUserScramCredentials_result ( \n    \\FFI\\CData|null $rkev\n ): \\FFI\\CData|null\n</code></pre> <p>Get DescribeUserScramCredentials result. </p> RemarksThe lifetime of the returned memory is the same as the lifetime of the <code>rkev</code> object. <p>Event types: RD_KAFKA_EVENT_DESCRIBEUSERSCRAMCREDENTIALS_RESULT </p> Parameters rkev <code>\\FFI\\CData|null</code> rd_kafka_event_t* - ) Returns <code>\\FFI\\CData|null</code> const rd_kafka_DescribeUserScramCredentials_result_t* - the result of a DescribeUserScramCredentials request, or NULL if event is of different type. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a69853c3d64324a45341b2a68b0e2026e </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_event_alteruserscramcredentials_result","title":"rd_kafka_event_AlterUserScramCredentials_result()","text":"<pre><code>public static rd_kafka_event_AlterUserScramCredentials_result ( \n    \\FFI\\CData|null $rkev\n ): \\FFI\\CData|null\n</code></pre> <p>Get AlterUserScramCredentials result. </p> RemarksThe lifetime of the returned memory is the same as the lifetime of the <code>rkev</code> object. <p>Event types: RD_KAFKA_EVENT_ALTERUSERSCRAMCREDENTIALS_RESULT </p> Parameters rkev <code>\\FFI\\CData|null</code> rd_kafka_event_t* - ) Returns <code>\\FFI\\CData|null</code> const rd_kafka_AlterUserScramCredentials_result_t* - the result of a AlterUserScramCredentials request, or NULL if event is of different type. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#abb9995f278c3eaf8e4bc6caba254ba0a </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_configresource_add_incremental_config","title":"rd_kafka_ConfigResource_add_incremental_config()","text":"<pre><code>public static rd_kafka_ConfigResource_add_incremental_config ( \n    \\FFI\\CData|null $config, \n    string|null $name, \n    int $op_type, \n    string|null $value\n ): \\FFI\\CData|null\n</code></pre> <p>Add the value of the configuration entry for a subsequent incremental alter config operation. APPEND and SUBTRACT are possible for list-type configuration entries only. </p> Parameters config <code>\\FFI\\CData|null</code> rd_kafka_ConfigResource_t* - ConfigResource to add config property to. name <code>string|null</code> const char* - Configuration name, depends on resource type. op_type <code>int</code> rd_kafka_AlterConfigOpType_t - Operation type, one of rd_kafka_AlterConfigOpType_t. value <code>string|null</code> const char* - Configuration value, depends on resource type and <code>name</code>. Set to <code>NULL</code>, only with with op_type set to DELETE, to revert configuration value to default. Returns <code>\\FFI\\CData|null</code> rd_kafka_error_t* - NULL on success, or an rd_kafka_error_t * with the corresponding error code and string. Error ownership belongs to the caller. Possible error codes:<ul> <li>RD_KAFKA_RESP_ERR__INVALID_ARG on invalid input. </li> </ul> <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ae989f95effcebe295a2a37c15d29b5ed </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_incrementalalterconfigs","title":"rd_kafka_IncrementalAlterConfigs()","text":"<pre><code>public static rd_kafka_IncrementalAlterConfigs ( \n    \\FFI\\CData|null $rk, \n    \\FFI\\CData|null $configs, \n    int|null $config_cnt, \n    \\FFI\\CData|null $options, \n    \\FFI\\CData|null $rkqu\n ): void\n</code></pre> <p>Incrementally update the configuration for the specified resources. Updates are not transactional so they may succeed for some resources while fail for others. The configs for a particular resource are updated atomically, executing the corresponding incremental operations on the provided configurations. </p> RemarksRequires broker version &gt;=2.3.0  Multiple resources and resource types may be set, but at most one resource of type <code>RD_KAFKA_RESOURCE_BROKER</code> is allowed per call since these resource requests must be sent to the broker specified in the resource. Broker option will be ignored in this case. Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* - Client instance. configs <code>\\FFI\\CData|null</code> rd_kafka_ConfigResource_t** - Array of config entries to alter. config_cnt <code>int|null</code> size_t - Number of elements in <code>configs</code> array. options <code>\\FFI\\CData|null</code> const rd_kafka_AdminOptions_t* - Optional admin options, or NULL for defaults. rkqu <code>\\FFI\\CData|null</code> rd_kafka_queue_t* - Queue to emit result on. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a36805ba8496fed43f6e87421c259804b </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_incrementalalterconfigs_result_resources","title":"rd_kafka_IncrementalAlterConfigs_result_resources()","text":"<pre><code>public static rd_kafka_IncrementalAlterConfigs_result_resources ( \n    \\FFI\\CData|null $result, \n    \\FFI\\CData|null $cntp\n ): \\FFI\\CData|null\n</code></pre> <p>Get an array of resource results from a IncrementalAlterConfigs result. </p> <p>Use <code>rd_kafka_ConfigResource_error()</code> and <code>rd_kafka_ConfigResource_error_string()</code> to extract per-resource error results on the returned array elements.</p> <p>The returned object life-times are the same as the <code>result</code> object.</p> Parameters result <code>\\FFI\\CData|null</code> const rd_kafka_IncrementalAlterConfigs_result_t* - Result object to get resource results from. cntp <code>\\FFI\\CData|null</code> size_t* - is updated to the number of elements in the array. Returns <code>\\FFI\\CData|null</code> const rd_kafka_ConfigResource_t** - an array of ConfigResource elements, or NULL if not available. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ad1d8458aa405d06de7feb716ae5144b5 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_scramcredentialinfo_mechanism","title":"rd_kafka_ScramCredentialInfo_mechanism()","text":"<pre><code>public static rd_kafka_ScramCredentialInfo_mechanism ( \n    \\FFI\\CData|null $scram_credential_info\n ): int\n</code></pre> Parameters scram_credential_info <code>\\FFI\\CData|null</code> const rd_kafka_ScramCredentialInfo_t* Returns <code>int</code> rd_kafka_ScramMechanism_t"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_scramcredentialinfo_iterations","title":"rd_kafka_ScramCredentialInfo_iterations()","text":"<pre><code>public static rd_kafka_ScramCredentialInfo_iterations ( \n    \\FFI\\CData|null $scram_credential_info\n ): int|null\n</code></pre> Parameters scram_credential_info <code>\\FFI\\CData|null</code> const rd_kafka_ScramCredentialInfo_t* Returns <code>int|null</code> int32_t"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_userscramcredentialsdescription_user","title":"rd_kafka_UserScramCredentialsDescription_user()","text":"<pre><code>public static rd_kafka_UserScramCredentialsDescription_user ( \n    \\FFI\\CData|null $description\n ): string|null\n</code></pre> Parameters description <code>\\FFI\\CData|null</code> const rd_kafka_UserScramCredentialsDescription_t* Returns <code>string|null</code> const char*"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_userscramcredentialsdescription_error","title":"rd_kafka_UserScramCredentialsDescription_error()","text":"<pre><code>public static rd_kafka_UserScramCredentialsDescription_error ( \n    \\FFI\\CData|null $description\n ): \\FFI\\CData|null\n</code></pre> Parameters description <code>\\FFI\\CData|null</code> const rd_kafka_UserScramCredentialsDescription_t* Returns <code>\\FFI\\CData|null</code> const rd_kafka_error_t*"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_userscramcredentialsdescription_scramcredentialinfo_count","title":"rd_kafka_UserScramCredentialsDescription_scramcredentialinfo_count()","text":"<pre><code>public static rd_kafka_UserScramCredentialsDescription_scramcredentialinfo_count ( \n    \\FFI\\CData|null $description\n ): int|null\n</code></pre> Parameters description <code>\\FFI\\CData|null</code> const rd_kafka_UserScramCredentialsDescription_t* Returns <code>int|null</code> size_t"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_userscramcredentialsdescription_scramcredentialinfo","title":"rd_kafka_UserScramCredentialsDescription_scramcredentialinfo()","text":"<pre><code>public static rd_kafka_UserScramCredentialsDescription_scramcredentialinfo ( \n    \\FFI\\CData|null $description, \n    int|null $idx\n ): \\FFI\\CData|null\n</code></pre> Parameters description <code>\\FFI\\CData|null</code> const rd_kafka_UserScramCredentialsDescription_t* idx <code>int|null</code> size_t Returns <code>\\FFI\\CData|null</code> const rd_kafka_ScramCredentialInfo_t*"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_describeuserscramcredentials_result_descriptions","title":"rd_kafka_DescribeUserScramCredentials_result_descriptions()","text":"<pre><code>public static rd_kafka_DescribeUserScramCredentials_result_descriptions ( \n    \\FFI\\CData|null $result, \n    \\FFI\\CData|null $cntp\n ): \\FFI\\CData|null\n</code></pre> <p>Get an array of descriptions from a DescribeUserScramCredentials result. </p> <p>The returned value life-time is the same as the <code>result</code> object.</p> Parameters result <code>\\FFI\\CData|null</code> const rd_kafka_DescribeUserScramCredentials_result_t* - Result to get descriptions from. cntp <code>\\FFI\\CData|null</code> size_t* - is updated to the number of elements in the array. Returns <code>\\FFI\\CData|null</code> const rd_kafka_UserScramCredentialsDescription_t** <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a1d6db38eb4f640a20a5806da2b12bc47 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_describeuserscramcredentials","title":"rd_kafka_DescribeUserScramCredentials()","text":"<pre><code>public static rd_kafka_DescribeUserScramCredentials ( \n    \\FFI\\CData|null $rk, \n    \\FFI\\CData|null $users, \n    int|null $user_cnt, \n    \\FFI\\CData|null $options, \n    \\FFI\\CData|null $rkqu\n ): void\n</code></pre> <p>Describe SASL/SCRAM credentials. This operation is supported by brokers with version 2.7.0 or higher. </p> Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* - Client instance. users <code>\\FFI\\CData|null</code> const char** - The users for which credentials are to be described. All users\u2019 credentials are described if NULL. user_cnt <code>int|null</code> size_t - Number of elements in <code>users</code> array. options <code>\\FFI\\CData|null</code> const rd_kafka_AdminOptions_t* - Optional admin options, or NULL for defaults. rkqu <code>\\FFI\\CData|null</code> rd_kafka_queue_t* - Queue to emit result on. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ac9d2f72dd1dddce0c7d24a4e413b3cf5 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_userscramcredentialupsertion_new","title":"rd_kafka_UserScramCredentialUpsertion_new()","text":"<pre><code>public static rd_kafka_UserScramCredentialUpsertion_new ( \n    string|null $username, \n    int $mechanism, \n    int|null $iterations, \n    \\FFI\\CData|null $password, \n    int|null $password_size, \n    \\FFI\\CData|null $salt, \n    int|null $salt_size\n ): \\FFI\\CData|null\n</code></pre> <p>Allocates a new UserScramCredentialUpsertion given its fields. If salt isn't given a 64 B salt is generated using OpenSSL RAND_priv_bytes, if available. </p> RemarksA random salt is generated, when NULL, only if OpenSSL &gt;= 1.1.1. Otherwise it's a required param. Parameters username <code>string|null</code> const char* - The username (not empty). mechanism <code>int</code> rd_kafka_ScramMechanism_t - SASL/SCRAM mechanism. iterations <code>int|null</code> int32_t - SASL/SCRAM iterations. password <code>\\FFI\\CData|null</code> const unsigned char* - Password bytes (not empty). password_size <code>int|null</code> size_t - Size of <code>password</code> (greater than 0). salt <code>\\FFI\\CData|null</code> const unsigned char* - Salt bytes (optional). salt_size <code>int|null</code> size_t - Size of <code>salt</code> (optional). Returns <code>\\FFI\\CData|null</code> rd_kafka_UserScramCredentialAlteration_t* - A newly created instance of rd_kafka_UserScramCredentialAlteration_t. Ownership belongs to the caller, use rd_kafka_UserScramCredentialAlteration_destroy to destroy. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ae1707143331cd5b798d25cb8df33df5f </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_userscramcredentialdeletion_new","title":"rd_kafka_UserScramCredentialDeletion_new()","text":"<pre><code>public static rd_kafka_UserScramCredentialDeletion_new ( \n    string|null $username, \n    int $mechanism\n ): \\FFI\\CData|null\n</code></pre> <p>Allocates a new UserScramCredentialDeletion given its fields. </p> Parameters username <code>string|null</code> const char* - The username (not empty). mechanism <code>int</code> rd_kafka_ScramMechanism_t - SASL/SCRAM mechanism. Returns <code>\\FFI\\CData|null</code> rd_kafka_UserScramCredentialAlteration_t* - A newly created instance of rd_kafka_UserScramCredentialAlteration_t. Ownership belongs to the caller, use rd_kafka_UserScramCredentialAlteration_destroy to destroy. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a89e57d12d9415354fcbbf1d7b0072db2 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_userscramcredentialalteration_destroy","title":"rd_kafka_UserScramCredentialAlteration_destroy()","text":"<pre><code>public static rd_kafka_UserScramCredentialAlteration_destroy ( \n    \\FFI\\CData|null $alteration\n ): void\n</code></pre> Parameters alteration <code>\\FFI\\CData|null</code> rd_kafka_UserScramCredentialAlteration_t*"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_userscramcredentialalteration_destroy_array","title":"rd_kafka_UserScramCredentialAlteration_destroy_array()","text":"<pre><code>public static rd_kafka_UserScramCredentialAlteration_destroy_array ( \n    \\FFI\\CData|null $alterations, \n    int|null $alteration_cnt\n ): void\n</code></pre> Parameters alterations <code>\\FFI\\CData|null</code> rd_kafka_UserScramCredentialAlteration_t** alteration_cnt <code>int|null</code> size_t"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_alteruserscramcredentials_result_response_user","title":"rd_kafka_AlterUserScramCredentials_result_response_user()","text":"<pre><code>public static rd_kafka_AlterUserScramCredentials_result_response_user ( \n    \\FFI\\CData|null $response\n ): string|null\n</code></pre> Parameters response <code>\\FFI\\CData|null</code> const rd_kafka_AlterUserScramCredentials_result_response_t* Returns <code>string|null</code> const char*"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_alteruserscramcredentials_result_response_error","title":"rd_kafka_AlterUserScramCredentials_result_response_error()","text":"<pre><code>public static rd_kafka_AlterUserScramCredentials_result_response_error ( \n    \\FFI\\CData|null $response\n ): \\FFI\\CData|null\n</code></pre> Parameters response <code>\\FFI\\CData|null</code> const rd_kafka_AlterUserScramCredentials_result_response_t* Returns <code>\\FFI\\CData|null</code> const rd_kafka_error_t*"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_alteruserscramcredentials_result_responses","title":"rd_kafka_AlterUserScramCredentials_result_responses()","text":"<pre><code>public static rd_kafka_AlterUserScramCredentials_result_responses ( \n    \\FFI\\CData|null $result, \n    \\FFI\\CData|null $cntp\n ): \\FFI\\CData|null\n</code></pre> <p>Get an array of responses from a AlterUserScramCredentials result. </p> <p>The returned value life-time is the same as the <code>result</code> object.</p> Parameters result <code>\\FFI\\CData|null</code> const rd_kafka_AlterUserScramCredentials_result_t* - Result to get responses from. cntp <code>\\FFI\\CData|null</code> size_t* - is updated to the number of elements in the array. Returns <code>\\FFI\\CData|null</code> const rd_kafka_AlterUserScramCredentials_result_response_t** <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#abf118e72e7bea8ad0cd56a950dcfe2b3 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_alteruserscramcredentials","title":"rd_kafka_AlterUserScramCredentials()","text":"<pre><code>public static rd_kafka_AlterUserScramCredentials ( \n    \\FFI\\CData|null $rk, \n    \\FFI\\CData|null $alterations, \n    int|null $alteration_cnt, \n    \\FFI\\CData|null $options, \n    \\FFI\\CData|null $rkqu\n ): void\n</code></pre> <p>Alter SASL/SCRAM credentials. This operation is supported by brokers with version 2.7.0 or higher. </p> RemarksFor upsertions to be processed, librdkfka must be build with OpenSSL support. It's needed to calculate the HMAC. Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* - Client instance. alterations <code>\\FFI\\CData|null</code> rd_kafka_UserScramCredentialAlteration_t** - The alterations to be applied. alteration_cnt <code>int|null</code> size_t - Number of elements in <code>alterations</code> array. options <code>\\FFI\\CData|null</code> const rd_kafka_AdminOptions_t* - Optional admin options, or NULL for defaults. rkqu <code>\\FFI\\CData|null</code> rd_kafka_queue_t* - Queue to emit result on. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ab02fa9f8f192f78c1ffb0111b0f5cb2f </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_uuid_base64str","title":"rd_kafka_Uuid_base64str()","text":"<pre><code>public static rd_kafka_Uuid_base64str ( \n    \\FFI\\CData|null $uuid\n ): string|null\n</code></pre> <p>Computes base64 encoding for the given uuid string. </p> Parameters uuid <code>\\FFI\\CData|null</code> const rd_kafka_Uuid_t* - ) - UUID for which base64 encoding is required. Returns <code>string|null</code> const char* - base64 encoded string for the given UUID or NULL in case of some issue with the conversion or the conversion is not supported. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a50639fc35e5e639ab5851857ed806b93 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_uuid_least_significant_bits","title":"rd_kafka_Uuid_least_significant_bits()","text":"<pre><code>public static rd_kafka_Uuid_least_significant_bits ( \n    \\FFI\\CData|null $uuid\n ): int|null\n</code></pre> <p>Gets least significant 64 bits for the given UUID. </p> Parameters uuid <code>\\FFI\\CData|null</code> const rd_kafka_Uuid_t* - ) - UUID Returns <code>int|null</code> int64_t - least significant 64 bits for the given UUID. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#afda9d744c58d439823bd9e06f5fbf851 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_uuid_most_significant_bits","title":"rd_kafka_Uuid_most_significant_bits()","text":"<pre><code>public static rd_kafka_Uuid_most_significant_bits ( \n    \\FFI\\CData|null $uuid\n ): int|null\n</code></pre> <p>Gets most significant 64 bits for the given UUID. </p> Parameters uuid <code>\\FFI\\CData|null</code> const rd_kafka_Uuid_t* - ) - UUID Returns <code>int|null</code> int64_t - most significant 64 bits for the given UUID. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a443577282d2071374f20896ce2f97a91 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_uuid_new","title":"rd_kafka_Uuid_new()","text":"<pre><code>public static rd_kafka_Uuid_new ( \n    int|null $most_significant_bits, \n    int|null $least_significant_bits\n ): \\FFI\\CData|null\n</code></pre> <p>Creates a new UUID. </p> RemarksMust be freed after use using rd_kafka_Uuid_destroy()  Parameters most_significant_bits <code>int|null</code> int64_t - most significant 64 bits of the 128 bits UUID. least_significant_bits <code>int|null</code> int64_t - least significant 64 bits of the 128 bits UUID. Returns <code>\\FFI\\CData|null</code> rd_kafka_Uuid_t* - A newly allocated UUID. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a0462c0b4858b2c2df6506b123ee9358c </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_uuid_copy","title":"rd_kafka_Uuid_copy()","text":"<pre><code>public static rd_kafka_Uuid_copy ( \n    \\FFI\\CData|null $uuid\n ): \\FFI\\CData|null\n</code></pre> <p>Copies the given UUID. </p> RemarksMust be freed after use using rd_kafka_Uuid_destroy()  Parameters uuid <code>\\FFI\\CData|null</code> const rd_kafka_Uuid_t* - ) - UUID to be copied. Returns <code>\\FFI\\CData|null</code> rd_kafka_Uuid_t* - A newly allocated copy of the provided UUID. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#adb76dc69e22b2fd34b9dfb881f685a07 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_uuid_destroy","title":"rd_kafka_Uuid_destroy()","text":"<pre><code>public static rd_kafka_Uuid_destroy ( \n    \\FFI\\CData|null $uuid\n ): void\n</code></pre> <p>Destroy the provided uuid. </p> Parameters uuid <code>\\FFI\\CData|null</code> rd_kafka_Uuid_t* - ) - UUID <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a04e21c3278dc96745bfb232df69dbfce </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_node_rack","title":"rd_kafka_Node_rack()","text":"<pre><code>public static rd_kafka_Node_rack ( \n    \\FFI\\CData|null $node\n ): string|null\n</code></pre> <p>Get the rack of <code>node</code>. </p> Parameters node <code>\\FFI\\CData|null</code> const rd_kafka_Node_t* - ) - The Node instance Returns <code>string|null</code> const char* - The node rack id. May be NULL. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a4082b53761808c022c49700988138dc7 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_event_describetopics_result","title":"rd_kafka_event_DescribeTopics_result()","text":"<pre><code>public static rd_kafka_event_DescribeTopics_result ( \n    \\FFI\\CData|null $rkev\n ): \\FFI\\CData|null\n</code></pre> <p>Get DescribeTopics result. </p> RemarksThe lifetime of the returned memory is the same as the lifetime of the <code>rkev</code> object. <p>Event types: RD_KAFKA_EVENT_DESCRIBETOPICS_RESULT </p> Parameters rkev <code>\\FFI\\CData|null</code> rd_kafka_event_t* - ) Returns <code>\\FFI\\CData|null</code> const rd_kafka_DescribeTopics_result_t* - the result of a DescribeTopics request, or NULL if event is of different type. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a3bdad3fc99fb284859e6ef258efcae89 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_event_describecluster_result","title":"rd_kafka_event_DescribeCluster_result()","text":"<pre><code>public static rd_kafka_event_DescribeCluster_result ( \n    \\FFI\\CData|null $rkev\n ): \\FFI\\CData|null\n</code></pre> <p>Get DescribeCluster result. </p> RemarksThe lifetime of the returned memory is the same as the lifetime of the <code>rkev</code> object. <p>Event types: RD_KAFKA_EVENT_DESCRIBECLUSTER_RESULT </p> Parameters rkev <code>\\FFI\\CData|null</code> rd_kafka_event_t* - ) Returns <code>\\FFI\\CData|null</code> const rd_kafka_DescribeCluster_result_t* - the result of a DescribeCluster request, or NULL if event is of different type. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aeb5c6a8c359bc0f0a769f8e6efa72c44 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_event_listoffsets_result","title":"rd_kafka_event_ListOffsets_result()","text":"<pre><code>public static rd_kafka_event_ListOffsets_result ( \n    \\FFI\\CData|null $rkev\n ): \\FFI\\CData|null\n</code></pre> <p>Get ListOffsets result. </p> RemarksThe lifetime of the returned memory is the same as the lifetime of the <code>rkev</code> object. <p>Event types: RD_KAFKA_EVENT_LISTOFFSETS_RESULT </p> Parameters rkev <code>\\FFI\\CData|null</code> rd_kafka_event_t* - ) Returns <code>\\FFI\\CData|null</code> const rd_kafka_ListOffsets_result_t* - the result of a ListOffsets request, or NULL if event is of different type. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a3851a3f25c563e7e2f18c756772d84be </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_adminoptions_set_include_authorized_operations","title":"rd_kafka_AdminOptions_set_include_authorized_operations()","text":"<pre><code>public static rd_kafka_AdminOptions_set_include_authorized_operations ( \n    \\FFI\\CData|null $options, \n    int|null $true_or_false\n ): \\FFI\\CData|null\n</code></pre> <p>Whether broker should return authorized operations for the given resource in the DescribeConsumerGroups, DescribeTopics, or DescribeCluster calls. </p> RemarksThis option is valid for DescribeConsumerGroups, DescribeTopics, DescribeCluster.  Parameters options <code>\\FFI\\CData|null</code> rd_kafka_AdminOptions_t* - Admin options. true_or_false <code>int|null</code> int - Defaults to false. Returns <code>\\FFI\\CData|null</code> rd_kafka_error_t* - NULL on success, a new error instance that must be released with rd_kafka_error_destroy() in case of error. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a22c4e359f297cf03f5a109cb72093a27 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_adminoptions_set_isolation_level","title":"rd_kafka_AdminOptions_set_isolation_level()","text":"<pre><code>public static rd_kafka_AdminOptions_set_isolation_level ( \n    \\FFI\\CData|null $options, \n    int $value\n ): \\FFI\\CData|null\n</code></pre> Parameters options <code>\\FFI\\CData|null</code> rd_kafka_AdminOptions_t* value <code>int</code> rd_kafka_IsolationLevel_t Returns <code>\\FFI\\CData|null</code> rd_kafka_error_t*"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_topiccollection_of_topic_names","title":"rd_kafka_TopicCollection_of_topic_names()","text":"<pre><code>public static rd_kafka_TopicCollection_of_topic_names ( \n    \\FFI\\CData|null $topics, \n    int|null $topics_cnt\n ): \\FFI\\CData|null\n</code></pre> <p>Creates a new TopicCollection for passing to rd_kafka_DescribeTopics. </p> Parameters topics <code>\\FFI\\CData|null</code> const char** - A list of topics. topics_cnt <code>int|null</code> size_t - Count of topics. Returns <code>\\FFI\\CData|null</code> rd_kafka_TopicCollection_t* - a newly allocated TopicCollection object. Must be freed using rd_kafka_TopicCollection_destroy when done. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ab9af9e28d53872823af6702d1b01d378 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_topiccollection_destroy","title":"rd_kafka_TopicCollection_destroy()","text":"<pre><code>public static rd_kafka_TopicCollection_destroy ( \n    \\FFI\\CData|null $topics\n ): void\n</code></pre> Parameters topics <code>\\FFI\\CData|null</code> rd_kafka_TopicCollection_t*"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_describetopics","title":"rd_kafka_DescribeTopics()","text":"<pre><code>public static rd_kafka_DescribeTopics ( \n    \\FFI\\CData|null $rk, \n    \\FFI\\CData|null $topics, \n    \\FFI\\CData|null $options, \n    \\FFI\\CData|null $rkqu\n ): void\n</code></pre> <p>Describe topics as specified by the <code>topics</code> array of size <code>topics_cnt</code> elements. </p> RemarksThe result event type emitted on the supplied queue is of type <code>RD_KAFKA_EVENT_DESCRIBETOPICS_RESULT</code> Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* - Client instance. topics <code>\\FFI\\CData|null</code> const rd_kafka_TopicCollection_t* - Collection of topics to describe. options <code>\\FFI\\CData|null</code> const rd_kafka_AdminOptions_t* - Optional admin options, or NULL for defaults. Valid options:<ul> <li>include_authorized_operations </li> </ul> rkqu <code>\\FFI\\CData|null</code> rd_kafka_queue_t* - Queue to emit result on. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a71e57916fc3936132289c81974c54c71 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_describetopics_result_topics","title":"rd_kafka_DescribeTopics_result_topics()","text":"<pre><code>public static rd_kafka_DescribeTopics_result_topics ( \n    \\FFI\\CData|null $result, \n    \\FFI\\CData|null $cntp\n ): \\FFI\\CData|null\n</code></pre> <p>Get an array of topic results from a DescribeTopics result. </p> RemarksThe lifetime of the returned memory is the same as the lifetime of the <code>result</code> object.  Parameters result <code>\\FFI\\CData|null</code> const rd_kafka_DescribeTopics_result_t* - Result to get topics results from. cntp <code>\\FFI\\CData|null</code> size_t* - is updated to the number of elements in the array. Returns <code>\\FFI\\CData|null</code> const rd_kafka_TopicDescription_t** <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a88c8a277f6001c95bf5d04fde169c4e2 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_topicdescription_partitions","title":"rd_kafka_TopicDescription_partitions()","text":"<pre><code>public static rd_kafka_TopicDescription_partitions ( \n    \\FFI\\CData|null $topicdesc, \n    \\FFI\\CData|null $cntp\n ): \\FFI\\CData|null\n</code></pre> <p>Gets an array of partitions for the <code>topicdesc</code> topic. </p> RemarksThe lifetime of the returned memory is the same as the lifetime of the <code>topicdesc</code> object.  Parameters topicdesc <code>\\FFI\\CData|null</code> const rd_kafka_TopicDescription_t* - The topic description. cntp <code>\\FFI\\CData|null</code> size_t* - is updated to the number of partitions in the array. Returns <code>\\FFI\\CData|null</code> const rd_kafka_TopicPartitionInfo_t** - An array of TopicPartitionInfos. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a55b846a85b6ca8174d976e559c82f999 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_topicpartitioninfo_partition","title":"rd_kafka_TopicPartitionInfo_partition()","text":"<pre><code>public static rd_kafka_TopicPartitionInfo_partition ( \n    \\FFI\\CData|null $partition\n ): int|null\n</code></pre> <p>Gets the partition id for <code>partition</code>. </p> Parameters partition <code>\\FFI\\CData|null</code> const rd_kafka_TopicPartitionInfo_t* - ) - The partition info. Returns <code>int|null</code> const int - The partition id. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#af75739639e889e477d6f1a98cea88b25 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_topicpartitioninfo_leader","title":"rd_kafka_TopicPartitionInfo_leader()","text":"<pre><code>public static rd_kafka_TopicPartitionInfo_leader ( \n    \\FFI\\CData|null $partition\n ): \\FFI\\CData|null\n</code></pre> <p>Gets the partition leader for <code>partition</code>. </p> RemarksThe lifetime of the returned memory is the same as the lifetime of the <code>partition</code> object.  Parameters partition <code>\\FFI\\CData|null</code> const rd_kafka_TopicPartitionInfo_t* - ) - The partition info. Returns <code>\\FFI\\CData|null</code> const rd_kafka_Node_t* - The partition leader. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a678305c429a8566a0b78d4298847ab03 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_topicpartitioninfo_isr","title":"rd_kafka_TopicPartitionInfo_isr()","text":"<pre><code>public static rd_kafka_TopicPartitionInfo_isr ( \n    \\FFI\\CData|null $partition, \n    \\FFI\\CData|null $cntp\n ): \\FFI\\CData|null\n</code></pre> <p>Gets the partition in-sync replicas for <code>partition</code>. </p> RemarksThe lifetime of the returned memory is the same as the lifetime of the <code>partition</code> object.  Parameters partition <code>\\FFI\\CData|null</code> const rd_kafka_TopicPartitionInfo_t* - The partition info. cntp <code>\\FFI\\CData|null</code> size_t* - is updated with in-sync replicas count. Returns <code>\\FFI\\CData|null</code> const rd_kafka_Node_t** - The in-sync replica nodes. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a1eb96b873cacfb0e1e418432e41d7a05 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_topicpartitioninfo_replicas","title":"rd_kafka_TopicPartitionInfo_replicas()","text":"<pre><code>public static rd_kafka_TopicPartitionInfo_replicas ( \n    \\FFI\\CData|null $partition, \n    \\FFI\\CData|null $cntp\n ): \\FFI\\CData|null\n</code></pre> <p>Gets the partition replicas for <code>partition</code>. </p> RemarksThe lifetime of the returned memory is the same as the lifetime of the <code>partition</code> object.  Parameters partition <code>\\FFI\\CData|null</code> const rd_kafka_TopicPartitionInfo_t* - The partition info. cntp <code>\\FFI\\CData|null</code> size_t* - is updated with partition replicas count. Returns <code>\\FFI\\CData|null</code> const rd_kafka_Node_t** - The partition replicas nodes. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a50e33ecb1e7714bee26986a7dcc7fe49 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_topicdescription_authorized_operations","title":"rd_kafka_TopicDescription_authorized_operations()","text":"<pre><code>public static rd_kafka_TopicDescription_authorized_operations ( \n    \\FFI\\CData|null $topicdesc, \n    \\FFI\\CData|null $cntp\n ): \\FFI\\CData|null\n</code></pre> <p>Gets the topic authorized ACL operations for the <code>topicdesc</code> topic. </p> RemarksThe lifetime of the returned memory is the same as the lifetime of the <code>topicdesc</code> object.  Parameters topicdesc <code>\\FFI\\CData|null</code> const rd_kafka_TopicDescription_t* - The topic description. cntp <code>\\FFI\\CData|null</code> size_t* - is updated with authorized ACL operations count. Returns <code>\\FFI\\CData|null</code> const rd_kafka_AclOperation_t* - The topic authorized operations. Is NULL if operations were not requested. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#af2d93ccb01cc15e96cb11a39718f11b8 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_topicdescription_name","title":"rd_kafka_TopicDescription_name()","text":"<pre><code>public static rd_kafka_TopicDescription_name ( \n    \\FFI\\CData|null $topicdesc\n ): string|null\n</code></pre> <p>Gets the topic name for the <code>topicdesc</code> topic. </p> RemarksThe lifetime of the returned memory is the same as the lifetime of the <code>topicdesc</code> object.  Parameters topicdesc <code>\\FFI\\CData|null</code> const rd_kafka_TopicDescription_t* - ) - The topic description. Returns <code>string|null</code> const char* - The topic name. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a490e028c8ed8fda61ae24da3a814322c </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_topicdescription_topic_id","title":"rd_kafka_TopicDescription_topic_id()","text":"<pre><code>public static rd_kafka_TopicDescription_topic_id ( \n    \\FFI\\CData|null $topicdesc\n ): \\FFI\\CData|null\n</code></pre> <p>Gets the topic id for the <code>topicdesc</code> topic. </p> RemarksThe lifetime of the returned memory is the same as the lifetime of the <code>topicdesc</code> object.  Parameters topicdesc <code>\\FFI\\CData|null</code> const rd_kafka_TopicDescription_t* - ) - The topic description. Returns <code>\\FFI\\CData|null</code> const rd_kafka_Uuid_t* - The topic id <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a557e353e835117478b865d085dededfd </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_topicdescription_is_internal","title":"rd_kafka_TopicDescription_is_internal()","text":"<pre><code>public static rd_kafka_TopicDescription_is_internal ( \n    \\FFI\\CData|null $topicdesc\n ): int|null\n</code></pre> <p>Gets if the <code>topicdesc</code> topic is internal. </p> Parameters topicdesc <code>\\FFI\\CData|null</code> const rd_kafka_TopicDescription_t* - ) - The topic description. Returns <code>int|null</code> int - 1 if the topic is internal to Kafka, 0 otherwise. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aec3f6b1edd182818266d79bf3a3d681f </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_topicdescription_error","title":"rd_kafka_TopicDescription_error()","text":"<pre><code>public static rd_kafka_TopicDescription_error ( \n    \\FFI\\CData|null $topicdesc\n ): \\FFI\\CData|null\n</code></pre> <p>Gets the error for the <code>topicdesc</code> topic. </p> RemarksThe lifetime of the returned memory is the same as the lifetime of the <code>topicdesc</code> object.  Parameters topicdesc <code>\\FFI\\CData|null</code> const rd_kafka_TopicDescription_t* - ) - The topic description. Returns <code>\\FFI\\CData|null</code> const rd_kafka_error_t* - The topic description error. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a122980e677b8673357e0ead8278d122e </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_describecluster","title":"rd_kafka_DescribeCluster()","text":"<pre><code>public static rd_kafka_DescribeCluster ( \n    \\FFI\\CData|null $rk, \n    \\FFI\\CData|null $options, \n    \\FFI\\CData|null $rkqu\n ): void\n</code></pre> <p>Describes the cluster. </p> RemarksThe result event type emitted on the supplied queue is of type <code>RD_KAFKA_EVENT_DESCRIBECLUSTER_RESULT</code> Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* - Client instance. options <code>\\FFI\\CData|null</code> const rd_kafka_AdminOptions_t* - Optional admin options, or NULL for defaults. Valid options:<ul> <li>include_authorized_operations </li> </ul> rkqu <code>\\FFI\\CData|null</code> rd_kafka_queue_t* - Queue to emit result on. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aeb726c502cc8ae2bf8688c4b6222b928 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_describecluster_result_nodes","title":"rd_kafka_DescribeCluster_result_nodes()","text":"<pre><code>public static rd_kafka_DescribeCluster_result_nodes ( \n    \\FFI\\CData|null $result, \n    \\FFI\\CData|null $cntp\n ): \\FFI\\CData|null\n</code></pre> <p>Gets the broker nodes for the <code>result</code> cluster. </p> RemarksThe lifetime of the returned memory is the same as the lifetime of the <code>result</code> object.  Parameters result <code>\\FFI\\CData|null</code> const rd_kafka_DescribeCluster_result_t* - The result of DescribeCluster. cntp <code>\\FFI\\CData|null</code> size_t* - is updated with the count of broker nodes. Returns <code>\\FFI\\CData|null</code> const rd_kafka_Node_t** - An array of broker nodes. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#add39eff7e0f0cde3614b661594310e28 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_describecluster_result_authorized_operations","title":"rd_kafka_DescribeCluster_result_authorized_operations()","text":"<pre><code>public static rd_kafka_DescribeCluster_result_authorized_operations ( \n    \\FFI\\CData|null $result, \n    \\FFI\\CData|null $cntp\n ): \\FFI\\CData|null\n</code></pre> <p>Gets the authorized ACL operations for the <code>result</code> cluster. </p> RemarksThe lifetime of the returned memory is the same as the lifetime of the <code>result</code> object.  Parameters result <code>\\FFI\\CData|null</code> const rd_kafka_DescribeCluster_result_t* - The result of DescribeCluster. cntp <code>\\FFI\\CData|null</code> size_t* - is updated with authorized ACL operations count. Returns <code>\\FFI\\CData|null</code> const rd_kafka_AclOperation_t* - The cluster authorized operations. Is NULL if operations were not requested. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aa0f78bad0da719956778d43fedc42454 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_describecluster_result_controller","title":"rd_kafka_DescribeCluster_result_controller()","text":"<pre><code>public static rd_kafka_DescribeCluster_result_controller ( \n    \\FFI\\CData|null $result\n ): \\FFI\\CData|null\n</code></pre> <p>Gets the current controller for the <code>result</code> cluster. </p> Parameters result <code>\\FFI\\CData|null</code> const rd_kafka_DescribeCluster_result_t* - ) - The result of DescribeCluster. Returns <code>\\FFI\\CData|null</code> const rd_kafka_Node_t* - The cluster current controller. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a268e83f5e58ea81ea87c2a9fb8a28af1 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_describecluster_result_cluster_id","title":"rd_kafka_DescribeCluster_result_cluster_id()","text":"<pre><code>public static rd_kafka_DescribeCluster_result_cluster_id ( \n    \\FFI\\CData|null $result\n ): string|null\n</code></pre> <p>Gets the cluster id for the <code>result</code> cluster. </p> RemarksThe lifetime of the returned memory is the same as the lifetime of the <code>result</code> object.  Parameters result <code>\\FFI\\CData|null</code> const rd_kafka_DescribeCluster_result_t* - ) - The result of DescribeCluster. Returns <code>string|null</code> const char* - The cluster id. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a70813d17f662b9b4524f42078a8ddd0f </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_consumergroupdescription_authorized_operations","title":"rd_kafka_ConsumerGroupDescription_authorized_operations()","text":"<pre><code>public static rd_kafka_ConsumerGroupDescription_authorized_operations ( \n    \\FFI\\CData|null $grpdesc, \n    \\FFI\\CData|null $cntp\n ): \\FFI\\CData|null\n</code></pre> <p>Gets the authorized ACL operations for the <code>grpdesc</code> group. </p> RemarksThe lifetime of the returned memory is the same as the lifetime of the <code>grpdesc</code> object.  Parameters grpdesc <code>\\FFI\\CData|null</code> const rd_kafka_ConsumerGroupDescription_t* - The group description. cntp <code>\\FFI\\CData|null</code> size_t* - is updated with authorized ACL operations count. Returns <code>\\FFI\\CData|null</code> const rd_kafka_AclOperation_t* - The group authorized operations. Is NULL if operations were not requested. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a9bfd676eceeb2c768fbf9cb4df2f63c1 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_listoffsetsresultinfo_topic_partition","title":"rd_kafka_ListOffsetsResultInfo_topic_partition()","text":"<pre><code>public static rd_kafka_ListOffsetsResultInfo_topic_partition ( \n    \\FFI\\CData|null $result_info\n ): \\FFI\\CData|null\n</code></pre> Parameters result_info <code>\\FFI\\CData|null</code> const rd_kafka_ListOffsetsResultInfo_t* Returns <code>\\FFI\\CData|null</code> const rd_kafka_topic_partition_t*"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_listoffsetsresultinfo_timestamp","title":"rd_kafka_ListOffsetsResultInfo_timestamp()","text":"<pre><code>public static rd_kafka_ListOffsetsResultInfo_timestamp ( \n    \\FFI\\CData|null $result_info\n ): int|null\n</code></pre> Parameters result_info <code>\\FFI\\CData|null</code> const rd_kafka_ListOffsetsResultInfo_t* Returns <code>int|null</code> int64_t"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_listoffsets_result_infos","title":"rd_kafka_ListOffsets_result_infos()","text":"<pre><code>public static rd_kafka_ListOffsets_result_infos ( \n    \\FFI\\CData|null $result, \n    \\FFI\\CData|null $cntp\n ): \\FFI\\CData|null\n</code></pre> Parameters result <code>\\FFI\\CData|null</code> const rd_kafka_ListOffsets_result_t* cntp <code>\\FFI\\CData|null</code> size_t* Returns <code>\\FFI\\CData|null</code> const rd_kafka_ListOffsetsResultInfo_t**"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_listoffsets","title":"rd_kafka_ListOffsets()","text":"<pre><code>public static rd_kafka_ListOffsets ( \n    \\FFI\\CData|null $rk, \n    \\FFI\\CData|null $topic_partitions, \n    \\FFI\\CData|null $options, \n    \\FFI\\CData|null $rkqu\n ): void\n</code></pre> <p>List offsets for the specified <code>topic_partitions</code>. This operation enables to find the beginning offset, end offset as well as the offset matching a timestamp in partitions or the offset with max timestamp. </p> <p>Supported admin options:</p> <ul> <li>rd_kafka_AdminOptions_set_isolation_level() - default <code>RD_KAFKA_ISOLATION_LEVEL_READ_UNCOMMITTED</code> </li> <li>rd_kafka_AdminOptions_set_request_timeout() - default socket.timeout.ms</li> </ul> RemarksThe result event type emitted on the supplied queue is of type <code>RD_KAFKA_EVENT_LISTOFFSETS_RESULT</code> Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* - Client instance. topic_partitions <code>\\FFI\\CData|null</code> rd_kafka_topic_partition_list_t* - topic_partition_list_t with the partitions and offsets to list. Each topic partition offset can be a value of the <code>rd_kafka_OffsetSpec_t</code> enum or a non-negative value, representing a timestamp, to query for the first offset after the given timestamp. options <code>\\FFI\\CData|null</code> const rd_kafka_AdminOptions_t* - Optional admin options, or NULL for defaults. rkqu <code>\\FFI\\CData|null</code> rd_kafka_queue_t* - Queue to emit result on. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a264a98c3d96233e68a05739baed9428f </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_mock_start_request_tracking","title":"rd_kafka_mock_start_request_tracking()","text":"<pre><code>public static rd_kafka_mock_start_request_tracking ( \n    \\FFI\\CData|null $mcluster\n ): void\n</code></pre> Parameters mcluster <code>\\FFI\\CData|null</code> rd_kafka_mock_cluster_t*"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_mock_stop_request_tracking","title":"rd_kafka_mock_stop_request_tracking()","text":"<pre><code>public static rd_kafka_mock_stop_request_tracking ( \n    \\FFI\\CData|null $mcluster\n ): void\n</code></pre> Parameters mcluster <code>\\FFI\\CData|null</code> rd_kafka_mock_cluster_t*"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_mock_request_destroy","title":"rd_kafka_mock_request_destroy()","text":"<pre><code>public static rd_kafka_mock_request_destroy ( \n    \\FFI\\CData|null $mreq\n ): void\n</code></pre> Parameters mreq <code>\\FFI\\CData|null</code> rd_kafka_mock_request_t*"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_mock_request_id","title":"rd_kafka_mock_request_id()","text":"<pre><code>public static rd_kafka_mock_request_id ( \n    \\FFI\\CData|null $mreq\n ): int|null\n</code></pre> Parameters mreq <code>\\FFI\\CData|null</code> rd_kafka_mock_request_t* Returns <code>int|null</code> int32_t"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_mock_request_api_key","title":"rd_kafka_mock_request_api_key()","text":"<pre><code>public static rd_kafka_mock_request_api_key ( \n    \\FFI\\CData|null $mreq\n ): int|null\n</code></pre> Parameters mreq <code>\\FFI\\CData|null</code> rd_kafka_mock_request_t* Returns <code>int|null</code> int16_t"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_mock_request_timestamp","title":"rd_kafka_mock_request_timestamp()","text":"<pre><code>public static rd_kafka_mock_request_timestamp ( \n    \\FFI\\CData|null $mreq\n ): int|null\n</code></pre> Parameters mreq <code>\\FFI\\CData|null</code> rd_kafka_mock_request_t* Returns <code>int|null</code> int64_t"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_mock_get_requests","title":"rd_kafka_mock_get_requests()","text":"<pre><code>public static rd_kafka_mock_get_requests ( \n    \\FFI\\CData|null $mcluster, \n    \\FFI\\CData|null $cntp\n ): \\FFI\\CData|null\n</code></pre> Parameters mcluster <code>\\FFI\\CData|null</code> rd_kafka_mock_cluster_t* cntp <code>\\FFI\\CData|null</code> size_t* Returns <code>\\FFI\\CData|null</code> rd_kafka_mock_request_t**"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_mock_clear_requests","title":"rd_kafka_mock_clear_requests()","text":"<pre><code>public static rd_kafka_mock_clear_requests ( \n    \\FFI\\CData|null $mcluster\n ): void\n</code></pre> Parameters mcluster <code>\\FFI\\CData|null</code> rd_kafka_mock_cluster_t*"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_message_produce_errstr","title":"rd_kafka_message_produce_errstr()","text":"<pre><code>public static rd_kafka_message_produce_errstr ( \n    \\FFI\\CData|null $rkmessage\n ): string|null\n</code></pre> <p>Returns the error string for an errored produced rd_kafka_message_t or NULL if there was no error. </p> RemarksThis function MUST used with the producer.  Parameters rkmessage <code>\\FFI\\CData|null</code> const rd_kafka_message_t* - ) Returns <code>string|null</code> const char* <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a308971e7560a146d2af791d7915b38a0 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_consumer_group_metadata_member_id","title":"rd_kafka_consumer_group_metadata_member_id()","text":"<pre><code>public static rd_kafka_consumer_group_metadata_member_id ( \n    \\FFI\\CData|null $group_metadata\n ): string|null\n</code></pre> <p>Get member id of a group metadata. </p> RemarksThe returned pointer has the same lifetime as <code>group_metadata</code>.  Parameters group_metadata <code>\\FFI\\CData|null</code> const rd_kafka_consumer_group_metadata_t* - ) - The group metadata. Returns <code>string|null</code> const char* - The member id contained in the passed <code>group_metadata</code>. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a2d472b3e20962fd2027d6a99f85e5149 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_mock_partition_push_leader_response","title":"rd_kafka_mock_partition_push_leader_response()","text":"<pre><code>public static rd_kafka_mock_partition_push_leader_response ( \n    \\FFI\\CData|null $mcluster, \n    string|null $topic, \n    int|null $partition, \n    int|null $leader_id, \n    int|null $leader_epoch\n ): int\n</code></pre> Parameters mcluster <code>\\FFI\\CData|null</code> rd_kafka_mock_cluster_t* topic <code>string|null</code> const char* partition <code>int|null</code> int leader_id <code>int|null</code> int32_t leader_epoch <code>int|null</code> int32_t Returns <code>int</code> rd_kafka_resp_err_t"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_mock_request_destroy_array","title":"rd_kafka_mock_request_destroy_array()","text":"<pre><code>public static rd_kafka_mock_request_destroy_array ( \n    \\FFI\\CData|null $mreqs, \n    int|null $mreq_cnt\n ): void\n</code></pre> Parameters mreqs <code>\\FFI\\CData|null</code> rd_kafka_mock_request_t** mreq_cnt <code>int|null</code> size_t"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_mock_telemetry_set_requested_metrics","title":"rd_kafka_mock_telemetry_set_requested_metrics()","text":"<pre><code>public static rd_kafka_mock_telemetry_set_requested_metrics ( \n    \\FFI\\CData|null $mcluster, \n    \\FFI\\CData|null $metrics, \n    int|null $metrics_cnt\n ): int\n</code></pre> Parameters mcluster <code>\\FFI\\CData|null</code> rd_kafka_mock_cluster_t* metrics <code>\\FFI\\CData|null</code> char** metrics_cnt <code>int|null</code> size_t Returns <code>int</code> rd_kafka_resp_err_t"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_mock_telemetry_set_push_interval","title":"rd_kafka_mock_telemetry_set_push_interval()","text":"<pre><code>public static rd_kafka_mock_telemetry_set_push_interval ( \n    \\FFI\\CData|null $mcluster, \n    int|null $push_interval_ms\n ): int\n</code></pre> Parameters mcluster <code>\\FFI\\CData|null</code> rd_kafka_mock_cluster_t* push_interval_ms <code>int|null</code> int64_t Returns <code>int</code> rd_kafka_resp_err_t"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_consumer_group_type_name","title":"rd_kafka_consumer_group_type_name()","text":"<pre><code>public static rd_kafka_consumer_group_type_name ( \n    int $type\n ): string|null\n</code></pre> <p>Returns a name for a group type code. </p> Parameters type <code>int</code> rd_kafka_consumer_group_type_t - ) - The group type value. Returns <code>string|null</code> const char* - The group type name corresponding to the provided group type value. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aa1832cc57552f789d1e27faaa93943d1 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_consumer_group_type_code","title":"rd_kafka_consumer_group_type_code()","text":"<pre><code>public static rd_kafka_consumer_group_type_code ( \n    string|null $name\n ): int\n</code></pre> <p>Returns a code for a group type name. </p> RemarksThe comparison is case-insensitive. Parameters name <code>string|null</code> const char* - ) - The group type name. Returns <code>int</code> rd_kafka_consumer_group_type_t - The group type value corresponding to the provided group type name. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ac2557eeb2e89bce046100adbee25c3dc </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_event_electleaders_result","title":"rd_kafka_event_ElectLeaders_result()","text":"<pre><code>public static rd_kafka_event_ElectLeaders_result ( \n    \\FFI\\CData|null $rkev\n ): \\FFI\\CData|null\n</code></pre> <p>Get ElectLeaders result. </p> RemarksThe lifetime of the returned memory is the same as the lifetime of the <code>rkev</code> object. <p>Event types: RD_KAFKA_EVENT_ELECTLEADERS_RESULT </p> Parameters rkev <code>\\FFI\\CData|null</code> rd_kafka_event_t* - ) Returns <code>\\FFI\\CData|null</code> const rd_kafka_ElectLeaders_result_t* - the result of a ElectLeaders request, or NULL if event is of different type. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#abf08b888315fc6bd49f397703b035233 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_topic_partition_result_partition","title":"rd_kafka_topic_partition_result_partition()","text":"<pre><code>public static rd_kafka_topic_partition_result_partition ( \n    \\FFI\\CData|null $partition_result\n ): \\FFI\\CData|null\n</code></pre> <p>Topic Partition Result provides per-topic+partition operation result Consists of TopicPartition object and error object. </p> Remarkslifetime of the returned string is the same as the <code>partition_result</code>. The error object is set inside the topic partition object. For the detailed error information, use rd_kafka_topic_partition_result_error()  Parameters partition_result <code>\\FFI\\CData|null</code> const rd_kafka_topic_partition_result_t* - ) Returns <code>\\FFI\\CData|null</code> const rd_kafka_topic_partition_t* - the topic partition object from the topic partition result object. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a6b516428ccc72a544681f16c130a8dd9 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_topic_partition_result_error","title":"rd_kafka_topic_partition_result_error()","text":"<pre><code>public static rd_kafka_topic_partition_result_error ( \n    \\FFI\\CData|null $partition_result\n ): \\FFI\\CData|null\n</code></pre> Remarkslifetime of the returned string is the same as the <code>partition_result</code>.  Parameters partition_result <code>\\FFI\\CData|null</code> const rd_kafka_topic_partition_result_t* - ) Returns <code>\\FFI\\CData|null</code> const rd_kafka_error_t* - the error object from the topic partition result object. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a6d6090e9f0cfe26744aa1c4489e4515c </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_adminoptions_set_match_consumer_group_types","title":"rd_kafka_AdminOptions_set_match_consumer_group_types()","text":"<pre><code>public static rd_kafka_AdminOptions_set_match_consumer_group_types ( \n    \\FFI\\CData|null $options, \n    \\FFI\\CData|null $consumer_group_types, \n    int|null $consumer_group_types_cnt\n ): \\FFI\\CData|null\n</code></pre> <p>Set consumer groups types to query for. </p> RemarksThis option is valid for ListConsumerGroups.  Parameters options <code>\\FFI\\CData|null</code> rd_kafka_AdminOptions_t* - Admin options. consumer_group_types <code>\\FFI\\CData|null</code> const rd_kafka_consumer_group_type_t* - Array of consumer group types. consumer_group_types_cnt <code>int|null</code> size_t - Size of the <code>consumer_group_types</code> array. Returns <code>\\FFI\\CData|null</code> rd_kafka_error_t* - NULL on success, a new error instance that must be released with rd_kafka_error_destroy() in case of error. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a93ca240fdff348f2cb46f870c51ffd1c </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_consumergrouplisting_type","title":"rd_kafka_ConsumerGroupListing_type()","text":"<pre><code>public static rd_kafka_ConsumerGroupListing_type ( \n    \\FFI\\CData|null $grplist\n ): int\n</code></pre> <p>Gets type for the <code>grplist</code> group. </p> Parameters grplist <code>\\FFI\\CData|null</code> const rd_kafka_ConsumerGroupListing_t* - ) - The group listing. Returns <code>int</code> rd_kafka_consumer_group_type_t - A group type. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ad8e4f9a805d98acc521a32ff585fff90 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_electleaders_new","title":"rd_kafka_ElectLeaders_new()","text":"<pre><code>public static rd_kafka_ElectLeaders_new ( \n    int $election_type, \n    \\FFI\\CData|null $partitions\n ): \\FFI\\CData|null\n</code></pre> <p>Create a new rd_kafka_ElectLeaders_t object. This object is later passed to rd_kafka_ElectLeaders(). </p> Parameters election_type <code>int</code> rd_kafka_ElectionType_t - The election type that needs to be performed, preferred or unclean. partitions <code>\\FFI\\CData|null</code> rd_kafka_topic_partition_list_t* - The topic partitions for which the leader election needs to be performed. Returns <code>\\FFI\\CData|null</code> rd_kafka_ElectLeaders_t* - a new allocated elect leaders object or returns NULL in case of invalid election_type. Use rd_kafka_ElectLeaders_destroy() to free object when done. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a059bcca58185c29fdf9908d7d11e8b22 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_electleaders_destroy","title":"rd_kafka_ElectLeaders_destroy()","text":"<pre><code>public static rd_kafka_ElectLeaders_destroy ( \n    \\FFI\\CData|null $elect_leaders\n ): void\n</code></pre> <p>Destroy and free a rd_kafka_ElectLeaders_t object previously created with rd_kafka_ElectLeaders_new() </p> Parameters elect_leaders <code>\\FFI\\CData|null</code> rd_kafka_ElectLeaders_t* - ) - The rd_kafka_ElectLeaders_t object to be destroyed. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a033c1190f2a18a34aa9d9051eb17a190 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_electleaders","title":"rd_kafka_ElectLeaders()","text":"<pre><code>public static rd_kafka_ElectLeaders ( \n    \\FFI\\CData|null $rk, \n    \\FFI\\CData|null $elect_leaders, \n    \\FFI\\CData|null $options, \n    \\FFI\\CData|null $rkqu\n ): void\n</code></pre> <p>Elect Leaders for the provided Topic Partitions according to the specified election type. </p> <p>Supported admin options:</p> <ul> <li>rd_kafka_AdminOptions_set_operation_timeout() - default 60 seconds. Controls how long the brokers will wait for records to be deleted.</li> <li>rd_kafka_AdminOptions_set_request_timeout() - default socket.timeout.ms. Controls how long <code>rdkafka</code> will wait for the request to complete.</li> </ul> RemarksThe result event type emitted on the supplied queue is of type <code>RD_KAFKA_EVENT_ELECTLEADERS_RESULT</code>  If we are passing partitions as NULL, then the broker will attempt leader election for all partitions, but the results will contain only partitions for which there was an election or resulted in an error.  Parameters rk <code>\\FFI\\CData|null</code> rd_kafka_t* - Client instance. elect_leaders <code>\\FFI\\CData|null</code> rd_kafka_ElectLeaders_t* - The elect leaders request containing election type and partitions information. options <code>\\FFI\\CData|null</code> const rd_kafka_AdminOptions_t* - Optional admin options, or NULL for defaults. rkqu <code>\\FFI\\CData|null</code> rd_kafka_queue_t* - Queue to emit result on. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ac96e1dcd76d254a5b0c37f8ed5a62b61 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_electleaders_result_partitions","title":"rd_kafka_ElectLeaders_result_partitions()","text":"<pre><code>public static rd_kafka_ElectLeaders_result_partitions ( \n    \\FFI\\CData|null $result, \n    \\FFI\\CData|null $cntp\n ): \\FFI\\CData|null\n</code></pre> <p>Get the array of topic partition result objects from the elect leaders result event and populates the size of the array in <code>cntp</code>. </p> Parameters result <code>\\FFI\\CData|null</code> const rd_kafka_ElectLeaders_result_t* - The elect leaders result. cntp <code>\\FFI\\CData|null</code> size_t* - The number of elements in the array. Returns <code>\\FFI\\CData|null</code> const rd_kafka_topic_partition_result_t** - the array of topic partition result objects from the elect leaders result event. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a7b745712f0acd7f6c1d8f916d7ad6581 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_mock_group_initial_rebalance_delay_ms","title":"rd_kafka_mock_group_initial_rebalance_delay_ms()","text":"<pre><code>public static rd_kafka_mock_group_initial_rebalance_delay_ms ( \n    \\FFI\\CData|null $mcluster, \n    int|null $delay_ms\n ): void\n</code></pre> Parameters mcluster <code>\\FFI\\CData|null</code> rd_kafka_mock_cluster_t* delay_ms <code>int|null</code> int32_t"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_consumer_group_metadata_group_id","title":"rd_kafka_consumer_group_metadata_group_id()","text":"<pre><code>public static rd_kafka_consumer_group_metadata_group_id ( \n    \\FFI\\CData|null $group_metadata\n ): string|null\n</code></pre> <p>Get group id of a group metadata. </p> RemarksThe returned pointer has the same lifetime as <code>group_metadata</code>.  Parameters group_metadata <code>\\FFI\\CData|null</code> const rd_kafka_consumer_group_metadata_t* - ) - The group metadata. Returns <code>string|null</code> const char* - The group id contained in the passed <code>group_metadata</code>. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ab916ea76159290e3f1e644c40816a042 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_consumer_group_metadata_group_instance_id","title":"rd_kafka_consumer_group_metadata_group_instance_id()","text":"<pre><code>public static rd_kafka_consumer_group_metadata_group_instance_id ( \n    \\FFI\\CData|null $group_metadata\n ): string|null\n</code></pre> <p>Get group instance id of a group metadata. </p> RemarksThe returned pointer has the same lifetime as <code>group_metadata</code>.  Parameters group_metadata <code>\\FFI\\CData|null</code> const rd_kafka_consumer_group_metadata_t* - ) - The group metadata. Returns <code>string|null</code> const char* - The group instance id contained in the passed <code>group_metadata</code> or NULL. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ad74ae94a86e81db03afcd772fad96c45 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_consumer_group_metadata_generation_id","title":"rd_kafka_consumer_group_metadata_generation_id()","text":"<pre><code>public static rd_kafka_consumer_group_metadata_generation_id ( \n    \\FFI\\CData|null $group_metadata\n ): int|null\n</code></pre> <p>Get the generation id (classic protocol) or member epoch (consumer protocol) of a group metadata. </p> Parameters group_metadata <code>\\FFI\\CData|null</code> const rd_kafka_consumer_group_metadata_t* - ) - The group metadata. Returns <code>int|null</code> int32_t - The generation id or member epoch contained in the passed <code>group_metadata</code>. <p>See also</p> <ul> <li> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a851a24b70797902f3600a4650b7f82f0 </li> </ul>"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_mock_cgrp_consumer_target_assignment_new","title":"rd_kafka_mock_cgrp_consumer_target_assignment_new()","text":"<pre><code>public static rd_kafka_mock_cgrp_consumer_target_assignment_new ( \n    \\FFI\\CData|null $member_ids, \n    int|null $member_cnt, \n    \\FFI\\CData|null $assignment\n ): \\FFI\\CData|null\n</code></pre> Parameters member_ids <code>\\FFI\\CData|null</code> char** member_cnt <code>int|null</code> int assignment <code>\\FFI\\CData|null</code> rd_kafka_topic_partition_list_t** Returns <code>\\FFI\\CData|null</code> rd_kafka_mock_cgrp_consumer_target_assignment_t*"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_mock_cgrp_consumer_target_assignment_destroy","title":"rd_kafka_mock_cgrp_consumer_target_assignment_destroy()","text":"<pre><code>public static rd_kafka_mock_cgrp_consumer_target_assignment_destroy ( \n    \\FFI\\CData|null $target_assignment\n ): void\n</code></pre> Parameters target_assignment <code>\\FFI\\CData|null</code> rd_kafka_mock_cgrp_consumer_target_assignment_t*"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_mock_cgrp_consumer_target_assignment","title":"rd_kafka_mock_cgrp_consumer_target_assignment()","text":"<pre><code>public static rd_kafka_mock_cgrp_consumer_target_assignment ( \n    \\FFI\\CData|null $mcluster, \n    string|null $group_id, \n    \\FFI\\CData|null $target_assignment\n ): void\n</code></pre> Parameters mcluster <code>\\FFI\\CData|null</code> rd_kafka_mock_cluster_t* group_id <code>string|null</code> const char* target_assignment <code>\\FFI\\CData|null</code> rd_kafka_mock_cgrp_consumer_target_assignment_t*"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_mock_set_group_consumer_session_timeout_ms","title":"rd_kafka_mock_set_group_consumer_session_timeout_ms()","text":"<pre><code>public static rd_kafka_mock_set_group_consumer_session_timeout_ms ( \n    \\FFI\\CData|null $mcluster, \n    int|null $group_consumer_session_timeout_ms\n ): void\n</code></pre> Parameters mcluster <code>\\FFI\\CData|null</code> rd_kafka_mock_cluster_t* group_consumer_session_timeout_ms <code>int|null</code> int"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_mock_set_group_consumer_heartbeat_interval_ms","title":"rd_kafka_mock_set_group_consumer_heartbeat_interval_ms()","text":"<pre><code>public static rd_kafka_mock_set_group_consumer_heartbeat_interval_ms ( \n    \\FFI\\CData|null $mcluster, \n    int|null $group_consumer_heartbeat_interval_ms\n ): void\n</code></pre> Parameters mcluster <code>\\FFI\\CData|null</code> rd_kafka_mock_cluster_t* group_consumer_heartbeat_interval_ms <code>int|null</code> int"},{"location":"api/RdKafka/FFI/Methods/#used-by","title":"Used by","text":"<ul> <li>\\RdKafka\\FFI\\Library</li> </ul>"},{"location":"api/RdKafka/FFI/NativePartitionerCallbackProxy/","title":"Class NativePartitionerCallbackProxy","text":"<p>Class \\RdKafka\\FFI\\NativePartitionerCallbackProxy</p>"},{"location":"api/RdKafka/FFI/NativePartitionerCallbackProxy/#methods","title":"Methods","text":""},{"location":"api/RdKafka/FFI/NativePartitionerCallbackProxy/#__construct","title":"__construct()","text":"<pre><code>public __construct ( \n    string $partitionerMethod\n ): \n</code></pre> Parameters partitionerMethod <code>string</code>"},{"location":"api/RdKafka/FFI/NativePartitionerCallbackProxy/#__invoke","title":"__invoke()","text":"<pre><code>public __invoke ( \n    ?\\FFI\\CData $topic, \n    ?\\FFI\\CData $keydata, \n    int $keylen, \n    int $partition_cnt, \n    ?\\FFI\\CData $topic_opaque = null, \n    ?\\FFI\\CData $msg_opaque = null\n ): int\n</code></pre> Parameters topic <code>?\\FFI\\CData</code> keydata <code>?\\FFI\\CData</code> keylen <code>int</code> partition_cnt <code>int</code> topic_opaque <code>?\\FFI\\CData</code> msg_opaque <code>?\\FFI\\CData</code> Returns <code>int</code>"},{"location":"api/RdKafka/FFI/NativePartitionerCallbackProxy/#create","title":"create()","text":"<pre><code>public static create ( \n    string $partitionerMethod\n ): \\Closure\n</code></pre> Parameters partitionerMethod <code>string</code> Returns <code>\\Closure</code>"},{"location":"api/RdKafka/FFI/NativePartitionerCallbackProxy/#test-coverage","title":"Test Coverage \ud83d\udc9a","text":"<ul> <li>\ud83d\udc9a  Lines: 100% (11 / 11)</li> <li>\ud83d\udc9a  Methods: 100% (3 / 3)</li> </ul>"},{"location":"api/RdKafka/FFI/OffsetCommitCallbackProxy/","title":"Class OffsetCommitCallbackProxy","text":"<p>Class \\RdKafka\\FFI\\OffsetCommitCallbackProxy</p> <ul> <li>extends \\RdKafka\\FFI\\CallbackProxy</li> </ul>"},{"location":"api/RdKafka/FFI/OffsetCommitCallbackProxy/#methods","title":"Methods","text":""},{"location":"api/RdKafka/FFI/OffsetCommitCallbackProxy/#__invoke","title":"__invoke()","text":"<pre><code>public __invoke ( \n    \\FFI\\CData $consumer, \n    int $err, \n    \\FFI\\CData $nativeTopicPartitionList, \n    ?\\FFI\\CData $opaque = null\n ): void\n</code></pre> Parameters consumer <code>\\FFI\\CData</code> err <code>int</code> nativeTopicPartitionList <code>\\FFI\\CData</code> opaque <code>?\\FFI\\CData</code>"},{"location":"api/RdKafka/FFI/OffsetCommitCallbackProxy/#test-coverage","title":"Test Coverage \ud83d\udc9a","text":"<ul> <li>\ud83d\udc9a  Lines: 100% (6 / 6)</li> <li>\ud83d\udc9a  Methods: 100% (1 / 1)</li> </ul>"},{"location":"api/RdKafka/FFI/OpaqueMap/","title":"Class OpaqueMap","text":"<p>Class \\RdKafka\\FFI\\OpaqueMap</p>"},{"location":"api/RdKafka/FFI/OpaqueMap/#methods","title":"Methods","text":""},{"location":"api/RdKafka/FFI/OpaqueMap/#get","title":"get()","text":"<pre><code>public static get ( \n    ?\\FFI\\CData $cOpaque\n ): mixed|null\n</code></pre> Parameters cOpaque <code>?\\FFI\\CData</code> Returns <code>mixed|null</code>"},{"location":"api/RdKafka/FFI/OpaqueMap/#pull","title":"pull()","text":"<pre><code>public static pull ( \n    ?\\FFI\\CData $cOpaque\n ): mixed|null\n</code></pre> Parameters cOpaque <code>?\\FFI\\CData</code> Returns <code>mixed|null</code>"},{"location":"api/RdKafka/FFI/OpaqueMap/#push","title":"push()","text":"<pre><code>public static push ( \n    mixed|null $opaque\n ): ?\\FFI\\CData\n</code></pre> Parameters opaque <code>mixed|null</code> Returns <code>?\\FFI\\CData</code>"},{"location":"api/RdKafka/FFI/OpaqueMap/#test-coverage","title":"Test Coverage \ud83d\udc9a","text":"<ul> <li>\ud83d\udc9a  Lines: 96.3% (26 / 27)</li> <li>\ud83e\udde1  Methods: 66.67% (2 / 3)</li> </ul>"},{"location":"api/RdKafka/FFI/PartitionerCallbackProxy/","title":"Class PartitionerCallbackProxy","text":"<p>Class \\RdKafka\\FFI\\PartitionerCallbackProxy</p> <ul> <li>extends \\RdKafka\\FFI\\CallbackProxy</li> </ul>"},{"location":"api/RdKafka/FFI/PartitionerCallbackProxy/#methods","title":"Methods","text":""},{"location":"api/RdKafka/FFI/PartitionerCallbackProxy/#__invoke","title":"__invoke()","text":"<pre><code>public __invoke ( \n    ?\\FFI\\CData $topic, \n    ?\\FFI\\CData $keydata, \n    int $keylen, \n    int $partition_cnt, \n    ?\\FFI\\CData $topic_opaque = null, \n    ?\\FFI\\CData $msg_opaque = null\n ): int\n</code></pre> Parameters topic <code>?\\FFI\\CData</code> keydata <code>?\\FFI\\CData</code> keylen <code>int</code> partition_cnt <code>int</code> topic_opaque <code>?\\FFI\\CData</code> msg_opaque <code>?\\FFI\\CData</code> Returns <code>int</code>"},{"location":"api/RdKafka/FFI/PartitionerCallbackProxy/#test-coverage","title":"Test Coverage \ud83d\udc9a","text":"<ul> <li>\ud83d\udc9a  Lines: 100% (6 / 6)</li> <li>\ud83d\udc9a  Methods: 100% (1 / 1)</li> </ul>"},{"location":"api/RdKafka/FFI/RebalanceCallbackProxy/","title":"Class RebalanceCallbackProxy","text":"<p>Class \\RdKafka\\FFI\\RebalanceCallbackProxy</p> <ul> <li>extends \\RdKafka\\FFI\\CallbackProxy</li> </ul>"},{"location":"api/RdKafka/FFI/RebalanceCallbackProxy/#methods","title":"Methods","text":""},{"location":"api/RdKafka/FFI/RebalanceCallbackProxy/#__invoke","title":"__invoke()","text":"<pre><code>public __invoke ( \n    \\FFI\\CData $consumer, \n    int $err, \n    \\FFI\\CData $nativeTopicPartitionList, \n    ?\\FFI\\CData $opaque = null\n ): void\n</code></pre> Parameters consumer <code>\\FFI\\CData</code> err <code>int</code> nativeTopicPartitionList <code>\\FFI\\CData</code> opaque <code>?\\FFI\\CData</code>"},{"location":"api/RdKafka/FFI/RebalanceCallbackProxy/#test-coverage","title":"Test Coverage \ud83d\udc9a","text":"<ul> <li>\ud83d\udc9a  Lines: 100% (6 / 6)</li> <li>\ud83d\udc9a  Methods: 100% (1 / 1)</li> </ul>"},{"location":"api/RdKafka/FFI/StatsCallbackProxy/","title":"Class StatsCallbackProxy","text":"<p>Class \\RdKafka\\FFI\\StatsCallbackProxy</p> <ul> <li>extends \\RdKafka\\FFI\\CallbackProxy</li> </ul>"},{"location":"api/RdKafka/FFI/StatsCallbackProxy/#methods","title":"Methods","text":""},{"location":"api/RdKafka/FFI/StatsCallbackProxy/#__invoke","title":"__invoke()","text":"<pre><code>public __invoke ( \n    \\FFI\\CData $consumerOrProducer, \n    \\FFI\\CData $json, \n    int $json_len, \n    ?\\FFI\\CData $opaque = null\n ): int\n</code></pre> Parameters consumerOrProducer <code>\\FFI\\CData</code> json <code>\\FFI\\CData</code> json_len <code>int</code> opaque <code>?\\FFI\\CData</code> Returns <code>int</code>"},{"location":"api/RdKafka/FFI/StatsCallbackProxy/#test-coverage","title":"Test Coverage \ud83d\udc9a","text":"<ul> <li>\ud83d\udc9a  Lines: 100% (7 / 7)</li> <li>\ud83d\udc9a  Methods: 100% (1 / 1)</li> </ul>"},{"location":"api/RdKafka/Metadata/Broker/","title":"Class Broker","text":"<p>Class \\RdKafka\\Metadata\\Broker</p>"},{"location":"api/RdKafka/Metadata/Broker/#methods","title":"Methods","text":""},{"location":"api/RdKafka/Metadata/Broker/#__construct","title":"__construct()","text":"<pre><code>public __construct ( \n    int $id, \n    string $host, \n    int $port\n ): \n</code></pre> Parameters id <code>int</code> host <code>string</code> port <code>int</code>"},{"location":"api/RdKafka/Metadata/Broker/#gethost","title":"getHost()","text":"<pre><code>public getHost (  ): string\n</code></pre> Returns <code>string</code>"},{"location":"api/RdKafka/Metadata/Broker/#getid","title":"getId()","text":"<pre><code>public getId (  ): int\n</code></pre> Returns <code>int</code>"},{"location":"api/RdKafka/Metadata/Broker/#getport","title":"getPort()","text":"<pre><code>public getPort (  ): int\n</code></pre> Returns <code>int</code>"},{"location":"api/RdKafka/Metadata/Broker/#test-coverage","title":"Test Coverage \ud83d\udc9a","text":"<ul> <li>\ud83d\udc9a  Lines: 100% (6 / 6)</li> <li>\ud83d\udc9a  Methods: 100% (4 / 4)</li> </ul>"},{"location":"api/RdKafka/Metadata/Collection/","title":"Class Collection","text":"<p>Class \\RdKafka\\Metadata\\Collection</p> <ul> <li>implements  \\Iterator</li> <li>implements  \\Countable</li> </ul>"},{"location":"api/RdKafka/Metadata/Collection/#methods","title":"Methods","text":""},{"location":"api/RdKafka/Metadata/Collection/#__construct","title":"__construct()","text":"<pre><code>public __construct ( \n    array $items = []\n ): \n</code></pre> Parameters items <code>array</code>"},{"location":"api/RdKafka/Metadata/Collection/#count","title":"count()","text":"<pre><code>public count (  ): int\n</code></pre> Returns <code>int</code>"},{"location":"api/RdKafka/Metadata/Collection/#current","title":"current()","text":"<pre><code>public current (  ): mixed\n</code></pre> Returns <code>mixed</code>"},{"location":"api/RdKafka/Metadata/Collection/#key","title":"key()","text":"<pre><code>public key (  ): int\n</code></pre> Returns <code>int</code>"},{"location":"api/RdKafka/Metadata/Collection/#next","title":"next()","text":"<pre><code>public next (  ): void\n</code></pre>"},{"location":"api/RdKafka/Metadata/Collection/#rewind","title":"rewind()","text":"<pre><code>public rewind (  ): void\n</code></pre>"},{"location":"api/RdKafka/Metadata/Collection/#valid","title":"valid()","text":"<pre><code>public valid (  ): bool\n</code></pre> Returns <code>bool</code>"},{"location":"api/RdKafka/Metadata/Collection/#test-coverage","title":"Test Coverage \ud83d\udc9a","text":"<ul> <li>\ud83d\udc9a  Lines: 100% (7 / 7)</li> <li>\ud83d\udc9a  Methods: 100% (7 / 7)</li> </ul>"},{"location":"api/RdKafka/Metadata/Partition/","title":"Class Partition","text":"<p>Class \\RdKafka\\Metadata\\Partition</p>"},{"location":"api/RdKafka/Metadata/Partition/#methods","title":"Methods","text":""},{"location":"api/RdKafka/Metadata/Partition/#__construct","title":"__construct()","text":"<pre><code>public __construct ( \n    int $id, \n    int $err, \n    int $leader, \n    \\RdKafka\\Metadata\\Collection $replicas, \n    \\RdKafka\\Metadata\\Collection $isrs\n ): \n</code></pre> Parameters id <code>int</code> err <code>int</code> leader <code>int</code> replicas <code>\\RdKafka\\Metadata\\Collection</code> isrs <code>\\RdKafka\\Metadata\\Collection</code>"},{"location":"api/RdKafka/Metadata/Partition/#geterr","title":"getErr()","text":"<pre><code>public getErr (  ): int\n</code></pre> Returns <code>int</code>"},{"location":"api/RdKafka/Metadata/Partition/#getid","title":"getId()","text":"<pre><code>public getId (  ): int\n</code></pre> Returns <code>int</code>"},{"location":"api/RdKafka/Metadata/Partition/#getisrs","title":"getIsrs()","text":"<pre><code>public getIsrs (  ): \\RdKafka\\Metadata\\Collection\n</code></pre> Returns <code>\\RdKafka\\Metadata\\Collection</code>"},{"location":"api/RdKafka/Metadata/Partition/#getleader","title":"getLeader()","text":"<pre><code>public getLeader (  ): int\n</code></pre> Returns <code>int</code>"},{"location":"api/RdKafka/Metadata/Partition/#getreplicas","title":"getReplicas()","text":"<pre><code>public getReplicas (  ): \\RdKafka\\Metadata\\Collection\n</code></pre> Returns <code>\\RdKafka\\Metadata\\Collection</code>"},{"location":"api/RdKafka/Metadata/Partition/#test-coverage","title":"Test Coverage \ud83d\udc9b","text":"<ul> <li>\ud83d\udc9b  Lines: 90% (9 / 10)</li> <li>\ud83d\udc9b  Methods: 83.33% (5 / 6)</li> </ul>"},{"location":"api/RdKafka/Metadata/Topic/","title":"Class Topic","text":"<p>Class \\RdKafka\\Metadata\\Topic</p>"},{"location":"api/RdKafka/Metadata/Topic/#methods","title":"Methods","text":""},{"location":"api/RdKafka/Metadata/Topic/#__construct","title":"__construct()","text":"<pre><code>public __construct ( \n    string $topic, \n    \\RdKafka\\Metadata\\Collection $partitions, \n    int $err\n ): \n</code></pre> Parameters topic <code>string</code> partitions <code>\\RdKafka\\Metadata\\Collection</code> err <code>int</code>"},{"location":"api/RdKafka/Metadata/Topic/#geterr","title":"getErr()","text":"<pre><code>public getErr (  ): int\n</code></pre> Returns <code>int</code>"},{"location":"api/RdKafka/Metadata/Topic/#getpartitions","title":"getPartitions()","text":"<pre><code>public getPartitions (  ): \\RdKafka\\Metadata\\Collection|\\RdKafka\\Metadata\\Partition[]\n</code></pre> Returns <code>\\RdKafka\\Metadata\\Collection|\\RdKafka\\Metadata\\Partition[]</code>"},{"location":"api/RdKafka/Metadata/Topic/#gettopic","title":"getTopic()","text":"<pre><code>public getTopic (  ): string\n</code></pre> Returns <code>string</code>"},{"location":"api/RdKafka/Metadata/Topic/#test-coverage","title":"Test Coverage \ud83d\udc9a","text":"<ul> <li>\ud83d\udc9a  Lines: 100% (6 / 6)</li> <li>\ud83d\udc9a  Methods: 100% (4 / 4)</li> </ul>"},{"location":"api/RdKafka/Test/ApiKey/","title":"Class ApiKey","text":"<p>Class \\RdKafka\\Test\\ApiKey</p> <p>See also</p> <ul> <li> https://kafka.apache.org/protocol#protocol_api_keys </li> </ul>"},{"location":"api/RdKafka/Test/ApiKey/#constants","title":"Constants","text":""},{"location":"api/RdKafka/Test/ApiKey/#addoffsetstotxn","title":"AddOffsetsToTxn","text":"<pre><code>public AddOffsetsToTxn = 25\n</code></pre>"},{"location":"api/RdKafka/Test/ApiKey/#addpartitionstotxn","title":"AddPartitionsToTxn","text":"<pre><code>public AddPartitionsToTxn = 24\n</code></pre>"},{"location":"api/RdKafka/Test/ApiKey/#alterconfigs","title":"AlterConfigs","text":"<pre><code>public AlterConfigs = 33\n</code></pre>"},{"location":"api/RdKafka/Test/ApiKey/#alterreplicalogdirs","title":"AlterReplicaLogDirs","text":"<pre><code>public AlterReplicaLogDirs = 34\n</code></pre>"},{"location":"api/RdKafka/Test/ApiKey/#apiversion","title":"ApiVersion","text":"<pre><code>public ApiVersion = 18\n</code></pre>"},{"location":"api/RdKafka/Test/ApiKey/#controlledshutdown","title":"ControlledShutdown","text":"<pre><code>public ControlledShutdown = 7\n</code></pre>"},{"location":"api/RdKafka/Test/ApiKey/#createacls","title":"CreateAcls","text":"<pre><code>public CreateAcls = 30\n</code></pre>"},{"location":"api/RdKafka/Test/ApiKey/#createdelegationtoken","title":"CreateDelegationToken","text":"<pre><code>public CreateDelegationToken = 38\n</code></pre>"},{"location":"api/RdKafka/Test/ApiKey/#createpartitions","title":"CreatePartitions","text":"<pre><code>public CreatePartitions = 37\n</code></pre>"},{"location":"api/RdKafka/Test/ApiKey/#createtopics","title":"CreateTopics","text":"<pre><code>public CreateTopics = 19\n</code></pre>"},{"location":"api/RdKafka/Test/ApiKey/#deleteacls","title":"DeleteAcls","text":"<pre><code>public DeleteAcls = 31\n</code></pre>"},{"location":"api/RdKafka/Test/ApiKey/#deletegroups","title":"DeleteGroups","text":"<pre><code>public DeleteGroups = 42\n</code></pre>"},{"location":"api/RdKafka/Test/ApiKey/#deleterecords","title":"DeleteRecords","text":"<pre><code>public DeleteRecords = 21\n</code></pre>"},{"location":"api/RdKafka/Test/ApiKey/#deletetopics","title":"DeleteTopics","text":"<pre><code>public DeleteTopics = 20\n</code></pre>"},{"location":"api/RdKafka/Test/ApiKey/#describeacls","title":"DescribeAcls","text":"<pre><code>public DescribeAcls = 29\n</code></pre>"},{"location":"api/RdKafka/Test/ApiKey/#describeconfigs","title":"DescribeConfigs","text":"<pre><code>public DescribeConfigs = 32\n</code></pre>"},{"location":"api/RdKafka/Test/ApiKey/#describedelegationtoken","title":"DescribeDelegationToken","text":"<pre><code>public DescribeDelegationToken = 41\n</code></pre>"},{"location":"api/RdKafka/Test/ApiKey/#describegroups","title":"DescribeGroups","text":"<pre><code>public DescribeGroups = 15\n</code></pre>"},{"location":"api/RdKafka/Test/ApiKey/#describelogdirs","title":"DescribeLogDirs","text":"<pre><code>public DescribeLogDirs = 35\n</code></pre>"},{"location":"api/RdKafka/Test/ApiKey/#endtxn","title":"EndTxn","text":"<pre><code>public EndTxn = 26\n</code></pre>"},{"location":"api/RdKafka/Test/ApiKey/#expiredelegationtoken","title":"ExpireDelegationToken","text":"<pre><code>public ExpireDelegationToken = 40\n</code></pre>"},{"location":"api/RdKafka/Test/ApiKey/#fetch","title":"Fetch","text":"<pre><code>public Fetch = 1\n</code></pre>"},{"location":"api/RdKafka/Test/ApiKey/#findcoordinator","title":"FindCoordinator","text":"<pre><code>public FindCoordinator = 10\n</code></pre>"},{"location":"api/RdKafka/Test/ApiKey/#heartbeat","title":"Heartbeat","text":"<pre><code>public Heartbeat = 12\n</code></pre>"},{"location":"api/RdKafka/Test/ApiKey/#initproducerid","title":"InitProducerId","text":"<pre><code>public InitProducerId = 22\n</code></pre>"},{"location":"api/RdKafka/Test/ApiKey/#joingroup","title":"JoinGroup","text":"<pre><code>public JoinGroup = 11\n</code></pre>"},{"location":"api/RdKafka/Test/ApiKey/#leaderandisr","title":"LeaderAndIsr","text":"<pre><code>public LeaderAndIsr = 4\n</code></pre>"},{"location":"api/RdKafka/Test/ApiKey/#leavegroup","title":"LeaveGroup","text":"<pre><code>public LeaveGroup = 13\n</code></pre>"},{"location":"api/RdKafka/Test/ApiKey/#listgroups","title":"ListGroups","text":"<pre><code>public ListGroups = 16\n</code></pre>"},{"location":"api/RdKafka/Test/ApiKey/#metadata","title":"Metadata","text":"<pre><code>public Metadata = 3\n</code></pre>"},{"location":"api/RdKafka/Test/ApiKey/#none","title":"None","text":"<pre><code>public None = -1\n</code></pre>"},{"location":"api/RdKafka/Test/ApiKey/#offset","title":"Offset","text":"<pre><code>public Offset = 2\n</code></pre>"},{"location":"api/RdKafka/Test/ApiKey/#offsetcommit","title":"OffsetCommit","text":"<pre><code>public OffsetCommit = 8\n</code></pre>"},{"location":"api/RdKafka/Test/ApiKey/#offsetfetch","title":"OffsetFetch","text":"<pre><code>public OffsetFetch = 9\n</code></pre>"},{"location":"api/RdKafka/Test/ApiKey/#offsetforleaderepoch","title":"OffsetForLeaderEpoch","text":"<pre><code>public OffsetForLeaderEpoch = 23\n</code></pre>"},{"location":"api/RdKafka/Test/ApiKey/#produce","title":"Produce","text":"<pre><code>public Produce = 0\n</code></pre>"},{"location":"api/RdKafka/Test/ApiKey/#renewdelegationtoken","title":"RenewDelegationToken","text":"<pre><code>public RenewDelegationToken = 39\n</code></pre>"},{"location":"api/RdKafka/Test/ApiKey/#saslauthenticate","title":"SaslAuthenticate","text":"<pre><code>public SaslAuthenticate = 36\n</code></pre>"},{"location":"api/RdKafka/Test/ApiKey/#saslhandshake","title":"SaslHandshake","text":"<pre><code>public SaslHandshake = 17\n</code></pre>"},{"location":"api/RdKafka/Test/ApiKey/#stopreplica","title":"StopReplica","text":"<pre><code>public StopReplica = 5\n</code></pre>"},{"location":"api/RdKafka/Test/ApiKey/#syncgroup","title":"SyncGroup","text":"<pre><code>public SyncGroup = 14\n</code></pre>"},{"location":"api/RdKafka/Test/ApiKey/#txnoffsetcommit","title":"TxnOffsetCommit","text":"<pre><code>public TxnOffsetCommit = 28\n</code></pre>"},{"location":"api/RdKafka/Test/ApiKey/#updatemetadata","title":"UpdateMetadata","text":"<pre><code>public UpdateMetadata = 6\n</code></pre>"},{"location":"api/RdKafka/Test/ApiKey/#writetxnmarkers","title":"WriteTxnMarkers","text":"<pre><code>public WriteTxnMarkers = 27\n</code></pre>"},{"location":"api/RdKafka/Test/MockCluster/","title":"Class MockCluster","text":"<p>Class \\RdKafka\\Test\\MockCluster</p> <p>Note: MockCluster is experimental - even in librdkafka! Expect breaking changes within minor versions of this library.</p>"},{"location":"api/RdKafka/Test/MockCluster/#methods","title":"Methods","text":""},{"location":"api/RdKafka/Test/MockCluster/#__destruct","title":"__destruct()","text":"<pre><code>public __destruct (  ): \n</code></pre>"},{"location":"api/RdKafka/Test/MockCluster/#create","title":"create()","text":"<pre><code>public static create ( \n    int $brokerCount, \n    ?\\RdKafka\\Conf $conf = null\n ): self\n</code></pre> Parameters brokerCount <code>int</code> conf <code>?\\RdKafka\\Conf</code> Returns <code>self</code>"},{"location":"api/RdKafka/Test/MockCluster/#createtopic","title":"createTopic()","text":"<pre><code>public createTopic ( \n    string $topic, \n    int $partitionCount, \n    int $replicationFactor\n ): void\n</code></pre> <p>Creates a topic.</p> <p>This is an alternative to automatic topic creation as performed by the client itself. The Topic Admin API (CreateTopics) is not supported by the mock broker.</p> Parameters topic <code>string</code> partitionCount <code>int</code> replicationFactor <code>int</code>"},{"location":"api/RdKafka/Test/MockCluster/#fromproducer","title":"fromProducer()","text":"<pre><code>public static fromProducer ( \n    \\RdKafka\\Producer $producer\n ): self\n</code></pre> <p>Derive mock cluster from Producer created by setting the <code>test.mock.num.brokers</code> configuration property.</p> Parameters producer <code>\\RdKafka\\Producer</code> Returns <code>self</code>"},{"location":"api/RdKafka/Test/MockCluster/#getbootstraps","title":"getBootstraps()","text":"<pre><code>public getBootstraps (  ): string\n</code></pre> Returns <code>string</code> the mock cluster\u2019s bootstrap.servers list"},{"location":"api/RdKafka/Test/MockCluster/#pushbrokerrequesterrorrtts","title":"pushBrokerRequestErrorRtts()","text":"<pre><code>public pushBrokerRequestErrorRtts ( \n    int $brokerId, \n    int $apiKey, \n    int $count, \n    int[] $errorCodeAndRttTuples\n ): void\n</code></pre> <p>Same as {@link MockCluster::pushBrokerRequestErrors()} but for a specific broker.</p> <p>The broker errors take precedence over the cluster errors.</p> Parameters brokerId <code>int</code> apiKey <code>int</code> count <code>int</code> errorCodeAndRttTuples <code>int[]</code> plain tuples of error code or 0 (int) and response RTT/delay in millisecond (int)"},{"location":"api/RdKafka/Test/MockCluster/#pushbrokerrequesterrors","title":"pushBrokerRequestErrors()","text":"<pre><code>public pushBrokerRequestErrors ( \n    int $brokerId, \n    int $apiKey, \n    int $count, \n    int[] $errorCodes\n ): void\n</code></pre> <p>Same as {@link MockCluster::pushRequestErrors()} but for a specific broker.</p> <p>The broker errors take precedence over the cluster errors.</p> Parameters brokerId <code>int</code> apiKey <code>int</code> count <code>int</code> errorCodes <code>int[]</code> a list of error codes or 0"},{"location":"api/RdKafka/Test/MockCluster/#pushrequesterrors","title":"pushRequestErrors()","text":"<pre><code>public pushRequestErrors ( \n    int $apiKey, \n    int $count, \n    int $errorCodes\n ): void\n</code></pre> <p>Push cnt errors onto the cluster\u2019s error stack for the given apiKey.</p> <p>ApiKey is the Kafka protocol request type, e.g., Produce (0).</p> <p>The following cnt protocol requests matching apiKey will fail with the provided error code and removed from the stack, starting with the first error code, then the second, etc.</p> Parameters apiKey <code>int</code> count <code>int</code> errorCodes <code>int</code>"},{"location":"api/RdKafka/Test/MockCluster/#pushrequesterrorsarray","title":"pushRequestErrorsArray()","text":"<pre><code>public pushRequestErrorsArray ( \n    int $apiKey, \n    int $count, \n    int[] $errorCodes\n ): void\n</code></pre> <p>See {@link MockCluster::pushRequestErrors()}</p> Parameters apiKey <code>int</code> count <code>int</code> errorCodes <code>int[]</code>"},{"location":"api/RdKafka/Test/MockCluster/#setapiversion","title":"setApiVersion()","text":"<pre><code>public setApiVersion ( \n    int $apiKey, \n    int $minVersion, \n    int $maxVersion\n ): void\n</code></pre> <p>Set the allowed ApiVersion range for apiKey.</p> <p>Set minVersion and maxVersion to -1 to disable the API completely. MaxVersion MUST not exceed the maximum implemented value.</p> Parameters apiKey <code>int</code> Protocol request type/key minVersion <code>int</code> Minimum version supported (or -1 to disable). maxVersion <code>int</code> Maximum version supported (or -1 to disable)."},{"location":"api/RdKafka/Test/MockCluster/#setbrokerdown","title":"setBrokerDown()","text":"<pre><code>public setBrokerDown ( \n    int $brokerId\n ): void\n</code></pre> <p>Disconnects the broker and disallows any new connections.</p> <p>This does NOT trigger leader change.</p> Parameters brokerId <code>int</code>"},{"location":"api/RdKafka/Test/MockCluster/#setbrokerrack","title":"setBrokerRack()","text":"<pre><code>public setBrokerRack ( \n    int $brokerId, \n    string $rack\n ): void\n</code></pre> <p>Sets the broker\u2019s rack as reported in Metadata to the client.</p> Parameters brokerId <code>int</code> rack <code>string</code>"},{"location":"api/RdKafka/Test/MockCluster/#setbrokerup","title":"setBrokerUp()","text":"<pre><code>public setBrokerUp ( \n    int $brokerId\n ): void\n</code></pre> <p>Makes the broker accept connections again.</p> <p>This does NOT trigger leader change.</p> Parameters brokerId <code>int</code>"},{"location":"api/RdKafka/Test/MockCluster/#setcoordinator","title":"setCoordinator()","text":"<pre><code>public setCoordinator ( \n    string $keyType, \n    string $key, \n    int $brokerId\n ): void\n</code></pre> <p>Explicitly sets the coordinator.</p> <p>If this API is not a standard hashing scheme will be used.</p> Parameters keyType <code>string</code> \u201ctransaction\u201d or \u201cgroup\u201d key <code>string</code> The transactional.id or group.id brokerId <code>int</code> The new coordinator, does not have to be a valid broker."},{"location":"api/RdKafka/Test/MockCluster/#setpartitionfollower","title":"setPartitionFollower()","text":"<pre><code>public setPartitionFollower ( \n    string $topic, \n    int $partition, \n    int $brokerId\n ): void\n</code></pre> <p>Sets the partition\u2019s preferred replica / follower.</p> <p>The topic will be created if it does not exist.</p> Parameters topic <code>string</code> partition <code>int</code> brokerId <code>int</code> does not need to point to an existing broker."},{"location":"api/RdKafka/Test/MockCluster/#setpartitionfollowerwatermarks","title":"setPartitionFollowerWatermarks()","text":"<pre><code>public setPartitionFollowerWatermarks ( \n    string $topic, \n    int $partition, \n    int $low, \n    int $high\n ): void\n</code></pre> <p>Sets the partition\u2019s preferred replica / follower low and high watermarks.</p> <p>The topic will be created if it does not exist. Setting an offset to -1 will revert back to the leader\u2019s corresponding watermark.</p> Parameters topic <code>string</code> partition <code>int</code> low <code>int</code> high <code>int</code>"},{"location":"api/RdKafka/Test/MockCluster/#setpartitionleader","title":"setPartitionLeader()","text":"<pre><code>public setPartitionLeader ( \n    string $topic, \n    int $partition, \n    int $brokerId\n ): void\n</code></pre> <p>Sets the partition leader.</p> <p>The topic will be created if it does not exist.</p> Parameters topic <code>string</code> partition <code>int</code> brokerId <code>int</code> needs to be an existing broker"},{"location":"api/RdKafka/Test/MockCluster/#setrtt","title":"setRtt()","text":"<pre><code>public setRtt ( \n    int $brokerId, \n    int $roundTripTimeDelayMs\n ): void\n</code></pre> <p>Set broker round-trip-time delay in milliseconds.</p> Parameters brokerId <code>int</code> roundTripTimeDelayMs <code>int</code>"},{"location":"api/RdKafka/Test/MockCluster/#settopicerror","title":"setTopicError()","text":"<pre><code>public setTopicError ( \n    string $topic, \n    int $errorCode\n ): void\n</code></pre> <p>Set the topic error to return in protocol requests.</p> <p>Currently only used for TopicMetadataRequest and AddPartitionsToTxnRequest.</p> Parameters topic <code>string</code> errorCode <code>int</code>"},{"location":"api/RdKafka/Test/MockCluster/#test-coverage","title":"Test Coverage \ud83e\udde1","text":"<ul> <li>\ud83e\udde1  Lines: 67.71% (65 / 96)</li> <li>\u2764\ufe0f  Methods: 35% (7 / 20)</li> </ul>"},{"location":"contributing/","title":"Contributing","text":"<p>We welcome any contributions whether it\u2019s,</p> <ul> <li>Submitting feedback</li> <li>Fixing bugs</li> <li>Or implementing a new feature.</li> </ul> <p>Please read this guide before making any contributions.</p>"},{"location":"contributing/#submit-feedback","title":"Submit Feedback","text":"<p>The feedback should be submitted by creating an issue at GitHub issues.</p>"},{"location":"contributing/#fix-bugs","title":"Fix Bugs","text":"<p>You may look through the GitHub issues for bugs.</p>"},{"location":"contributing/#implement-features","title":"Implement Features","text":"<p>You may look through the GitHub issues for feature requests.</p>"},{"location":"contributing/#pull-requests-pr","title":"Pull Requests (PR)","text":"<ol> <li>Fork the repository and create a new branch from the master branch.</li> <li>For bug fixes, add new tests and for new features please add changes to the documentation.</li> <li>Do a PR from your new branch to our <code>main</code> branch of the original idealo/php-rdkafka-ffi repo.</li> </ol>"},{"location":"contributing/#code-style","title":"Code Style","text":"<ul> <li>Make sure any new code you introduce has proper code styling according to PRS-12. You should run <code>composer cs-fix</code> before a PR. </li> </ul>"},{"location":"contributing/#documentation","title":"Documentation","text":"<ul> <li>Make sure any new code you introduce has proper phpdoc. You may add extra usage documentation under /docs/usage</li> </ul> <p>See work on the documentation locally.</p>"},{"location":"contributing/#testing","title":"Testing","text":"<ul> <li>Make sure to write tests for any new feature and/or bug fixes. We use phpunit for our testing. </li> </ul> <p>See run tests locally.</p>"},{"location":"contributing/#main-contributor-list","title":"Main Contributor List","text":"<p>We maintain a list of main contributors to appreciate all the contributions.</p>"},{"location":"contributing/contributors/","title":"Contributors","text":"Contributor Contributions  dirx 506  siad007 5  carusogabriel 2  kmbremner 1  manonworldrepository 1"},{"location":"contributing/project-overview/","title":"Project Overview","text":""},{"location":"contributing/project-overview/#directory-overview","title":"Directory overview","text":"<ul> <li>/benchmarks - phpbench based benchmark tests</li> <li>/docs - docs dir (markdown)</li> <li>/examples - example scripts</li> <li>/resources<ul> <li>/benchmarks ansible playbooks setup and run benchmarks</li> <li>/docker<ul> <li>/php74-librdkafka-ffi - dockerfile for PHP 7.4 image with librdkafka and ffi &amp; rdkafka ext (based   on php:7.4-cli )</li> <li>/php80-librdkafka-ffi - dockerfile for PHP 8.0 image with librdkafka and ffi &amp; rdkafka ext (based   on php:8.0-rc-cli )</li> </ul> </li> <li>/docs - scripts to build documentation site from /docs</li> <li>/ffigen - config to build low level library bindings</li> <li>/phpunit - bootstrap and config for phpunit tests</li> <li>/test-extension - base dir for rdkafka ext compatibility tests</li> </ul> </li> <li>/src - source dir</li> <li>/tests - tests dir</li> </ul>"},{"location":"contributing/project-overview/#docker-images-for-development","title":"Docker Images for Development","text":"<p>Build all images</p> <pre><code>docker-compose build --no-cache --pull\n</code></pre> <p>Alternative: build the image individually</p> <pre><code>docker-compose build --no-cache --pull php74 php80\n</code></pre> <p>Alternative: build the image individually and set optional build args (LIBRDKAFKA_VERSION default = v1.5.3, RDKAFKA_EXT_VERSION default = 4.1.x for php74 / 5.x for php80)</p> <pre><code>docker-compose build --no-cache --pull --build-arg LIBRDKAFKA_VERSION=\"v1.5.3\" --build-arg RDKAFKA_EXT_VERSION=\"4.1.1\" php74\n</code></pre> <p>Test - should show latest 7.4 version</p> <pre><code>docker-compose run php74 php -v\n</code></pre> <p>Test - should show <code>FFI</code> in modules list</p> <pre><code>docker-compose run php74 php -m\n</code></pre> <p>Test ffi librdkafka binding - should show current version of librdkafka:</p> <pre><code>docker-compose run php74 php examples/version.php\n</code></pre> <p>Test - should show <code>rdkafka</code> in modules list</p> <pre><code>docker-compose run php74 php -dextension=rdkafka.so -m\n</code></pre>"},{"location":"contributing/project-overview/#references","title":"References","text":"<ul> <li>FFI extension</li> <li>librdkafka ^1.0 (docs)</li> <li>Confluent Kafka / Zookeeper docker   images</li> <li>phpbench lib for benchmarking</li> </ul>"},{"location":"contributing/run-benchmarks/","title":"Run benchmarks","text":"<p>Benchmarks use topic <code>benchmarks</code>.</p> <p>Run Benchmarks</p> <pre><code>docker-compose down -v; \\\ndocker-compose up -d kafka; \\\ndocker-compose exec kafka cub kafka-ready -z zookeeper:2181 1 20; \\\ndocker-compose run --rm php74 composer benchmarks-init; \\\ndocker-compose run --rm php74 vendor/bin/phpbench run benchmarks --config=/app/benchmarks/ffi.json --report=default --store --tag=php74_ffi --group=ffi; \\\ndocker-compose run --rm php74 vendor/bin/phpbench run benchmarks --config=/app/benchmarks/ffi_preload.json --report=default --store --tag=php74_ffi_preload --group=ffi; \\\ndocker-compose run --rm php80 vendor/bin/phpbench run benchmarks --config=/app/benchmarks/ffi.json --report=default --store --tag=php80_ffi --group=ffi; \\\ndocker-compose run --rm php80 vendor/bin/phpbench run benchmarks --config=/app/benchmarks/ffi_preload.json --report=default --store --tag=php80_ffi_preload --group=ffi; \\\ndocker-compose run --rm php80 vendor/bin/phpbench run benchmarks --config=/app/benchmarks/ffi_jit.json --report=default --store --tag=php80_ffi_preload_jit --group=ffi; \\\ndocker-compose run --rm php74 vendor/bin/phpbench run benchmarks --config=/app/benchmarks/ext.json --report=default --store --tag=php74_ext --group=ext; \\\ndocker-compose run --rm php80 vendor/bin/phpbench run benchmarks --config=/app/benchmarks/ext.json --report=default --store --tag=php80_ext --group=ext\n</code></pre> <p>Show comparison for runtime average</p> <pre><code>docker-compose run --rm php74 vendor/bin/phpbench report \\\n    --ref=php74_ffi \\\n    --ref=php74_ffi_preload \\\n    --ref=php80_ffi \\\n    --ref=php80_ffi_preload \\\n    --ref=php80_ffi_preload_jit \\\n    --ref=php74_ext \\\n    --ref=php80_ext \\\n    --report=summary \\\n    --config=benchmarks\\report.json\n</code></pre> <p>Run Api::init benchmark (fix vs auto detected version)</p> <pre><code>docker-compose run --rm php74 vendor/bin/phpbench run benchmarks --config=/app/benchmarks/ffi.json --report=default --group=Api\n</code></pre>"},{"location":"contributing/run-tests/","title":"Run tests","text":"<p>Tests use topics <code>test*</code>.</p>"},{"location":"contributing/run-tests/#prepare","title":"Prepare","text":"<p>Startup php &amp; kafka</p> <pre><code>docker-compose up -d\n</code></pre> <p>Updating Dependencies</p> <pre><code>docker-compose run --rm --no-deps php74 composer update\n</code></pre> <p>Run tests</p> <pre><code>docker-compose run --rm php74 composer test-init\ndocker-compose run --rm php74 composer test\n</code></pre> <p>Run tests with coverage</p> <pre><code>docker-compose run --rm php74 composer test-coverage\n</code></pre>"},{"location":"contributing/run-tests/#run-tests-against-rdkafka-extension-php-74","title":"Run tests against RdKafka extension / PHP 7.4","text":"<p>Updating Dependencies</p> <pre><code>docker-compose run --rm --no-deps php74 composer update -d /app/resources/test-extension --ignore-platform-reqs\n</code></pre> <p>Run tests</p> <pre><code>docker-compose run --rm php74 composer test-extension-init\ndocker-compose run --rm php74 composer test-extension\n</code></pre>"},{"location":"contributing/run-tests/#run-tests-against-rdkafka-extension-php-80","title":"Run tests against RdKafka extension / PHP 8.0","text":"<p>Updating Dependencies</p> <pre><code>docker-compose run --rm --no-deps php80 composer update -d /app/resources/test-extension --ignore-platform-reqs\n</code></pre> <p>Run tests</p> <pre><code>docker-compose run --rm php80 composer test-extension-init\ndocker-compose run --rm php80 composer test-extension\n</code></pre>"},{"location":"contributing/work-on-the-documentation/","title":"Work on the documentation","text":"<p>Documentation is based on <code>markdown</code> and the static site is build with mkdocs material. The API documentation is generated by dog as markdown.</p> <p>Serve documentation on http://localhost:8000/</p> <pre><code>docker-compose run --rm php74 composer prepare-docs\ndocker-compose up mkdocs\n</code></pre> <p>Build static site in folder site</p> <pre><code>docker-compose run --rm php74 composer prepare-docs\ndocker-compose run --rm mkdocs build\n</code></pre>"},{"location":"usage/about-ffi-and-librdkafka/","title":"About FFI and librdkafka","text":"<p>This library is pretty slim wrapper around librdkafka. Most of the heavy lifting is done by librdkafka.</p> <p>The binding to librdkafka is done via the FFI extension which is bundled since PHP ^7.4.</p>"},{"location":"usage/about-ffi-and-librdkafka/#what-is-ffi","title":"What is FFI?","text":"<p>FFI stands Foreign Function Interface.</p> <p>The ffi extension allows the loading of shared libraries (.so, .dynlib or .DLL), calling of C functions and accessing of C data structures in pure PHP, without having to have deep knowledge of the Zend extension API, and without having to learn a third \u201cintermediate\u201d language. The public API is implemented as a single class FFI with several static methods (some of them may be called dynamically), and overloaded object methods, which perform the actual interaction with C data.</p> <p>Hint</p> <p>The FFI extension is marked as EXPERIMENTAL.  This means that its PHP interface may have breaking changes even in minor PHP releases. This library will take care of those changes to support upcoming PHP releases.  In fact, there were no breaking changes between PHP version 7 and 8.</p>"},{"location":"usage/about-ffi-and-librdkafka/#what-is-librdkafka","title":"What is librdkafka?","text":"<p>librdkafka is a high performance C implementation of the Apache Kafka client, providing a reliable and performant client for production use.</p> <p>This librdkafka introduction gives a detailed overview of the supported features and inner workings.</p> <p>It is maintained by Confluent Inc..</p>"},{"location":"usage/admin-client/","title":"Admin Client","text":"<p>The admin client provides support for:</p> <ul> <li>reading/updating broker configuration</li> <li>creating/deleting topics</li> <li>reading/updating topic configuration</li> <li>deleting records from topics</li> <li>reading/updating consumer group configuration</li> <li>deleting consumer groups and consumer group offsets</li> </ul> <p>Admin Client features depend on the currently very limited support in librdkafka.</p> <p>Experimental</p> <p>API can have breaking changes in next releases and does not follow semantic versioning.</p>"},{"location":"usage/admin-client/#create-client","title":"Create client","text":"<p>There are 3 ways to create an Admin Client.</p>"},{"location":"usage/admin-client/#from-conf","title":"From Conf","text":"<pre><code>$config = new RdKafka\\Conf();\n$config-&gt;set('metadata.broker.list', 'kafka:9092');\n$client = RdKafka\\Admin\\Client::fromConf($conf);\n</code></pre>"},{"location":"usage/admin-client/#from-producer","title":"From Producer","text":"<pre><code>// \\RdKafka\\Producer $producer was initialized before\n$client = \\RdKafka\\Admin\\Client::fromProducer($producer);\n</code></pre>"},{"location":"usage/admin-client/#from-consumer-low-level","title":"From Consumer (low level)","text":"<pre><code>// \\RdKafka\\Consumer $consumer was initialized before\n$client = \\RdKafka\\Admin\\Client::fromConsumer($consumer);\n</code></pre> <p>You may optionally set internal waitForResultEventTimeout property in case you run into timing issues:</p> <pre><code>$timeoutMs = 100;\n$client-&gt;setWaitForResultEventTimeout($timeoutMs);\n</code></pre>"},{"location":"usage/admin-client/#configuration","title":"Configuration","text":"<p>You can read or change config values on resource types Broker, Topic or Consumer Group.</p>"},{"location":"usage/admin-client/#resource-types","title":"Resource Types","text":""},{"location":"usage/admin-client/#topic","title":"Topic","text":"<p>Initialize ConfigResource for a topic:</p> <pre><code>$configResource = new \\RdKafka\\Admin\\ConfigResource(\n    RD_KAFKA_RESOURCE_TOPIC, // 2\n    'test' // name of topic\n);\n</code></pre>"},{"location":"usage/admin-client/#consumer-group","title":"Consumer Group","text":"<p>Initialize ConfigResource for a consumer group:</p> <pre><code>$configResource = new \\RdKafka\\Admin\\ConfigResource(\n    RD_KAFKA_RESOURCE_GROUP, // 3\n    'test' // name of consumer group\n);\n</code></pre>"},{"location":"usage/admin-client/#broker","title":"Broker","text":"<p>Initialize ConfigResource for a broker:</p> <pre><code>$configResource = new \\RdKafka\\Admin\\ConfigResource(\n    RD_KAFKA_RESOURCE_BROKER, // 4\n    '111' // broker id\n);\n</code></pre>"},{"location":"usage/admin-client/#set-config-values","title":"Set Config Values","text":"<p>Set config values on resource for alterConfigs requests.</p> <pre><code>$configResource-&gt;setConfig('max.connections.per.ip', (string) 2147483647);\n$configResource-&gt;setConfig('any.other', 'new value');\n</code></pre>"},{"location":"usage/admin-client/#describe","title":"Describe","text":"<p>Read configurations for resources:</p> <pre><code>// optionally set request options\n$options = $client-&gt;newDescribeConfigsOptions();\n$options-&gt;setRequestTimeout(500);\n$options-&gt;setBrokerId(111);\n\n$results = $client-&gt;describeConfigs(\n    [\n        new \\RdKafka\\Admin\\ConfigResource(\n            RD_KAFKA_RESOURCE_BROKER,\n            '111'\n        ),\n        new \\RdKafka\\Admin\\ConfigResource(\n            RD_KAFKA_RESOURCE_TOPIC,\n            'test'\n        )\n    ],\n    $options\n);\n\nforeach ($results as $result) {\n    if ($result-&gt;error === RD_KAFKA_RESP_ERR_NO_ERROR) {\n        var_dump($result-&gt;configs);\n    } else {\n        // handle errors\n    }\n}\n</code></pre> <p><code>$results</code> contains array of <code>\\RdKafka\\Admin\\ConfigResourceResult</code> objects for each requested ConfigResource.</p>"},{"location":"usage/admin-client/#alter","title":"Alter","text":"<p>Change configuration values for resources:</p> <pre><code>$configResource = new \\RdKafka\\Admin\\ConfigResource(\n    RD_KAFKA_RESOURCE_BROKER,\n    '111' // broker id\n);\n$configResource-&gt;setConfig('max.connections.per.ip', '2147483647');\n\n// optionally set request options\n$options = $client-&gt;newDescribeConfigsOptions();\n$options-&gt;setRequestTimeout(500);\n$options-&gt;setBrokerId(111);\n\n$results = $client-&gt;alterConfigs(\n    [\n        $configResource\n    ],\n    $options\n);\n\nforeach ($results as $result) {\n    if ($result-&gt;error === RD_KAFKA_RESP_ERR_NO_ERROR) {\n        var_dump($result-&gt;configs);\n    } else {\n        // handle errors\n    }\n}\n</code></pre> <p><code>$results</code> contains array of <code>\\RdKafka\\Admin\\ConfigResourceResult</code> objects for each requested ConfigResource.</p>"},{"location":"usage/admin-client/#topic_1","title":"Topic","text":""},{"location":"usage/admin-client/#create","title":"Create","text":"<pre><code>// optionally set request options\n$options = $client-&gt;newCreateTopicsOptions();\n$options-&gt;setRequestTimeout(500);\n$options-&gt;setBrokerId(111);\n$options-&gt;setValidateOnly(true); // set true for dry run\n\n$results = $client-&gt;createTopics(\n    [\n        new \\RdKafka\\Admin\\NewTopic(\n            'test', // name of topic\n            1, // partitions\n            1 // replica\n        ),\n    ],\n    $options\n);\n\nforeach ($results as $result) {\n    if ($result-&gt;error === RD_KAFKA_RESP_ERR_NO_ERROR) {\n        var_dump($result-&gt;configs);\n    } else {\n        // handle errors\n    }\n}\n</code></pre> <p><code>$results</code> contains array of <code>\\RdKafka\\Admin\\TopicResult</code> objects for each requested NewTopic.</p>"},{"location":"usage/admin-client/#delete","title":"Delete","text":"<pre><code>// optionally set request options\n$options = $client-&gt;newDeleteTopicsOptions();\n$options-&gt;setRequestTimeout(500);\n$options-&gt;setBrokerId(111);\n$options-&gt;setValidateOnly(true); // set true for dry run\n\n$results = $client-&gt;deleteTopics(\n    [\n        new \\RdKafka\\Admin\\DeleteTopic(\n            'test', // name of topic\n        ),\n    ],\n    $options\n);\n\nforeach ($results as $result) {\n    if ($result-&gt;error === RD_KAFKA_RESP_ERR_NO_ERROR) {\n        var_dump($result-&gt;configs);\n    } else {\n        // handle errors\n    }\n}\n</code></pre> <p><code>$results</code> contains array of <code>\\RdKafka\\Admin\\TopicResult</code> objects for each requested DeleteTopic.</p>"},{"location":"usage/admin-client/#add-partitions","title":"Add Partitions","text":"<pre><code>// optionally set request options\n$options = $client-&gt;newDeleteTopicsOptions();\n$options-&gt;setRequestTimeout(500);\n$options-&gt;setBrokerId(111);\n$options-&gt;setValidateOnly(true); // set true for dry run\n\n$results = $client-&gt;createPartitions(\n    [\n        new \\RdKafka\\Admin\\NewPartitions(\n            'test', // name of topic\n            3, // new total partition count\n        ),\n    ],\n    $options\n);\n\nforeach ($results as $result) {\n    if ($result-&gt;error === RD_KAFKA_RESP_ERR_NO_ERROR) {\n        var_dump($result-&gt;configs);\n    } else {\n        // handle errors\n    }\n}\n</code></pre>"},{"location":"usage/admin-client/#delete-records-messages","title":"Delete Records (Messages)","text":"<p>Delete records (messages) in topic partitions older than the offsets provided.</p> <pre><code>// optionally set request options\n$options = $client-&gt;newDeleteRecordsOptions();\n$options-&gt;setRequestTimeout(500);\n$options-&gt;setBrokerId(111);\n$options-&gt;setValidateOnly(true); // set true for dry run\n\n$results = $client-&gt;deleteRecords(\n    [\n        new \\RdKafka\\Admin\\DeleteRecords(\n            new \\RdKafka\\TopicPartition('example', 0, 1)\n        ),\n    ],\n    $options\n);\n\nforeach ($results as $result) {\n    if ($result-&gt;error === RD_KAFKA_RESP_ERR_NO_ERROR) {\n        var_dump($result);\n    } else {\n        // handle errors\n    }\n}\n</code></pre> <p><code>$results</code> contains array of <code>\\RdKafka\\TopicPartition</code> objects for each requested TopicPartition.</p>"},{"location":"usage/admin-client/#consumer-group_1","title":"Consumer Group","text":""},{"location":"usage/admin-client/#delete-group","title":"Delete Group","text":"<p>tbd.</p>"},{"location":"usage/admin-client/#delete-consumer-group-offsets","title":"Delete Consumer Group Offsets","text":"<p>tbd.</p>"},{"location":"usage/admin-client/#get-metadata","title":"Get Metadata","text":"<p>Request Metadata for Broker, Topics and Partitions from broker cluster.</p>"},{"location":"usage/admin-client/#for-all-topics","title":"For all topics","text":"<p>This will also return data for internal topics like <code>__consumer_offsets</code>.</p> <pre><code>$metadata = $client-&gt;getMetadata(\n    true, // true for all topics\n    null,\n    1000 // timeout in ms\n);\n\nvar_dump($metadata-&gt;getOrigBrokerName());\nvar_dump($metadata-&gt;getOrigBrokerId());\nvar_dump($metadata-&gt;getBrokers());\nvar_dump($metadata-&gt;getTopics());\n</code></pre>"},{"location":"usage/admin-client/#for-specific-topic","title":"For specific topic","text":"<pre><code>$metadata = $client-&gt;getMetadata(\n    false, // false to request data only for specific topic\n    $topic, // instance of a RdKafka\\Topic\n    1000 // timeout in ms\n);\n\nvar_dump($metadata-&gt;getOrigBrokerName());\nvar_dump($metadata-&gt;getOrigBrokerId());\nvar_dump($metadata-&gt;getBrokers());\nvar_dump($metadata-&gt;getTopics()); // will hold only details to specific topic\n</code></pre>"},{"location":"usage/admin-client/#run-examples","title":"Run Examples","text":"<p>If you want to test some of the Admin Client features, you can take a look at the examples. Please take a look at how to prepare running the examples before.</p>"},{"location":"usage/admin-client/#describe-config","title":"Describe config","text":"<p>Cli options of the describe config example</p> <ul> <li><code>-t</code> is for the type of config you want and in our case it should be <code>4</code> to get configuration options for a specific broker</li> <li><code>-v</code> is the value of the broker ID that you want to get its own configuration options and in our example we use <code>111</code></li> <li><code>-b</code> is the broker used and in our example we use <code>kafka:9092</code></li> </ul> <p>Run the example:</p> <pre><code>docker-compose run --rm php74 php examples/describe-config.php -t=4 -v=111 -b=kafka:9092\n</code></pre> <p>And you should see the configuration options for the broker you selected.</p>"},{"location":"usage/admin-client/#create-topic","title":"Create Topic","text":"<p>Cli options of the create topic example</p> <ul> <li><code>-t</code> is the name of the topic to be created and in our example we use <code>example</code></li> <li><code>-p</code> is the number of partitions and in our example we use <code>3</code></li> <li><code>-r</code> is the number of replicas and in our example we use <code>1</code></li> <li><code>-b</code> is the broker used and in our example we use <code>kafka:9092</code></li> <li><code>-w</code> is the time to wait for the result in ms <code>10000</code></li> </ul> <p>Run the example:</p> <pre><code>docker-compose run --rm php74 php examples/create-topic.php -t=example -p=3 -r=1 -b=kafka:9092\n</code></pre> <p>And you should see the topic <code>example</code>.</p>"},{"location":"usage/admin-client/#delete-topic","title":"Delete Topic","text":"<p>Cli options of the delete topic example</p> <ul> <li><code>-t</code> is the name of the topic to be deleted and in our example we use <code>example</code></li> <li><code>-b</code> is the broker used and in our example we use <code>kafka:9092</code></li> <li><code>-w</code> is the time to wait for the result in ms <code>10000</code></li> </ul> <p>Run the example:</p> <pre><code>docker-compose run --rm php74 php examples/delete-topic.php -t=example -b=kafka:9092\n</code></pre> <p>And you should not see topic <code>example</code> any longer.</p>"},{"location":"usage/alternatives/","title":"Alternatives","text":""},{"location":"usage/alternatives/#rdkafka-extension","title":"RdKafka Extension","text":"<p>The PHP Extension rdkafka (github) uses librdkafka for binding. This is the best known Kafka client implementation for PHP. It is maintained by Arnaud Le Blanc.</p> <p>It currently does not support features like the Admin Client and Mock Cluster.</p> <p>Note</p> <p>The RdKafka FFI library supports the same interfaces like this extension.</p>"},{"location":"usage/alternatives/#simple-kafka-client-extension","title":"Simple Kafka Client Extension","text":"<p>The PHP Extension simple_kafka_client (github) uses librdkafka for binding. This implementation focuses on simplicity. It is maintained by Nikazu Tenaka.</p> <p>More resources around PHP &amp; Kafka can be found at https://github.com/php-kafka.</p>"},{"location":"usage/changelog/","title":"Changelog","text":"<p>All notable changes to this project are documented in this file using the Keep a CHANGELOG principles. This project adheres to Semantic Versioning.</p>"},{"location":"usage/changelog/#unreleased","title":"Unreleased","text":""},{"location":"usage/changelog/#060","title":"0.6.0","text":"<p>This pre-release improves compatible with the PHP RdKafka extension ^5.0 and ^6.0.</p>"},{"location":"usage/changelog/#added","title":"Added","text":"<ul> <li>Add support for PHP 8.3 and 8.4</li> <li>Add support for librdkafka 2.1.0, 2.1.1, 2.2.0, 2.2.1, 2.3.0, 2.4.0, 2.5.0, 2.5.3, 2.6.0, 2.6.1, 2.8.0</li> </ul>"},{"location":"usage/changelog/#changed","title":"Changed","text":"<ul> <li>Change internal usage for deprecated static FFI::new(), FFI:;cast(), FFI::type()</li> </ul>"},{"location":"usage/changelog/#fixed","title":"Fixed","text":"<ul> <li>Fix handling of native transaction error lifecycle</li> </ul>"},{"location":"usage/changelog/#050","title":"0.5.0","text":"<p>This pre-release improves compatible with the PHP RdKafka extension ^5.0 and ^6.0.</p> <p>Note: compatibility with PHP RdKafka extension ^4.0 is no longer supported.</p>"},{"location":"usage/changelog/#added_1","title":"Added","text":"<ul> <li>Add explicit support for PHP 8.1 and 8.2</li> <li>Add support for librdkafka v1.6.2, v1.9.0, v1.9.1, v1.9.2, v2.0.0, v2.0.1, v2.0.2</li> </ul>"},{"location":"usage/changelog/#fixed_1","title":"Fixed","text":"<ul> <li>Fix Message header &amp; len type handling</li> <li>Message::headers is now always of type array</li> <li>Message::len is null if payload is null</li> <li>Fix Collection:key() and Collection::current() type handling</li> <li>Collection:key() always returns int</li> </ul>"},{"location":"usage/changelog/#040","title":"0.4.0","text":"<p>This pre-release improves compatible with the PHP RdKafka extension ^4.0 and ^5.0.</p>"},{"location":"usage/changelog/#added_2","title":"Added","text":"<ul> <li>Add pausePartitions/resumePartitions to Producer/ KafkaConsumer</li> <li>Add deleteRecords, deleteConsumerGroupOffsets and deleteGroups to Admin Client</li> <li>Add support for librdkafka v1.6.0, v1.6.1, v1.7.0, v1.8.0, v1.8.2</li> </ul>"},{"location":"usage/changelog/#changed_1","title":"Changed","text":"<ul> <li>Rename Message::_private to ::opaque</li> <li>Mark consumeCallback in ConsumerTopic as deprecated (it is deprecated in librdkafka since v1.4.0)</li> </ul>"},{"location":"usage/changelog/#fixed_2","title":"Fixed","text":"<ul> <li>Fix headers param in ProducerTopic::producev does not accept null</li> </ul>"},{"location":"usage/changelog/#030-2020-12-16","title":"0.3.0 - 2020-12-16","text":""},{"location":"usage/changelog/#added_3","title":"Added","text":"<ul> <li>Add support for rd_kafka_err2name</li> <li>Add opaque reference handling in Configs &amp; Callbacks, produce &amp; Message</li> </ul>"},{"location":"usage/changelog/#020-2020-12-09","title":"0.2.0 - 2020-12-09","text":"<p>This pre-release supports PHP ^7.4 and ^8.0 and librdkafka v1.0.0 - v1.5.3. It is compatible with the PHP RdKafka extension ^4.0.</p> <p>Note: Transactional Producer is no longer marked as experimental.</p>"},{"location":"usage/changelog/#fixed_3","title":"Fixed","text":"<ul> <li>Fix empty TopicPartition metadata handling</li> </ul>"},{"location":"usage/changelog/#added_4","title":"Added","text":"<ul> <li>Add TopicPartition::getMetadataSize()</li> <li>Add support for librdkafka v1.5.3</li> </ul>"},{"location":"usage/changelog/#changed_2","title":"Changed","text":"<ul> <li>Rename KafkaError to KafkaErrorException and change its interface for rdkafka extension compatibility with v4.1.*</li> <li>Suggests pcntl extension (instead of requires)</li> </ul>"},{"location":"usage/changelog/#010-2020-12-06","title":"0.1.0 - 2020-12-06","text":"<p>This first pre-release supports PHP ^7.4 and ^8.0 and librdkafka v1.0.0 - v1.5.2.  It is compatible with the PHP RdKafka extension 4.0.*.</p> <p>Note: features marked as experimental are stable, but the interface may change in future releases.</p> <p>Special thanks to @siad007 and @carusogabriel for early fixes and tweaks.</p>"},{"location":"usage/changelog/#added_5","title":"Added","text":"<ul> <li>Add Consumer (low and high level)</li> <li>Add Producer (with support for experimental transactional producing)</li> <li>Add Admin Client (experimental)</li> <li>Add Mock Cluster to simplify integration tests (experimental)</li> <li>Add FFI binding for librdkafka 1.0.0 - 1.5.2</li> <li>Add examples and basic documentation</li> <li>Add benchmarks</li> </ul>"},{"location":"usage/configuration/","title":"Configuration","text":"<p>Tip</p> <p>See librdkafka CONFIGURATION for available parameters</p>"},{"location":"usage/configuration/#set-get-dump","title":"Set, Get &amp; Dump","text":"<p>Note</p> <p>Values are always of type <code>string</code>.</p> <pre><code>// create config\n$conf = new \\RdKafka\\Conf();\n\n$conf-&gt;set('log_level', (string) LOG_DEBUG);\n\nvar_dump($conf-&gt;get('log_level'));\nvar_dump($conf-&gt;dump());\n</code></pre>"},{"location":"usage/configuration/#logging","title":"Logging","text":"<p>The default is to print to stderr. Alternatively the application may provide its own logger callback. Or call <code>setLogCb(null)</code> to disable logging.</p> <pre><code>// create config\n$conf = new \\RdKafka\\Conf();\n\n// enable logging\n$conf-&gt;set('log_level', (string) LOG_DEBUG);\n$conf-&gt;set('debug', 'all');\n$conf-&gt;setLogCb(\n    function (\\RdKafka $rdkafka, int $level, string $facility, string $message): void {\n        echo sprintf(\"log: %d %s %s\", $level, $fac, $buf) . PHP_EOL;\n    }\n);\n</code></pre>"},{"location":"usage/configuration/#error-handling","title":"Error Handling","text":"<p>The error callback is used by librdkafka to signal warnings and errors back to the application.</p> <p>These errors should generally be considered informational and non-permanent, the client will try to recover automatically from all type of errors. Given that the client and cluster configuration is correct the application should treat these as temporary errors.</p> <p>The error callback will be triggered with err set to RD_KAFKA_RESP_ERR__FATAL if a fatal error has been raised; in this case use rd_kafka_fatal_error() to retrieve the fatal error code and error string, and then begin terminating the client instance.</p> <pre><code>// create config\n$conf = new \\RdKafka\\Conf();\n$conf-&gt;setErrorCb(\n    function (\\RdKafka $rdkafka, int $err, string $reason, $opaque = null): void \n    {\n        echo sprintf(\"Error %d %s. Reason: %s\", $err, rd_kafka_err2str($err), $reason) . PHP_EOL;\n        if ($err === RD_KAFKA_RESP_ERR__FATAL) {\n            throw new \\RuntimeException('fatal error');\n        }\n    }\n);\n</code></pre>"},{"location":"usage/configuration/#read-statistics","title":"Read Statistics","text":"<p>Tip</p> <p>See https://github.com/confluentinc/librdkafka/blob/master/STATISTICS.md for a detailed list of emitted metrics.</p> <pre><code>// create config\n$conf = new \\RdKafka\\Conf();\n$conf-&gt;setStatsCb(\n    function ($consumerOrProducer, string $json, int $jsonLength, $opaque = null): void \n    {\n        var_dump(\\json_decode($json, true));\n    }\n);\n</code></pre>"},{"location":"usage/configuration/#monitor-message-delivery","title":"Monitor Message Delivery","text":"<p>Producer only.</p> <p>Keep track of message delivery and react on final delivery errors.</p> <p>Note</p> <p>Please read about librdkafka &amp; its message reliability to fully understand why delivery of messages can fail and how to handle failures.</p> <pre><code>$conf-&gt;setDrMsgCb(\n    function (\\RdKafka\\Producer $producer, \\RdKafka\\Message $message): void {\n        if ($message-&gt;err !== RD_KAFKA_RESP_ERR_NO_ERROR) {\n            // handle delivery errors\n        }\n    }\n);\n</code></pre>"},{"location":"usage/consumer-high-level/","title":"Create a High Level Consumer","text":"<p>Tip</p> <p>Consider using the high-level consumer if you want to worry less about managing offsets, handling broker failover and load balancing partitions and consumers.</p>"},{"location":"usage/consumer-high-level/#configure-the-consumer","title":"Configure the consumer","text":"<pre><code>$conf = new \\RdKafka\\Conf();\n$conf-&gt;set('bootstrap.servers', 'kafka:9092');\n$conf-&gt;set('group.id', 'consumer-highlevel');\n$conf-&gt;set('enable.partition.eof', 'true');\n$conf-&gt;set('auto.offset.reset', 'earliest');\n$conf-&gt;set('log_level', (string) LOG_DEBUG);\n$conf-&gt;set('debug', 'all');\n$conf-&gt;setLogCb(\n    function (\\RdKafka\\KafkaConsumer $consumer, int $level, string $facility, string $message): void {\n        // Perform your logging mechanism here\n    }\n);\n</code></pre> <p>See configuration for more details.</p>"},{"location":"usage/consumer-high-level/#create-a-consumer-instance","title":"Create a consumer instance","text":"<pre><code>$consumer = new \\RdKafka\\KafkaConsumer($conf);\n$consumer-&gt;subscribe(['playground']); // Our example topic name\n</code></pre>"},{"location":"usage/consumer-high-level/#consume-messages","title":"Consume Messages","text":"<pre><code>do {\n    $message = $consumer-&gt;consume(100);\n\n    if ($message-&gt;err === RD_KAFKA_RESP_ERR__TIMED_OUT) {\n        continue;\n    }\n    if ($message-&gt;err === RD_KAFKA_RESP_ERR__PARTITION_EOF) {\n        continue;\n    }\n\n    // process your message here\n\n    $consumer-&gt;commit($message);\n} while (true);\n</code></pre>"},{"location":"usage/consumer-high-level/#run-example","title":"Run Example","text":"<p>If you want to test consuming messages with the high level consumer, you can take a look at the high level consumer example. Please take a look at how to prepare running the examples before.</p> <p>Produce to the same topic that we created using the following command:</p> <pre><code>docker-compose run --rm php74 php examples/producer.php\n</code></pre> <p>Consume the messages produced to the same topic using the following command:</p> <pre><code>docker-compose run --rm php74 php examples/consumer-highlevel.php\n</code></pre> <p>And you should see all messages consumed from topic <code>playground</code>.</p>"},{"location":"usage/consumer-low-level/","title":"Create a Low Level Consumer","text":"<p>Warning</p> <p>Consider using the low level consumer only if you need more flexible control over consuming messages.</p>"},{"location":"usage/consumer-low-level/#configure-the-consumer","title":"Configure the Consumer","text":"<pre><code>$conf = new \\RdKafka\\Conf();\n$conf-&gt;set('bootstrap.servers', 'kafka:9092');\n$conf-&gt;set('group.id', 'test');\n$conf-&gt;set('log_level', (string) LOG_DEBUG);\n$conf-&gt;set('debug', 'all');\n$conf-&gt;setLogCb(\n    function (\\RdKafka\\Consumer $consumer, int $level, string $facility, string $message): void {\n        // Perform your logging mechanism here\n    }\n);\n\n$conf-&gt;set('statistics.interval.ms', (string) 1000);\n$conf-&gt;setStatsCb(\n    function (\\RdKafka\\Consumer $consumer, string $json, int $jsonLength, $opaque): void {\n        // Perform your stats mechanism here ...\n    }\n);\n</code></pre> <p>See configuration for more details.</p>"},{"location":"usage/consumer-low-level/#configure-the-topic","title":"Configure the topic","text":"<pre><code>$topicConf = new \\RdKafka\\TopicConf();\n$topicConf-&gt;set('enable.auto.commit', 'true');\n$topicConf-&gt;set('auto.commit.interval.ms', (string) 100);\n$topicConf-&gt;set('auto.offset.reset', 'earliest');\n</code></pre>"},{"location":"usage/consumer-low-level/#create-a-consumer-instance","title":"Create a consumer instance","text":"<pre><code>$consumer = new \\RdKafka\\Consumer($conf);\n</code></pre>"},{"location":"usage/consumer-low-level/#consume-from-topic","title":"Consume from topic","text":"<pre><code>$topic = $consumer-&gt;newTopic('playground', $topicConf); // Our example topic name\n</code></pre>"},{"location":"usage/consumer-low-level/#create-a-new-queue","title":"Create a new Queue","text":"<pre><code>$queue = $consumer-&gt;newQueue();\n</code></pre>"},{"location":"usage/consumer-low-level/#consume-messages","title":"Consume Messages","text":"<p>E.g. consume messages from 3 partitions via the new queue</p> <pre><code>$topic-&gt;consumeQueueStart(0, RD_KAFKA_OFFSET_BEGINNING, $queue);\n$topic-&gt;consumeQueueStart(1, RD_KAFKA_OFFSET_BEGINNING, $queue);\n$topic-&gt;consumeQueueStart(2, RD_KAFKA_OFFSET_BEGINNING, $queue);\ndo {\n    $message = $queue-&gt;consume(1000);\n\n    if ($message === null) {\n        continue;\n    } elseif ($message-&gt;err === RD_KAFKA_RESP_ERR_NO_ERROR) {\n        // process your message here\n    } elseif ($message-&gt;err === RD_KAFKA_RESP_ERR__PARTITION_EOF) {\n        // handle end of partition\n    } elseif ($message-&gt;err === RD_KAFKA_RESP_ERR__TIMED_OUT) {\n        // handle timeout\n    } else {\n        // handle other errors\n        $topic-&gt;consumeStop(0);\n        $topic-&gt;consumeStop(1);\n        $topic-&gt;consumeStop(2);\n        throw new \\Exception($message-&gt;errstr(), $message-&gt;err);\n    }\n\n    // trigger callback queues\n    $consumer-&gt;poll(1);\n} while (true);\n</code></pre>"},{"location":"usage/consumer-low-level/#finish-the-consumption","title":"Finish the Consumption","text":"<pre><code>$topic-&gt;consumeStop(0);\n$topic-&gt;consumeStop(1);\n$topic-&gt;consumeStop(2);\n</code></pre>"},{"location":"usage/consumer-low-level/#run-example","title":"Run Example","text":"<p>If you want to test consuming messages with the high level consumer, you can take a look at the low level consumer example. Please take a look at how to prepare running the examples before.</p> <p>Produce to the same topic that we created using the following command:</p> <pre><code>docker-compose run --rm php74 php examples/producer.php\n</code></pre> <p>Consume the messages produced to the same topic using the following command:</p> <pre><code>docker-compose run --rm php74 php examples/consumer-lowlevel.php\n</code></pre> <p>And you should see all messages consumed from topic <code>playground</code>.</p>"},{"location":"usage/examples/","title":"Examples","text":""},{"location":"usage/examples/#prepare","title":"Prepare","text":"<p>Startup php &amp; kafka</p> <pre><code>docker-compose up -d\n</code></pre> <p>Updating dependencies</p> <pre><code>docker-compose run --rm --no-deps php74 composer update\n</code></pre> <p>Init <code>playground</code> topic used by Examples</p> <pre><code>docker-compose run --rm php74 composer examples-init\n</code></pre> <p>Tip</p> <p>You may use tools like Conduktor to take a look at produced messages, broker &amp; topic configurations.</p>"},{"location":"usage/examples/#run-examples","title":"Run Examples","text":"<p>Producing \u2026</p> <pre><code>docker-compose run --rm php74 php examples/producer.php\n</code></pre> <p>Consuming (with low level consumer) \u2026</p> <pre><code>docker-compose run --rm php74 php examples/consumer-lowlevel.php\n</code></pre> <p>Consuming (with high level consumer) \u2026</p> <pre><code>docker-compose run --rm -T php74 php examples/consumer-highlevel.php\n</code></pre> <p>Broker metadata \u2026</p> <pre><code>docker-compose run --rm php74 php examples/metadata.php\n</code></pre> <p>Describe config values for a topic \u2026</p> <pre><code>docker-compose run --rm php74 php examples/describe-config.php\ndocker-compose run --rm php74 php examples/describe-config.php -t2 -vtest\n</code></pre> <p>Describe config values for a broker \u2026</p> <pre><code>docker-compose run --rm php74 php examples/describe-config.php -t4 -v111\n</code></pre> <p>Test preload (shows current librdkafka version &amp; opcache status)</p> <pre><code>docker-compose run --rm php80 php \\\n    -dffi.enable=preload \\\n    -dzend_extension=opcache \\\n    -dopcache.enable=true \\\n    -dopcache.enable_cli=true \\\n    -dopcache.preload_user=phpdev \\\n    -dopcache.preload=/app/examples/preload.php \\\n    examples/test-preload.php\n</code></pre> <p>Test preload with jit (shows current librdkafka version &amp; opcache status)</p> <pre><code>docker-compose run --rm php80 php \\\n    -dffi.enable=preload \\\n    -dzend_extension=opcache \\\n    -dopcache.enable=true \\\n    -dopcache.enable_cli=true \\\n    -dopcache.preload_user=phpdev \\\n    -dopcache.preload=/app/examples/preload.php \\\n    -dopcache.jit_buffer_size=100M \\\n    -dopcache.jit=function \\\n    examples/test-preload.php\n</code></pre> <p>Experimental! Test mock cluster (producing and consuming) - requires librdkafka ^1.3.0</p> <pre><code> docker-compose run --rm php74 php examples/mock-cluster.php\n</code></pre> <p>Experimental! Read consumer offset lags</p> <pre><code> docker-compose run --rm php74 php examples/offset-lags.php\n</code></pre> <p>Delete topic <code>playground</code> \u2026</p> <pre><code>docker-compose run --rm php74 php examples/delete-topic.php -tplayground\n</code></pre> <p>Create topic <code>playground</code> \u2026</p> <pre><code>docker-compose run --rm php74 php examples/create-topic.php -tplayground -p3 -r1\n</code></pre>"},{"location":"usage/library-version-handling/","title":"Library Version Handling","text":"<p>There are 2 versions:</p> <ul> <li>the version of librdkafka</li> <li>the version of the librdkafka binding</li> </ul> <p>The librdkafka version and the matching binding version is auto-detected by default. </p>"},{"location":"usage/library-version-handling/#get-version","title":"Get version","text":"<p>Get the version of librdkafka</p> <pre><code>echo \\RdKafka\\FFI\\Library::rd_kafka_version();\n</code></pre> <p>Get the version of the librdkafka binding</p> <pre><code>echo RdKafka\\FFI\\Library::getLibraryVersion();\n</code></pre>"},{"location":"usage/library-version-handling/#set-binding-version-manually","title":"Set binding version manually","text":"<p>In some situations it may be required to initialize the binding version manually.</p> <pre><code>use RdKafka\\FFI\\Library;\n\nrequire_once dirname(__DIR__) . '/vendor/autoload.php';\n\n$version = getenv('LIBRDKAFKA_VERSION') ?: Library::VERSION_AUTODETECT;\nLibrary::init($version);\n</code></pre> <p>Tip</p> <p>The binding will (usually) fail if you choose a higher version than the actual librdkafka version.</p>"},{"location":"usage/license/","title":"License","text":"<p>Apache License Version 2.0, January 2004 http://www.apache.org/licenses/</p> <p>TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION</p> <ol> <li>Definitions.</li> </ol> <p>\u201cLicense\u201d shall mean the terms and conditions for use, reproduction, and distribution as defined by Sections 1 through 9 of this document.</p> <p>\u201cLicensor\u201d shall mean the copyright owner or entity authorized by the copyright owner that is granting the License.</p> <p>\u201cLegal Entity\u201d shall mean the union of the acting entity and all other entities that control, are controlled by, or are under common control with that entity. For the purposes of this definition, \u201ccontrol\u201d means (i) the power, direct or indirect, to cause the direction or management of such entity, whether by contract or otherwise, or (ii) ownership of fifty percent (50%) or more of the outstanding shares, or (iii) beneficial ownership of such entity.</p> <p>\u201cYou\u201d (or \u201cYour\u201d) shall mean an individual or Legal Entity exercising permissions granted by this License.</p> <p>\u201cSource\u201d form shall mean the preferred form for making modifications, including but not limited to software source code, documentation source, and configuration files.</p> <p>\u201cObject\u201d form shall mean any form resulting from mechanical transformation or translation of a Source form, including but not limited to compiled object code, generated documentation, and conversions to other media types.</p> <p>\u201cWork\u201d shall mean the work of authorship, whether in Source or Object form, made available under the License, as indicated by a copyright notice that is included in or attached to the work (an example is provided in the Appendix below).</p> <p>\u201cDerivative Works\u201d shall mean any work, whether in Source or Object form, that is based on (or derived from) the Work and for which the editorial revisions, annotations, elaborations, or other modifications represent, as a whole, an original work of authorship. For the purposes of this License, Derivative Works shall not include works that remain separable from, or merely link (or bind by name) to the interfaces of, the Work and Derivative Works thereof.</p> <p>\u201cContribution\u201d shall mean any work of authorship, including the original version of the Work and any modifications or additions to that Work or Derivative Works thereof, that is intentionally submitted to Licensor for inclusion in the Work by the copyright owner or by an individual or Legal Entity authorized to submit on behalf of the copyright owner. For the purposes of this definition, \u201csubmitted\u201d means any form of electronic, verbal, or written communication sent to the Licensor or its representatives, including but not limited to communication on electronic mailing lists, source code control systems, and issue tracking systems that are managed by, or on behalf of, the Licensor for the purpose of discussing and improving the Work, but excluding communication that is conspicuously marked or otherwise designated in writing by the copyright owner as \u201cNot a Contribution.\u201d</p> <p>\u201cContributor\u201d shall mean Licensor and any individual or Legal Entity on behalf of whom a Contribution has been received by Licensor and subsequently incorporated within the Work.</p> <ol> <li> <p>Grant of Copyright License. Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable copyright license to reproduce, prepare Derivative Works of, publicly display, publicly perform, sublicense, and distribute the Work and such Derivative Works in Source or Object form.</p> </li> <li> <p>Grant of Patent License. Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable (except as stated in this section) patent license to make, have made, use, offer to sell, sell, import, and otherwise transfer the Work, where such license applies only to those patent claims licensable by such Contributor that are necessarily infringed by their Contribution(s) alone or by combination of their Contribution(s) with the Work to which such Contribution(s) was submitted. If You institute patent litigation against any entity (including a cross-claim or counterclaim in a lawsuit) alleging that the Work or a Contribution incorporated within the Work constitutes direct or contributory patent infringement, then any patent licenses granted to You under this License for that Work shall terminate as of the date such litigation is filed.</p> </li> <li> <p>Redistribution. You may reproduce and distribute copies of the Work or Derivative Works thereof in any medium, with or without modifications, and in Source or Object form, provided that You meet the following conditions:</p> </li> </ol> <p>(a) You must give any other recipients of the Work or Derivative Works a copy of this License; and</p> <p>(b) You must cause any modified files to carry prominent notices stating that You changed the files; and</p> <p>\u00a9 You must retain, in the Source form of any Derivative Works that You distribute, all copyright, patent, trademark, and attribution notices from the Source form of the Work, excluding those notices that do not pertain to any part of the Derivative Works; and</p> <p>(d) If the Work includes a \u201cNOTICE\u201d text file as part of its distribution, then any Derivative Works that You distribute must include a readable copy of the attribution notices contained within such NOTICE file, excluding those notices that do not pertain to any part of the Derivative Works, in at least one of the following places: within a NOTICE text file distributed as part of the Derivative Works; within the Source form or documentation, if provided along with the Derivative Works; or, within a display generated by the Derivative Works, if and wherever such third-party notices normally appear. The contents of the NOTICE file are for informational purposes only and do not modify the License. You may add Your own attribution notices within Derivative Works that You distribute, alongside or as an addendum to the NOTICE text from the Work, provided that such additional attribution notices cannot be construed as modifying the License.</p> <p>You may add Your own copyright statement to Your modifications and may provide additional or different license terms and conditions for use, reproduction, or distribution of Your modifications, or for any such Derivative Works as a whole, provided Your use, reproduction, and distribution of the Work otherwise complies with the conditions stated in this License.</p> <ol> <li> <p>Submission of Contributions. Unless You explicitly state otherwise, any Contribution intentionally submitted for inclusion in the Work by You to the Licensor shall be under the terms and conditions of this License, without any additional terms or conditions. Notwithstanding the above, nothing herein shall supersede or modify the terms of any separate license agreement you may have executed with Licensor regarding such Contributions.</p> </li> <li> <p>Trademarks. This License does not grant permission to use the trade names, trademarks, service marks, or product names of the Licensor, except as required for reasonable and customary use in describing the origin of the Work and reproducing the content of the NOTICE file.</p> </li> <li> <p>Disclaimer of Warranty. Unless required by applicable law or agreed to in writing, Licensor provides the Work (and each Contributor provides its Contributions) on an \u201cAS IS\u201d BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied, including, without limitation, any warranties or conditions of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A PARTICULAR PURPOSE. You are solely responsible for determining the appropriateness of using or redistributing the Work and assume any risks associated with Your exercise of permissions under this License.</p> </li> <li> <p>Limitation of Liability. In no event and under no legal theory, whether in tort (including negligence), contract, or otherwise, unless required by applicable law (such as deliberate and grossly negligent acts) or agreed to in writing, shall any Contributor be liable to You for damages, including any direct, indirect, special, incidental, or consequential damages of any character arising as a result of this License or out of the use or inability to use the Work (including but not limited to damages for loss of goodwill, work stoppage, computer failure or malfunction, or any and all other commercial damages or losses), even if such Contributor has been advised of the possibility of such damages.</p> </li> <li> <p>Accepting Warranty or Additional Liability. While redistributing the Work or Derivative Works thereof, You may choose to offer, and charge a fee for, acceptance of support, warranty, indemnity, or other liability obligations and/or rights consistent with this License. However, in accepting such obligations, You may act only on Your own behalf and on Your sole responsibility, not on behalf of any other Contributor, and only if You agree to indemnify, defend, and hold each Contributor harmless for any liability incurred by, or claims asserted against, such Contributor by reason of your accepting any such warranty or additional liability.</p> </li> </ol> <p>END OF TERMS AND CONDITIONS</p> <p>Copyright 2019 idealo internet GmbH</p> <p>Licensed under the Apache License, Version 2.0 (the \u201cLicense\u201d); you may not use this file except in compliance with the License. You may obtain a copy of the License at</p> <p>http://www.apache.org/licenses/LICENSE-2.0</p> <p>Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \u201cAS IS\u201d BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.</p>"},{"location":"usage/mock-cluster/","title":"Mock Cluster","text":"<p>Experimental</p> <p>API can have breaking changes in next releases and does not follow semantic versioning.</p> <p>Tip</p> <p>Basic support is available since librdkafka 1.3. However it is recommended to use version 1.4 or higher to have better support for simulating error situations. </p> <p>Mock Cluster provides a simple and easy way for integration testing without the need to setup a real test kafka cluster e.g. via docker-compose.</p>"},{"location":"usage/mock-cluster/#create-cluster-configuration","title":"Create cluster configuration","text":"<p>Configuration for the mock cluster is optional. You may disable logging output like this:</p> <pre><code>$clusterConf = new \\RdKafka\\Conf();\n$clusterConf-&gt;setLogCb(null);\n</code></pre>"},{"location":"usage/mock-cluster/#create-mock-cluster","title":"Create mock cluster","text":"<p>E.g. create 3 brokers with consecutive broker ids (1,2,3)</p> <pre><code>$numberOfBrokers = 3;\n$cluster = \\RdKafka\\Test\\MockCluster::create($numberOfBrokers, $clusterConf);\n</code></pre>"},{"location":"usage/mock-cluster/#produce-and-consume-messages","title":"Produce and Consume Messages","text":"<p>E.g. produce message on partition 0</p> <pre><code>$producerConf = new \\RdKafka\\Conf();\n$producerConf-&gt;set('metadata.broker.list', $cluster-&gt;getBootstraps());\n$producer = new \\RdKafka\\Producer($producerConf);\n$topic = $producer-&gt;newTopic('playground');\n$topic-&gt;produce(0, 0, 'any-payload');\n$producer-&gt;flush(1000);\n</code></pre> <p>E.g. consume message on partition 0</p> <pre><code>$consumerConf = new \\RdKafka\\Conf();\n$consumerConf-&gt;set('group.id', 'mock-cluster-example');\n$consumerConf-&gt;set('metadata.broker.list', $cluster-&gt;getBootstraps());\n$consumer = new \\RdKafka\\KafkaConsumer($consumerConf);\n$consumer-&gt;assign([new \\RdKafka\\TopicPartition('playground', 0, rd_kafka_offset_tail(1))]);\n$message = $consumer-&gt;consume(1000)\n</code></pre>"},{"location":"usage/mock-cluster/#create-a-specific-test-topic","title":"Create a specific test topic","text":"<p>Note</p> <p>Admin protocol request types like creating or deleting a topic are not supported by the mock cluster.</p> <p>E.g. create a topic with 3 partitions and replication factor 1</p> <pre><code>$numberOfBrokers = 3;\n$cluster = \\RdKafka\\Test\\MockCluster::create($numberOfBrokers);\n\n$cluster-&gt;createTopic('payload', 3, 1);\n</code></pre>"},{"location":"usage/mock-cluster/#set-broker-up-or-down","title":"Set broker up or down","text":"<pre><code>$numberOfBrokers = 2;\n$cluster = \\RdKafka\\Test\\MockCluster::create($numberOfBrokers);\n\n// set broker with id 1 down\n$cluster-&gt;setBrokerDown(1);\n\n// set broker with id 1 up again\n$cluster-&gt;setBrokerUp(1);\n</code></pre>"},{"location":"usage/mock-cluster/#set-broker-as-topic-partition-leader-or-follower","title":"Set broker as topic partition leader or follower","text":"<pre><code>$numberOfBrokers = 2;\n$cluster = \\RdKafka\\Test\\MockCluster::create($numberOfBrokers);\n$cluster-&gt;createTopic('payload', 3, 1);\n\n// set broker with id 1 as leader for topic payload partition 0\n$cluster-&gt;setPartitionLeader('payload', 0, 1);\n\n// set broker with id 2 as follower for topic payload partition 0\n$cluster-&gt;setPartitionFollower('payload', 0, 2);\n</code></pre>"},{"location":"usage/mock-cluster/#set-coordinator-for-transactions","title":"Set coordinator for transactions","text":"<p>tbd.</p>"},{"location":"usage/mock-cluster/#prepare-error-situations","title":"Prepare error situations","text":"<p>tbd.</p>"},{"location":"usage/mock-cluster/#run-example","title":"Run example","text":"<p>You can take a look at the mock cluster example for an actual implementation of the mocked cluster. Please take a look at how to prepare running the examples before.</p> <p>Run the example:</p> <pre><code>docker-compose run --rm php74 php examples/mock-cluster.php\n</code></pre>"},{"location":"usage/preloading/","title":"Use preloading","text":"<p>Preloading helps to reduce the overhead of parsing C declarations and frequently used php files per request.</p> <p>Note</p> <p>Requires activated opcache.</p>"},{"location":"usage/preloading/#example-preloadphp","title":"Example preload.php","text":"<pre><code>&lt;?php\n\ndeclare(strict_types=1);\n\nuse RdKafka\\FFI\\Library;\n\nrequire_once dirname(__DIR__) . '/vendor/autoload.php';\n\n$files = new RegexIterator(\n    new RecursiveIteratorIterator(\n        new RecursiveDirectoryIterator(\n            dirname(__DIR__) . '/src'\n        )\n    ),\n    '/^.+\\/[A-Z][^\\/]+?\\.php$/'\n);\n\nforeach ($files as $file) {\n    if (! $file-&gt;isFile()) {\n        continue;\n    }\n    require_once($file-&gt;getPathName());\n}\n\nLibrary::preload();\n</code></pre>"},{"location":"usage/preloading/#configure-phpini","title":"Configure php.ini","text":"<pre><code># force preload mode\nffi.enable = preload\n# enable opcache extension\nzend_extension = opcache\n# enable opcache\nopcache.enable = true\n# enable opcache on cli\nopcache.enable_cli = true\n# change to correct user\nopcache.preload_user = wwwdata\n# absolute path to preload.php\nopcache.preload = /path/to/preload.php\n</code></pre>"},{"location":"usage/preloading/#see-also","title":"See also","text":"<ul> <li>opcache.preload</li> <li>FFI preloading example</li> </ul>"},{"location":"usage/producer/","title":"Create a Producer","text":""},{"location":"usage/producer/#configure-the-producer","title":"Configure the producer","text":"<pre><code>$conf = new \\RdKafka\\Conf();\n$conf-&gt;set('bootstrap.servers', 'kafka:9092');\n$conf-&gt;set('socket.timeout.ms', (string) 50);\n$conf-&gt;set('queue.buffering.max.messages', (string) 1000);\n$conf-&gt;set('max.in.flight.requests.per.connection', (string) 1);\n$conf-&gt;setDrMsgCb(\n    function (\\RdKafka\\Producer $producer, \\RdKafka\\Message $message): void {\n        if ($message-&gt;err !== RD_KAFKA_RESP_ERR_NO_ERROR) {\n            // Perform your error handling here using $message-&gt;errstr()\n        }\n    }\n);\n$conf-&gt;set('log_level', (string) LOG_DEBUG);\n$conf-&gt;set('debug', 'all');\n$conf-&gt;setLogCb(\n    function (\\RdKafka\\Producer $producer, int $level, string $facility, string $message): void {\n        // Perform your logging mechanism here\n    }\n);\n$conf-&gt;set('statistics.interval.ms', (string) 1000);\n$conf-&gt;setStatsCb(\n    function (\\RdKafka\\Producer $producer, string $json, int $json_len, $opaque): void {\n        // Perform your stats mechanism here ...\n    }\n);\n</code></pre> <p>See configuration for more details.</p>"},{"location":"usage/producer/#configure-the-topic","title":"Configure the topic","text":"<pre><code>$topicConf = new \\RdKafka\\TopicConf();\n$topicConf-&gt;set('message.timeout.ms', (string) 30000);\n$topicConf-&gt;set('request.required.acks', (string) -1);\n$topicConf-&gt;set('request.timeout.ms', (string) 5000);\n</code></pre>"},{"location":"usage/producer/#create-the-producer","title":"Create the producer","text":"<pre><code>$producer = new \\RdKafka\\Producer($conf);\n</code></pre>"},{"location":"usage/producer/#create-a-new-topic","title":"Create a new topic","text":"<pre><code>$topic = $producer-&gt;newTopic('playground', $topicConf);\n</code></pre>"},{"location":"usage/producer/#produce-messages","title":"Produce Messages","text":"<pre><code>for ($i = 0; $i &lt; 1000; $i++) {\n    $key = $i % 10;\n    $payload = sprintf('payload-%d-%s', $i, $key);\n    $topic-&gt;produce(RD_KAFKA_PARTITION_UA, 0, $payload, (string) $key);\n\n    // trigger callback queues\n    $producer-&gt;poll(1);\n}\n\n$producer-&gt;flush(5000);\n</code></pre> <p>Warning</p> <p>Always call <code>flush</code> after producing messages to not lose messages on shutdown that are still queued up within librdkafka memory and not yet delivered to a broker.</p>"},{"location":"usage/producer/#flush-on-shutdown","title":"Flush on shutdown","text":"<p>Best practise is to wrap the producer instance and call flush on destruction.</p> <pre><code>class ExampleApp {\n    private \\RdKafka\\Producer $producer;\n\n    function __construct(\\RdKafka\\Conf $conf) {\n        $this-&gt;producer = new \\RdKafka\\Producer($conf);\n    }\n\n    function __destruct() {\n        $err = $this-&gt;producer-&gt;flush(10000);\n        if ($err === RD_KAFKA_RESP_ERR__TIMED_OUT) {\n            throw new \\RuntimeException('Failed to flush producer. Messages might not have been delivered.');\n        }\n    }\n}\n</code></pre> <p>Hint</p> <p>Call <code>flush(-1)</code> to wait indefinitely until all messages are flushed.</p>"},{"location":"usage/producer/#run-example","title":"Run example","text":"<p>If you want to test producing messages, you can take a look at the producer example. Please take a look at how to prepare running the examples before.</p> <p>Run the example:</p> <pre><code>docker-compose run --rm php74 php examples/producer.php\n</code></pre> <p>And now you have produced messages to the topic <code>playground</code>.</p>"},{"location":"usage/topic-configuration/","title":"Topic Configuration","text":"<p>Note</p> <p>See librdkafka CONFIGURATION for topic specific parameters</p>"},{"location":"usage/topic-configuration/#set-partitioner","title":"Set Partitioner","text":"<p>Tip</p> <p>Default partitioner for librdkafka is <code>consistent_random</code> while for Java based tools like Kafka MirrorMaker 2 or Kafka Rest Api Proxy it is <code>murmur2_random</code>.</p> <pre><code>$topicConf = new \\RdKafka\\TopicConf();\n$topicConf-&gt;setPartitioner(RD_KAFKA_MSG_PARTITIONER_MURMUR2_RANDOM);\n</code></pre>"},{"location":"usage/topic-configuration/#use-a-custom-partitioner","title":"Use a custom Partitioner","text":"<pre><code>$topicConf = new \\RdKafka\\TopicConf();\n$topicConf-&gt;setPartitionerCb(\n    function (string $key, int $partitionCount):int {\n        // e.g. force partition 2\n        return 2;\n    }\n);\n</code></pre>"},{"location":"usage/transactional-producer/","title":"Create a Transactional Producer","text":"<p>tbd.</p>"}]}