
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
        <meta name="author" content="Dirk Adler">
      
      
      
        <link rel="prev" href="../RdKafka/">
      
      
        <link rel="next" href="../functions/">
      
      
      <link rel="icon" href="../../img/php-rdkafka.svg">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.5.50">
    
    
      
        <title>Constants - PHP Kafka Client</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/main.a40c8224.min.css">
      
        
        <link rel="stylesheet" href="../../assets/stylesheets/palette.06af60db.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
    <script>__md_scope=new URL("../..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    
    
      
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="white" data-md-color-accent="indigo">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#constants" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

<header class="md-header" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="../.." title="PHP Kafka Client" class="md-header__button md-logo" aria-label="PHP Kafka Client" data-md-component="logo">
      
  <img src="../../img/php-rdkafka.svg" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            PHP Kafka Client
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Constants
            
          </span>
        </div>
      </div>
    </div>
    
      
        <form class="md-header__option" data-md-component="palette">
  
    
    
    
    <input class="md-option" data-md-color-media="" data-md-color-scheme="default" data-md-color-primary="white" data-md-color-accent="indigo"  aria-label="Switch to dark mode"  type="radio" name="__palette" id="__palette_0">
    
      <label class="md-header__button md-icon" title="Switch to dark mode" for="__palette_1" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M17 6H7c-3.31 0-6 2.69-6 6s2.69 6 6 6h10c3.31 0 6-2.69 6-6s-2.69-6-6-6m0 10H7c-2.21 0-4-1.79-4-4s1.79-4 4-4h10c2.21 0 4 1.79 4 4s-1.79 4-4 4M7 9c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3"/></svg>
      </label>
    
  
    
    
    
    <input class="md-option" data-md-color-media="" data-md-color-scheme="slate" data-md-color-primary="black" data-md-color-accent="indigo"  aria-label="Switch to light mode"  type="radio" name="__palette" id="__palette_1">
    
      <label class="md-header__button md-icon" title="Switch to light mode" for="__palette_0" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M17 7H7a5 5 0 0 0-5 5 5 5 0 0 0 5 5h10a5 5 0 0 0 5-5 5 5 0 0 0-5-5m0 8a3 3 0 0 1-3-3 3 3 0 0 1 3-3 3 3 0 0 1 3 3 3 3 0 0 1-3 3"/></svg>
      </label>
    
  
</form>
      
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
      <div class="md-header__source">
        <a href="https://github.com/idealo/php-rdkafka-ffi" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81"/></svg>
  </div>
  <div class="md-source__repository">
    idealo/php-rdkafka-ffi
  </div>
</a>
      </div>
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
            
<nav class="md-tabs" aria-label="Tabs" data-md-component="tabs">
  <div class="md-grid">
    <ul class="md-tabs__list">
      
        
  
  
  
    <li class="md-tabs__item">
      <a href="../.." class="md-tabs__link">
        
  
    
  
  Getting Started

      </a>
    </li>
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../usage/about-ffi-and-librdkafka/" class="md-tabs__link">
          
  
    
  
  Usage

        </a>
      </li>
    
  

      
        
  
  
    
  
  
    
    
      <li class="md-tabs__item md-tabs__item--active">
        <a href="../" class="md-tabs__link">
          
  
    
  
  Api

        </a>
      </li>
    
  

      
        
  
  
  
    <li class="md-tabs__item">
      <a href="../../benchmarks/" class="md-tabs__link">
        
  
    
  
  Benchmarks

      </a>
    </li>
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../contributing/" class="md-tabs__link">
          
  
    
  
  Contributing

        </a>
      </li>
    
  

      
    </ul>
  </div>
</nav>
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


  


<nav class="md-nav md-nav--primary md-nav--lifted" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../.." title="PHP Kafka Client" class="md-nav__button md-logo" aria-label="PHP Kafka Client" data-md-component="logo">
      
  <img src="../../img/php-rdkafka.svg" alt="logo">

    </a>
    PHP Kafka Client
  </label>
  
    <div class="md-nav__source">
      <a href="https://github.com/idealo/php-rdkafka-ffi" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81"/></svg>
  </div>
  <div class="md-source__repository">
    idealo/php-rdkafka-ffi
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../.." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Getting Started
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2" >
        
          
          <label class="md-nav__link" for="__nav_2" id="__nav_2_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Usage
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2">
            <span class="md-nav__icon md-icon"></span>
            Usage
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../usage/about-ffi-and-librdkafka/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    About FFI and librdkafka
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../usage/producer/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Create a Producer
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../usage/transactional-producer/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Create a Transactional Producer
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../usage/consumer-high-level/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Create a High Level Consumer
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../usage/consumer-low-level/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Create a Low Level Consumer
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../usage/configuration/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Configuration
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../usage/topic-configuration/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Topic Configuration
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../usage/mock-cluster/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Mock Cluster
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../usage/admin-client/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Admin Client
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../usage/preloading/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Use preloading
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../usage/library-version-handling/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Library Version Handling
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../usage/examples/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Examples
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../usage/changelog/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Changelog
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../usage/license/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    License
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../usage/alternatives/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Alternatives
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
    
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
        
      
    
    
      
        
        
      
      
    
    
    <li class="md-nav__item md-nav__item--active md-nav__item--section md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3" checked>
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    Api
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_3" id="__nav_3_label" tabindex="">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_3_label" aria-expanded="true">
          <label class="md-nav__title" for="__nav_3">
            <span class="md-nav__icon md-icon"></span>
            Api
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../RdKafka/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    RdKafka
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
    
  
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          
  
  <span class="md-ellipsis">
    Constants
  </span>
  

          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        
  
  <span class="md-ellipsis">
    Constants
  </span>
  

      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_log_print" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_LOG_PRINT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_log_syslog" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_LOG_SYSLOG
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_log_syslog_print" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_LOG_SYSLOG_PRINT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_msg_partitioner_random" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_MSG_PARTITIONER_RANDOM
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_msg_partitioner_consistent" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_MSG_PARTITIONER_CONSISTENT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_msg_partitioner_consistent_random" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_MSG_PARTITIONER_CONSISTENT_RANDOM
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_msg_partitioner_murmur2" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_MSG_PARTITIONER_MURMUR2
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_msg_partitioner_murmur2_random" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_MSG_PARTITIONER_MURMUR2_RANDOM
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_msg_partitioner_fnv1a" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_MSG_PARTITIONER_FNV1A
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_msg_partitioner_fnv1a_random" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_MSG_PARTITIONER_FNV1A_RANDOM
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_destroy_f_no_consumer_close" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_DESTROY_F_NO_CONSUMER_CLOSE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_partition_ua" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_PARTITION_UA
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_offset_beginning" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_OFFSET_BEGINNING
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_offset_end" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_OFFSET_END
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_offset_stored" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_OFFSET_STORED
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_offset_invalid" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_OFFSET_INVALID
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_offset_tail_base" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_OFFSET_TAIL_BASE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_msg_f_free" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_MSG_F_FREE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_msg_f_copy" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_MSG_F_COPY
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_msg_f_block" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_MSG_F_BLOCK
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_msg_f_partition" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_MSG_F_PARTITION
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_purge_f_queue" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_PURGE_F_QUEUE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_purge_f_inflight" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_PURGE_F_INFLIGHT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_purge_f_non_blocking" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_PURGE_F_NON_BLOCKING
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_event_none" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_EVENT_NONE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_event_dr" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_EVENT_DR
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_event_fetch" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_EVENT_FETCH
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_event_log" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_EVENT_LOG
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_event_error" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_EVENT_ERROR
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_event_rebalance" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_EVENT_REBALANCE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_event_offset_commit" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_EVENT_OFFSET_COMMIT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_event_stats" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_EVENT_STATS
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_event_createtopics_result" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_EVENT_CREATETOPICS_RESULT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_event_deletetopics_result" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_EVENT_DELETETOPICS_RESULT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_event_createpartitions_result" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_EVENT_CREATEPARTITIONS_RESULT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_event_alterconfigs_result" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_EVENT_ALTERCONFIGS_RESULT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_event_describeconfigs_result" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_EVENT_DESCRIBECONFIGS_RESULT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_producer" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_PRODUCER
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_consumer" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_CONSUMER
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_timestamp_not_available" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_TIMESTAMP_NOT_AVAILABLE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_timestamp_create_time" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_TIMESTAMP_CREATE_TIME
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_timestamp_log_append_time" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_TIMESTAMP_LOG_APPEND_TIME
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__begin" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR__BEGIN
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__bad_msg" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR__BAD_MSG
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__bad_compression" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR__BAD_COMPRESSION
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__destroy" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR__DESTROY
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__fail" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR__FAIL
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__transport" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR__TRANSPORT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__crit_sys_resource" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR__CRIT_SYS_RESOURCE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__resolve" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR__RESOLVE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__msg_timed_out" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR__MSG_TIMED_OUT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__partition_eof" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR__PARTITION_EOF
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__unknown_partition" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__fs" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR__FS
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__unknown_topic" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__all_brokers_down" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR__ALL_BROKERS_DOWN
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__invalid_arg" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR__INVALID_ARG
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__timed_out" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR__TIMED_OUT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__queue_full" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR__QUEUE_FULL
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__isr_insuff" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR__ISR_INSUFF
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__node_update" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR__NODE_UPDATE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__ssl" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR__SSL
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__wait_coord" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR__WAIT_COORD
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__unknown_group" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR__UNKNOWN_GROUP
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__in_progress" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR__IN_PROGRESS
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__prev_in_progress" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR__PREV_IN_PROGRESS
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__existing_subscription" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR__EXISTING_SUBSCRIPTION
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__assign_partitions" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__revoke_partitions" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__conflict" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR__CONFLICT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__state" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR__STATE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__unknown_protocol" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR__UNKNOWN_PROTOCOL
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__not_implemented" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__authentication" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR__AUTHENTICATION
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__no_offset" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR__NO_OFFSET
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__outdated" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR__OUTDATED
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__timed_out_queue" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR__TIMED_OUT_QUEUE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__unsupported_feature" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR__UNSUPPORTED_FEATURE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__wait_cache" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR__WAIT_CACHE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__intr" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR__INTR
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__key_serialization" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR__KEY_SERIALIZATION
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__value_serialization" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR__VALUE_SERIALIZATION
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__key_deserialization" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR__KEY_DESERIALIZATION
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__value_deserialization" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR__VALUE_DESERIALIZATION
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__partial" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR__PARTIAL
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__read_only" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR__READ_ONLY
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__noent" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR__NOENT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__underflow" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR__UNDERFLOW
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__invalid_type" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR__INVALID_TYPE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__retry" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR__RETRY
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__purge_queue" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR__PURGE_QUEUE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__purge_inflight" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR__PURGE_INFLIGHT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__fatal" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR__FATAL
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__inconsistent" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR__INCONSISTENT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__gapless_guarantee" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR__GAPLESS_GUARANTEE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__max_poll_exceeded" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR__MAX_POLL_EXCEEDED
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__end" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR__END
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_unknown" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_UNKNOWN
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_no_error" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_NO_ERROR
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_offset_out_of_range" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_OFFSET_OUT_OF_RANGE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_invalid_msg" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_INVALID_MSG
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_unknown_topic_or_part" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_invalid_msg_size" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_INVALID_MSG_SIZE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_leader_not_available" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_not_leader_for_partition" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_NOT_LEADER_FOR_PARTITION
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_request_timed_out" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_REQUEST_TIMED_OUT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_broker_not_available" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_BROKER_NOT_AVAILABLE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_replica_not_available" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_REPLICA_NOT_AVAILABLE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_msg_size_too_large" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_stale_ctrl_epoch" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_STALE_CTRL_EPOCH
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_offset_metadata_too_large" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_OFFSET_METADATA_TOO_LARGE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_network_exception" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_NETWORK_EXCEPTION
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_group_load_in_progress" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_GROUP_LOAD_IN_PROGRESS
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_group_coordinator_not_available" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_GROUP_COORDINATOR_NOT_AVAILABLE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_not_coordinator_for_group" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_NOT_COORDINATOR_FOR_GROUP
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_topic_exception" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_TOPIC_EXCEPTION
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_record_list_too_large" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_RECORD_LIST_TOO_LARGE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_not_enough_replicas" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_not_enough_replicas_after_append" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS_AFTER_APPEND
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_invalid_required_acks" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_INVALID_REQUIRED_ACKS
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_illegal_generation" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_ILLEGAL_GENERATION
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_inconsistent_group_protocol" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_INCONSISTENT_GROUP_PROTOCOL
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_invalid_group_id" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_INVALID_GROUP_ID
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_unknown_member_id" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_UNKNOWN_MEMBER_ID
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_invalid_session_timeout" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_INVALID_SESSION_TIMEOUT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_rebalance_in_progress" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_REBALANCE_IN_PROGRESS
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_invalid_commit_offset_size" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_INVALID_COMMIT_OFFSET_SIZE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_topic_authorization_failed" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_TOPIC_AUTHORIZATION_FAILED
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_group_authorization_failed" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_GROUP_AUTHORIZATION_FAILED
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_cluster_authorization_failed" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_CLUSTER_AUTHORIZATION_FAILED
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_invalid_timestamp" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_INVALID_TIMESTAMP
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_unsupported_sasl_mechanism" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_UNSUPPORTED_SASL_MECHANISM
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_illegal_sasl_state" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_ILLEGAL_SASL_STATE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_unsupported_version" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_UNSUPPORTED_VERSION
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_topic_already_exists" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_TOPIC_ALREADY_EXISTS
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_invalid_partitions" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_INVALID_PARTITIONS
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_invalid_replication_factor" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_INVALID_REPLICATION_FACTOR
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_invalid_replica_assignment" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_INVALID_REPLICA_ASSIGNMENT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_invalid_config" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_INVALID_CONFIG
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_not_controller" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_NOT_CONTROLLER
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_invalid_request" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_INVALID_REQUEST
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_unsupported_for_message_format" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_UNSUPPORTED_FOR_MESSAGE_FORMAT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_policy_violation" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_POLICY_VIOLATION
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_out_of_order_sequence_number" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_OUT_OF_ORDER_SEQUENCE_NUMBER
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_duplicate_sequence_number" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_DUPLICATE_SEQUENCE_NUMBER
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_invalid_producer_epoch" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_INVALID_PRODUCER_EPOCH
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_invalid_txn_state" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_INVALID_TXN_STATE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_invalid_producer_id_mapping" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_INVALID_PRODUCER_ID_MAPPING
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_invalid_transaction_timeout" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_INVALID_TRANSACTION_TIMEOUT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_concurrent_transactions" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_CONCURRENT_TRANSACTIONS
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_transaction_coordinator_fenced" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_TRANSACTION_COORDINATOR_FENCED
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_transactional_id_authorization_failed" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_TRANSACTIONAL_ID_AUTHORIZATION_FAILED
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_security_disabled" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_SECURITY_DISABLED
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_operation_not_attempted" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_OPERATION_NOT_ATTEMPTED
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_kafka_storage_error" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_KAFKA_STORAGE_ERROR
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_log_dir_not_found" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_LOG_DIR_NOT_FOUND
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_sasl_authentication_failed" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_SASL_AUTHENTICATION_FAILED
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_unknown_producer_id" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_UNKNOWN_PRODUCER_ID
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_reassignment_in_progress" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_REASSIGNMENT_IN_PROGRESS
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_delegation_token_auth_disabled" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTH_DISABLED
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_delegation_token_not_found" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_NOT_FOUND
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_delegation_token_owner_mismatch" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_OWNER_MISMATCH
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_delegation_token_request_not_allowed" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_REQUEST_NOT_ALLOWED
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_delegation_token_authorization_failed" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTHORIZATION_FAILED
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_delegation_token_expired" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_EXPIRED
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_invalid_principal_type" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_INVALID_PRINCIPAL_TYPE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_non_empty_group" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_NON_EMPTY_GROUP
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_group_id_not_found" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_GROUP_ID_NOT_FOUND
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_fetch_session_id_not_found" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_FETCH_SESSION_ID_NOT_FOUND
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_invalid_fetch_session_epoch" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_INVALID_FETCH_SESSION_EPOCH
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_listener_not_found" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_LISTENER_NOT_FOUND
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_topic_deletion_disabled" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_TOPIC_DELETION_DISABLED
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_vtype_end" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_VTYPE_END
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_vtype_topic" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_VTYPE_TOPIC
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_vtype_rkt" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_VTYPE_RKT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_vtype_partition" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_VTYPE_PARTITION
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_vtype_value" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_VTYPE_VALUE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_vtype_key" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_VTYPE_KEY
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_vtype_opaque" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_VTYPE_OPAQUE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_vtype_msgflags" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_VTYPE_MSGFLAGS
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_vtype_timestamp" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_VTYPE_TIMESTAMP
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_vtype_header" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_VTYPE_HEADER
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_vtype_headers" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_VTYPE_HEADERS
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_msg_status_not_persisted" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_MSG_STATUS_NOT_PERSISTED
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_msg_status_possibly_persisted" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_MSG_STATUS_POSSIBLY_PERSISTED
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_msg_status_persisted" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_MSG_STATUS_PERSISTED
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_conf_unknown" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_CONF_UNKNOWN
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_conf_invalid" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_CONF_INVALID
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_conf_ok" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_CONF_OK
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op_any" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ADMIN_OP_ANY
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op_createtopics" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ADMIN_OP_CREATETOPICS
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op_deletetopics" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ADMIN_OP_DELETETOPICS
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op_createpartitions" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ADMIN_OP_CREATEPARTITIONS
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op_alterconfigs" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ADMIN_OP_ALTERCONFIGS
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op_describeconfigs" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ADMIN_OP_DESCRIBECONFIGS
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_config_source_unknown_config" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_CONFIG_SOURCE_UNKNOWN_CONFIG
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_config_source_dynamic_topic_config" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_CONFIG_SOURCE_DYNAMIC_TOPIC_CONFIG
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_config_source_dynamic_broker_config" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_CONFIG_SOURCE_DYNAMIC_BROKER_CONFIG
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_config_source_dynamic_default_broker_config" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_CONFIG_SOURCE_DYNAMIC_DEFAULT_BROKER_CONFIG
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_config_source_static_broker_config" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_CONFIG_SOURCE_STATIC_BROKER_CONFIG
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_config_source_default_config" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_CONFIG_SOURCE_DEFAULT_CONFIG
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_config_source__cnt" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_CONFIG_SOURCE__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resource_unknown" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESOURCE_UNKNOWN
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resource_any" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESOURCE_ANY
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resource_topic" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESOURCE_TOPIC
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resource_group" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESOURCE_GROUP
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resource_broker" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESOURCE_BROKER
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_fenced_leader_epoch" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_FENCED_LEADER_EPOCH
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_unknown_leader_epoch" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_UNKNOWN_LEADER_EPOCH
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_stale_broker_epoch" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_STALE_BROKER_EPOCH
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_offset_not_available" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_OFFSET_NOT_AVAILABLE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_member_id_required" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_MEMBER_ID_REQUIRED
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_preferred_leader_not_available" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_PREFERRED_LEADER_NOT_AVAILABLE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_group_max_size_reached" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_GROUP_MAX_SIZE_REACHED
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_event_oauthbearer_token_refresh" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_EVENT_OAUTHBEARER_TOKEN_REFRESH
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_cert_public_key" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_CERT_PUBLIC_KEY
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_cert_private_key" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_CERT_PRIVATE_KEY
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_cert_ca" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_CERT_CA
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_cert__cnt" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_CERT__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_cert_enc_pkcs12" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_CERT_ENC_PKCS12
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_cert_enc_der" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_CERT_ENC_DER
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_cert_enc_pem" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_CERT_ENC_PEM
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_cert_enc__cnt" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_CERT_ENC__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_thread_main" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_THREAD_MAIN
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_thread_background" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_THREAD_BACKGROUND
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_thread_broker" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_THREAD_BROKER
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__unknown_broker" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR__UNKNOWN_BROKER
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_coordinator_load_in_progress" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_COORDINATOR_LOAD_IN_PROGRESS
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_coordinator_not_available" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_COORDINATOR_NOT_AVAILABLE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_not_coordinator" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_NOT_COORDINATOR
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__not_configured" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR__NOT_CONFIGURED
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__fenced" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR__FENCED
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__application" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR__APPLICATION
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_fenced_instance_id" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_FENCED_INSTANCE_ID
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_eligible_leaders_not_available" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_ELIGIBLE_LEADERS_NOT_AVAILABLE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_election_not_needed" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_ELECTION_NOT_NEEDED
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_no_reassignment_in_progress" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_NO_REASSIGNMENT_IN_PROGRESS
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_group_subscribed_to_topic" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_GROUP_SUBSCRIBED_TO_TOPIC
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_invalid_record" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_INVALID_RECORD
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_unstable_offset_commit" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_UNSTABLE_OFFSET_COMMIT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_event_deleterecords_result" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_EVENT_DELETERECORDS_RESULT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_event_deletegroups_result" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_EVENT_DELETEGROUPS_RESULT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_event_deleteconsumergroupoffsets_result" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_EVENT_DELETECONSUMERGROUPOFFSETS_RESULT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__assignment_lost" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR__ASSIGNMENT_LOST
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__noop" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR__NOOP
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_throttling_quota_exceeded" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_THROTTLING_QUOTA_EXCEEDED
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_producer_fenced" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_PRODUCER_FENCED
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_resource_not_found" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_RESOURCE_NOT_FOUND
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_duplicate_resource" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_DUPLICATE_RESOURCE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_unacceptable_credential" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_UNACCEPTABLE_CREDENTIAL
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_inconsistent_voter_set" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_INCONSISTENT_VOTER_SET
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_invalid_update_version" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_INVALID_UPDATE_VERSION
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_feature_update_failed" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_FEATURE_UPDATE_FAILED
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_principal_deserialization_failure" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_PRINCIPAL_DESERIALIZATION_FAILURE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op_deleterecords" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ADMIN_OP_DELETERECORDS
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op_deletegroups" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ADMIN_OP_DELETEGROUPS
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op_deleteconsumergroupoffsets" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ADMIN_OP_DELETECONSUMERGROUPOFFSETS
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__auto_offset_reset" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR__AUTO_OFFSET_RESET
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_event_background" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_EVENT_BACKGROUND
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_event_createacls_result" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_EVENT_CREATEACLS_RESULT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_event_describeacls_result" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_EVENT_DESCRIBEACLS_RESULT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_event_deleteacls_result" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_EVENT_DELETEACLS_RESULT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op_createacls" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ADMIN_OP_CREATEACLS
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op_describeacls" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ADMIN_OP_DESCRIBEACLS
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op_deleteacls" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ADMIN_OP_DELETEACLS
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resource_pattern_unknown" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESOURCE_PATTERN_UNKNOWN
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resource_pattern_any" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESOURCE_PATTERN_ANY
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resource_pattern_match" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESOURCE_PATTERN_MATCH
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resource_pattern_literal" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESOURCE_PATTERN_LITERAL
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resource_pattern_prefixed" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESOURCE_PATTERN_PREFIXED
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resource_pattern_type__cnt" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESOURCE_PATTERN_TYPE__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_acl_operation_unknown" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ACL_OPERATION_UNKNOWN
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_acl_operation_any" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ACL_OPERATION_ANY
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_acl_operation_all" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ACL_OPERATION_ALL
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_acl_operation_read" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ACL_OPERATION_READ
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_acl_operation_write" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ACL_OPERATION_WRITE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_acl_operation_create" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ACL_OPERATION_CREATE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_acl_operation_delete" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ACL_OPERATION_DELETE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_acl_operation_alter" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ACL_OPERATION_ALTER
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_acl_operation_describe" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ACL_OPERATION_DESCRIBE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_acl_operation_cluster_action" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ACL_OPERATION_CLUSTER_ACTION
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_acl_operation_describe_configs" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ACL_OPERATION_DESCRIBE_CONFIGS
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_acl_operation_alter_configs" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ACL_OPERATION_ALTER_CONFIGS
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_acl_operation_idempotent_write" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ACL_OPERATION_IDEMPOTENT_WRITE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_acl_operation__cnt" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ACL_OPERATION__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_acl_permission_type_unknown" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ACL_PERMISSION_TYPE_UNKNOWN
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_acl_permission_type_any" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ACL_PERMISSION_TYPE_ANY
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_acl_permission_type_deny" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ACL_PERMISSION_TYPE_DENY
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_acl_permission_type_allow" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ACL_PERMISSION_TYPE_ALLOW
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_acl_permission_type__cnt" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ACL_PERMISSION_TYPE__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_event_listconsumergroups_result" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_EVENT_LISTCONSUMERGROUPS_RESULT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_event_describeconsumergroups_result" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_EVENT_DESCRIBECONSUMERGROUPS_RESULT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_event_listconsumergroupoffsets_result" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_EVENT_LISTCONSUMERGROUPOFFSETS_RESULT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_event_alterconsumergroupoffsets_result" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_EVENT_ALTERCONSUMERGROUPOFFSETS_RESULT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_consumer_group_state_unknown" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_CONSUMER_GROUP_STATE_UNKNOWN
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_consumer_group_state_preparing_rebalance" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_CONSUMER_GROUP_STATE_PREPARING_REBALANCE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_consumer_group_state_completing_rebalance" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_CONSUMER_GROUP_STATE_COMPLETING_REBALANCE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_consumer_group_state_stable" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_CONSUMER_GROUP_STATE_STABLE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_consumer_group_state_dead" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_CONSUMER_GROUP_STATE_DEAD
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_consumer_group_state_empty" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_CONSUMER_GROUP_STATE_EMPTY
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_consumer_group_state__cnt" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_CONSUMER_GROUP_STATE__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op_listconsumergroups" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ADMIN_OP_LISTCONSUMERGROUPS
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op_describeconsumergroups" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ADMIN_OP_DESCRIBECONSUMERGROUPS
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op_listconsumergroupoffsets" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ADMIN_OP_LISTCONSUMERGROUPOFFSETS
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op_alterconsumergroupoffsets" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ADMIN_OP_ALTERCONSUMERGROUPOFFSETS
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__log_truncation" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR__LOG_TRUNCATION
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_event_incrementalalterconfigs_result" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_EVENT_INCREMENTALALTERCONFIGS_RESULT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_event_describeuserscramcredentials_result" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_EVENT_DESCRIBEUSERSCRAMCREDENTIALS_RESULT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_event_alteruserscramcredentials_result" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_EVENT_ALTERUSERSCRAMCREDENTIALS_RESULT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op_incrementalalterconfigs" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ADMIN_OP_INCREMENTALALTERCONFIGS
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op_describeuserscramcredentials" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ADMIN_OP_DESCRIBEUSERSCRAMCREDENTIALS
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op_alteruserscramcredentials" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ADMIN_OP_ALTERUSERSCRAMCREDENTIALS
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_alter_config_op_type_set" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ALTER_CONFIG_OP_TYPE_SET
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_alter_config_op_type_delete" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ALTER_CONFIG_OP_TYPE_DELETE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_alter_config_op_type_append" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ALTER_CONFIG_OP_TYPE_APPEND
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_alter_config_op_type_subtract" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ALTER_CONFIG_OP_TYPE_SUBTRACT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_alter_config_op_type__cnt" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ALTER_CONFIG_OP_TYPE__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_scram_mechanism_unknown" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_SCRAM_MECHANISM_UNKNOWN
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_scram_mechanism_sha_256" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_SCRAM_MECHANISM_SHA_256
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_scram_mechanism_sha_512" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_SCRAM_MECHANISM_SHA_512
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_scram_mechanism__cnt" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_SCRAM_MECHANISM__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_event_describetopics_result" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_EVENT_DESCRIBETOPICS_RESULT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_event_describecluster_result" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_EVENT_DESCRIBECLUSTER_RESULT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_event_listoffsets_result" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_EVENT_LISTOFFSETS_RESULT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op_describetopics" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ADMIN_OP_DESCRIBETOPICS
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op_describecluster" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ADMIN_OP_DESCRIBECLUSTER
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op_listoffsets" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ADMIN_OP_LISTOFFSETS
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_isolation_level_read_uncommitted" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ISOLATION_LEVEL_READ_UNCOMMITTED
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_isolation_level_read_committed" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ISOLATION_LEVEL_READ_COMMITTED
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_offset_spec_max_timestamp" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_OFFSET_SPEC_MAX_TIMESTAMP
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_offset_spec_earliest" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_OFFSET_SPEC_EARLIEST
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_offset_spec_latest" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_OFFSET_SPEC_LATEST
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__invalid_different_record" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR__INVALID_DIFFERENT_RECORD
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_unknown_topic_id" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_ID
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_fenced_member_epoch" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_FENCED_MEMBER_EPOCH
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_unreleased_instance_id" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_UNRELEASED_INSTANCE_ID
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_unsupported_assignor" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_UNSUPPORTED_ASSIGNOR
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_stale_member_epoch" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_STALE_MEMBER_EPOCH
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_unknown_subscription_id" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_UNKNOWN_SUBSCRIPTION_ID
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_telemetry_too_large" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_TELEMETRY_TOO_LARGE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_event_electleaders_result" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_EVENT_ELECTLEADERS_RESULT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_consumer_group_type_unknown" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_CONSUMER_GROUP_TYPE_UNKNOWN
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_consumer_group_type_consumer" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_CONSUMER_GROUP_TYPE_CONSUMER
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_consumer_group_type_classic" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_CONSUMER_GROUP_TYPE_CLASSIC
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_consumer_group_type__cnt" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_CONSUMER_GROUP_TYPE__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op_electleaders" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ADMIN_OP_ELECTLEADERS
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resource_transactional_id" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESOURCE_TRANSACTIONAL_ID
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_election_type_preferred" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ELECTION_TYPE_PREFERRED
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_election_type_unclean" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ELECTION_TYPE_UNCLEAN
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_supported_methods" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_SUPPORTED_METHODS
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_version" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_VERSION
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_unsupported_compression_type" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_end_all" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_END_ALL
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op__cnt" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ADMIN_OP__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resource__cnt" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESOURCE__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_cdef" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_CDEF
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_version_1" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_VERSION
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_unsupported_compression_type_1" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_end_all_1" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_END_ALL
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op__cnt_1" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ADMIN_OP__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resource__cnt_1" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESOURCE__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_cdef_1" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_CDEF
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_version_2" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_VERSION
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_unsupported_compression_type_2" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_end_all_2" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_END_ALL
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op__cnt_2" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ADMIN_OP__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resource__cnt_2" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESOURCE__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_cdef_2" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_CDEF
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_version_3" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_VERSION
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_unsupported_compression_type_3" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_end_all_3" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_END_ALL
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op__cnt_3" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ADMIN_OP__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resource__cnt_3" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESOURCE__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_cdef_3" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_CDEF
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_version_4" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_VERSION
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_unsupported_compression_type_4" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_end_all_4" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_END_ALL
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op__cnt_4" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ADMIN_OP__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resource__cnt_4" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESOURCE__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_cdef_4" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_CDEF
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_version_5" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_VERSION
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_unsupported_compression_type_5" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_end_all_5" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_END_ALL
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op__cnt_5" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ADMIN_OP__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resource__cnt_5" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESOURCE__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_cdef_5" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_CDEF
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_version_6" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_VERSION
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_unsupported_compression_type_6" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_end_all_6" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_END_ALL
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op__cnt_6" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ADMIN_OP__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resource__cnt_6" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESOURCE__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_cdef_6" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_CDEF
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_version_7" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_VERSION
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_unsupported_compression_type_7" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_end_all_7" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_END_ALL
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op__cnt_7" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ADMIN_OP__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resource__cnt_7" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESOURCE__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_cdef_7" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_CDEF
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_version_8" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_VERSION
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_unsupported_compression_type_8" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_end_all_8" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_END_ALL
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op__cnt_8" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ADMIN_OP__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resource__cnt_8" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESOURCE__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_cdef_8" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_CDEF
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_version_9" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_VERSION
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_unsupported_compression_type_9" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_end_all_9" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_END_ALL
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op__cnt_9" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ADMIN_OP__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resource__cnt_9" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESOURCE__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_cdef_9" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_CDEF
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_version_10" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_VERSION
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_unsupported_compression_type_10" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_end_all_10" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_END_ALL
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op__cnt_10" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ADMIN_OP__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resource__cnt_10" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESOURCE__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_cdef_10" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_CDEF
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_version_11" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_VERSION
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_unsupported_compression_type_11" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_end_all_11" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_END_ALL
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op__cnt_11" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ADMIN_OP__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resource__cnt_11" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESOURCE__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_cdef_11" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_CDEF
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_version_12" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_VERSION
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_unsupported_compression_type_12" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_end_all_12" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_END_ALL
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op__cnt_12" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ADMIN_OP__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resource__cnt_12" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESOURCE__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_cdef_12" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_CDEF
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_version_13" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_VERSION
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_unsupported_compression_type_13" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_end_all_13" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_END_ALL
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op__cnt_13" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ADMIN_OP__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resource__cnt_13" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESOURCE__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_cdef_13" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_CDEF
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_version_14" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_VERSION
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_unsupported_compression_type_14" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_end_all_14" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_END_ALL
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op__cnt_14" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ADMIN_OP__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resource__cnt_14" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESOURCE__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_cdef_14" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_CDEF
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_version_15" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_VERSION
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_unsupported_compression_type_15" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_end_all_15" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_END_ALL
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op__cnt_15" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ADMIN_OP__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resource__cnt_15" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESOURCE__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_cdef_15" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_CDEF
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_version_16" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_VERSION
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_unsupported_compression_type_16" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_end_all_16" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_END_ALL
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op__cnt_16" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ADMIN_OP__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resource__cnt_16" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESOURCE__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_cdef_16" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_CDEF
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_version_17" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_VERSION
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_unsupported_compression_type_17" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_end_all_17" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_END_ALL
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op__cnt_17" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ADMIN_OP__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resource__cnt_17" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESOURCE__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_cdef_17" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_CDEF
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_version_18" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_VERSION
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_unsupported_compression_type_18" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_end_all_18" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_END_ALL
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op__cnt_18" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ADMIN_OP__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resource__cnt_18" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESOURCE__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_cdef_18" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_CDEF
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_version_19" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_VERSION
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_unsupported_compression_type_19" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_end_all_19" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_END_ALL
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op__cnt_19" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ADMIN_OP__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resource__cnt_19" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESOURCE__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_cdef_19" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_CDEF
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_version_20" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_VERSION
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_unsupported_compression_type_20" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_end_all_20" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_END_ALL
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op__cnt_20" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ADMIN_OP__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resource__cnt_20" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESOURCE__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_cdef_20" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_CDEF
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_version_21" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_VERSION
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_unsupported_compression_type_21" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_end_all_21" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_END_ALL
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op__cnt_21" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ADMIN_OP__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resource__cnt_21" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESOURCE__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_cdef_21" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_CDEF
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_version_22" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_VERSION
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_unsupported_compression_type_22" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_end_all_22" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_END_ALL
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op__cnt_22" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ADMIN_OP__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resource__cnt_22" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESOURCE__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_cdef_22" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_CDEF
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_version_23" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_VERSION
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_unsupported_compression_type_23" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_end_all_23" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_END_ALL
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op__cnt_23" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ADMIN_OP__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resource__cnt_23" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESOURCE__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_cdef_23" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_CDEF
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_version_24" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_VERSION
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_unsupported_compression_type_24" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_end_all_24" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_END_ALL
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op__cnt_24" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ADMIN_OP__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resource__cnt_24" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESOURCE__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_cdef_24" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_CDEF
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_version_25" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_VERSION
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_unsupported_compression_type_25" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_end_all_25" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_END_ALL
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op__cnt_25" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ADMIN_OP__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resource__cnt_25" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESOURCE__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_cdef_25" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_CDEF
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_version_26" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_VERSION
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_unsupported_compression_type_26" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_end_all_26" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_END_ALL
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op__cnt_26" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ADMIN_OP__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resource__cnt_26" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESOURCE__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_cdef_26" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_CDEF
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_version_27" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_VERSION
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_unsupported_compression_type_27" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_end_all_27" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_END_ALL
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op__cnt_27" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ADMIN_OP__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resource__cnt_27" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESOURCE__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_cdef_27" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_CDEF
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_version_28" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_VERSION
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_unsupported_compression_type_28" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_end_all_28" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_END_ALL
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op__cnt_28" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ADMIN_OP__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resource__cnt_28" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESOURCE__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_cdef_28" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_CDEF
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_version_29" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_VERSION
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_unsupported_compression_type_29" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_end_all_29" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_END_ALL
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op__cnt_29" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ADMIN_OP__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resource__cnt_29" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESOURCE__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_cdef_29" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_CDEF
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_version_30" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_VERSION
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_unsupported_compression_type_30" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_end_all_30" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_END_ALL
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op__cnt_30" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ADMIN_OP__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resource__cnt_30" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESOURCE__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_cdef_30" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_CDEF
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_version_31" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_VERSION
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_unsupported_compression_type_31" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_end_all_31" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_END_ALL
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op__cnt_31" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ADMIN_OP__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resource__cnt_31" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESOURCE__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_cdef_31" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_CDEF
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_version_32" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_VERSION
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_unsupported_compression_type_32" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_end_all_32" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_END_ALL
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op__cnt_32" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ADMIN_OP__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resource__cnt_32" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESOURCE__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_cdef_32" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_CDEF
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_version_33" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_VERSION
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_unsupported_compression_type_33" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_end_all_33" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_END_ALL
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op__cnt_33" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ADMIN_OP__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resource__cnt_33" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESOURCE__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_cdef_33" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_CDEF
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_version_34" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_VERSION
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_unsupported_compression_type_34" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_end_all_34" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_END_ALL
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op__cnt_34" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ADMIN_OP__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resource__cnt_34" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESOURCE__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_cdef_34" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_CDEF
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_version_35" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_VERSION
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_unsupported_compression_type_35" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_end_all_35" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_END_ALL
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op__cnt_35" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ADMIN_OP__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resource__cnt_35" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESOURCE__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_cdef_35" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_CDEF
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../functions/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Functions
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    
    
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3_5" >
        
          
          <label class="md-nav__link" for="__nav_3_5" id="__nav_3_5_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    RdKafka
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_3_5_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3_5">
            <span class="md-nav__icon md-icon"></span>
            RdKafka
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../RdKafka/Conf/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Conf
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../RdKafka/Consumer/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Consumer
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../RdKafka/ConsumerTopic/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    ConsumerTopic
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../RdKafka/Event/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Event
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../RdKafka/Exception/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Exception
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../RdKafka/KafkaConsumer/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    KafkaConsumer
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../RdKafka/KafkaConsumerTopic/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    KafkaConsumerTopic
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../RdKafka/KafkaErrorException/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    KafkaErrorException
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../RdKafka/Message/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Message
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../RdKafka/Metadata/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Metadata
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../RdKafka/Producer/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Producer
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../RdKafka/ProducerTopic/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    ProducerTopic
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../RdKafka/Queue/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Queue
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../RdKafka/Topic/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Topic
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../RdKafka/TopicConf/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    TopicConf
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../RdKafka/TopicPartition/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    TopicPartition
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../RdKafka/TopicPartitionList/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    TopicPartitionList
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    
    
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3_5_18" >
        
          
          <label class="md-nav__link" for="__nav_3_5_18" id="__nav_3_5_18_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Admin
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="3" aria-labelledby="__nav_3_5_18_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3_5_18">
            <span class="md-nav__icon md-icon"></span>
            Admin
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../RdKafka/Admin/AlterConfigsOptions/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    AlterConfigsOptions
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../RdKafka/Admin/Client/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Client
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../RdKafka/Admin/ConfigEntry/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    ConfigEntry
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../RdKafka/Admin/ConfigResource/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    ConfigResource
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../RdKafka/Admin/ConfigResourceResult/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    ConfigResourceResult
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../RdKafka/Admin/CreatePartitionsOptions/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    CreatePartitionsOptions
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../RdKafka/Admin/CreateTopicsOptions/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    CreateTopicsOptions
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../RdKafka/Admin/DeleteConsumerGroupOffsets/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    DeleteConsumerGroupOffsets
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../RdKafka/Admin/DeleteConsumerGroupOffsetsOptions/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    DeleteConsumerGroupOffsetsOptions
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../RdKafka/Admin/DeleteGroup/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    DeleteGroup
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../RdKafka/Admin/DeleteGroupsOptions/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    DeleteGroupsOptions
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../RdKafka/Admin/DeleteRecords/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    DeleteRecords
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../RdKafka/Admin/DeleteRecordsOptions/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    DeleteRecordsOptions
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../RdKafka/Admin/DeleteTopic/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    DeleteTopic
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../RdKafka/Admin/DeleteTopicsOptions/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    DeleteTopicsOptions
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../RdKafka/Admin/DescribeConfigsOptions/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    DescribeConfigsOptions
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../RdKafka/Admin/GroupResult/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    GroupResult
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../RdKafka/Admin/NewPartitions/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    NewPartitions
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../RdKafka/Admin/NewTopic/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    NewTopic
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../RdKafka/Admin/Options/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Options
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../RdKafka/Admin/TopicResult/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    TopicResult
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3_5_19" >
        
          
          <label class="md-nav__link" for="__nav_3_5_19" id="__nav_3_5_19_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    FFI
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="3" aria-labelledby="__nav_3_5_19_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3_5_19">
            <span class="md-nav__icon md-icon"></span>
            FFI
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../RdKafka/FFI/CallbackProxy/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    CallbackProxy
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../RdKafka/FFI/ConsumeCallbackProxy/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    ConsumeCallbackProxy
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../RdKafka/FFI/DrMsgCallbackProxy/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    DrMsgCallbackProxy
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../RdKafka/FFI/ErrorCallbackProxy/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    ErrorCallbackProxy
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../RdKafka/FFI/Library/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Library
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../RdKafka/FFI/LogCallbackProxy/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    LogCallbackProxy
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../RdKafka/FFI/Methods/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Methods
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../RdKafka/FFI/NativePartitionerCallbackProxy/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    NativePartitionerCallbackProxy
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../RdKafka/FFI/OffsetCommitCallbackProxy/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    OffsetCommitCallbackProxy
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../RdKafka/FFI/OpaqueMap/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    OpaqueMap
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../RdKafka/FFI/PartitionerCallbackProxy/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    PartitionerCallbackProxy
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../RdKafka/FFI/RebalanceCallbackProxy/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    RebalanceCallbackProxy
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../RdKafka/FFI/StatsCallbackProxy/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    StatsCallbackProxy
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
      
        
      
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3_5_20" >
        
          
          <label class="md-nav__link" for="__nav_3_5_20" id="__nav_3_5_20_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Metadata
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="3" aria-labelledby="__nav_3_5_20_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3_5_20">
            <span class="md-nav__icon md-icon"></span>
            Metadata
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../RdKafka/Metadata/Broker/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Broker
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../RdKafka/Metadata/Collection/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Collection
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../RdKafka/Metadata/Partition/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Partition
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../RdKafka/Metadata/Topic/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Topic
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3_5_21" >
        
          
          <label class="md-nav__link" for="__nav_3_5_21" id="__nav_3_5_21_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Test
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="3" aria-labelledby="__nav_3_5_21_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3_5_21">
            <span class="md-nav__icon md-icon"></span>
            Test
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../RdKafka/Test/ApiKey/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    ApiKey
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../RdKafka/Test/MockCluster/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    MockCluster
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../benchmarks/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Benchmarks
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_5" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../contributing/" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    Contributing
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_5" id="__nav_5_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_5_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_5">
            <span class="md-nav__icon md-icon"></span>
            Contributing
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../contributing/project-overview/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Project Overview
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../contributing/run-tests/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Run tests
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../contributing/work-on-the-documentation/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Work on the documentation
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../contributing/run-benchmarks/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Run benchmarks
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../contributing/contributors/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Contributors
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_log_print" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_LOG_PRINT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_log_syslog" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_LOG_SYSLOG
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_log_syslog_print" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_LOG_SYSLOG_PRINT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_msg_partitioner_random" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_MSG_PARTITIONER_RANDOM
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_msg_partitioner_consistent" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_MSG_PARTITIONER_CONSISTENT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_msg_partitioner_consistent_random" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_MSG_PARTITIONER_CONSISTENT_RANDOM
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_msg_partitioner_murmur2" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_MSG_PARTITIONER_MURMUR2
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_msg_partitioner_murmur2_random" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_MSG_PARTITIONER_MURMUR2_RANDOM
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_msg_partitioner_fnv1a" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_MSG_PARTITIONER_FNV1A
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_msg_partitioner_fnv1a_random" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_MSG_PARTITIONER_FNV1A_RANDOM
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_destroy_f_no_consumer_close" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_DESTROY_F_NO_CONSUMER_CLOSE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_partition_ua" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_PARTITION_UA
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_offset_beginning" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_OFFSET_BEGINNING
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_offset_end" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_OFFSET_END
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_offset_stored" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_OFFSET_STORED
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_offset_invalid" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_OFFSET_INVALID
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_offset_tail_base" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_OFFSET_TAIL_BASE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_msg_f_free" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_MSG_F_FREE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_msg_f_copy" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_MSG_F_COPY
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_msg_f_block" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_MSG_F_BLOCK
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_msg_f_partition" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_MSG_F_PARTITION
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_purge_f_queue" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_PURGE_F_QUEUE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_purge_f_inflight" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_PURGE_F_INFLIGHT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_purge_f_non_blocking" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_PURGE_F_NON_BLOCKING
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_event_none" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_EVENT_NONE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_event_dr" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_EVENT_DR
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_event_fetch" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_EVENT_FETCH
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_event_log" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_EVENT_LOG
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_event_error" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_EVENT_ERROR
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_event_rebalance" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_EVENT_REBALANCE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_event_offset_commit" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_EVENT_OFFSET_COMMIT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_event_stats" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_EVENT_STATS
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_event_createtopics_result" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_EVENT_CREATETOPICS_RESULT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_event_deletetopics_result" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_EVENT_DELETETOPICS_RESULT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_event_createpartitions_result" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_EVENT_CREATEPARTITIONS_RESULT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_event_alterconfigs_result" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_EVENT_ALTERCONFIGS_RESULT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_event_describeconfigs_result" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_EVENT_DESCRIBECONFIGS_RESULT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_producer" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_PRODUCER
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_consumer" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_CONSUMER
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_timestamp_not_available" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_TIMESTAMP_NOT_AVAILABLE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_timestamp_create_time" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_TIMESTAMP_CREATE_TIME
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_timestamp_log_append_time" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_TIMESTAMP_LOG_APPEND_TIME
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__begin" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR__BEGIN
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__bad_msg" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR__BAD_MSG
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__bad_compression" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR__BAD_COMPRESSION
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__destroy" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR__DESTROY
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__fail" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR__FAIL
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__transport" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR__TRANSPORT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__crit_sys_resource" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR__CRIT_SYS_RESOURCE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__resolve" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR__RESOLVE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__msg_timed_out" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR__MSG_TIMED_OUT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__partition_eof" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR__PARTITION_EOF
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__unknown_partition" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__fs" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR__FS
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__unknown_topic" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__all_brokers_down" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR__ALL_BROKERS_DOWN
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__invalid_arg" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR__INVALID_ARG
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__timed_out" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR__TIMED_OUT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__queue_full" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR__QUEUE_FULL
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__isr_insuff" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR__ISR_INSUFF
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__node_update" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR__NODE_UPDATE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__ssl" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR__SSL
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__wait_coord" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR__WAIT_COORD
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__unknown_group" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR__UNKNOWN_GROUP
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__in_progress" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR__IN_PROGRESS
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__prev_in_progress" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR__PREV_IN_PROGRESS
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__existing_subscription" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR__EXISTING_SUBSCRIPTION
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__assign_partitions" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__revoke_partitions" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__conflict" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR__CONFLICT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__state" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR__STATE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__unknown_protocol" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR__UNKNOWN_PROTOCOL
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__not_implemented" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__authentication" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR__AUTHENTICATION
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__no_offset" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR__NO_OFFSET
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__outdated" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR__OUTDATED
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__timed_out_queue" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR__TIMED_OUT_QUEUE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__unsupported_feature" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR__UNSUPPORTED_FEATURE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__wait_cache" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR__WAIT_CACHE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__intr" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR__INTR
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__key_serialization" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR__KEY_SERIALIZATION
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__value_serialization" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR__VALUE_SERIALIZATION
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__key_deserialization" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR__KEY_DESERIALIZATION
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__value_deserialization" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR__VALUE_DESERIALIZATION
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__partial" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR__PARTIAL
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__read_only" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR__READ_ONLY
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__noent" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR__NOENT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__underflow" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR__UNDERFLOW
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__invalid_type" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR__INVALID_TYPE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__retry" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR__RETRY
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__purge_queue" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR__PURGE_QUEUE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__purge_inflight" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR__PURGE_INFLIGHT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__fatal" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR__FATAL
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__inconsistent" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR__INCONSISTENT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__gapless_guarantee" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR__GAPLESS_GUARANTEE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__max_poll_exceeded" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR__MAX_POLL_EXCEEDED
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__end" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR__END
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_unknown" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_UNKNOWN
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_no_error" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_NO_ERROR
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_offset_out_of_range" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_OFFSET_OUT_OF_RANGE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_invalid_msg" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_INVALID_MSG
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_unknown_topic_or_part" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_invalid_msg_size" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_INVALID_MSG_SIZE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_leader_not_available" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_not_leader_for_partition" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_NOT_LEADER_FOR_PARTITION
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_request_timed_out" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_REQUEST_TIMED_OUT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_broker_not_available" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_BROKER_NOT_AVAILABLE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_replica_not_available" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_REPLICA_NOT_AVAILABLE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_msg_size_too_large" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_stale_ctrl_epoch" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_STALE_CTRL_EPOCH
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_offset_metadata_too_large" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_OFFSET_METADATA_TOO_LARGE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_network_exception" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_NETWORK_EXCEPTION
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_group_load_in_progress" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_GROUP_LOAD_IN_PROGRESS
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_group_coordinator_not_available" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_GROUP_COORDINATOR_NOT_AVAILABLE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_not_coordinator_for_group" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_NOT_COORDINATOR_FOR_GROUP
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_topic_exception" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_TOPIC_EXCEPTION
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_record_list_too_large" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_RECORD_LIST_TOO_LARGE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_not_enough_replicas" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_not_enough_replicas_after_append" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS_AFTER_APPEND
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_invalid_required_acks" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_INVALID_REQUIRED_ACKS
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_illegal_generation" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_ILLEGAL_GENERATION
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_inconsistent_group_protocol" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_INCONSISTENT_GROUP_PROTOCOL
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_invalid_group_id" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_INVALID_GROUP_ID
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_unknown_member_id" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_UNKNOWN_MEMBER_ID
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_invalid_session_timeout" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_INVALID_SESSION_TIMEOUT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_rebalance_in_progress" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_REBALANCE_IN_PROGRESS
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_invalid_commit_offset_size" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_INVALID_COMMIT_OFFSET_SIZE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_topic_authorization_failed" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_TOPIC_AUTHORIZATION_FAILED
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_group_authorization_failed" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_GROUP_AUTHORIZATION_FAILED
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_cluster_authorization_failed" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_CLUSTER_AUTHORIZATION_FAILED
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_invalid_timestamp" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_INVALID_TIMESTAMP
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_unsupported_sasl_mechanism" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_UNSUPPORTED_SASL_MECHANISM
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_illegal_sasl_state" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_ILLEGAL_SASL_STATE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_unsupported_version" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_UNSUPPORTED_VERSION
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_topic_already_exists" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_TOPIC_ALREADY_EXISTS
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_invalid_partitions" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_INVALID_PARTITIONS
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_invalid_replication_factor" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_INVALID_REPLICATION_FACTOR
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_invalid_replica_assignment" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_INVALID_REPLICA_ASSIGNMENT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_invalid_config" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_INVALID_CONFIG
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_not_controller" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_NOT_CONTROLLER
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_invalid_request" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_INVALID_REQUEST
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_unsupported_for_message_format" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_UNSUPPORTED_FOR_MESSAGE_FORMAT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_policy_violation" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_POLICY_VIOLATION
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_out_of_order_sequence_number" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_OUT_OF_ORDER_SEQUENCE_NUMBER
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_duplicate_sequence_number" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_DUPLICATE_SEQUENCE_NUMBER
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_invalid_producer_epoch" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_INVALID_PRODUCER_EPOCH
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_invalid_txn_state" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_INVALID_TXN_STATE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_invalid_producer_id_mapping" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_INVALID_PRODUCER_ID_MAPPING
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_invalid_transaction_timeout" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_INVALID_TRANSACTION_TIMEOUT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_concurrent_transactions" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_CONCURRENT_TRANSACTIONS
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_transaction_coordinator_fenced" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_TRANSACTION_COORDINATOR_FENCED
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_transactional_id_authorization_failed" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_TRANSACTIONAL_ID_AUTHORIZATION_FAILED
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_security_disabled" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_SECURITY_DISABLED
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_operation_not_attempted" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_OPERATION_NOT_ATTEMPTED
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_kafka_storage_error" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_KAFKA_STORAGE_ERROR
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_log_dir_not_found" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_LOG_DIR_NOT_FOUND
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_sasl_authentication_failed" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_SASL_AUTHENTICATION_FAILED
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_unknown_producer_id" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_UNKNOWN_PRODUCER_ID
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_reassignment_in_progress" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_REASSIGNMENT_IN_PROGRESS
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_delegation_token_auth_disabled" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTH_DISABLED
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_delegation_token_not_found" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_NOT_FOUND
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_delegation_token_owner_mismatch" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_OWNER_MISMATCH
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_delegation_token_request_not_allowed" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_REQUEST_NOT_ALLOWED
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_delegation_token_authorization_failed" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTHORIZATION_FAILED
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_delegation_token_expired" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_EXPIRED
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_invalid_principal_type" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_INVALID_PRINCIPAL_TYPE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_non_empty_group" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_NON_EMPTY_GROUP
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_group_id_not_found" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_GROUP_ID_NOT_FOUND
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_fetch_session_id_not_found" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_FETCH_SESSION_ID_NOT_FOUND
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_invalid_fetch_session_epoch" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_INVALID_FETCH_SESSION_EPOCH
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_listener_not_found" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_LISTENER_NOT_FOUND
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_topic_deletion_disabled" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_TOPIC_DELETION_DISABLED
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_vtype_end" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_VTYPE_END
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_vtype_topic" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_VTYPE_TOPIC
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_vtype_rkt" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_VTYPE_RKT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_vtype_partition" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_VTYPE_PARTITION
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_vtype_value" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_VTYPE_VALUE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_vtype_key" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_VTYPE_KEY
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_vtype_opaque" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_VTYPE_OPAQUE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_vtype_msgflags" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_VTYPE_MSGFLAGS
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_vtype_timestamp" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_VTYPE_TIMESTAMP
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_vtype_header" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_VTYPE_HEADER
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_vtype_headers" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_VTYPE_HEADERS
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_msg_status_not_persisted" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_MSG_STATUS_NOT_PERSISTED
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_msg_status_possibly_persisted" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_MSG_STATUS_POSSIBLY_PERSISTED
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_msg_status_persisted" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_MSG_STATUS_PERSISTED
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_conf_unknown" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_CONF_UNKNOWN
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_conf_invalid" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_CONF_INVALID
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_conf_ok" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_CONF_OK
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op_any" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ADMIN_OP_ANY
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op_createtopics" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ADMIN_OP_CREATETOPICS
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op_deletetopics" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ADMIN_OP_DELETETOPICS
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op_createpartitions" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ADMIN_OP_CREATEPARTITIONS
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op_alterconfigs" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ADMIN_OP_ALTERCONFIGS
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op_describeconfigs" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ADMIN_OP_DESCRIBECONFIGS
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_config_source_unknown_config" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_CONFIG_SOURCE_UNKNOWN_CONFIG
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_config_source_dynamic_topic_config" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_CONFIG_SOURCE_DYNAMIC_TOPIC_CONFIG
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_config_source_dynamic_broker_config" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_CONFIG_SOURCE_DYNAMIC_BROKER_CONFIG
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_config_source_dynamic_default_broker_config" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_CONFIG_SOURCE_DYNAMIC_DEFAULT_BROKER_CONFIG
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_config_source_static_broker_config" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_CONFIG_SOURCE_STATIC_BROKER_CONFIG
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_config_source_default_config" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_CONFIG_SOURCE_DEFAULT_CONFIG
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_config_source__cnt" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_CONFIG_SOURCE__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resource_unknown" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESOURCE_UNKNOWN
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resource_any" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESOURCE_ANY
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resource_topic" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESOURCE_TOPIC
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resource_group" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESOURCE_GROUP
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resource_broker" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESOURCE_BROKER
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_fenced_leader_epoch" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_FENCED_LEADER_EPOCH
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_unknown_leader_epoch" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_UNKNOWN_LEADER_EPOCH
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_stale_broker_epoch" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_STALE_BROKER_EPOCH
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_offset_not_available" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_OFFSET_NOT_AVAILABLE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_member_id_required" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_MEMBER_ID_REQUIRED
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_preferred_leader_not_available" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_PREFERRED_LEADER_NOT_AVAILABLE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_group_max_size_reached" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_GROUP_MAX_SIZE_REACHED
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_event_oauthbearer_token_refresh" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_EVENT_OAUTHBEARER_TOKEN_REFRESH
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_cert_public_key" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_CERT_PUBLIC_KEY
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_cert_private_key" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_CERT_PRIVATE_KEY
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_cert_ca" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_CERT_CA
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_cert__cnt" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_CERT__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_cert_enc_pkcs12" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_CERT_ENC_PKCS12
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_cert_enc_der" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_CERT_ENC_DER
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_cert_enc_pem" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_CERT_ENC_PEM
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_cert_enc__cnt" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_CERT_ENC__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_thread_main" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_THREAD_MAIN
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_thread_background" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_THREAD_BACKGROUND
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_thread_broker" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_THREAD_BROKER
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__unknown_broker" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR__UNKNOWN_BROKER
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_coordinator_load_in_progress" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_COORDINATOR_LOAD_IN_PROGRESS
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_coordinator_not_available" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_COORDINATOR_NOT_AVAILABLE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_not_coordinator" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_NOT_COORDINATOR
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__not_configured" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR__NOT_CONFIGURED
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__fenced" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR__FENCED
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__application" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR__APPLICATION
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_fenced_instance_id" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_FENCED_INSTANCE_ID
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_eligible_leaders_not_available" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_ELIGIBLE_LEADERS_NOT_AVAILABLE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_election_not_needed" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_ELECTION_NOT_NEEDED
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_no_reassignment_in_progress" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_NO_REASSIGNMENT_IN_PROGRESS
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_group_subscribed_to_topic" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_GROUP_SUBSCRIBED_TO_TOPIC
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_invalid_record" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_INVALID_RECORD
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_unstable_offset_commit" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_UNSTABLE_OFFSET_COMMIT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_event_deleterecords_result" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_EVENT_DELETERECORDS_RESULT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_event_deletegroups_result" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_EVENT_DELETEGROUPS_RESULT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_event_deleteconsumergroupoffsets_result" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_EVENT_DELETECONSUMERGROUPOFFSETS_RESULT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__assignment_lost" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR__ASSIGNMENT_LOST
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__noop" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR__NOOP
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_throttling_quota_exceeded" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_THROTTLING_QUOTA_EXCEEDED
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_producer_fenced" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_PRODUCER_FENCED
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_resource_not_found" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_RESOURCE_NOT_FOUND
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_duplicate_resource" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_DUPLICATE_RESOURCE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_unacceptable_credential" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_UNACCEPTABLE_CREDENTIAL
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_inconsistent_voter_set" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_INCONSISTENT_VOTER_SET
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_invalid_update_version" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_INVALID_UPDATE_VERSION
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_feature_update_failed" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_FEATURE_UPDATE_FAILED
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_principal_deserialization_failure" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_PRINCIPAL_DESERIALIZATION_FAILURE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op_deleterecords" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ADMIN_OP_DELETERECORDS
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op_deletegroups" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ADMIN_OP_DELETEGROUPS
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op_deleteconsumergroupoffsets" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ADMIN_OP_DELETECONSUMERGROUPOFFSETS
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__auto_offset_reset" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR__AUTO_OFFSET_RESET
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_event_background" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_EVENT_BACKGROUND
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_event_createacls_result" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_EVENT_CREATEACLS_RESULT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_event_describeacls_result" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_EVENT_DESCRIBEACLS_RESULT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_event_deleteacls_result" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_EVENT_DELETEACLS_RESULT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op_createacls" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ADMIN_OP_CREATEACLS
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op_describeacls" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ADMIN_OP_DESCRIBEACLS
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op_deleteacls" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ADMIN_OP_DELETEACLS
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resource_pattern_unknown" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESOURCE_PATTERN_UNKNOWN
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resource_pattern_any" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESOURCE_PATTERN_ANY
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resource_pattern_match" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESOURCE_PATTERN_MATCH
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resource_pattern_literal" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESOURCE_PATTERN_LITERAL
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resource_pattern_prefixed" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESOURCE_PATTERN_PREFIXED
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resource_pattern_type__cnt" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESOURCE_PATTERN_TYPE__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_acl_operation_unknown" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ACL_OPERATION_UNKNOWN
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_acl_operation_any" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ACL_OPERATION_ANY
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_acl_operation_all" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ACL_OPERATION_ALL
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_acl_operation_read" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ACL_OPERATION_READ
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_acl_operation_write" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ACL_OPERATION_WRITE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_acl_operation_create" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ACL_OPERATION_CREATE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_acl_operation_delete" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ACL_OPERATION_DELETE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_acl_operation_alter" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ACL_OPERATION_ALTER
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_acl_operation_describe" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ACL_OPERATION_DESCRIBE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_acl_operation_cluster_action" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ACL_OPERATION_CLUSTER_ACTION
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_acl_operation_describe_configs" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ACL_OPERATION_DESCRIBE_CONFIGS
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_acl_operation_alter_configs" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ACL_OPERATION_ALTER_CONFIGS
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_acl_operation_idempotent_write" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ACL_OPERATION_IDEMPOTENT_WRITE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_acl_operation__cnt" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ACL_OPERATION__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_acl_permission_type_unknown" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ACL_PERMISSION_TYPE_UNKNOWN
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_acl_permission_type_any" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ACL_PERMISSION_TYPE_ANY
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_acl_permission_type_deny" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ACL_PERMISSION_TYPE_DENY
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_acl_permission_type_allow" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ACL_PERMISSION_TYPE_ALLOW
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_acl_permission_type__cnt" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ACL_PERMISSION_TYPE__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_event_listconsumergroups_result" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_EVENT_LISTCONSUMERGROUPS_RESULT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_event_describeconsumergroups_result" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_EVENT_DESCRIBECONSUMERGROUPS_RESULT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_event_listconsumergroupoffsets_result" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_EVENT_LISTCONSUMERGROUPOFFSETS_RESULT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_event_alterconsumergroupoffsets_result" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_EVENT_ALTERCONSUMERGROUPOFFSETS_RESULT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_consumer_group_state_unknown" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_CONSUMER_GROUP_STATE_UNKNOWN
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_consumer_group_state_preparing_rebalance" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_CONSUMER_GROUP_STATE_PREPARING_REBALANCE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_consumer_group_state_completing_rebalance" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_CONSUMER_GROUP_STATE_COMPLETING_REBALANCE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_consumer_group_state_stable" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_CONSUMER_GROUP_STATE_STABLE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_consumer_group_state_dead" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_CONSUMER_GROUP_STATE_DEAD
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_consumer_group_state_empty" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_CONSUMER_GROUP_STATE_EMPTY
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_consumer_group_state__cnt" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_CONSUMER_GROUP_STATE__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op_listconsumergroups" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ADMIN_OP_LISTCONSUMERGROUPS
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op_describeconsumergroups" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ADMIN_OP_DESCRIBECONSUMERGROUPS
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op_listconsumergroupoffsets" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ADMIN_OP_LISTCONSUMERGROUPOFFSETS
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op_alterconsumergroupoffsets" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ADMIN_OP_ALTERCONSUMERGROUPOFFSETS
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__log_truncation" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR__LOG_TRUNCATION
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_event_incrementalalterconfigs_result" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_EVENT_INCREMENTALALTERCONFIGS_RESULT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_event_describeuserscramcredentials_result" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_EVENT_DESCRIBEUSERSCRAMCREDENTIALS_RESULT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_event_alteruserscramcredentials_result" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_EVENT_ALTERUSERSCRAMCREDENTIALS_RESULT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op_incrementalalterconfigs" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ADMIN_OP_INCREMENTALALTERCONFIGS
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op_describeuserscramcredentials" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ADMIN_OP_DESCRIBEUSERSCRAMCREDENTIALS
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op_alteruserscramcredentials" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ADMIN_OP_ALTERUSERSCRAMCREDENTIALS
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_alter_config_op_type_set" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ALTER_CONFIG_OP_TYPE_SET
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_alter_config_op_type_delete" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ALTER_CONFIG_OP_TYPE_DELETE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_alter_config_op_type_append" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ALTER_CONFIG_OP_TYPE_APPEND
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_alter_config_op_type_subtract" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ALTER_CONFIG_OP_TYPE_SUBTRACT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_alter_config_op_type__cnt" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ALTER_CONFIG_OP_TYPE__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_scram_mechanism_unknown" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_SCRAM_MECHANISM_UNKNOWN
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_scram_mechanism_sha_256" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_SCRAM_MECHANISM_SHA_256
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_scram_mechanism_sha_512" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_SCRAM_MECHANISM_SHA_512
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_scram_mechanism__cnt" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_SCRAM_MECHANISM__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_event_describetopics_result" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_EVENT_DESCRIBETOPICS_RESULT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_event_describecluster_result" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_EVENT_DESCRIBECLUSTER_RESULT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_event_listoffsets_result" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_EVENT_LISTOFFSETS_RESULT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op_describetopics" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ADMIN_OP_DESCRIBETOPICS
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op_describecluster" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ADMIN_OP_DESCRIBECLUSTER
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op_listoffsets" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ADMIN_OP_LISTOFFSETS
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_isolation_level_read_uncommitted" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ISOLATION_LEVEL_READ_UNCOMMITTED
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_isolation_level_read_committed" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ISOLATION_LEVEL_READ_COMMITTED
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_offset_spec_max_timestamp" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_OFFSET_SPEC_MAX_TIMESTAMP
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_offset_spec_earliest" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_OFFSET_SPEC_EARLIEST
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_offset_spec_latest" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_OFFSET_SPEC_LATEST
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__invalid_different_record" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR__INVALID_DIFFERENT_RECORD
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_unknown_topic_id" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_ID
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_fenced_member_epoch" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_FENCED_MEMBER_EPOCH
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_unreleased_instance_id" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_UNRELEASED_INSTANCE_ID
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_unsupported_assignor" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_UNSUPPORTED_ASSIGNOR
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_stale_member_epoch" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_STALE_MEMBER_EPOCH
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_unknown_subscription_id" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_UNKNOWN_SUBSCRIPTION_ID
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_telemetry_too_large" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_TELEMETRY_TOO_LARGE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_event_electleaders_result" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_EVENT_ELECTLEADERS_RESULT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_consumer_group_type_unknown" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_CONSUMER_GROUP_TYPE_UNKNOWN
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_consumer_group_type_consumer" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_CONSUMER_GROUP_TYPE_CONSUMER
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_consumer_group_type_classic" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_CONSUMER_GROUP_TYPE_CLASSIC
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_consumer_group_type__cnt" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_CONSUMER_GROUP_TYPE__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op_electleaders" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ADMIN_OP_ELECTLEADERS
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resource_transactional_id" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESOURCE_TRANSACTIONAL_ID
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_election_type_preferred" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ELECTION_TYPE_PREFERRED
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_election_type_unclean" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ELECTION_TYPE_UNCLEAN
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_supported_methods" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_SUPPORTED_METHODS
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_version" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_VERSION
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_unsupported_compression_type" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_end_all" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_END_ALL
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op__cnt" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ADMIN_OP__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resource__cnt" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESOURCE__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_cdef" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_CDEF
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_version_1" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_VERSION
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_unsupported_compression_type_1" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_end_all_1" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_END_ALL
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op__cnt_1" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ADMIN_OP__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resource__cnt_1" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESOURCE__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_cdef_1" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_CDEF
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_version_2" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_VERSION
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_unsupported_compression_type_2" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_end_all_2" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_END_ALL
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op__cnt_2" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ADMIN_OP__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resource__cnt_2" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESOURCE__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_cdef_2" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_CDEF
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_version_3" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_VERSION
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_unsupported_compression_type_3" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_end_all_3" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_END_ALL
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op__cnt_3" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ADMIN_OP__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resource__cnt_3" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESOURCE__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_cdef_3" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_CDEF
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_version_4" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_VERSION
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_unsupported_compression_type_4" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_end_all_4" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_END_ALL
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op__cnt_4" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ADMIN_OP__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resource__cnt_4" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESOURCE__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_cdef_4" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_CDEF
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_version_5" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_VERSION
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_unsupported_compression_type_5" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_end_all_5" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_END_ALL
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op__cnt_5" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ADMIN_OP__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resource__cnt_5" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESOURCE__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_cdef_5" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_CDEF
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_version_6" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_VERSION
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_unsupported_compression_type_6" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_end_all_6" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_END_ALL
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op__cnt_6" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ADMIN_OP__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resource__cnt_6" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESOURCE__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_cdef_6" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_CDEF
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_version_7" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_VERSION
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_unsupported_compression_type_7" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_end_all_7" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_END_ALL
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op__cnt_7" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ADMIN_OP__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resource__cnt_7" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESOURCE__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_cdef_7" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_CDEF
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_version_8" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_VERSION
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_unsupported_compression_type_8" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_end_all_8" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_END_ALL
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op__cnt_8" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ADMIN_OP__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resource__cnt_8" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESOURCE__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_cdef_8" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_CDEF
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_version_9" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_VERSION
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_unsupported_compression_type_9" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_end_all_9" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_END_ALL
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op__cnt_9" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ADMIN_OP__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resource__cnt_9" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESOURCE__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_cdef_9" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_CDEF
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_version_10" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_VERSION
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_unsupported_compression_type_10" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_end_all_10" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_END_ALL
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op__cnt_10" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ADMIN_OP__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resource__cnt_10" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESOURCE__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_cdef_10" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_CDEF
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_version_11" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_VERSION
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_unsupported_compression_type_11" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_end_all_11" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_END_ALL
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op__cnt_11" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ADMIN_OP__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resource__cnt_11" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESOURCE__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_cdef_11" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_CDEF
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_version_12" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_VERSION
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_unsupported_compression_type_12" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_end_all_12" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_END_ALL
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op__cnt_12" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ADMIN_OP__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resource__cnt_12" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESOURCE__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_cdef_12" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_CDEF
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_version_13" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_VERSION
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_unsupported_compression_type_13" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_end_all_13" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_END_ALL
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op__cnt_13" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ADMIN_OP__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resource__cnt_13" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESOURCE__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_cdef_13" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_CDEF
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_version_14" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_VERSION
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_unsupported_compression_type_14" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_end_all_14" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_END_ALL
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op__cnt_14" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ADMIN_OP__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resource__cnt_14" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESOURCE__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_cdef_14" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_CDEF
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_version_15" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_VERSION
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_unsupported_compression_type_15" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_end_all_15" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_END_ALL
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op__cnt_15" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ADMIN_OP__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resource__cnt_15" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESOURCE__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_cdef_15" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_CDEF
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_version_16" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_VERSION
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_unsupported_compression_type_16" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_end_all_16" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_END_ALL
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op__cnt_16" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ADMIN_OP__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resource__cnt_16" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESOURCE__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_cdef_16" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_CDEF
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_version_17" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_VERSION
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_unsupported_compression_type_17" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_end_all_17" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_END_ALL
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op__cnt_17" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ADMIN_OP__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resource__cnt_17" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESOURCE__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_cdef_17" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_CDEF
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_version_18" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_VERSION
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_unsupported_compression_type_18" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_end_all_18" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_END_ALL
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op__cnt_18" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ADMIN_OP__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resource__cnt_18" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESOURCE__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_cdef_18" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_CDEF
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_version_19" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_VERSION
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_unsupported_compression_type_19" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_end_all_19" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_END_ALL
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op__cnt_19" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ADMIN_OP__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resource__cnt_19" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESOURCE__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_cdef_19" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_CDEF
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_version_20" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_VERSION
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_unsupported_compression_type_20" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_end_all_20" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_END_ALL
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op__cnt_20" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ADMIN_OP__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resource__cnt_20" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESOURCE__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_cdef_20" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_CDEF
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_version_21" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_VERSION
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_unsupported_compression_type_21" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_end_all_21" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_END_ALL
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op__cnt_21" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ADMIN_OP__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resource__cnt_21" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESOURCE__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_cdef_21" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_CDEF
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_version_22" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_VERSION
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_unsupported_compression_type_22" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_end_all_22" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_END_ALL
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op__cnt_22" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ADMIN_OP__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resource__cnt_22" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESOURCE__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_cdef_22" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_CDEF
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_version_23" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_VERSION
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_unsupported_compression_type_23" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_end_all_23" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_END_ALL
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op__cnt_23" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ADMIN_OP__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resource__cnt_23" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESOURCE__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_cdef_23" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_CDEF
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_version_24" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_VERSION
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_unsupported_compression_type_24" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_end_all_24" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_END_ALL
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op__cnt_24" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ADMIN_OP__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resource__cnt_24" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESOURCE__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_cdef_24" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_CDEF
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_version_25" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_VERSION
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_unsupported_compression_type_25" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_end_all_25" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_END_ALL
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op__cnt_25" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ADMIN_OP__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resource__cnt_25" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESOURCE__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_cdef_25" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_CDEF
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_version_26" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_VERSION
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_unsupported_compression_type_26" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_end_all_26" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_END_ALL
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op__cnt_26" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ADMIN_OP__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resource__cnt_26" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESOURCE__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_cdef_26" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_CDEF
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_version_27" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_VERSION
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_unsupported_compression_type_27" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_end_all_27" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_END_ALL
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op__cnt_27" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ADMIN_OP__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resource__cnt_27" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESOURCE__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_cdef_27" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_CDEF
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_version_28" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_VERSION
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_unsupported_compression_type_28" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_end_all_28" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_END_ALL
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op__cnt_28" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ADMIN_OP__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resource__cnt_28" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESOURCE__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_cdef_28" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_CDEF
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_version_29" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_VERSION
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_unsupported_compression_type_29" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_end_all_29" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_END_ALL
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op__cnt_29" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ADMIN_OP__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resource__cnt_29" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESOURCE__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_cdef_29" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_CDEF
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_version_30" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_VERSION
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_unsupported_compression_type_30" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_end_all_30" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_END_ALL
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op__cnt_30" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ADMIN_OP__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resource__cnt_30" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESOURCE__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_cdef_30" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_CDEF
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_version_31" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_VERSION
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_unsupported_compression_type_31" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_end_all_31" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_END_ALL
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op__cnt_31" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ADMIN_OP__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resource__cnt_31" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESOURCE__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_cdef_31" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_CDEF
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_version_32" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_VERSION
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_unsupported_compression_type_32" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_end_all_32" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_END_ALL
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op__cnt_32" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ADMIN_OP__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resource__cnt_32" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESOURCE__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_cdef_32" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_CDEF
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_version_33" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_VERSION
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_unsupported_compression_type_33" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_end_all_33" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_END_ALL
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op__cnt_33" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ADMIN_OP__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resource__cnt_33" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESOURCE__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_cdef_33" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_CDEF
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_version_34" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_VERSION
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_unsupported_compression_type_34" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_end_all_34" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_END_ALL
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op__cnt_34" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ADMIN_OP__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resource__cnt_34" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESOURCE__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_cdef_34" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_CDEF
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_version_35" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_VERSION
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_unsupported_compression_type_35" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_end_all_35" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESP_ERR_END_ALL
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op__cnt_35" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_ADMIN_OP__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resource__cnt_35" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_RESOURCE__CNT
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_cdef_35" class="md-nav__link">
    <span class="md-ellipsis">
      RD_KAFKA_CDEF
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  

  
  


<h1 id="constants">Constants<a class="headerlink" href="#constants" title="Permanent link">&para;</a></h1>
<h3 id="rd_kafka_log_print">RD_KAFKA_LOG_PRINT<a class="headerlink" href="#rd_kafka_log_print" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_LOG_PRINT</span> <span class="o">=</span> <span class="mi">100</span>
</code></pre></div>
<h3 id="rd_kafka_log_syslog">RD_KAFKA_LOG_SYSLOG<a class="headerlink" href="#rd_kafka_log_syslog" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_LOG_SYSLOG</span> <span class="o">=</span> <span class="mi">101</span>
</code></pre></div>
<h3 id="rd_kafka_log_syslog_print">RD_KAFKA_LOG_SYSLOG_PRINT<a class="headerlink" href="#rd_kafka_log_syslog_print" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_LOG_SYSLOG_PRINT</span> <span class="o">=</span> <span class="mi">102</span>
</code></pre></div>
<h3 id="rd_kafka_msg_partitioner_random">RD_KAFKA_MSG_PARTITIONER_RANDOM<a class="headerlink" href="#rd_kafka_msg_partitioner_random" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_MSG_PARTITIONER_RANDOM</span> <span class="o">=</span> <span class="mi">2</span>
</code></pre></div>
<h3 id="rd_kafka_msg_partitioner_consistent">RD_KAFKA_MSG_PARTITIONER_CONSISTENT<a class="headerlink" href="#rd_kafka_msg_partitioner_consistent" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_MSG_PARTITIONER_CONSISTENT</span> <span class="o">=</span> <span class="mi">3</span>
</code></pre></div>
<h3 id="rd_kafka_msg_partitioner_consistent_random">RD_KAFKA_MSG_PARTITIONER_CONSISTENT_RANDOM<a class="headerlink" href="#rd_kafka_msg_partitioner_consistent_random" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_MSG_PARTITIONER_CONSISTENT_RANDOM</span> <span class="o">=</span> <span class="mi">4</span>
</code></pre></div>
<h3 id="rd_kafka_msg_partitioner_murmur2">RD_KAFKA_MSG_PARTITIONER_MURMUR2<a class="headerlink" href="#rd_kafka_msg_partitioner_murmur2" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_MSG_PARTITIONER_MURMUR2</span> <span class="o">=</span> <span class="mi">5</span>
</code></pre></div>
<h3 id="rd_kafka_msg_partitioner_murmur2_random">RD_KAFKA_MSG_PARTITIONER_MURMUR2_RANDOM<a class="headerlink" href="#rd_kafka_msg_partitioner_murmur2_random" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_MSG_PARTITIONER_MURMUR2_RANDOM</span> <span class="o">=</span> <span class="mi">6</span>
</code></pre></div>
<h3 id="rd_kafka_msg_partitioner_fnv1a">RD_KAFKA_MSG_PARTITIONER_FNV1A<a class="headerlink" href="#rd_kafka_msg_partitioner_fnv1a" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_MSG_PARTITIONER_FNV1A</span> <span class="o">=</span> <span class="mi">7</span>
</code></pre></div>
<h3 id="rd_kafka_msg_partitioner_fnv1a_random">RD_KAFKA_MSG_PARTITIONER_FNV1A_RANDOM<a class="headerlink" href="#rd_kafka_msg_partitioner_fnv1a_random" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_MSG_PARTITIONER_FNV1A_RANDOM</span> <span class="o">=</span> <span class="mi">8</span>
</code></pre></div>
<h3 id="rd_kafka_destroy_f_no_consumer_close">RD_KAFKA_DESTROY_F_NO_CONSUMER_CLOSE<a class="headerlink" href="#rd_kafka_destroy_f_no_consumer_close" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_DESTROY_F_NO_CONSUMER_CLOSE</span> <span class="o">=</span> <span class="mi">8</span>
</code></pre></div>
<p>Flags for rd_kafka_destroy_flags() </p>
<p>Don't call consumer_close() to leave group and commit final offsets.</p>
<p>This also disables consumer callbacks to be called from rd_kafka_destroy*(), such as rebalance_cb.</p>
<p>The consumer group handler is still closed internally, but from an application perspective none of the functionality from consumer_close() is performed. </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#af2a79b2f2bef22e06ed9fade159f42d4"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#af2a79b2f2bef22e06ed9fade159f42d4 </a></li>
</ul>
</div>
<h3 id="rd_kafka_partition_ua">RD_KAFKA_PARTITION_UA<a class="headerlink" href="#rd_kafka_partition_ua" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_PARTITION_UA</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
</code></pre></div>
<p>Unassigned partition. </p>
<p>The unassigned partition is used by the producer API for messages that should be partitioned using the configured or default partitioner. </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a3002d1858385de283ea004893e352863"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a3002d1858385de283ea004893e352863 </a></li>
</ul>
</div>
<h3 id="rd_kafka_offset_beginning">RD_KAFKA_OFFSET_BEGINNING<a class="headerlink" href="#rd_kafka_offset_beginning" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_OFFSET_BEGINNING</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span>
</code></pre></div>
<p>Start consuming from beginning of \ kafka partition queue: oldest msg </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a32dc6dd93c16e3aac9b89804c4817fba"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a32dc6dd93c16e3aac9b89804c4817fba </a></li>
</ul>
</div>
<h3 id="rd_kafka_offset_end">RD_KAFKA_OFFSET_END<a class="headerlink" href="#rd_kafka_offset_end" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_OFFSET_END</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
</code></pre></div>
<p>Start consuming from end of kafka \ partition queue: next msg </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aa7aaaf16e5bd7c0a8a8cb014275c3e06"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aa7aaaf16e5bd7c0a8a8cb014275c3e06 </a></li>
</ul>
</div>
<h3 id="rd_kafka_offset_stored">RD_KAFKA_OFFSET_STORED<a class="headerlink" href="#rd_kafka_offset_stored" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_OFFSET_STORED</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1000</span>
</code></pre></div>
<p>Start consuming from offset retrieved \ from offset store </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a727dc7080140da43adbd5d0b170d49be"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a727dc7080140da43adbd5d0b170d49be </a></li>
</ul>
</div>
<h3 id="rd_kafka_offset_invalid">RD_KAFKA_OFFSET_INVALID<a class="headerlink" href="#rd_kafka_offset_invalid" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_OFFSET_INVALID</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1001</span>
</code></pre></div>
<p>Invalid offset </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ac2e48c4fef9e959ab43cad60ade84af1"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ac2e48c4fef9e959ab43cad60ade84af1 </a></li>
</ul>
</div>
<h3 id="rd_kafka_offset_tail_base">RD_KAFKA_OFFSET_TAIL_BASE<a class="headerlink" href="#rd_kafka_offset_tail_base" title="Permanent link">&para;</a></h3>
<p><div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_OFFSET_TAIL_BASE</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2000</span>
</code></pre></div>
define</p>
<h3 id="rd_kafka_msg_f_free">RD_KAFKA_MSG_F_FREE<a class="headerlink" href="#rd_kafka_msg_f_free" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_MSG_F_FREE</span> <span class="o">=</span> <span class="mi">1</span>
</code></pre></div>
<p>Producer message flags. </p>
<p>Delegate freeing of payload to rdkafka. \ </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a21be13f8a4cb1d5aff01419f333e5ea7"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a21be13f8a4cb1d5aff01419f333e5ea7 </a></li>
</ul>
</div>
<h3 id="rd_kafka_msg_f_copy">RD_KAFKA_MSG_F_COPY<a class="headerlink" href="#rd_kafka_msg_f_copy" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_MSG_F_COPY</span> <span class="o">=</span> <span class="mi">2</span>
</code></pre></div>
<p>rdkafka will make a copy of the payload. \ </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ad7468ab0ece73cc9cb6253a3dcfe702d"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ad7468ab0ece73cc9cb6253a3dcfe702d </a></li>
</ul>
</div>
<h3 id="rd_kafka_msg_f_block">RD_KAFKA_MSG_F_BLOCK<a class="headerlink" href="#rd_kafka_msg_f_block" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_MSG_F_BLOCK</span> <span class="o">=</span> <span class="mi">4</span>
</code></pre></div>
<p>Block produce*() on message queue full. \ WARNING: If a delivery report callback \ is used, the application MUST \ call rd_kafka_poll() (or equiv.) \ to make sure delivered messages \ are drained from the internal \ delivery report queue. \ Failure to do so will result \ in indefinitely blocking on \ the produce() call when the \ message queue is full. </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aca3cdf1c55668f4aa1c2391ddd39c9c2"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aca3cdf1c55668f4aa1c2391ddd39c9c2 </a></li>
</ul>
</div>
<h3 id="rd_kafka_msg_f_partition">RD_KAFKA_MSG_F_PARTITION<a class="headerlink" href="#rd_kafka_msg_f_partition" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_MSG_F_PARTITION</span> <span class="o">=</span> <span class="mi">8</span>
</code></pre></div>
<p>produce_batch() will honor \ per-message partition. </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a991bd9378d2fc5b2102ce3a29805b345"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a991bd9378d2fc5b2102ce3a29805b345 </a></li>
</ul>
</div>
<h3 id="rd_kafka_purge_f_queue">RD_KAFKA_PURGE_F_QUEUE<a class="headerlink" href="#rd_kafka_purge_f_queue" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_PURGE_F_QUEUE</span> <span class="o">=</span> <span class="mi">1</span>
</code></pre></div>
<p>Flags for rd_kafka_purge() </p>
<p>Purge messages in internal queues. </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ad5bcdab21e406a23d50cdb1c68e95a34"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ad5bcdab21e406a23d50cdb1c68e95a34 </a></li>
</ul>
</div>
<h3 id="rd_kafka_purge_f_inflight">RD_KAFKA_PURGE_F_INFLIGHT<a class="headerlink" href="#rd_kafka_purge_f_inflight" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_PURGE_F_INFLIGHT</span> <span class="o">=</span> <span class="mi">2</span>
</code></pre></div>
<p>Purge messages in-flight to or from the broker. Purging these messages will void any future acknowledgements from the broker, making it impossible for the application to know if these messages were successfully delivered or not. Retrying these messages may lead to duplicates. </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#af232512144175a21b5bda2a1fcbe1f00"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#af232512144175a21b5bda2a1fcbe1f00 </a></li>
</ul>
</div>
<h3 id="rd_kafka_purge_f_non_blocking">RD_KAFKA_PURGE_F_NON_BLOCKING<a class="headerlink" href="#rd_kafka_purge_f_non_blocking" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_PURGE_F_NON_BLOCKING</span> <span class="o">=</span> <span class="mi">4</span>
</code></pre></div>
<p>Don't wait for background thread queue purging to finish. </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aef197fd7fd6dfa02d70563e359b8281f"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aef197fd7fd6dfa02d70563e359b8281f </a></li>
</ul>
</div>
<h3 id="rd_kafka_event_none">RD_KAFKA_EVENT_NONE<a class="headerlink" href="#rd_kafka_event_none" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_EVENT_NONE</span> <span class="o">=</span> <span class="mi">0</span>
</code></pre></div>
<p>Unset value </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aa2707dd1a6225e7649fd5d825284da4d"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aa2707dd1a6225e7649fd5d825284da4d </a></li>
</ul>
</div>
<h3 id="rd_kafka_event_dr">RD_KAFKA_EVENT_DR<a class="headerlink" href="#rd_kafka_event_dr" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_EVENT_DR</span> <span class="o">=</span> <span class="mi">1</span>
</code></pre></div>
<p>Producer Delivery report batch </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#abfe880d05ff52138b26dbe8b8e0d2132"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#abfe880d05ff52138b26dbe8b8e0d2132 </a></li>
</ul>
</div>
<h3 id="rd_kafka_event_fetch">RD_KAFKA_EVENT_FETCH<a class="headerlink" href="#rd_kafka_event_fetch" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_EVENT_FETCH</span> <span class="o">=</span> <span class="mi">2</span>
</code></pre></div>
<p>Fetched message (consumer) </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#acfddfd9f3d49591dcd9e7f323dbcd865"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#acfddfd9f3d49591dcd9e7f323dbcd865 </a></li>
</ul>
</div>
<h3 id="rd_kafka_event_log">RD_KAFKA_EVENT_LOG<a class="headerlink" href="#rd_kafka_event_log" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_EVENT_LOG</span> <span class="o">=</span> <span class="mi">4</span>
</code></pre></div>
<p>Log message </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a6265a9eeee57e83eb9f3bbd33d92700f"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a6265a9eeee57e83eb9f3bbd33d92700f </a></li>
</ul>
</div>
<h3 id="rd_kafka_event_error">RD_KAFKA_EVENT_ERROR<a class="headerlink" href="#rd_kafka_event_error" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_EVENT_ERROR</span> <span class="o">=</span> <span class="mi">8</span>
</code></pre></div>
<p>Error </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a080a7ad60de643f47424031ee95da103"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a080a7ad60de643f47424031ee95da103 </a></li>
</ul>
</div>
<h3 id="rd_kafka_event_rebalance">RD_KAFKA_EVENT_REBALANCE<a class="headerlink" href="#rd_kafka_event_rebalance" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_EVENT_REBALANCE</span> <span class="o">=</span> <span class="mi">16</span>
</code></pre></div>
<p>Group rebalance (consumer) </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a271e6a5984932015585dd5248535aa2b"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a271e6a5984932015585dd5248535aa2b </a></li>
</ul>
</div>
<h3 id="rd_kafka_event_offset_commit">RD_KAFKA_EVENT_OFFSET_COMMIT<a class="headerlink" href="#rd_kafka_event_offset_commit" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_EVENT_OFFSET_COMMIT</span> <span class="o">=</span> <span class="mi">32</span>
</code></pre></div>
<p>Offset commit result </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a73a29f22b22433a93253a5f77c866437"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a73a29f22b22433a93253a5f77c866437 </a></li>
</ul>
</div>
<h3 id="rd_kafka_event_stats">RD_KAFKA_EVENT_STATS<a class="headerlink" href="#rd_kafka_event_stats" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_EVENT_STATS</span> <span class="o">=</span> <span class="mi">64</span>
</code></pre></div>
<p>Stats </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a67070a77150f54039273097c57da5965"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a67070a77150f54039273097c57da5965 </a></li>
</ul>
</div>
<h3 id="rd_kafka_event_createtopics_result">RD_KAFKA_EVENT_CREATETOPICS_RESULT<a class="headerlink" href="#rd_kafka_event_createtopics_result" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_EVENT_CREATETOPICS_RESULT</span> <span class="o">=</span> <span class="mi">100</span>
</code></pre></div>
<p>CreateTopics_result_t </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ae0622aab30c391aed6c8b57d1aa5d0a8"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ae0622aab30c391aed6c8b57d1aa5d0a8 </a></li>
</ul>
</div>
<h3 id="rd_kafka_event_deletetopics_result">RD_KAFKA_EVENT_DELETETOPICS_RESULT<a class="headerlink" href="#rd_kafka_event_deletetopics_result" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_EVENT_DELETETOPICS_RESULT</span> <span class="o">=</span> <span class="mi">101</span>
</code></pre></div>
<p>DeleteTopics_result_t </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#af69b2889c6e9cc2ebb03c607efade311"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#af69b2889c6e9cc2ebb03c607efade311 </a></li>
</ul>
</div>
<h3 id="rd_kafka_event_createpartitions_result">RD_KAFKA_EVENT_CREATEPARTITIONS_RESULT<a class="headerlink" href="#rd_kafka_event_createpartitions_result" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_EVENT_CREATEPARTITIONS_RESULT</span> <span class="o">=</span> <span class="mi">102</span>
</code></pre></div>
<p>CreatePartitions_result_t </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a82de17d7d0eb7ac80761a35695b1f971"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a82de17d7d0eb7ac80761a35695b1f971 </a></li>
</ul>
</div>
<h3 id="rd_kafka_event_alterconfigs_result">RD_KAFKA_EVENT_ALTERCONFIGS_RESULT<a class="headerlink" href="#rd_kafka_event_alterconfigs_result" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_EVENT_ALTERCONFIGS_RESULT</span> <span class="o">=</span> <span class="mi">103</span>
</code></pre></div>
<p>AlterConfigs_result_t </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a25ded37b0459f4207e033ead15d30909"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a25ded37b0459f4207e033ead15d30909 </a></li>
</ul>
</div>
<h3 id="rd_kafka_event_describeconfigs_result">RD_KAFKA_EVENT_DESCRIBECONFIGS_RESULT<a class="headerlink" href="#rd_kafka_event_describeconfigs_result" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_EVENT_DESCRIBECONFIGS_RESULT</span> <span class="o">=</span> <span class="mi">104</span>
</code></pre></div>
<p>DescribeConfigs_result_t </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a5918e726a9b2828c3051e48d6a747259"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a5918e726a9b2828c3051e48d6a747259 </a></li>
</ul>
</div>
<h3 id="rd_kafka_producer">RD_KAFKA_PRODUCER<a class="headerlink" href="#rd_kafka_producer" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_PRODUCER</span> <span class="o">=</span> <span class="mi">0</span>
</code></pre></div>
<p>Producer client </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ac6f9c3cb01cbaf3013689c4f2731b831"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ac6f9c3cb01cbaf3013689c4f2731b831 </a></li>
</ul>
</div>
<h3 id="rd_kafka_consumer">RD_KAFKA_CONSUMER<a class="headerlink" href="#rd_kafka_consumer" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_CONSUMER</span> <span class="o">=</span> <span class="mi">1</span>
</code></pre></div>
<p>Consumer client </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ac6f9c3cb01cbaf3013689c4f2731b831"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ac6f9c3cb01cbaf3013689c4f2731b831 </a></li>
</ul>
</div>
<h3 id="rd_kafka_timestamp_not_available">RD_KAFKA_TIMESTAMP_NOT_AVAILABLE<a class="headerlink" href="#rd_kafka_timestamp_not_available" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_TIMESTAMP_NOT_AVAILABLE</span> <span class="o">=</span> <span class="mi">0</span>
</code></pre></div>
<p>Timestamp not available </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#af7cb459a230a61489234823da2beb3f3"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#af7cb459a230a61489234823da2beb3f3 </a></li>
</ul>
</div>
<h3 id="rd_kafka_timestamp_create_time">RD_KAFKA_TIMESTAMP_CREATE_TIME<a class="headerlink" href="#rd_kafka_timestamp_create_time" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_TIMESTAMP_CREATE_TIME</span> <span class="o">=</span> <span class="mi">1</span>
</code></pre></div>
<p>Message creation time </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#af7cb459a230a61489234823da2beb3f3"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#af7cb459a230a61489234823da2beb3f3 </a></li>
</ul>
</div>
<h3 id="rd_kafka_timestamp_log_append_time">RD_KAFKA_TIMESTAMP_LOG_APPEND_TIME<a class="headerlink" href="#rd_kafka_timestamp_log_append_time" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_TIMESTAMP_LOG_APPEND_TIME</span> <span class="o">=</span> <span class="mi">2</span>
</code></pre></div>
<p>Log append time </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#af7cb459a230a61489234823da2beb3f3"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#af7cb459a230a61489234823da2beb3f3 </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err__begin">RD_KAFKA_RESP_ERR__BEGIN<a class="headerlink" href="#rd_kafka_resp_err__begin" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR__BEGIN</span> <span class="o">=</span> <span class="o">-</span><span class="mi">200</span>
</code></pre></div>
<p>Begin internal error codes </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err__bad_msg">RD_KAFKA_RESP_ERR__BAD_MSG<a class="headerlink" href="#rd_kafka_resp_err__bad_msg" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR__BAD_MSG</span> <span class="o">=</span> <span class="o">-</span><span class="mi">199</span>
</code></pre></div>
<p>Received message is incorrect </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err__bad_compression">RD_KAFKA_RESP_ERR__BAD_COMPRESSION<a class="headerlink" href="#rd_kafka_resp_err__bad_compression" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR__BAD_COMPRESSION</span> <span class="o">=</span> <span class="o">-</span><span class="mi">198</span>
</code></pre></div>
<p>Bad/unknown compression </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err__destroy">RD_KAFKA_RESP_ERR__DESTROY<a class="headerlink" href="#rd_kafka_resp_err__destroy" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR__DESTROY</span> <span class="o">=</span> <span class="o">-</span><span class="mi">197</span>
</code></pre></div>
<p>Broker is going away </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err__fail">RD_KAFKA_RESP_ERR__FAIL<a class="headerlink" href="#rd_kafka_resp_err__fail" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR__FAIL</span> <span class="o">=</span> <span class="o">-</span><span class="mi">196</span>
</code></pre></div>
<p>Generic failure </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err__transport">RD_KAFKA_RESP_ERR__TRANSPORT<a class="headerlink" href="#rd_kafka_resp_err__transport" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR__TRANSPORT</span> <span class="o">=</span> <span class="o">-</span><span class="mi">195</span>
</code></pre></div>
<p>Broker transport failure </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err__crit_sys_resource">RD_KAFKA_RESP_ERR__CRIT_SYS_RESOURCE<a class="headerlink" href="#rd_kafka_resp_err__crit_sys_resource" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR__CRIT_SYS_RESOURCE</span> <span class="o">=</span> <span class="o">-</span><span class="mi">194</span>
</code></pre></div>
<p>Critical system resource </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err__resolve">RD_KAFKA_RESP_ERR__RESOLVE<a class="headerlink" href="#rd_kafka_resp_err__resolve" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR__RESOLVE</span> <span class="o">=</span> <span class="o">-</span><span class="mi">193</span>
</code></pre></div>
<p>Failed to resolve broker </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err__msg_timed_out">RD_KAFKA_RESP_ERR__MSG_TIMED_OUT<a class="headerlink" href="#rd_kafka_resp_err__msg_timed_out" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR__MSG_TIMED_OUT</span> <span class="o">=</span> <span class="o">-</span><span class="mi">192</span>
</code></pre></div>
<p>Produced message timed out </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err__partition_eof">RD_KAFKA_RESP_ERR__PARTITION_EOF<a class="headerlink" href="#rd_kafka_resp_err__partition_eof" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR__PARTITION_EOF</span> <span class="o">=</span> <span class="o">-</span><span class="mi">191</span>
</code></pre></div>
<p>Reached the end of the topic+partition queue on the broker. Not really an error. This event is disabled by default, see the <code>enable.partition.eof</code> configuration property. </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err__unknown_partition">RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION<a class="headerlink" href="#rd_kafka_resp_err__unknown_partition" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION</span> <span class="o">=</span> <span class="o">-</span><span class="mi">190</span>
</code></pre></div>
<p>Permanent: Partition does not exist in cluster. </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err__fs">RD_KAFKA_RESP_ERR__FS<a class="headerlink" href="#rd_kafka_resp_err__fs" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR__FS</span> <span class="o">=</span> <span class="o">-</span><span class="mi">189</span>
</code></pre></div>
<p>File or filesystem error </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err__unknown_topic">RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC<a class="headerlink" href="#rd_kafka_resp_err__unknown_topic" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC</span> <span class="o">=</span> <span class="o">-</span><span class="mi">188</span>
</code></pre></div>
<p>Permanent: Topic does not exist in cluster. </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err__all_brokers_down">RD_KAFKA_RESP_ERR__ALL_BROKERS_DOWN<a class="headerlink" href="#rd_kafka_resp_err__all_brokers_down" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR__ALL_BROKERS_DOWN</span> <span class="o">=</span> <span class="o">-</span><span class="mi">187</span>
</code></pre></div>
<p>All broker connections are down. </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err__invalid_arg">RD_KAFKA_RESP_ERR__INVALID_ARG<a class="headerlink" href="#rd_kafka_resp_err__invalid_arg" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR__INVALID_ARG</span> <span class="o">=</span> <span class="o">-</span><span class="mi">186</span>
</code></pre></div>
<p>Invalid argument, or invalid configuration </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err__timed_out">RD_KAFKA_RESP_ERR__TIMED_OUT<a class="headerlink" href="#rd_kafka_resp_err__timed_out" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR__TIMED_OUT</span> <span class="o">=</span> <span class="o">-</span><span class="mi">185</span>
</code></pre></div>
<p>Operation timed out </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err__queue_full">RD_KAFKA_RESP_ERR__QUEUE_FULL<a class="headerlink" href="#rd_kafka_resp_err__queue_full" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR__QUEUE_FULL</span> <span class="o">=</span> <span class="o">-</span><span class="mi">184</span>
</code></pre></div>
<p>Queue is full </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err__isr_insuff">RD_KAFKA_RESP_ERR__ISR_INSUFF<a class="headerlink" href="#rd_kafka_resp_err__isr_insuff" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR__ISR_INSUFF</span> <span class="o">=</span> <span class="o">-</span><span class="mi">183</span>
</code></pre></div>
<p>ISR count &lt; required.acks </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err__node_update">RD_KAFKA_RESP_ERR__NODE_UPDATE<a class="headerlink" href="#rd_kafka_resp_err__node_update" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR__NODE_UPDATE</span> <span class="o">=</span> <span class="o">-</span><span class="mi">182</span>
</code></pre></div>
<p>Broker node update </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err__ssl">RD_KAFKA_RESP_ERR__SSL<a class="headerlink" href="#rd_kafka_resp_err__ssl" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR__SSL</span> <span class="o">=</span> <span class="o">-</span><span class="mi">181</span>
</code></pre></div>
<p>SSL error </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err__wait_coord">RD_KAFKA_RESP_ERR__WAIT_COORD<a class="headerlink" href="#rd_kafka_resp_err__wait_coord" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR__WAIT_COORD</span> <span class="o">=</span> <span class="o">-</span><span class="mi">180</span>
</code></pre></div>
<p>Waiting for coordinator to become available. </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err__unknown_group">RD_KAFKA_RESP_ERR__UNKNOWN_GROUP<a class="headerlink" href="#rd_kafka_resp_err__unknown_group" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR__UNKNOWN_GROUP</span> <span class="o">=</span> <span class="o">-</span><span class="mi">179</span>
</code></pre></div>
<p>Unknown client group </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err__in_progress">RD_KAFKA_RESP_ERR__IN_PROGRESS<a class="headerlink" href="#rd_kafka_resp_err__in_progress" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR__IN_PROGRESS</span> <span class="o">=</span> <span class="o">-</span><span class="mi">178</span>
</code></pre></div>
<p>Operation in progress </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err__prev_in_progress">RD_KAFKA_RESP_ERR__PREV_IN_PROGRESS<a class="headerlink" href="#rd_kafka_resp_err__prev_in_progress" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR__PREV_IN_PROGRESS</span> <span class="o">=</span> <span class="o">-</span><span class="mi">177</span>
</code></pre></div>
<p>Previous operation in progress, wait for it to finish. </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err__existing_subscription">RD_KAFKA_RESP_ERR__EXISTING_SUBSCRIPTION<a class="headerlink" href="#rd_kafka_resp_err__existing_subscription" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR__EXISTING_SUBSCRIPTION</span> <span class="o">=</span> <span class="o">-</span><span class="mi">176</span>
</code></pre></div>
<p>This operation would interfere with an existing subscription </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err__assign_partitions">RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS<a class="headerlink" href="#rd_kafka_resp_err__assign_partitions" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS</span> <span class="o">=</span> <span class="o">-</span><span class="mi">175</span>
</code></pre></div>
<p>Assigned partitions (rebalance_cb) </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err__revoke_partitions">RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS<a class="headerlink" href="#rd_kafka_resp_err__revoke_partitions" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS</span> <span class="o">=</span> <span class="o">-</span><span class="mi">174</span>
</code></pre></div>
<p>Revoked partitions (rebalance_cb) </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err__conflict">RD_KAFKA_RESP_ERR__CONFLICT<a class="headerlink" href="#rd_kafka_resp_err__conflict" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR__CONFLICT</span> <span class="o">=</span> <span class="o">-</span><span class="mi">173</span>
</code></pre></div>
<p>Conflicting use </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err__state">RD_KAFKA_RESP_ERR__STATE<a class="headerlink" href="#rd_kafka_resp_err__state" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR__STATE</span> <span class="o">=</span> <span class="o">-</span><span class="mi">172</span>
</code></pre></div>
<p>Wrong state </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err__unknown_protocol">RD_KAFKA_RESP_ERR__UNKNOWN_PROTOCOL<a class="headerlink" href="#rd_kafka_resp_err__unknown_protocol" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR__UNKNOWN_PROTOCOL</span> <span class="o">=</span> <span class="o">-</span><span class="mi">171</span>
</code></pre></div>
<p>Unknown protocol </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err__not_implemented">RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED<a class="headerlink" href="#rd_kafka_resp_err__not_implemented" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED</span> <span class="o">=</span> <span class="o">-</span><span class="mi">170</span>
</code></pre></div>
<p>Not implemented </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err__authentication">RD_KAFKA_RESP_ERR__AUTHENTICATION<a class="headerlink" href="#rd_kafka_resp_err__authentication" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR__AUTHENTICATION</span> <span class="o">=</span> <span class="o">-</span><span class="mi">169</span>
</code></pre></div>
<p>Authentication failure </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err__no_offset">RD_KAFKA_RESP_ERR__NO_OFFSET<a class="headerlink" href="#rd_kafka_resp_err__no_offset" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR__NO_OFFSET</span> <span class="o">=</span> <span class="o">-</span><span class="mi">168</span>
</code></pre></div>
<p>No stored offset </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err__outdated">RD_KAFKA_RESP_ERR__OUTDATED<a class="headerlink" href="#rd_kafka_resp_err__outdated" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR__OUTDATED</span> <span class="o">=</span> <span class="o">-</span><span class="mi">167</span>
</code></pre></div>
<p>Outdated </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err__timed_out_queue">RD_KAFKA_RESP_ERR__TIMED_OUT_QUEUE<a class="headerlink" href="#rd_kafka_resp_err__timed_out_queue" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR__TIMED_OUT_QUEUE</span> <span class="o">=</span> <span class="o">-</span><span class="mi">166</span>
</code></pre></div>
<p>Timed out in queue </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err__unsupported_feature">RD_KAFKA_RESP_ERR__UNSUPPORTED_FEATURE<a class="headerlink" href="#rd_kafka_resp_err__unsupported_feature" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR__UNSUPPORTED_FEATURE</span> <span class="o">=</span> <span class="o">-</span><span class="mi">165</span>
</code></pre></div>
<p>Feature not supported by broker </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err__wait_cache">RD_KAFKA_RESP_ERR__WAIT_CACHE<a class="headerlink" href="#rd_kafka_resp_err__wait_cache" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR__WAIT_CACHE</span> <span class="o">=</span> <span class="o">-</span><span class="mi">164</span>
</code></pre></div>
<p>Awaiting cache update </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err__intr">RD_KAFKA_RESP_ERR__INTR<a class="headerlink" href="#rd_kafka_resp_err__intr" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR__INTR</span> <span class="o">=</span> <span class="o">-</span><span class="mi">163</span>
</code></pre></div>
<p>Operation interrupted (e.g., due to yield)) </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err__key_serialization">RD_KAFKA_RESP_ERR__KEY_SERIALIZATION<a class="headerlink" href="#rd_kafka_resp_err__key_serialization" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR__KEY_SERIALIZATION</span> <span class="o">=</span> <span class="o">-</span><span class="mi">162</span>
</code></pre></div>
<p>Key serialization error </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err__value_serialization">RD_KAFKA_RESP_ERR__VALUE_SERIALIZATION<a class="headerlink" href="#rd_kafka_resp_err__value_serialization" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR__VALUE_SERIALIZATION</span> <span class="o">=</span> <span class="o">-</span><span class="mi">161</span>
</code></pre></div>
<p>Value serialization error </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err__key_deserialization">RD_KAFKA_RESP_ERR__KEY_DESERIALIZATION<a class="headerlink" href="#rd_kafka_resp_err__key_deserialization" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR__KEY_DESERIALIZATION</span> <span class="o">=</span> <span class="o">-</span><span class="mi">160</span>
</code></pre></div>
<p>Key deserialization error </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err__value_deserialization">RD_KAFKA_RESP_ERR__VALUE_DESERIALIZATION<a class="headerlink" href="#rd_kafka_resp_err__value_deserialization" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR__VALUE_DESERIALIZATION</span> <span class="o">=</span> <span class="o">-</span><span class="mi">159</span>
</code></pre></div>
<p>Value deserialization error </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err__partial">RD_KAFKA_RESP_ERR__PARTIAL<a class="headerlink" href="#rd_kafka_resp_err__partial" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR__PARTIAL</span> <span class="o">=</span> <span class="o">-</span><span class="mi">158</span>
</code></pre></div>
<p>Partial response </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err__read_only">RD_KAFKA_RESP_ERR__READ_ONLY<a class="headerlink" href="#rd_kafka_resp_err__read_only" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR__READ_ONLY</span> <span class="o">=</span> <span class="o">-</span><span class="mi">157</span>
</code></pre></div>
<p>Modification attempted on read-only object </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err__noent">RD_KAFKA_RESP_ERR__NOENT<a class="headerlink" href="#rd_kafka_resp_err__noent" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR__NOENT</span> <span class="o">=</span> <span class="o">-</span><span class="mi">156</span>
</code></pre></div>
<p>No such entry / item not found </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err__underflow">RD_KAFKA_RESP_ERR__UNDERFLOW<a class="headerlink" href="#rd_kafka_resp_err__underflow" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR__UNDERFLOW</span> <span class="o">=</span> <span class="o">-</span><span class="mi">155</span>
</code></pre></div>
<p>Read underflow </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err__invalid_type">RD_KAFKA_RESP_ERR__INVALID_TYPE<a class="headerlink" href="#rd_kafka_resp_err__invalid_type" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR__INVALID_TYPE</span> <span class="o">=</span> <span class="o">-</span><span class="mi">154</span>
</code></pre></div>
<p>Invalid type </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err__retry">RD_KAFKA_RESP_ERR__RETRY<a class="headerlink" href="#rd_kafka_resp_err__retry" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR__RETRY</span> <span class="o">=</span> <span class="o">-</span><span class="mi">153</span>
</code></pre></div>
<p>Retry operation </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err__purge_queue">RD_KAFKA_RESP_ERR__PURGE_QUEUE<a class="headerlink" href="#rd_kafka_resp_err__purge_queue" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR__PURGE_QUEUE</span> <span class="o">=</span> <span class="o">-</span><span class="mi">152</span>
</code></pre></div>
<p>Purged in queue </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err__purge_inflight">RD_KAFKA_RESP_ERR__PURGE_INFLIGHT<a class="headerlink" href="#rd_kafka_resp_err__purge_inflight" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR__PURGE_INFLIGHT</span> <span class="o">=</span> <span class="o">-</span><span class="mi">151</span>
</code></pre></div>
<p>Purged in flight </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err__fatal">RD_KAFKA_RESP_ERR__FATAL<a class="headerlink" href="#rd_kafka_resp_err__fatal" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR__FATAL</span> <span class="o">=</span> <span class="o">-</span><span class="mi">150</span>
</code></pre></div>
<p>Fatal error: see rd_kafka_fatal_error() </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err__inconsistent">RD_KAFKA_RESP_ERR__INCONSISTENT<a class="headerlink" href="#rd_kafka_resp_err__inconsistent" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR__INCONSISTENT</span> <span class="o">=</span> <span class="o">-</span><span class="mi">149</span>
</code></pre></div>
<p>Inconsistent state </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err__gapless_guarantee">RD_KAFKA_RESP_ERR__GAPLESS_GUARANTEE<a class="headerlink" href="#rd_kafka_resp_err__gapless_guarantee" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR__GAPLESS_GUARANTEE</span> <span class="o">=</span> <span class="o">-</span><span class="mi">148</span>
</code></pre></div>
<p>Gap-less ordering would not be guaranteed if proceeding </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err__max_poll_exceeded">RD_KAFKA_RESP_ERR__MAX_POLL_EXCEEDED<a class="headerlink" href="#rd_kafka_resp_err__max_poll_exceeded" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR__MAX_POLL_EXCEEDED</span> <span class="o">=</span> <span class="o">-</span><span class="mi">147</span>
</code></pre></div>
<p>Maximum poll interval exceeded </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err__end">RD_KAFKA_RESP_ERR__END<a class="headerlink" href="#rd_kafka_resp_err__end" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR__END</span> <span class="o">=</span> <span class="o">-</span><span class="mi">100</span>
</code></pre></div>
<p>End internal error codes </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_unknown">RD_KAFKA_RESP_ERR_UNKNOWN<a class="headerlink" href="#rd_kafka_resp_err_unknown" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_UNKNOWN</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
</code></pre></div>
<p>Unknown broker error </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_no_error">RD_KAFKA_RESP_ERR_NO_ERROR<a class="headerlink" href="#rd_kafka_resp_err_no_error" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_NO_ERROR</span> <span class="o">=</span> <span class="mi">0</span>
</code></pre></div>
<p>Success </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_offset_out_of_range">RD_KAFKA_RESP_ERR_OFFSET_OUT_OF_RANGE<a class="headerlink" href="#rd_kafka_resp_err_offset_out_of_range" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_OFFSET_OUT_OF_RANGE</span> <span class="o">=</span> <span class="mi">1</span>
</code></pre></div>
<p>Offset out of range </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_invalid_msg">RD_KAFKA_RESP_ERR_INVALID_MSG<a class="headerlink" href="#rd_kafka_resp_err_invalid_msg" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_INVALID_MSG</span> <span class="o">=</span> <span class="mi">2</span>
</code></pre></div>
<p>Invalid message </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_unknown_topic_or_part">RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART<a class="headerlink" href="#rd_kafka_resp_err_unknown_topic_or_part" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART</span> <span class="o">=</span> <span class="mi">3</span>
</code></pre></div>
<p>Unknown topic or partition </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_invalid_msg_size">RD_KAFKA_RESP_ERR_INVALID_MSG_SIZE<a class="headerlink" href="#rd_kafka_resp_err_invalid_msg_size" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_INVALID_MSG_SIZE</span> <span class="o">=</span> <span class="mi">4</span>
</code></pre></div>
<p>Invalid message size </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_leader_not_available">RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE<a class="headerlink" href="#rd_kafka_resp_err_leader_not_available" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE</span> <span class="o">=</span> <span class="mi">5</span>
</code></pre></div>
<p>Leader not available </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_not_leader_for_partition">RD_KAFKA_RESP_ERR_NOT_LEADER_FOR_PARTITION<a class="headerlink" href="#rd_kafka_resp_err_not_leader_for_partition" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_NOT_LEADER_FOR_PARTITION</span> <span class="o">=</span> <span class="mi">6</span>
</code></pre></div>
<p>Not leader for partition </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ad4aa22eb292d320e5155c6cec9de4c43"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ad4aa22eb292d320e5155c6cec9de4c43 </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_request_timed_out">RD_KAFKA_RESP_ERR_REQUEST_TIMED_OUT<a class="headerlink" href="#rd_kafka_resp_err_request_timed_out" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_REQUEST_TIMED_OUT</span> <span class="o">=</span> <span class="mi">7</span>
</code></pre></div>
<p>Request timed out </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_broker_not_available">RD_KAFKA_RESP_ERR_BROKER_NOT_AVAILABLE<a class="headerlink" href="#rd_kafka_resp_err_broker_not_available" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_BROKER_NOT_AVAILABLE</span> <span class="o">=</span> <span class="mi">8</span>
</code></pre></div>
<p>Broker not available </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_replica_not_available">RD_KAFKA_RESP_ERR_REPLICA_NOT_AVAILABLE<a class="headerlink" href="#rd_kafka_resp_err_replica_not_available" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_REPLICA_NOT_AVAILABLE</span> <span class="o">=</span> <span class="mi">9</span>
</code></pre></div>
<p>Replica not available </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_msg_size_too_large">RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE<a class="headerlink" href="#rd_kafka_resp_err_msg_size_too_large" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE</span> <span class="o">=</span> <span class="mi">10</span>
</code></pre></div>
<p>Message size too large </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_stale_ctrl_epoch">RD_KAFKA_RESP_ERR_STALE_CTRL_EPOCH<a class="headerlink" href="#rd_kafka_resp_err_stale_ctrl_epoch" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_STALE_CTRL_EPOCH</span> <span class="o">=</span> <span class="mi">11</span>
</code></pre></div>
<p>StaleControllerEpochCode </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_offset_metadata_too_large">RD_KAFKA_RESP_ERR_OFFSET_METADATA_TOO_LARGE<a class="headerlink" href="#rd_kafka_resp_err_offset_metadata_too_large" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_OFFSET_METADATA_TOO_LARGE</span> <span class="o">=</span> <span class="mi">12</span>
</code></pre></div>
<p>Offset metadata string too large </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_network_exception">RD_KAFKA_RESP_ERR_NETWORK_EXCEPTION<a class="headerlink" href="#rd_kafka_resp_err_network_exception" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_NETWORK_EXCEPTION</span> <span class="o">=</span> <span class="mi">13</span>
</code></pre></div>
<p>Broker disconnected before response received </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_group_load_in_progress">RD_KAFKA_RESP_ERR_GROUP_LOAD_IN_PROGRESS<a class="headerlink" href="#rd_kafka_resp_err_group_load_in_progress" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_GROUP_LOAD_IN_PROGRESS</span> <span class="o">=</span> <span class="mi">14</span>
</code></pre></div>
<p>Group coordinator load in progress </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#afa695eee077bfd031e5bb637b899cfd8"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#afa695eee077bfd031e5bb637b899cfd8 </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_group_coordinator_not_available">RD_KAFKA_RESP_ERR_GROUP_COORDINATOR_NOT_AVAILABLE<a class="headerlink" href="#rd_kafka_resp_err_group_coordinator_not_available" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_GROUP_COORDINATOR_NOT_AVAILABLE</span> <span class="o">=</span> <span class="mi">15</span>
</code></pre></div>
<p>Group coordinator not available </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a23a154df5190e1fc072199737f39bd87"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a23a154df5190e1fc072199737f39bd87 </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_not_coordinator_for_group">RD_KAFKA_RESP_ERR_NOT_COORDINATOR_FOR_GROUP<a class="headerlink" href="#rd_kafka_resp_err_not_coordinator_for_group" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_NOT_COORDINATOR_FOR_GROUP</span> <span class="o">=</span> <span class="mi">16</span>
</code></pre></div>
<p>Not coordinator for group </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a7755c1901da130a937be67a1c66e2c1f"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a7755c1901da130a937be67a1c66e2c1f </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_topic_exception">RD_KAFKA_RESP_ERR_TOPIC_EXCEPTION<a class="headerlink" href="#rd_kafka_resp_err_topic_exception" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_TOPIC_EXCEPTION</span> <span class="o">=</span> <span class="mi">17</span>
</code></pre></div>
<p>Invalid topic </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_record_list_too_large">RD_KAFKA_RESP_ERR_RECORD_LIST_TOO_LARGE<a class="headerlink" href="#rd_kafka_resp_err_record_list_too_large" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_RECORD_LIST_TOO_LARGE</span> <span class="o">=</span> <span class="mi">18</span>
</code></pre></div>
<p>Message batch larger than configured server segment size </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_not_enough_replicas">RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS<a class="headerlink" href="#rd_kafka_resp_err_not_enough_replicas" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS</span> <span class="o">=</span> <span class="mi">19</span>
</code></pre></div>
<p>Not enough in-sync replicas </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_not_enough_replicas_after_append">RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS_AFTER_APPEND<a class="headerlink" href="#rd_kafka_resp_err_not_enough_replicas_after_append" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS_AFTER_APPEND</span> <span class="o">=</span> <span class="mi">20</span>
</code></pre></div>
<p>Message(s) written to insufficient number of in-sync replicas </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_invalid_required_acks">RD_KAFKA_RESP_ERR_INVALID_REQUIRED_ACKS<a class="headerlink" href="#rd_kafka_resp_err_invalid_required_acks" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_INVALID_REQUIRED_ACKS</span> <span class="o">=</span> <span class="mi">21</span>
</code></pre></div>
<p>Invalid required acks value </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_illegal_generation">RD_KAFKA_RESP_ERR_ILLEGAL_GENERATION<a class="headerlink" href="#rd_kafka_resp_err_illegal_generation" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_ILLEGAL_GENERATION</span> <span class="o">=</span> <span class="mi">22</span>
</code></pre></div>
<p>Specified group generation id is not valid </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_inconsistent_group_protocol">RD_KAFKA_RESP_ERR_INCONSISTENT_GROUP_PROTOCOL<a class="headerlink" href="#rd_kafka_resp_err_inconsistent_group_protocol" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_INCONSISTENT_GROUP_PROTOCOL</span> <span class="o">=</span> <span class="mi">23</span>
</code></pre></div>
<p>Inconsistent group protocol </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_invalid_group_id">RD_KAFKA_RESP_ERR_INVALID_GROUP_ID<a class="headerlink" href="#rd_kafka_resp_err_invalid_group_id" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_INVALID_GROUP_ID</span> <span class="o">=</span> <span class="mi">24</span>
</code></pre></div>
<p>Invalid group.id </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_unknown_member_id">RD_KAFKA_RESP_ERR_UNKNOWN_MEMBER_ID<a class="headerlink" href="#rd_kafka_resp_err_unknown_member_id" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_UNKNOWN_MEMBER_ID</span> <span class="o">=</span> <span class="mi">25</span>
</code></pre></div>
<p>Unknown member </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_invalid_session_timeout">RD_KAFKA_RESP_ERR_INVALID_SESSION_TIMEOUT<a class="headerlink" href="#rd_kafka_resp_err_invalid_session_timeout" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_INVALID_SESSION_TIMEOUT</span> <span class="o">=</span> <span class="mi">26</span>
</code></pre></div>
<p>Invalid session timeout </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_rebalance_in_progress">RD_KAFKA_RESP_ERR_REBALANCE_IN_PROGRESS<a class="headerlink" href="#rd_kafka_resp_err_rebalance_in_progress" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_REBALANCE_IN_PROGRESS</span> <span class="o">=</span> <span class="mi">27</span>
</code></pre></div>
<p>Group rebalance in progress </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_invalid_commit_offset_size">RD_KAFKA_RESP_ERR_INVALID_COMMIT_OFFSET_SIZE<a class="headerlink" href="#rd_kafka_resp_err_invalid_commit_offset_size" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_INVALID_COMMIT_OFFSET_SIZE</span> <span class="o">=</span> <span class="mi">28</span>
</code></pre></div>
<p>Commit offset data size is not valid </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_topic_authorization_failed">RD_KAFKA_RESP_ERR_TOPIC_AUTHORIZATION_FAILED<a class="headerlink" href="#rd_kafka_resp_err_topic_authorization_failed" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_TOPIC_AUTHORIZATION_FAILED</span> <span class="o">=</span> <span class="mi">29</span>
</code></pre></div>
<p>Topic authorization failed </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_group_authorization_failed">RD_KAFKA_RESP_ERR_GROUP_AUTHORIZATION_FAILED<a class="headerlink" href="#rd_kafka_resp_err_group_authorization_failed" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_GROUP_AUTHORIZATION_FAILED</span> <span class="o">=</span> <span class="mi">30</span>
</code></pre></div>
<p>Group authorization failed </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_cluster_authorization_failed">RD_KAFKA_RESP_ERR_CLUSTER_AUTHORIZATION_FAILED<a class="headerlink" href="#rd_kafka_resp_err_cluster_authorization_failed" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_CLUSTER_AUTHORIZATION_FAILED</span> <span class="o">=</span> <span class="mi">31</span>
</code></pre></div>
<p>Cluster authorization failed </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_invalid_timestamp">RD_KAFKA_RESP_ERR_INVALID_TIMESTAMP<a class="headerlink" href="#rd_kafka_resp_err_invalid_timestamp" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_INVALID_TIMESTAMP</span> <span class="o">=</span> <span class="mi">32</span>
</code></pre></div>
<p>Invalid timestamp </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_unsupported_sasl_mechanism">RD_KAFKA_RESP_ERR_UNSUPPORTED_SASL_MECHANISM<a class="headerlink" href="#rd_kafka_resp_err_unsupported_sasl_mechanism" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_UNSUPPORTED_SASL_MECHANISM</span> <span class="o">=</span> <span class="mi">33</span>
</code></pre></div>
<p>Unsupported SASL mechanism </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_illegal_sasl_state">RD_KAFKA_RESP_ERR_ILLEGAL_SASL_STATE<a class="headerlink" href="#rd_kafka_resp_err_illegal_sasl_state" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_ILLEGAL_SASL_STATE</span> <span class="o">=</span> <span class="mi">34</span>
</code></pre></div>
<p>Illegal SASL state </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_unsupported_version">RD_KAFKA_RESP_ERR_UNSUPPORTED_VERSION<a class="headerlink" href="#rd_kafka_resp_err_unsupported_version" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_UNSUPPORTED_VERSION</span> <span class="o">=</span> <span class="mi">35</span>
</code></pre></div>
<p>Unuspported version </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_topic_already_exists">RD_KAFKA_RESP_ERR_TOPIC_ALREADY_EXISTS<a class="headerlink" href="#rd_kafka_resp_err_topic_already_exists" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_TOPIC_ALREADY_EXISTS</span> <span class="o">=</span> <span class="mi">36</span>
</code></pre></div>
<p>Topic already exists </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_invalid_partitions">RD_KAFKA_RESP_ERR_INVALID_PARTITIONS<a class="headerlink" href="#rd_kafka_resp_err_invalid_partitions" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_INVALID_PARTITIONS</span> <span class="o">=</span> <span class="mi">37</span>
</code></pre></div>
<p>Invalid number of partitions </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_invalid_replication_factor">RD_KAFKA_RESP_ERR_INVALID_REPLICATION_FACTOR<a class="headerlink" href="#rd_kafka_resp_err_invalid_replication_factor" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_INVALID_REPLICATION_FACTOR</span> <span class="o">=</span> <span class="mi">38</span>
</code></pre></div>
<p>Invalid replication factor </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_invalid_replica_assignment">RD_KAFKA_RESP_ERR_INVALID_REPLICA_ASSIGNMENT<a class="headerlink" href="#rd_kafka_resp_err_invalid_replica_assignment" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_INVALID_REPLICA_ASSIGNMENT</span> <span class="o">=</span> <span class="mi">39</span>
</code></pre></div>
<p>Invalid replica assignment </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_invalid_config">RD_KAFKA_RESP_ERR_INVALID_CONFIG<a class="headerlink" href="#rd_kafka_resp_err_invalid_config" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_INVALID_CONFIG</span> <span class="o">=</span> <span class="mi">40</span>
</code></pre></div>
<p>Invalid config </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_not_controller">RD_KAFKA_RESP_ERR_NOT_CONTROLLER<a class="headerlink" href="#rd_kafka_resp_err_not_controller" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_NOT_CONTROLLER</span> <span class="o">=</span> <span class="mi">41</span>
</code></pre></div>
<p>Not controller for cluster </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_invalid_request">RD_KAFKA_RESP_ERR_INVALID_REQUEST<a class="headerlink" href="#rd_kafka_resp_err_invalid_request" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_INVALID_REQUEST</span> <span class="o">=</span> <span class="mi">42</span>
</code></pre></div>
<p>Invalid request </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_unsupported_for_message_format">RD_KAFKA_RESP_ERR_UNSUPPORTED_FOR_MESSAGE_FORMAT<a class="headerlink" href="#rd_kafka_resp_err_unsupported_for_message_format" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_UNSUPPORTED_FOR_MESSAGE_FORMAT</span> <span class="o">=</span> <span class="mi">43</span>
</code></pre></div>
<p>Message format on broker does not support request </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_policy_violation">RD_KAFKA_RESP_ERR_POLICY_VIOLATION<a class="headerlink" href="#rd_kafka_resp_err_policy_violation" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_POLICY_VIOLATION</span> <span class="o">=</span> <span class="mi">44</span>
</code></pre></div>
<p>Policy violation </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_out_of_order_sequence_number">RD_KAFKA_RESP_ERR_OUT_OF_ORDER_SEQUENCE_NUMBER<a class="headerlink" href="#rd_kafka_resp_err_out_of_order_sequence_number" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_OUT_OF_ORDER_SEQUENCE_NUMBER</span> <span class="o">=</span> <span class="mi">45</span>
</code></pre></div>
<p>Broker received an out of order sequence number </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_duplicate_sequence_number">RD_KAFKA_RESP_ERR_DUPLICATE_SEQUENCE_NUMBER<a class="headerlink" href="#rd_kafka_resp_err_duplicate_sequence_number" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_DUPLICATE_SEQUENCE_NUMBER</span> <span class="o">=</span> <span class="mi">46</span>
</code></pre></div>
<p>Broker received a duplicate sequence number </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_invalid_producer_epoch">RD_KAFKA_RESP_ERR_INVALID_PRODUCER_EPOCH<a class="headerlink" href="#rd_kafka_resp_err_invalid_producer_epoch" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_INVALID_PRODUCER_EPOCH</span> <span class="o">=</span> <span class="mi">47</span>
</code></pre></div>
<p>Producer attempted an operation with an old epoch </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_invalid_txn_state">RD_KAFKA_RESP_ERR_INVALID_TXN_STATE<a class="headerlink" href="#rd_kafka_resp_err_invalid_txn_state" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_INVALID_TXN_STATE</span> <span class="o">=</span> <span class="mi">48</span>
</code></pre></div>
<p>Producer attempted a transactional operation in an invalid state </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_invalid_producer_id_mapping">RD_KAFKA_RESP_ERR_INVALID_PRODUCER_ID_MAPPING<a class="headerlink" href="#rd_kafka_resp_err_invalid_producer_id_mapping" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_INVALID_PRODUCER_ID_MAPPING</span> <span class="o">=</span> <span class="mi">49</span>
</code></pre></div>
<p>Producer attempted to use a producer id which is not currently assigned to its transactional id </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_invalid_transaction_timeout">RD_KAFKA_RESP_ERR_INVALID_TRANSACTION_TIMEOUT<a class="headerlink" href="#rd_kafka_resp_err_invalid_transaction_timeout" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_INVALID_TRANSACTION_TIMEOUT</span> <span class="o">=</span> <span class="mi">50</span>
</code></pre></div>
<p>Transaction timeout is larger than the maximum value allowed by the broker's max.transaction.timeout.ms </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_concurrent_transactions">RD_KAFKA_RESP_ERR_CONCURRENT_TRANSACTIONS<a class="headerlink" href="#rd_kafka_resp_err_concurrent_transactions" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_CONCURRENT_TRANSACTIONS</span> <span class="o">=</span> <span class="mi">51</span>
</code></pre></div>
<p>Producer attempted to update a transaction while another concurrent operation on the same transaction was ongoing </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_transaction_coordinator_fenced">RD_KAFKA_RESP_ERR_TRANSACTION_COORDINATOR_FENCED<a class="headerlink" href="#rd_kafka_resp_err_transaction_coordinator_fenced" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_TRANSACTION_COORDINATOR_FENCED</span> <span class="o">=</span> <span class="mi">52</span>
</code></pre></div>
<p>Indicates that the transaction coordinator sending a WriteTxnMarker is no longer the current coordinator for a given producer </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_transactional_id_authorization_failed">RD_KAFKA_RESP_ERR_TRANSACTIONAL_ID_AUTHORIZATION_FAILED<a class="headerlink" href="#rd_kafka_resp_err_transactional_id_authorization_failed" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_TRANSACTIONAL_ID_AUTHORIZATION_FAILED</span> <span class="o">=</span> <span class="mi">53</span>
</code></pre></div>
<p>Transactional Id authorization failed </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_security_disabled">RD_KAFKA_RESP_ERR_SECURITY_DISABLED<a class="headerlink" href="#rd_kafka_resp_err_security_disabled" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_SECURITY_DISABLED</span> <span class="o">=</span> <span class="mi">54</span>
</code></pre></div>
<p>Security features are disabled </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_operation_not_attempted">RD_KAFKA_RESP_ERR_OPERATION_NOT_ATTEMPTED<a class="headerlink" href="#rd_kafka_resp_err_operation_not_attempted" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_OPERATION_NOT_ATTEMPTED</span> <span class="o">=</span> <span class="mi">55</span>
</code></pre></div>
<p>Operation not attempted </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_kafka_storage_error">RD_KAFKA_RESP_ERR_KAFKA_STORAGE_ERROR<a class="headerlink" href="#rd_kafka_resp_err_kafka_storage_error" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_KAFKA_STORAGE_ERROR</span> <span class="o">=</span> <span class="mi">56</span>
</code></pre></div>
<p>Disk error when trying to access log file on the disk </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_log_dir_not_found">RD_KAFKA_RESP_ERR_LOG_DIR_NOT_FOUND<a class="headerlink" href="#rd_kafka_resp_err_log_dir_not_found" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_LOG_DIR_NOT_FOUND</span> <span class="o">=</span> <span class="mi">57</span>
</code></pre></div>
<p>The user-specified log directory is not found in the broker config </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_sasl_authentication_failed">RD_KAFKA_RESP_ERR_SASL_AUTHENTICATION_FAILED<a class="headerlink" href="#rd_kafka_resp_err_sasl_authentication_failed" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_SASL_AUTHENTICATION_FAILED</span> <span class="o">=</span> <span class="mi">58</span>
</code></pre></div>
<p>SASL Authentication failed </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_unknown_producer_id">RD_KAFKA_RESP_ERR_UNKNOWN_PRODUCER_ID<a class="headerlink" href="#rd_kafka_resp_err_unknown_producer_id" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_UNKNOWN_PRODUCER_ID</span> <span class="o">=</span> <span class="mi">59</span>
</code></pre></div>
<p>Unknown Producer Id </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_reassignment_in_progress">RD_KAFKA_RESP_ERR_REASSIGNMENT_IN_PROGRESS<a class="headerlink" href="#rd_kafka_resp_err_reassignment_in_progress" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_REASSIGNMENT_IN_PROGRESS</span> <span class="o">=</span> <span class="mi">60</span>
</code></pre></div>
<p>Partition reassignment is in progress </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_delegation_token_auth_disabled">RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTH_DISABLED<a class="headerlink" href="#rd_kafka_resp_err_delegation_token_auth_disabled" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTH_DISABLED</span> <span class="o">=</span> <span class="mi">61</span>
</code></pre></div>
<p>Delegation Token feature is not enabled </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_delegation_token_not_found">RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_NOT_FOUND<a class="headerlink" href="#rd_kafka_resp_err_delegation_token_not_found" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_NOT_FOUND</span> <span class="o">=</span> <span class="mi">62</span>
</code></pre></div>
<p>Delegation Token is not found on server </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_delegation_token_owner_mismatch">RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_OWNER_MISMATCH<a class="headerlink" href="#rd_kafka_resp_err_delegation_token_owner_mismatch" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_OWNER_MISMATCH</span> <span class="o">=</span> <span class="mi">63</span>
</code></pre></div>
<p>Specified Principal is not valid Owner/Renewer </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_delegation_token_request_not_allowed">RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_REQUEST_NOT_ALLOWED<a class="headerlink" href="#rd_kafka_resp_err_delegation_token_request_not_allowed" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_REQUEST_NOT_ALLOWED</span> <span class="o">=</span> <span class="mi">64</span>
</code></pre></div>
<p>Delegation Token requests are not allowed on this connection </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_delegation_token_authorization_failed">RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTHORIZATION_FAILED<a class="headerlink" href="#rd_kafka_resp_err_delegation_token_authorization_failed" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTHORIZATION_FAILED</span> <span class="o">=</span> <span class="mi">65</span>
</code></pre></div>
<p>Delegation Token authorization failed </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_delegation_token_expired">RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_EXPIRED<a class="headerlink" href="#rd_kafka_resp_err_delegation_token_expired" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_EXPIRED</span> <span class="o">=</span> <span class="mi">66</span>
</code></pre></div>
<p>Delegation Token is expired </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_invalid_principal_type">RD_KAFKA_RESP_ERR_INVALID_PRINCIPAL_TYPE<a class="headerlink" href="#rd_kafka_resp_err_invalid_principal_type" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_INVALID_PRINCIPAL_TYPE</span> <span class="o">=</span> <span class="mi">67</span>
</code></pre></div>
<p>Supplied principalType is not supported </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_non_empty_group">RD_KAFKA_RESP_ERR_NON_EMPTY_GROUP<a class="headerlink" href="#rd_kafka_resp_err_non_empty_group" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_NON_EMPTY_GROUP</span> <span class="o">=</span> <span class="mi">68</span>
</code></pre></div>
<p>The group is not empty </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_group_id_not_found">RD_KAFKA_RESP_ERR_GROUP_ID_NOT_FOUND<a class="headerlink" href="#rd_kafka_resp_err_group_id_not_found" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_GROUP_ID_NOT_FOUND</span> <span class="o">=</span> <span class="mi">69</span>
</code></pre></div>
<p>The group id does not exist </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_fetch_session_id_not_found">RD_KAFKA_RESP_ERR_FETCH_SESSION_ID_NOT_FOUND<a class="headerlink" href="#rd_kafka_resp_err_fetch_session_id_not_found" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_FETCH_SESSION_ID_NOT_FOUND</span> <span class="o">=</span> <span class="mi">70</span>
</code></pre></div>
<p>The fetch session ID was not found </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_invalid_fetch_session_epoch">RD_KAFKA_RESP_ERR_INVALID_FETCH_SESSION_EPOCH<a class="headerlink" href="#rd_kafka_resp_err_invalid_fetch_session_epoch" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_INVALID_FETCH_SESSION_EPOCH</span> <span class="o">=</span> <span class="mi">71</span>
</code></pre></div>
<p>The fetch session epoch is invalid </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_listener_not_found">RD_KAFKA_RESP_ERR_LISTENER_NOT_FOUND<a class="headerlink" href="#rd_kafka_resp_err_listener_not_found" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_LISTENER_NOT_FOUND</span> <span class="o">=</span> <span class="mi">72</span>
</code></pre></div>
<p>No matching listener </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_topic_deletion_disabled">RD_KAFKA_RESP_ERR_TOPIC_DELETION_DISABLED<a class="headerlink" href="#rd_kafka_resp_err_topic_deletion_disabled" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_TOPIC_DELETION_DISABLED</span> <span class="o">=</span> <span class="mi">73</span>
</code></pre></div>
<p>Topic deletion is disabled </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_vtype_end">RD_KAFKA_VTYPE_END<a class="headerlink" href="#rd_kafka_vtype_end" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_VTYPE_END</span> <span class="o">=</span> <span class="mi">0</span>
</code></pre></div>
<p>va-arg sentinel </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li>
<p><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03c74ceba678b4e7a624310160a02165"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03c74ceba678b4e7a624310160a02165 </a></p>
</li>
<li>
<p><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a9aac65afa4c30e6d75550e39f6c1ea6b"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a9aac65afa4c30e6d75550e39f6c1ea6b </a></p>
</li>
</ul>
</div>
<h3 id="rd_kafka_vtype_topic">RD_KAFKA_VTYPE_TOPIC<a class="headerlink" href="#rd_kafka_vtype_topic" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_VTYPE_TOPIC</span> <span class="o">=</span> <span class="mi">1</span>
</code></pre></div>
<p>(const char *) Topic name </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a9aac65afa4c30e6d75550e39f6c1ea6b"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a9aac65afa4c30e6d75550e39f6c1ea6b </a></li>
</ul>
</div>
<h3 id="rd_kafka_vtype_rkt">RD_KAFKA_VTYPE_RKT<a class="headerlink" href="#rd_kafka_vtype_rkt" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_VTYPE_RKT</span> <span class="o">=</span> <span class="mi">2</span>
</code></pre></div>
<p>(rd_kafka_topic_t *) Topic handle </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a9aac65afa4c30e6d75550e39f6c1ea6b"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a9aac65afa4c30e6d75550e39f6c1ea6b </a></li>
</ul>
</div>
<h3 id="rd_kafka_vtype_partition">RD_KAFKA_VTYPE_PARTITION<a class="headerlink" href="#rd_kafka_vtype_partition" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_VTYPE_PARTITION</span> <span class="o">=</span> <span class="mi">3</span>
</code></pre></div>
<p>(int32_t) Partition </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a9aac65afa4c30e6d75550e39f6c1ea6b"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a9aac65afa4c30e6d75550e39f6c1ea6b </a></li>
</ul>
</div>
<h3 id="rd_kafka_vtype_value">RD_KAFKA_VTYPE_VALUE<a class="headerlink" href="#rd_kafka_vtype_value" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_VTYPE_VALUE</span> <span class="o">=</span> <span class="mi">4</span>
</code></pre></div>
<p>(void *, size_t) Message value (payload) </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a9aac65afa4c30e6d75550e39f6c1ea6b"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a9aac65afa4c30e6d75550e39f6c1ea6b </a></li>
</ul>
</div>
<h3 id="rd_kafka_vtype_key">RD_KAFKA_VTYPE_KEY<a class="headerlink" href="#rd_kafka_vtype_key" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_VTYPE_KEY</span> <span class="o">=</span> <span class="mi">5</span>
</code></pre></div>
<p>(void *, size_t) Message key </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a9aac65afa4c30e6d75550e39f6c1ea6b"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a9aac65afa4c30e6d75550e39f6c1ea6b </a></li>
</ul>
</div>
<h3 id="rd_kafka_vtype_opaque">RD_KAFKA_VTYPE_OPAQUE<a class="headerlink" href="#rd_kafka_vtype_opaque" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_VTYPE_OPAQUE</span> <span class="o">=</span> <span class="mi">6</span>
</code></pre></div>
<p>(void *) Per-message application opaque value. This is the same as the _private field in rd_kafka_message_t, also known as the msg_opaque. </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a9aac65afa4c30e6d75550e39f6c1ea6b"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a9aac65afa4c30e6d75550e39f6c1ea6b </a></li>
</ul>
</div>
<h3 id="rd_kafka_vtype_msgflags">RD_KAFKA_VTYPE_MSGFLAGS<a class="headerlink" href="#rd_kafka_vtype_msgflags" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_VTYPE_MSGFLAGS</span> <span class="o">=</span> <span class="mi">7</span>
</code></pre></div>
<p>(int) RD_KAFKA_MSG_F_.. flags </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a9aac65afa4c30e6d75550e39f6c1ea6b"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a9aac65afa4c30e6d75550e39f6c1ea6b </a></li>
</ul>
</div>
<h3 id="rd_kafka_vtype_timestamp">RD_KAFKA_VTYPE_TIMESTAMP<a class="headerlink" href="#rd_kafka_vtype_timestamp" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_VTYPE_TIMESTAMP</span> <span class="o">=</span> <span class="mi">8</span>
</code></pre></div>
<p>(int64_t) Milliseconds since epoch UTC </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a9aac65afa4c30e6d75550e39f6c1ea6b"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a9aac65afa4c30e6d75550e39f6c1ea6b </a></li>
</ul>
</div>
<h3 id="rd_kafka_vtype_header">RD_KAFKA_VTYPE_HEADER<a class="headerlink" href="#rd_kafka_vtype_header" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_VTYPE_HEADER</span> <span class="o">=</span> <span class="mi">9</span>
</code></pre></div>
<p>(const char *, const void *, ssize_t) Message Header </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a9aac65afa4c30e6d75550e39f6c1ea6b"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a9aac65afa4c30e6d75550e39f6c1ea6b </a></li>
</ul>
</div>
<h3 id="rd_kafka_vtype_headers">RD_KAFKA_VTYPE_HEADERS<a class="headerlink" href="#rd_kafka_vtype_headers" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_VTYPE_HEADERS</span> <span class="o">=</span> <span class="mi">10</span>
</code></pre></div>
<p>(rd_kafka_headers_t *) Headers list </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a9aac65afa4c30e6d75550e39f6c1ea6b"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a9aac65afa4c30e6d75550e39f6c1ea6b </a></li>
</ul>
</div>
<h3 id="rd_kafka_msg_status_not_persisted">RD_KAFKA_MSG_STATUS_NOT_PERSISTED<a class="headerlink" href="#rd_kafka_msg_status_not_persisted" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_MSG_STATUS_NOT_PERSISTED</span> <span class="o">=</span> <span class="mi">0</span>
</code></pre></div>
<p>Message was never transmitted to the broker, or failed with an error indicating it was not written to the log. Application retry risks ordering, but not duplication. </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ad46cb2b6064fcfbe2451aca8df802517"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ad46cb2b6064fcfbe2451aca8df802517 </a></li>
</ul>
</div>
<h3 id="rd_kafka_msg_status_possibly_persisted">RD_KAFKA_MSG_STATUS_POSSIBLY_PERSISTED<a class="headerlink" href="#rd_kafka_msg_status_possibly_persisted" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_MSG_STATUS_POSSIBLY_PERSISTED</span> <span class="o">=</span> <span class="mi">1</span>
</code></pre></div>
<p>Message was transmitted to broker, but no acknowledgement was received. Application retry risks ordering and duplication. </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ad46cb2b6064fcfbe2451aca8df802517"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ad46cb2b6064fcfbe2451aca8df802517 </a></li>
</ul>
</div>
<h3 id="rd_kafka_msg_status_persisted">RD_KAFKA_MSG_STATUS_PERSISTED<a class="headerlink" href="#rd_kafka_msg_status_persisted" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_MSG_STATUS_PERSISTED</span> <span class="o">=</span> <span class="mi">2</span>
</code></pre></div>
<p>Message was written to the log and acknowledged by the broker. No reason for application to retry. Note: this value should only be trusted with <code>acks=all</code>. </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ad46cb2b6064fcfbe2451aca8df802517"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ad46cb2b6064fcfbe2451aca8df802517 </a></li>
</ul>
</div>
<h3 id="rd_kafka_conf_unknown">RD_KAFKA_CONF_UNKNOWN<a class="headerlink" href="#rd_kafka_conf_unknown" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_CONF_UNKNOWN</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span>
</code></pre></div>
<p>Unknown configuration name. </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ad8306a08e59e8e2cbc6abdb84f9689f4"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ad8306a08e59e8e2cbc6abdb84f9689f4 </a></li>
</ul>
</div>
<h3 id="rd_kafka_conf_invalid">RD_KAFKA_CONF_INVALID<a class="headerlink" href="#rd_kafka_conf_invalid" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_CONF_INVALID</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
</code></pre></div>
<p>Invalid configuration value or property or value not supported in this build. </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ad8306a08e59e8e2cbc6abdb84f9689f4"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ad8306a08e59e8e2cbc6abdb84f9689f4 </a></li>
</ul>
</div>
<h3 id="rd_kafka_conf_ok">RD_KAFKA_CONF_OK<a class="headerlink" href="#rd_kafka_conf_ok" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_CONF_OK</span> <span class="o">=</span> <span class="mi">0</span>
</code></pre></div>
<p>Configuration okay </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ad8306a08e59e8e2cbc6abdb84f9689f4"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ad8306a08e59e8e2cbc6abdb84f9689f4 </a></li>
</ul>
</div>
<h3 id="rd_kafka_admin_op_any">RD_KAFKA_ADMIN_OP_ANY<a class="headerlink" href="#rd_kafka_admin_op_any" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_ADMIN_OP_ANY</span> <span class="o">=</span> <span class="mi">0</span>
</code></pre></div>
<p>Default value </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe </a></li>
</ul>
</div>
<h3 id="rd_kafka_admin_op_createtopics">RD_KAFKA_ADMIN_OP_CREATETOPICS<a class="headerlink" href="#rd_kafka_admin_op_createtopics" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_ADMIN_OP_CREATETOPICS</span> <span class="o">=</span> <span class="mi">1</span>
</code></pre></div>
<p>CreateTopics </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe </a></li>
</ul>
</div>
<h3 id="rd_kafka_admin_op_deletetopics">RD_KAFKA_ADMIN_OP_DELETETOPICS<a class="headerlink" href="#rd_kafka_admin_op_deletetopics" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_ADMIN_OP_DELETETOPICS</span> <span class="o">=</span> <span class="mi">2</span>
</code></pre></div>
<p>DeleteTopics </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe </a></li>
</ul>
</div>
<h3 id="rd_kafka_admin_op_createpartitions">RD_KAFKA_ADMIN_OP_CREATEPARTITIONS<a class="headerlink" href="#rd_kafka_admin_op_createpartitions" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_ADMIN_OP_CREATEPARTITIONS</span> <span class="o">=</span> <span class="mi">3</span>
</code></pre></div>
<p>CreatePartitions </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe </a></li>
</ul>
</div>
<h3 id="rd_kafka_admin_op_alterconfigs">RD_KAFKA_ADMIN_OP_ALTERCONFIGS<a class="headerlink" href="#rd_kafka_admin_op_alterconfigs" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_ADMIN_OP_ALTERCONFIGS</span> <span class="o">=</span> <span class="mi">4</span>
</code></pre></div>
<p>AlterConfigs </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe </a></li>
</ul>
</div>
<h3 id="rd_kafka_admin_op_describeconfigs">RD_KAFKA_ADMIN_OP_DESCRIBECONFIGS<a class="headerlink" href="#rd_kafka_admin_op_describeconfigs" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_ADMIN_OP_DESCRIBECONFIGS</span> <span class="o">=</span> <span class="mi">5</span>
</code></pre></div>
<p>DescribeConfigs </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe </a></li>
</ul>
</div>
<h3 id="rd_kafka_config_source_unknown_config">RD_KAFKA_CONFIG_SOURCE_UNKNOWN_CONFIG<a class="headerlink" href="#rd_kafka_config_source_unknown_config" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_CONFIG_SOURCE_UNKNOWN_CONFIG</span> <span class="o">=</span> <span class="mi">0</span>
</code></pre></div>
<p>Source unknown, e.g., in the ConfigEntry used for alter requests where source is not set </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aab84b4178e74bd4319721ee0c68ae62c"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aab84b4178e74bd4319721ee0c68ae62c </a></li>
</ul>
</div>
<h3 id="rd_kafka_config_source_dynamic_topic_config">RD_KAFKA_CONFIG_SOURCE_DYNAMIC_TOPIC_CONFIG<a class="headerlink" href="#rd_kafka_config_source_dynamic_topic_config" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_CONFIG_SOURCE_DYNAMIC_TOPIC_CONFIG</span> <span class="o">=</span> <span class="mi">1</span>
</code></pre></div>
<p>Dynamic topic config that is configured for a specific topic </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aab84b4178e74bd4319721ee0c68ae62c"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aab84b4178e74bd4319721ee0c68ae62c </a></li>
</ul>
</div>
<h3 id="rd_kafka_config_source_dynamic_broker_config">RD_KAFKA_CONFIG_SOURCE_DYNAMIC_BROKER_CONFIG<a class="headerlink" href="#rd_kafka_config_source_dynamic_broker_config" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_CONFIG_SOURCE_DYNAMIC_BROKER_CONFIG</span> <span class="o">=</span> <span class="mi">2</span>
</code></pre></div>
<p>Dynamic broker config that is configured for a specific broker </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aab84b4178e74bd4319721ee0c68ae62c"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aab84b4178e74bd4319721ee0c68ae62c </a></li>
</ul>
</div>
<h3 id="rd_kafka_config_source_dynamic_default_broker_config">RD_KAFKA_CONFIG_SOURCE_DYNAMIC_DEFAULT_BROKER_CONFIG<a class="headerlink" href="#rd_kafka_config_source_dynamic_default_broker_config" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_CONFIG_SOURCE_DYNAMIC_DEFAULT_BROKER_CONFIG</span> <span class="o">=</span> <span class="mi">3</span>
</code></pre></div>
<p>Dynamic broker config that is configured as default for all brokers in the cluster </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aab84b4178e74bd4319721ee0c68ae62c"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aab84b4178e74bd4319721ee0c68ae62c </a></li>
</ul>
</div>
<h3 id="rd_kafka_config_source_static_broker_config">RD_KAFKA_CONFIG_SOURCE_STATIC_BROKER_CONFIG<a class="headerlink" href="#rd_kafka_config_source_static_broker_config" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_CONFIG_SOURCE_STATIC_BROKER_CONFIG</span> <span class="o">=</span> <span class="mi">4</span>
</code></pre></div>
<p>Static broker config provided as broker properties at startup (e.g. from server.properties file) </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aab84b4178e74bd4319721ee0c68ae62c"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aab84b4178e74bd4319721ee0c68ae62c </a></li>
</ul>
</div>
<h3 id="rd_kafka_config_source_default_config">RD_KAFKA_CONFIG_SOURCE_DEFAULT_CONFIG<a class="headerlink" href="#rd_kafka_config_source_default_config" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_CONFIG_SOURCE_DEFAULT_CONFIG</span> <span class="o">=</span> <span class="mi">5</span>
</code></pre></div>
<p>Built-in default configuration for configs that have a default value </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aab84b4178e74bd4319721ee0c68ae62c"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aab84b4178e74bd4319721ee0c68ae62c </a></li>
</ul>
</div>
<h3 id="rd_kafka_config_source__cnt">RD_KAFKA_CONFIG_SOURCE__CNT<a class="headerlink" href="#rd_kafka_config_source__cnt" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_CONFIG_SOURCE__CNT</span> <span class="o">=</span> <span class="mi">6</span>
</code></pre></div>
<p>Number of source types defined </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aab84b4178e74bd4319721ee0c68ae62c"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aab84b4178e74bd4319721ee0c68ae62c </a></li>
</ul>
</div>
<h3 id="rd_kafka_resource_unknown">RD_KAFKA_RESOURCE_UNKNOWN<a class="headerlink" href="#rd_kafka_resource_unknown" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESOURCE_UNKNOWN</span> <span class="o">=</span> <span class="mi">0</span>
</code></pre></div>
<p>Unknown </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#acca83a66d7783ff7683ed2691cc907c9"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#acca83a66d7783ff7683ed2691cc907c9 </a></li>
</ul>
</div>
<h3 id="rd_kafka_resource_any">RD_KAFKA_RESOURCE_ANY<a class="headerlink" href="#rd_kafka_resource_any" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESOURCE_ANY</span> <span class="o">=</span> <span class="mi">1</span>
</code></pre></div>
<p>Any (used for lookups) </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#acca83a66d7783ff7683ed2691cc907c9"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#acca83a66d7783ff7683ed2691cc907c9 </a></li>
</ul>
</div>
<h3 id="rd_kafka_resource_topic">RD_KAFKA_RESOURCE_TOPIC<a class="headerlink" href="#rd_kafka_resource_topic" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESOURCE_TOPIC</span> <span class="o">=</span> <span class="mi">2</span>
</code></pre></div>
<p>Topic </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#acca83a66d7783ff7683ed2691cc907c9"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#acca83a66d7783ff7683ed2691cc907c9 </a></li>
</ul>
</div>
<h3 id="rd_kafka_resource_group">RD_KAFKA_RESOURCE_GROUP<a class="headerlink" href="#rd_kafka_resource_group" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESOURCE_GROUP</span> <span class="o">=</span> <span class="mi">3</span>
</code></pre></div>
<p>Group </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#acca83a66d7783ff7683ed2691cc907c9"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#acca83a66d7783ff7683ed2691cc907c9 </a></li>
</ul>
</div>
<h3 id="rd_kafka_resource_broker">RD_KAFKA_RESOURCE_BROKER<a class="headerlink" href="#rd_kafka_resource_broker" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESOURCE_BROKER</span> <span class="o">=</span> <span class="mi">4</span>
</code></pre></div>
<p>Broker </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#acca83a66d7783ff7683ed2691cc907c9"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#acca83a66d7783ff7683ed2691cc907c9 </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_fenced_leader_epoch">RD_KAFKA_RESP_ERR_FENCED_LEADER_EPOCH<a class="headerlink" href="#rd_kafka_resp_err_fenced_leader_epoch" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_FENCED_LEADER_EPOCH</span> <span class="o">=</span> <span class="mi">74</span>
</code></pre></div>
<p>Leader epoch is older than broker epoch </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_unknown_leader_epoch">RD_KAFKA_RESP_ERR_UNKNOWN_LEADER_EPOCH<a class="headerlink" href="#rd_kafka_resp_err_unknown_leader_epoch" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_UNKNOWN_LEADER_EPOCH</span> <span class="o">=</span> <span class="mi">75</span>
</code></pre></div>
<p>Leader epoch is newer than broker epoch </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_stale_broker_epoch">RD_KAFKA_RESP_ERR_STALE_BROKER_EPOCH<a class="headerlink" href="#rd_kafka_resp_err_stale_broker_epoch" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_STALE_BROKER_EPOCH</span> <span class="o">=</span> <span class="mi">77</span>
</code></pre></div>
<p>Broker epoch has changed </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_offset_not_available">RD_KAFKA_RESP_ERR_OFFSET_NOT_AVAILABLE<a class="headerlink" href="#rd_kafka_resp_err_offset_not_available" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_OFFSET_NOT_AVAILABLE</span> <span class="o">=</span> <span class="mi">78</span>
</code></pre></div>
<p>Leader high watermark is not caught up </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_member_id_required">RD_KAFKA_RESP_ERR_MEMBER_ID_REQUIRED<a class="headerlink" href="#rd_kafka_resp_err_member_id_required" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_MEMBER_ID_REQUIRED</span> <span class="o">=</span> <span class="mi">79</span>
</code></pre></div>
<p>Group member needs a valid member ID </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_preferred_leader_not_available">RD_KAFKA_RESP_ERR_PREFERRED_LEADER_NOT_AVAILABLE<a class="headerlink" href="#rd_kafka_resp_err_preferred_leader_not_available" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_PREFERRED_LEADER_NOT_AVAILABLE</span> <span class="o">=</span> <span class="mi">80</span>
</code></pre></div>
<p>Preferred leader was not available </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_group_max_size_reached">RD_KAFKA_RESP_ERR_GROUP_MAX_SIZE_REACHED<a class="headerlink" href="#rd_kafka_resp_err_group_max_size_reached" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_GROUP_MAX_SIZE_REACHED</span> <span class="o">=</span> <span class="mi">81</span>
</code></pre></div>
<p>Consumer group has reached maximum size </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_event_oauthbearer_token_refresh">RD_KAFKA_EVENT_OAUTHBEARER_TOKEN_REFRESH<a class="headerlink" href="#rd_kafka_event_oauthbearer_token_refresh" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_EVENT_OAUTHBEARER_TOKEN_REFRESH</span> <span class="o">=</span> <span class="mi">256</span>
</code></pre></div>
<p>SASL/OAUTHBEARER token needs to be refreshed </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a63e097de934fac48b93411ac91564db1"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a63e097de934fac48b93411ac91564db1 </a></li>
</ul>
</div>
<h3 id="rd_kafka_cert_public_key">RD_KAFKA_CERT_PUBLIC_KEY<a class="headerlink" href="#rd_kafka_cert_public_key" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_CERT_PUBLIC_KEY</span> <span class="o">=</span> <span class="mi">0</span>
</code></pre></div>
<p>Client's public key </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a5f0ba54591c0ffa725cb1a5eafe8b180"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a5f0ba54591c0ffa725cb1a5eafe8b180 </a></li>
</ul>
</div>
<h3 id="rd_kafka_cert_private_key">RD_KAFKA_CERT_PRIVATE_KEY<a class="headerlink" href="#rd_kafka_cert_private_key" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_CERT_PRIVATE_KEY</span> <span class="o">=</span> <span class="mi">1</span>
</code></pre></div>
<p>Client's private key </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a5f0ba54591c0ffa725cb1a5eafe8b180"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a5f0ba54591c0ffa725cb1a5eafe8b180 </a></li>
</ul>
</div>
<h3 id="rd_kafka_cert_ca">RD_KAFKA_CERT_CA<a class="headerlink" href="#rd_kafka_cert_ca" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_CERT_CA</span> <span class="o">=</span> <span class="mi">2</span>
</code></pre></div>
<p>CA certificate </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a5f0ba54591c0ffa725cb1a5eafe8b180"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a5f0ba54591c0ffa725cb1a5eafe8b180 </a></li>
</ul>
</div>
<h3 id="rd_kafka_cert__cnt">RD_KAFKA_CERT__CNT<a class="headerlink" href="#rd_kafka_cert__cnt" title="Permanent link">&para;</a></h3>
<p><div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_CERT__CNT</span> <span class="o">=</span> <span class="mi">3</span>
</code></pre></div>
enum rd_kafka_cert_type_t</p>
<h3 id="rd_kafka_cert_enc_pkcs12">RD_KAFKA_CERT_ENC_PKCS12<a class="headerlink" href="#rd_kafka_cert_enc_pkcs12" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_CERT_ENC_PKCS12</span> <span class="o">=</span> <span class="mi">0</span>
</code></pre></div>
<p>PKCS#12 </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ab7a624d3a484453f4abe5955bb6a45eb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ab7a624d3a484453f4abe5955bb6a45eb </a></li>
</ul>
</div>
<h3 id="rd_kafka_cert_enc_der">RD_KAFKA_CERT_ENC_DER<a class="headerlink" href="#rd_kafka_cert_enc_der" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_CERT_ENC_DER</span> <span class="o">=</span> <span class="mi">1</span>
</code></pre></div>
<p>DER / binary X.509 ASN1 </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ab7a624d3a484453f4abe5955bb6a45eb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ab7a624d3a484453f4abe5955bb6a45eb </a></li>
</ul>
</div>
<h3 id="rd_kafka_cert_enc_pem">RD_KAFKA_CERT_ENC_PEM<a class="headerlink" href="#rd_kafka_cert_enc_pem" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_CERT_ENC_PEM</span> <span class="o">=</span> <span class="mi">2</span>
</code></pre></div>
<p>PEM </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ab7a624d3a484453f4abe5955bb6a45eb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ab7a624d3a484453f4abe5955bb6a45eb </a></li>
</ul>
</div>
<h3 id="rd_kafka_cert_enc__cnt">RD_KAFKA_CERT_ENC__CNT<a class="headerlink" href="#rd_kafka_cert_enc__cnt" title="Permanent link">&para;</a></h3>
<p><div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_CERT_ENC__CNT</span> <span class="o">=</span> <span class="mi">3</span>
</code></pre></div>
enum rd_kafka_cert_enc_t</p>
<h3 id="rd_kafka_thread_main">RD_KAFKA_THREAD_MAIN<a class="headerlink" href="#rd_kafka_thread_main" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_THREAD_MAIN</span> <span class="o">=</span> <span class="mi">0</span>
</code></pre></div>
<p>librdkafka's internal main thread </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ab327ca8929b6895de7b300970ad59745"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ab327ca8929b6895de7b300970ad59745 </a></li>
</ul>
</div>
<h3 id="rd_kafka_thread_background">RD_KAFKA_THREAD_BACKGROUND<a class="headerlink" href="#rd_kafka_thread_background" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_THREAD_BACKGROUND</span> <span class="o">=</span> <span class="mi">1</span>
</code></pre></div>
<p>Background thread (if enabled) </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ab327ca8929b6895de7b300970ad59745"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ab327ca8929b6895de7b300970ad59745 </a></li>
</ul>
</div>
<h3 id="rd_kafka_thread_broker">RD_KAFKA_THREAD_BROKER<a class="headerlink" href="#rd_kafka_thread_broker" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_THREAD_BROKER</span> <span class="o">=</span> <span class="mi">2</span>
</code></pre></div>
<p>Per-broker thread </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ab327ca8929b6895de7b300970ad59745"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ab327ca8929b6895de7b300970ad59745 </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err__unknown_broker">RD_KAFKA_RESP_ERR__UNKNOWN_BROKER<a class="headerlink" href="#rd_kafka_resp_err__unknown_broker" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR__UNKNOWN_BROKER</span> <span class="o">=</span> <span class="o">-</span><span class="mi">146</span>
</code></pre></div>
<p>Unknown broker </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_coordinator_load_in_progress">RD_KAFKA_RESP_ERR_COORDINATOR_LOAD_IN_PROGRESS<a class="headerlink" href="#rd_kafka_resp_err_coordinator_load_in_progress" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_COORDINATOR_LOAD_IN_PROGRESS</span> <span class="o">=</span> <span class="mi">14</span>
</code></pre></div>
<p>Coordinator load in progress </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li>
<p><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#afa695eee077bfd031e5bb637b899cfd8"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#afa695eee077bfd031e5bb637b899cfd8 </a></p>
</li>
<li>
<p><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></p>
</li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_coordinator_not_available">RD_KAFKA_RESP_ERR_COORDINATOR_NOT_AVAILABLE<a class="headerlink" href="#rd_kafka_resp_err_coordinator_not_available" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_COORDINATOR_NOT_AVAILABLE</span> <span class="o">=</span> <span class="mi">15</span>
</code></pre></div>
<p>Coordinator not available </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li>
<p><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a23a154df5190e1fc072199737f39bd87"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a23a154df5190e1fc072199737f39bd87 </a></p>
</li>
<li>
<p><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></p>
</li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_not_coordinator">RD_KAFKA_RESP_ERR_NOT_COORDINATOR<a class="headerlink" href="#rd_kafka_resp_err_not_coordinator" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_NOT_COORDINATOR</span> <span class="o">=</span> <span class="mi">16</span>
</code></pre></div>
<p>Not coordinator </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li>
<p><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a7755c1901da130a937be67a1c66e2c1f"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a7755c1901da130a937be67a1c66e2c1f </a></p>
</li>
<li>
<p><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></p>
</li>
</ul>
</div>
<h3 id="rd_kafka_resp_err__not_configured">RD_KAFKA_RESP_ERR__NOT_CONFIGURED<a class="headerlink" href="#rd_kafka_resp_err__not_configured" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR__NOT_CONFIGURED</span> <span class="o">=</span> <span class="o">-</span><span class="mi">145</span>
</code></pre></div>
<p>Functionality not configured </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err__fenced">RD_KAFKA_RESP_ERR__FENCED<a class="headerlink" href="#rd_kafka_resp_err__fenced" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR__FENCED</span> <span class="o">=</span> <span class="o">-</span><span class="mi">144</span>
</code></pre></div>
<p>Instance has been fenced </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err__application">RD_KAFKA_RESP_ERR__APPLICATION<a class="headerlink" href="#rd_kafka_resp_err__application" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR__APPLICATION</span> <span class="o">=</span> <span class="o">-</span><span class="mi">143</span>
</code></pre></div>
<p>Application generated error </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_fenced_instance_id">RD_KAFKA_RESP_ERR_FENCED_INSTANCE_ID<a class="headerlink" href="#rd_kafka_resp_err_fenced_instance_id" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_FENCED_INSTANCE_ID</span> <span class="o">=</span> <span class="mi">82</span>
</code></pre></div>
<p>Static consumer fenced by other consumer with same group.instance.id. </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_eligible_leaders_not_available">RD_KAFKA_RESP_ERR_ELIGIBLE_LEADERS_NOT_AVAILABLE<a class="headerlink" href="#rd_kafka_resp_err_eligible_leaders_not_available" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_ELIGIBLE_LEADERS_NOT_AVAILABLE</span> <span class="o">=</span> <span class="mi">83</span>
</code></pre></div>
<p>Eligible partition leaders are not available </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_election_not_needed">RD_KAFKA_RESP_ERR_ELECTION_NOT_NEEDED<a class="headerlink" href="#rd_kafka_resp_err_election_not_needed" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_ELECTION_NOT_NEEDED</span> <span class="o">=</span> <span class="mi">84</span>
</code></pre></div>
<p>Leader election not needed for topic partition </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_no_reassignment_in_progress">RD_KAFKA_RESP_ERR_NO_REASSIGNMENT_IN_PROGRESS<a class="headerlink" href="#rd_kafka_resp_err_no_reassignment_in_progress" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_NO_REASSIGNMENT_IN_PROGRESS</span> <span class="o">=</span> <span class="mi">85</span>
</code></pre></div>
<p>No partition reassignment is in progress </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_group_subscribed_to_topic">RD_KAFKA_RESP_ERR_GROUP_SUBSCRIBED_TO_TOPIC<a class="headerlink" href="#rd_kafka_resp_err_group_subscribed_to_topic" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_GROUP_SUBSCRIBED_TO_TOPIC</span> <span class="o">=</span> <span class="mi">86</span>
</code></pre></div>
<p>Deleting offsets of a topic while the consumer group is subscribed to it </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_invalid_record">RD_KAFKA_RESP_ERR_INVALID_RECORD<a class="headerlink" href="#rd_kafka_resp_err_invalid_record" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_INVALID_RECORD</span> <span class="o">=</span> <span class="mi">87</span>
</code></pre></div>
<p>Broker failed to validate record </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_unstable_offset_commit">RD_KAFKA_RESP_ERR_UNSTABLE_OFFSET_COMMIT<a class="headerlink" href="#rd_kafka_resp_err_unstable_offset_commit" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_UNSTABLE_OFFSET_COMMIT</span> <span class="o">=</span> <span class="mi">88</span>
</code></pre></div>
<p>There are unstable offsets that need to be cleared </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_event_deleterecords_result">RD_KAFKA_EVENT_DELETERECORDS_RESULT<a class="headerlink" href="#rd_kafka_event_deleterecords_result" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_EVENT_DELETERECORDS_RESULT</span> <span class="o">=</span> <span class="mi">105</span>
</code></pre></div>
<p>DeleteRecords_result_t </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ab572fd50785847b03c96af744ceffaf1"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ab572fd50785847b03c96af744ceffaf1 </a></li>
</ul>
</div>
<h3 id="rd_kafka_event_deletegroups_result">RD_KAFKA_EVENT_DELETEGROUPS_RESULT<a class="headerlink" href="#rd_kafka_event_deletegroups_result" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_EVENT_DELETEGROUPS_RESULT</span> <span class="o">=</span> <span class="mi">106</span>
</code></pre></div>
<p>DeleteGroups_result_t </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a6d2f3f1797ba2241c707b077ddc2c1b3"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a6d2f3f1797ba2241c707b077ddc2c1b3 </a></li>
</ul>
</div>
<h3 id="rd_kafka_event_deleteconsumergroupoffsets_result">RD_KAFKA_EVENT_DELETECONSUMERGROUPOFFSETS_RESULT<a class="headerlink" href="#rd_kafka_event_deleteconsumergroupoffsets_result" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_EVENT_DELETECONSUMERGROUPOFFSETS_RESULT</span> <span class="o">=</span> <span class="mi">107</span>
</code></pre></div>
<p>DeleteConsumerGroupOffsets_result_t </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a16dee39b23bef225ad3bb902cf391659"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a16dee39b23bef225ad3bb902cf391659 </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err__assignment_lost">RD_KAFKA_RESP_ERR__ASSIGNMENT_LOST<a class="headerlink" href="#rd_kafka_resp_err__assignment_lost" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR__ASSIGNMENT_LOST</span> <span class="o">=</span> <span class="o">-</span><span class="mi">142</span>
</code></pre></div>
<p>Assignment lost </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err__noop">RD_KAFKA_RESP_ERR__NOOP<a class="headerlink" href="#rd_kafka_resp_err__noop" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR__NOOP</span> <span class="o">=</span> <span class="o">-</span><span class="mi">141</span>
</code></pre></div>
<p>No operation performed </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_throttling_quota_exceeded">RD_KAFKA_RESP_ERR_THROTTLING_QUOTA_EXCEEDED<a class="headerlink" href="#rd_kafka_resp_err_throttling_quota_exceeded" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_THROTTLING_QUOTA_EXCEEDED</span> <span class="o">=</span> <span class="mi">89</span>
</code></pre></div>
<p>Throttling quota has been exceeded </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_producer_fenced">RD_KAFKA_RESP_ERR_PRODUCER_FENCED<a class="headerlink" href="#rd_kafka_resp_err_producer_fenced" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_PRODUCER_FENCED</span> <span class="o">=</span> <span class="mi">90</span>
</code></pre></div>
<p>There is a newer producer with the same transactionalId which fences the current one </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_resource_not_found">RD_KAFKA_RESP_ERR_RESOURCE_NOT_FOUND<a class="headerlink" href="#rd_kafka_resp_err_resource_not_found" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_RESOURCE_NOT_FOUND</span> <span class="o">=</span> <span class="mi">91</span>
</code></pre></div>
<p>Request illegally referred to resource that does not exist </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_duplicate_resource">RD_KAFKA_RESP_ERR_DUPLICATE_RESOURCE<a class="headerlink" href="#rd_kafka_resp_err_duplicate_resource" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_DUPLICATE_RESOURCE</span> <span class="o">=</span> <span class="mi">92</span>
</code></pre></div>
<p>Request illegally referred to the same resource twice </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_unacceptable_credential">RD_KAFKA_RESP_ERR_UNACCEPTABLE_CREDENTIAL<a class="headerlink" href="#rd_kafka_resp_err_unacceptable_credential" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_UNACCEPTABLE_CREDENTIAL</span> <span class="o">=</span> <span class="mi">93</span>
</code></pre></div>
<p>Requested credential would not meet criteria for acceptability </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_inconsistent_voter_set">RD_KAFKA_RESP_ERR_INCONSISTENT_VOTER_SET<a class="headerlink" href="#rd_kafka_resp_err_inconsistent_voter_set" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_INCONSISTENT_VOTER_SET</span> <span class="o">=</span> <span class="mi">94</span>
</code></pre></div>
<p>Indicates that the either the sender or recipient of a voter-only request is not one of the expected voters </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_invalid_update_version">RD_KAFKA_RESP_ERR_INVALID_UPDATE_VERSION<a class="headerlink" href="#rd_kafka_resp_err_invalid_update_version" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_INVALID_UPDATE_VERSION</span> <span class="o">=</span> <span class="mi">95</span>
</code></pre></div>
<p>Invalid update version </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_feature_update_failed">RD_KAFKA_RESP_ERR_FEATURE_UPDATE_FAILED<a class="headerlink" href="#rd_kafka_resp_err_feature_update_failed" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_FEATURE_UPDATE_FAILED</span> <span class="o">=</span> <span class="mi">96</span>
</code></pre></div>
<p>Unable to update finalized features due to server error </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_principal_deserialization_failure">RD_KAFKA_RESP_ERR_PRINCIPAL_DESERIALIZATION_FAILURE<a class="headerlink" href="#rd_kafka_resp_err_principal_deserialization_failure" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_PRINCIPAL_DESERIALIZATION_FAILURE</span> <span class="o">=</span> <span class="mi">97</span>
</code></pre></div>
<p>Request principal deserialization failed during forwarding </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_admin_op_deleterecords">RD_KAFKA_ADMIN_OP_DELETERECORDS<a class="headerlink" href="#rd_kafka_admin_op_deleterecords" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_ADMIN_OP_DELETERECORDS</span> <span class="o">=</span> <span class="mi">6</span>
</code></pre></div>
<p>DeleteRecords </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe </a></li>
</ul>
</div>
<h3 id="rd_kafka_admin_op_deletegroups">RD_KAFKA_ADMIN_OP_DELETEGROUPS<a class="headerlink" href="#rd_kafka_admin_op_deletegroups" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_ADMIN_OP_DELETEGROUPS</span> <span class="o">=</span> <span class="mi">7</span>
</code></pre></div>
<p>DeleteGroups </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe </a></li>
</ul>
</div>
<h3 id="rd_kafka_admin_op_deleteconsumergroupoffsets">RD_KAFKA_ADMIN_OP_DELETECONSUMERGROUPOFFSETS<a class="headerlink" href="#rd_kafka_admin_op_deleteconsumergroupoffsets" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_ADMIN_OP_DELETECONSUMERGROUPOFFSETS</span> <span class="o">=</span> <span class="mi">8</span>
</code></pre></div>
<p>DeleteConsumerGroupOffsets </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err__auto_offset_reset">RD_KAFKA_RESP_ERR__AUTO_OFFSET_RESET<a class="headerlink" href="#rd_kafka_resp_err__auto_offset_reset" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR__AUTO_OFFSET_RESET</span> <span class="o">=</span> <span class="o">-</span><span class="mi">140</span>
</code></pre></div>
<p>No offset to automatically reset to </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_event_background">RD_KAFKA_EVENT_BACKGROUND<a class="headerlink" href="#rd_kafka_event_background" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_EVENT_BACKGROUND</span> <span class="o">=</span> <span class="mi">512</span>
</code></pre></div>
<p>Enable background thread. </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ad6fc906cff51d7ed8bfc9597c2054190"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ad6fc906cff51d7ed8bfc9597c2054190 </a></li>
</ul>
</div>
<h3 id="rd_kafka_event_createacls_result">RD_KAFKA_EVENT_CREATEACLS_RESULT<a class="headerlink" href="#rd_kafka_event_createacls_result" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_EVENT_CREATEACLS_RESULT</span> <span class="o">=</span> <span class="mi">1024</span>
</code></pre></div>
<p>CreateAcls_result_t </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ae09849fc4a1e0a1b4240fbf9e195f2b9"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ae09849fc4a1e0a1b4240fbf9e195f2b9 </a></li>
</ul>
</div>
<h3 id="rd_kafka_event_describeacls_result">RD_KAFKA_EVENT_DESCRIBEACLS_RESULT<a class="headerlink" href="#rd_kafka_event_describeacls_result" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_EVENT_DESCRIBEACLS_RESULT</span> <span class="o">=</span> <span class="mi">2048</span>
</code></pre></div>
<p>DescribeAcls_result_t </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#af4991ffb7e86a8344a7012d40e2124d8"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#af4991ffb7e86a8344a7012d40e2124d8 </a></li>
</ul>
</div>
<h3 id="rd_kafka_event_deleteacls_result">RD_KAFKA_EVENT_DELETEACLS_RESULT<a class="headerlink" href="#rd_kafka_event_deleteacls_result" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_EVENT_DELETEACLS_RESULT</span> <span class="o">=</span> <span class="mi">4096</span>
</code></pre></div>
<p>DeleteAcls_result_t </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aa44fa18142c943e305b48ae67c836cb4"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aa44fa18142c943e305b48ae67c836cb4 </a></li>
</ul>
</div>
<h3 id="rd_kafka_admin_op_createacls">RD_KAFKA_ADMIN_OP_CREATEACLS<a class="headerlink" href="#rd_kafka_admin_op_createacls" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_ADMIN_OP_CREATEACLS</span> <span class="o">=</span> <span class="mi">9</span>
</code></pre></div>
<p>CreateAcls </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe </a></li>
</ul>
</div>
<h3 id="rd_kafka_admin_op_describeacls">RD_KAFKA_ADMIN_OP_DESCRIBEACLS<a class="headerlink" href="#rd_kafka_admin_op_describeacls" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_ADMIN_OP_DESCRIBEACLS</span> <span class="o">=</span> <span class="mi">10</span>
</code></pre></div>
<p>DescribeAcls </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe </a></li>
</ul>
</div>
<h3 id="rd_kafka_admin_op_deleteacls">RD_KAFKA_ADMIN_OP_DELETEACLS<a class="headerlink" href="#rd_kafka_admin_op_deleteacls" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_ADMIN_OP_DELETEACLS</span> <span class="o">=</span> <span class="mi">11</span>
</code></pre></div>
<p>DeleteAcls </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe </a></li>
</ul>
</div>
<h3 id="rd_kafka_resource_pattern_unknown">RD_KAFKA_RESOURCE_PATTERN_UNKNOWN<a class="headerlink" href="#rd_kafka_resource_pattern_unknown" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESOURCE_PATTERN_UNKNOWN</span> <span class="o">=</span> <span class="mi">0</span>
</code></pre></div>
<p>Unknown </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#acbe0ed4347fe1bd085eef03ca7aadbdb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#acbe0ed4347fe1bd085eef03ca7aadbdb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resource_pattern_any">RD_KAFKA_RESOURCE_PATTERN_ANY<a class="headerlink" href="#rd_kafka_resource_pattern_any" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESOURCE_PATTERN_ANY</span> <span class="o">=</span> <span class="mi">1</span>
</code></pre></div>
<p>Any (used for lookups) </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#acbe0ed4347fe1bd085eef03ca7aadbdb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#acbe0ed4347fe1bd085eef03ca7aadbdb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resource_pattern_match">RD_KAFKA_RESOURCE_PATTERN_MATCH<a class="headerlink" href="#rd_kafka_resource_pattern_match" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESOURCE_PATTERN_MATCH</span> <span class="o">=</span> <span class="mi">2</span>
</code></pre></div>
<p>Match: will perform pattern matching </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#acbe0ed4347fe1bd085eef03ca7aadbdb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#acbe0ed4347fe1bd085eef03ca7aadbdb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resource_pattern_literal">RD_KAFKA_RESOURCE_PATTERN_LITERAL<a class="headerlink" href="#rd_kafka_resource_pattern_literal" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESOURCE_PATTERN_LITERAL</span> <span class="o">=</span> <span class="mi">3</span>
</code></pre></div>
<p>Literal: A literal resource name </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#acbe0ed4347fe1bd085eef03ca7aadbdb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#acbe0ed4347fe1bd085eef03ca7aadbdb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resource_pattern_prefixed">RD_KAFKA_RESOURCE_PATTERN_PREFIXED<a class="headerlink" href="#rd_kafka_resource_pattern_prefixed" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESOURCE_PATTERN_PREFIXED</span> <span class="o">=</span> <span class="mi">4</span>
</code></pre></div>
<p>Prefixed: A prefixed resource name </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#acbe0ed4347fe1bd085eef03ca7aadbdb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#acbe0ed4347fe1bd085eef03ca7aadbdb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resource_pattern_type__cnt">RD_KAFKA_RESOURCE_PATTERN_TYPE__CNT<a class="headerlink" href="#rd_kafka_resource_pattern_type__cnt" title="Permanent link">&para;</a></h3>
<p><div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESOURCE_PATTERN_TYPE__CNT</span> <span class="o">=</span> <span class="mi">5</span>
</code></pre></div>
enum rd_kafka_ResourcePatternType_t</p>
<h3 id="rd_kafka_acl_operation_unknown">RD_KAFKA_ACL_OPERATION_UNKNOWN<a class="headerlink" href="#rd_kafka_acl_operation_unknown" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_ACL_OPERATION_UNKNOWN</span> <span class="o">=</span> <span class="mi">0</span>
</code></pre></div>
<p>Unknown </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a526269d7fc5c9acd1b8b56e84895c2bb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a526269d7fc5c9acd1b8b56e84895c2bb </a></li>
</ul>
</div>
<h3 id="rd_kafka_acl_operation_any">RD_KAFKA_ACL_OPERATION_ANY<a class="headerlink" href="#rd_kafka_acl_operation_any" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_ACL_OPERATION_ANY</span> <span class="o">=</span> <span class="mi">1</span>
</code></pre></div>
<p>In a filter, matches any AclOperation </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a526269d7fc5c9acd1b8b56e84895c2bb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a526269d7fc5c9acd1b8b56e84895c2bb </a></li>
</ul>
</div>
<h3 id="rd_kafka_acl_operation_all">RD_KAFKA_ACL_OPERATION_ALL<a class="headerlink" href="#rd_kafka_acl_operation_all" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_ACL_OPERATION_ALL</span> <span class="o">=</span> <span class="mi">2</span>
</code></pre></div>
<p>ALL operation </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a526269d7fc5c9acd1b8b56e84895c2bb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a526269d7fc5c9acd1b8b56e84895c2bb </a></li>
</ul>
</div>
<h3 id="rd_kafka_acl_operation_read">RD_KAFKA_ACL_OPERATION_READ<a class="headerlink" href="#rd_kafka_acl_operation_read" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_ACL_OPERATION_READ</span> <span class="o">=</span> <span class="mi">3</span>
</code></pre></div>
<p>READ operation </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a526269d7fc5c9acd1b8b56e84895c2bb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a526269d7fc5c9acd1b8b56e84895c2bb </a></li>
</ul>
</div>
<h3 id="rd_kafka_acl_operation_write">RD_KAFKA_ACL_OPERATION_WRITE<a class="headerlink" href="#rd_kafka_acl_operation_write" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_ACL_OPERATION_WRITE</span> <span class="o">=</span> <span class="mi">4</span>
</code></pre></div>
<p>WRITE operation </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a526269d7fc5c9acd1b8b56e84895c2bb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a526269d7fc5c9acd1b8b56e84895c2bb </a></li>
</ul>
</div>
<h3 id="rd_kafka_acl_operation_create">RD_KAFKA_ACL_OPERATION_CREATE<a class="headerlink" href="#rd_kafka_acl_operation_create" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_ACL_OPERATION_CREATE</span> <span class="o">=</span> <span class="mi">5</span>
</code></pre></div>
<p>CREATE operation </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a526269d7fc5c9acd1b8b56e84895c2bb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a526269d7fc5c9acd1b8b56e84895c2bb </a></li>
</ul>
</div>
<h3 id="rd_kafka_acl_operation_delete">RD_KAFKA_ACL_OPERATION_DELETE<a class="headerlink" href="#rd_kafka_acl_operation_delete" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_ACL_OPERATION_DELETE</span> <span class="o">=</span> <span class="mi">6</span>
</code></pre></div>
<p>DELETE operation </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a526269d7fc5c9acd1b8b56e84895c2bb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a526269d7fc5c9acd1b8b56e84895c2bb </a></li>
</ul>
</div>
<h3 id="rd_kafka_acl_operation_alter">RD_KAFKA_ACL_OPERATION_ALTER<a class="headerlink" href="#rd_kafka_acl_operation_alter" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_ACL_OPERATION_ALTER</span> <span class="o">=</span> <span class="mi">7</span>
</code></pre></div>
<p>ALTER operation </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a526269d7fc5c9acd1b8b56e84895c2bb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a526269d7fc5c9acd1b8b56e84895c2bb </a></li>
</ul>
</div>
<h3 id="rd_kafka_acl_operation_describe">RD_KAFKA_ACL_OPERATION_DESCRIBE<a class="headerlink" href="#rd_kafka_acl_operation_describe" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_ACL_OPERATION_DESCRIBE</span> <span class="o">=</span> <span class="mi">8</span>
</code></pre></div>
<p>DESCRIBE operation </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a526269d7fc5c9acd1b8b56e84895c2bb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a526269d7fc5c9acd1b8b56e84895c2bb </a></li>
</ul>
</div>
<h3 id="rd_kafka_acl_operation_cluster_action">RD_KAFKA_ACL_OPERATION_CLUSTER_ACTION<a class="headerlink" href="#rd_kafka_acl_operation_cluster_action" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_ACL_OPERATION_CLUSTER_ACTION</span> <span class="o">=</span> <span class="mi">9</span>
</code></pre></div>
<p>CLUSTER_ACTION operation </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a526269d7fc5c9acd1b8b56e84895c2bb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a526269d7fc5c9acd1b8b56e84895c2bb </a></li>
</ul>
</div>
<h3 id="rd_kafka_acl_operation_describe_configs">RD_KAFKA_ACL_OPERATION_DESCRIBE_CONFIGS<a class="headerlink" href="#rd_kafka_acl_operation_describe_configs" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_ACL_OPERATION_DESCRIBE_CONFIGS</span> <span class="o">=</span> <span class="mi">10</span>
</code></pre></div>
<p>DESCRIBE_CONFIGS operation </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a526269d7fc5c9acd1b8b56e84895c2bb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a526269d7fc5c9acd1b8b56e84895c2bb </a></li>
</ul>
</div>
<h3 id="rd_kafka_acl_operation_alter_configs">RD_KAFKA_ACL_OPERATION_ALTER_CONFIGS<a class="headerlink" href="#rd_kafka_acl_operation_alter_configs" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_ACL_OPERATION_ALTER_CONFIGS</span> <span class="o">=</span> <span class="mi">11</span>
</code></pre></div>
<p>ALTER_CONFIGS operation </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a526269d7fc5c9acd1b8b56e84895c2bb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a526269d7fc5c9acd1b8b56e84895c2bb </a></li>
</ul>
</div>
<h3 id="rd_kafka_acl_operation_idempotent_write">RD_KAFKA_ACL_OPERATION_IDEMPOTENT_WRITE<a class="headerlink" href="#rd_kafka_acl_operation_idempotent_write" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_ACL_OPERATION_IDEMPOTENT_WRITE</span> <span class="o">=</span> <span class="mi">12</span>
</code></pre></div>
<p>IDEMPOTENT_WRITE operation </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a526269d7fc5c9acd1b8b56e84895c2bb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a526269d7fc5c9acd1b8b56e84895c2bb </a></li>
</ul>
</div>
<h3 id="rd_kafka_acl_operation__cnt">RD_KAFKA_ACL_OPERATION__CNT<a class="headerlink" href="#rd_kafka_acl_operation__cnt" title="Permanent link">&para;</a></h3>
<p><div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_ACL_OPERATION__CNT</span> <span class="o">=</span> <span class="mi">13</span>
</code></pre></div>
enum rd_kafka_AclOperation_t</p>
<h3 id="rd_kafka_acl_permission_type_unknown">RD_KAFKA_ACL_PERMISSION_TYPE_UNKNOWN<a class="headerlink" href="#rd_kafka_acl_permission_type_unknown" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_ACL_PERMISSION_TYPE_UNKNOWN</span> <span class="o">=</span> <span class="mi">0</span>
</code></pre></div>
<p>Unknown </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ab2da1706fced5ccc7ac5566825ba44b8"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ab2da1706fced5ccc7ac5566825ba44b8 </a></li>
</ul>
</div>
<h3 id="rd_kafka_acl_permission_type_any">RD_KAFKA_ACL_PERMISSION_TYPE_ANY<a class="headerlink" href="#rd_kafka_acl_permission_type_any" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_ACL_PERMISSION_TYPE_ANY</span> <span class="o">=</span> <span class="mi">1</span>
</code></pre></div>
<p>In a filter, matches any AclPermissionType </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ab2da1706fced5ccc7ac5566825ba44b8"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ab2da1706fced5ccc7ac5566825ba44b8 </a></li>
</ul>
</div>
<h3 id="rd_kafka_acl_permission_type_deny">RD_KAFKA_ACL_PERMISSION_TYPE_DENY<a class="headerlink" href="#rd_kafka_acl_permission_type_deny" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_ACL_PERMISSION_TYPE_DENY</span> <span class="o">=</span> <span class="mi">2</span>
</code></pre></div>
<p>Disallows access </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ab2da1706fced5ccc7ac5566825ba44b8"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ab2da1706fced5ccc7ac5566825ba44b8 </a></li>
</ul>
</div>
<h3 id="rd_kafka_acl_permission_type_allow">RD_KAFKA_ACL_PERMISSION_TYPE_ALLOW<a class="headerlink" href="#rd_kafka_acl_permission_type_allow" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_ACL_PERMISSION_TYPE_ALLOW</span> <span class="o">=</span> <span class="mi">3</span>
</code></pre></div>
<p>Grants access. </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ab2da1706fced5ccc7ac5566825ba44b8"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ab2da1706fced5ccc7ac5566825ba44b8 </a></li>
</ul>
</div>
<h3 id="rd_kafka_acl_permission_type__cnt">RD_KAFKA_ACL_PERMISSION_TYPE__CNT<a class="headerlink" href="#rd_kafka_acl_permission_type__cnt" title="Permanent link">&para;</a></h3>
<p><div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_ACL_PERMISSION_TYPE__CNT</span> <span class="o">=</span> <span class="mi">4</span>
</code></pre></div>
enum rd_kafka_AclPermissionType_t</p>
<h3 id="rd_kafka_event_listconsumergroups_result">RD_KAFKA_EVENT_LISTCONSUMERGROUPS_RESULT<a class="headerlink" href="#rd_kafka_event_listconsumergroups_result" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_EVENT_LISTCONSUMERGROUPS_RESULT</span> <span class="o">=</span> <span class="mi">8192</span>
</code></pre></div>
<p>ListConsumerGroupsResult_t </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a7ba2a751aaf1dc30083f91d09b8a5d13"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a7ba2a751aaf1dc30083f91d09b8a5d13 </a></li>
</ul>
</div>
<h3 id="rd_kafka_event_describeconsumergroups_result">RD_KAFKA_EVENT_DESCRIBECONSUMERGROUPS_RESULT<a class="headerlink" href="#rd_kafka_event_describeconsumergroups_result" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_EVENT_DESCRIBECONSUMERGROUPS_RESULT</span> <span class="o">=</span> <span class="mi">16384</span>
</code></pre></div>
<p>DescribeConsumerGroups_result_t </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a9f1efde95e9895a55407f2edc2a9dc35"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a9f1efde95e9895a55407f2edc2a9dc35 </a></li>
</ul>
</div>
<h3 id="rd_kafka_event_listconsumergroupoffsets_result">RD_KAFKA_EVENT_LISTCONSUMERGROUPOFFSETS_RESULT<a class="headerlink" href="#rd_kafka_event_listconsumergroupoffsets_result" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_EVENT_LISTCONSUMERGROUPOFFSETS_RESULT</span> <span class="o">=</span> <span class="mi">32768</span>
</code></pre></div>
<p>ListConsumerGroupOffsets_result_t </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a04babfacd056e51968c5c3c4b5410f5f"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a04babfacd056e51968c5c3c4b5410f5f </a></li>
</ul>
</div>
<h3 id="rd_kafka_event_alterconsumergroupoffsets_result">RD_KAFKA_EVENT_ALTERCONSUMERGROUPOFFSETS_RESULT<a class="headerlink" href="#rd_kafka_event_alterconsumergroupoffsets_result" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_EVENT_ALTERCONSUMERGROUPOFFSETS_RESULT</span> <span class="o">=</span> <span class="mi">65536</span>
</code></pre></div>
<p>AlterConsumerGroupOffsets_result_t </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#af2b49b7fc3d4368c8cd24e78c31d275c"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#af2b49b7fc3d4368c8cd24e78c31d275c </a></li>
</ul>
</div>
<h3 id="rd_kafka_consumer_group_state_unknown">RD_KAFKA_CONSUMER_GROUP_STATE_UNKNOWN<a class="headerlink" href="#rd_kafka_consumer_group_state_unknown" title="Permanent link">&para;</a></h3>
<p><div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_CONSUMER_GROUP_STATE_UNKNOWN</span> <span class="o">=</span> <span class="mi">0</span>
</code></pre></div>
enum rd_kafka_consumer_group_state_t</p>
<h3 id="rd_kafka_consumer_group_state_preparing_rebalance">RD_KAFKA_CONSUMER_GROUP_STATE_PREPARING_REBALANCE<a class="headerlink" href="#rd_kafka_consumer_group_state_preparing_rebalance" title="Permanent link">&para;</a></h3>
<p><div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_CONSUMER_GROUP_STATE_PREPARING_REBALANCE</span> <span class="o">=</span> <span class="mi">1</span>
</code></pre></div>
enum rd_kafka_consumer_group_state_t</p>
<h3 id="rd_kafka_consumer_group_state_completing_rebalance">RD_KAFKA_CONSUMER_GROUP_STATE_COMPLETING_REBALANCE<a class="headerlink" href="#rd_kafka_consumer_group_state_completing_rebalance" title="Permanent link">&para;</a></h3>
<p><div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_CONSUMER_GROUP_STATE_COMPLETING_REBALANCE</span> <span class="o">=</span> <span class="mi">2</span>
</code></pre></div>
enum rd_kafka_consumer_group_state_t</p>
<h3 id="rd_kafka_consumer_group_state_stable">RD_KAFKA_CONSUMER_GROUP_STATE_STABLE<a class="headerlink" href="#rd_kafka_consumer_group_state_stable" title="Permanent link">&para;</a></h3>
<p><div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_CONSUMER_GROUP_STATE_STABLE</span> <span class="o">=</span> <span class="mi">3</span>
</code></pre></div>
enum rd_kafka_consumer_group_state_t</p>
<h3 id="rd_kafka_consumer_group_state_dead">RD_KAFKA_CONSUMER_GROUP_STATE_DEAD<a class="headerlink" href="#rd_kafka_consumer_group_state_dead" title="Permanent link">&para;</a></h3>
<p><div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_CONSUMER_GROUP_STATE_DEAD</span> <span class="o">=</span> <span class="mi">4</span>
</code></pre></div>
enum rd_kafka_consumer_group_state_t</p>
<h3 id="rd_kafka_consumer_group_state_empty">RD_KAFKA_CONSUMER_GROUP_STATE_EMPTY<a class="headerlink" href="#rd_kafka_consumer_group_state_empty" title="Permanent link">&para;</a></h3>
<p><div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_CONSUMER_GROUP_STATE_EMPTY</span> <span class="o">=</span> <span class="mi">5</span>
</code></pre></div>
enum rd_kafka_consumer_group_state_t</p>
<h3 id="rd_kafka_consumer_group_state__cnt">RD_KAFKA_CONSUMER_GROUP_STATE__CNT<a class="headerlink" href="#rd_kafka_consumer_group_state__cnt" title="Permanent link">&para;</a></h3>
<p><div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_CONSUMER_GROUP_STATE__CNT</span> <span class="o">=</span> <span class="mi">6</span>
</code></pre></div>
enum rd_kafka_consumer_group_state_t</p>
<h3 id="rd_kafka_admin_op_listconsumergroups">RD_KAFKA_ADMIN_OP_LISTCONSUMERGROUPS<a class="headerlink" href="#rd_kafka_admin_op_listconsumergroups" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_ADMIN_OP_LISTCONSUMERGROUPS</span> <span class="o">=</span> <span class="mi">12</span>
</code></pre></div>
<p>ListConsumerGroups </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe </a></li>
</ul>
</div>
<h3 id="rd_kafka_admin_op_describeconsumergroups">RD_KAFKA_ADMIN_OP_DESCRIBECONSUMERGROUPS<a class="headerlink" href="#rd_kafka_admin_op_describeconsumergroups" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_ADMIN_OP_DESCRIBECONSUMERGROUPS</span> <span class="o">=</span> <span class="mi">13</span>
</code></pre></div>
<p>DescribeConsumerGroups </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe </a></li>
</ul>
</div>
<h3 id="rd_kafka_admin_op_listconsumergroupoffsets">RD_KAFKA_ADMIN_OP_LISTCONSUMERGROUPOFFSETS<a class="headerlink" href="#rd_kafka_admin_op_listconsumergroupoffsets" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_ADMIN_OP_LISTCONSUMERGROUPOFFSETS</span> <span class="o">=</span> <span class="mi">14</span>
</code></pre></div>
<p>ListConsumerGroupOffsets </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe </a></li>
</ul>
</div>
<h3 id="rd_kafka_admin_op_alterconsumergroupoffsets">RD_KAFKA_ADMIN_OP_ALTERCONSUMERGROUPOFFSETS<a class="headerlink" href="#rd_kafka_admin_op_alterconsumergroupoffsets" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_ADMIN_OP_ALTERCONSUMERGROUPOFFSETS</span> <span class="o">=</span> <span class="mi">15</span>
</code></pre></div>
<p>AlterConsumerGroupOffsets </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err__log_truncation">RD_KAFKA_RESP_ERR__LOG_TRUNCATION<a class="headerlink" href="#rd_kafka_resp_err__log_truncation" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR__LOG_TRUNCATION</span> <span class="o">=</span> <span class="o">-</span><span class="mi">139</span>
</code></pre></div>
<p>Partition log truncation detected </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_event_incrementalalterconfigs_result">RD_KAFKA_EVENT_INCREMENTALALTERCONFIGS_RESULT<a class="headerlink" href="#rd_kafka_event_incrementalalterconfigs_result" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_EVENT_INCREMENTALALTERCONFIGS_RESULT</span> <span class="o">=</span> <span class="mi">131072</span>
</code></pre></div>
<p>IncrementalAlterConfigs_result_t </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ab9388401d375ee75080814b9a1aff78c"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#ab9388401d375ee75080814b9a1aff78c </a></li>
</ul>
</div>
<h3 id="rd_kafka_event_describeuserscramcredentials_result">RD_KAFKA_EVENT_DESCRIBEUSERSCRAMCREDENTIALS_RESULT<a class="headerlink" href="#rd_kafka_event_describeuserscramcredentials_result" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_EVENT_DESCRIBEUSERSCRAMCREDENTIALS_RESULT</span> <span class="o">=</span> <span class="mi">262144</span>
</code></pre></div>
<p>DescribeUserScramCredentials_result_t </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a05a179e0165a01bfd72fd78163c465c1"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a05a179e0165a01bfd72fd78163c465c1 </a></li>
</ul>
</div>
<h3 id="rd_kafka_event_alteruserscramcredentials_result">RD_KAFKA_EVENT_ALTERUSERSCRAMCREDENTIALS_RESULT<a class="headerlink" href="#rd_kafka_event_alteruserscramcredentials_result" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_EVENT_ALTERUSERSCRAMCREDENTIALS_RESULT</span> <span class="o">=</span> <span class="mi">524288</span>
</code></pre></div>
<p>AlterUserScramCredentials_result_t </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a11f6abfe27ffb6edcd184df41218f5cf"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a11f6abfe27ffb6edcd184df41218f5cf </a></li>
</ul>
</div>
<h3 id="rd_kafka_admin_op_incrementalalterconfigs">RD_KAFKA_ADMIN_OP_INCREMENTALALTERCONFIGS<a class="headerlink" href="#rd_kafka_admin_op_incrementalalterconfigs" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_ADMIN_OP_INCREMENTALALTERCONFIGS</span> <span class="o">=</span> <span class="mi">16</span>
</code></pre></div>
<p>IncrementalAlterConfigs </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe </a></li>
</ul>
</div>
<h3 id="rd_kafka_admin_op_describeuserscramcredentials">RD_KAFKA_ADMIN_OP_DESCRIBEUSERSCRAMCREDENTIALS<a class="headerlink" href="#rd_kafka_admin_op_describeuserscramcredentials" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_ADMIN_OP_DESCRIBEUSERSCRAMCREDENTIALS</span> <span class="o">=</span> <span class="mi">17</span>
</code></pre></div>
<p>DescribeUserScramCredentials </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe </a></li>
</ul>
</div>
<h3 id="rd_kafka_admin_op_alteruserscramcredentials">RD_KAFKA_ADMIN_OP_ALTERUSERSCRAMCREDENTIALS<a class="headerlink" href="#rd_kafka_admin_op_alteruserscramcredentials" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_ADMIN_OP_ALTERUSERSCRAMCREDENTIALS</span> <span class="o">=</span> <span class="mi">18</span>
</code></pre></div>
<p>AlterUserScramCredentials </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe </a></li>
</ul>
</div>
<h3 id="rd_kafka_alter_config_op_type_set">RD_KAFKA_ALTER_CONFIG_OP_TYPE_SET<a class="headerlink" href="#rd_kafka_alter_config_op_type_set" title="Permanent link">&para;</a></h3>
<p><div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_ALTER_CONFIG_OP_TYPE_SET</span> <span class="o">=</span> <span class="mi">0</span>
</code></pre></div>
enum rd_kafka_AlterConfigOpType_t</p>
<h3 id="rd_kafka_alter_config_op_type_delete">RD_KAFKA_ALTER_CONFIG_OP_TYPE_DELETE<a class="headerlink" href="#rd_kafka_alter_config_op_type_delete" title="Permanent link">&para;</a></h3>
<p><div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_ALTER_CONFIG_OP_TYPE_DELETE</span> <span class="o">=</span> <span class="mi">1</span>
</code></pre></div>
enum rd_kafka_AlterConfigOpType_t</p>
<h3 id="rd_kafka_alter_config_op_type_append">RD_KAFKA_ALTER_CONFIG_OP_TYPE_APPEND<a class="headerlink" href="#rd_kafka_alter_config_op_type_append" title="Permanent link">&para;</a></h3>
<p><div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_ALTER_CONFIG_OP_TYPE_APPEND</span> <span class="o">=</span> <span class="mi">2</span>
</code></pre></div>
enum rd_kafka_AlterConfigOpType_t</p>
<h3 id="rd_kafka_alter_config_op_type_subtract">RD_KAFKA_ALTER_CONFIG_OP_TYPE_SUBTRACT<a class="headerlink" href="#rd_kafka_alter_config_op_type_subtract" title="Permanent link">&para;</a></h3>
<p><div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_ALTER_CONFIG_OP_TYPE_SUBTRACT</span> <span class="o">=</span> <span class="mi">3</span>
</code></pre></div>
enum rd_kafka_AlterConfigOpType_t</p>
<h3 id="rd_kafka_alter_config_op_type__cnt">RD_KAFKA_ALTER_CONFIG_OP_TYPE__CNT<a class="headerlink" href="#rd_kafka_alter_config_op_type__cnt" title="Permanent link">&para;</a></h3>
<p><div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_ALTER_CONFIG_OP_TYPE__CNT</span> <span class="o">=</span> <span class="mi">4</span>
</code></pre></div>
enum rd_kafka_AlterConfigOpType_t</p>
<h3 id="rd_kafka_scram_mechanism_unknown">RD_KAFKA_SCRAM_MECHANISM_UNKNOWN<a class="headerlink" href="#rd_kafka_scram_mechanism_unknown" title="Permanent link">&para;</a></h3>
<p><div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_SCRAM_MECHANISM_UNKNOWN</span> <span class="o">=</span> <span class="mi">0</span>
</code></pre></div>
enum rd_kafka_ScramMechanism_t</p>
<h3 id="rd_kafka_scram_mechanism_sha_256">RD_KAFKA_SCRAM_MECHANISM_SHA_256<a class="headerlink" href="#rd_kafka_scram_mechanism_sha_256" title="Permanent link">&para;</a></h3>
<p><div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_SCRAM_MECHANISM_SHA_256</span> <span class="o">=</span> <span class="mi">1</span>
</code></pre></div>
enum rd_kafka_ScramMechanism_t</p>
<h3 id="rd_kafka_scram_mechanism_sha_512">RD_KAFKA_SCRAM_MECHANISM_SHA_512<a class="headerlink" href="#rd_kafka_scram_mechanism_sha_512" title="Permanent link">&para;</a></h3>
<p><div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_SCRAM_MECHANISM_SHA_512</span> <span class="o">=</span> <span class="mi">2</span>
</code></pre></div>
enum rd_kafka_ScramMechanism_t</p>
<h3 id="rd_kafka_scram_mechanism__cnt">RD_KAFKA_SCRAM_MECHANISM__CNT<a class="headerlink" href="#rd_kafka_scram_mechanism__cnt" title="Permanent link">&para;</a></h3>
<p><div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_SCRAM_MECHANISM__CNT</span> <span class="o">=</span> <span class="mi">3</span>
</code></pre></div>
enum rd_kafka_ScramMechanism_t</p>
<h3 id="rd_kafka_event_describetopics_result">RD_KAFKA_EVENT_DESCRIBETOPICS_RESULT<a class="headerlink" href="#rd_kafka_event_describetopics_result" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_EVENT_DESCRIBETOPICS_RESULT</span> <span class="o">=</span> <span class="mi">1048576</span>
</code></pre></div>
<p>DescribeTopics_result_t </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a54fb65ad2053d2a8058932f414d0af1a"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a54fb65ad2053d2a8058932f414d0af1a </a></li>
</ul>
</div>
<h3 id="rd_kafka_event_describecluster_result">RD_KAFKA_EVENT_DESCRIBECLUSTER_RESULT<a class="headerlink" href="#rd_kafka_event_describecluster_result" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_EVENT_DESCRIBECLUSTER_RESULT</span> <span class="o">=</span> <span class="mi">2097152</span>
</code></pre></div>
<p>DescribeCluster_result_t </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a9834684799e542cdcf5ad60d0b3f9fc0"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a9834684799e542cdcf5ad60d0b3f9fc0 </a></li>
</ul>
</div>
<h3 id="rd_kafka_event_listoffsets_result">RD_KAFKA_EVENT_LISTOFFSETS_RESULT<a class="headerlink" href="#rd_kafka_event_listoffsets_result" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_EVENT_LISTOFFSETS_RESULT</span> <span class="o">=</span> <span class="mi">4194304</span>
</code></pre></div>
<p>ListOffsets_result_t </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8cb212872006d6ae10574cd8fdeacb7c"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8cb212872006d6ae10574cd8fdeacb7c </a></li>
</ul>
</div>
<h3 id="rd_kafka_admin_op_describetopics">RD_KAFKA_ADMIN_OP_DESCRIBETOPICS<a class="headerlink" href="#rd_kafka_admin_op_describetopics" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_ADMIN_OP_DESCRIBETOPICS</span> <span class="o">=</span> <span class="mi">19</span>
</code></pre></div>
<p>DescribeTopics </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe </a></li>
</ul>
</div>
<h3 id="rd_kafka_admin_op_describecluster">RD_KAFKA_ADMIN_OP_DESCRIBECLUSTER<a class="headerlink" href="#rd_kafka_admin_op_describecluster" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_ADMIN_OP_DESCRIBECLUSTER</span> <span class="o">=</span> <span class="mi">20</span>
</code></pre></div>
<p>DescribeCluster </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe </a></li>
</ul>
</div>
<h3 id="rd_kafka_admin_op_listoffsets">RD_KAFKA_ADMIN_OP_LISTOFFSETS<a class="headerlink" href="#rd_kafka_admin_op_listoffsets" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_ADMIN_OP_LISTOFFSETS</span> <span class="o">=</span> <span class="mi">21</span>
</code></pre></div>
<p>ListOffsets </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe </a></li>
</ul>
</div>
<h3 id="rd_kafka_isolation_level_read_uncommitted">RD_KAFKA_ISOLATION_LEVEL_READ_UNCOMMITTED<a class="headerlink" href="#rd_kafka_isolation_level_read_uncommitted" title="Permanent link">&para;</a></h3>
<p><div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_ISOLATION_LEVEL_READ_UNCOMMITTED</span> <span class="o">=</span> <span class="mi">0</span>
</code></pre></div>
enum rd_kafka_IsolationLevel_t</p>
<h3 id="rd_kafka_isolation_level_read_committed">RD_KAFKA_ISOLATION_LEVEL_READ_COMMITTED<a class="headerlink" href="#rd_kafka_isolation_level_read_committed" title="Permanent link">&para;</a></h3>
<p><div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_ISOLATION_LEVEL_READ_COMMITTED</span> <span class="o">=</span> <span class="mi">1</span>
</code></pre></div>
enum rd_kafka_IsolationLevel_t</p>
<h3 id="rd_kafka_offset_spec_max_timestamp">RD_KAFKA_OFFSET_SPEC_MAX_TIMESTAMP<a class="headerlink" href="#rd_kafka_offset_spec_max_timestamp" title="Permanent link">&para;</a></h3>
<p><div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_OFFSET_SPEC_MAX_TIMESTAMP</span> <span class="o">=</span> <span class="o">-</span><span class="mi">3</span>
</code></pre></div>
enum rd_kafka_OffsetSpec_t</p>
<h3 id="rd_kafka_offset_spec_earliest">RD_KAFKA_OFFSET_SPEC_EARLIEST<a class="headerlink" href="#rd_kafka_offset_spec_earliest" title="Permanent link">&para;</a></h3>
<p><div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_OFFSET_SPEC_EARLIEST</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span>
</code></pre></div>
enum rd_kafka_OffsetSpec_t</p>
<h3 id="rd_kafka_offset_spec_latest">RD_KAFKA_OFFSET_SPEC_LATEST<a class="headerlink" href="#rd_kafka_offset_spec_latest" title="Permanent link">&para;</a></h3>
<p><div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_OFFSET_SPEC_LATEST</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
</code></pre></div>
enum rd_kafka_OffsetSpec_t</p>
<h3 id="rd_kafka_resp_err__invalid_different_record">RD_KAFKA_RESP_ERR__INVALID_DIFFERENT_RECORD<a class="headerlink" href="#rd_kafka_resp_err__invalid_different_record" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR__INVALID_DIFFERENT_RECORD</span> <span class="o">=</span> <span class="o">-</span><span class="mi">138</span>
</code></pre></div>
<p>A different record in the batch was invalid and this message failed persisting. </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_unknown_topic_id">RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_ID<a class="headerlink" href="#rd_kafka_resp_err_unknown_topic_id" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_ID</span> <span class="o">=</span> <span class="mi">100</span>
</code></pre></div>
<p>Unknown Topic Id </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_fenced_member_epoch">RD_KAFKA_RESP_ERR_FENCED_MEMBER_EPOCH<a class="headerlink" href="#rd_kafka_resp_err_fenced_member_epoch" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_FENCED_MEMBER_EPOCH</span> <span class="o">=</span> <span class="mi">110</span>
</code></pre></div>
<p>The member epoch is fenced by the group coordinator </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_unreleased_instance_id">RD_KAFKA_RESP_ERR_UNRELEASED_INSTANCE_ID<a class="headerlink" href="#rd_kafka_resp_err_unreleased_instance_id" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_UNRELEASED_INSTANCE_ID</span> <span class="o">=</span> <span class="mi">111</span>
</code></pre></div>
<p>The instance ID is still used by another member in the consumer group </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_unsupported_assignor">RD_KAFKA_RESP_ERR_UNSUPPORTED_ASSIGNOR<a class="headerlink" href="#rd_kafka_resp_err_unsupported_assignor" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_UNSUPPORTED_ASSIGNOR</span> <span class="o">=</span> <span class="mi">112</span>
</code></pre></div>
<p>The assignor or its version range is not supported by the consumer group </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_stale_member_epoch">RD_KAFKA_RESP_ERR_STALE_MEMBER_EPOCH<a class="headerlink" href="#rd_kafka_resp_err_stale_member_epoch" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_STALE_MEMBER_EPOCH</span> <span class="o">=</span> <span class="mi">113</span>
</code></pre></div>
<p>The member epoch is stale </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_unknown_subscription_id">RD_KAFKA_RESP_ERR_UNKNOWN_SUBSCRIPTION_ID<a class="headerlink" href="#rd_kafka_resp_err_unknown_subscription_id" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_UNKNOWN_SUBSCRIPTION_ID</span> <span class="o">=</span> <span class="mi">117</span>
</code></pre></div>
<p>Client sent a push telemetry request with an invalid or outdated subscription ID. </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_telemetry_too_large">RD_KAFKA_RESP_ERR_TELEMETRY_TOO_LARGE<a class="headerlink" href="#rd_kafka_resp_err_telemetry_too_large" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_TELEMETRY_TOO_LARGE</span> <span class="o">=</span> <span class="mi">118</span>
</code></pre></div>
<p>Client sent a push telemetry request larger than the maximum size the broker will accept. </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_event_electleaders_result">RD_KAFKA_EVENT_ELECTLEADERS_RESULT<a class="headerlink" href="#rd_kafka_event_electleaders_result" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_EVENT_ELECTLEADERS_RESULT</span> <span class="o">=</span> <span class="mi">8388608</span>
</code></pre></div>
<p>ElectLeaders_result_t </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a7f8345f7468058dcce009b1ed891d36e"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a7f8345f7468058dcce009b1ed891d36e </a></li>
</ul>
</div>
<h3 id="rd_kafka_consumer_group_type_unknown">RD_KAFKA_CONSUMER_GROUP_TYPE_UNKNOWN<a class="headerlink" href="#rd_kafka_consumer_group_type_unknown" title="Permanent link">&para;</a></h3>
<p><div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_CONSUMER_GROUP_TYPE_UNKNOWN</span> <span class="o">=</span> <span class="mi">0</span>
</code></pre></div>
enum rd_kafka_consumer_group_type_t</p>
<h3 id="rd_kafka_consumer_group_type_consumer">RD_KAFKA_CONSUMER_GROUP_TYPE_CONSUMER<a class="headerlink" href="#rd_kafka_consumer_group_type_consumer" title="Permanent link">&para;</a></h3>
<p><div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_CONSUMER_GROUP_TYPE_CONSUMER</span> <span class="o">=</span> <span class="mi">1</span>
</code></pre></div>
enum rd_kafka_consumer_group_type_t</p>
<h3 id="rd_kafka_consumer_group_type_classic">RD_KAFKA_CONSUMER_GROUP_TYPE_CLASSIC<a class="headerlink" href="#rd_kafka_consumer_group_type_classic" title="Permanent link">&para;</a></h3>
<p><div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_CONSUMER_GROUP_TYPE_CLASSIC</span> <span class="o">=</span> <span class="mi">2</span>
</code></pre></div>
enum rd_kafka_consumer_group_type_t</p>
<h3 id="rd_kafka_consumer_group_type__cnt">RD_KAFKA_CONSUMER_GROUP_TYPE__CNT<a class="headerlink" href="#rd_kafka_consumer_group_type__cnt" title="Permanent link">&para;</a></h3>
<p><div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_CONSUMER_GROUP_TYPE__CNT</span> <span class="o">=</span> <span class="mi">3</span>
</code></pre></div>
enum rd_kafka_consumer_group_type_t</p>
<h3 id="rd_kafka_admin_op_electleaders">RD_KAFKA_ADMIN_OP_ELECTLEADERS<a class="headerlink" href="#rd_kafka_admin_op_electleaders" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_ADMIN_OP_ELECTLEADERS</span> <span class="o">=</span> <span class="mi">22</span>
</code></pre></div>
<p>ElectLeaders </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe </a></li>
</ul>
</div>
<h3 id="rd_kafka_resource_transactional_id">RD_KAFKA_RESOURCE_TRANSACTIONAL_ID<a class="headerlink" href="#rd_kafka_resource_transactional_id" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESOURCE_TRANSACTIONAL_ID</span> <span class="o">=</span> <span class="mi">5</span>
</code></pre></div>
<p>Transactional ID </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#acca83a66d7783ff7683ed2691cc907c9"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#acca83a66d7783ff7683ed2691cc907c9 </a></li>
</ul>
</div>
<h3 id="rd_kafka_election_type_preferred">RD_KAFKA_ELECTION_TYPE_PREFERRED<a class="headerlink" href="#rd_kafka_election_type_preferred" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_ELECTION_TYPE_PREFERRED</span> <span class="o">=</span> <span class="mi">0</span>
</code></pre></div>
<p>Preferred Replica Election </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aea051bad25a647e140abc310d2f400d4"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aea051bad25a647e140abc310d2f400d4 </a></li>
</ul>
</div>
<h3 id="rd_kafka_election_type_unclean">RD_KAFKA_ELECTION_TYPE_UNCLEAN<a class="headerlink" href="#rd_kafka_election_type_unclean" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_ELECTION_TYPE_UNCLEAN</span> <span class="o">=</span> <span class="mi">1</span>
</code></pre></div>
<p>Unclean Election </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aea051bad25a647e140abc310d2f400d4"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aea051bad25a647e140abc310d2f400d4 </a></li>
</ul>
</div>
<h3 id="rd_kafka_supported_methods">RD_KAFKA_SUPPORTED_METHODS<a class="headerlink" href="#rd_kafka_supported_methods" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_SUPPORTED_METHODS</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;rd_kafka_version&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_version_str&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_get_debug_contexts&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_get_err_descs&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_err2str&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_err2name&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_last_error&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_errno2err&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_errno&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_fatal_error&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_test_fatal_error&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_topic_partition_destroy&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_topic_partition_list_new&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_topic_partition_list_destroy&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_topic_partition_list_add&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_topic_partition_list_add_range&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_topic_partition_list_del&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_topic_partition_list_del_by_idx&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_topic_partition_list_copy&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_topic_partition_list_set_offset&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_topic_partition_list_find&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_topic_partition_list_sort&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_headers_new&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_headers_destroy&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_headers_copy&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_header_add&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_header_remove&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_header_get_last&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_header_get&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_header_get_all&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_message_destroy&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_message_timestamp&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_message_latency&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_message_headers&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_message_detach_headers&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_message_set_headers&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_header_cnt&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_message_status&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_conf_new&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_conf_destroy&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_conf_dup&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_conf_dup_filter&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_conf_set&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_conf_set_events&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_conf_set_background_event_cb&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_conf_set_dr_cb&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_conf_set_dr_msg_cb&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_conf_set_consume_cb&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_conf_set_rebalance_cb&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_conf_set_offset_commit_cb&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_conf_set_error_cb&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_conf_set_throttle_cb&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_conf_set_log_cb&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_conf_set_stats_cb&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_conf_set_socket_cb&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_conf_set_connect_cb&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_conf_set_closesocket_cb&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_conf_set_opaque&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_opaque&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_conf_set_default_topic_conf&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_conf_get&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_topic_conf_get&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_conf_dump&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_topic_conf_dump&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_conf_dump_free&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_conf_properties_show&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_topic_conf_new&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_topic_conf_dup&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_default_topic_conf_dup&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_topic_conf_destroy&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_topic_conf_set&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_topic_conf_set_opaque&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_topic_conf_set_partitioner_cb&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_topic_conf_set_msg_order_cmp&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_topic_partition_available&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_msg_partitioner_random&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_msg_partitioner_consistent&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_msg_partitioner_consistent_random&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_msg_partitioner_murmur2&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_msg_partitioner_murmur2_random&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_new&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_destroy&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_destroy_flags&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_name&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_type&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_memberid&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_clusterid&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_controllerid&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_topic_new&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_topic_destroy&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_topic_name&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_topic_opaque&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_poll&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_yield&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_pause_partitions&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_resume_partitions&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_query_watermark_offsets&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_get_watermark_offsets&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_offsets_for_times&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_mem_free&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_queue_new&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_queue_destroy&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_queue_get_main&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_queue_get_consumer&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_queue_get_partition&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_queue_get_background&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_queue_forward&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_set_log_queue&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_queue_length&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_queue_io_event_enable&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_queue_cb_event_enable&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_consume_start&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_consume_start_queue&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_consume_stop&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_seek&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_consume&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_consume_batch&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_consume_callback&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_consume_queue&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_consume_batch_queue&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_consume_callback_queue&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_offset_store&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_offsets_store&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_subscribe&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_unsubscribe&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_subscription&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_consumer_poll&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_consumer_close&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_assign&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_assignment&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_commit&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_commit_message&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_commit_queue&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_committed&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_position&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_produce&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_producev&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_produce_batch&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_flush&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_purge&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_metadata&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_metadata_destroy&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_list_groups&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_group_list_destroy&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_brokers_add&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_set_logger&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_set_log_level&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_log_print&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_log_syslog&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_outq_len&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_dump&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_thread_cnt&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_wait_destroyed&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_unittest&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_poll_set_consumer&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_event_type&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_event_name&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_event_destroy&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_event_message_next&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_event_message_array&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_event_message_count&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_event_error&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_event_error_string&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_event_error_is_fatal&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_event_opaque&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_event_log&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_event_stats&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_event_topic_partition_list&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_event_topic_partition&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_event_CreateTopics_result&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_event_DeleteTopics_result&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_event_CreatePartitions_result&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_event_AlterConfigs_result&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_event_DescribeConfigs_result&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_queue_poll&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_queue_poll_callback&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_plugin_f_conf_init_t&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_interceptor_f_on_conf_set_t&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_interceptor_f_on_conf_dup_t&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_interceptor_f_on_conf_destroy_t&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_interceptor_f_on_new_t&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_interceptor_f_on_destroy_t&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_interceptor_f_on_send_t&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_interceptor_f_on_acknowledgement_t&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_interceptor_f_on_consume_t&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_interceptor_f_on_commit_t&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_interceptor_f_on_request_sent_t&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_conf_interceptor_add_on_conf_set&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_conf_interceptor_add_on_conf_dup&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_conf_interceptor_add_on_conf_destroy&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_conf_interceptor_add_on_new&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_interceptor_add_on_destroy&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_interceptor_add_on_send&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_interceptor_add_on_acknowledgement&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_interceptor_add_on_consume&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_interceptor_add_on_commit&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_interceptor_add_on_request_sent&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_topic_result_error&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_topic_result_error_string&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_topic_result_name&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_AdminOptions_new&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_AdminOptions_destroy&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_AdminOptions_set_request_timeout&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_AdminOptions_set_operation_timeout&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_AdminOptions_set_validate_only&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_AdminOptions_set_broker&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_AdminOptions_set_opaque&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_NewTopic_new&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_NewTopic_destroy&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_NewTopic_destroy_array&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_NewTopic_set_replica_assignment&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_NewTopic_set_config&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_CreateTopics&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_CreateTopics_result_topics&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_DeleteTopic_new&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_DeleteTopic_destroy&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_DeleteTopic_destroy_array&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_DeleteTopics&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_DeleteTopics_result_topics&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_NewPartitions_new&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_NewPartitions_destroy&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_NewPartitions_destroy_array&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_NewPartitions_set_replica_assignment&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_CreatePartitions&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_CreatePartitions_result_topics&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_ConfigSource_name&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_ConfigEntry_name&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_ConfigEntry_value&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_ConfigEntry_source&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_ConfigEntry_is_read_only&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_ConfigEntry_is_default&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_ConfigEntry_is_sensitive&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_ConfigEntry_is_synonym&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_ConfigEntry_synonyms&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_ResourceType_name&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_ConfigResource_new&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_ConfigResource_destroy&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_ConfigResource_destroy_array&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_ConfigResource_set_config&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_ConfigResource_configs&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_ConfigResource_type&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_ConfigResource_name&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_ConfigResource_error&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_ConfigResource_error_string&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_AlterConfigs&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_AlterConfigs_result_resources&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_DescribeConfigs&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_DescribeConfigs_result_resources&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_conf&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.1.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_conf_set_oauthbearer_token_refresh_cb&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.1.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_conf_set_ssl_cert_verify_cb&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.1.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_conf_set_ssl_cert&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.1.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_event_config_string&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.1.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_oauthbearer_set_token&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.1.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_oauthbearer_set_token_failure&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.1.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_interceptor_f_on_thread_start_t&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.2.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_interceptor_f_on_thread_exit_t&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.2.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_interceptor_add_on_thread_start&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.2.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_interceptor_add_on_thread_exit&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.2.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_mock_cluster_new&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.3.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_mock_cluster_destroy&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.3.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_mock_cluster_handle&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.3.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_mock_cluster_bootstraps&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.3.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_mock_push_request_errors&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.3.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_mock_topic_set_error&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.3.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_mock_partition_set_leader&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.3.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_mock_partition_set_follower&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.3.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_mock_partition_set_follower_wmarks&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.3.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_mock_broker_set_rack&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.3.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_error_code&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.4.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_error_name&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.4.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_error_string&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.4.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_error_is_fatal&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.4.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_error_is_retriable&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.4.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_error_txn_requires_abort&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.4.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_error_destroy&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.4.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_error_new&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.4.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_msg_partitioner_fnv1a&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.4.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_msg_partitioner_fnv1a_random&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.4.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_consumer_group_metadata&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.4.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_consumer_group_metadata_new&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.4.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_consumer_group_metadata_destroy&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.4.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_consumer_group_metadata_write&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.4.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_consumer_group_metadata_read&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.4.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_init_transactions&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.4.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_begin_transaction&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.4.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_send_offsets_to_transaction&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.4.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_commit_transaction&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.4.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_abort_transaction&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.4.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_handle_mock_cluster&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.4.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_mock_topic_create&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.4.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_mock_broker_set_down&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.4.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_mock_broker_set_up&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.4.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_mock_coordinator_set&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.4.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_mock_set_apiversion&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.4.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_mock_broker_set_rtt&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.4.4&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_message_errstr&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.5.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_message_broker_id&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.5.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_produceva&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.5.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_event_debug_contexts&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.5.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_mock_broker_push_request_errors&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.5.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.6.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_conf_get_default_topic_conf&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.6.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_queue_yield&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.6.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_seek_partitions&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.6.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_incremental_assign&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.6.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_incremental_unassign&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.6.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_rebalance_protocol&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.6.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_assignment_lost&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.6.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_consumer_group_metadata_new_with_genid&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.6.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_event_DeleteRecords_result&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.6.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_event_DeleteGroups_result&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.6.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_event_DeleteConsumerGroupOffsets_result&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.6.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_group_result_error&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.6.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_group_result_name&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.6.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_group_result_partitions&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.6.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_DeleteRecords_new&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.6.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_DeleteRecords_destroy&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.6.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_DeleteRecords_destroy_array&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.6.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_DeleteRecords&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.6.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_DeleteRecords_result_offsets&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.6.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_DeleteGroup_new&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.6.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_DeleteGroup_destroy&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.6.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_DeleteGroup_destroy_array&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.6.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_DeleteGroups&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.6.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_DeleteGroups_result_groups&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.6.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_DeleteConsumerGroupOffsets_new&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.6.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_DeleteConsumerGroupOffsets_destroy&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.6.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_DeleteConsumerGroupOffsets_destroy_array&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.6.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_DeleteConsumerGroupOffsets&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.6.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_DeleteConsumerGroupOffsets_result_groups&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.6.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_mock_clear_request_errors&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.6.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_mock_push_request_errors_array&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.6.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_interceptor_f_on_response_received_t&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.6.1&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_interceptor_add_on_response_received&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.6.1&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_conf_set_engine_callback_data&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.7.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_mem_calloc&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.7.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_mem_malloc&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.7.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_mock_broker_push_request_error_rtts&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.7.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_conf_enable_sasl_queue&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.9.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_queue_get_sasl&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.9.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_sasl_background_callbacks_enable&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.9.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_consumer_close_queue&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.9.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_consumer_closed&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.9.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_event_CreateAcls_result&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.9.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_event_DescribeAcls_result&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.9.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_event_DeleteAcls_result&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.9.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_ResourcePatternType_name&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.9.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_acl_result_error&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.9.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_AclOperation_name&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.9.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_AclPermissionType_name&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.9.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_AclBinding_new&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.9.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_AclBindingFilter_new&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.9.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_AclBinding_restype&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.9.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_AclBinding_name&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.9.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_AclBinding_principal&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.9.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_AclBinding_host&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.9.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_AclBinding_operation&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.9.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_AclBinding_permission_type&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.9.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_AclBinding_resource_pattern_type&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.9.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_AclBinding_error&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.9.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_AclBinding_destroy&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.9.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_AclBinding_destroy_array&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.9.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_CreateAcls_result_acls&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.9.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_CreateAcls&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.9.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_DescribeAcls_result_acls&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.9.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_DescribeAcls&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.9.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_DeleteAcls_result_responses&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.9.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_DeleteAcls_result_response_error&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.9.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_DeleteAcls_result_response_matching_acls&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.9.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_DeleteAcls&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.9.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_conf_set_resolve_cb&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_sasl_set_credentials&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_Node_id&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_Node_host&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_Node_port&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_consumer_group_state_name&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_consumer_group_state_code&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_event_ListConsumerGroups_result&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_event_DescribeConsumerGroups_result&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_event_AlterConsumerGroupOffsets_result&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_event_ListConsumerGroupOffsets_result&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_interceptor_f_on_broker_state_change_t&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_interceptor_add_on_broker_state_change&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_AdminOptions_set_require_stable_offsets&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_AdminOptions_set_match_consumer_group_states&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_ListConsumerGroups&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_ConsumerGroupListing_group_id&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_ConsumerGroupListing_is_simple_consumer_group&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_ConsumerGroupListing_state&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_ListConsumerGroups_result_valid&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_ListConsumerGroups_result_errors&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_DescribeConsumerGroups&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_DescribeConsumerGroups_result_groups&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_ConsumerGroupDescription_group_id&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_ConsumerGroupDescription_error&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_ConsumerGroupDescription_is_simple_consumer_group&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_ConsumerGroupDescription_partition_assignor&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_ConsumerGroupDescription_state&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_ConsumerGroupDescription_coordinator&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_ConsumerGroupDescription_member_count&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_ConsumerGroupDescription_member&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_MemberDescription_client_id&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_MemberDescription_group_instance_id&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_MemberDescription_consumer_id&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_MemberDescription_host&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_MemberDescription_assignment&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_MemberAssignment_partitions&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_ListConsumerGroupOffsets_new&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_ListConsumerGroupOffsets_destroy&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_ListConsumerGroupOffsets_destroy_array&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_ListConsumerGroupOffsets&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_ListConsumerGroupOffsets_result_groups&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_AlterConsumerGroupOffsets_new&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_AlterConsumerGroupOffsets_destroy&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_AlterConsumerGroupOffsets_destroy_array&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_AlterConsumerGroupOffsets&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_AlterConsumerGroupOffsets_result_groups&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_mock_broker_error_stack_cnt&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_topic_partition_set_leader_epoch&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.1.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_topic_partition_get_leader_epoch&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.1.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_message_leader_epoch&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.1.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_offset_store_message&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.1.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_event_IncrementalAlterConfigs_result&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.2.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_event_DescribeUserScramCredentials_result&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.2.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_event_AlterUserScramCredentials_result&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.2.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_ConfigResource_add_incremental_config&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.2.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_IncrementalAlterConfigs&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.2.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_IncrementalAlterConfigs_result_resources&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.2.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_ScramCredentialInfo_mechanism&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.2.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_ScramCredentialInfo_iterations&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.2.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_UserScramCredentialsDescription_user&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.2.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_UserScramCredentialsDescription_error&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.2.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_UserScramCredentialsDescription_scramcredentialinfo_count&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.2.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_UserScramCredentialsDescription_scramcredentialinfo&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.2.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_DescribeUserScramCredentials_result_descriptions&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.2.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_DescribeUserScramCredentials&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.2.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_UserScramCredentialUpsertion_new&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.2.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_UserScramCredentialDeletion_new&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.2.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_UserScramCredentialAlteration_destroy&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.2.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_UserScramCredentialAlteration_destroy_array&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.2.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_AlterUserScramCredentials_result_response_user&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.2.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_AlterUserScramCredentials_result_response_error&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.2.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_AlterUserScramCredentials_result_responses&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.2.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_AlterUserScramCredentials&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.2.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_Uuid_base64str&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.3.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_Uuid_least_significant_bits&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.3.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_Uuid_most_significant_bits&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.3.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_Uuid_new&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.3.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_Uuid_copy&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.3.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_Uuid_destroy&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.3.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_Node_rack&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.3.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_event_DescribeTopics_result&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.3.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_event_DescribeCluster_result&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.3.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_event_ListOffsets_result&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.3.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_AdminOptions_set_include_authorized_operations&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.3.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_AdminOptions_set_isolation_level&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.3.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_TopicCollection_of_topic_names&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.3.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_TopicCollection_destroy&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.3.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_DescribeTopics&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.3.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_DescribeTopics_result_topics&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.3.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_TopicDescription_partitions&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.3.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_TopicPartitionInfo_partition&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.3.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_TopicPartitionInfo_leader&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.3.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_TopicPartitionInfo_isr&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.3.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_TopicPartitionInfo_replicas&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.3.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_TopicDescription_authorized_operations&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.3.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_TopicDescription_name&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.3.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_TopicDescription_topic_id&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.3.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_TopicDescription_is_internal&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.3.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_TopicDescription_error&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.3.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_DescribeCluster&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.3.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_DescribeCluster_result_nodes&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.3.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_DescribeCluster_result_authorized_operations&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.3.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_DescribeCluster_result_controller&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.3.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_DescribeCluster_result_cluster_id&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.3.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_ConsumerGroupDescription_authorized_operations&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.3.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_ListOffsetsResultInfo_topic_partition&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.3.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_ListOffsetsResultInfo_timestamp&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.3.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_ListOffsets_result_infos&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.3.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_ListOffsets&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.3.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_mock_start_request_tracking&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.3.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_mock_stop_request_tracking&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.3.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_mock_request_destroy&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.3.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_mock_request_id&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.3.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_mock_request_api_key&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.3.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_mock_request_timestamp&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.3.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_mock_get_requests&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.3.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_mock_clear_requests&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.3.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_message_produce_errstr&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.4.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_consumer_group_metadata_member_id&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.4.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_mock_partition_push_leader_response&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.4.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_mock_request_destroy_array&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.4.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_mock_telemetry_set_requested_metrics&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.5.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_mock_telemetry_set_push_interval&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.5.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_consumer_group_type_name&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.6.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_consumer_group_type_code&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.6.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_event_ElectLeaders_result&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.6.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_topic_partition_result_partition&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.6.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_topic_partition_result_error&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.6.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_AdminOptions_set_match_consumer_group_types&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.6.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_ConsumerGroupListing_type&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.6.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_ElectLeaders_new&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.6.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_ElectLeaders_destroy&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.6.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_ElectLeaders&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.6.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_ElectLeaders_result_partitions&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.6.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_mock_group_initial_rebalance_delay_ms&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.6.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_consumer_group_metadata_group_id&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_consumer_group_metadata_group_instance_id&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_consumer_group_metadata_generation_id&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_mock_cgrp_consumer_target_assignment_new&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_mock_cgrp_consumer_target_assignment_destroy&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_mock_cgrp_consumer_target_assignment&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_mock_set_group_consumer_session_timeout_ms&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_mock_set_group_consumer_heartbeat_interval_ms&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.8.0&#39;</span><span class="p">]]</span>
</code></pre></div>
<h3 id="rd_kafka_version">RD_KAFKA_VERSION<a class="headerlink" href="#rd_kafka_version" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_VERSION</span> <span class="o">=</span> <span class="mi">16777471</span>
</code></pre></div>
<p>librdkafka version </p>
<p>Interpreted as hex <code>MM.mm.rr.xx</code>:</p>
<ul>
<li>MM = Major</li>
<li>mm = minor</li>
<li>rr = revision</li>
<li>xx = pre-release id (0xff is the final release)</li>
</ul>
<p>E.g.: <code>0x000801ff</code> = 0.8.1</p>
<dl class="section remark"><dt>Remarks</dt><dd>This value should only be used during compile time, for runtime checks of version use rd_kafka_version() </dd></dl>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_unsupported_compression_type">RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE<a class="headerlink" href="#rd_kafka_resp_err_unsupported_compression_type" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE</span> <span class="o">=</span> <span class="mi">74</span>
</code></pre></div>
<p>Unsupported compression type </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_end_all">RD_KAFKA_RESP_ERR_END_ALL<a class="headerlink" href="#rd_kafka_resp_err_end_all" title="Permanent link">&para;</a></h3>
<p><div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_END_ALL</span> <span class="o">=</span> <span class="mi">75</span>
</code></pre></div>
enum rd_kafka_resp_err_t</p>
<h3 id="rd_kafka_admin_op__cnt">RD_KAFKA_ADMIN_OP__CNT<a class="headerlink" href="#rd_kafka_admin_op__cnt" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_ADMIN_OP__CNT</span> <span class="o">=</span> <span class="mi">6</span>
</code></pre></div>
<p>Number of ops defined </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe </a></li>
</ul>
</div>
<h3 id="rd_kafka_resource__cnt">RD_KAFKA_RESOURCE__CNT<a class="headerlink" href="#rd_kafka_resource__cnt" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESOURCE__CNT</span> <span class="o">=</span> <span class="mi">5</span>
</code></pre></div>
<p>Number of resource types defined </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#acca83a66d7783ff7683ed2691cc907c9"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#acca83a66d7783ff7683ed2691cc907c9 </a></li>
</ul>
</div>
<h3 id="rd_kafka_cdef">RD_KAFKA_CDEF<a class="headerlink" href="#rd_kafka_cdef" title="Permanent link">&para;</a></h3>
<p><div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_CDEF</span> <span class="o">=</span> <span class="s1">&#39;typedef long int ssize_t;</span>
<span class="s1">typedef struct _IO_FILE FILE;</span>
<span class="s1">typedef long int mode_t;</span>
<span class="s1">typedef signed int int16_t;</span>
<span class="s1">typedef unsigned int uint16_t;</span>
<span class="s1">typedef signed int int32_t;</span>
<span class="s1">typedef signed long int int64_t;</span>
<span class="s1">int rd_kafka_version(void);</span>
<span class="s1">const char *rd_kafka_version_str(void);</span>
<span class="s1">typedef enum rd_kafka_type_t {</span>
<span class="s1">  RD_KAFKA_PRODUCER,</span>
<span class="s1">  RD_KAFKA_CONSUMER,</span>
<span class="s1">} rd_kafka_type_t;</span>
<span class="s1">typedef enum rd_kafka_timestamp_type_t {</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_NOT_AVAILABLE,</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_CREATE_TIME,</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_LOG_APPEND_TIME,</span>
<span class="s1">} rd_kafka_timestamp_type_t;</span>
<span class="s1">const char *rd_kafka_get_debug_contexts(void);</span>
<span class="s1">typedef struct rd_kafka_s rd_kafka_t;</span>
<span class="s1">typedef struct rd_kafka_topic_s rd_kafka_topic_t;</span>
<span class="s1">typedef struct rd_kafka_conf_s rd_kafka_conf_t;</span>
<span class="s1">typedef struct rd_kafka_topic_conf_s rd_kafka_topic_conf_t;</span>
<span class="s1">typedef struct rd_kafka_queue_s rd_kafka_queue_t;</span>
<span class="s1">typedef struct rd_kafka_op_s rd_kafka_event_t;</span>
<span class="s1">typedef struct rd_kafka_topic_result_s rd_kafka_topic_result_t;</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BEGIN = (- 200),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BAD_MSG = (- 199),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BAD_COMPRESSION = (- 198),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__DESTROY = (- 197),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FAIL = (- 196),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TRANSPORT = (- 195),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__CRIT_SYS_RESOURCE = (- 194),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__RESOLVE = (- 193),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__MSG_TIMED_OUT = (- 192),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PARTITION_EOF = (- 191),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION = (- 190),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FS = (- 189),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC = (- 188),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ALL_BROKERS_DOWN = (- 187),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INVALID_ARG = (- 186),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TIMED_OUT = (- 185),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__QUEUE_FULL = (- 184),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ISR_INSUFF = (- 183),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NODE_UPDATE = (- 182),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__SSL = (- 181),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__WAIT_COORD = (- 180),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_GROUP = (- 179),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__IN_PROGRESS = (- 178),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PREV_IN_PROGRESS = (- 177),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__EXISTING_SUBSCRIPTION = (- 176),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS = (- 175),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS = (- 174),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__CONFLICT = (- 173),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__STATE = (- 172),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_PROTOCOL = (- 171),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED = (- 170),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__AUTHENTICATION = (- 169),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NO_OFFSET = (- 168),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__OUTDATED = (- 167),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TIMED_OUT_QUEUE = (- 166),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNSUPPORTED_FEATURE = (- 165),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__WAIT_CACHE = (- 164),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INTR = (- 163),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__KEY_SERIALIZATION = (- 162),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__VALUE_SERIALIZATION = (- 161),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__KEY_DESERIALIZATION = (- 160),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__VALUE_DESERIALIZATION = (- 159),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PARTIAL = (- 158),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__READ_ONLY = (- 157),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOENT = (- 156),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNDERFLOW = (- 155),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INVALID_TYPE = (- 154),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__RETRY = (- 153),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PURGE_QUEUE = (- 152),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PURGE_INFLIGHT = (- 151),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FATAL = (- 150),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INCONSISTENT = (- 149),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__GAPLESS_GUARANTEE = (- 148),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__MAX_POLL_EXCEEDED = (- 147),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__END = (- 100),</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN = (- 1),</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NO_ERROR = 0,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_OUT_OF_RANGE = 1,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_MSG = 2,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART = 3,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_MSG_SIZE = 4,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE = 5,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_LEADER_FOR_PARTITION = 6,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REQUEST_TIMED_OUT = 7,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_BROKER_NOT_AVAILABLE = 8,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REPLICA_NOT_AVAILABLE = 9,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE = 10,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_STALE_CTRL_EPOCH = 11,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_METADATA_TOO_LARGE = 12,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NETWORK_EXCEPTION = 13,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_LOAD_IN_PROGRESS = 14,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_COORDINATOR_NOT_AVAILABLE = 15,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_COORDINATOR_FOR_GROUP = 16,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_EXCEPTION = 17,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_RECORD_LIST_TOO_LARGE = 18,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS = 19,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS_AFTER_APPEND = 20,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REQUIRED_ACKS = 21,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ILLEGAL_GENERATION = 22,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INCONSISTENT_GROUP_PROTOCOL = 23,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_GROUP_ID = 24,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_MEMBER_ID = 25,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_SESSION_TIMEOUT = 26,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REBALANCE_IN_PROGRESS = 27,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_COMMIT_OFFSET_SIZE = 28,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_AUTHORIZATION_FAILED = 29,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_AUTHORIZATION_FAILED = 30,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_CLUSTER_AUTHORIZATION_FAILED = 31,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TIMESTAMP = 32,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_SASL_MECHANISM = 33,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ILLEGAL_SASL_STATE = 34,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_VERSION = 35,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_ALREADY_EXISTS = 36,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PARTITIONS = 37,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REPLICATION_FACTOR = 38,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REPLICA_ASSIGNMENT = 39,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_CONFIG = 40,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_CONTROLLER = 41,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REQUEST = 42,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_FOR_MESSAGE_FORMAT = 43,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_POLICY_VIOLATION = 44,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OUT_OF_ORDER_SEQUENCE_NUMBER = 45,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DUPLICATE_SEQUENCE_NUMBER = 46,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_EPOCH = 47,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TXN_STATE = 48,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_ID_MAPPING = 49,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TRANSACTION_TIMEOUT = 50,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_CONCURRENT_TRANSACTIONS = 51,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TRANSACTION_COORDINATOR_FENCED = 52,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TRANSACTIONAL_ID_AUTHORIZATION_FAILED = 53,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_SECURITY_DISABLED = 54,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OPERATION_NOT_ATTEMPTED = 55,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_KAFKA_STORAGE_ERROR = 56,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LOG_DIR_NOT_FOUND = 57,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_SASL_AUTHENTICATION_FAILED = 58,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_PRODUCER_ID = 59,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REASSIGNMENT_IN_PROGRESS = 60,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTH_DISABLED = 61,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_NOT_FOUND = 62,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_OWNER_MISMATCH = 63,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_REQUEST_NOT_ALLOWED = 64,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTHORIZATION_FAILED = 65,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_EXPIRED = 66,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRINCIPAL_TYPE = 67,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NON_EMPTY_GROUP = 68,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_ID_NOT_FOUND = 69,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FETCH_SESSION_ID_NOT_FOUND = 70,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_FETCH_SESSION_EPOCH = 71,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LISTENER_NOT_FOUND = 72,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_DELETION_DISABLED = 73,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 74,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_END_ALL,</span>
<span class="s1">} rd_kafka_resp_err_t;</span>
<span class="s1">struct rd_kafka_err_desc {</span>
<span class="s1">  rd_kafka_resp_err_t code;</span>
<span class="s1">  char *name;</span>
<span class="s1">  char *desc;</span>
<span class="s1">};</span>
<span class="s1">void rd_kafka_get_err_descs(const struct rd_kafka_err_desc **errdescs, size_t *cntp);</span>
<span class="s1">const char *rd_kafka_err2str(rd_kafka_resp_err_t err);</span>
<span class="s1">const char *rd_kafka_err2name(rd_kafka_resp_err_t err);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_last_error(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_errno2err(int errnox);</span>
<span class="s1">int rd_kafka_errno(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_fatal_error(rd_kafka_t *rk, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_test_fatal_error(rd_kafka_t *rk, rd_kafka_resp_err_t err, const char *reason);</span>
<span class="s1">typedef struct rd_kafka_topic_partition_s {</span>
<span class="s1">  char *topic;</span>
<span class="s1">  int32_t partition;</span>
<span class="s1">  int64_t offset;</span>
<span class="s1">  void *metadata;</span>
<span class="s1">  size_t metadata_size;</span>
<span class="s1">  void *opaque;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  void *_private;</span>
<span class="s1">} rd_kafka_topic_partition_t;</span>
<span class="s1">void rd_kafka_topic_partition_destroy(rd_kafka_topic_partition_t *rktpar);</span>
<span class="s1">typedef struct rd_kafka_topic_partition_list_s {</span>
<span class="s1">  int cnt;</span>
<span class="s1">  int size;</span>
<span class="s1">  rd_kafka_topic_partition_t *elems;</span>
<span class="s1">} rd_kafka_topic_partition_list_t;</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_new(int size);</span>
<span class="s1">void rd_kafka_topic_partition_list_destroy(rd_kafka_topic_partition_list_t *rkparlist);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_add(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">void rd_kafka_topic_partition_list_add_range(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t start, int32_t stop);</span>
<span class="s1">int rd_kafka_topic_partition_list_del(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">int rd_kafka_topic_partition_list_del_by_idx(rd_kafka_topic_partition_list_t *rktparlist, int idx);</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_copy(const rd_kafka_topic_partition_list_t *src);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_topic_partition_list_set_offset(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition, int64_t offset);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_find(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">void rd_kafka_topic_partition_list_sort(rd_kafka_topic_partition_list_t *rktparlist, int (*cmp)(const void *a, const void *b, void *opaque), void *opaque);</span>
<span class="s1">typedef enum rd_kafka_vtype_t {</span>
<span class="s1">  RD_KAFKA_VTYPE_END,</span>
<span class="s1">  RD_KAFKA_VTYPE_TOPIC,</span>
<span class="s1">  RD_KAFKA_VTYPE_RKT,</span>
<span class="s1">  RD_KAFKA_VTYPE_PARTITION,</span>
<span class="s1">  RD_KAFKA_VTYPE_VALUE,</span>
<span class="s1">  RD_KAFKA_VTYPE_KEY,</span>
<span class="s1">  RD_KAFKA_VTYPE_OPAQUE,</span>
<span class="s1">  RD_KAFKA_VTYPE_MSGFLAGS,</span>
<span class="s1">  RD_KAFKA_VTYPE_TIMESTAMP,</span>
<span class="s1">  RD_KAFKA_VTYPE_HEADER,</span>
<span class="s1">  RD_KAFKA_VTYPE_HEADERS,</span>
<span class="s1">} rd_kafka_vtype_t;</span>
<span class="s1">typedef struct rd_kafka_headers_s rd_kafka_headers_t;</span>
<span class="s1">rd_kafka_headers_t *rd_kafka_headers_new(size_t initial_count);</span>
<span class="s1">void rd_kafka_headers_destroy(rd_kafka_headers_t *hdrs);</span>
<span class="s1">rd_kafka_headers_t *rd_kafka_headers_copy(const rd_kafka_headers_t *src);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_add(rd_kafka_headers_t *hdrs, const char *name, ssize_t name_size, const void *value, ssize_t value_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_remove(rd_kafka_headers_t *hdrs, const char *name);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get_last(const rd_kafka_headers_t *hdrs, const char *name, const void **valuep, size_t *sizep);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get(const rd_kafka_headers_t *hdrs, size_t idx, const char *name, const void **valuep, size_t *sizep);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get_all(const rd_kafka_headers_t *hdrs, size_t idx, const char **namep, const void **valuep, size_t *sizep);</span>
<span class="s1">typedef struct rd_kafka_message_s {</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  rd_kafka_topic_t *rkt;</span>
<span class="s1">  int32_t partition;</span>
<span class="s1">  void *payload;</span>
<span class="s1">  size_t len;</span>
<span class="s1">  void *key;</span>
<span class="s1">  size_t key_len;</span>
<span class="s1">  int64_t offset;</span>
<span class="s1">  void *_private;</span>
<span class="s1">} rd_kafka_message_t;</span>
<span class="s1">void rd_kafka_message_destroy(rd_kafka_message_t *rkmessage);</span>
<span class="s1">int64_t rd_kafka_message_timestamp(const rd_kafka_message_t *rkmessage, rd_kafka_timestamp_type_t *tstype);</span>
<span class="s1">int64_t rd_kafka_message_latency(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_message_headers(const rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_message_detach_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);</span>
<span class="s1">void rd_kafka_message_set_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t *hdrs);</span>
<span class="s1">size_t rd_kafka_header_cnt(const rd_kafka_headers_t *hdrs);</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_NOT_PERSISTED = 0,</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_POSSIBLY_PERSISTED = 1,</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_PERSISTED = 2,</span>
<span class="s1">} rd_kafka_msg_status_t;</span>
<span class="s1">rd_kafka_msg_status_t rd_kafka_message_status(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_CONF_UNKNOWN = (- 2),</span>
<span class="s1">  RD_KAFKA_CONF_INVALID = (- 1),</span>
<span class="s1">  RD_KAFKA_CONF_OK = 0,</span>
<span class="s1">} rd_kafka_conf_res_t;</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_new(void);</span>
<span class="s1">void rd_kafka_conf_destroy(rd_kafka_conf_t *conf);</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_dup(const rd_kafka_conf_t *conf);</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_dup_filter(const rd_kafka_conf_t *conf, size_t filter_cnt, const char **filter);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_set(rd_kafka_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_conf_set_events(rd_kafka_conf_t *conf, int events);</span>
<span class="s1">void rd_kafka_conf_set_background_event_cb(rd_kafka_conf_t *conf, void (*event_cb)(rd_kafka_t *rk, rd_kafka_event_t *rkev, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_dr_cb(rd_kafka_conf_t *conf, void (*dr_cb)(rd_kafka_t *rk, void *payload, size_t len, rd_kafka_resp_err_t err, void *opaque, void *msg_opaque));</span>
<span class="s1">void rd_kafka_conf_set_dr_msg_cb(rd_kafka_conf_t *conf, void (*dr_msg_cb)(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_consume_cb(rd_kafka_conf_t *conf, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_rebalance_cb(rd_kafka_conf_t *conf, void (*rebalance_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *partitions, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_offset_commit_cb(rd_kafka_conf_t *conf, void (*offset_commit_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_error_cb(rd_kafka_conf_t *conf, void (*error_cb)(rd_kafka_t *rk, int err, const char *reason, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_throttle_cb(rd_kafka_conf_t *conf, void (*throttle_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int throttle_time_ms, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_log_cb(rd_kafka_conf_t *conf, void (*log_cb)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));</span>
<span class="s1">void rd_kafka_conf_set_stats_cb(rd_kafka_conf_t *conf, int (*stats_cb)(rd_kafka_t *rk, char *json, size_t json_len, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_socket_cb(rd_kafka_conf_t *conf, int (*socket_cb)(int domain, int type, int protocol, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_connect_cb(rd_kafka_conf_t *conf, int (*connect_cb)(int sockfd, const struct sockaddr *addr, int addrlen, const char *id, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_closesocket_cb(rd_kafka_conf_t *conf, int (*closesocket_cb)(int sockfd, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_opaque(rd_kafka_conf_t *conf, void *opaque);</span>
<span class="s1">void *rd_kafka_opaque(const rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_conf_set_default_topic_conf(rd_kafka_conf_t *conf, rd_kafka_topic_conf_t *tconf);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_get(const rd_kafka_conf_t *conf, const char *name, char *dest, size_t *dest_size);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_topic_conf_get(const rd_kafka_topic_conf_t *conf, const char *name, char *dest, size_t *dest_size);</span>
<span class="s1">const char **rd_kafka_conf_dump(rd_kafka_conf_t *conf, size_t *cntp);</span>
<span class="s1">const char **rd_kafka_topic_conf_dump(rd_kafka_topic_conf_t *conf, size_t *cntp);</span>
<span class="s1">void rd_kafka_conf_dump_free(const char **arr, size_t cnt);</span>
<span class="s1">void rd_kafka_conf_properties_show(FILE *fp);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_topic_conf_new(void);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_topic_conf_dup(const rd_kafka_topic_conf_t *conf);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_default_topic_conf_dup(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_topic_conf_destroy(rd_kafka_topic_conf_t *topic_conf);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_topic_conf_set(rd_kafka_topic_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_topic_conf_set_opaque(rd_kafka_topic_conf_t *conf, void *opaque);</span>
<span class="s1">void rd_kafka_topic_conf_set_partitioner_cb(rd_kafka_topic_conf_t *topic_conf, int32_t (*partitioner)(const rd_kafka_topic_t *rkt, const void *keydata, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque));</span>
<span class="s1">void rd_kafka_topic_conf_set_msg_order_cmp(rd_kafka_topic_conf_t *topic_conf, int (*msg_order_cmp)(const rd_kafka_message_t *a, const rd_kafka_message_t *b));</span>
<span class="s1">int rd_kafka_topic_partition_available(const rd_kafka_topic_t *rkt, int32_t partition);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_consistent(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_consistent_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_murmur2(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_murmur2_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">rd_kafka_t *rd_kafka_new(rd_kafka_type_t type, rd_kafka_conf_t *conf, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_destroy(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_destroy_flags(rd_kafka_t *rk, int flags);</span>
<span class="s1">const char *rd_kafka_name(const rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_type_t rd_kafka_type(const rd_kafka_t *rk);</span>
<span class="s1">char *rd_kafka_memberid(const rd_kafka_t *rk);</span>
<span class="s1">char *rd_kafka_clusterid(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">int32_t rd_kafka_controllerid(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_topic_t *rd_kafka_topic_new(rd_kafka_t *rk, const char *topic, rd_kafka_topic_conf_t *conf);</span>
<span class="s1">void rd_kafka_topic_destroy(rd_kafka_topic_t *rkt);</span>
<span class="s1">const char *rd_kafka_topic_name(const rd_kafka_topic_t *rkt);</span>
<span class="s1">void *rd_kafka_topic_opaque(const rd_kafka_topic_t *rkt);</span>
<span class="s1">int rd_kafka_poll(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">void rd_kafka_yield(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_pause_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_resume_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_query_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_get_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offsets_for_times(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets, int timeout_ms);</span>
<span class="s1">void rd_kafka_mem_free(rd_kafka_t *rk, void *ptr);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_new(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_queue_destroy(rd_kafka_queue_t *rkqu);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_main(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_consumer(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_partition(rd_kafka_t *rk, const char *topic, int32_t partition);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_background(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_queue_forward(rd_kafka_queue_t *src, rd_kafka_queue_t *dst);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_set_log_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu);</span>
<span class="s1">size_t rd_kafka_queue_length(rd_kafka_queue_t *rkqu);</span>
<span class="s1">void rd_kafka_queue_io_event_enable(rd_kafka_queue_t *rkqu, int fd, const void *payload, size_t size);</span>
<span class="s1">void rd_kafka_queue_cb_event_enable(rd_kafka_queue_t *rkqu, void (*event_cb)(rd_kafka_t *rk, void *opaque), void *opaque);</span>
<span class="s1">int rd_kafka_consume_start(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);</span>
<span class="s1">int rd_kafka_consume_start_queue(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, rd_kafka_queue_t *rkqu);</span>
<span class="s1">int rd_kafka_consume_stop(rd_kafka_topic_t *rkt, int32_t partition);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_seek(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, int timeout_ms);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consume(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms);</span>
<span class="s1">ssize_t rd_kafka_consume_batch(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);</span>
<span class="s1">int rd_kafka_consume_callback(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *opaque), void *opaque);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consume_queue(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">ssize_t rd_kafka_consume_batch_queue(rd_kafka_queue_t *rkqu, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);</span>
<span class="s1">int rd_kafka_consume_callback_queue(rd_kafka_queue_t *rkqu, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *opaque), void *opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offset_store(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offsets_store(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_subscribe(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *topics);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_unsubscribe(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_subscription(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **topics);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consumer_poll(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_consumer_close(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_assignment(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, int async);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit_message(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, int async);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit_queue(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_queue_t *rkqu, void (*cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *opaque), void *opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_committed(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_position(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">int rd_kafka_produce(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, void *payload, size_t len, const void *key, size_t keylen, void *msg_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_producev(rd_kafka_t *rk, ...);</span>
<span class="s1">int rd_kafka_produce_batch(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, rd_kafka_message_t *rkmessages, int message_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_flush(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_purge(rd_kafka_t *rk, int purge_flags);</span>
<span class="s1">typedef struct rd_kafka_metadata_broker {</span>
<span class="s1">  int32_t id;</span>
<span class="s1">  char *host;</span>
<span class="s1">  int port;</span>
<span class="s1">} rd_kafka_metadata_broker_t;</span>
<span class="s1">typedef struct rd_kafka_metadata_partition {</span>
<span class="s1">  int32_t id;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  int32_t leader;</span>
<span class="s1">  int replica_cnt;</span>
<span class="s1">  int32_t *replicas;</span>
<span class="s1">  int isr_cnt;</span>
<span class="s1">  int32_t *isrs;</span>
<span class="s1">} rd_kafka_metadata_partition_t;</span>
<span class="s1">typedef struct rd_kafka_metadata_topic {</span>
<span class="s1">  char *topic;</span>
<span class="s1">  int partition_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_partition *partitions;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">} rd_kafka_metadata_topic_t;</span>
<span class="s1">typedef struct rd_kafka_metadata {</span>
<span class="s1">  int broker_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_broker *brokers;</span>
<span class="s1">  int topic_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_topic *topics;</span>
<span class="s1">  int32_t orig_broker_id;</span>
<span class="s1">  char *orig_broker_name;</span>
<span class="s1">} rd_kafka_metadata_t;</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_metadata(rd_kafka_t *rk, int all_topics, rd_kafka_topic_t *only_rkt, const struct rd_kafka_metadata **metadatap, int timeout_ms);</span>
<span class="s1">void rd_kafka_metadata_destroy(const struct rd_kafka_metadata *metadata);</span>
<span class="s1">struct rd_kafka_group_member_info {</span>
<span class="s1">  char *member_id;</span>
<span class="s1">  char *client_id;</span>
<span class="s1">  char *client_host;</span>
<span class="s1">  void *member_metadata;</span>
<span class="s1">  int member_metadata_size;</span>
<span class="s1">  void *member_assignment;</span>
<span class="s1">  int member_assignment_size;</span>
<span class="s1">};</span>
<span class="s1">struct rd_kafka_group_info {</span>
<span class="s1">  struct rd_kafka_metadata_broker broker;</span>
<span class="s1">  char *group;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  char *state;</span>
<span class="s1">  char *protocol_type;</span>
<span class="s1">  char *protocol;</span>
<span class="s1">  struct rd_kafka_group_member_info *members;</span>
<span class="s1">  int member_cnt;</span>
<span class="s1">};</span>
<span class="s1">struct rd_kafka_group_list {</span>
<span class="s1">  struct rd_kafka_group_info *groups;</span>
<span class="s1">  int group_cnt;</span>
<span class="s1">};</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_list_groups(rd_kafka_t *rk, const char *group, const struct rd_kafka_group_list **grplistp, int timeout_ms);</span>
<span class="s1">void rd_kafka_group_list_destroy(const struct rd_kafka_group_list *grplist);</span>
<span class="s1">int rd_kafka_brokers_add(rd_kafka_t *rk, const char *brokerlist);</span>
<span class="s1">void rd_kafka_set_logger(rd_kafka_t *rk, void (*func)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));</span>
<span class="s1">void rd_kafka_set_log_level(rd_kafka_t *rk, int level);</span>
<span class="s1">void rd_kafka_log_print(const rd_kafka_t *rk, int level, const char *fac, const char *buf);</span>
<span class="s1">void rd_kafka_log_syslog(const rd_kafka_t *rk, int level, const char *fac, const char *buf);</span>
<span class="s1">int rd_kafka_outq_len(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_dump(FILE *fp, rd_kafka_t *rk);</span>
<span class="s1">int rd_kafka_thread_cnt(void);</span>
<span class="s1">int rd_kafka_wait_destroyed(int timeout_ms);</span>
<span class="s1">int rd_kafka_unittest(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_poll_set_consumer(rd_kafka_t *rk);</span>
<span class="s1">typedef int rd_kafka_event_type_t;</span>
<span class="s1">rd_kafka_event_type_t rd_kafka_event_type(const rd_kafka_event_t *rkev);</span>
<span class="s1">const char *rd_kafka_event_name(const rd_kafka_event_t *rkev);</span>
<span class="s1">void rd_kafka_event_destroy(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_message_t *rd_kafka_event_message_next(rd_kafka_event_t *rkev);</span>
<span class="s1">size_t rd_kafka_event_message_array(rd_kafka_event_t *rkev, const rd_kafka_message_t **rkmessages, size_t size);</span>
<span class="s1">size_t rd_kafka_event_message_count(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_event_error(rd_kafka_event_t *rkev);</span>
<span class="s1">const char *rd_kafka_event_error_string(rd_kafka_event_t *rkev);</span>
<span class="s1">int rd_kafka_event_error_is_fatal(rd_kafka_event_t *rkev);</span>
<span class="s1">void *rd_kafka_event_opaque(rd_kafka_event_t *rkev);</span>
<span class="s1">int rd_kafka_event_log(rd_kafka_event_t *rkev, const char **fac, const char **str, int *level);</span>
<span class="s1">const char *rd_kafka_event_stats(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_event_topic_partition_list(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_event_topic_partition(rd_kafka_event_t *rkev);</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_CreateTopics_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DeleteTopics_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_CreatePartitions_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_AlterConfigs_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DescribeConfigs_result_t;</span>
<span class="s1">const rd_kafka_CreateTopics_result_t *rd_kafka_event_CreateTopics_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DeleteTopics_result_t *rd_kafka_event_DeleteTopics_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_CreatePartitions_result_t *rd_kafka_event_CreatePartitions_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_AlterConfigs_result_t *rd_kafka_event_AlterConfigs_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DescribeConfigs_result_t *rd_kafka_event_DescribeConfigs_result(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_event_t *rd_kafka_queue_poll(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">int rd_kafka_queue_poll_callback(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_plugin_f_conf_init_t)(rd_kafka_conf_t *conf, void **plug_opaquep, char *errstr, size_t errstr_size);</span>
<span class="s1">typedef rd_kafka_conf_res_t (rd_kafka_interceptor_f_on_conf_set_t)(rd_kafka_conf_t *conf, const char *name, const char *val, char *errstr, size_t errstr_size, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_dup_t)(rd_kafka_conf_t *new_conf, const rd_kafka_conf_t *old_conf, size_t filter_cnt, const char **filter, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_destroy_t)(void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_new_t)(rd_kafka_t *rk, const rd_kafka_conf_t *conf, void *ic_opaque, char *errstr, size_t errstr_size);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_destroy_t)(rd_kafka_t *rk, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_send_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_acknowledgement_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_consume_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_commit_t)(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_resp_err_t err, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_request_sent_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_set(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_set_t *on_conf_set, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_dup(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_dup_t *on_conf_dup, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_destroy(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_destroy_t *on_conf_destroy, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_new(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_new_t *on_new, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_destroy(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_destroy_t *on_destroy, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_send(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_send_t *on_send, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_acknowledgement(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_acknowledgement_t *on_acknowledgement, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_consume(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_consume_t *on_consume, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_commit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_commit_t *on_commit, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_request_sent(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_request_sent_t *on_request_sent, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_topic_result_error(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">const char *rd_kafka_topic_result_error_string(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">const char *rd_kafka_topic_result_name(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">typedef enum rd_kafka_admin_op_t {</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_ANY = 0,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_CREATETOPICS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DELETETOPICS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_CREATEPARTITIONS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_ALTERCONFIGS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DESCRIBECONFIGS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP__CNT,</span>
<span class="s1">} rd_kafka_admin_op_t;</span>
<span class="s1">typedef struct rd_kafka_AdminOptions_s rd_kafka_AdminOptions_t;</span>
<span class="s1">rd_kafka_AdminOptions_t *rd_kafka_AdminOptions_new(rd_kafka_t *rk, rd_kafka_admin_op_t for_api);</span>
<span class="s1">void rd_kafka_AdminOptions_destroy(rd_kafka_AdminOptions_t *options);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_request_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_operation_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_validate_only(rd_kafka_AdminOptions_t *options, int true_or_false, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_broker(rd_kafka_AdminOptions_t *options, int32_t broker_id, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_AdminOptions_set_opaque(rd_kafka_AdminOptions_t *options, void *opaque);</span>
<span class="s1">typedef struct rd_kafka_NewTopic_s rd_kafka_NewTopic_t;</span>
<span class="s1">rd_kafka_NewTopic_t *rd_kafka_NewTopic_new(const char *topic, int num_partitions, int replication_factor, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_NewTopic_destroy(rd_kafka_NewTopic_t *new_topic);</span>
<span class="s1">void rd_kafka_NewTopic_destroy_array(rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewTopic_set_replica_assignment(rd_kafka_NewTopic_t *new_topic, int32_t partition, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewTopic_set_config(rd_kafka_NewTopic_t *new_topic, const char *name, const char *value);</span>
<span class="s1">void rd_kafka_CreateTopics(rd_kafka_t *rk, rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_CreateTopics_result_topics(const rd_kafka_CreateTopics_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_DeleteTopic_s rd_kafka_DeleteTopic_t;</span>
<span class="s1">rd_kafka_DeleteTopic_t *rd_kafka_DeleteTopic_new(const char *topic);</span>
<span class="s1">void rd_kafka_DeleteTopic_destroy(rd_kafka_DeleteTopic_t *del_topic);</span>
<span class="s1">void rd_kafka_DeleteTopic_destroy_array(rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt);</span>
<span class="s1">void rd_kafka_DeleteTopics(rd_kafka_t *rk, rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_DeleteTopics_result_topics(const rd_kafka_DeleteTopics_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_NewPartitions_s rd_kafka_NewPartitions_t;</span>
<span class="s1">rd_kafka_NewPartitions_t *rd_kafka_NewPartitions_new(const char *topic, size_t new_total_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_NewPartitions_destroy(rd_kafka_NewPartitions_t *new_parts);</span>
<span class="s1">void rd_kafka_NewPartitions_destroy_array(rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewPartitions_set_replica_assignment(rd_kafka_NewPartitions_t *new_parts, int32_t new_partition_idx, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_CreatePartitions(rd_kafka_t *rk, rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_CreatePartitions_result_topics(const rd_kafka_CreatePartitions_result_t *result, size_t *cntp);</span>
<span class="s1">typedef enum rd_kafka_ConfigSource_t {</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_UNKNOWN_CONFIG = 0,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_TOPIC_CONFIG = 1,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_BROKER_CONFIG = 2,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_DEFAULT_BROKER_CONFIG = 3,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_STATIC_BROKER_CONFIG = 4,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DEFAULT_CONFIG = 5,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE__CNT,</span>
<span class="s1">} rd_kafka_ConfigSource_t;</span>
<span class="s1">const char *rd_kafka_ConfigSource_name(rd_kafka_ConfigSource_t confsource);</span>
<span class="s1">typedef struct rd_kafka_ConfigEntry_s rd_kafka_ConfigEntry_t;</span>
<span class="s1">const char *rd_kafka_ConfigEntry_name(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">const char *rd_kafka_ConfigEntry_value(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">rd_kafka_ConfigSource_t rd_kafka_ConfigEntry_source(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_read_only(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_default(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_sensitive(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_synonym(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">const rd_kafka_ConfigEntry_t **rd_kafka_ConfigEntry_synonyms(const rd_kafka_ConfigEntry_t *entry, size_t *cntp);</span>
<span class="s1">typedef enum rd_kafka_ResourceType_t {</span>
<span class="s1">  RD_KAFKA_RESOURCE_UNKNOWN = 0,</span>
<span class="s1">  RD_KAFKA_RESOURCE_ANY = 1,</span>
<span class="s1">  RD_KAFKA_RESOURCE_TOPIC = 2,</span>
<span class="s1">  RD_KAFKA_RESOURCE_GROUP = 3,</span>
<span class="s1">  RD_KAFKA_RESOURCE_BROKER = 4,</span>
<span class="s1">  RD_KAFKA_RESOURCE__CNT,</span>
<span class="s1">} rd_kafka_ResourceType_t;</span>
<span class="s1">const char *rd_kafka_ResourceType_name(rd_kafka_ResourceType_t restype);</span>
<span class="s1">typedef struct rd_kafka_ConfigResource_s rd_kafka_ConfigResource_t;</span>
<span class="s1">rd_kafka_ConfigResource_t *rd_kafka_ConfigResource_new(rd_kafka_ResourceType_t restype, const char *resname);</span>
<span class="s1">void rd_kafka_ConfigResource_destroy(rd_kafka_ConfigResource_t *config);</span>
<span class="s1">void rd_kafka_ConfigResource_destroy_array(rd_kafka_ConfigResource_t **config, size_t config_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_ConfigResource_set_config(rd_kafka_ConfigResource_t *config, const char *name, const char *value);</span>
<span class="s1">const rd_kafka_ConfigEntry_t **rd_kafka_ConfigResource_configs(const rd_kafka_ConfigResource_t *config, size_t *cntp);</span>
<span class="s1">rd_kafka_ResourceType_t rd_kafka_ConfigResource_type(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">const char *rd_kafka_ConfigResource_name(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_ConfigResource_error(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">const char *rd_kafka_ConfigResource_error_string(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">void rd_kafka_AlterConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_ConfigResource_t **rd_kafka_AlterConfigs_result_resources(const rd_kafka_AlterConfigs_result_t *result, size_t *cntp);</span>
<span class="s1">void rd_kafka_DescribeConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_ConfigResource_t **rd_kafka_DescribeConfigs_result_resources(const rd_kafka_DescribeConfigs_result_t *result, size_t *cntp);</span>
<span class="s1">&#39;</span>
</code></pre></div>
rdkafka.h, rdkafka_mock.h</p>
<h3 id="rd_kafka_version_1">RD_KAFKA_VERSION<a class="headerlink" href="#rd_kafka_version_1" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_VERSION</span> <span class="o">=</span> <span class="mi">16777727</span>
</code></pre></div>
<p>librdkafka version </p>
<p>Interpreted as hex <code>MM.mm.rr.xx</code>:</p>
<ul>
<li>MM = Major</li>
<li>mm = minor</li>
<li>rr = revision</li>
<li>xx = pre-release id (0xff is the final release)</li>
</ul>
<p>E.g.: <code>0x000801ff</code> = 0.8.1</p>
<dl class="section remark"><dt>Remarks</dt><dd>This value should only be used during compile time, for runtime checks of version use rd_kafka_version() </dd></dl>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_unsupported_compression_type_1">RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE<a class="headerlink" href="#rd_kafka_resp_err_unsupported_compression_type_1" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE</span> <span class="o">=</span> <span class="mi">76</span>
</code></pre></div>
<p>Unsupported compression type </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_end_all_1">RD_KAFKA_RESP_ERR_END_ALL<a class="headerlink" href="#rd_kafka_resp_err_end_all_1" title="Permanent link">&para;</a></h3>
<p><div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_END_ALL</span> <span class="o">=</span> <span class="mi">82</span>
</code></pre></div>
enum rd_kafka_resp_err_t</p>
<h3 id="rd_kafka_admin_op__cnt_1">RD_KAFKA_ADMIN_OP__CNT<a class="headerlink" href="#rd_kafka_admin_op__cnt_1" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_ADMIN_OP__CNT</span> <span class="o">=</span> <span class="mi">6</span>
</code></pre></div>
<p>Number of ops defined </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe </a></li>
</ul>
</div>
<h3 id="rd_kafka_resource__cnt_1">RD_KAFKA_RESOURCE__CNT<a class="headerlink" href="#rd_kafka_resource__cnt_1" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESOURCE__CNT</span> <span class="o">=</span> <span class="mi">5</span>
</code></pre></div>
<p>Number of resource types defined </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#acca83a66d7783ff7683ed2691cc907c9"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#acca83a66d7783ff7683ed2691cc907c9 </a></li>
</ul>
</div>
<h3 id="rd_kafka_cdef_1">RD_KAFKA_CDEF<a class="headerlink" href="#rd_kafka_cdef_1" title="Permanent link">&para;</a></h3>
<p><div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_CDEF</span> <span class="o">=</span> <span class="s1">&#39;typedef long int ssize_t;</span>
<span class="s1">typedef struct _IO_FILE FILE;</span>
<span class="s1">typedef long int mode_t;</span>
<span class="s1">typedef signed int int16_t;</span>
<span class="s1">typedef unsigned int uint16_t;</span>
<span class="s1">typedef signed int int32_t;</span>
<span class="s1">typedef signed long int int64_t;</span>
<span class="s1">int rd_kafka_version(void);</span>
<span class="s1">const char *rd_kafka_version_str(void);</span>
<span class="s1">typedef enum rd_kafka_type_t {</span>
<span class="s1">  RD_KAFKA_PRODUCER,</span>
<span class="s1">  RD_KAFKA_CONSUMER,</span>
<span class="s1">} rd_kafka_type_t;</span>
<span class="s1">typedef enum rd_kafka_timestamp_type_t {</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_NOT_AVAILABLE,</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_CREATE_TIME,</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_LOG_APPEND_TIME,</span>
<span class="s1">} rd_kafka_timestamp_type_t;</span>
<span class="s1">const char *rd_kafka_get_debug_contexts(void);</span>
<span class="s1">typedef struct rd_kafka_s rd_kafka_t;</span>
<span class="s1">typedef struct rd_kafka_topic_s rd_kafka_topic_t;</span>
<span class="s1">typedef struct rd_kafka_conf_s rd_kafka_conf_t;</span>
<span class="s1">typedef struct rd_kafka_topic_conf_s rd_kafka_topic_conf_t;</span>
<span class="s1">typedef struct rd_kafka_queue_s rd_kafka_queue_t;</span>
<span class="s1">typedef struct rd_kafka_op_s rd_kafka_event_t;</span>
<span class="s1">typedef struct rd_kafka_topic_result_s rd_kafka_topic_result_t;</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BEGIN = (- 200),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BAD_MSG = (- 199),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BAD_COMPRESSION = (- 198),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__DESTROY = (- 197),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FAIL = (- 196),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TRANSPORT = (- 195),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__CRIT_SYS_RESOURCE = (- 194),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__RESOLVE = (- 193),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__MSG_TIMED_OUT = (- 192),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PARTITION_EOF = (- 191),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION = (- 190),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FS = (- 189),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC = (- 188),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ALL_BROKERS_DOWN = (- 187),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INVALID_ARG = (- 186),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TIMED_OUT = (- 185),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__QUEUE_FULL = (- 184),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ISR_INSUFF = (- 183),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NODE_UPDATE = (- 182),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__SSL = (- 181),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__WAIT_COORD = (- 180),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_GROUP = (- 179),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__IN_PROGRESS = (- 178),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PREV_IN_PROGRESS = (- 177),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__EXISTING_SUBSCRIPTION = (- 176),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS = (- 175),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS = (- 174),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__CONFLICT = (- 173),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__STATE = (- 172),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_PROTOCOL = (- 171),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED = (- 170),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__AUTHENTICATION = (- 169),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NO_OFFSET = (- 168),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__OUTDATED = (- 167),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TIMED_OUT_QUEUE = (- 166),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNSUPPORTED_FEATURE = (- 165),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__WAIT_CACHE = (- 164),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INTR = (- 163),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__KEY_SERIALIZATION = (- 162),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__VALUE_SERIALIZATION = (- 161),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__KEY_DESERIALIZATION = (- 160),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__VALUE_DESERIALIZATION = (- 159),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PARTIAL = (- 158),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__READ_ONLY = (- 157),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOENT = (- 156),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNDERFLOW = (- 155),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INVALID_TYPE = (- 154),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__RETRY = (- 153),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PURGE_QUEUE = (- 152),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PURGE_INFLIGHT = (- 151),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FATAL = (- 150),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INCONSISTENT = (- 149),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__GAPLESS_GUARANTEE = (- 148),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__MAX_POLL_EXCEEDED = (- 147),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__END = (- 100),</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN = (- 1),</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NO_ERROR = 0,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_OUT_OF_RANGE = 1,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_MSG = 2,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART = 3,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_MSG_SIZE = 4,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE = 5,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_LEADER_FOR_PARTITION = 6,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REQUEST_TIMED_OUT = 7,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_BROKER_NOT_AVAILABLE = 8,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REPLICA_NOT_AVAILABLE = 9,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE = 10,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_STALE_CTRL_EPOCH = 11,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_METADATA_TOO_LARGE = 12,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NETWORK_EXCEPTION = 13,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_LOAD_IN_PROGRESS = 14,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_COORDINATOR_NOT_AVAILABLE = 15,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_COORDINATOR_FOR_GROUP = 16,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_EXCEPTION = 17,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_RECORD_LIST_TOO_LARGE = 18,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS = 19,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS_AFTER_APPEND = 20,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REQUIRED_ACKS = 21,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ILLEGAL_GENERATION = 22,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INCONSISTENT_GROUP_PROTOCOL = 23,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_GROUP_ID = 24,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_MEMBER_ID = 25,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_SESSION_TIMEOUT = 26,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REBALANCE_IN_PROGRESS = 27,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_COMMIT_OFFSET_SIZE = 28,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_AUTHORIZATION_FAILED = 29,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_AUTHORIZATION_FAILED = 30,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_CLUSTER_AUTHORIZATION_FAILED = 31,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TIMESTAMP = 32,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_SASL_MECHANISM = 33,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ILLEGAL_SASL_STATE = 34,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_VERSION = 35,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_ALREADY_EXISTS = 36,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PARTITIONS = 37,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REPLICATION_FACTOR = 38,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REPLICA_ASSIGNMENT = 39,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_CONFIG = 40,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_CONTROLLER = 41,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REQUEST = 42,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_FOR_MESSAGE_FORMAT = 43,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_POLICY_VIOLATION = 44,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OUT_OF_ORDER_SEQUENCE_NUMBER = 45,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DUPLICATE_SEQUENCE_NUMBER = 46,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_EPOCH = 47,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TXN_STATE = 48,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_ID_MAPPING = 49,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TRANSACTION_TIMEOUT = 50,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_CONCURRENT_TRANSACTIONS = 51,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TRANSACTION_COORDINATOR_FENCED = 52,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TRANSACTIONAL_ID_AUTHORIZATION_FAILED = 53,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_SECURITY_DISABLED = 54,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OPERATION_NOT_ATTEMPTED = 55,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_KAFKA_STORAGE_ERROR = 56,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LOG_DIR_NOT_FOUND = 57,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_SASL_AUTHENTICATION_FAILED = 58,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_PRODUCER_ID = 59,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REASSIGNMENT_IN_PROGRESS = 60,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTH_DISABLED = 61,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_NOT_FOUND = 62,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_OWNER_MISMATCH = 63,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_REQUEST_NOT_ALLOWED = 64,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTHORIZATION_FAILED = 65,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_EXPIRED = 66,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRINCIPAL_TYPE = 67,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NON_EMPTY_GROUP = 68,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_ID_NOT_FOUND = 69,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FETCH_SESSION_ID_NOT_FOUND = 70,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_FETCH_SESSION_EPOCH = 71,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LISTENER_NOT_FOUND = 72,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_DELETION_DISABLED = 73,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FENCED_LEADER_EPOCH = 74,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_LEADER_EPOCH = 75,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_STALE_BROKER_EPOCH = 77,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_NOT_AVAILABLE = 78,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_MEMBER_ID_REQUIRED = 79,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_PREFERRED_LEADER_NOT_AVAILABLE = 80,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_MAX_SIZE_REACHED = 81,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_END_ALL,</span>
<span class="s1">} rd_kafka_resp_err_t;</span>
<span class="s1">struct rd_kafka_err_desc {</span>
<span class="s1">  rd_kafka_resp_err_t code;</span>
<span class="s1">  char *name;</span>
<span class="s1">  char *desc;</span>
<span class="s1">};</span>
<span class="s1">void rd_kafka_get_err_descs(const struct rd_kafka_err_desc **errdescs, size_t *cntp);</span>
<span class="s1">const char *rd_kafka_err2str(rd_kafka_resp_err_t err);</span>
<span class="s1">const char *rd_kafka_err2name(rd_kafka_resp_err_t err);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_last_error(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_errno2err(int errnox);</span>
<span class="s1">int rd_kafka_errno(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_fatal_error(rd_kafka_t *rk, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_test_fatal_error(rd_kafka_t *rk, rd_kafka_resp_err_t err, const char *reason);</span>
<span class="s1">typedef struct rd_kafka_topic_partition_s {</span>
<span class="s1">  char *topic;</span>
<span class="s1">  int32_t partition;</span>
<span class="s1">  int64_t offset;</span>
<span class="s1">  void *metadata;</span>
<span class="s1">  size_t metadata_size;</span>
<span class="s1">  void *opaque;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  void *_private;</span>
<span class="s1">} rd_kafka_topic_partition_t;</span>
<span class="s1">void rd_kafka_topic_partition_destroy(rd_kafka_topic_partition_t *rktpar);</span>
<span class="s1">typedef struct rd_kafka_topic_partition_list_s {</span>
<span class="s1">  int cnt;</span>
<span class="s1">  int size;</span>
<span class="s1">  rd_kafka_topic_partition_t *elems;</span>
<span class="s1">} rd_kafka_topic_partition_list_t;</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_new(int size);</span>
<span class="s1">void rd_kafka_topic_partition_list_destroy(rd_kafka_topic_partition_list_t *rkparlist);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_add(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">void rd_kafka_topic_partition_list_add_range(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t start, int32_t stop);</span>
<span class="s1">int rd_kafka_topic_partition_list_del(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">int rd_kafka_topic_partition_list_del_by_idx(rd_kafka_topic_partition_list_t *rktparlist, int idx);</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_copy(const rd_kafka_topic_partition_list_t *src);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_topic_partition_list_set_offset(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition, int64_t offset);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_find(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">void rd_kafka_topic_partition_list_sort(rd_kafka_topic_partition_list_t *rktparlist, int (*cmp)(const void *a, const void *b, void *opaque), void *opaque);</span>
<span class="s1">typedef enum rd_kafka_vtype_t {</span>
<span class="s1">  RD_KAFKA_VTYPE_END,</span>
<span class="s1">  RD_KAFKA_VTYPE_TOPIC,</span>
<span class="s1">  RD_KAFKA_VTYPE_RKT,</span>
<span class="s1">  RD_KAFKA_VTYPE_PARTITION,</span>
<span class="s1">  RD_KAFKA_VTYPE_VALUE,</span>
<span class="s1">  RD_KAFKA_VTYPE_KEY,</span>
<span class="s1">  RD_KAFKA_VTYPE_OPAQUE,</span>
<span class="s1">  RD_KAFKA_VTYPE_MSGFLAGS,</span>
<span class="s1">  RD_KAFKA_VTYPE_TIMESTAMP,</span>
<span class="s1">  RD_KAFKA_VTYPE_HEADER,</span>
<span class="s1">  RD_KAFKA_VTYPE_HEADERS,</span>
<span class="s1">} rd_kafka_vtype_t;</span>
<span class="s1">typedef struct rd_kafka_headers_s rd_kafka_headers_t;</span>
<span class="s1">rd_kafka_headers_t *rd_kafka_headers_new(size_t initial_count);</span>
<span class="s1">void rd_kafka_headers_destroy(rd_kafka_headers_t *hdrs);</span>
<span class="s1">rd_kafka_headers_t *rd_kafka_headers_copy(const rd_kafka_headers_t *src);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_add(rd_kafka_headers_t *hdrs, const char *name, ssize_t name_size, const void *value, ssize_t value_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_remove(rd_kafka_headers_t *hdrs, const char *name);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get_last(const rd_kafka_headers_t *hdrs, const char *name, const void **valuep, size_t *sizep);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get(const rd_kafka_headers_t *hdrs, size_t idx, const char *name, const void **valuep, size_t *sizep);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get_all(const rd_kafka_headers_t *hdrs, size_t idx, const char **namep, const void **valuep, size_t *sizep);</span>
<span class="s1">typedef struct rd_kafka_message_s {</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  rd_kafka_topic_t *rkt;</span>
<span class="s1">  int32_t partition;</span>
<span class="s1">  void *payload;</span>
<span class="s1">  size_t len;</span>
<span class="s1">  void *key;</span>
<span class="s1">  size_t key_len;</span>
<span class="s1">  int64_t offset;</span>
<span class="s1">  void *_private;</span>
<span class="s1">} rd_kafka_message_t;</span>
<span class="s1">void rd_kafka_message_destroy(rd_kafka_message_t *rkmessage);</span>
<span class="s1">int64_t rd_kafka_message_timestamp(const rd_kafka_message_t *rkmessage, rd_kafka_timestamp_type_t *tstype);</span>
<span class="s1">int64_t rd_kafka_message_latency(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_message_headers(const rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_message_detach_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);</span>
<span class="s1">void rd_kafka_message_set_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t *hdrs);</span>
<span class="s1">size_t rd_kafka_header_cnt(const rd_kafka_headers_t *hdrs);</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_NOT_PERSISTED = 0,</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_POSSIBLY_PERSISTED = 1,</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_PERSISTED = 2,</span>
<span class="s1">} rd_kafka_msg_status_t;</span>
<span class="s1">rd_kafka_msg_status_t rd_kafka_message_status(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_CONF_UNKNOWN = (- 2),</span>
<span class="s1">  RD_KAFKA_CONF_INVALID = (- 1),</span>
<span class="s1">  RD_KAFKA_CONF_OK = 0,</span>
<span class="s1">} rd_kafka_conf_res_t;</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_new(void);</span>
<span class="s1">void rd_kafka_conf_destroy(rd_kafka_conf_t *conf);</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_dup(const rd_kafka_conf_t *conf);</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_dup_filter(const rd_kafka_conf_t *conf, size_t filter_cnt, const char **filter);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_set(rd_kafka_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_conf_set_events(rd_kafka_conf_t *conf, int events);</span>
<span class="s1">void rd_kafka_conf_set_background_event_cb(rd_kafka_conf_t *conf, void (*event_cb)(rd_kafka_t *rk, rd_kafka_event_t *rkev, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_dr_cb(rd_kafka_conf_t *conf, void (*dr_cb)(rd_kafka_t *rk, void *payload, size_t len, rd_kafka_resp_err_t err, void *opaque, void *msg_opaque));</span>
<span class="s1">void rd_kafka_conf_set_dr_msg_cb(rd_kafka_conf_t *conf, void (*dr_msg_cb)(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_consume_cb(rd_kafka_conf_t *conf, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_rebalance_cb(rd_kafka_conf_t *conf, void (*rebalance_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *partitions, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_offset_commit_cb(rd_kafka_conf_t *conf, void (*offset_commit_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_error_cb(rd_kafka_conf_t *conf, void (*error_cb)(rd_kafka_t *rk, int err, const char *reason, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_throttle_cb(rd_kafka_conf_t *conf, void (*throttle_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int throttle_time_ms, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_log_cb(rd_kafka_conf_t *conf, void (*log_cb)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));</span>
<span class="s1">void rd_kafka_conf_set_stats_cb(rd_kafka_conf_t *conf, int (*stats_cb)(rd_kafka_t *rk, char *json, size_t json_len, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_socket_cb(rd_kafka_conf_t *conf, int (*socket_cb)(int domain, int type, int protocol, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_connect_cb(rd_kafka_conf_t *conf, int (*connect_cb)(int sockfd, const struct sockaddr *addr, int addrlen, const char *id, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_closesocket_cb(rd_kafka_conf_t *conf, int (*closesocket_cb)(int sockfd, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_opaque(rd_kafka_conf_t *conf, void *opaque);</span>
<span class="s1">void *rd_kafka_opaque(const rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_conf_set_default_topic_conf(rd_kafka_conf_t *conf, rd_kafka_topic_conf_t *tconf);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_get(const rd_kafka_conf_t *conf, const char *name, char *dest, size_t *dest_size);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_topic_conf_get(const rd_kafka_topic_conf_t *conf, const char *name, char *dest, size_t *dest_size);</span>
<span class="s1">const char **rd_kafka_conf_dump(rd_kafka_conf_t *conf, size_t *cntp);</span>
<span class="s1">const char **rd_kafka_topic_conf_dump(rd_kafka_topic_conf_t *conf, size_t *cntp);</span>
<span class="s1">void rd_kafka_conf_dump_free(const char **arr, size_t cnt);</span>
<span class="s1">void rd_kafka_conf_properties_show(FILE *fp);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_topic_conf_new(void);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_topic_conf_dup(const rd_kafka_topic_conf_t *conf);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_default_topic_conf_dup(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_topic_conf_destroy(rd_kafka_topic_conf_t *topic_conf);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_topic_conf_set(rd_kafka_topic_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_topic_conf_set_opaque(rd_kafka_topic_conf_t *conf, void *opaque);</span>
<span class="s1">void rd_kafka_topic_conf_set_partitioner_cb(rd_kafka_topic_conf_t *topic_conf, int32_t (*partitioner)(const rd_kafka_topic_t *rkt, const void *keydata, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque));</span>
<span class="s1">void rd_kafka_topic_conf_set_msg_order_cmp(rd_kafka_topic_conf_t *topic_conf, int (*msg_order_cmp)(const rd_kafka_message_t *a, const rd_kafka_message_t *b));</span>
<span class="s1">int rd_kafka_topic_partition_available(const rd_kafka_topic_t *rkt, int32_t partition);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_consistent(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_consistent_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_murmur2(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_murmur2_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">rd_kafka_t *rd_kafka_new(rd_kafka_type_t type, rd_kafka_conf_t *conf, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_destroy(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_destroy_flags(rd_kafka_t *rk, int flags);</span>
<span class="s1">const char *rd_kafka_name(const rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_type_t rd_kafka_type(const rd_kafka_t *rk);</span>
<span class="s1">char *rd_kafka_memberid(const rd_kafka_t *rk);</span>
<span class="s1">char *rd_kafka_clusterid(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">int32_t rd_kafka_controllerid(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_topic_t *rd_kafka_topic_new(rd_kafka_t *rk, const char *topic, rd_kafka_topic_conf_t *conf);</span>
<span class="s1">void rd_kafka_topic_destroy(rd_kafka_topic_t *rkt);</span>
<span class="s1">const char *rd_kafka_topic_name(const rd_kafka_topic_t *rkt);</span>
<span class="s1">void *rd_kafka_topic_opaque(const rd_kafka_topic_t *rkt);</span>
<span class="s1">int rd_kafka_poll(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">void rd_kafka_yield(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_pause_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_resume_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_query_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_get_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offsets_for_times(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets, int timeout_ms);</span>
<span class="s1">void rd_kafka_mem_free(rd_kafka_t *rk, void *ptr);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_new(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_queue_destroy(rd_kafka_queue_t *rkqu);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_main(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_consumer(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_partition(rd_kafka_t *rk, const char *topic, int32_t partition);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_background(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_queue_forward(rd_kafka_queue_t *src, rd_kafka_queue_t *dst);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_set_log_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu);</span>
<span class="s1">size_t rd_kafka_queue_length(rd_kafka_queue_t *rkqu);</span>
<span class="s1">void rd_kafka_queue_io_event_enable(rd_kafka_queue_t *rkqu, int fd, const void *payload, size_t size);</span>
<span class="s1">void rd_kafka_queue_cb_event_enable(rd_kafka_queue_t *rkqu, void (*event_cb)(rd_kafka_t *rk, void *opaque), void *opaque);</span>
<span class="s1">int rd_kafka_consume_start(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);</span>
<span class="s1">int rd_kafka_consume_start_queue(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, rd_kafka_queue_t *rkqu);</span>
<span class="s1">int rd_kafka_consume_stop(rd_kafka_topic_t *rkt, int32_t partition);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_seek(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, int timeout_ms);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consume(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms);</span>
<span class="s1">ssize_t rd_kafka_consume_batch(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);</span>
<span class="s1">int rd_kafka_consume_callback(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *opaque), void *opaque);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consume_queue(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">ssize_t rd_kafka_consume_batch_queue(rd_kafka_queue_t *rkqu, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);</span>
<span class="s1">int rd_kafka_consume_callback_queue(rd_kafka_queue_t *rkqu, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *opaque), void *opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offset_store(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offsets_store(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_subscribe(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *topics);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_unsubscribe(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_subscription(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **topics);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consumer_poll(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_consumer_close(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_assignment(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, int async);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit_message(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, int async);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit_queue(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_queue_t *rkqu, void (*cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *opaque), void *opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_committed(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_position(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">int rd_kafka_produce(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, void *payload, size_t len, const void *key, size_t keylen, void *msg_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_producev(rd_kafka_t *rk, ...);</span>
<span class="s1">int rd_kafka_produce_batch(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, rd_kafka_message_t *rkmessages, int message_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_flush(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_purge(rd_kafka_t *rk, int purge_flags);</span>
<span class="s1">typedef struct rd_kafka_metadata_broker {</span>
<span class="s1">  int32_t id;</span>
<span class="s1">  char *host;</span>
<span class="s1">  int port;</span>
<span class="s1">} rd_kafka_metadata_broker_t;</span>
<span class="s1">typedef struct rd_kafka_metadata_partition {</span>
<span class="s1">  int32_t id;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  int32_t leader;</span>
<span class="s1">  int replica_cnt;</span>
<span class="s1">  int32_t *replicas;</span>
<span class="s1">  int isr_cnt;</span>
<span class="s1">  int32_t *isrs;</span>
<span class="s1">} rd_kafka_metadata_partition_t;</span>
<span class="s1">typedef struct rd_kafka_metadata_topic {</span>
<span class="s1">  char *topic;</span>
<span class="s1">  int partition_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_partition *partitions;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">} rd_kafka_metadata_topic_t;</span>
<span class="s1">typedef struct rd_kafka_metadata {</span>
<span class="s1">  int broker_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_broker *brokers;</span>
<span class="s1">  int topic_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_topic *topics;</span>
<span class="s1">  int32_t orig_broker_id;</span>
<span class="s1">  char *orig_broker_name;</span>
<span class="s1">} rd_kafka_metadata_t;</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_metadata(rd_kafka_t *rk, int all_topics, rd_kafka_topic_t *only_rkt, const struct rd_kafka_metadata **metadatap, int timeout_ms);</span>
<span class="s1">void rd_kafka_metadata_destroy(const struct rd_kafka_metadata *metadata);</span>
<span class="s1">struct rd_kafka_group_member_info {</span>
<span class="s1">  char *member_id;</span>
<span class="s1">  char *client_id;</span>
<span class="s1">  char *client_host;</span>
<span class="s1">  void *member_metadata;</span>
<span class="s1">  int member_metadata_size;</span>
<span class="s1">  void *member_assignment;</span>
<span class="s1">  int member_assignment_size;</span>
<span class="s1">};</span>
<span class="s1">struct rd_kafka_group_info {</span>
<span class="s1">  struct rd_kafka_metadata_broker broker;</span>
<span class="s1">  char *group;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  char *state;</span>
<span class="s1">  char *protocol_type;</span>
<span class="s1">  char *protocol;</span>
<span class="s1">  struct rd_kafka_group_member_info *members;</span>
<span class="s1">  int member_cnt;</span>
<span class="s1">};</span>
<span class="s1">struct rd_kafka_group_list {</span>
<span class="s1">  struct rd_kafka_group_info *groups;</span>
<span class="s1">  int group_cnt;</span>
<span class="s1">};</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_list_groups(rd_kafka_t *rk, const char *group, const struct rd_kafka_group_list **grplistp, int timeout_ms);</span>
<span class="s1">void rd_kafka_group_list_destroy(const struct rd_kafka_group_list *grplist);</span>
<span class="s1">int rd_kafka_brokers_add(rd_kafka_t *rk, const char *brokerlist);</span>
<span class="s1">void rd_kafka_set_logger(rd_kafka_t *rk, void (*func)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));</span>
<span class="s1">void rd_kafka_set_log_level(rd_kafka_t *rk, int level);</span>
<span class="s1">void rd_kafka_log_print(const rd_kafka_t *rk, int level, const char *fac, const char *buf);</span>
<span class="s1">void rd_kafka_log_syslog(const rd_kafka_t *rk, int level, const char *fac, const char *buf);</span>
<span class="s1">int rd_kafka_outq_len(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_dump(FILE *fp, rd_kafka_t *rk);</span>
<span class="s1">int rd_kafka_thread_cnt(void);</span>
<span class="s1">int rd_kafka_wait_destroyed(int timeout_ms);</span>
<span class="s1">int rd_kafka_unittest(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_poll_set_consumer(rd_kafka_t *rk);</span>
<span class="s1">typedef int rd_kafka_event_type_t;</span>
<span class="s1">rd_kafka_event_type_t rd_kafka_event_type(const rd_kafka_event_t *rkev);</span>
<span class="s1">const char *rd_kafka_event_name(const rd_kafka_event_t *rkev);</span>
<span class="s1">void rd_kafka_event_destroy(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_message_t *rd_kafka_event_message_next(rd_kafka_event_t *rkev);</span>
<span class="s1">size_t rd_kafka_event_message_array(rd_kafka_event_t *rkev, const rd_kafka_message_t **rkmessages, size_t size);</span>
<span class="s1">size_t rd_kafka_event_message_count(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_event_error(rd_kafka_event_t *rkev);</span>
<span class="s1">const char *rd_kafka_event_error_string(rd_kafka_event_t *rkev);</span>
<span class="s1">int rd_kafka_event_error_is_fatal(rd_kafka_event_t *rkev);</span>
<span class="s1">void *rd_kafka_event_opaque(rd_kafka_event_t *rkev);</span>
<span class="s1">int rd_kafka_event_log(rd_kafka_event_t *rkev, const char **fac, const char **str, int *level);</span>
<span class="s1">const char *rd_kafka_event_stats(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_event_topic_partition_list(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_event_topic_partition(rd_kafka_event_t *rkev);</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_CreateTopics_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DeleteTopics_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_CreatePartitions_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_AlterConfigs_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DescribeConfigs_result_t;</span>
<span class="s1">const rd_kafka_CreateTopics_result_t *rd_kafka_event_CreateTopics_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DeleteTopics_result_t *rd_kafka_event_DeleteTopics_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_CreatePartitions_result_t *rd_kafka_event_CreatePartitions_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_AlterConfigs_result_t *rd_kafka_event_AlterConfigs_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DescribeConfigs_result_t *rd_kafka_event_DescribeConfigs_result(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_event_t *rd_kafka_queue_poll(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">int rd_kafka_queue_poll_callback(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_plugin_f_conf_init_t)(rd_kafka_conf_t *conf, void **plug_opaquep, char *errstr, size_t errstr_size);</span>
<span class="s1">typedef rd_kafka_conf_res_t (rd_kafka_interceptor_f_on_conf_set_t)(rd_kafka_conf_t *conf, const char *name, const char *val, char *errstr, size_t errstr_size, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_dup_t)(rd_kafka_conf_t *new_conf, const rd_kafka_conf_t *old_conf, size_t filter_cnt, const char **filter, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_destroy_t)(void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_new_t)(rd_kafka_t *rk, const rd_kafka_conf_t *conf, void *ic_opaque, char *errstr, size_t errstr_size);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_destroy_t)(rd_kafka_t *rk, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_send_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_acknowledgement_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_consume_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_commit_t)(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_resp_err_t err, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_request_sent_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_set(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_set_t *on_conf_set, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_dup(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_dup_t *on_conf_dup, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_destroy(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_destroy_t *on_conf_destroy, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_new(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_new_t *on_new, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_destroy(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_destroy_t *on_destroy, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_send(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_send_t *on_send, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_acknowledgement(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_acknowledgement_t *on_acknowledgement, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_consume(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_consume_t *on_consume, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_commit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_commit_t *on_commit, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_request_sent(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_request_sent_t *on_request_sent, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_topic_result_error(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">const char *rd_kafka_topic_result_error_string(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">const char *rd_kafka_topic_result_name(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">typedef enum rd_kafka_admin_op_t {</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_ANY = 0,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_CREATETOPICS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DELETETOPICS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_CREATEPARTITIONS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_ALTERCONFIGS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DESCRIBECONFIGS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP__CNT,</span>
<span class="s1">} rd_kafka_admin_op_t;</span>
<span class="s1">typedef struct rd_kafka_AdminOptions_s rd_kafka_AdminOptions_t;</span>
<span class="s1">rd_kafka_AdminOptions_t *rd_kafka_AdminOptions_new(rd_kafka_t *rk, rd_kafka_admin_op_t for_api);</span>
<span class="s1">void rd_kafka_AdminOptions_destroy(rd_kafka_AdminOptions_t *options);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_request_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_operation_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_validate_only(rd_kafka_AdminOptions_t *options, int true_or_false, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_broker(rd_kafka_AdminOptions_t *options, int32_t broker_id, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_AdminOptions_set_opaque(rd_kafka_AdminOptions_t *options, void *opaque);</span>
<span class="s1">typedef struct rd_kafka_NewTopic_s rd_kafka_NewTopic_t;</span>
<span class="s1">rd_kafka_NewTopic_t *rd_kafka_NewTopic_new(const char *topic, int num_partitions, int replication_factor, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_NewTopic_destroy(rd_kafka_NewTopic_t *new_topic);</span>
<span class="s1">void rd_kafka_NewTopic_destroy_array(rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewTopic_set_replica_assignment(rd_kafka_NewTopic_t *new_topic, int32_t partition, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewTopic_set_config(rd_kafka_NewTopic_t *new_topic, const char *name, const char *value);</span>
<span class="s1">void rd_kafka_CreateTopics(rd_kafka_t *rk, rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_CreateTopics_result_topics(const rd_kafka_CreateTopics_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_DeleteTopic_s rd_kafka_DeleteTopic_t;</span>
<span class="s1">rd_kafka_DeleteTopic_t *rd_kafka_DeleteTopic_new(const char *topic);</span>
<span class="s1">void rd_kafka_DeleteTopic_destroy(rd_kafka_DeleteTopic_t *del_topic);</span>
<span class="s1">void rd_kafka_DeleteTopic_destroy_array(rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt);</span>
<span class="s1">void rd_kafka_DeleteTopics(rd_kafka_t *rk, rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_DeleteTopics_result_topics(const rd_kafka_DeleteTopics_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_NewPartitions_s rd_kafka_NewPartitions_t;</span>
<span class="s1">rd_kafka_NewPartitions_t *rd_kafka_NewPartitions_new(const char *topic, size_t new_total_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_NewPartitions_destroy(rd_kafka_NewPartitions_t *new_parts);</span>
<span class="s1">void rd_kafka_NewPartitions_destroy_array(rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewPartitions_set_replica_assignment(rd_kafka_NewPartitions_t *new_parts, int32_t new_partition_idx, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_CreatePartitions(rd_kafka_t *rk, rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_CreatePartitions_result_topics(const rd_kafka_CreatePartitions_result_t *result, size_t *cntp);</span>
<span class="s1">typedef enum rd_kafka_ConfigSource_t {</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_UNKNOWN_CONFIG = 0,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_TOPIC_CONFIG = 1,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_BROKER_CONFIG = 2,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_DEFAULT_BROKER_CONFIG = 3,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_STATIC_BROKER_CONFIG = 4,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DEFAULT_CONFIG = 5,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE__CNT,</span>
<span class="s1">} rd_kafka_ConfigSource_t;</span>
<span class="s1">const char *rd_kafka_ConfigSource_name(rd_kafka_ConfigSource_t confsource);</span>
<span class="s1">typedef struct rd_kafka_ConfigEntry_s rd_kafka_ConfigEntry_t;</span>
<span class="s1">const char *rd_kafka_ConfigEntry_name(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">const char *rd_kafka_ConfigEntry_value(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">rd_kafka_ConfigSource_t rd_kafka_ConfigEntry_source(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_read_only(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_default(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_sensitive(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_synonym(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">const rd_kafka_ConfigEntry_t **rd_kafka_ConfigEntry_synonyms(const rd_kafka_ConfigEntry_t *entry, size_t *cntp);</span>
<span class="s1">typedef enum rd_kafka_ResourceType_t {</span>
<span class="s1">  RD_KAFKA_RESOURCE_UNKNOWN = 0,</span>
<span class="s1">  RD_KAFKA_RESOURCE_ANY = 1,</span>
<span class="s1">  RD_KAFKA_RESOURCE_TOPIC = 2,</span>
<span class="s1">  RD_KAFKA_RESOURCE_GROUP = 3,</span>
<span class="s1">  RD_KAFKA_RESOURCE_BROKER = 4,</span>
<span class="s1">  RD_KAFKA_RESOURCE__CNT,</span>
<span class="s1">} rd_kafka_ResourceType_t;</span>
<span class="s1">const char *rd_kafka_ResourceType_name(rd_kafka_ResourceType_t restype);</span>
<span class="s1">typedef struct rd_kafka_ConfigResource_s rd_kafka_ConfigResource_t;</span>
<span class="s1">rd_kafka_ConfigResource_t *rd_kafka_ConfigResource_new(rd_kafka_ResourceType_t restype, const char *resname);</span>
<span class="s1">void rd_kafka_ConfigResource_destroy(rd_kafka_ConfigResource_t *config);</span>
<span class="s1">void rd_kafka_ConfigResource_destroy_array(rd_kafka_ConfigResource_t **config, size_t config_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_ConfigResource_set_config(rd_kafka_ConfigResource_t *config, const char *name, const char *value);</span>
<span class="s1">const rd_kafka_ConfigEntry_t **rd_kafka_ConfigResource_configs(const rd_kafka_ConfigResource_t *config, size_t *cntp);</span>
<span class="s1">rd_kafka_ResourceType_t rd_kafka_ConfigResource_type(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">const char *rd_kafka_ConfigResource_name(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_ConfigResource_error(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">const char *rd_kafka_ConfigResource_error_string(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">void rd_kafka_AlterConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_ConfigResource_t **rd_kafka_AlterConfigs_result_resources(const rd_kafka_AlterConfigs_result_t *result, size_t *cntp);</span>
<span class="s1">void rd_kafka_DescribeConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_ConfigResource_t **rd_kafka_DescribeConfigs_result_resources(const rd_kafka_DescribeConfigs_result_t *result, size_t *cntp);</span>
<span class="s1">&#39;</span>
</code></pre></div>
rdkafka.h, rdkafka_mock.h</p>
<h3 id="rd_kafka_version_2">RD_KAFKA_VERSION<a class="headerlink" href="#rd_kafka_version_2" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_VERSION</span> <span class="o">=</span> <span class="mi">16843007</span>
</code></pre></div>
<p>librdkafka version </p>
<p>Interpreted as hex <code>MM.mm.rr.xx</code>:</p>
<ul>
<li>MM = Major</li>
<li>mm = minor</li>
<li>rr = revision</li>
<li>xx = pre-release id (0xff is the final release)</li>
</ul>
<p>E.g.: <code>0x000801ff</code> = 0.8.1</p>
<dl class="section remark"><dt>Remarks</dt><dd>This value should only be used during compile time, for runtime checks of version use rd_kafka_version() </dd></dl>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_unsupported_compression_type_2">RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE<a class="headerlink" href="#rd_kafka_resp_err_unsupported_compression_type_2" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE</span> <span class="o">=</span> <span class="mi">76</span>
</code></pre></div>
<p>Unsupported compression type </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_end_all_2">RD_KAFKA_RESP_ERR_END_ALL<a class="headerlink" href="#rd_kafka_resp_err_end_all_2" title="Permanent link">&para;</a></h3>
<p><div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_END_ALL</span> <span class="o">=</span> <span class="mi">82</span>
</code></pre></div>
enum rd_kafka_resp_err_t</p>
<h3 id="rd_kafka_admin_op__cnt_2">RD_KAFKA_ADMIN_OP__CNT<a class="headerlink" href="#rd_kafka_admin_op__cnt_2" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_ADMIN_OP__CNT</span> <span class="o">=</span> <span class="mi">6</span>
</code></pre></div>
<p>Number of ops defined </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe </a></li>
</ul>
</div>
<h3 id="rd_kafka_resource__cnt_2">RD_KAFKA_RESOURCE__CNT<a class="headerlink" href="#rd_kafka_resource__cnt_2" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESOURCE__CNT</span> <span class="o">=</span> <span class="mi">5</span>
</code></pre></div>
<p>Number of resource types defined </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#acca83a66d7783ff7683ed2691cc907c9"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#acca83a66d7783ff7683ed2691cc907c9 </a></li>
</ul>
</div>
<h3 id="rd_kafka_cdef_2">RD_KAFKA_CDEF<a class="headerlink" href="#rd_kafka_cdef_2" title="Permanent link">&para;</a></h3>
<p><div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_CDEF</span> <span class="o">=</span> <span class="s1">&#39;typedef long int ssize_t;</span>
<span class="s1">typedef struct _IO_FILE FILE;</span>
<span class="s1">typedef long int mode_t;</span>
<span class="s1">typedef signed int int16_t;</span>
<span class="s1">typedef unsigned int uint16_t;</span>
<span class="s1">typedef signed int int32_t;</span>
<span class="s1">typedef signed long int int64_t;</span>
<span class="s1">int rd_kafka_version(void);</span>
<span class="s1">const char *rd_kafka_version_str(void);</span>
<span class="s1">typedef enum rd_kafka_type_t {</span>
<span class="s1">  RD_KAFKA_PRODUCER,</span>
<span class="s1">  RD_KAFKA_CONSUMER,</span>
<span class="s1">} rd_kafka_type_t;</span>
<span class="s1">typedef enum rd_kafka_timestamp_type_t {</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_NOT_AVAILABLE,</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_CREATE_TIME,</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_LOG_APPEND_TIME,</span>
<span class="s1">} rd_kafka_timestamp_type_t;</span>
<span class="s1">const char *rd_kafka_get_debug_contexts(void);</span>
<span class="s1">typedef struct rd_kafka_s rd_kafka_t;</span>
<span class="s1">typedef struct rd_kafka_topic_s rd_kafka_topic_t;</span>
<span class="s1">typedef struct rd_kafka_conf_s rd_kafka_conf_t;</span>
<span class="s1">typedef struct rd_kafka_topic_conf_s rd_kafka_topic_conf_t;</span>
<span class="s1">typedef struct rd_kafka_queue_s rd_kafka_queue_t;</span>
<span class="s1">typedef struct rd_kafka_op_s rd_kafka_event_t;</span>
<span class="s1">typedef struct rd_kafka_topic_result_s rd_kafka_topic_result_t;</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BEGIN = (- 200),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BAD_MSG = (- 199),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BAD_COMPRESSION = (- 198),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__DESTROY = (- 197),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FAIL = (- 196),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TRANSPORT = (- 195),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__CRIT_SYS_RESOURCE = (- 194),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__RESOLVE = (- 193),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__MSG_TIMED_OUT = (- 192),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PARTITION_EOF = (- 191),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION = (- 190),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FS = (- 189),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC = (- 188),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ALL_BROKERS_DOWN = (- 187),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INVALID_ARG = (- 186),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TIMED_OUT = (- 185),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__QUEUE_FULL = (- 184),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ISR_INSUFF = (- 183),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NODE_UPDATE = (- 182),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__SSL = (- 181),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__WAIT_COORD = (- 180),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_GROUP = (- 179),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__IN_PROGRESS = (- 178),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PREV_IN_PROGRESS = (- 177),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__EXISTING_SUBSCRIPTION = (- 176),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS = (- 175),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS = (- 174),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__CONFLICT = (- 173),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__STATE = (- 172),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_PROTOCOL = (- 171),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED = (- 170),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__AUTHENTICATION = (- 169),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NO_OFFSET = (- 168),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__OUTDATED = (- 167),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TIMED_OUT_QUEUE = (- 166),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNSUPPORTED_FEATURE = (- 165),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__WAIT_CACHE = (- 164),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INTR = (- 163),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__KEY_SERIALIZATION = (- 162),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__VALUE_SERIALIZATION = (- 161),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__KEY_DESERIALIZATION = (- 160),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__VALUE_DESERIALIZATION = (- 159),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PARTIAL = (- 158),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__READ_ONLY = (- 157),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOENT = (- 156),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNDERFLOW = (- 155),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INVALID_TYPE = (- 154),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__RETRY = (- 153),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PURGE_QUEUE = (- 152),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PURGE_INFLIGHT = (- 151),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FATAL = (- 150),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INCONSISTENT = (- 149),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__GAPLESS_GUARANTEE = (- 148),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__MAX_POLL_EXCEEDED = (- 147),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__END = (- 100),</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN = (- 1),</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NO_ERROR = 0,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_OUT_OF_RANGE = 1,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_MSG = 2,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART = 3,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_MSG_SIZE = 4,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE = 5,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_LEADER_FOR_PARTITION = 6,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REQUEST_TIMED_OUT = 7,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_BROKER_NOT_AVAILABLE = 8,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REPLICA_NOT_AVAILABLE = 9,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE = 10,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_STALE_CTRL_EPOCH = 11,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_METADATA_TOO_LARGE = 12,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NETWORK_EXCEPTION = 13,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_LOAD_IN_PROGRESS = 14,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_COORDINATOR_NOT_AVAILABLE = 15,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_COORDINATOR_FOR_GROUP = 16,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_EXCEPTION = 17,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_RECORD_LIST_TOO_LARGE = 18,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS = 19,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS_AFTER_APPEND = 20,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REQUIRED_ACKS = 21,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ILLEGAL_GENERATION = 22,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INCONSISTENT_GROUP_PROTOCOL = 23,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_GROUP_ID = 24,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_MEMBER_ID = 25,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_SESSION_TIMEOUT = 26,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REBALANCE_IN_PROGRESS = 27,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_COMMIT_OFFSET_SIZE = 28,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_AUTHORIZATION_FAILED = 29,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_AUTHORIZATION_FAILED = 30,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_CLUSTER_AUTHORIZATION_FAILED = 31,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TIMESTAMP = 32,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_SASL_MECHANISM = 33,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ILLEGAL_SASL_STATE = 34,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_VERSION = 35,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_ALREADY_EXISTS = 36,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PARTITIONS = 37,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REPLICATION_FACTOR = 38,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REPLICA_ASSIGNMENT = 39,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_CONFIG = 40,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_CONTROLLER = 41,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REQUEST = 42,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_FOR_MESSAGE_FORMAT = 43,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_POLICY_VIOLATION = 44,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OUT_OF_ORDER_SEQUENCE_NUMBER = 45,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DUPLICATE_SEQUENCE_NUMBER = 46,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_EPOCH = 47,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TXN_STATE = 48,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_ID_MAPPING = 49,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TRANSACTION_TIMEOUT = 50,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_CONCURRENT_TRANSACTIONS = 51,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TRANSACTION_COORDINATOR_FENCED = 52,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TRANSACTIONAL_ID_AUTHORIZATION_FAILED = 53,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_SECURITY_DISABLED = 54,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OPERATION_NOT_ATTEMPTED = 55,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_KAFKA_STORAGE_ERROR = 56,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LOG_DIR_NOT_FOUND = 57,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_SASL_AUTHENTICATION_FAILED = 58,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_PRODUCER_ID = 59,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REASSIGNMENT_IN_PROGRESS = 60,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTH_DISABLED = 61,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_NOT_FOUND = 62,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_OWNER_MISMATCH = 63,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_REQUEST_NOT_ALLOWED = 64,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTHORIZATION_FAILED = 65,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_EXPIRED = 66,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRINCIPAL_TYPE = 67,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NON_EMPTY_GROUP = 68,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_ID_NOT_FOUND = 69,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FETCH_SESSION_ID_NOT_FOUND = 70,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_FETCH_SESSION_EPOCH = 71,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LISTENER_NOT_FOUND = 72,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_DELETION_DISABLED = 73,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FENCED_LEADER_EPOCH = 74,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_LEADER_EPOCH = 75,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_STALE_BROKER_EPOCH = 77,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_NOT_AVAILABLE = 78,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_MEMBER_ID_REQUIRED = 79,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_PREFERRED_LEADER_NOT_AVAILABLE = 80,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_MAX_SIZE_REACHED = 81,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_END_ALL,</span>
<span class="s1">} rd_kafka_resp_err_t;</span>
<span class="s1">struct rd_kafka_err_desc {</span>
<span class="s1">  rd_kafka_resp_err_t code;</span>
<span class="s1">  char *name;</span>
<span class="s1">  char *desc;</span>
<span class="s1">};</span>
<span class="s1">void rd_kafka_get_err_descs(const struct rd_kafka_err_desc **errdescs, size_t *cntp);</span>
<span class="s1">const char *rd_kafka_err2str(rd_kafka_resp_err_t err);</span>
<span class="s1">const char *rd_kafka_err2name(rd_kafka_resp_err_t err);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_last_error(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_errno2err(int errnox);</span>
<span class="s1">int rd_kafka_errno(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_fatal_error(rd_kafka_t *rk, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_test_fatal_error(rd_kafka_t *rk, rd_kafka_resp_err_t err, const char *reason);</span>
<span class="s1">typedef struct rd_kafka_topic_partition_s {</span>
<span class="s1">  char *topic;</span>
<span class="s1">  int32_t partition;</span>
<span class="s1">  int64_t offset;</span>
<span class="s1">  void *metadata;</span>
<span class="s1">  size_t metadata_size;</span>
<span class="s1">  void *opaque;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  void *_private;</span>
<span class="s1">} rd_kafka_topic_partition_t;</span>
<span class="s1">void rd_kafka_topic_partition_destroy(rd_kafka_topic_partition_t *rktpar);</span>
<span class="s1">typedef struct rd_kafka_topic_partition_list_s {</span>
<span class="s1">  int cnt;</span>
<span class="s1">  int size;</span>
<span class="s1">  rd_kafka_topic_partition_t *elems;</span>
<span class="s1">} rd_kafka_topic_partition_list_t;</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_new(int size);</span>
<span class="s1">void rd_kafka_topic_partition_list_destroy(rd_kafka_topic_partition_list_t *rkparlist);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_add(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">void rd_kafka_topic_partition_list_add_range(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t start, int32_t stop);</span>
<span class="s1">int rd_kafka_topic_partition_list_del(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">int rd_kafka_topic_partition_list_del_by_idx(rd_kafka_topic_partition_list_t *rktparlist, int idx);</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_copy(const rd_kafka_topic_partition_list_t *src);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_topic_partition_list_set_offset(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition, int64_t offset);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_find(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">void rd_kafka_topic_partition_list_sort(rd_kafka_topic_partition_list_t *rktparlist, int (*cmp)(const void *a, const void *b, void *opaque), void *opaque);</span>
<span class="s1">typedef enum rd_kafka_vtype_t {</span>
<span class="s1">  RD_KAFKA_VTYPE_END,</span>
<span class="s1">  RD_KAFKA_VTYPE_TOPIC,</span>
<span class="s1">  RD_KAFKA_VTYPE_RKT,</span>
<span class="s1">  RD_KAFKA_VTYPE_PARTITION,</span>
<span class="s1">  RD_KAFKA_VTYPE_VALUE,</span>
<span class="s1">  RD_KAFKA_VTYPE_KEY,</span>
<span class="s1">  RD_KAFKA_VTYPE_OPAQUE,</span>
<span class="s1">  RD_KAFKA_VTYPE_MSGFLAGS,</span>
<span class="s1">  RD_KAFKA_VTYPE_TIMESTAMP,</span>
<span class="s1">  RD_KAFKA_VTYPE_HEADER,</span>
<span class="s1">  RD_KAFKA_VTYPE_HEADERS,</span>
<span class="s1">} rd_kafka_vtype_t;</span>
<span class="s1">typedef struct rd_kafka_headers_s rd_kafka_headers_t;</span>
<span class="s1">rd_kafka_headers_t *rd_kafka_headers_new(size_t initial_count);</span>
<span class="s1">void rd_kafka_headers_destroy(rd_kafka_headers_t *hdrs);</span>
<span class="s1">rd_kafka_headers_t *rd_kafka_headers_copy(const rd_kafka_headers_t *src);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_add(rd_kafka_headers_t *hdrs, const char *name, ssize_t name_size, const void *value, ssize_t value_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_remove(rd_kafka_headers_t *hdrs, const char *name);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get_last(const rd_kafka_headers_t *hdrs, const char *name, const void **valuep, size_t *sizep);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get(const rd_kafka_headers_t *hdrs, size_t idx, const char *name, const void **valuep, size_t *sizep);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get_all(const rd_kafka_headers_t *hdrs, size_t idx, const char **namep, const void **valuep, size_t *sizep);</span>
<span class="s1">typedef struct rd_kafka_message_s {</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  rd_kafka_topic_t *rkt;</span>
<span class="s1">  int32_t partition;</span>
<span class="s1">  void *payload;</span>
<span class="s1">  size_t len;</span>
<span class="s1">  void *key;</span>
<span class="s1">  size_t key_len;</span>
<span class="s1">  int64_t offset;</span>
<span class="s1">  void *_private;</span>
<span class="s1">} rd_kafka_message_t;</span>
<span class="s1">void rd_kafka_message_destroy(rd_kafka_message_t *rkmessage);</span>
<span class="s1">int64_t rd_kafka_message_timestamp(const rd_kafka_message_t *rkmessage, rd_kafka_timestamp_type_t *tstype);</span>
<span class="s1">int64_t rd_kafka_message_latency(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_message_headers(const rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_message_detach_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);</span>
<span class="s1">void rd_kafka_message_set_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t *hdrs);</span>
<span class="s1">size_t rd_kafka_header_cnt(const rd_kafka_headers_t *hdrs);</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_NOT_PERSISTED = 0,</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_POSSIBLY_PERSISTED = 1,</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_PERSISTED = 2,</span>
<span class="s1">} rd_kafka_msg_status_t;</span>
<span class="s1">rd_kafka_msg_status_t rd_kafka_message_status(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_CONF_UNKNOWN = (- 2),</span>
<span class="s1">  RD_KAFKA_CONF_INVALID = (- 1),</span>
<span class="s1">  RD_KAFKA_CONF_OK = 0,</span>
<span class="s1">} rd_kafka_conf_res_t;</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_new(void);</span>
<span class="s1">void rd_kafka_conf_destroy(rd_kafka_conf_t *conf);</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_dup(const rd_kafka_conf_t *conf);</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_dup_filter(const rd_kafka_conf_t *conf, size_t filter_cnt, const char **filter);</span>
<span class="s1">const rd_kafka_conf_t *rd_kafka_conf(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_set(rd_kafka_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_conf_set_events(rd_kafka_conf_t *conf, int events);</span>
<span class="s1">void rd_kafka_conf_set_background_event_cb(rd_kafka_conf_t *conf, void (*event_cb)(rd_kafka_t *rk, rd_kafka_event_t *rkev, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_dr_cb(rd_kafka_conf_t *conf, void (*dr_cb)(rd_kafka_t *rk, void *payload, size_t len, rd_kafka_resp_err_t err, void *opaque, void *msg_opaque));</span>
<span class="s1">void rd_kafka_conf_set_dr_msg_cb(rd_kafka_conf_t *conf, void (*dr_msg_cb)(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_consume_cb(rd_kafka_conf_t *conf, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_rebalance_cb(rd_kafka_conf_t *conf, void (*rebalance_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *partitions, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_offset_commit_cb(rd_kafka_conf_t *conf, void (*offset_commit_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_error_cb(rd_kafka_conf_t *conf, void (*error_cb)(rd_kafka_t *rk, int err, const char *reason, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_throttle_cb(rd_kafka_conf_t *conf, void (*throttle_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int throttle_time_ms, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_log_cb(rd_kafka_conf_t *conf, void (*log_cb)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));</span>
<span class="s1">void rd_kafka_conf_set_stats_cb(rd_kafka_conf_t *conf, int (*stats_cb)(rd_kafka_t *rk, char *json, size_t json_len, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_oauthbearer_token_refresh_cb(rd_kafka_conf_t *conf, void (*oauthbearer_token_refresh_cb)(rd_kafka_t *rk, const char *oauthbearer_config, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_socket_cb(rd_kafka_conf_t *conf, int (*socket_cb)(int domain, int type, int protocol, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_connect_cb(rd_kafka_conf_t *conf, int (*connect_cb)(int sockfd, const struct sockaddr *addr, int addrlen, const char *id, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_closesocket_cb(rd_kafka_conf_t *conf, int (*closesocket_cb)(int sockfd, void *opaque));</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert_verify_cb(rd_kafka_conf_t *conf, int (*ssl_cert_verify_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int *x509_error, int depth, const char *buf, size_t size, char *errstr, size_t errstr_size, void *opaque));</span>
<span class="s1">typedef enum rd_kafka_cert_type_t {</span>
<span class="s1">  RD_KAFKA_CERT_PUBLIC_KEY,</span>
<span class="s1">  RD_KAFKA_CERT_PRIVATE_KEY,</span>
<span class="s1">  RD_KAFKA_CERT_CA,</span>
<span class="s1">  RD_KAFKA_CERT__CNT,</span>
<span class="s1">} rd_kafka_cert_type_t;</span>
<span class="s1">typedef enum rd_kafka_cert_enc_t {</span>
<span class="s1">  RD_KAFKA_CERT_ENC_PKCS12,</span>
<span class="s1">  RD_KAFKA_CERT_ENC_DER,</span>
<span class="s1">  RD_KAFKA_CERT_ENC_PEM,</span>
<span class="s1">  RD_KAFKA_CERT_ENC__CNT,</span>
<span class="s1">} rd_kafka_cert_enc_t;</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert(rd_kafka_conf_t *conf, rd_kafka_cert_type_t cert_type, rd_kafka_cert_enc_t cert_enc, const void *buffer, size_t size, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_conf_set_opaque(rd_kafka_conf_t *conf, void *opaque);</span>
<span class="s1">void *rd_kafka_opaque(const rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_conf_set_default_topic_conf(rd_kafka_conf_t *conf, rd_kafka_topic_conf_t *tconf);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_get(const rd_kafka_conf_t *conf, const char *name, char *dest, size_t *dest_size);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_topic_conf_get(const rd_kafka_topic_conf_t *conf, const char *name, char *dest, size_t *dest_size);</span>
<span class="s1">const char **rd_kafka_conf_dump(rd_kafka_conf_t *conf, size_t *cntp);</span>
<span class="s1">const char **rd_kafka_topic_conf_dump(rd_kafka_topic_conf_t *conf, size_t *cntp);</span>
<span class="s1">void rd_kafka_conf_dump_free(const char **arr, size_t cnt);</span>
<span class="s1">void rd_kafka_conf_properties_show(FILE *fp);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_topic_conf_new(void);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_topic_conf_dup(const rd_kafka_topic_conf_t *conf);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_default_topic_conf_dup(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_topic_conf_destroy(rd_kafka_topic_conf_t *topic_conf);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_topic_conf_set(rd_kafka_topic_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_topic_conf_set_opaque(rd_kafka_topic_conf_t *conf, void *opaque);</span>
<span class="s1">void rd_kafka_topic_conf_set_partitioner_cb(rd_kafka_topic_conf_t *topic_conf, int32_t (*partitioner)(const rd_kafka_topic_t *rkt, const void *keydata, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque));</span>
<span class="s1">void rd_kafka_topic_conf_set_msg_order_cmp(rd_kafka_topic_conf_t *topic_conf, int (*msg_order_cmp)(const rd_kafka_message_t *a, const rd_kafka_message_t *b));</span>
<span class="s1">int rd_kafka_topic_partition_available(const rd_kafka_topic_t *rkt, int32_t partition);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_consistent(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_consistent_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_murmur2(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_murmur2_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">rd_kafka_t *rd_kafka_new(rd_kafka_type_t type, rd_kafka_conf_t *conf, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_destroy(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_destroy_flags(rd_kafka_t *rk, int flags);</span>
<span class="s1">const char *rd_kafka_name(const rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_type_t rd_kafka_type(const rd_kafka_t *rk);</span>
<span class="s1">char *rd_kafka_memberid(const rd_kafka_t *rk);</span>
<span class="s1">char *rd_kafka_clusterid(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">int32_t rd_kafka_controllerid(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_topic_t *rd_kafka_topic_new(rd_kafka_t *rk, const char *topic, rd_kafka_topic_conf_t *conf);</span>
<span class="s1">void rd_kafka_topic_destroy(rd_kafka_topic_t *rkt);</span>
<span class="s1">const char *rd_kafka_topic_name(const rd_kafka_topic_t *rkt);</span>
<span class="s1">void *rd_kafka_topic_opaque(const rd_kafka_topic_t *rkt);</span>
<span class="s1">int rd_kafka_poll(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">void rd_kafka_yield(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_pause_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_resume_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_query_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_get_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offsets_for_times(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets, int timeout_ms);</span>
<span class="s1">void rd_kafka_mem_free(rd_kafka_t *rk, void *ptr);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_new(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_queue_destroy(rd_kafka_queue_t *rkqu);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_main(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_consumer(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_partition(rd_kafka_t *rk, const char *topic, int32_t partition);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_background(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_queue_forward(rd_kafka_queue_t *src, rd_kafka_queue_t *dst);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_set_log_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu);</span>
<span class="s1">size_t rd_kafka_queue_length(rd_kafka_queue_t *rkqu);</span>
<span class="s1">void rd_kafka_queue_io_event_enable(rd_kafka_queue_t *rkqu, int fd, const void *payload, size_t size);</span>
<span class="s1">void rd_kafka_queue_cb_event_enable(rd_kafka_queue_t *rkqu, void (*event_cb)(rd_kafka_t *rk, void *opaque), void *opaque);</span>
<span class="s1">int rd_kafka_consume_start(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);</span>
<span class="s1">int rd_kafka_consume_start_queue(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, rd_kafka_queue_t *rkqu);</span>
<span class="s1">int rd_kafka_consume_stop(rd_kafka_topic_t *rkt, int32_t partition);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_seek(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, int timeout_ms);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consume(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms);</span>
<span class="s1">ssize_t rd_kafka_consume_batch(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);</span>
<span class="s1">int rd_kafka_consume_callback(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *opaque), void *opaque);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consume_queue(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">ssize_t rd_kafka_consume_batch_queue(rd_kafka_queue_t *rkqu, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);</span>
<span class="s1">int rd_kafka_consume_callback_queue(rd_kafka_queue_t *rkqu, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *opaque), void *opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offset_store(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offsets_store(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_subscribe(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *topics);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_unsubscribe(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_subscription(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **topics);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consumer_poll(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_consumer_close(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_assignment(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, int async);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit_message(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, int async);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit_queue(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_queue_t *rkqu, void (*cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *opaque), void *opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_committed(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_position(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">int rd_kafka_produce(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, void *payload, size_t len, const void *key, size_t keylen, void *msg_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_producev(rd_kafka_t *rk, ...);</span>
<span class="s1">int rd_kafka_produce_batch(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, rd_kafka_message_t *rkmessages, int message_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_flush(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_purge(rd_kafka_t *rk, int purge_flags);</span>
<span class="s1">typedef struct rd_kafka_metadata_broker {</span>
<span class="s1">  int32_t id;</span>
<span class="s1">  char *host;</span>
<span class="s1">  int port;</span>
<span class="s1">} rd_kafka_metadata_broker_t;</span>
<span class="s1">typedef struct rd_kafka_metadata_partition {</span>
<span class="s1">  int32_t id;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  int32_t leader;</span>
<span class="s1">  int replica_cnt;</span>
<span class="s1">  int32_t *replicas;</span>
<span class="s1">  int isr_cnt;</span>
<span class="s1">  int32_t *isrs;</span>
<span class="s1">} rd_kafka_metadata_partition_t;</span>
<span class="s1">typedef struct rd_kafka_metadata_topic {</span>
<span class="s1">  char *topic;</span>
<span class="s1">  int partition_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_partition *partitions;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">} rd_kafka_metadata_topic_t;</span>
<span class="s1">typedef struct rd_kafka_metadata {</span>
<span class="s1">  int broker_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_broker *brokers;</span>
<span class="s1">  int topic_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_topic *topics;</span>
<span class="s1">  int32_t orig_broker_id;</span>
<span class="s1">  char *orig_broker_name;</span>
<span class="s1">} rd_kafka_metadata_t;</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_metadata(rd_kafka_t *rk, int all_topics, rd_kafka_topic_t *only_rkt, const struct rd_kafka_metadata **metadatap, int timeout_ms);</span>
<span class="s1">void rd_kafka_metadata_destroy(const struct rd_kafka_metadata *metadata);</span>
<span class="s1">struct rd_kafka_group_member_info {</span>
<span class="s1">  char *member_id;</span>
<span class="s1">  char *client_id;</span>
<span class="s1">  char *client_host;</span>
<span class="s1">  void *member_metadata;</span>
<span class="s1">  int member_metadata_size;</span>
<span class="s1">  void *member_assignment;</span>
<span class="s1">  int member_assignment_size;</span>
<span class="s1">};</span>
<span class="s1">struct rd_kafka_group_info {</span>
<span class="s1">  struct rd_kafka_metadata_broker broker;</span>
<span class="s1">  char *group;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  char *state;</span>
<span class="s1">  char *protocol_type;</span>
<span class="s1">  char *protocol;</span>
<span class="s1">  struct rd_kafka_group_member_info *members;</span>
<span class="s1">  int member_cnt;</span>
<span class="s1">};</span>
<span class="s1">struct rd_kafka_group_list {</span>
<span class="s1">  struct rd_kafka_group_info *groups;</span>
<span class="s1">  int group_cnt;</span>
<span class="s1">};</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_list_groups(rd_kafka_t *rk, const char *group, const struct rd_kafka_group_list **grplistp, int timeout_ms);</span>
<span class="s1">void rd_kafka_group_list_destroy(const struct rd_kafka_group_list *grplist);</span>
<span class="s1">int rd_kafka_brokers_add(rd_kafka_t *rk, const char *brokerlist);</span>
<span class="s1">void rd_kafka_set_logger(rd_kafka_t *rk, void (*func)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));</span>
<span class="s1">void rd_kafka_set_log_level(rd_kafka_t *rk, int level);</span>
<span class="s1">void rd_kafka_log_print(const rd_kafka_t *rk, int level, const char *fac, const char *buf);</span>
<span class="s1">void rd_kafka_log_syslog(const rd_kafka_t *rk, int level, const char *fac, const char *buf);</span>
<span class="s1">int rd_kafka_outq_len(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_dump(FILE *fp, rd_kafka_t *rk);</span>
<span class="s1">int rd_kafka_thread_cnt(void);</span>
<span class="s1">int rd_kafka_wait_destroyed(int timeout_ms);</span>
<span class="s1">int rd_kafka_unittest(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_poll_set_consumer(rd_kafka_t *rk);</span>
<span class="s1">typedef int rd_kafka_event_type_t;</span>
<span class="s1">rd_kafka_event_type_t rd_kafka_event_type(const rd_kafka_event_t *rkev);</span>
<span class="s1">const char *rd_kafka_event_name(const rd_kafka_event_t *rkev);</span>
<span class="s1">void rd_kafka_event_destroy(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_message_t *rd_kafka_event_message_next(rd_kafka_event_t *rkev);</span>
<span class="s1">size_t rd_kafka_event_message_array(rd_kafka_event_t *rkev, const rd_kafka_message_t **rkmessages, size_t size);</span>
<span class="s1">size_t rd_kafka_event_message_count(rd_kafka_event_t *rkev);</span>
<span class="s1">const char *rd_kafka_event_config_string(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_event_error(rd_kafka_event_t *rkev);</span>
<span class="s1">const char *rd_kafka_event_error_string(rd_kafka_event_t *rkev);</span>
<span class="s1">int rd_kafka_event_error_is_fatal(rd_kafka_event_t *rkev);</span>
<span class="s1">void *rd_kafka_event_opaque(rd_kafka_event_t *rkev);</span>
<span class="s1">int rd_kafka_event_log(rd_kafka_event_t *rkev, const char **fac, const char **str, int *level);</span>
<span class="s1">const char *rd_kafka_event_stats(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_event_topic_partition_list(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_event_topic_partition(rd_kafka_event_t *rkev);</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_CreateTopics_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DeleteTopics_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_CreatePartitions_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_AlterConfigs_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DescribeConfigs_result_t;</span>
<span class="s1">const rd_kafka_CreateTopics_result_t *rd_kafka_event_CreateTopics_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DeleteTopics_result_t *rd_kafka_event_DeleteTopics_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_CreatePartitions_result_t *rd_kafka_event_CreatePartitions_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_AlterConfigs_result_t *rd_kafka_event_AlterConfigs_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DescribeConfigs_result_t *rd_kafka_event_DescribeConfigs_result(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_event_t *rd_kafka_queue_poll(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">int rd_kafka_queue_poll_callback(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_plugin_f_conf_init_t)(rd_kafka_conf_t *conf, void **plug_opaquep, char *errstr, size_t errstr_size);</span>
<span class="s1">typedef rd_kafka_conf_res_t (rd_kafka_interceptor_f_on_conf_set_t)(rd_kafka_conf_t *conf, const char *name, const char *val, char *errstr, size_t errstr_size, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_dup_t)(rd_kafka_conf_t *new_conf, const rd_kafka_conf_t *old_conf, size_t filter_cnt, const char **filter, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_destroy_t)(void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_new_t)(rd_kafka_t *rk, const rd_kafka_conf_t *conf, void *ic_opaque, char *errstr, size_t errstr_size);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_destroy_t)(rd_kafka_t *rk, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_send_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_acknowledgement_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_consume_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_commit_t)(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_resp_err_t err, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_request_sent_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_set(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_set_t *on_conf_set, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_dup(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_dup_t *on_conf_dup, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_destroy(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_destroy_t *on_conf_destroy, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_new(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_new_t *on_new, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_destroy(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_destroy_t *on_destroy, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_send(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_send_t *on_send, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_acknowledgement(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_acknowledgement_t *on_acknowledgement, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_consume(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_consume_t *on_consume, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_commit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_commit_t *on_commit, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_request_sent(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_request_sent_t *on_request_sent, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_topic_result_error(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">const char *rd_kafka_topic_result_error_string(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">const char *rd_kafka_topic_result_name(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">typedef enum rd_kafka_admin_op_t {</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_ANY = 0,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_CREATETOPICS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DELETETOPICS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_CREATEPARTITIONS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_ALTERCONFIGS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DESCRIBECONFIGS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP__CNT,</span>
<span class="s1">} rd_kafka_admin_op_t;</span>
<span class="s1">typedef struct rd_kafka_AdminOptions_s rd_kafka_AdminOptions_t;</span>
<span class="s1">rd_kafka_AdminOptions_t *rd_kafka_AdminOptions_new(rd_kafka_t *rk, rd_kafka_admin_op_t for_api);</span>
<span class="s1">void rd_kafka_AdminOptions_destroy(rd_kafka_AdminOptions_t *options);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_request_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_operation_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_validate_only(rd_kafka_AdminOptions_t *options, int true_or_false, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_broker(rd_kafka_AdminOptions_t *options, int32_t broker_id, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_AdminOptions_set_opaque(rd_kafka_AdminOptions_t *options, void *opaque);</span>
<span class="s1">typedef struct rd_kafka_NewTopic_s rd_kafka_NewTopic_t;</span>
<span class="s1">rd_kafka_NewTopic_t *rd_kafka_NewTopic_new(const char *topic, int num_partitions, int replication_factor, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_NewTopic_destroy(rd_kafka_NewTopic_t *new_topic);</span>
<span class="s1">void rd_kafka_NewTopic_destroy_array(rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewTopic_set_replica_assignment(rd_kafka_NewTopic_t *new_topic, int32_t partition, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewTopic_set_config(rd_kafka_NewTopic_t *new_topic, const char *name, const char *value);</span>
<span class="s1">void rd_kafka_CreateTopics(rd_kafka_t *rk, rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_CreateTopics_result_topics(const rd_kafka_CreateTopics_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_DeleteTopic_s rd_kafka_DeleteTopic_t;</span>
<span class="s1">rd_kafka_DeleteTopic_t *rd_kafka_DeleteTopic_new(const char *topic);</span>
<span class="s1">void rd_kafka_DeleteTopic_destroy(rd_kafka_DeleteTopic_t *del_topic);</span>
<span class="s1">void rd_kafka_DeleteTopic_destroy_array(rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt);</span>
<span class="s1">void rd_kafka_DeleteTopics(rd_kafka_t *rk, rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_DeleteTopics_result_topics(const rd_kafka_DeleteTopics_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_NewPartitions_s rd_kafka_NewPartitions_t;</span>
<span class="s1">rd_kafka_NewPartitions_t *rd_kafka_NewPartitions_new(const char *topic, size_t new_total_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_NewPartitions_destroy(rd_kafka_NewPartitions_t *new_parts);</span>
<span class="s1">void rd_kafka_NewPartitions_destroy_array(rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewPartitions_set_replica_assignment(rd_kafka_NewPartitions_t *new_parts, int32_t new_partition_idx, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_CreatePartitions(rd_kafka_t *rk, rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_CreatePartitions_result_topics(const rd_kafka_CreatePartitions_result_t *result, size_t *cntp);</span>
<span class="s1">typedef enum rd_kafka_ConfigSource_t {</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_UNKNOWN_CONFIG = 0,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_TOPIC_CONFIG = 1,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_BROKER_CONFIG = 2,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_DEFAULT_BROKER_CONFIG = 3,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_STATIC_BROKER_CONFIG = 4,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DEFAULT_CONFIG = 5,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE__CNT,</span>
<span class="s1">} rd_kafka_ConfigSource_t;</span>
<span class="s1">const char *rd_kafka_ConfigSource_name(rd_kafka_ConfigSource_t confsource);</span>
<span class="s1">typedef struct rd_kafka_ConfigEntry_s rd_kafka_ConfigEntry_t;</span>
<span class="s1">const char *rd_kafka_ConfigEntry_name(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">const char *rd_kafka_ConfigEntry_value(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">rd_kafka_ConfigSource_t rd_kafka_ConfigEntry_source(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_read_only(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_default(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_sensitive(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_synonym(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">const rd_kafka_ConfigEntry_t **rd_kafka_ConfigEntry_synonyms(const rd_kafka_ConfigEntry_t *entry, size_t *cntp);</span>
<span class="s1">typedef enum rd_kafka_ResourceType_t {</span>
<span class="s1">  RD_KAFKA_RESOURCE_UNKNOWN = 0,</span>
<span class="s1">  RD_KAFKA_RESOURCE_ANY = 1,</span>
<span class="s1">  RD_KAFKA_RESOURCE_TOPIC = 2,</span>
<span class="s1">  RD_KAFKA_RESOURCE_GROUP = 3,</span>
<span class="s1">  RD_KAFKA_RESOURCE_BROKER = 4,</span>
<span class="s1">  RD_KAFKA_RESOURCE__CNT,</span>
<span class="s1">} rd_kafka_ResourceType_t;</span>
<span class="s1">const char *rd_kafka_ResourceType_name(rd_kafka_ResourceType_t restype);</span>
<span class="s1">typedef struct rd_kafka_ConfigResource_s rd_kafka_ConfigResource_t;</span>
<span class="s1">rd_kafka_ConfigResource_t *rd_kafka_ConfigResource_new(rd_kafka_ResourceType_t restype, const char *resname);</span>
<span class="s1">void rd_kafka_ConfigResource_destroy(rd_kafka_ConfigResource_t *config);</span>
<span class="s1">void rd_kafka_ConfigResource_destroy_array(rd_kafka_ConfigResource_t **config, size_t config_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_ConfigResource_set_config(rd_kafka_ConfigResource_t *config, const char *name, const char *value);</span>
<span class="s1">const rd_kafka_ConfigEntry_t **rd_kafka_ConfigResource_configs(const rd_kafka_ConfigResource_t *config, size_t *cntp);</span>
<span class="s1">rd_kafka_ResourceType_t rd_kafka_ConfigResource_type(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">const char *rd_kafka_ConfigResource_name(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_ConfigResource_error(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">const char *rd_kafka_ConfigResource_error_string(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">void rd_kafka_AlterConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_ConfigResource_t **rd_kafka_AlterConfigs_result_resources(const rd_kafka_AlterConfigs_result_t *result, size_t *cntp);</span>
<span class="s1">void rd_kafka_DescribeConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_ConfigResource_t **rd_kafka_DescribeConfigs_result_resources(const rd_kafka_DescribeConfigs_result_t *result, size_t *cntp);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token(rd_kafka_t *rk, const char *token_value, int64_t md_lifetime_ms, const char *md_principal_name, const char **extensions, size_t extension_size, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token_failure(rd_kafka_t *rk, const char *errstr);</span>
<span class="s1">&#39;</span>
</code></pre></div>
rdkafka.h, rdkafka_mock.h</p>
<h3 id="rd_kafka_version_3">RD_KAFKA_VERSION<a class="headerlink" href="#rd_kafka_version_3" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_VERSION</span> <span class="o">=</span> <span class="mi">16908543</span>
</code></pre></div>
<p>librdkafka version </p>
<p>Interpreted as hex <code>MM.mm.rr.xx</code>:</p>
<ul>
<li>MM = Major</li>
<li>mm = minor</li>
<li>rr = revision</li>
<li>xx = pre-release id (0xff is the final release)</li>
</ul>
<p>E.g.: <code>0x000801ff</code> = 0.8.1</p>
<dl class="section remark"><dt>Remarks</dt><dd>This value should only be used during compile time, for runtime checks of version use rd_kafka_version() </dd></dl>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_unsupported_compression_type_3">RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE<a class="headerlink" href="#rd_kafka_resp_err_unsupported_compression_type_3" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE</span> <span class="o">=</span> <span class="mi">76</span>
</code></pre></div>
<p>Unsupported compression type </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_end_all_3">RD_KAFKA_RESP_ERR_END_ALL<a class="headerlink" href="#rd_kafka_resp_err_end_all_3" title="Permanent link">&para;</a></h3>
<p><div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_END_ALL</span> <span class="o">=</span> <span class="mi">82</span>
</code></pre></div>
enum rd_kafka_resp_err_t</p>
<h3 id="rd_kafka_admin_op__cnt_3">RD_KAFKA_ADMIN_OP__CNT<a class="headerlink" href="#rd_kafka_admin_op__cnt_3" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_ADMIN_OP__CNT</span> <span class="o">=</span> <span class="mi">6</span>
</code></pre></div>
<p>Number of ops defined </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe </a></li>
</ul>
</div>
<h3 id="rd_kafka_resource__cnt_3">RD_KAFKA_RESOURCE__CNT<a class="headerlink" href="#rd_kafka_resource__cnt_3" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESOURCE__CNT</span> <span class="o">=</span> <span class="mi">5</span>
</code></pre></div>
<p>Number of resource types defined </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#acca83a66d7783ff7683ed2691cc907c9"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#acca83a66d7783ff7683ed2691cc907c9 </a></li>
</ul>
</div>
<h3 id="rd_kafka_cdef_3">RD_KAFKA_CDEF<a class="headerlink" href="#rd_kafka_cdef_3" title="Permanent link">&para;</a></h3>
<p><div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_CDEF</span> <span class="o">=</span> <span class="s1">&#39;typedef long int ssize_t;</span>
<span class="s1">typedef struct _IO_FILE FILE;</span>
<span class="s1">typedef long int mode_t;</span>
<span class="s1">typedef signed int int16_t;</span>
<span class="s1">typedef unsigned int uint16_t;</span>
<span class="s1">typedef signed int int32_t;</span>
<span class="s1">typedef signed long int int64_t;</span>
<span class="s1">int rd_kafka_version(void);</span>
<span class="s1">const char *rd_kafka_version_str(void);</span>
<span class="s1">typedef enum rd_kafka_type_t {</span>
<span class="s1">  RD_KAFKA_PRODUCER,</span>
<span class="s1">  RD_KAFKA_CONSUMER,</span>
<span class="s1">} rd_kafka_type_t;</span>
<span class="s1">typedef enum rd_kafka_timestamp_type_t {</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_NOT_AVAILABLE,</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_CREATE_TIME,</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_LOG_APPEND_TIME,</span>
<span class="s1">} rd_kafka_timestamp_type_t;</span>
<span class="s1">const char *rd_kafka_get_debug_contexts(void);</span>
<span class="s1">typedef struct rd_kafka_s rd_kafka_t;</span>
<span class="s1">typedef struct rd_kafka_topic_s rd_kafka_topic_t;</span>
<span class="s1">typedef struct rd_kafka_conf_s rd_kafka_conf_t;</span>
<span class="s1">typedef struct rd_kafka_topic_conf_s rd_kafka_topic_conf_t;</span>
<span class="s1">typedef struct rd_kafka_queue_s rd_kafka_queue_t;</span>
<span class="s1">typedef struct rd_kafka_op_s rd_kafka_event_t;</span>
<span class="s1">typedef struct rd_kafka_topic_result_s rd_kafka_topic_result_t;</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BEGIN = (- 200),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BAD_MSG = (- 199),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BAD_COMPRESSION = (- 198),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__DESTROY = (- 197),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FAIL = (- 196),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TRANSPORT = (- 195),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__CRIT_SYS_RESOURCE = (- 194),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__RESOLVE = (- 193),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__MSG_TIMED_OUT = (- 192),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PARTITION_EOF = (- 191),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION = (- 190),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FS = (- 189),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC = (- 188),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ALL_BROKERS_DOWN = (- 187),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INVALID_ARG = (- 186),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TIMED_OUT = (- 185),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__QUEUE_FULL = (- 184),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ISR_INSUFF = (- 183),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NODE_UPDATE = (- 182),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__SSL = (- 181),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__WAIT_COORD = (- 180),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_GROUP = (- 179),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__IN_PROGRESS = (- 178),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PREV_IN_PROGRESS = (- 177),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__EXISTING_SUBSCRIPTION = (- 176),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS = (- 175),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS = (- 174),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__CONFLICT = (- 173),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__STATE = (- 172),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_PROTOCOL = (- 171),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED = (- 170),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__AUTHENTICATION = (- 169),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NO_OFFSET = (- 168),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__OUTDATED = (- 167),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TIMED_OUT_QUEUE = (- 166),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNSUPPORTED_FEATURE = (- 165),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__WAIT_CACHE = (- 164),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INTR = (- 163),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__KEY_SERIALIZATION = (- 162),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__VALUE_SERIALIZATION = (- 161),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__KEY_DESERIALIZATION = (- 160),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__VALUE_DESERIALIZATION = (- 159),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PARTIAL = (- 158),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__READ_ONLY = (- 157),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOENT = (- 156),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNDERFLOW = (- 155),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INVALID_TYPE = (- 154),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__RETRY = (- 153),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PURGE_QUEUE = (- 152),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PURGE_INFLIGHT = (- 151),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FATAL = (- 150),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INCONSISTENT = (- 149),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__GAPLESS_GUARANTEE = (- 148),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__MAX_POLL_EXCEEDED = (- 147),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__END = (- 100),</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN = (- 1),</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NO_ERROR = 0,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_OUT_OF_RANGE = 1,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_MSG = 2,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART = 3,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_MSG_SIZE = 4,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE = 5,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_LEADER_FOR_PARTITION = 6,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REQUEST_TIMED_OUT = 7,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_BROKER_NOT_AVAILABLE = 8,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REPLICA_NOT_AVAILABLE = 9,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE = 10,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_STALE_CTRL_EPOCH = 11,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_METADATA_TOO_LARGE = 12,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NETWORK_EXCEPTION = 13,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_LOAD_IN_PROGRESS = 14,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_COORDINATOR_NOT_AVAILABLE = 15,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_COORDINATOR_FOR_GROUP = 16,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_EXCEPTION = 17,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_RECORD_LIST_TOO_LARGE = 18,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS = 19,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS_AFTER_APPEND = 20,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REQUIRED_ACKS = 21,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ILLEGAL_GENERATION = 22,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INCONSISTENT_GROUP_PROTOCOL = 23,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_GROUP_ID = 24,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_MEMBER_ID = 25,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_SESSION_TIMEOUT = 26,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REBALANCE_IN_PROGRESS = 27,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_COMMIT_OFFSET_SIZE = 28,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_AUTHORIZATION_FAILED = 29,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_AUTHORIZATION_FAILED = 30,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_CLUSTER_AUTHORIZATION_FAILED = 31,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TIMESTAMP = 32,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_SASL_MECHANISM = 33,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ILLEGAL_SASL_STATE = 34,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_VERSION = 35,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_ALREADY_EXISTS = 36,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PARTITIONS = 37,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REPLICATION_FACTOR = 38,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REPLICA_ASSIGNMENT = 39,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_CONFIG = 40,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_CONTROLLER = 41,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REQUEST = 42,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_FOR_MESSAGE_FORMAT = 43,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_POLICY_VIOLATION = 44,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OUT_OF_ORDER_SEQUENCE_NUMBER = 45,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DUPLICATE_SEQUENCE_NUMBER = 46,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_EPOCH = 47,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TXN_STATE = 48,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_ID_MAPPING = 49,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TRANSACTION_TIMEOUT = 50,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_CONCURRENT_TRANSACTIONS = 51,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TRANSACTION_COORDINATOR_FENCED = 52,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TRANSACTIONAL_ID_AUTHORIZATION_FAILED = 53,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_SECURITY_DISABLED = 54,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OPERATION_NOT_ATTEMPTED = 55,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_KAFKA_STORAGE_ERROR = 56,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LOG_DIR_NOT_FOUND = 57,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_SASL_AUTHENTICATION_FAILED = 58,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_PRODUCER_ID = 59,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REASSIGNMENT_IN_PROGRESS = 60,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTH_DISABLED = 61,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_NOT_FOUND = 62,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_OWNER_MISMATCH = 63,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_REQUEST_NOT_ALLOWED = 64,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTHORIZATION_FAILED = 65,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_EXPIRED = 66,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRINCIPAL_TYPE = 67,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NON_EMPTY_GROUP = 68,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_ID_NOT_FOUND = 69,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FETCH_SESSION_ID_NOT_FOUND = 70,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_FETCH_SESSION_EPOCH = 71,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LISTENER_NOT_FOUND = 72,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_DELETION_DISABLED = 73,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FENCED_LEADER_EPOCH = 74,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_LEADER_EPOCH = 75,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_STALE_BROKER_EPOCH = 77,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_NOT_AVAILABLE = 78,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_MEMBER_ID_REQUIRED = 79,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_PREFERRED_LEADER_NOT_AVAILABLE = 80,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_MAX_SIZE_REACHED = 81,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_END_ALL,</span>
<span class="s1">} rd_kafka_resp_err_t;</span>
<span class="s1">struct rd_kafka_err_desc {</span>
<span class="s1">  rd_kafka_resp_err_t code;</span>
<span class="s1">  char *name;</span>
<span class="s1">  char *desc;</span>
<span class="s1">};</span>
<span class="s1">void rd_kafka_get_err_descs(const struct rd_kafka_err_desc **errdescs, size_t *cntp);</span>
<span class="s1">const char *rd_kafka_err2str(rd_kafka_resp_err_t err);</span>
<span class="s1">const char *rd_kafka_err2name(rd_kafka_resp_err_t err);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_last_error(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_errno2err(int errnox);</span>
<span class="s1">int rd_kafka_errno(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_fatal_error(rd_kafka_t *rk, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_test_fatal_error(rd_kafka_t *rk, rd_kafka_resp_err_t err, const char *reason);</span>
<span class="s1">typedef struct rd_kafka_topic_partition_s {</span>
<span class="s1">  char *topic;</span>
<span class="s1">  int32_t partition;</span>
<span class="s1">  int64_t offset;</span>
<span class="s1">  void *metadata;</span>
<span class="s1">  size_t metadata_size;</span>
<span class="s1">  void *opaque;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  void *_private;</span>
<span class="s1">} rd_kafka_topic_partition_t;</span>
<span class="s1">void rd_kafka_topic_partition_destroy(rd_kafka_topic_partition_t *rktpar);</span>
<span class="s1">typedef struct rd_kafka_topic_partition_list_s {</span>
<span class="s1">  int cnt;</span>
<span class="s1">  int size;</span>
<span class="s1">  rd_kafka_topic_partition_t *elems;</span>
<span class="s1">} rd_kafka_topic_partition_list_t;</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_new(int size);</span>
<span class="s1">void rd_kafka_topic_partition_list_destroy(rd_kafka_topic_partition_list_t *rkparlist);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_add(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">void rd_kafka_topic_partition_list_add_range(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t start, int32_t stop);</span>
<span class="s1">int rd_kafka_topic_partition_list_del(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">int rd_kafka_topic_partition_list_del_by_idx(rd_kafka_topic_partition_list_t *rktparlist, int idx);</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_copy(const rd_kafka_topic_partition_list_t *src);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_topic_partition_list_set_offset(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition, int64_t offset);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_find(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">void rd_kafka_topic_partition_list_sort(rd_kafka_topic_partition_list_t *rktparlist, int (*cmp)(const void *a, const void *b, void *cmp_opaque), void *cmp_opaque);</span>
<span class="s1">typedef enum rd_kafka_vtype_t {</span>
<span class="s1">  RD_KAFKA_VTYPE_END,</span>
<span class="s1">  RD_KAFKA_VTYPE_TOPIC,</span>
<span class="s1">  RD_KAFKA_VTYPE_RKT,</span>
<span class="s1">  RD_KAFKA_VTYPE_PARTITION,</span>
<span class="s1">  RD_KAFKA_VTYPE_VALUE,</span>
<span class="s1">  RD_KAFKA_VTYPE_KEY,</span>
<span class="s1">  RD_KAFKA_VTYPE_OPAQUE,</span>
<span class="s1">  RD_KAFKA_VTYPE_MSGFLAGS,</span>
<span class="s1">  RD_KAFKA_VTYPE_TIMESTAMP,</span>
<span class="s1">  RD_KAFKA_VTYPE_HEADER,</span>
<span class="s1">  RD_KAFKA_VTYPE_HEADERS,</span>
<span class="s1">} rd_kafka_vtype_t;</span>
<span class="s1">typedef struct rd_kafka_headers_s rd_kafka_headers_t;</span>
<span class="s1">rd_kafka_headers_t *rd_kafka_headers_new(size_t initial_count);</span>
<span class="s1">void rd_kafka_headers_destroy(rd_kafka_headers_t *hdrs);</span>
<span class="s1">rd_kafka_headers_t *rd_kafka_headers_copy(const rd_kafka_headers_t *src);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_add(rd_kafka_headers_t *hdrs, const char *name, ssize_t name_size, const void *value, ssize_t value_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_remove(rd_kafka_headers_t *hdrs, const char *name);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get_last(const rd_kafka_headers_t *hdrs, const char *name, const void **valuep, size_t *sizep);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get(const rd_kafka_headers_t *hdrs, size_t idx, const char *name, const void **valuep, size_t *sizep);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get_all(const rd_kafka_headers_t *hdrs, size_t idx, const char **namep, const void **valuep, size_t *sizep);</span>
<span class="s1">typedef struct rd_kafka_message_s {</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  rd_kafka_topic_t *rkt;</span>
<span class="s1">  int32_t partition;</span>
<span class="s1">  void *payload;</span>
<span class="s1">  size_t len;</span>
<span class="s1">  void *key;</span>
<span class="s1">  size_t key_len;</span>
<span class="s1">  int64_t offset;</span>
<span class="s1">  void *_private;</span>
<span class="s1">} rd_kafka_message_t;</span>
<span class="s1">void rd_kafka_message_destroy(rd_kafka_message_t *rkmessage);</span>
<span class="s1">int64_t rd_kafka_message_timestamp(const rd_kafka_message_t *rkmessage, rd_kafka_timestamp_type_t *tstype);</span>
<span class="s1">int64_t rd_kafka_message_latency(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_message_headers(const rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_message_detach_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);</span>
<span class="s1">void rd_kafka_message_set_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t *hdrs);</span>
<span class="s1">size_t rd_kafka_header_cnt(const rd_kafka_headers_t *hdrs);</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_NOT_PERSISTED = 0,</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_POSSIBLY_PERSISTED = 1,</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_PERSISTED = 2,</span>
<span class="s1">} rd_kafka_msg_status_t;</span>
<span class="s1">rd_kafka_msg_status_t rd_kafka_message_status(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_CONF_UNKNOWN = (- 2),</span>
<span class="s1">  RD_KAFKA_CONF_INVALID = (- 1),</span>
<span class="s1">  RD_KAFKA_CONF_OK = 0,</span>
<span class="s1">} rd_kafka_conf_res_t;</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_new(void);</span>
<span class="s1">void rd_kafka_conf_destroy(rd_kafka_conf_t *conf);</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_dup(const rd_kafka_conf_t *conf);</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_dup_filter(const rd_kafka_conf_t *conf, size_t filter_cnt, const char **filter);</span>
<span class="s1">const rd_kafka_conf_t *rd_kafka_conf(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_set(rd_kafka_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_conf_set_events(rd_kafka_conf_t *conf, int events);</span>
<span class="s1">void rd_kafka_conf_set_background_event_cb(rd_kafka_conf_t *conf, void (*event_cb)(rd_kafka_t *rk, rd_kafka_event_t *rkev, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_dr_cb(rd_kafka_conf_t *conf, void (*dr_cb)(rd_kafka_t *rk, void *payload, size_t len, rd_kafka_resp_err_t err, void *opaque, void *msg_opaque));</span>
<span class="s1">void rd_kafka_conf_set_dr_msg_cb(rd_kafka_conf_t *conf, void (*dr_msg_cb)(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_consume_cb(rd_kafka_conf_t *conf, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_rebalance_cb(rd_kafka_conf_t *conf, void (*rebalance_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *partitions, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_offset_commit_cb(rd_kafka_conf_t *conf, void (*offset_commit_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_error_cb(rd_kafka_conf_t *conf, void (*error_cb)(rd_kafka_t *rk, int err, const char *reason, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_throttle_cb(rd_kafka_conf_t *conf, void (*throttle_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int throttle_time_ms, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_log_cb(rd_kafka_conf_t *conf, void (*log_cb)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));</span>
<span class="s1">void rd_kafka_conf_set_stats_cb(rd_kafka_conf_t *conf, int (*stats_cb)(rd_kafka_t *rk, char *json, size_t json_len, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_oauthbearer_token_refresh_cb(rd_kafka_conf_t *conf, void (*oauthbearer_token_refresh_cb)(rd_kafka_t *rk, const char *oauthbearer_config, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_socket_cb(rd_kafka_conf_t *conf, int (*socket_cb)(int domain, int type, int protocol, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_connect_cb(rd_kafka_conf_t *conf, int (*connect_cb)(int sockfd, const struct sockaddr *addr, int addrlen, const char *id, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_closesocket_cb(rd_kafka_conf_t *conf, int (*closesocket_cb)(int sockfd, void *opaque));</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert_verify_cb(rd_kafka_conf_t *conf, int (*ssl_cert_verify_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int *x509_error, int depth, const char *buf, size_t size, char *errstr, size_t errstr_size, void *opaque));</span>
<span class="s1">typedef enum rd_kafka_cert_type_t {</span>
<span class="s1">  RD_KAFKA_CERT_PUBLIC_KEY,</span>
<span class="s1">  RD_KAFKA_CERT_PRIVATE_KEY,</span>
<span class="s1">  RD_KAFKA_CERT_CA,</span>
<span class="s1">  RD_KAFKA_CERT__CNT,</span>
<span class="s1">} rd_kafka_cert_type_t;</span>
<span class="s1">typedef enum rd_kafka_cert_enc_t {</span>
<span class="s1">  RD_KAFKA_CERT_ENC_PKCS12,</span>
<span class="s1">  RD_KAFKA_CERT_ENC_DER,</span>
<span class="s1">  RD_KAFKA_CERT_ENC_PEM,</span>
<span class="s1">  RD_KAFKA_CERT_ENC__CNT,</span>
<span class="s1">} rd_kafka_cert_enc_t;</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert(rd_kafka_conf_t *conf, rd_kafka_cert_type_t cert_type, rd_kafka_cert_enc_t cert_enc, const void *buffer, size_t size, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_conf_set_opaque(rd_kafka_conf_t *conf, void *opaque);</span>
<span class="s1">void *rd_kafka_opaque(const rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_conf_set_default_topic_conf(rd_kafka_conf_t *conf, rd_kafka_topic_conf_t *tconf);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_get(const rd_kafka_conf_t *conf, const char *name, char *dest, size_t *dest_size);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_topic_conf_get(const rd_kafka_topic_conf_t *conf, const char *name, char *dest, size_t *dest_size);</span>
<span class="s1">const char **rd_kafka_conf_dump(rd_kafka_conf_t *conf, size_t *cntp);</span>
<span class="s1">const char **rd_kafka_topic_conf_dump(rd_kafka_topic_conf_t *conf, size_t *cntp);</span>
<span class="s1">void rd_kafka_conf_dump_free(const char **arr, size_t cnt);</span>
<span class="s1">void rd_kafka_conf_properties_show(FILE *fp);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_topic_conf_new(void);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_topic_conf_dup(const rd_kafka_topic_conf_t *conf);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_default_topic_conf_dup(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_topic_conf_destroy(rd_kafka_topic_conf_t *topic_conf);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_topic_conf_set(rd_kafka_topic_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_topic_conf_set_opaque(rd_kafka_topic_conf_t *conf, void *rkt_opaque);</span>
<span class="s1">void rd_kafka_topic_conf_set_partitioner_cb(rd_kafka_topic_conf_t *topic_conf, int32_t (*partitioner)(const rd_kafka_topic_t *rkt, const void *keydata, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque));</span>
<span class="s1">void rd_kafka_topic_conf_set_msg_order_cmp(rd_kafka_topic_conf_t *topic_conf, int (*msg_order_cmp)(const rd_kafka_message_t *a, const rd_kafka_message_t *b));</span>
<span class="s1">int rd_kafka_topic_partition_available(const rd_kafka_topic_t *rkt, int32_t partition);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_consistent(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_consistent_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_murmur2(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_murmur2_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">rd_kafka_t *rd_kafka_new(rd_kafka_type_t type, rd_kafka_conf_t *conf, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_destroy(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_destroy_flags(rd_kafka_t *rk, int flags);</span>
<span class="s1">const char *rd_kafka_name(const rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_type_t rd_kafka_type(const rd_kafka_t *rk);</span>
<span class="s1">char *rd_kafka_memberid(const rd_kafka_t *rk);</span>
<span class="s1">char *rd_kafka_clusterid(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">int32_t rd_kafka_controllerid(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_topic_t *rd_kafka_topic_new(rd_kafka_t *rk, const char *topic, rd_kafka_topic_conf_t *conf);</span>
<span class="s1">void rd_kafka_topic_destroy(rd_kafka_topic_t *rkt);</span>
<span class="s1">const char *rd_kafka_topic_name(const rd_kafka_topic_t *rkt);</span>
<span class="s1">void *rd_kafka_topic_opaque(const rd_kafka_topic_t *rkt);</span>
<span class="s1">int rd_kafka_poll(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">void rd_kafka_yield(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_pause_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_resume_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_query_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_get_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offsets_for_times(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets, int timeout_ms);</span>
<span class="s1">void rd_kafka_mem_free(rd_kafka_t *rk, void *ptr);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_new(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_queue_destroy(rd_kafka_queue_t *rkqu);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_main(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_consumer(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_partition(rd_kafka_t *rk, const char *topic, int32_t partition);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_background(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_queue_forward(rd_kafka_queue_t *src, rd_kafka_queue_t *dst);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_set_log_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu);</span>
<span class="s1">size_t rd_kafka_queue_length(rd_kafka_queue_t *rkqu);</span>
<span class="s1">void rd_kafka_queue_io_event_enable(rd_kafka_queue_t *rkqu, int fd, const void *payload, size_t size);</span>
<span class="s1">void rd_kafka_queue_cb_event_enable(rd_kafka_queue_t *rkqu, void (*event_cb)(rd_kafka_t *rk, void *qev_opaque), void *qev_opaque);</span>
<span class="s1">int rd_kafka_consume_start(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);</span>
<span class="s1">int rd_kafka_consume_start_queue(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, rd_kafka_queue_t *rkqu);</span>
<span class="s1">int rd_kafka_consume_stop(rd_kafka_topic_t *rkt, int32_t partition);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_seek(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, int timeout_ms);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consume(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms);</span>
<span class="s1">ssize_t rd_kafka_consume_batch(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);</span>
<span class="s1">int rd_kafka_consume_callback(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consume_queue(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">ssize_t rd_kafka_consume_batch_queue(rd_kafka_queue_t *rkqu, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);</span>
<span class="s1">int rd_kafka_consume_callback_queue(rd_kafka_queue_t *rkqu, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offset_store(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offsets_store(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_subscribe(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *topics);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_unsubscribe(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_subscription(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **topics);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consumer_poll(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_consumer_close(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_assignment(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, int async);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit_message(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, int async);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit_queue(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_queue_t *rkqu, void (*cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *commit_opaque), void *commit_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_committed(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_position(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">int rd_kafka_produce(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, void *payload, size_t len, const void *key, size_t keylen, void *msg_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_producev(rd_kafka_t *rk, ...);</span>
<span class="s1">int rd_kafka_produce_batch(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, rd_kafka_message_t *rkmessages, int message_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_flush(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_purge(rd_kafka_t *rk, int purge_flags);</span>
<span class="s1">typedef struct rd_kafka_metadata_broker {</span>
<span class="s1">  int32_t id;</span>
<span class="s1">  char *host;</span>
<span class="s1">  int port;</span>
<span class="s1">} rd_kafka_metadata_broker_t;</span>
<span class="s1">typedef struct rd_kafka_metadata_partition {</span>
<span class="s1">  int32_t id;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  int32_t leader;</span>
<span class="s1">  int replica_cnt;</span>
<span class="s1">  int32_t *replicas;</span>
<span class="s1">  int isr_cnt;</span>
<span class="s1">  int32_t *isrs;</span>
<span class="s1">} rd_kafka_metadata_partition_t;</span>
<span class="s1">typedef struct rd_kafka_metadata_topic {</span>
<span class="s1">  char *topic;</span>
<span class="s1">  int partition_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_partition *partitions;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">} rd_kafka_metadata_topic_t;</span>
<span class="s1">typedef struct rd_kafka_metadata {</span>
<span class="s1">  int broker_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_broker *brokers;</span>
<span class="s1">  int topic_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_topic *topics;</span>
<span class="s1">  int32_t orig_broker_id;</span>
<span class="s1">  char *orig_broker_name;</span>
<span class="s1">} rd_kafka_metadata_t;</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_metadata(rd_kafka_t *rk, int all_topics, rd_kafka_topic_t *only_rkt, const struct rd_kafka_metadata **metadatap, int timeout_ms);</span>
<span class="s1">void rd_kafka_metadata_destroy(const struct rd_kafka_metadata *metadata);</span>
<span class="s1">struct rd_kafka_group_member_info {</span>
<span class="s1">  char *member_id;</span>
<span class="s1">  char *client_id;</span>
<span class="s1">  char *client_host;</span>
<span class="s1">  void *member_metadata;</span>
<span class="s1">  int member_metadata_size;</span>
<span class="s1">  void *member_assignment;</span>
<span class="s1">  int member_assignment_size;</span>
<span class="s1">};</span>
<span class="s1">struct rd_kafka_group_info {</span>
<span class="s1">  struct rd_kafka_metadata_broker broker;</span>
<span class="s1">  char *group;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  char *state;</span>
<span class="s1">  char *protocol_type;</span>
<span class="s1">  char *protocol;</span>
<span class="s1">  struct rd_kafka_group_member_info *members;</span>
<span class="s1">  int member_cnt;</span>
<span class="s1">};</span>
<span class="s1">struct rd_kafka_group_list {</span>
<span class="s1">  struct rd_kafka_group_info *groups;</span>
<span class="s1">  int group_cnt;</span>
<span class="s1">};</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_list_groups(rd_kafka_t *rk, const char *group, const struct rd_kafka_group_list **grplistp, int timeout_ms);</span>
<span class="s1">void rd_kafka_group_list_destroy(const struct rd_kafka_group_list *grplist);</span>
<span class="s1">int rd_kafka_brokers_add(rd_kafka_t *rk, const char *brokerlist);</span>
<span class="s1">void rd_kafka_set_logger(rd_kafka_t *rk, void (*func)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));</span>
<span class="s1">void rd_kafka_set_log_level(rd_kafka_t *rk, int level);</span>
<span class="s1">void rd_kafka_log_print(const rd_kafka_t *rk, int level, const char *fac, const char *buf);</span>
<span class="s1">void rd_kafka_log_syslog(const rd_kafka_t *rk, int level, const char *fac, const char *buf);</span>
<span class="s1">int rd_kafka_outq_len(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_dump(FILE *fp, rd_kafka_t *rk);</span>
<span class="s1">int rd_kafka_thread_cnt(void);</span>
<span class="s1">typedef enum rd_kafka_thread_type_t {</span>
<span class="s1">  RD_KAFKA_THREAD_MAIN,</span>
<span class="s1">  RD_KAFKA_THREAD_BACKGROUND,</span>
<span class="s1">  RD_KAFKA_THREAD_BROKER,</span>
<span class="s1">} rd_kafka_thread_type_t;</span>
<span class="s1">int rd_kafka_wait_destroyed(int timeout_ms);</span>
<span class="s1">int rd_kafka_unittest(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_poll_set_consumer(rd_kafka_t *rk);</span>
<span class="s1">typedef int rd_kafka_event_type_t;</span>
<span class="s1">rd_kafka_event_type_t rd_kafka_event_type(const rd_kafka_event_t *rkev);</span>
<span class="s1">const char *rd_kafka_event_name(const rd_kafka_event_t *rkev);</span>
<span class="s1">void rd_kafka_event_destroy(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_message_t *rd_kafka_event_message_next(rd_kafka_event_t *rkev);</span>
<span class="s1">size_t rd_kafka_event_message_array(rd_kafka_event_t *rkev, const rd_kafka_message_t **rkmessages, size_t size);</span>
<span class="s1">size_t rd_kafka_event_message_count(rd_kafka_event_t *rkev);</span>
<span class="s1">const char *rd_kafka_event_config_string(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_event_error(rd_kafka_event_t *rkev);</span>
<span class="s1">const char *rd_kafka_event_error_string(rd_kafka_event_t *rkev);</span>
<span class="s1">int rd_kafka_event_error_is_fatal(rd_kafka_event_t *rkev);</span>
<span class="s1">void *rd_kafka_event_opaque(rd_kafka_event_t *rkev);</span>
<span class="s1">int rd_kafka_event_log(rd_kafka_event_t *rkev, const char **fac, const char **str, int *level);</span>
<span class="s1">const char *rd_kafka_event_stats(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_event_topic_partition_list(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_event_topic_partition(rd_kafka_event_t *rkev);</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_CreateTopics_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DeleteTopics_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_CreatePartitions_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_AlterConfigs_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DescribeConfigs_result_t;</span>
<span class="s1">const rd_kafka_CreateTopics_result_t *rd_kafka_event_CreateTopics_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DeleteTopics_result_t *rd_kafka_event_DeleteTopics_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_CreatePartitions_result_t *rd_kafka_event_CreatePartitions_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_AlterConfigs_result_t *rd_kafka_event_AlterConfigs_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DescribeConfigs_result_t *rd_kafka_event_DescribeConfigs_result(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_event_t *rd_kafka_queue_poll(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">int rd_kafka_queue_poll_callback(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_plugin_f_conf_init_t)(rd_kafka_conf_t *conf, void **plug_opaquep, char *errstr, size_t errstr_size);</span>
<span class="s1">typedef rd_kafka_conf_res_t (rd_kafka_interceptor_f_on_conf_set_t)(rd_kafka_conf_t *conf, const char *name, const char *val, char *errstr, size_t errstr_size, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_dup_t)(rd_kafka_conf_t *new_conf, const rd_kafka_conf_t *old_conf, size_t filter_cnt, const char **filter, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_destroy_t)(void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_new_t)(rd_kafka_t *rk, const rd_kafka_conf_t *conf, void *ic_opaque, char *errstr, size_t errstr_size);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_destroy_t)(rd_kafka_t *rk, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_send_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_acknowledgement_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_consume_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_commit_t)(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_resp_err_t err, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_request_sent_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_start_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_exit_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_set(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_set_t *on_conf_set, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_dup(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_dup_t *on_conf_dup, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_destroy(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_destroy_t *on_conf_destroy, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_new(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_new_t *on_new, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_destroy(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_destroy_t *on_destroy, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_send(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_send_t *on_send, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_acknowledgement(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_acknowledgement_t *on_acknowledgement, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_consume(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_consume_t *on_consume, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_commit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_commit_t *on_commit, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_request_sent(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_request_sent_t *on_request_sent, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_start(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_start_t *on_thread_start, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_exit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_exit_t *on_thread_exit, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_topic_result_error(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">const char *rd_kafka_topic_result_error_string(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">const char *rd_kafka_topic_result_name(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">typedef enum rd_kafka_admin_op_t {</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_ANY = 0,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_CREATETOPICS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DELETETOPICS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_CREATEPARTITIONS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_ALTERCONFIGS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DESCRIBECONFIGS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP__CNT,</span>
<span class="s1">} rd_kafka_admin_op_t;</span>
<span class="s1">typedef struct rd_kafka_AdminOptions_s rd_kafka_AdminOptions_t;</span>
<span class="s1">rd_kafka_AdminOptions_t *rd_kafka_AdminOptions_new(rd_kafka_t *rk, rd_kafka_admin_op_t for_api);</span>
<span class="s1">void rd_kafka_AdminOptions_destroy(rd_kafka_AdminOptions_t *options);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_request_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_operation_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_validate_only(rd_kafka_AdminOptions_t *options, int true_or_false, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_broker(rd_kafka_AdminOptions_t *options, int32_t broker_id, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_AdminOptions_set_opaque(rd_kafka_AdminOptions_t *options, void *ev_opaque);</span>
<span class="s1">typedef struct rd_kafka_NewTopic_s rd_kafka_NewTopic_t;</span>
<span class="s1">rd_kafka_NewTopic_t *rd_kafka_NewTopic_new(const char *topic, int num_partitions, int replication_factor, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_NewTopic_destroy(rd_kafka_NewTopic_t *new_topic);</span>
<span class="s1">void rd_kafka_NewTopic_destroy_array(rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewTopic_set_replica_assignment(rd_kafka_NewTopic_t *new_topic, int32_t partition, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewTopic_set_config(rd_kafka_NewTopic_t *new_topic, const char *name, const char *value);</span>
<span class="s1">void rd_kafka_CreateTopics(rd_kafka_t *rk, rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_CreateTopics_result_topics(const rd_kafka_CreateTopics_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_DeleteTopic_s rd_kafka_DeleteTopic_t;</span>
<span class="s1">rd_kafka_DeleteTopic_t *rd_kafka_DeleteTopic_new(const char *topic);</span>
<span class="s1">void rd_kafka_DeleteTopic_destroy(rd_kafka_DeleteTopic_t *del_topic);</span>
<span class="s1">void rd_kafka_DeleteTopic_destroy_array(rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt);</span>
<span class="s1">void rd_kafka_DeleteTopics(rd_kafka_t *rk, rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_DeleteTopics_result_topics(const rd_kafka_DeleteTopics_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_NewPartitions_s rd_kafka_NewPartitions_t;</span>
<span class="s1">rd_kafka_NewPartitions_t *rd_kafka_NewPartitions_new(const char *topic, size_t new_total_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_NewPartitions_destroy(rd_kafka_NewPartitions_t *new_parts);</span>
<span class="s1">void rd_kafka_NewPartitions_destroy_array(rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewPartitions_set_replica_assignment(rd_kafka_NewPartitions_t *new_parts, int32_t new_partition_idx, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_CreatePartitions(rd_kafka_t *rk, rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_CreatePartitions_result_topics(const rd_kafka_CreatePartitions_result_t *result, size_t *cntp);</span>
<span class="s1">typedef enum rd_kafka_ConfigSource_t {</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_UNKNOWN_CONFIG = 0,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_TOPIC_CONFIG = 1,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_BROKER_CONFIG = 2,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_DEFAULT_BROKER_CONFIG = 3,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_STATIC_BROKER_CONFIG = 4,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DEFAULT_CONFIG = 5,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE__CNT,</span>
<span class="s1">} rd_kafka_ConfigSource_t;</span>
<span class="s1">const char *rd_kafka_ConfigSource_name(rd_kafka_ConfigSource_t confsource);</span>
<span class="s1">typedef struct rd_kafka_ConfigEntry_s rd_kafka_ConfigEntry_t;</span>
<span class="s1">const char *rd_kafka_ConfigEntry_name(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">const char *rd_kafka_ConfigEntry_value(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">rd_kafka_ConfigSource_t rd_kafka_ConfigEntry_source(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_read_only(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_default(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_sensitive(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_synonym(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">const rd_kafka_ConfigEntry_t **rd_kafka_ConfigEntry_synonyms(const rd_kafka_ConfigEntry_t *entry, size_t *cntp);</span>
<span class="s1">typedef enum rd_kafka_ResourceType_t {</span>
<span class="s1">  RD_KAFKA_RESOURCE_UNKNOWN = 0,</span>
<span class="s1">  RD_KAFKA_RESOURCE_ANY = 1,</span>
<span class="s1">  RD_KAFKA_RESOURCE_TOPIC = 2,</span>
<span class="s1">  RD_KAFKA_RESOURCE_GROUP = 3,</span>
<span class="s1">  RD_KAFKA_RESOURCE_BROKER = 4,</span>
<span class="s1">  RD_KAFKA_RESOURCE__CNT,</span>
<span class="s1">} rd_kafka_ResourceType_t;</span>
<span class="s1">const char *rd_kafka_ResourceType_name(rd_kafka_ResourceType_t restype);</span>
<span class="s1">typedef struct rd_kafka_ConfigResource_s rd_kafka_ConfigResource_t;</span>
<span class="s1">rd_kafka_ConfigResource_t *rd_kafka_ConfigResource_new(rd_kafka_ResourceType_t restype, const char *resname);</span>
<span class="s1">void rd_kafka_ConfigResource_destroy(rd_kafka_ConfigResource_t *config);</span>
<span class="s1">void rd_kafka_ConfigResource_destroy_array(rd_kafka_ConfigResource_t **config, size_t config_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_ConfigResource_set_config(rd_kafka_ConfigResource_t *config, const char *name, const char *value);</span>
<span class="s1">const rd_kafka_ConfigEntry_t **rd_kafka_ConfigResource_configs(const rd_kafka_ConfigResource_t *config, size_t *cntp);</span>
<span class="s1">rd_kafka_ResourceType_t rd_kafka_ConfigResource_type(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">const char *rd_kafka_ConfigResource_name(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_ConfigResource_error(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">const char *rd_kafka_ConfigResource_error_string(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">void rd_kafka_AlterConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_ConfigResource_t **rd_kafka_AlterConfigs_result_resources(const rd_kafka_AlterConfigs_result_t *result, size_t *cntp);</span>
<span class="s1">void rd_kafka_DescribeConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_ConfigResource_t **rd_kafka_DescribeConfigs_result_resources(const rd_kafka_DescribeConfigs_result_t *result, size_t *cntp);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token(rd_kafka_t *rk, const char *token_value, int64_t md_lifetime_ms, const char *md_principal_name, const char **extensions, size_t extension_size, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token_failure(rd_kafka_t *rk, const char *errstr);</span>
<span class="s1">&#39;</span>
</code></pre></div>
rdkafka.h, rdkafka_mock.h</p>
<h3 id="rd_kafka_version_4">RD_KAFKA_VERSION<a class="headerlink" href="#rd_kafka_version_4" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_VERSION</span> <span class="o">=</span> <span class="mi">16908799</span>
</code></pre></div>
<p>librdkafka version </p>
<p>Interpreted as hex <code>MM.mm.rr.xx</code>:</p>
<ul>
<li>MM = Major</li>
<li>mm = minor</li>
<li>rr = revision</li>
<li>xx = pre-release id (0xff is the final release)</li>
</ul>
<p>E.g.: <code>0x000801ff</code> = 0.8.1</p>
<dl class="section remark"><dt>Remarks</dt><dd>This value should only be used during compile time, for runtime checks of version use rd_kafka_version() </dd></dl>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_unsupported_compression_type_4">RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE<a class="headerlink" href="#rd_kafka_resp_err_unsupported_compression_type_4" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE</span> <span class="o">=</span> <span class="mi">76</span>
</code></pre></div>
<p>Unsupported compression type </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_end_all_4">RD_KAFKA_RESP_ERR_END_ALL<a class="headerlink" href="#rd_kafka_resp_err_end_all_4" title="Permanent link">&para;</a></h3>
<p><div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_END_ALL</span> <span class="o">=</span> <span class="mi">82</span>
</code></pre></div>
enum rd_kafka_resp_err_t</p>
<h3 id="rd_kafka_admin_op__cnt_4">RD_KAFKA_ADMIN_OP__CNT<a class="headerlink" href="#rd_kafka_admin_op__cnt_4" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_ADMIN_OP__CNT</span> <span class="o">=</span> <span class="mi">6</span>
</code></pre></div>
<p>Number of ops defined </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe </a></li>
</ul>
</div>
<h3 id="rd_kafka_resource__cnt_4">RD_KAFKA_RESOURCE__CNT<a class="headerlink" href="#rd_kafka_resource__cnt_4" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESOURCE__CNT</span> <span class="o">=</span> <span class="mi">5</span>
</code></pre></div>
<p>Number of resource types defined </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#acca83a66d7783ff7683ed2691cc907c9"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#acca83a66d7783ff7683ed2691cc907c9 </a></li>
</ul>
</div>
<h3 id="rd_kafka_cdef_4">RD_KAFKA_CDEF<a class="headerlink" href="#rd_kafka_cdef_4" title="Permanent link">&para;</a></h3>
<p><div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_CDEF</span> <span class="o">=</span> <span class="s1">&#39;typedef long int ssize_t;</span>
<span class="s1">typedef struct _IO_FILE FILE;</span>
<span class="s1">typedef long int mode_t;</span>
<span class="s1">typedef signed int int16_t;</span>
<span class="s1">typedef unsigned int uint16_t;</span>
<span class="s1">typedef signed int int32_t;</span>
<span class="s1">typedef signed long int int64_t;</span>
<span class="s1">int rd_kafka_version(void);</span>
<span class="s1">const char *rd_kafka_version_str(void);</span>
<span class="s1">typedef enum rd_kafka_type_t {</span>
<span class="s1">  RD_KAFKA_PRODUCER,</span>
<span class="s1">  RD_KAFKA_CONSUMER,</span>
<span class="s1">} rd_kafka_type_t;</span>
<span class="s1">typedef enum rd_kafka_timestamp_type_t {</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_NOT_AVAILABLE,</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_CREATE_TIME,</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_LOG_APPEND_TIME,</span>
<span class="s1">} rd_kafka_timestamp_type_t;</span>
<span class="s1">const char *rd_kafka_get_debug_contexts(void);</span>
<span class="s1">typedef struct rd_kafka_s rd_kafka_t;</span>
<span class="s1">typedef struct rd_kafka_topic_s rd_kafka_topic_t;</span>
<span class="s1">typedef struct rd_kafka_conf_s rd_kafka_conf_t;</span>
<span class="s1">typedef struct rd_kafka_topic_conf_s rd_kafka_topic_conf_t;</span>
<span class="s1">typedef struct rd_kafka_queue_s rd_kafka_queue_t;</span>
<span class="s1">typedef struct rd_kafka_op_s rd_kafka_event_t;</span>
<span class="s1">typedef struct rd_kafka_topic_result_s rd_kafka_topic_result_t;</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BEGIN = (- 200),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BAD_MSG = (- 199),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BAD_COMPRESSION = (- 198),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__DESTROY = (- 197),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FAIL = (- 196),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TRANSPORT = (- 195),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__CRIT_SYS_RESOURCE = (- 194),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__RESOLVE = (- 193),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__MSG_TIMED_OUT = (- 192),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PARTITION_EOF = (- 191),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION = (- 190),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FS = (- 189),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC = (- 188),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ALL_BROKERS_DOWN = (- 187),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INVALID_ARG = (- 186),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TIMED_OUT = (- 185),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__QUEUE_FULL = (- 184),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ISR_INSUFF = (- 183),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NODE_UPDATE = (- 182),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__SSL = (- 181),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__WAIT_COORD = (- 180),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_GROUP = (- 179),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__IN_PROGRESS = (- 178),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PREV_IN_PROGRESS = (- 177),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__EXISTING_SUBSCRIPTION = (- 176),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS = (- 175),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS = (- 174),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__CONFLICT = (- 173),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__STATE = (- 172),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_PROTOCOL = (- 171),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED = (- 170),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__AUTHENTICATION = (- 169),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NO_OFFSET = (- 168),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__OUTDATED = (- 167),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TIMED_OUT_QUEUE = (- 166),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNSUPPORTED_FEATURE = (- 165),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__WAIT_CACHE = (- 164),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INTR = (- 163),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__KEY_SERIALIZATION = (- 162),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__VALUE_SERIALIZATION = (- 161),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__KEY_DESERIALIZATION = (- 160),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__VALUE_DESERIALIZATION = (- 159),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PARTIAL = (- 158),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__READ_ONLY = (- 157),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOENT = (- 156),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNDERFLOW = (- 155),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INVALID_TYPE = (- 154),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__RETRY = (- 153),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PURGE_QUEUE = (- 152),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PURGE_INFLIGHT = (- 151),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FATAL = (- 150),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INCONSISTENT = (- 149),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__GAPLESS_GUARANTEE = (- 148),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__MAX_POLL_EXCEEDED = (- 147),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__END = (- 100),</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN = (- 1),</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NO_ERROR = 0,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_OUT_OF_RANGE = 1,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_MSG = 2,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART = 3,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_MSG_SIZE = 4,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE = 5,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_LEADER_FOR_PARTITION = 6,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REQUEST_TIMED_OUT = 7,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_BROKER_NOT_AVAILABLE = 8,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REPLICA_NOT_AVAILABLE = 9,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE = 10,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_STALE_CTRL_EPOCH = 11,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_METADATA_TOO_LARGE = 12,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NETWORK_EXCEPTION = 13,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_LOAD_IN_PROGRESS = 14,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_COORDINATOR_NOT_AVAILABLE = 15,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_COORDINATOR_FOR_GROUP = 16,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_EXCEPTION = 17,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_RECORD_LIST_TOO_LARGE = 18,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS = 19,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS_AFTER_APPEND = 20,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REQUIRED_ACKS = 21,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ILLEGAL_GENERATION = 22,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INCONSISTENT_GROUP_PROTOCOL = 23,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_GROUP_ID = 24,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_MEMBER_ID = 25,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_SESSION_TIMEOUT = 26,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REBALANCE_IN_PROGRESS = 27,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_COMMIT_OFFSET_SIZE = 28,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_AUTHORIZATION_FAILED = 29,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_AUTHORIZATION_FAILED = 30,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_CLUSTER_AUTHORIZATION_FAILED = 31,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TIMESTAMP = 32,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_SASL_MECHANISM = 33,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ILLEGAL_SASL_STATE = 34,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_VERSION = 35,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_ALREADY_EXISTS = 36,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PARTITIONS = 37,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REPLICATION_FACTOR = 38,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REPLICA_ASSIGNMENT = 39,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_CONFIG = 40,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_CONTROLLER = 41,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REQUEST = 42,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_FOR_MESSAGE_FORMAT = 43,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_POLICY_VIOLATION = 44,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OUT_OF_ORDER_SEQUENCE_NUMBER = 45,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DUPLICATE_SEQUENCE_NUMBER = 46,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_EPOCH = 47,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TXN_STATE = 48,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_ID_MAPPING = 49,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TRANSACTION_TIMEOUT = 50,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_CONCURRENT_TRANSACTIONS = 51,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TRANSACTION_COORDINATOR_FENCED = 52,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TRANSACTIONAL_ID_AUTHORIZATION_FAILED = 53,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_SECURITY_DISABLED = 54,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OPERATION_NOT_ATTEMPTED = 55,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_KAFKA_STORAGE_ERROR = 56,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LOG_DIR_NOT_FOUND = 57,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_SASL_AUTHENTICATION_FAILED = 58,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_PRODUCER_ID = 59,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REASSIGNMENT_IN_PROGRESS = 60,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTH_DISABLED = 61,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_NOT_FOUND = 62,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_OWNER_MISMATCH = 63,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_REQUEST_NOT_ALLOWED = 64,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTHORIZATION_FAILED = 65,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_EXPIRED = 66,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRINCIPAL_TYPE = 67,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NON_EMPTY_GROUP = 68,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_ID_NOT_FOUND = 69,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FETCH_SESSION_ID_NOT_FOUND = 70,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_FETCH_SESSION_EPOCH = 71,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LISTENER_NOT_FOUND = 72,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_DELETION_DISABLED = 73,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FENCED_LEADER_EPOCH = 74,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_LEADER_EPOCH = 75,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_STALE_BROKER_EPOCH = 77,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_NOT_AVAILABLE = 78,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_MEMBER_ID_REQUIRED = 79,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_PREFERRED_LEADER_NOT_AVAILABLE = 80,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_MAX_SIZE_REACHED = 81,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_END_ALL,</span>
<span class="s1">} rd_kafka_resp_err_t;</span>
<span class="s1">struct rd_kafka_err_desc {</span>
<span class="s1">  rd_kafka_resp_err_t code;</span>
<span class="s1">  char *name;</span>
<span class="s1">  char *desc;</span>
<span class="s1">};</span>
<span class="s1">void rd_kafka_get_err_descs(const struct rd_kafka_err_desc **errdescs, size_t *cntp);</span>
<span class="s1">const char *rd_kafka_err2str(rd_kafka_resp_err_t err);</span>
<span class="s1">const char *rd_kafka_err2name(rd_kafka_resp_err_t err);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_last_error(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_errno2err(int errnox);</span>
<span class="s1">int rd_kafka_errno(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_fatal_error(rd_kafka_t *rk, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_test_fatal_error(rd_kafka_t *rk, rd_kafka_resp_err_t err, const char *reason);</span>
<span class="s1">typedef struct rd_kafka_topic_partition_s {</span>
<span class="s1">  char *topic;</span>
<span class="s1">  int32_t partition;</span>
<span class="s1">  int64_t offset;</span>
<span class="s1">  void *metadata;</span>
<span class="s1">  size_t metadata_size;</span>
<span class="s1">  void *opaque;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  void *_private;</span>
<span class="s1">} rd_kafka_topic_partition_t;</span>
<span class="s1">void rd_kafka_topic_partition_destroy(rd_kafka_topic_partition_t *rktpar);</span>
<span class="s1">typedef struct rd_kafka_topic_partition_list_s {</span>
<span class="s1">  int cnt;</span>
<span class="s1">  int size;</span>
<span class="s1">  rd_kafka_topic_partition_t *elems;</span>
<span class="s1">} rd_kafka_topic_partition_list_t;</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_new(int size);</span>
<span class="s1">void rd_kafka_topic_partition_list_destroy(rd_kafka_topic_partition_list_t *rkparlist);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_add(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">void rd_kafka_topic_partition_list_add_range(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t start, int32_t stop);</span>
<span class="s1">int rd_kafka_topic_partition_list_del(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">int rd_kafka_topic_partition_list_del_by_idx(rd_kafka_topic_partition_list_t *rktparlist, int idx);</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_copy(const rd_kafka_topic_partition_list_t *src);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_topic_partition_list_set_offset(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition, int64_t offset);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_find(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">void rd_kafka_topic_partition_list_sort(rd_kafka_topic_partition_list_t *rktparlist, int (*cmp)(const void *a, const void *b, void *cmp_opaque), void *cmp_opaque);</span>
<span class="s1">typedef enum rd_kafka_vtype_t {</span>
<span class="s1">  RD_KAFKA_VTYPE_END,</span>
<span class="s1">  RD_KAFKA_VTYPE_TOPIC,</span>
<span class="s1">  RD_KAFKA_VTYPE_RKT,</span>
<span class="s1">  RD_KAFKA_VTYPE_PARTITION,</span>
<span class="s1">  RD_KAFKA_VTYPE_VALUE,</span>
<span class="s1">  RD_KAFKA_VTYPE_KEY,</span>
<span class="s1">  RD_KAFKA_VTYPE_OPAQUE,</span>
<span class="s1">  RD_KAFKA_VTYPE_MSGFLAGS,</span>
<span class="s1">  RD_KAFKA_VTYPE_TIMESTAMP,</span>
<span class="s1">  RD_KAFKA_VTYPE_HEADER,</span>
<span class="s1">  RD_KAFKA_VTYPE_HEADERS,</span>
<span class="s1">} rd_kafka_vtype_t;</span>
<span class="s1">typedef struct rd_kafka_headers_s rd_kafka_headers_t;</span>
<span class="s1">rd_kafka_headers_t *rd_kafka_headers_new(size_t initial_count);</span>
<span class="s1">void rd_kafka_headers_destroy(rd_kafka_headers_t *hdrs);</span>
<span class="s1">rd_kafka_headers_t *rd_kafka_headers_copy(const rd_kafka_headers_t *src);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_add(rd_kafka_headers_t *hdrs, const char *name, ssize_t name_size, const void *value, ssize_t value_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_remove(rd_kafka_headers_t *hdrs, const char *name);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get_last(const rd_kafka_headers_t *hdrs, const char *name, const void **valuep, size_t *sizep);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get(const rd_kafka_headers_t *hdrs, size_t idx, const char *name, const void **valuep, size_t *sizep);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get_all(const rd_kafka_headers_t *hdrs, size_t idx, const char **namep, const void **valuep, size_t *sizep);</span>
<span class="s1">typedef struct rd_kafka_message_s {</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  rd_kafka_topic_t *rkt;</span>
<span class="s1">  int32_t partition;</span>
<span class="s1">  void *payload;</span>
<span class="s1">  size_t len;</span>
<span class="s1">  void *key;</span>
<span class="s1">  size_t key_len;</span>
<span class="s1">  int64_t offset;</span>
<span class="s1">  void *_private;</span>
<span class="s1">} rd_kafka_message_t;</span>
<span class="s1">void rd_kafka_message_destroy(rd_kafka_message_t *rkmessage);</span>
<span class="s1">int64_t rd_kafka_message_timestamp(const rd_kafka_message_t *rkmessage, rd_kafka_timestamp_type_t *tstype);</span>
<span class="s1">int64_t rd_kafka_message_latency(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_message_headers(const rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_message_detach_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);</span>
<span class="s1">void rd_kafka_message_set_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t *hdrs);</span>
<span class="s1">size_t rd_kafka_header_cnt(const rd_kafka_headers_t *hdrs);</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_NOT_PERSISTED = 0,</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_POSSIBLY_PERSISTED = 1,</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_PERSISTED = 2,</span>
<span class="s1">} rd_kafka_msg_status_t;</span>
<span class="s1">rd_kafka_msg_status_t rd_kafka_message_status(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_CONF_UNKNOWN = (- 2),</span>
<span class="s1">  RD_KAFKA_CONF_INVALID = (- 1),</span>
<span class="s1">  RD_KAFKA_CONF_OK = 0,</span>
<span class="s1">} rd_kafka_conf_res_t;</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_new(void);</span>
<span class="s1">void rd_kafka_conf_destroy(rd_kafka_conf_t *conf);</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_dup(const rd_kafka_conf_t *conf);</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_dup_filter(const rd_kafka_conf_t *conf, size_t filter_cnt, const char **filter);</span>
<span class="s1">const rd_kafka_conf_t *rd_kafka_conf(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_set(rd_kafka_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_conf_set_events(rd_kafka_conf_t *conf, int events);</span>
<span class="s1">void rd_kafka_conf_set_background_event_cb(rd_kafka_conf_t *conf, void (*event_cb)(rd_kafka_t *rk, rd_kafka_event_t *rkev, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_dr_cb(rd_kafka_conf_t *conf, void (*dr_cb)(rd_kafka_t *rk, void *payload, size_t len, rd_kafka_resp_err_t err, void *opaque, void *msg_opaque));</span>
<span class="s1">void rd_kafka_conf_set_dr_msg_cb(rd_kafka_conf_t *conf, void (*dr_msg_cb)(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_consume_cb(rd_kafka_conf_t *conf, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_rebalance_cb(rd_kafka_conf_t *conf, void (*rebalance_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *partitions, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_offset_commit_cb(rd_kafka_conf_t *conf, void (*offset_commit_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_error_cb(rd_kafka_conf_t *conf, void (*error_cb)(rd_kafka_t *rk, int err, const char *reason, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_throttle_cb(rd_kafka_conf_t *conf, void (*throttle_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int throttle_time_ms, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_log_cb(rd_kafka_conf_t *conf, void (*log_cb)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));</span>
<span class="s1">void rd_kafka_conf_set_stats_cb(rd_kafka_conf_t *conf, int (*stats_cb)(rd_kafka_t *rk, char *json, size_t json_len, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_oauthbearer_token_refresh_cb(rd_kafka_conf_t *conf, void (*oauthbearer_token_refresh_cb)(rd_kafka_t *rk, const char *oauthbearer_config, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_socket_cb(rd_kafka_conf_t *conf, int (*socket_cb)(int domain, int type, int protocol, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_connect_cb(rd_kafka_conf_t *conf, int (*connect_cb)(int sockfd, const struct sockaddr *addr, int addrlen, const char *id, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_closesocket_cb(rd_kafka_conf_t *conf, int (*closesocket_cb)(int sockfd, void *opaque));</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert_verify_cb(rd_kafka_conf_t *conf, int (*ssl_cert_verify_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int *x509_error, int depth, const char *buf, size_t size, char *errstr, size_t errstr_size, void *opaque));</span>
<span class="s1">typedef enum rd_kafka_cert_type_t {</span>
<span class="s1">  RD_KAFKA_CERT_PUBLIC_KEY,</span>
<span class="s1">  RD_KAFKA_CERT_PRIVATE_KEY,</span>
<span class="s1">  RD_KAFKA_CERT_CA,</span>
<span class="s1">  RD_KAFKA_CERT__CNT,</span>
<span class="s1">} rd_kafka_cert_type_t;</span>
<span class="s1">typedef enum rd_kafka_cert_enc_t {</span>
<span class="s1">  RD_KAFKA_CERT_ENC_PKCS12,</span>
<span class="s1">  RD_KAFKA_CERT_ENC_DER,</span>
<span class="s1">  RD_KAFKA_CERT_ENC_PEM,</span>
<span class="s1">  RD_KAFKA_CERT_ENC__CNT,</span>
<span class="s1">} rd_kafka_cert_enc_t;</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert(rd_kafka_conf_t *conf, rd_kafka_cert_type_t cert_type, rd_kafka_cert_enc_t cert_enc, const void *buffer, size_t size, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_conf_set_opaque(rd_kafka_conf_t *conf, void *opaque);</span>
<span class="s1">void *rd_kafka_opaque(const rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_conf_set_default_topic_conf(rd_kafka_conf_t *conf, rd_kafka_topic_conf_t *tconf);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_get(const rd_kafka_conf_t *conf, const char *name, char *dest, size_t *dest_size);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_topic_conf_get(const rd_kafka_topic_conf_t *conf, const char *name, char *dest, size_t *dest_size);</span>
<span class="s1">const char **rd_kafka_conf_dump(rd_kafka_conf_t *conf, size_t *cntp);</span>
<span class="s1">const char **rd_kafka_topic_conf_dump(rd_kafka_topic_conf_t *conf, size_t *cntp);</span>
<span class="s1">void rd_kafka_conf_dump_free(const char **arr, size_t cnt);</span>
<span class="s1">void rd_kafka_conf_properties_show(FILE *fp);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_topic_conf_new(void);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_topic_conf_dup(const rd_kafka_topic_conf_t *conf);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_default_topic_conf_dup(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_topic_conf_destroy(rd_kafka_topic_conf_t *topic_conf);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_topic_conf_set(rd_kafka_topic_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_topic_conf_set_opaque(rd_kafka_topic_conf_t *conf, void *rkt_opaque);</span>
<span class="s1">void rd_kafka_topic_conf_set_partitioner_cb(rd_kafka_topic_conf_t *topic_conf, int32_t (*partitioner)(const rd_kafka_topic_t *rkt, const void *keydata, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque));</span>
<span class="s1">void rd_kafka_topic_conf_set_msg_order_cmp(rd_kafka_topic_conf_t *topic_conf, int (*msg_order_cmp)(const rd_kafka_message_t *a, const rd_kafka_message_t *b));</span>
<span class="s1">int rd_kafka_topic_partition_available(const rd_kafka_topic_t *rkt, int32_t partition);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_consistent(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_consistent_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_murmur2(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_murmur2_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">rd_kafka_t *rd_kafka_new(rd_kafka_type_t type, rd_kafka_conf_t *conf, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_destroy(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_destroy_flags(rd_kafka_t *rk, int flags);</span>
<span class="s1">const char *rd_kafka_name(const rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_type_t rd_kafka_type(const rd_kafka_t *rk);</span>
<span class="s1">char *rd_kafka_memberid(const rd_kafka_t *rk);</span>
<span class="s1">char *rd_kafka_clusterid(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">int32_t rd_kafka_controllerid(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_topic_t *rd_kafka_topic_new(rd_kafka_t *rk, const char *topic, rd_kafka_topic_conf_t *conf);</span>
<span class="s1">void rd_kafka_topic_destroy(rd_kafka_topic_t *rkt);</span>
<span class="s1">const char *rd_kafka_topic_name(const rd_kafka_topic_t *rkt);</span>
<span class="s1">void *rd_kafka_topic_opaque(const rd_kafka_topic_t *rkt);</span>
<span class="s1">int rd_kafka_poll(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">void rd_kafka_yield(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_pause_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_resume_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_query_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_get_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offsets_for_times(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets, int timeout_ms);</span>
<span class="s1">void rd_kafka_mem_free(rd_kafka_t *rk, void *ptr);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_new(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_queue_destroy(rd_kafka_queue_t *rkqu);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_main(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_consumer(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_partition(rd_kafka_t *rk, const char *topic, int32_t partition);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_background(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_queue_forward(rd_kafka_queue_t *src, rd_kafka_queue_t *dst);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_set_log_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu);</span>
<span class="s1">size_t rd_kafka_queue_length(rd_kafka_queue_t *rkqu);</span>
<span class="s1">void rd_kafka_queue_io_event_enable(rd_kafka_queue_t *rkqu, int fd, const void *payload, size_t size);</span>
<span class="s1">void rd_kafka_queue_cb_event_enable(rd_kafka_queue_t *rkqu, void (*event_cb)(rd_kafka_t *rk, void *qev_opaque), void *qev_opaque);</span>
<span class="s1">int rd_kafka_consume_start(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);</span>
<span class="s1">int rd_kafka_consume_start_queue(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, rd_kafka_queue_t *rkqu);</span>
<span class="s1">int rd_kafka_consume_stop(rd_kafka_topic_t *rkt, int32_t partition);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_seek(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, int timeout_ms);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consume(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms);</span>
<span class="s1">ssize_t rd_kafka_consume_batch(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);</span>
<span class="s1">int rd_kafka_consume_callback(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consume_queue(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">ssize_t rd_kafka_consume_batch_queue(rd_kafka_queue_t *rkqu, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);</span>
<span class="s1">int rd_kafka_consume_callback_queue(rd_kafka_queue_t *rkqu, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offset_store(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offsets_store(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_subscribe(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *topics);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_unsubscribe(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_subscription(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **topics);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consumer_poll(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_consumer_close(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_assignment(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, int async);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit_message(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, int async);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit_queue(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_queue_t *rkqu, void (*cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *commit_opaque), void *commit_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_committed(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_position(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">int rd_kafka_produce(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, void *payload, size_t len, const void *key, size_t keylen, void *msg_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_producev(rd_kafka_t *rk, ...);</span>
<span class="s1">int rd_kafka_produce_batch(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, rd_kafka_message_t *rkmessages, int message_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_flush(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_purge(rd_kafka_t *rk, int purge_flags);</span>
<span class="s1">typedef struct rd_kafka_metadata_broker {</span>
<span class="s1">  int32_t id;</span>
<span class="s1">  char *host;</span>
<span class="s1">  int port;</span>
<span class="s1">} rd_kafka_metadata_broker_t;</span>
<span class="s1">typedef struct rd_kafka_metadata_partition {</span>
<span class="s1">  int32_t id;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  int32_t leader;</span>
<span class="s1">  int replica_cnt;</span>
<span class="s1">  int32_t *replicas;</span>
<span class="s1">  int isr_cnt;</span>
<span class="s1">  int32_t *isrs;</span>
<span class="s1">} rd_kafka_metadata_partition_t;</span>
<span class="s1">typedef struct rd_kafka_metadata_topic {</span>
<span class="s1">  char *topic;</span>
<span class="s1">  int partition_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_partition *partitions;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">} rd_kafka_metadata_topic_t;</span>
<span class="s1">typedef struct rd_kafka_metadata {</span>
<span class="s1">  int broker_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_broker *brokers;</span>
<span class="s1">  int topic_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_topic *topics;</span>
<span class="s1">  int32_t orig_broker_id;</span>
<span class="s1">  char *orig_broker_name;</span>
<span class="s1">} rd_kafka_metadata_t;</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_metadata(rd_kafka_t *rk, int all_topics, rd_kafka_topic_t *only_rkt, const struct rd_kafka_metadata **metadatap, int timeout_ms);</span>
<span class="s1">void rd_kafka_metadata_destroy(const struct rd_kafka_metadata *metadata);</span>
<span class="s1">struct rd_kafka_group_member_info {</span>
<span class="s1">  char *member_id;</span>
<span class="s1">  char *client_id;</span>
<span class="s1">  char *client_host;</span>
<span class="s1">  void *member_metadata;</span>
<span class="s1">  int member_metadata_size;</span>
<span class="s1">  void *member_assignment;</span>
<span class="s1">  int member_assignment_size;</span>
<span class="s1">};</span>
<span class="s1">struct rd_kafka_group_info {</span>
<span class="s1">  struct rd_kafka_metadata_broker broker;</span>
<span class="s1">  char *group;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  char *state;</span>
<span class="s1">  char *protocol_type;</span>
<span class="s1">  char *protocol;</span>
<span class="s1">  struct rd_kafka_group_member_info *members;</span>
<span class="s1">  int member_cnt;</span>
<span class="s1">};</span>
<span class="s1">struct rd_kafka_group_list {</span>
<span class="s1">  struct rd_kafka_group_info *groups;</span>
<span class="s1">  int group_cnt;</span>
<span class="s1">};</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_list_groups(rd_kafka_t *rk, const char *group, const struct rd_kafka_group_list **grplistp, int timeout_ms);</span>
<span class="s1">void rd_kafka_group_list_destroy(const struct rd_kafka_group_list *grplist);</span>
<span class="s1">int rd_kafka_brokers_add(rd_kafka_t *rk, const char *brokerlist);</span>
<span class="s1">void rd_kafka_set_logger(rd_kafka_t *rk, void (*func)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));</span>
<span class="s1">void rd_kafka_set_log_level(rd_kafka_t *rk, int level);</span>
<span class="s1">void rd_kafka_log_print(const rd_kafka_t *rk, int level, const char *fac, const char *buf);</span>
<span class="s1">void rd_kafka_log_syslog(const rd_kafka_t *rk, int level, const char *fac, const char *buf);</span>
<span class="s1">int rd_kafka_outq_len(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_dump(FILE *fp, rd_kafka_t *rk);</span>
<span class="s1">int rd_kafka_thread_cnt(void);</span>
<span class="s1">typedef enum rd_kafka_thread_type_t {</span>
<span class="s1">  RD_KAFKA_THREAD_MAIN,</span>
<span class="s1">  RD_KAFKA_THREAD_BACKGROUND,</span>
<span class="s1">  RD_KAFKA_THREAD_BROKER,</span>
<span class="s1">} rd_kafka_thread_type_t;</span>
<span class="s1">int rd_kafka_wait_destroyed(int timeout_ms);</span>
<span class="s1">int rd_kafka_unittest(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_poll_set_consumer(rd_kafka_t *rk);</span>
<span class="s1">typedef int rd_kafka_event_type_t;</span>
<span class="s1">rd_kafka_event_type_t rd_kafka_event_type(const rd_kafka_event_t *rkev);</span>
<span class="s1">const char *rd_kafka_event_name(const rd_kafka_event_t *rkev);</span>
<span class="s1">void rd_kafka_event_destroy(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_message_t *rd_kafka_event_message_next(rd_kafka_event_t *rkev);</span>
<span class="s1">size_t rd_kafka_event_message_array(rd_kafka_event_t *rkev, const rd_kafka_message_t **rkmessages, size_t size);</span>
<span class="s1">size_t rd_kafka_event_message_count(rd_kafka_event_t *rkev);</span>
<span class="s1">const char *rd_kafka_event_config_string(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_event_error(rd_kafka_event_t *rkev);</span>
<span class="s1">const char *rd_kafka_event_error_string(rd_kafka_event_t *rkev);</span>
<span class="s1">int rd_kafka_event_error_is_fatal(rd_kafka_event_t *rkev);</span>
<span class="s1">void *rd_kafka_event_opaque(rd_kafka_event_t *rkev);</span>
<span class="s1">int rd_kafka_event_log(rd_kafka_event_t *rkev, const char **fac, const char **str, int *level);</span>
<span class="s1">const char *rd_kafka_event_stats(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_event_topic_partition_list(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_event_topic_partition(rd_kafka_event_t *rkev);</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_CreateTopics_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DeleteTopics_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_CreatePartitions_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_AlterConfigs_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DescribeConfigs_result_t;</span>
<span class="s1">const rd_kafka_CreateTopics_result_t *rd_kafka_event_CreateTopics_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DeleteTopics_result_t *rd_kafka_event_DeleteTopics_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_CreatePartitions_result_t *rd_kafka_event_CreatePartitions_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_AlterConfigs_result_t *rd_kafka_event_AlterConfigs_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DescribeConfigs_result_t *rd_kafka_event_DescribeConfigs_result(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_event_t *rd_kafka_queue_poll(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">int rd_kafka_queue_poll_callback(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_plugin_f_conf_init_t)(rd_kafka_conf_t *conf, void **plug_opaquep, char *errstr, size_t errstr_size);</span>
<span class="s1">typedef rd_kafka_conf_res_t (rd_kafka_interceptor_f_on_conf_set_t)(rd_kafka_conf_t *conf, const char *name, const char *val, char *errstr, size_t errstr_size, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_dup_t)(rd_kafka_conf_t *new_conf, const rd_kafka_conf_t *old_conf, size_t filter_cnt, const char **filter, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_destroy_t)(void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_new_t)(rd_kafka_t *rk, const rd_kafka_conf_t *conf, void *ic_opaque, char *errstr, size_t errstr_size);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_destroy_t)(rd_kafka_t *rk, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_send_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_acknowledgement_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_consume_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_commit_t)(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_resp_err_t err, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_request_sent_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_start_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_exit_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_set(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_set_t *on_conf_set, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_dup(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_dup_t *on_conf_dup, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_destroy(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_destroy_t *on_conf_destroy, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_new(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_new_t *on_new, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_destroy(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_destroy_t *on_destroy, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_send(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_send_t *on_send, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_acknowledgement(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_acknowledgement_t *on_acknowledgement, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_consume(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_consume_t *on_consume, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_commit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_commit_t *on_commit, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_request_sent(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_request_sent_t *on_request_sent, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_start(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_start_t *on_thread_start, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_exit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_exit_t *on_thread_exit, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_topic_result_error(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">const char *rd_kafka_topic_result_error_string(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">const char *rd_kafka_topic_result_name(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">typedef enum rd_kafka_admin_op_t {</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_ANY = 0,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_CREATETOPICS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DELETETOPICS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_CREATEPARTITIONS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_ALTERCONFIGS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DESCRIBECONFIGS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP__CNT,</span>
<span class="s1">} rd_kafka_admin_op_t;</span>
<span class="s1">typedef struct rd_kafka_AdminOptions_s rd_kafka_AdminOptions_t;</span>
<span class="s1">rd_kafka_AdminOptions_t *rd_kafka_AdminOptions_new(rd_kafka_t *rk, rd_kafka_admin_op_t for_api);</span>
<span class="s1">void rd_kafka_AdminOptions_destroy(rd_kafka_AdminOptions_t *options);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_request_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_operation_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_validate_only(rd_kafka_AdminOptions_t *options, int true_or_false, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_broker(rd_kafka_AdminOptions_t *options, int32_t broker_id, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_AdminOptions_set_opaque(rd_kafka_AdminOptions_t *options, void *ev_opaque);</span>
<span class="s1">typedef struct rd_kafka_NewTopic_s rd_kafka_NewTopic_t;</span>
<span class="s1">rd_kafka_NewTopic_t *rd_kafka_NewTopic_new(const char *topic, int num_partitions, int replication_factor, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_NewTopic_destroy(rd_kafka_NewTopic_t *new_topic);</span>
<span class="s1">void rd_kafka_NewTopic_destroy_array(rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewTopic_set_replica_assignment(rd_kafka_NewTopic_t *new_topic, int32_t partition, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewTopic_set_config(rd_kafka_NewTopic_t *new_topic, const char *name, const char *value);</span>
<span class="s1">void rd_kafka_CreateTopics(rd_kafka_t *rk, rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_CreateTopics_result_topics(const rd_kafka_CreateTopics_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_DeleteTopic_s rd_kafka_DeleteTopic_t;</span>
<span class="s1">rd_kafka_DeleteTopic_t *rd_kafka_DeleteTopic_new(const char *topic);</span>
<span class="s1">void rd_kafka_DeleteTopic_destroy(rd_kafka_DeleteTopic_t *del_topic);</span>
<span class="s1">void rd_kafka_DeleteTopic_destroy_array(rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt);</span>
<span class="s1">void rd_kafka_DeleteTopics(rd_kafka_t *rk, rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_DeleteTopics_result_topics(const rd_kafka_DeleteTopics_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_NewPartitions_s rd_kafka_NewPartitions_t;</span>
<span class="s1">rd_kafka_NewPartitions_t *rd_kafka_NewPartitions_new(const char *topic, size_t new_total_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_NewPartitions_destroy(rd_kafka_NewPartitions_t *new_parts);</span>
<span class="s1">void rd_kafka_NewPartitions_destroy_array(rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewPartitions_set_replica_assignment(rd_kafka_NewPartitions_t *new_parts, int32_t new_partition_idx, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_CreatePartitions(rd_kafka_t *rk, rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_CreatePartitions_result_topics(const rd_kafka_CreatePartitions_result_t *result, size_t *cntp);</span>
<span class="s1">typedef enum rd_kafka_ConfigSource_t {</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_UNKNOWN_CONFIG = 0,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_TOPIC_CONFIG = 1,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_BROKER_CONFIG = 2,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_DEFAULT_BROKER_CONFIG = 3,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_STATIC_BROKER_CONFIG = 4,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DEFAULT_CONFIG = 5,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE__CNT,</span>
<span class="s1">} rd_kafka_ConfigSource_t;</span>
<span class="s1">const char *rd_kafka_ConfigSource_name(rd_kafka_ConfigSource_t confsource);</span>
<span class="s1">typedef struct rd_kafka_ConfigEntry_s rd_kafka_ConfigEntry_t;</span>
<span class="s1">const char *rd_kafka_ConfigEntry_name(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">const char *rd_kafka_ConfigEntry_value(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">rd_kafka_ConfigSource_t rd_kafka_ConfigEntry_source(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_read_only(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_default(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_sensitive(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_synonym(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">const rd_kafka_ConfigEntry_t **rd_kafka_ConfigEntry_synonyms(const rd_kafka_ConfigEntry_t *entry, size_t *cntp);</span>
<span class="s1">typedef enum rd_kafka_ResourceType_t {</span>
<span class="s1">  RD_KAFKA_RESOURCE_UNKNOWN = 0,</span>
<span class="s1">  RD_KAFKA_RESOURCE_ANY = 1,</span>
<span class="s1">  RD_KAFKA_RESOURCE_TOPIC = 2,</span>
<span class="s1">  RD_KAFKA_RESOURCE_GROUP = 3,</span>
<span class="s1">  RD_KAFKA_RESOURCE_BROKER = 4,</span>
<span class="s1">  RD_KAFKA_RESOURCE__CNT,</span>
<span class="s1">} rd_kafka_ResourceType_t;</span>
<span class="s1">const char *rd_kafka_ResourceType_name(rd_kafka_ResourceType_t restype);</span>
<span class="s1">typedef struct rd_kafka_ConfigResource_s rd_kafka_ConfigResource_t;</span>
<span class="s1">rd_kafka_ConfigResource_t *rd_kafka_ConfigResource_new(rd_kafka_ResourceType_t restype, const char *resname);</span>
<span class="s1">void rd_kafka_ConfigResource_destroy(rd_kafka_ConfigResource_t *config);</span>
<span class="s1">void rd_kafka_ConfigResource_destroy_array(rd_kafka_ConfigResource_t **config, size_t config_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_ConfigResource_set_config(rd_kafka_ConfigResource_t *config, const char *name, const char *value);</span>
<span class="s1">const rd_kafka_ConfigEntry_t **rd_kafka_ConfigResource_configs(const rd_kafka_ConfigResource_t *config, size_t *cntp);</span>
<span class="s1">rd_kafka_ResourceType_t rd_kafka_ConfigResource_type(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">const char *rd_kafka_ConfigResource_name(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_ConfigResource_error(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">const char *rd_kafka_ConfigResource_error_string(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">void rd_kafka_AlterConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_ConfigResource_t **rd_kafka_AlterConfigs_result_resources(const rd_kafka_AlterConfigs_result_t *result, size_t *cntp);</span>
<span class="s1">void rd_kafka_DescribeConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_ConfigResource_t **rd_kafka_DescribeConfigs_result_resources(const rd_kafka_DescribeConfigs_result_t *result, size_t *cntp);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token(rd_kafka_t *rk, const char *token_value, int64_t md_lifetime_ms, const char *md_principal_name, const char **extensions, size_t extension_size, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token_failure(rd_kafka_t *rk, const char *errstr);</span>
<span class="s1">&#39;</span>
</code></pre></div>
rdkafka.h, rdkafka_mock.h</p>
<h3 id="rd_kafka_version_5">RD_KAFKA_VERSION<a class="headerlink" href="#rd_kafka_version_5" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_VERSION</span> <span class="o">=</span> <span class="mi">16909055</span>
</code></pre></div>
<p>librdkafka version </p>
<p>Interpreted as hex <code>MM.mm.rr.xx</code>:</p>
<ul>
<li>MM = Major</li>
<li>mm = minor</li>
<li>rr = revision</li>
<li>xx = pre-release id (0xff is the final release)</li>
</ul>
<p>E.g.: <code>0x000801ff</code> = 0.8.1</p>
<dl class="section remark"><dt>Remarks</dt><dd>This value should only be used during compile time, for runtime checks of version use rd_kafka_version() </dd></dl>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_unsupported_compression_type_5">RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE<a class="headerlink" href="#rd_kafka_resp_err_unsupported_compression_type_5" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE</span> <span class="o">=</span> <span class="mi">76</span>
</code></pre></div>
<p>Unsupported compression type </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_end_all_5">RD_KAFKA_RESP_ERR_END_ALL<a class="headerlink" href="#rd_kafka_resp_err_end_all_5" title="Permanent link">&para;</a></h3>
<p><div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_END_ALL</span> <span class="o">=</span> <span class="mi">82</span>
</code></pre></div>
enum rd_kafka_resp_err_t</p>
<h3 id="rd_kafka_admin_op__cnt_5">RD_KAFKA_ADMIN_OP__CNT<a class="headerlink" href="#rd_kafka_admin_op__cnt_5" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_ADMIN_OP__CNT</span> <span class="o">=</span> <span class="mi">6</span>
</code></pre></div>
<p>Number of ops defined </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe </a></li>
</ul>
</div>
<h3 id="rd_kafka_resource__cnt_5">RD_KAFKA_RESOURCE__CNT<a class="headerlink" href="#rd_kafka_resource__cnt_5" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESOURCE__CNT</span> <span class="o">=</span> <span class="mi">5</span>
</code></pre></div>
<p>Number of resource types defined </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#acca83a66d7783ff7683ed2691cc907c9"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#acca83a66d7783ff7683ed2691cc907c9 </a></li>
</ul>
</div>
<h3 id="rd_kafka_cdef_5">RD_KAFKA_CDEF<a class="headerlink" href="#rd_kafka_cdef_5" title="Permanent link">&para;</a></h3>
<p><div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_CDEF</span> <span class="o">=</span> <span class="s1">&#39;typedef long int ssize_t;</span>
<span class="s1">typedef struct _IO_FILE FILE;</span>
<span class="s1">typedef long int mode_t;</span>
<span class="s1">typedef signed int int16_t;</span>
<span class="s1">typedef unsigned int uint16_t;</span>
<span class="s1">typedef signed int int32_t;</span>
<span class="s1">typedef signed long int int64_t;</span>
<span class="s1">int rd_kafka_version(void);</span>
<span class="s1">const char *rd_kafka_version_str(void);</span>
<span class="s1">typedef enum rd_kafka_type_t {</span>
<span class="s1">  RD_KAFKA_PRODUCER,</span>
<span class="s1">  RD_KAFKA_CONSUMER,</span>
<span class="s1">} rd_kafka_type_t;</span>
<span class="s1">typedef enum rd_kafka_timestamp_type_t {</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_NOT_AVAILABLE,</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_CREATE_TIME,</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_LOG_APPEND_TIME,</span>
<span class="s1">} rd_kafka_timestamp_type_t;</span>
<span class="s1">const char *rd_kafka_get_debug_contexts(void);</span>
<span class="s1">typedef struct rd_kafka_s rd_kafka_t;</span>
<span class="s1">typedef struct rd_kafka_topic_s rd_kafka_topic_t;</span>
<span class="s1">typedef struct rd_kafka_conf_s rd_kafka_conf_t;</span>
<span class="s1">typedef struct rd_kafka_topic_conf_s rd_kafka_topic_conf_t;</span>
<span class="s1">typedef struct rd_kafka_queue_s rd_kafka_queue_t;</span>
<span class="s1">typedef struct rd_kafka_op_s rd_kafka_event_t;</span>
<span class="s1">typedef struct rd_kafka_topic_result_s rd_kafka_topic_result_t;</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BEGIN = (- 200),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BAD_MSG = (- 199),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BAD_COMPRESSION = (- 198),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__DESTROY = (- 197),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FAIL = (- 196),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TRANSPORT = (- 195),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__CRIT_SYS_RESOURCE = (- 194),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__RESOLVE = (- 193),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__MSG_TIMED_OUT = (- 192),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PARTITION_EOF = (- 191),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION = (- 190),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FS = (- 189),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC = (- 188),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ALL_BROKERS_DOWN = (- 187),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INVALID_ARG = (- 186),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TIMED_OUT = (- 185),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__QUEUE_FULL = (- 184),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ISR_INSUFF = (- 183),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NODE_UPDATE = (- 182),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__SSL = (- 181),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__WAIT_COORD = (- 180),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_GROUP = (- 179),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__IN_PROGRESS = (- 178),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PREV_IN_PROGRESS = (- 177),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__EXISTING_SUBSCRIPTION = (- 176),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS = (- 175),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS = (- 174),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__CONFLICT = (- 173),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__STATE = (- 172),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_PROTOCOL = (- 171),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED = (- 170),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__AUTHENTICATION = (- 169),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NO_OFFSET = (- 168),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__OUTDATED = (- 167),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TIMED_OUT_QUEUE = (- 166),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNSUPPORTED_FEATURE = (- 165),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__WAIT_CACHE = (- 164),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INTR = (- 163),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__KEY_SERIALIZATION = (- 162),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__VALUE_SERIALIZATION = (- 161),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__KEY_DESERIALIZATION = (- 160),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__VALUE_DESERIALIZATION = (- 159),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PARTIAL = (- 158),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__READ_ONLY = (- 157),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOENT = (- 156),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNDERFLOW = (- 155),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INVALID_TYPE = (- 154),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__RETRY = (- 153),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PURGE_QUEUE = (- 152),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PURGE_INFLIGHT = (- 151),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FATAL = (- 150),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INCONSISTENT = (- 149),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__GAPLESS_GUARANTEE = (- 148),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__MAX_POLL_EXCEEDED = (- 147),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__END = (- 100),</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN = (- 1),</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NO_ERROR = 0,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_OUT_OF_RANGE = 1,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_MSG = 2,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART = 3,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_MSG_SIZE = 4,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE = 5,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_LEADER_FOR_PARTITION = 6,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REQUEST_TIMED_OUT = 7,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_BROKER_NOT_AVAILABLE = 8,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REPLICA_NOT_AVAILABLE = 9,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE = 10,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_STALE_CTRL_EPOCH = 11,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_METADATA_TOO_LARGE = 12,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NETWORK_EXCEPTION = 13,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_LOAD_IN_PROGRESS = 14,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_COORDINATOR_NOT_AVAILABLE = 15,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_COORDINATOR_FOR_GROUP = 16,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_EXCEPTION = 17,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_RECORD_LIST_TOO_LARGE = 18,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS = 19,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS_AFTER_APPEND = 20,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REQUIRED_ACKS = 21,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ILLEGAL_GENERATION = 22,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INCONSISTENT_GROUP_PROTOCOL = 23,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_GROUP_ID = 24,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_MEMBER_ID = 25,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_SESSION_TIMEOUT = 26,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REBALANCE_IN_PROGRESS = 27,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_COMMIT_OFFSET_SIZE = 28,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_AUTHORIZATION_FAILED = 29,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_AUTHORIZATION_FAILED = 30,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_CLUSTER_AUTHORIZATION_FAILED = 31,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TIMESTAMP = 32,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_SASL_MECHANISM = 33,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ILLEGAL_SASL_STATE = 34,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_VERSION = 35,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_ALREADY_EXISTS = 36,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PARTITIONS = 37,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REPLICATION_FACTOR = 38,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REPLICA_ASSIGNMENT = 39,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_CONFIG = 40,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_CONTROLLER = 41,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REQUEST = 42,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_FOR_MESSAGE_FORMAT = 43,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_POLICY_VIOLATION = 44,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OUT_OF_ORDER_SEQUENCE_NUMBER = 45,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DUPLICATE_SEQUENCE_NUMBER = 46,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_EPOCH = 47,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TXN_STATE = 48,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_ID_MAPPING = 49,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TRANSACTION_TIMEOUT = 50,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_CONCURRENT_TRANSACTIONS = 51,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TRANSACTION_COORDINATOR_FENCED = 52,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TRANSACTIONAL_ID_AUTHORIZATION_FAILED = 53,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_SECURITY_DISABLED = 54,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OPERATION_NOT_ATTEMPTED = 55,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_KAFKA_STORAGE_ERROR = 56,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LOG_DIR_NOT_FOUND = 57,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_SASL_AUTHENTICATION_FAILED = 58,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_PRODUCER_ID = 59,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REASSIGNMENT_IN_PROGRESS = 60,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTH_DISABLED = 61,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_NOT_FOUND = 62,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_OWNER_MISMATCH = 63,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_REQUEST_NOT_ALLOWED = 64,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTHORIZATION_FAILED = 65,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_EXPIRED = 66,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRINCIPAL_TYPE = 67,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NON_EMPTY_GROUP = 68,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_ID_NOT_FOUND = 69,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FETCH_SESSION_ID_NOT_FOUND = 70,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_FETCH_SESSION_EPOCH = 71,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LISTENER_NOT_FOUND = 72,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_DELETION_DISABLED = 73,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FENCED_LEADER_EPOCH = 74,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_LEADER_EPOCH = 75,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_STALE_BROKER_EPOCH = 77,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_NOT_AVAILABLE = 78,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_MEMBER_ID_REQUIRED = 79,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_PREFERRED_LEADER_NOT_AVAILABLE = 80,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_MAX_SIZE_REACHED = 81,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_END_ALL,</span>
<span class="s1">} rd_kafka_resp_err_t;</span>
<span class="s1">struct rd_kafka_err_desc {</span>
<span class="s1">  rd_kafka_resp_err_t code;</span>
<span class="s1">  char *name;</span>
<span class="s1">  char *desc;</span>
<span class="s1">};</span>
<span class="s1">void rd_kafka_get_err_descs(const struct rd_kafka_err_desc **errdescs, size_t *cntp);</span>
<span class="s1">const char *rd_kafka_err2str(rd_kafka_resp_err_t err);</span>
<span class="s1">const char *rd_kafka_err2name(rd_kafka_resp_err_t err);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_last_error(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_errno2err(int errnox);</span>
<span class="s1">int rd_kafka_errno(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_fatal_error(rd_kafka_t *rk, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_test_fatal_error(rd_kafka_t *rk, rd_kafka_resp_err_t err, const char *reason);</span>
<span class="s1">typedef struct rd_kafka_topic_partition_s {</span>
<span class="s1">  char *topic;</span>
<span class="s1">  int32_t partition;</span>
<span class="s1">  int64_t offset;</span>
<span class="s1">  void *metadata;</span>
<span class="s1">  size_t metadata_size;</span>
<span class="s1">  void *opaque;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  void *_private;</span>
<span class="s1">} rd_kafka_topic_partition_t;</span>
<span class="s1">void rd_kafka_topic_partition_destroy(rd_kafka_topic_partition_t *rktpar);</span>
<span class="s1">typedef struct rd_kafka_topic_partition_list_s {</span>
<span class="s1">  int cnt;</span>
<span class="s1">  int size;</span>
<span class="s1">  rd_kafka_topic_partition_t *elems;</span>
<span class="s1">} rd_kafka_topic_partition_list_t;</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_new(int size);</span>
<span class="s1">void rd_kafka_topic_partition_list_destroy(rd_kafka_topic_partition_list_t *rkparlist);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_add(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">void rd_kafka_topic_partition_list_add_range(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t start, int32_t stop);</span>
<span class="s1">int rd_kafka_topic_partition_list_del(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">int rd_kafka_topic_partition_list_del_by_idx(rd_kafka_topic_partition_list_t *rktparlist, int idx);</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_copy(const rd_kafka_topic_partition_list_t *src);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_topic_partition_list_set_offset(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition, int64_t offset);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_find(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">void rd_kafka_topic_partition_list_sort(rd_kafka_topic_partition_list_t *rktparlist, int (*cmp)(const void *a, const void *b, void *cmp_opaque), void *cmp_opaque);</span>
<span class="s1">typedef enum rd_kafka_vtype_t {</span>
<span class="s1">  RD_KAFKA_VTYPE_END,</span>
<span class="s1">  RD_KAFKA_VTYPE_TOPIC,</span>
<span class="s1">  RD_KAFKA_VTYPE_RKT,</span>
<span class="s1">  RD_KAFKA_VTYPE_PARTITION,</span>
<span class="s1">  RD_KAFKA_VTYPE_VALUE,</span>
<span class="s1">  RD_KAFKA_VTYPE_KEY,</span>
<span class="s1">  RD_KAFKA_VTYPE_OPAQUE,</span>
<span class="s1">  RD_KAFKA_VTYPE_MSGFLAGS,</span>
<span class="s1">  RD_KAFKA_VTYPE_TIMESTAMP,</span>
<span class="s1">  RD_KAFKA_VTYPE_HEADER,</span>
<span class="s1">  RD_KAFKA_VTYPE_HEADERS,</span>
<span class="s1">} rd_kafka_vtype_t;</span>
<span class="s1">typedef struct rd_kafka_headers_s rd_kafka_headers_t;</span>
<span class="s1">rd_kafka_headers_t *rd_kafka_headers_new(size_t initial_count);</span>
<span class="s1">void rd_kafka_headers_destroy(rd_kafka_headers_t *hdrs);</span>
<span class="s1">rd_kafka_headers_t *rd_kafka_headers_copy(const rd_kafka_headers_t *src);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_add(rd_kafka_headers_t *hdrs, const char *name, ssize_t name_size, const void *value, ssize_t value_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_remove(rd_kafka_headers_t *hdrs, const char *name);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get_last(const rd_kafka_headers_t *hdrs, const char *name, const void **valuep, size_t *sizep);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get(const rd_kafka_headers_t *hdrs, size_t idx, const char *name, const void **valuep, size_t *sizep);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get_all(const rd_kafka_headers_t *hdrs, size_t idx, const char **namep, const void **valuep, size_t *sizep);</span>
<span class="s1">typedef struct rd_kafka_message_s {</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  rd_kafka_topic_t *rkt;</span>
<span class="s1">  int32_t partition;</span>
<span class="s1">  void *payload;</span>
<span class="s1">  size_t len;</span>
<span class="s1">  void *key;</span>
<span class="s1">  size_t key_len;</span>
<span class="s1">  int64_t offset;</span>
<span class="s1">  void *_private;</span>
<span class="s1">} rd_kafka_message_t;</span>
<span class="s1">void rd_kafka_message_destroy(rd_kafka_message_t *rkmessage);</span>
<span class="s1">int64_t rd_kafka_message_timestamp(const rd_kafka_message_t *rkmessage, rd_kafka_timestamp_type_t *tstype);</span>
<span class="s1">int64_t rd_kafka_message_latency(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_message_headers(const rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_message_detach_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);</span>
<span class="s1">void rd_kafka_message_set_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t *hdrs);</span>
<span class="s1">size_t rd_kafka_header_cnt(const rd_kafka_headers_t *hdrs);</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_NOT_PERSISTED = 0,</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_POSSIBLY_PERSISTED = 1,</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_PERSISTED = 2,</span>
<span class="s1">} rd_kafka_msg_status_t;</span>
<span class="s1">rd_kafka_msg_status_t rd_kafka_message_status(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_CONF_UNKNOWN = (- 2),</span>
<span class="s1">  RD_KAFKA_CONF_INVALID = (- 1),</span>
<span class="s1">  RD_KAFKA_CONF_OK = 0,</span>
<span class="s1">} rd_kafka_conf_res_t;</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_new(void);</span>
<span class="s1">void rd_kafka_conf_destroy(rd_kafka_conf_t *conf);</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_dup(const rd_kafka_conf_t *conf);</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_dup_filter(const rd_kafka_conf_t *conf, size_t filter_cnt, const char **filter);</span>
<span class="s1">const rd_kafka_conf_t *rd_kafka_conf(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_set(rd_kafka_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_conf_set_events(rd_kafka_conf_t *conf, int events);</span>
<span class="s1">void rd_kafka_conf_set_background_event_cb(rd_kafka_conf_t *conf, void (*event_cb)(rd_kafka_t *rk, rd_kafka_event_t *rkev, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_dr_cb(rd_kafka_conf_t *conf, void (*dr_cb)(rd_kafka_t *rk, void *payload, size_t len, rd_kafka_resp_err_t err, void *opaque, void *msg_opaque));</span>
<span class="s1">void rd_kafka_conf_set_dr_msg_cb(rd_kafka_conf_t *conf, void (*dr_msg_cb)(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_consume_cb(rd_kafka_conf_t *conf, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_rebalance_cb(rd_kafka_conf_t *conf, void (*rebalance_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *partitions, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_offset_commit_cb(rd_kafka_conf_t *conf, void (*offset_commit_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_error_cb(rd_kafka_conf_t *conf, void (*error_cb)(rd_kafka_t *rk, int err, const char *reason, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_throttle_cb(rd_kafka_conf_t *conf, void (*throttle_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int throttle_time_ms, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_log_cb(rd_kafka_conf_t *conf, void (*log_cb)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));</span>
<span class="s1">void rd_kafka_conf_set_stats_cb(rd_kafka_conf_t *conf, int (*stats_cb)(rd_kafka_t *rk, char *json, size_t json_len, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_oauthbearer_token_refresh_cb(rd_kafka_conf_t *conf, void (*oauthbearer_token_refresh_cb)(rd_kafka_t *rk, const char *oauthbearer_config, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_socket_cb(rd_kafka_conf_t *conf, int (*socket_cb)(int domain, int type, int protocol, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_connect_cb(rd_kafka_conf_t *conf, int (*connect_cb)(int sockfd, const struct sockaddr *addr, int addrlen, const char *id, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_closesocket_cb(rd_kafka_conf_t *conf, int (*closesocket_cb)(int sockfd, void *opaque));</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert_verify_cb(rd_kafka_conf_t *conf, int (*ssl_cert_verify_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int *x509_error, int depth, const char *buf, size_t size, char *errstr, size_t errstr_size, void *opaque));</span>
<span class="s1">typedef enum rd_kafka_cert_type_t {</span>
<span class="s1">  RD_KAFKA_CERT_PUBLIC_KEY,</span>
<span class="s1">  RD_KAFKA_CERT_PRIVATE_KEY,</span>
<span class="s1">  RD_KAFKA_CERT_CA,</span>
<span class="s1">  RD_KAFKA_CERT__CNT,</span>
<span class="s1">} rd_kafka_cert_type_t;</span>
<span class="s1">typedef enum rd_kafka_cert_enc_t {</span>
<span class="s1">  RD_KAFKA_CERT_ENC_PKCS12,</span>
<span class="s1">  RD_KAFKA_CERT_ENC_DER,</span>
<span class="s1">  RD_KAFKA_CERT_ENC_PEM,</span>
<span class="s1">  RD_KAFKA_CERT_ENC__CNT,</span>
<span class="s1">} rd_kafka_cert_enc_t;</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert(rd_kafka_conf_t *conf, rd_kafka_cert_type_t cert_type, rd_kafka_cert_enc_t cert_enc, const void *buffer, size_t size, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_conf_set_opaque(rd_kafka_conf_t *conf, void *opaque);</span>
<span class="s1">void *rd_kafka_opaque(const rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_conf_set_default_topic_conf(rd_kafka_conf_t *conf, rd_kafka_topic_conf_t *tconf);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_get(const rd_kafka_conf_t *conf, const char *name, char *dest, size_t *dest_size);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_topic_conf_get(const rd_kafka_topic_conf_t *conf, const char *name, char *dest, size_t *dest_size);</span>
<span class="s1">const char **rd_kafka_conf_dump(rd_kafka_conf_t *conf, size_t *cntp);</span>
<span class="s1">const char **rd_kafka_topic_conf_dump(rd_kafka_topic_conf_t *conf, size_t *cntp);</span>
<span class="s1">void rd_kafka_conf_dump_free(const char **arr, size_t cnt);</span>
<span class="s1">void rd_kafka_conf_properties_show(FILE *fp);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_topic_conf_new(void);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_topic_conf_dup(const rd_kafka_topic_conf_t *conf);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_default_topic_conf_dup(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_topic_conf_destroy(rd_kafka_topic_conf_t *topic_conf);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_topic_conf_set(rd_kafka_topic_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_topic_conf_set_opaque(rd_kafka_topic_conf_t *conf, void *rkt_opaque);</span>
<span class="s1">void rd_kafka_topic_conf_set_partitioner_cb(rd_kafka_topic_conf_t *topic_conf, int32_t (*partitioner)(const rd_kafka_topic_t *rkt, const void *keydata, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque));</span>
<span class="s1">void rd_kafka_topic_conf_set_msg_order_cmp(rd_kafka_topic_conf_t *topic_conf, int (*msg_order_cmp)(const rd_kafka_message_t *a, const rd_kafka_message_t *b));</span>
<span class="s1">int rd_kafka_topic_partition_available(const rd_kafka_topic_t *rkt, int32_t partition);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_consistent(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_consistent_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_murmur2(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_murmur2_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">rd_kafka_t *rd_kafka_new(rd_kafka_type_t type, rd_kafka_conf_t *conf, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_destroy(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_destroy_flags(rd_kafka_t *rk, int flags);</span>
<span class="s1">const char *rd_kafka_name(const rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_type_t rd_kafka_type(const rd_kafka_t *rk);</span>
<span class="s1">char *rd_kafka_memberid(const rd_kafka_t *rk);</span>
<span class="s1">char *rd_kafka_clusterid(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">int32_t rd_kafka_controllerid(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_topic_t *rd_kafka_topic_new(rd_kafka_t *rk, const char *topic, rd_kafka_topic_conf_t *conf);</span>
<span class="s1">void rd_kafka_topic_destroy(rd_kafka_topic_t *rkt);</span>
<span class="s1">const char *rd_kafka_topic_name(const rd_kafka_topic_t *rkt);</span>
<span class="s1">void *rd_kafka_topic_opaque(const rd_kafka_topic_t *rkt);</span>
<span class="s1">int rd_kafka_poll(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">void rd_kafka_yield(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_pause_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_resume_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_query_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_get_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offsets_for_times(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets, int timeout_ms);</span>
<span class="s1">void rd_kafka_mem_free(rd_kafka_t *rk, void *ptr);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_new(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_queue_destroy(rd_kafka_queue_t *rkqu);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_main(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_consumer(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_partition(rd_kafka_t *rk, const char *topic, int32_t partition);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_background(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_queue_forward(rd_kafka_queue_t *src, rd_kafka_queue_t *dst);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_set_log_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu);</span>
<span class="s1">size_t rd_kafka_queue_length(rd_kafka_queue_t *rkqu);</span>
<span class="s1">void rd_kafka_queue_io_event_enable(rd_kafka_queue_t *rkqu, int fd, const void *payload, size_t size);</span>
<span class="s1">void rd_kafka_queue_cb_event_enable(rd_kafka_queue_t *rkqu, void (*event_cb)(rd_kafka_t *rk, void *qev_opaque), void *qev_opaque);</span>
<span class="s1">int rd_kafka_consume_start(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);</span>
<span class="s1">int rd_kafka_consume_start_queue(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, rd_kafka_queue_t *rkqu);</span>
<span class="s1">int rd_kafka_consume_stop(rd_kafka_topic_t *rkt, int32_t partition);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_seek(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, int timeout_ms);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consume(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms);</span>
<span class="s1">ssize_t rd_kafka_consume_batch(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);</span>
<span class="s1">int rd_kafka_consume_callback(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consume_queue(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">ssize_t rd_kafka_consume_batch_queue(rd_kafka_queue_t *rkqu, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);</span>
<span class="s1">int rd_kafka_consume_callback_queue(rd_kafka_queue_t *rkqu, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offset_store(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offsets_store(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_subscribe(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *topics);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_unsubscribe(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_subscription(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **topics);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consumer_poll(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_consumer_close(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_assignment(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, int async);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit_message(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, int async);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit_queue(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_queue_t *rkqu, void (*cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *commit_opaque), void *commit_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_committed(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_position(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">int rd_kafka_produce(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, void *payload, size_t len, const void *key, size_t keylen, void *msg_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_producev(rd_kafka_t *rk, ...);</span>
<span class="s1">int rd_kafka_produce_batch(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, rd_kafka_message_t *rkmessages, int message_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_flush(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_purge(rd_kafka_t *rk, int purge_flags);</span>
<span class="s1">typedef struct rd_kafka_metadata_broker {</span>
<span class="s1">  int32_t id;</span>
<span class="s1">  char *host;</span>
<span class="s1">  int port;</span>
<span class="s1">} rd_kafka_metadata_broker_t;</span>
<span class="s1">typedef struct rd_kafka_metadata_partition {</span>
<span class="s1">  int32_t id;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  int32_t leader;</span>
<span class="s1">  int replica_cnt;</span>
<span class="s1">  int32_t *replicas;</span>
<span class="s1">  int isr_cnt;</span>
<span class="s1">  int32_t *isrs;</span>
<span class="s1">} rd_kafka_metadata_partition_t;</span>
<span class="s1">typedef struct rd_kafka_metadata_topic {</span>
<span class="s1">  char *topic;</span>
<span class="s1">  int partition_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_partition *partitions;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">} rd_kafka_metadata_topic_t;</span>
<span class="s1">typedef struct rd_kafka_metadata {</span>
<span class="s1">  int broker_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_broker *brokers;</span>
<span class="s1">  int topic_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_topic *topics;</span>
<span class="s1">  int32_t orig_broker_id;</span>
<span class="s1">  char *orig_broker_name;</span>
<span class="s1">} rd_kafka_metadata_t;</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_metadata(rd_kafka_t *rk, int all_topics, rd_kafka_topic_t *only_rkt, const struct rd_kafka_metadata **metadatap, int timeout_ms);</span>
<span class="s1">void rd_kafka_metadata_destroy(const struct rd_kafka_metadata *metadata);</span>
<span class="s1">struct rd_kafka_group_member_info {</span>
<span class="s1">  char *member_id;</span>
<span class="s1">  char *client_id;</span>
<span class="s1">  char *client_host;</span>
<span class="s1">  void *member_metadata;</span>
<span class="s1">  int member_metadata_size;</span>
<span class="s1">  void *member_assignment;</span>
<span class="s1">  int member_assignment_size;</span>
<span class="s1">};</span>
<span class="s1">struct rd_kafka_group_info {</span>
<span class="s1">  struct rd_kafka_metadata_broker broker;</span>
<span class="s1">  char *group;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  char *state;</span>
<span class="s1">  char *protocol_type;</span>
<span class="s1">  char *protocol;</span>
<span class="s1">  struct rd_kafka_group_member_info *members;</span>
<span class="s1">  int member_cnt;</span>
<span class="s1">};</span>
<span class="s1">struct rd_kafka_group_list {</span>
<span class="s1">  struct rd_kafka_group_info *groups;</span>
<span class="s1">  int group_cnt;</span>
<span class="s1">};</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_list_groups(rd_kafka_t *rk, const char *group, const struct rd_kafka_group_list **grplistp, int timeout_ms);</span>
<span class="s1">void rd_kafka_group_list_destroy(const struct rd_kafka_group_list *grplist);</span>
<span class="s1">int rd_kafka_brokers_add(rd_kafka_t *rk, const char *brokerlist);</span>
<span class="s1">void rd_kafka_set_logger(rd_kafka_t *rk, void (*func)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));</span>
<span class="s1">void rd_kafka_set_log_level(rd_kafka_t *rk, int level);</span>
<span class="s1">void rd_kafka_log_print(const rd_kafka_t *rk, int level, const char *fac, const char *buf);</span>
<span class="s1">void rd_kafka_log_syslog(const rd_kafka_t *rk, int level, const char *fac, const char *buf);</span>
<span class="s1">int rd_kafka_outq_len(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_dump(FILE *fp, rd_kafka_t *rk);</span>
<span class="s1">int rd_kafka_thread_cnt(void);</span>
<span class="s1">typedef enum rd_kafka_thread_type_t {</span>
<span class="s1">  RD_KAFKA_THREAD_MAIN,</span>
<span class="s1">  RD_KAFKA_THREAD_BACKGROUND,</span>
<span class="s1">  RD_KAFKA_THREAD_BROKER,</span>
<span class="s1">} rd_kafka_thread_type_t;</span>
<span class="s1">int rd_kafka_wait_destroyed(int timeout_ms);</span>
<span class="s1">int rd_kafka_unittest(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_poll_set_consumer(rd_kafka_t *rk);</span>
<span class="s1">typedef int rd_kafka_event_type_t;</span>
<span class="s1">rd_kafka_event_type_t rd_kafka_event_type(const rd_kafka_event_t *rkev);</span>
<span class="s1">const char *rd_kafka_event_name(const rd_kafka_event_t *rkev);</span>
<span class="s1">void rd_kafka_event_destroy(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_message_t *rd_kafka_event_message_next(rd_kafka_event_t *rkev);</span>
<span class="s1">size_t rd_kafka_event_message_array(rd_kafka_event_t *rkev, const rd_kafka_message_t **rkmessages, size_t size);</span>
<span class="s1">size_t rd_kafka_event_message_count(rd_kafka_event_t *rkev);</span>
<span class="s1">const char *rd_kafka_event_config_string(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_event_error(rd_kafka_event_t *rkev);</span>
<span class="s1">const char *rd_kafka_event_error_string(rd_kafka_event_t *rkev);</span>
<span class="s1">int rd_kafka_event_error_is_fatal(rd_kafka_event_t *rkev);</span>
<span class="s1">void *rd_kafka_event_opaque(rd_kafka_event_t *rkev);</span>
<span class="s1">int rd_kafka_event_log(rd_kafka_event_t *rkev, const char **fac, const char **str, int *level);</span>
<span class="s1">const char *rd_kafka_event_stats(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_event_topic_partition_list(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_event_topic_partition(rd_kafka_event_t *rkev);</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_CreateTopics_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DeleteTopics_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_CreatePartitions_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_AlterConfigs_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DescribeConfigs_result_t;</span>
<span class="s1">const rd_kafka_CreateTopics_result_t *rd_kafka_event_CreateTopics_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DeleteTopics_result_t *rd_kafka_event_DeleteTopics_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_CreatePartitions_result_t *rd_kafka_event_CreatePartitions_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_AlterConfigs_result_t *rd_kafka_event_AlterConfigs_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DescribeConfigs_result_t *rd_kafka_event_DescribeConfigs_result(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_event_t *rd_kafka_queue_poll(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">int rd_kafka_queue_poll_callback(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_plugin_f_conf_init_t)(rd_kafka_conf_t *conf, void **plug_opaquep, char *errstr, size_t errstr_size);</span>
<span class="s1">typedef rd_kafka_conf_res_t (rd_kafka_interceptor_f_on_conf_set_t)(rd_kafka_conf_t *conf, const char *name, const char *val, char *errstr, size_t errstr_size, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_dup_t)(rd_kafka_conf_t *new_conf, const rd_kafka_conf_t *old_conf, size_t filter_cnt, const char **filter, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_destroy_t)(void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_new_t)(rd_kafka_t *rk, const rd_kafka_conf_t *conf, void *ic_opaque, char *errstr, size_t errstr_size);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_destroy_t)(rd_kafka_t *rk, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_send_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_acknowledgement_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_consume_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_commit_t)(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_resp_err_t err, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_request_sent_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_start_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_exit_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_set(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_set_t *on_conf_set, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_dup(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_dup_t *on_conf_dup, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_destroy(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_destroy_t *on_conf_destroy, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_new(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_new_t *on_new, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_destroy(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_destroy_t *on_destroy, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_send(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_send_t *on_send, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_acknowledgement(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_acknowledgement_t *on_acknowledgement, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_consume(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_consume_t *on_consume, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_commit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_commit_t *on_commit, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_request_sent(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_request_sent_t *on_request_sent, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_start(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_start_t *on_thread_start, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_exit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_exit_t *on_thread_exit, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_topic_result_error(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">const char *rd_kafka_topic_result_error_string(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">const char *rd_kafka_topic_result_name(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">typedef enum rd_kafka_admin_op_t {</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_ANY = 0,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_CREATETOPICS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DELETETOPICS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_CREATEPARTITIONS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_ALTERCONFIGS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DESCRIBECONFIGS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP__CNT,</span>
<span class="s1">} rd_kafka_admin_op_t;</span>
<span class="s1">typedef struct rd_kafka_AdminOptions_s rd_kafka_AdminOptions_t;</span>
<span class="s1">rd_kafka_AdminOptions_t *rd_kafka_AdminOptions_new(rd_kafka_t *rk, rd_kafka_admin_op_t for_api);</span>
<span class="s1">void rd_kafka_AdminOptions_destroy(rd_kafka_AdminOptions_t *options);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_request_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_operation_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_validate_only(rd_kafka_AdminOptions_t *options, int true_or_false, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_broker(rd_kafka_AdminOptions_t *options, int32_t broker_id, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_AdminOptions_set_opaque(rd_kafka_AdminOptions_t *options, void *ev_opaque);</span>
<span class="s1">typedef struct rd_kafka_NewTopic_s rd_kafka_NewTopic_t;</span>
<span class="s1">rd_kafka_NewTopic_t *rd_kafka_NewTopic_new(const char *topic, int num_partitions, int replication_factor, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_NewTopic_destroy(rd_kafka_NewTopic_t *new_topic);</span>
<span class="s1">void rd_kafka_NewTopic_destroy_array(rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewTopic_set_replica_assignment(rd_kafka_NewTopic_t *new_topic, int32_t partition, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewTopic_set_config(rd_kafka_NewTopic_t *new_topic, const char *name, const char *value);</span>
<span class="s1">void rd_kafka_CreateTopics(rd_kafka_t *rk, rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_CreateTopics_result_topics(const rd_kafka_CreateTopics_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_DeleteTopic_s rd_kafka_DeleteTopic_t;</span>
<span class="s1">rd_kafka_DeleteTopic_t *rd_kafka_DeleteTopic_new(const char *topic);</span>
<span class="s1">void rd_kafka_DeleteTopic_destroy(rd_kafka_DeleteTopic_t *del_topic);</span>
<span class="s1">void rd_kafka_DeleteTopic_destroy_array(rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt);</span>
<span class="s1">void rd_kafka_DeleteTopics(rd_kafka_t *rk, rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_DeleteTopics_result_topics(const rd_kafka_DeleteTopics_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_NewPartitions_s rd_kafka_NewPartitions_t;</span>
<span class="s1">rd_kafka_NewPartitions_t *rd_kafka_NewPartitions_new(const char *topic, size_t new_total_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_NewPartitions_destroy(rd_kafka_NewPartitions_t *new_parts);</span>
<span class="s1">void rd_kafka_NewPartitions_destroy_array(rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewPartitions_set_replica_assignment(rd_kafka_NewPartitions_t *new_parts, int32_t new_partition_idx, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_CreatePartitions(rd_kafka_t *rk, rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_CreatePartitions_result_topics(const rd_kafka_CreatePartitions_result_t *result, size_t *cntp);</span>
<span class="s1">typedef enum rd_kafka_ConfigSource_t {</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_UNKNOWN_CONFIG = 0,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_TOPIC_CONFIG = 1,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_BROKER_CONFIG = 2,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_DEFAULT_BROKER_CONFIG = 3,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_STATIC_BROKER_CONFIG = 4,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DEFAULT_CONFIG = 5,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE__CNT,</span>
<span class="s1">} rd_kafka_ConfigSource_t;</span>
<span class="s1">const char *rd_kafka_ConfigSource_name(rd_kafka_ConfigSource_t confsource);</span>
<span class="s1">typedef struct rd_kafka_ConfigEntry_s rd_kafka_ConfigEntry_t;</span>
<span class="s1">const char *rd_kafka_ConfigEntry_name(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">const char *rd_kafka_ConfigEntry_value(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">rd_kafka_ConfigSource_t rd_kafka_ConfigEntry_source(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_read_only(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_default(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_sensitive(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_synonym(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">const rd_kafka_ConfigEntry_t **rd_kafka_ConfigEntry_synonyms(const rd_kafka_ConfigEntry_t *entry, size_t *cntp);</span>
<span class="s1">typedef enum rd_kafka_ResourceType_t {</span>
<span class="s1">  RD_KAFKA_RESOURCE_UNKNOWN = 0,</span>
<span class="s1">  RD_KAFKA_RESOURCE_ANY = 1,</span>
<span class="s1">  RD_KAFKA_RESOURCE_TOPIC = 2,</span>
<span class="s1">  RD_KAFKA_RESOURCE_GROUP = 3,</span>
<span class="s1">  RD_KAFKA_RESOURCE_BROKER = 4,</span>
<span class="s1">  RD_KAFKA_RESOURCE__CNT,</span>
<span class="s1">} rd_kafka_ResourceType_t;</span>
<span class="s1">const char *rd_kafka_ResourceType_name(rd_kafka_ResourceType_t restype);</span>
<span class="s1">typedef struct rd_kafka_ConfigResource_s rd_kafka_ConfigResource_t;</span>
<span class="s1">rd_kafka_ConfigResource_t *rd_kafka_ConfigResource_new(rd_kafka_ResourceType_t restype, const char *resname);</span>
<span class="s1">void rd_kafka_ConfigResource_destroy(rd_kafka_ConfigResource_t *config);</span>
<span class="s1">void rd_kafka_ConfigResource_destroy_array(rd_kafka_ConfigResource_t **config, size_t config_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_ConfigResource_set_config(rd_kafka_ConfigResource_t *config, const char *name, const char *value);</span>
<span class="s1">const rd_kafka_ConfigEntry_t **rd_kafka_ConfigResource_configs(const rd_kafka_ConfigResource_t *config, size_t *cntp);</span>
<span class="s1">rd_kafka_ResourceType_t rd_kafka_ConfigResource_type(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">const char *rd_kafka_ConfigResource_name(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_ConfigResource_error(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">const char *rd_kafka_ConfigResource_error_string(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">void rd_kafka_AlterConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_ConfigResource_t **rd_kafka_AlterConfigs_result_resources(const rd_kafka_AlterConfigs_result_t *result, size_t *cntp);</span>
<span class="s1">void rd_kafka_DescribeConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_ConfigResource_t **rd_kafka_DescribeConfigs_result_resources(const rd_kafka_DescribeConfigs_result_t *result, size_t *cntp);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token(rd_kafka_t *rk, const char *token_value, int64_t md_lifetime_ms, const char *md_principal_name, const char **extensions, size_t extension_size, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token_failure(rd_kafka_t *rk, const char *errstr);</span>
<span class="s1">&#39;</span>
</code></pre></div>
rdkafka.h, rdkafka_mock.h</p>
<h3 id="rd_kafka_version_6">RD_KAFKA_VERSION<a class="headerlink" href="#rd_kafka_version_6" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_VERSION</span> <span class="o">=</span> <span class="mi">16974079</span>
</code></pre></div>
<p>librdkafka version </p>
<p>Interpreted as hex <code>MM.mm.rr.xx</code>:</p>
<ul>
<li>MM = Major</li>
<li>mm = minor</li>
<li>rr = revision</li>
<li>xx = pre-release id (0xff is the final release)</li>
</ul>
<p>E.g.: <code>0x000801ff</code> = 0.8.1</p>
<dl class="section remark"><dt>Remarks</dt><dd>This value should only be used during compile time, for runtime checks of version use rd_kafka_version() </dd></dl>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_unsupported_compression_type_6">RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE<a class="headerlink" href="#rd_kafka_resp_err_unsupported_compression_type_6" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE</span> <span class="o">=</span> <span class="mi">76</span>
</code></pre></div>
<p>Unsupported compression type </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_end_all_6">RD_KAFKA_RESP_ERR_END_ALL<a class="headerlink" href="#rd_kafka_resp_err_end_all_6" title="Permanent link">&para;</a></h3>
<p><div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_END_ALL</span> <span class="o">=</span> <span class="mi">82</span>
</code></pre></div>
enum rd_kafka_resp_err_t</p>
<h3 id="rd_kafka_admin_op__cnt_6">RD_KAFKA_ADMIN_OP__CNT<a class="headerlink" href="#rd_kafka_admin_op__cnt_6" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_ADMIN_OP__CNT</span> <span class="o">=</span> <span class="mi">6</span>
</code></pre></div>
<p>Number of ops defined </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe </a></li>
</ul>
</div>
<h3 id="rd_kafka_resource__cnt_6">RD_KAFKA_RESOURCE__CNT<a class="headerlink" href="#rd_kafka_resource__cnt_6" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESOURCE__CNT</span> <span class="o">=</span> <span class="mi">5</span>
</code></pre></div>
<p>Number of resource types defined </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#acca83a66d7783ff7683ed2691cc907c9"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#acca83a66d7783ff7683ed2691cc907c9 </a></li>
</ul>
</div>
<h3 id="rd_kafka_cdef_6">RD_KAFKA_CDEF<a class="headerlink" href="#rd_kafka_cdef_6" title="Permanent link">&para;</a></h3>
<p><div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_CDEF</span> <span class="o">=</span> <span class="s1">&#39;typedef long int ssize_t;</span>
<span class="s1">typedef struct _IO_FILE FILE;</span>
<span class="s1">typedef long int mode_t;</span>
<span class="s1">typedef signed int int16_t;</span>
<span class="s1">typedef unsigned int uint16_t;</span>
<span class="s1">typedef signed int int32_t;</span>
<span class="s1">typedef signed long int int64_t;</span>
<span class="s1">int rd_kafka_version(void);</span>
<span class="s1">const char *rd_kafka_version_str(void);</span>
<span class="s1">typedef enum rd_kafka_type_t {</span>
<span class="s1">  RD_KAFKA_PRODUCER,</span>
<span class="s1">  RD_KAFKA_CONSUMER,</span>
<span class="s1">} rd_kafka_type_t;</span>
<span class="s1">typedef enum rd_kafka_timestamp_type_t {</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_NOT_AVAILABLE,</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_CREATE_TIME,</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_LOG_APPEND_TIME,</span>
<span class="s1">} rd_kafka_timestamp_type_t;</span>
<span class="s1">const char *rd_kafka_get_debug_contexts(void);</span>
<span class="s1">typedef struct rd_kafka_s rd_kafka_t;</span>
<span class="s1">typedef struct rd_kafka_topic_s rd_kafka_topic_t;</span>
<span class="s1">typedef struct rd_kafka_conf_s rd_kafka_conf_t;</span>
<span class="s1">typedef struct rd_kafka_topic_conf_s rd_kafka_topic_conf_t;</span>
<span class="s1">typedef struct rd_kafka_queue_s rd_kafka_queue_t;</span>
<span class="s1">typedef struct rd_kafka_op_s rd_kafka_event_t;</span>
<span class="s1">typedef struct rd_kafka_topic_result_s rd_kafka_topic_result_t;</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BEGIN = (- 200),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BAD_MSG = (- 199),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BAD_COMPRESSION = (- 198),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__DESTROY = (- 197),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FAIL = (- 196),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TRANSPORT = (- 195),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__CRIT_SYS_RESOURCE = (- 194),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__RESOLVE = (- 193),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__MSG_TIMED_OUT = (- 192),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PARTITION_EOF = (- 191),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION = (- 190),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FS = (- 189),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC = (- 188),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ALL_BROKERS_DOWN = (- 187),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INVALID_ARG = (- 186),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TIMED_OUT = (- 185),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__QUEUE_FULL = (- 184),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ISR_INSUFF = (- 183),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NODE_UPDATE = (- 182),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__SSL = (- 181),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__WAIT_COORD = (- 180),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_GROUP = (- 179),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__IN_PROGRESS = (- 178),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PREV_IN_PROGRESS = (- 177),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__EXISTING_SUBSCRIPTION = (- 176),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS = (- 175),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS = (- 174),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__CONFLICT = (- 173),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__STATE = (- 172),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_PROTOCOL = (- 171),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED = (- 170),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__AUTHENTICATION = (- 169),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NO_OFFSET = (- 168),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__OUTDATED = (- 167),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TIMED_OUT_QUEUE = (- 166),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNSUPPORTED_FEATURE = (- 165),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__WAIT_CACHE = (- 164),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INTR = (- 163),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__KEY_SERIALIZATION = (- 162),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__VALUE_SERIALIZATION = (- 161),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__KEY_DESERIALIZATION = (- 160),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__VALUE_DESERIALIZATION = (- 159),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PARTIAL = (- 158),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__READ_ONLY = (- 157),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOENT = (- 156),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNDERFLOW = (- 155),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INVALID_TYPE = (- 154),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__RETRY = (- 153),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PURGE_QUEUE = (- 152),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PURGE_INFLIGHT = (- 151),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FATAL = (- 150),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INCONSISTENT = (- 149),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__GAPLESS_GUARANTEE = (- 148),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__MAX_POLL_EXCEEDED = (- 147),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_BROKER = (- 146),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__END = (- 100),</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN = (- 1),</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NO_ERROR = 0,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_OUT_OF_RANGE = 1,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_MSG = 2,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART = 3,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_MSG_SIZE = 4,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE = 5,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_LEADER_FOR_PARTITION = 6,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REQUEST_TIMED_OUT = 7,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_BROKER_NOT_AVAILABLE = 8,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REPLICA_NOT_AVAILABLE = 9,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE = 10,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_STALE_CTRL_EPOCH = 11,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_METADATA_TOO_LARGE = 12,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NETWORK_EXCEPTION = 13,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_COORDINATOR_LOAD_IN_PROGRESS = 14,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_COORDINATOR_NOT_AVAILABLE = 15,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_COORDINATOR = 16,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_EXCEPTION = 17,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_RECORD_LIST_TOO_LARGE = 18,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS = 19,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS_AFTER_APPEND = 20,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REQUIRED_ACKS = 21,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ILLEGAL_GENERATION = 22,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INCONSISTENT_GROUP_PROTOCOL = 23,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_GROUP_ID = 24,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_MEMBER_ID = 25,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_SESSION_TIMEOUT = 26,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REBALANCE_IN_PROGRESS = 27,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_COMMIT_OFFSET_SIZE = 28,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_AUTHORIZATION_FAILED = 29,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_AUTHORIZATION_FAILED = 30,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_CLUSTER_AUTHORIZATION_FAILED = 31,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TIMESTAMP = 32,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_SASL_MECHANISM = 33,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ILLEGAL_SASL_STATE = 34,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_VERSION = 35,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_ALREADY_EXISTS = 36,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PARTITIONS = 37,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REPLICATION_FACTOR = 38,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REPLICA_ASSIGNMENT = 39,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_CONFIG = 40,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_CONTROLLER = 41,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REQUEST = 42,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_FOR_MESSAGE_FORMAT = 43,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_POLICY_VIOLATION = 44,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OUT_OF_ORDER_SEQUENCE_NUMBER = 45,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DUPLICATE_SEQUENCE_NUMBER = 46,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_EPOCH = 47,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TXN_STATE = 48,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_ID_MAPPING = 49,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TRANSACTION_TIMEOUT = 50,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_CONCURRENT_TRANSACTIONS = 51,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TRANSACTION_COORDINATOR_FENCED = 52,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TRANSACTIONAL_ID_AUTHORIZATION_FAILED = 53,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_SECURITY_DISABLED = 54,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OPERATION_NOT_ATTEMPTED = 55,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_KAFKA_STORAGE_ERROR = 56,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LOG_DIR_NOT_FOUND = 57,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_SASL_AUTHENTICATION_FAILED = 58,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_PRODUCER_ID = 59,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REASSIGNMENT_IN_PROGRESS = 60,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTH_DISABLED = 61,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_NOT_FOUND = 62,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_OWNER_MISMATCH = 63,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_REQUEST_NOT_ALLOWED = 64,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTHORIZATION_FAILED = 65,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_EXPIRED = 66,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRINCIPAL_TYPE = 67,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NON_EMPTY_GROUP = 68,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_ID_NOT_FOUND = 69,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FETCH_SESSION_ID_NOT_FOUND = 70,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_FETCH_SESSION_EPOCH = 71,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LISTENER_NOT_FOUND = 72,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_DELETION_DISABLED = 73,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FENCED_LEADER_EPOCH = 74,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_LEADER_EPOCH = 75,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_STALE_BROKER_EPOCH = 77,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_NOT_AVAILABLE = 78,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_MEMBER_ID_REQUIRED = 79,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_PREFERRED_LEADER_NOT_AVAILABLE = 80,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_MAX_SIZE_REACHED = 81,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_END_ALL,</span>
<span class="s1">} rd_kafka_resp_err_t;</span>
<span class="s1">struct rd_kafka_err_desc {</span>
<span class="s1">  rd_kafka_resp_err_t code;</span>
<span class="s1">  char *name;</span>
<span class="s1">  char *desc;</span>
<span class="s1">};</span>
<span class="s1">void rd_kafka_get_err_descs(const struct rd_kafka_err_desc **errdescs, size_t *cntp);</span>
<span class="s1">const char *rd_kafka_err2str(rd_kafka_resp_err_t err);</span>
<span class="s1">const char *rd_kafka_err2name(rd_kafka_resp_err_t err);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_last_error(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_errno2err(int errnox);</span>
<span class="s1">int rd_kafka_errno(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_fatal_error(rd_kafka_t *rk, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_test_fatal_error(rd_kafka_t *rk, rd_kafka_resp_err_t err, const char *reason);</span>
<span class="s1">typedef struct rd_kafka_topic_partition_s {</span>
<span class="s1">  char *topic;</span>
<span class="s1">  int32_t partition;</span>
<span class="s1">  int64_t offset;</span>
<span class="s1">  void *metadata;</span>
<span class="s1">  size_t metadata_size;</span>
<span class="s1">  void *opaque;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  void *_private;</span>
<span class="s1">} rd_kafka_topic_partition_t;</span>
<span class="s1">void rd_kafka_topic_partition_destroy(rd_kafka_topic_partition_t *rktpar);</span>
<span class="s1">typedef struct rd_kafka_topic_partition_list_s {</span>
<span class="s1">  int cnt;</span>
<span class="s1">  int size;</span>
<span class="s1">  rd_kafka_topic_partition_t *elems;</span>
<span class="s1">} rd_kafka_topic_partition_list_t;</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_new(int size);</span>
<span class="s1">void rd_kafka_topic_partition_list_destroy(rd_kafka_topic_partition_list_t *rkparlist);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_add(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">void rd_kafka_topic_partition_list_add_range(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t start, int32_t stop);</span>
<span class="s1">int rd_kafka_topic_partition_list_del(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">int rd_kafka_topic_partition_list_del_by_idx(rd_kafka_topic_partition_list_t *rktparlist, int idx);</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_copy(const rd_kafka_topic_partition_list_t *src);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_topic_partition_list_set_offset(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition, int64_t offset);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_find(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">void rd_kafka_topic_partition_list_sort(rd_kafka_topic_partition_list_t *rktparlist, int (*cmp)(const void *a, const void *b, void *cmp_opaque), void *cmp_opaque);</span>
<span class="s1">typedef enum rd_kafka_vtype_t {</span>
<span class="s1">  RD_KAFKA_VTYPE_END,</span>
<span class="s1">  RD_KAFKA_VTYPE_TOPIC,</span>
<span class="s1">  RD_KAFKA_VTYPE_RKT,</span>
<span class="s1">  RD_KAFKA_VTYPE_PARTITION,</span>
<span class="s1">  RD_KAFKA_VTYPE_VALUE,</span>
<span class="s1">  RD_KAFKA_VTYPE_KEY,</span>
<span class="s1">  RD_KAFKA_VTYPE_OPAQUE,</span>
<span class="s1">  RD_KAFKA_VTYPE_MSGFLAGS,</span>
<span class="s1">  RD_KAFKA_VTYPE_TIMESTAMP,</span>
<span class="s1">  RD_KAFKA_VTYPE_HEADER,</span>
<span class="s1">  RD_KAFKA_VTYPE_HEADERS,</span>
<span class="s1">} rd_kafka_vtype_t;</span>
<span class="s1">typedef struct rd_kafka_headers_s rd_kafka_headers_t;</span>
<span class="s1">rd_kafka_headers_t *rd_kafka_headers_new(size_t initial_count);</span>
<span class="s1">void rd_kafka_headers_destroy(rd_kafka_headers_t *hdrs);</span>
<span class="s1">rd_kafka_headers_t *rd_kafka_headers_copy(const rd_kafka_headers_t *src);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_add(rd_kafka_headers_t *hdrs, const char *name, ssize_t name_size, const void *value, ssize_t value_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_remove(rd_kafka_headers_t *hdrs, const char *name);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get_last(const rd_kafka_headers_t *hdrs, const char *name, const void **valuep, size_t *sizep);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get(const rd_kafka_headers_t *hdrs, size_t idx, const char *name, const void **valuep, size_t *sizep);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get_all(const rd_kafka_headers_t *hdrs, size_t idx, const char **namep, const void **valuep, size_t *sizep);</span>
<span class="s1">typedef struct rd_kafka_message_s {</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  rd_kafka_topic_t *rkt;</span>
<span class="s1">  int32_t partition;</span>
<span class="s1">  void *payload;</span>
<span class="s1">  size_t len;</span>
<span class="s1">  void *key;</span>
<span class="s1">  size_t key_len;</span>
<span class="s1">  int64_t offset;</span>
<span class="s1">  void *_private;</span>
<span class="s1">} rd_kafka_message_t;</span>
<span class="s1">void rd_kafka_message_destroy(rd_kafka_message_t *rkmessage);</span>
<span class="s1">int64_t rd_kafka_message_timestamp(const rd_kafka_message_t *rkmessage, rd_kafka_timestamp_type_t *tstype);</span>
<span class="s1">int64_t rd_kafka_message_latency(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_message_headers(const rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_message_detach_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);</span>
<span class="s1">void rd_kafka_message_set_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t *hdrs);</span>
<span class="s1">size_t rd_kafka_header_cnt(const rd_kafka_headers_t *hdrs);</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_NOT_PERSISTED = 0,</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_POSSIBLY_PERSISTED = 1,</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_PERSISTED = 2,</span>
<span class="s1">} rd_kafka_msg_status_t;</span>
<span class="s1">rd_kafka_msg_status_t rd_kafka_message_status(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_CONF_UNKNOWN = (- 2),</span>
<span class="s1">  RD_KAFKA_CONF_INVALID = (- 1),</span>
<span class="s1">  RD_KAFKA_CONF_OK = 0,</span>
<span class="s1">} rd_kafka_conf_res_t;</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_new(void);</span>
<span class="s1">void rd_kafka_conf_destroy(rd_kafka_conf_t *conf);</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_dup(const rd_kafka_conf_t *conf);</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_dup_filter(const rd_kafka_conf_t *conf, size_t filter_cnt, const char **filter);</span>
<span class="s1">const rd_kafka_conf_t *rd_kafka_conf(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_set(rd_kafka_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_conf_set_events(rd_kafka_conf_t *conf, int events);</span>
<span class="s1">void rd_kafka_conf_set_background_event_cb(rd_kafka_conf_t *conf, void (*event_cb)(rd_kafka_t *rk, rd_kafka_event_t *rkev, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_dr_cb(rd_kafka_conf_t *conf, void (*dr_cb)(rd_kafka_t *rk, void *payload, size_t len, rd_kafka_resp_err_t err, void *opaque, void *msg_opaque));</span>
<span class="s1">void rd_kafka_conf_set_dr_msg_cb(rd_kafka_conf_t *conf, void (*dr_msg_cb)(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_consume_cb(rd_kafka_conf_t *conf, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_rebalance_cb(rd_kafka_conf_t *conf, void (*rebalance_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *partitions, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_offset_commit_cb(rd_kafka_conf_t *conf, void (*offset_commit_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_error_cb(rd_kafka_conf_t *conf, void (*error_cb)(rd_kafka_t *rk, int err, const char *reason, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_throttle_cb(rd_kafka_conf_t *conf, void (*throttle_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int throttle_time_ms, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_log_cb(rd_kafka_conf_t *conf, void (*log_cb)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));</span>
<span class="s1">void rd_kafka_conf_set_stats_cb(rd_kafka_conf_t *conf, int (*stats_cb)(rd_kafka_t *rk, char *json, size_t json_len, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_oauthbearer_token_refresh_cb(rd_kafka_conf_t *conf, void (*oauthbearer_token_refresh_cb)(rd_kafka_t *rk, const char *oauthbearer_config, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_socket_cb(rd_kafka_conf_t *conf, int (*socket_cb)(int domain, int type, int protocol, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_connect_cb(rd_kafka_conf_t *conf, int (*connect_cb)(int sockfd, const struct sockaddr *addr, int addrlen, const char *id, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_closesocket_cb(rd_kafka_conf_t *conf, int (*closesocket_cb)(int sockfd, void *opaque));</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert_verify_cb(rd_kafka_conf_t *conf, int (*ssl_cert_verify_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int *x509_error, int depth, const char *buf, size_t size, char *errstr, size_t errstr_size, void *opaque));</span>
<span class="s1">typedef enum rd_kafka_cert_type_t {</span>
<span class="s1">  RD_KAFKA_CERT_PUBLIC_KEY,</span>
<span class="s1">  RD_KAFKA_CERT_PRIVATE_KEY,</span>
<span class="s1">  RD_KAFKA_CERT_CA,</span>
<span class="s1">  RD_KAFKA_CERT__CNT,</span>
<span class="s1">} rd_kafka_cert_type_t;</span>
<span class="s1">typedef enum rd_kafka_cert_enc_t {</span>
<span class="s1">  RD_KAFKA_CERT_ENC_PKCS12,</span>
<span class="s1">  RD_KAFKA_CERT_ENC_DER,</span>
<span class="s1">  RD_KAFKA_CERT_ENC_PEM,</span>
<span class="s1">  RD_KAFKA_CERT_ENC__CNT,</span>
<span class="s1">} rd_kafka_cert_enc_t;</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert(rd_kafka_conf_t *conf, rd_kafka_cert_type_t cert_type, rd_kafka_cert_enc_t cert_enc, const void *buffer, size_t size, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_conf_set_opaque(rd_kafka_conf_t *conf, void *opaque);</span>
<span class="s1">void *rd_kafka_opaque(const rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_conf_set_default_topic_conf(rd_kafka_conf_t *conf, rd_kafka_topic_conf_t *tconf);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_get(const rd_kafka_conf_t *conf, const char *name, char *dest, size_t *dest_size);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_topic_conf_get(const rd_kafka_topic_conf_t *conf, const char *name, char *dest, size_t *dest_size);</span>
<span class="s1">const char **rd_kafka_conf_dump(rd_kafka_conf_t *conf, size_t *cntp);</span>
<span class="s1">const char **rd_kafka_topic_conf_dump(rd_kafka_topic_conf_t *conf, size_t *cntp);</span>
<span class="s1">void rd_kafka_conf_dump_free(const char **arr, size_t cnt);</span>
<span class="s1">void rd_kafka_conf_properties_show(FILE *fp);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_topic_conf_new(void);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_topic_conf_dup(const rd_kafka_topic_conf_t *conf);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_default_topic_conf_dup(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_topic_conf_destroy(rd_kafka_topic_conf_t *topic_conf);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_topic_conf_set(rd_kafka_topic_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_topic_conf_set_opaque(rd_kafka_topic_conf_t *conf, void *rkt_opaque);</span>
<span class="s1">void rd_kafka_topic_conf_set_partitioner_cb(rd_kafka_topic_conf_t *topic_conf, int32_t (*partitioner)(const rd_kafka_topic_t *rkt, const void *keydata, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque));</span>
<span class="s1">void rd_kafka_topic_conf_set_msg_order_cmp(rd_kafka_topic_conf_t *topic_conf, int (*msg_order_cmp)(const rd_kafka_message_t *a, const rd_kafka_message_t *b));</span>
<span class="s1">int rd_kafka_topic_partition_available(const rd_kafka_topic_t *rkt, int32_t partition);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_consistent(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_consistent_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_murmur2(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_murmur2_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">rd_kafka_t *rd_kafka_new(rd_kafka_type_t type, rd_kafka_conf_t *conf, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_destroy(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_destroy_flags(rd_kafka_t *rk, int flags);</span>
<span class="s1">const char *rd_kafka_name(const rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_type_t rd_kafka_type(const rd_kafka_t *rk);</span>
<span class="s1">char *rd_kafka_memberid(const rd_kafka_t *rk);</span>
<span class="s1">char *rd_kafka_clusterid(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">int32_t rd_kafka_controllerid(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_topic_t *rd_kafka_topic_new(rd_kafka_t *rk, const char *topic, rd_kafka_topic_conf_t *conf);</span>
<span class="s1">void rd_kafka_topic_destroy(rd_kafka_topic_t *rkt);</span>
<span class="s1">const char *rd_kafka_topic_name(const rd_kafka_topic_t *rkt);</span>
<span class="s1">void *rd_kafka_topic_opaque(const rd_kafka_topic_t *rkt);</span>
<span class="s1">int rd_kafka_poll(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">void rd_kafka_yield(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_pause_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_resume_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_query_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_get_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offsets_for_times(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets, int timeout_ms);</span>
<span class="s1">void rd_kafka_mem_free(rd_kafka_t *rk, void *ptr);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_new(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_queue_destroy(rd_kafka_queue_t *rkqu);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_main(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_consumer(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_partition(rd_kafka_t *rk, const char *topic, int32_t partition);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_background(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_queue_forward(rd_kafka_queue_t *src, rd_kafka_queue_t *dst);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_set_log_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu);</span>
<span class="s1">size_t rd_kafka_queue_length(rd_kafka_queue_t *rkqu);</span>
<span class="s1">void rd_kafka_queue_io_event_enable(rd_kafka_queue_t *rkqu, int fd, const void *payload, size_t size);</span>
<span class="s1">void rd_kafka_queue_cb_event_enable(rd_kafka_queue_t *rkqu, void (*event_cb)(rd_kafka_t *rk, void *qev_opaque), void *qev_opaque);</span>
<span class="s1">int rd_kafka_consume_start(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);</span>
<span class="s1">int rd_kafka_consume_start_queue(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, rd_kafka_queue_t *rkqu);</span>
<span class="s1">int rd_kafka_consume_stop(rd_kafka_topic_t *rkt, int32_t partition);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_seek(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, int timeout_ms);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consume(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms);</span>
<span class="s1">ssize_t rd_kafka_consume_batch(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);</span>
<span class="s1">int rd_kafka_consume_callback(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consume_queue(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">ssize_t rd_kafka_consume_batch_queue(rd_kafka_queue_t *rkqu, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);</span>
<span class="s1">int rd_kafka_consume_callback_queue(rd_kafka_queue_t *rkqu, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offset_store(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offsets_store(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_subscribe(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *topics);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_unsubscribe(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_subscription(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **topics);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consumer_poll(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_consumer_close(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_assignment(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, int async);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit_message(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, int async);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit_queue(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_queue_t *rkqu, void (*cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *commit_opaque), void *commit_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_committed(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_position(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">int rd_kafka_produce(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, void *payload, size_t len, const void *key, size_t keylen, void *msg_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_producev(rd_kafka_t *rk, ...);</span>
<span class="s1">int rd_kafka_produce_batch(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, rd_kafka_message_t *rkmessages, int message_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_flush(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_purge(rd_kafka_t *rk, int purge_flags);</span>
<span class="s1">typedef struct rd_kafka_metadata_broker {</span>
<span class="s1">  int32_t id;</span>
<span class="s1">  char *host;</span>
<span class="s1">  int port;</span>
<span class="s1">} rd_kafka_metadata_broker_t;</span>
<span class="s1">typedef struct rd_kafka_metadata_partition {</span>
<span class="s1">  int32_t id;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  int32_t leader;</span>
<span class="s1">  int replica_cnt;</span>
<span class="s1">  int32_t *replicas;</span>
<span class="s1">  int isr_cnt;</span>
<span class="s1">  int32_t *isrs;</span>
<span class="s1">} rd_kafka_metadata_partition_t;</span>
<span class="s1">typedef struct rd_kafka_metadata_topic {</span>
<span class="s1">  char *topic;</span>
<span class="s1">  int partition_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_partition *partitions;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">} rd_kafka_metadata_topic_t;</span>
<span class="s1">typedef struct rd_kafka_metadata {</span>
<span class="s1">  int broker_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_broker *brokers;</span>
<span class="s1">  int topic_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_topic *topics;</span>
<span class="s1">  int32_t orig_broker_id;</span>
<span class="s1">  char *orig_broker_name;</span>
<span class="s1">} rd_kafka_metadata_t;</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_metadata(rd_kafka_t *rk, int all_topics, rd_kafka_topic_t *only_rkt, const struct rd_kafka_metadata **metadatap, int timeout_ms);</span>
<span class="s1">void rd_kafka_metadata_destroy(const struct rd_kafka_metadata *metadata);</span>
<span class="s1">struct rd_kafka_group_member_info {</span>
<span class="s1">  char *member_id;</span>
<span class="s1">  char *client_id;</span>
<span class="s1">  char *client_host;</span>
<span class="s1">  void *member_metadata;</span>
<span class="s1">  int member_metadata_size;</span>
<span class="s1">  void *member_assignment;</span>
<span class="s1">  int member_assignment_size;</span>
<span class="s1">};</span>
<span class="s1">struct rd_kafka_group_info {</span>
<span class="s1">  struct rd_kafka_metadata_broker broker;</span>
<span class="s1">  char *group;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  char *state;</span>
<span class="s1">  char *protocol_type;</span>
<span class="s1">  char *protocol;</span>
<span class="s1">  struct rd_kafka_group_member_info *members;</span>
<span class="s1">  int member_cnt;</span>
<span class="s1">};</span>
<span class="s1">struct rd_kafka_group_list {</span>
<span class="s1">  struct rd_kafka_group_info *groups;</span>
<span class="s1">  int group_cnt;</span>
<span class="s1">};</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_list_groups(rd_kafka_t *rk, const char *group, const struct rd_kafka_group_list **grplistp, int timeout_ms);</span>
<span class="s1">void rd_kafka_group_list_destroy(const struct rd_kafka_group_list *grplist);</span>
<span class="s1">int rd_kafka_brokers_add(rd_kafka_t *rk, const char *brokerlist);</span>
<span class="s1">void rd_kafka_set_logger(rd_kafka_t *rk, void (*func)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));</span>
<span class="s1">void rd_kafka_set_log_level(rd_kafka_t *rk, int level);</span>
<span class="s1">void rd_kafka_log_print(const rd_kafka_t *rk, int level, const char *fac, const char *buf);</span>
<span class="s1">void rd_kafka_log_syslog(const rd_kafka_t *rk, int level, const char *fac, const char *buf);</span>
<span class="s1">int rd_kafka_outq_len(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_dump(FILE *fp, rd_kafka_t *rk);</span>
<span class="s1">int rd_kafka_thread_cnt(void);</span>
<span class="s1">typedef enum rd_kafka_thread_type_t {</span>
<span class="s1">  RD_KAFKA_THREAD_MAIN,</span>
<span class="s1">  RD_KAFKA_THREAD_BACKGROUND,</span>
<span class="s1">  RD_KAFKA_THREAD_BROKER,</span>
<span class="s1">} rd_kafka_thread_type_t;</span>
<span class="s1">int rd_kafka_wait_destroyed(int timeout_ms);</span>
<span class="s1">int rd_kafka_unittest(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_poll_set_consumer(rd_kafka_t *rk);</span>
<span class="s1">typedef int rd_kafka_event_type_t;</span>
<span class="s1">rd_kafka_event_type_t rd_kafka_event_type(const rd_kafka_event_t *rkev);</span>
<span class="s1">const char *rd_kafka_event_name(const rd_kafka_event_t *rkev);</span>
<span class="s1">void rd_kafka_event_destroy(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_message_t *rd_kafka_event_message_next(rd_kafka_event_t *rkev);</span>
<span class="s1">size_t rd_kafka_event_message_array(rd_kafka_event_t *rkev, const rd_kafka_message_t **rkmessages, size_t size);</span>
<span class="s1">size_t rd_kafka_event_message_count(rd_kafka_event_t *rkev);</span>
<span class="s1">const char *rd_kafka_event_config_string(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_event_error(rd_kafka_event_t *rkev);</span>
<span class="s1">const char *rd_kafka_event_error_string(rd_kafka_event_t *rkev);</span>
<span class="s1">int rd_kafka_event_error_is_fatal(rd_kafka_event_t *rkev);</span>
<span class="s1">void *rd_kafka_event_opaque(rd_kafka_event_t *rkev);</span>
<span class="s1">int rd_kafka_event_log(rd_kafka_event_t *rkev, const char **fac, const char **str, int *level);</span>
<span class="s1">const char *rd_kafka_event_stats(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_event_topic_partition_list(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_event_topic_partition(rd_kafka_event_t *rkev);</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_CreateTopics_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DeleteTopics_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_CreatePartitions_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_AlterConfigs_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DescribeConfigs_result_t;</span>
<span class="s1">const rd_kafka_CreateTopics_result_t *rd_kafka_event_CreateTopics_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DeleteTopics_result_t *rd_kafka_event_DeleteTopics_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_CreatePartitions_result_t *rd_kafka_event_CreatePartitions_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_AlterConfigs_result_t *rd_kafka_event_AlterConfigs_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DescribeConfigs_result_t *rd_kafka_event_DescribeConfigs_result(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_event_t *rd_kafka_queue_poll(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">int rd_kafka_queue_poll_callback(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_plugin_f_conf_init_t)(rd_kafka_conf_t *conf, void **plug_opaquep, char *errstr, size_t errstr_size);</span>
<span class="s1">typedef rd_kafka_conf_res_t (rd_kafka_interceptor_f_on_conf_set_t)(rd_kafka_conf_t *conf, const char *name, const char *val, char *errstr, size_t errstr_size, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_dup_t)(rd_kafka_conf_t *new_conf, const rd_kafka_conf_t *old_conf, size_t filter_cnt, const char **filter, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_destroy_t)(void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_new_t)(rd_kafka_t *rk, const rd_kafka_conf_t *conf, void *ic_opaque, char *errstr, size_t errstr_size);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_destroy_t)(rd_kafka_t *rk, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_send_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_acknowledgement_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_consume_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_commit_t)(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_resp_err_t err, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_request_sent_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_start_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_exit_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_set(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_set_t *on_conf_set, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_dup(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_dup_t *on_conf_dup, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_destroy(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_destroy_t *on_conf_destroy, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_new(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_new_t *on_new, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_destroy(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_destroy_t *on_destroy, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_send(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_send_t *on_send, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_acknowledgement(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_acknowledgement_t *on_acknowledgement, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_consume(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_consume_t *on_consume, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_commit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_commit_t *on_commit, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_request_sent(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_request_sent_t *on_request_sent, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_start(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_start_t *on_thread_start, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_exit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_exit_t *on_thread_exit, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_topic_result_error(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">const char *rd_kafka_topic_result_error_string(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">const char *rd_kafka_topic_result_name(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">typedef enum rd_kafka_admin_op_t {</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_ANY = 0,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_CREATETOPICS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DELETETOPICS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_CREATEPARTITIONS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_ALTERCONFIGS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DESCRIBECONFIGS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP__CNT,</span>
<span class="s1">} rd_kafka_admin_op_t;</span>
<span class="s1">typedef struct rd_kafka_AdminOptions_s rd_kafka_AdminOptions_t;</span>
<span class="s1">rd_kafka_AdminOptions_t *rd_kafka_AdminOptions_new(rd_kafka_t *rk, rd_kafka_admin_op_t for_api);</span>
<span class="s1">void rd_kafka_AdminOptions_destroy(rd_kafka_AdminOptions_t *options);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_request_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_operation_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_validate_only(rd_kafka_AdminOptions_t *options, int true_or_false, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_broker(rd_kafka_AdminOptions_t *options, int32_t broker_id, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_AdminOptions_set_opaque(rd_kafka_AdminOptions_t *options, void *ev_opaque);</span>
<span class="s1">typedef struct rd_kafka_NewTopic_s rd_kafka_NewTopic_t;</span>
<span class="s1">rd_kafka_NewTopic_t *rd_kafka_NewTopic_new(const char *topic, int num_partitions, int replication_factor, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_NewTopic_destroy(rd_kafka_NewTopic_t *new_topic);</span>
<span class="s1">void rd_kafka_NewTopic_destroy_array(rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewTopic_set_replica_assignment(rd_kafka_NewTopic_t *new_topic, int32_t partition, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewTopic_set_config(rd_kafka_NewTopic_t *new_topic, const char *name, const char *value);</span>
<span class="s1">void rd_kafka_CreateTopics(rd_kafka_t *rk, rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_CreateTopics_result_topics(const rd_kafka_CreateTopics_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_DeleteTopic_s rd_kafka_DeleteTopic_t;</span>
<span class="s1">rd_kafka_DeleteTopic_t *rd_kafka_DeleteTopic_new(const char *topic);</span>
<span class="s1">void rd_kafka_DeleteTopic_destroy(rd_kafka_DeleteTopic_t *del_topic);</span>
<span class="s1">void rd_kafka_DeleteTopic_destroy_array(rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt);</span>
<span class="s1">void rd_kafka_DeleteTopics(rd_kafka_t *rk, rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_DeleteTopics_result_topics(const rd_kafka_DeleteTopics_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_NewPartitions_s rd_kafka_NewPartitions_t;</span>
<span class="s1">rd_kafka_NewPartitions_t *rd_kafka_NewPartitions_new(const char *topic, size_t new_total_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_NewPartitions_destroy(rd_kafka_NewPartitions_t *new_parts);</span>
<span class="s1">void rd_kafka_NewPartitions_destroy_array(rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewPartitions_set_replica_assignment(rd_kafka_NewPartitions_t *new_parts, int32_t new_partition_idx, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_CreatePartitions(rd_kafka_t *rk, rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_CreatePartitions_result_topics(const rd_kafka_CreatePartitions_result_t *result, size_t *cntp);</span>
<span class="s1">typedef enum rd_kafka_ConfigSource_t {</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_UNKNOWN_CONFIG = 0,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_TOPIC_CONFIG = 1,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_BROKER_CONFIG = 2,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_DEFAULT_BROKER_CONFIG = 3,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_STATIC_BROKER_CONFIG = 4,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DEFAULT_CONFIG = 5,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE__CNT,</span>
<span class="s1">} rd_kafka_ConfigSource_t;</span>
<span class="s1">const char *rd_kafka_ConfigSource_name(rd_kafka_ConfigSource_t confsource);</span>
<span class="s1">typedef struct rd_kafka_ConfigEntry_s rd_kafka_ConfigEntry_t;</span>
<span class="s1">const char *rd_kafka_ConfigEntry_name(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">const char *rd_kafka_ConfigEntry_value(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">rd_kafka_ConfigSource_t rd_kafka_ConfigEntry_source(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_read_only(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_default(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_sensitive(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_synonym(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">const rd_kafka_ConfigEntry_t **rd_kafka_ConfigEntry_synonyms(const rd_kafka_ConfigEntry_t *entry, size_t *cntp);</span>
<span class="s1">typedef enum rd_kafka_ResourceType_t {</span>
<span class="s1">  RD_KAFKA_RESOURCE_UNKNOWN = 0,</span>
<span class="s1">  RD_KAFKA_RESOURCE_ANY = 1,</span>
<span class="s1">  RD_KAFKA_RESOURCE_TOPIC = 2,</span>
<span class="s1">  RD_KAFKA_RESOURCE_GROUP = 3,</span>
<span class="s1">  RD_KAFKA_RESOURCE_BROKER = 4,</span>
<span class="s1">  RD_KAFKA_RESOURCE__CNT,</span>
<span class="s1">} rd_kafka_ResourceType_t;</span>
<span class="s1">const char *rd_kafka_ResourceType_name(rd_kafka_ResourceType_t restype);</span>
<span class="s1">typedef struct rd_kafka_ConfigResource_s rd_kafka_ConfigResource_t;</span>
<span class="s1">rd_kafka_ConfigResource_t *rd_kafka_ConfigResource_new(rd_kafka_ResourceType_t restype, const char *resname);</span>
<span class="s1">void rd_kafka_ConfigResource_destroy(rd_kafka_ConfigResource_t *config);</span>
<span class="s1">void rd_kafka_ConfigResource_destroy_array(rd_kafka_ConfigResource_t **config, size_t config_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_ConfigResource_set_config(rd_kafka_ConfigResource_t *config, const char *name, const char *value);</span>
<span class="s1">const rd_kafka_ConfigEntry_t **rd_kafka_ConfigResource_configs(const rd_kafka_ConfigResource_t *config, size_t *cntp);</span>
<span class="s1">rd_kafka_ResourceType_t rd_kafka_ConfigResource_type(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">const char *rd_kafka_ConfigResource_name(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_ConfigResource_error(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">const char *rd_kafka_ConfigResource_error_string(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">void rd_kafka_AlterConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_ConfigResource_t **rd_kafka_AlterConfigs_result_resources(const rd_kafka_AlterConfigs_result_t *result, size_t *cntp);</span>
<span class="s1">void rd_kafka_DescribeConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_ConfigResource_t **rd_kafka_DescribeConfigs_result_resources(const rd_kafka_DescribeConfigs_result_t *result, size_t *cntp);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token(rd_kafka_t *rk, const char *token_value, int64_t md_lifetime_ms, const char *md_principal_name, const char **extensions, size_t extension_size, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token_failure(rd_kafka_t *rk, const char *errstr);</span>
<span class="s1">typedef struct rd_kafka_mock_cluster_s rd_kafka_mock_cluster_t;</span>
<span class="s1">rd_kafka_mock_cluster_t *rd_kafka_mock_cluster_new(rd_kafka_t *rk, int broker_cnt);</span>
<span class="s1">void rd_kafka_mock_cluster_destroy(rd_kafka_mock_cluster_t *mcluster);</span>
<span class="s1">rd_kafka_t *rd_kafka_mock_cluster_handle(const rd_kafka_mock_cluster_t *mcluster);</span>
<span class="s1">const char *rd_kafka_mock_cluster_bootstraps(const rd_kafka_mock_cluster_t *mcluster);</span>
<span class="s1">void rd_kafka_mock_push_request_errors(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, size_t cnt, ...);</span>
<span class="s1">void rd_kafka_mock_topic_set_error(rd_kafka_mock_cluster_t *mcluster, const char *topic, rd_kafka_resp_err_t err);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_partition_set_leader(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_partition_set_follower(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_partition_set_follower_wmarks(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int64_t lo, int64_t hi);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_set_rack(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, const char *rack);</span>
<span class="s1">&#39;</span>
</code></pre></div>
rdkafka.h, rdkafka_mock.h</p>
<h3 id="rd_kafka_version_7">RD_KAFKA_VERSION<a class="headerlink" href="#rd_kafka_version_7" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_VERSION</span> <span class="o">=</span> <span class="mi">17039615</span>
</code></pre></div>
<p>librdkafka version </p>
<p>Interpreted as hex <code>MM.mm.rr.xx</code>:</p>
<ul>
<li>MM = Major</li>
<li>mm = minor</li>
<li>rr = revision</li>
<li>xx = pre-release id (0xff is the final release)</li>
</ul>
<p>E.g.: <code>0x000801ff</code> = 0.8.1</p>
<dl class="section remark"><dt>Remarks</dt><dd>This value should only be used during compile time, for runtime checks of version use rd_kafka_version() </dd></dl>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_unsupported_compression_type_7">RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE<a class="headerlink" href="#rd_kafka_resp_err_unsupported_compression_type_7" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE</span> <span class="o">=</span> <span class="mi">76</span>
</code></pre></div>
<p>Unsupported compression type </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_end_all_7">RD_KAFKA_RESP_ERR_END_ALL<a class="headerlink" href="#rd_kafka_resp_err_end_all_7" title="Permanent link">&para;</a></h3>
<p><div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_END_ALL</span> <span class="o">=</span> <span class="mi">83</span>
</code></pre></div>
enum rd_kafka_resp_err_t</p>
<h3 id="rd_kafka_admin_op__cnt_7">RD_KAFKA_ADMIN_OP__CNT<a class="headerlink" href="#rd_kafka_admin_op__cnt_7" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_ADMIN_OP__CNT</span> <span class="o">=</span> <span class="mi">6</span>
</code></pre></div>
<p>Number of ops defined </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe </a></li>
</ul>
</div>
<h3 id="rd_kafka_resource__cnt_7">RD_KAFKA_RESOURCE__CNT<a class="headerlink" href="#rd_kafka_resource__cnt_7" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESOURCE__CNT</span> <span class="o">=</span> <span class="mi">5</span>
</code></pre></div>
<p>Number of resource types defined </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#acca83a66d7783ff7683ed2691cc907c9"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#acca83a66d7783ff7683ed2691cc907c9 </a></li>
</ul>
</div>
<h3 id="rd_kafka_cdef_7">RD_KAFKA_CDEF<a class="headerlink" href="#rd_kafka_cdef_7" title="Permanent link">&para;</a></h3>
<p><div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_CDEF</span> <span class="o">=</span> <span class="s1">&#39;typedef long int ssize_t;</span>
<span class="s1">typedef struct _IO_FILE FILE;</span>
<span class="s1">typedef long int mode_t;</span>
<span class="s1">typedef signed int int16_t;</span>
<span class="s1">typedef unsigned int uint16_t;</span>
<span class="s1">typedef signed int int32_t;</span>
<span class="s1">typedef signed long int int64_t;</span>
<span class="s1">int rd_kafka_version(void);</span>
<span class="s1">const char *rd_kafka_version_str(void);</span>
<span class="s1">typedef enum rd_kafka_type_t {</span>
<span class="s1">  RD_KAFKA_PRODUCER,</span>
<span class="s1">  RD_KAFKA_CONSUMER,</span>
<span class="s1">} rd_kafka_type_t;</span>
<span class="s1">typedef enum rd_kafka_timestamp_type_t {</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_NOT_AVAILABLE,</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_CREATE_TIME,</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_LOG_APPEND_TIME,</span>
<span class="s1">} rd_kafka_timestamp_type_t;</span>
<span class="s1">const char *rd_kafka_get_debug_contexts(void);</span>
<span class="s1">typedef struct rd_kafka_s rd_kafka_t;</span>
<span class="s1">typedef struct rd_kafka_topic_s rd_kafka_topic_t;</span>
<span class="s1">typedef struct rd_kafka_conf_s rd_kafka_conf_t;</span>
<span class="s1">typedef struct rd_kafka_topic_conf_s rd_kafka_topic_conf_t;</span>
<span class="s1">typedef struct rd_kafka_queue_s rd_kafka_queue_t;</span>
<span class="s1">typedef struct rd_kafka_op_s rd_kafka_event_t;</span>
<span class="s1">typedef struct rd_kafka_topic_result_s rd_kafka_topic_result_t;</span>
<span class="s1">typedef struct rd_kafka_consumer_group_metadata_s rd_kafka_consumer_group_metadata_t;</span>
<span class="s1">typedef struct rd_kafka_error_s {</span>
<span class="s1">  unsigned int code;</span>
<span class="s1">  char *errstr;</span>
<span class="s1">  unsigned char fatal;</span>
<span class="s1">  unsigned char retriable;</span>
<span class="s1">  unsigned char txn_requires_abort;</span>
<span class="s1">} rd_kafka_error_t;</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BEGIN = (- 200),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BAD_MSG = (- 199),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BAD_COMPRESSION = (- 198),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__DESTROY = (- 197),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FAIL = (- 196),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TRANSPORT = (- 195),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__CRIT_SYS_RESOURCE = (- 194),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__RESOLVE = (- 193),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__MSG_TIMED_OUT = (- 192),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PARTITION_EOF = (- 191),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION = (- 190),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FS = (- 189),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC = (- 188),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ALL_BROKERS_DOWN = (- 187),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INVALID_ARG = (- 186),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TIMED_OUT = (- 185),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__QUEUE_FULL = (- 184),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ISR_INSUFF = (- 183),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NODE_UPDATE = (- 182),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__SSL = (- 181),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__WAIT_COORD = (- 180),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_GROUP = (- 179),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__IN_PROGRESS = (- 178),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PREV_IN_PROGRESS = (- 177),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__EXISTING_SUBSCRIPTION = (- 176),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS = (- 175),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS = (- 174),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__CONFLICT = (- 173),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__STATE = (- 172),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_PROTOCOL = (- 171),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED = (- 170),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__AUTHENTICATION = (- 169),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NO_OFFSET = (- 168),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__OUTDATED = (- 167),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TIMED_OUT_QUEUE = (- 166),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNSUPPORTED_FEATURE = (- 165),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__WAIT_CACHE = (- 164),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INTR = (- 163),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__KEY_SERIALIZATION = (- 162),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__VALUE_SERIALIZATION = (- 161),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__KEY_DESERIALIZATION = (- 160),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__VALUE_DESERIALIZATION = (- 159),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PARTIAL = (- 158),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__READ_ONLY = (- 157),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOENT = (- 156),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNDERFLOW = (- 155),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INVALID_TYPE = (- 154),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__RETRY = (- 153),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PURGE_QUEUE = (- 152),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PURGE_INFLIGHT = (- 151),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FATAL = (- 150),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INCONSISTENT = (- 149),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__GAPLESS_GUARANTEE = (- 148),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__MAX_POLL_EXCEEDED = (- 147),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_BROKER = (- 146),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOT_CONFIGURED = (- 145),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FENCED = (- 144),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__APPLICATION = (- 143),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__END = (- 100),</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN = (- 1),</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NO_ERROR = 0,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_OUT_OF_RANGE = 1,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_MSG = 2,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART = 3,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_MSG_SIZE = 4,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE = 5,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_LEADER_FOR_PARTITION = 6,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REQUEST_TIMED_OUT = 7,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_BROKER_NOT_AVAILABLE = 8,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REPLICA_NOT_AVAILABLE = 9,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE = 10,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_STALE_CTRL_EPOCH = 11,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_METADATA_TOO_LARGE = 12,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NETWORK_EXCEPTION = 13,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_COORDINATOR_LOAD_IN_PROGRESS = 14,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_COORDINATOR_NOT_AVAILABLE = 15,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_COORDINATOR = 16,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_EXCEPTION = 17,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_RECORD_LIST_TOO_LARGE = 18,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS = 19,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS_AFTER_APPEND = 20,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REQUIRED_ACKS = 21,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ILLEGAL_GENERATION = 22,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INCONSISTENT_GROUP_PROTOCOL = 23,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_GROUP_ID = 24,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_MEMBER_ID = 25,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_SESSION_TIMEOUT = 26,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REBALANCE_IN_PROGRESS = 27,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_COMMIT_OFFSET_SIZE = 28,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_AUTHORIZATION_FAILED = 29,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_AUTHORIZATION_FAILED = 30,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_CLUSTER_AUTHORIZATION_FAILED = 31,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TIMESTAMP = 32,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_SASL_MECHANISM = 33,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ILLEGAL_SASL_STATE = 34,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_VERSION = 35,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_ALREADY_EXISTS = 36,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PARTITIONS = 37,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REPLICATION_FACTOR = 38,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REPLICA_ASSIGNMENT = 39,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_CONFIG = 40,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_CONTROLLER = 41,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REQUEST = 42,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_FOR_MESSAGE_FORMAT = 43,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_POLICY_VIOLATION = 44,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OUT_OF_ORDER_SEQUENCE_NUMBER = 45,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DUPLICATE_SEQUENCE_NUMBER = 46,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_EPOCH = 47,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TXN_STATE = 48,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_ID_MAPPING = 49,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TRANSACTION_TIMEOUT = 50,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_CONCURRENT_TRANSACTIONS = 51,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TRANSACTION_COORDINATOR_FENCED = 52,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TRANSACTIONAL_ID_AUTHORIZATION_FAILED = 53,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_SECURITY_DISABLED = 54,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OPERATION_NOT_ATTEMPTED = 55,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_KAFKA_STORAGE_ERROR = 56,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LOG_DIR_NOT_FOUND = 57,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_SASL_AUTHENTICATION_FAILED = 58,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_PRODUCER_ID = 59,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REASSIGNMENT_IN_PROGRESS = 60,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTH_DISABLED = 61,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_NOT_FOUND = 62,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_OWNER_MISMATCH = 63,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_REQUEST_NOT_ALLOWED = 64,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTHORIZATION_FAILED = 65,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_EXPIRED = 66,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRINCIPAL_TYPE = 67,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NON_EMPTY_GROUP = 68,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_ID_NOT_FOUND = 69,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FETCH_SESSION_ID_NOT_FOUND = 70,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_FETCH_SESSION_EPOCH = 71,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LISTENER_NOT_FOUND = 72,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_DELETION_DISABLED = 73,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FENCED_LEADER_EPOCH = 74,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_LEADER_EPOCH = 75,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_STALE_BROKER_EPOCH = 77,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_NOT_AVAILABLE = 78,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_MEMBER_ID_REQUIRED = 79,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_PREFERRED_LEADER_NOT_AVAILABLE = 80,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_MAX_SIZE_REACHED = 81,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FENCED_INSTANCE_ID = 82,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_END_ALL,</span>
<span class="s1">} rd_kafka_resp_err_t;</span>
<span class="s1">struct rd_kafka_err_desc {</span>
<span class="s1">  rd_kafka_resp_err_t code;</span>
<span class="s1">  char *name;</span>
<span class="s1">  char *desc;</span>
<span class="s1">};</span>
<span class="s1">void rd_kafka_get_err_descs(const struct rd_kafka_err_desc **errdescs, size_t *cntp);</span>
<span class="s1">const char *rd_kafka_err2str(rd_kafka_resp_err_t err);</span>
<span class="s1">const char *rd_kafka_err2name(rd_kafka_resp_err_t err);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_last_error(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_errno2err(int errnox);</span>
<span class="s1">int rd_kafka_errno(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_fatal_error(rd_kafka_t *rk, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_test_fatal_error(rd_kafka_t *rk, rd_kafka_resp_err_t err, const char *reason);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_error_code(const rd_kafka_error_t *error);</span>
<span class="s1">const char *rd_kafka_error_name(const rd_kafka_error_t *error);</span>
<span class="s1">const char *rd_kafka_error_string(const rd_kafka_error_t *error);</span>
<span class="s1">int rd_kafka_error_is_fatal(const rd_kafka_error_t *error);</span>
<span class="s1">int rd_kafka_error_is_retriable(const rd_kafka_error_t *error);</span>
<span class="s1">int rd_kafka_error_txn_requires_abort(const rd_kafka_error_t *error);</span>
<span class="s1">void rd_kafka_error_destroy(rd_kafka_error_t *error);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_error_new(rd_kafka_resp_err_t code, const char *fmt, ...);</span>
<span class="s1">typedef struct rd_kafka_topic_partition_s {</span>
<span class="s1">  char *topic;</span>
<span class="s1">  int32_t partition;</span>
<span class="s1">  int64_t offset;</span>
<span class="s1">  void *metadata;</span>
<span class="s1">  size_t metadata_size;</span>
<span class="s1">  void *opaque;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  void *_private;</span>
<span class="s1">} rd_kafka_topic_partition_t;</span>
<span class="s1">void rd_kafka_topic_partition_destroy(rd_kafka_topic_partition_t *rktpar);</span>
<span class="s1">typedef struct rd_kafka_topic_partition_list_s {</span>
<span class="s1">  int cnt;</span>
<span class="s1">  int size;</span>
<span class="s1">  rd_kafka_topic_partition_t *elems;</span>
<span class="s1">} rd_kafka_topic_partition_list_t;</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_new(int size);</span>
<span class="s1">void rd_kafka_topic_partition_list_destroy(rd_kafka_topic_partition_list_t *rkparlist);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_add(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">void rd_kafka_topic_partition_list_add_range(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t start, int32_t stop);</span>
<span class="s1">int rd_kafka_topic_partition_list_del(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">int rd_kafka_topic_partition_list_del_by_idx(rd_kafka_topic_partition_list_t *rktparlist, int idx);</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_copy(const rd_kafka_topic_partition_list_t *src);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_topic_partition_list_set_offset(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition, int64_t offset);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_find(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">void rd_kafka_topic_partition_list_sort(rd_kafka_topic_partition_list_t *rktparlist, int (*cmp)(const void *a, const void *b, void *cmp_opaque), void *cmp_opaque);</span>
<span class="s1">typedef enum rd_kafka_vtype_t {</span>
<span class="s1">  RD_KAFKA_VTYPE_END,</span>
<span class="s1">  RD_KAFKA_VTYPE_TOPIC,</span>
<span class="s1">  RD_KAFKA_VTYPE_RKT,</span>
<span class="s1">  RD_KAFKA_VTYPE_PARTITION,</span>
<span class="s1">  RD_KAFKA_VTYPE_VALUE,</span>
<span class="s1">  RD_KAFKA_VTYPE_KEY,</span>
<span class="s1">  RD_KAFKA_VTYPE_OPAQUE,</span>
<span class="s1">  RD_KAFKA_VTYPE_MSGFLAGS,</span>
<span class="s1">  RD_KAFKA_VTYPE_TIMESTAMP,</span>
<span class="s1">  RD_KAFKA_VTYPE_HEADER,</span>
<span class="s1">  RD_KAFKA_VTYPE_HEADERS,</span>
<span class="s1">} rd_kafka_vtype_t;</span>
<span class="s1">typedef struct rd_kafka_headers_s rd_kafka_headers_t;</span>
<span class="s1">rd_kafka_headers_t *rd_kafka_headers_new(size_t initial_count);</span>
<span class="s1">void rd_kafka_headers_destroy(rd_kafka_headers_t *hdrs);</span>
<span class="s1">rd_kafka_headers_t *rd_kafka_headers_copy(const rd_kafka_headers_t *src);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_add(rd_kafka_headers_t *hdrs, const char *name, ssize_t name_size, const void *value, ssize_t value_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_remove(rd_kafka_headers_t *hdrs, const char *name);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get_last(const rd_kafka_headers_t *hdrs, const char *name, const void **valuep, size_t *sizep);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get(const rd_kafka_headers_t *hdrs, size_t idx, const char *name, const void **valuep, size_t *sizep);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get_all(const rd_kafka_headers_t *hdrs, size_t idx, const char **namep, const void **valuep, size_t *sizep);</span>
<span class="s1">typedef struct rd_kafka_message_s {</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  rd_kafka_topic_t *rkt;</span>
<span class="s1">  int32_t partition;</span>
<span class="s1">  void *payload;</span>
<span class="s1">  size_t len;</span>
<span class="s1">  void *key;</span>
<span class="s1">  size_t key_len;</span>
<span class="s1">  int64_t offset;</span>
<span class="s1">  void *_private;</span>
<span class="s1">} rd_kafka_message_t;</span>
<span class="s1">void rd_kafka_message_destroy(rd_kafka_message_t *rkmessage);</span>
<span class="s1">int64_t rd_kafka_message_timestamp(const rd_kafka_message_t *rkmessage, rd_kafka_timestamp_type_t *tstype);</span>
<span class="s1">int64_t rd_kafka_message_latency(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_message_headers(const rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_message_detach_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);</span>
<span class="s1">void rd_kafka_message_set_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t *hdrs);</span>
<span class="s1">size_t rd_kafka_header_cnt(const rd_kafka_headers_t *hdrs);</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_NOT_PERSISTED = 0,</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_POSSIBLY_PERSISTED = 1,</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_PERSISTED = 2,</span>
<span class="s1">} rd_kafka_msg_status_t;</span>
<span class="s1">rd_kafka_msg_status_t rd_kafka_message_status(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_CONF_UNKNOWN = (- 2),</span>
<span class="s1">  RD_KAFKA_CONF_INVALID = (- 1),</span>
<span class="s1">  RD_KAFKA_CONF_OK = 0,</span>
<span class="s1">} rd_kafka_conf_res_t;</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_new(void);</span>
<span class="s1">void rd_kafka_conf_destroy(rd_kafka_conf_t *conf);</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_dup(const rd_kafka_conf_t *conf);</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_dup_filter(const rd_kafka_conf_t *conf, size_t filter_cnt, const char **filter);</span>
<span class="s1">const rd_kafka_conf_t *rd_kafka_conf(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_set(rd_kafka_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_conf_set_events(rd_kafka_conf_t *conf, int events);</span>
<span class="s1">void rd_kafka_conf_set_background_event_cb(rd_kafka_conf_t *conf, void (*event_cb)(rd_kafka_t *rk, rd_kafka_event_t *rkev, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_dr_cb(rd_kafka_conf_t *conf, void (*dr_cb)(rd_kafka_t *rk, void *payload, size_t len, rd_kafka_resp_err_t err, void *opaque, void *msg_opaque));</span>
<span class="s1">void rd_kafka_conf_set_dr_msg_cb(rd_kafka_conf_t *conf, void (*dr_msg_cb)(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_consume_cb(rd_kafka_conf_t *conf, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_rebalance_cb(rd_kafka_conf_t *conf, void (*rebalance_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *partitions, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_offset_commit_cb(rd_kafka_conf_t *conf, void (*offset_commit_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_error_cb(rd_kafka_conf_t *conf, void (*error_cb)(rd_kafka_t *rk, int err, const char *reason, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_throttle_cb(rd_kafka_conf_t *conf, void (*throttle_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int throttle_time_ms, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_log_cb(rd_kafka_conf_t *conf, void (*log_cb)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));</span>
<span class="s1">void rd_kafka_conf_set_stats_cb(rd_kafka_conf_t *conf, int (*stats_cb)(rd_kafka_t *rk, char *json, size_t json_len, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_oauthbearer_token_refresh_cb(rd_kafka_conf_t *conf, void (*oauthbearer_token_refresh_cb)(rd_kafka_t *rk, const char *oauthbearer_config, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_socket_cb(rd_kafka_conf_t *conf, int (*socket_cb)(int domain, int type, int protocol, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_connect_cb(rd_kafka_conf_t *conf, int (*connect_cb)(int sockfd, const struct sockaddr *addr, int addrlen, const char *id, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_closesocket_cb(rd_kafka_conf_t *conf, int (*closesocket_cb)(int sockfd, void *opaque));</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert_verify_cb(rd_kafka_conf_t *conf, int (*ssl_cert_verify_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int *x509_error, int depth, const char *buf, size_t size, char *errstr, size_t errstr_size, void *opaque));</span>
<span class="s1">typedef enum rd_kafka_cert_type_t {</span>
<span class="s1">  RD_KAFKA_CERT_PUBLIC_KEY,</span>
<span class="s1">  RD_KAFKA_CERT_PRIVATE_KEY,</span>
<span class="s1">  RD_KAFKA_CERT_CA,</span>
<span class="s1">  RD_KAFKA_CERT__CNT,</span>
<span class="s1">} rd_kafka_cert_type_t;</span>
<span class="s1">typedef enum rd_kafka_cert_enc_t {</span>
<span class="s1">  RD_KAFKA_CERT_ENC_PKCS12,</span>
<span class="s1">  RD_KAFKA_CERT_ENC_DER,</span>
<span class="s1">  RD_KAFKA_CERT_ENC_PEM,</span>
<span class="s1">  RD_KAFKA_CERT_ENC__CNT,</span>
<span class="s1">} rd_kafka_cert_enc_t;</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert(rd_kafka_conf_t *conf, rd_kafka_cert_type_t cert_type, rd_kafka_cert_enc_t cert_enc, const void *buffer, size_t size, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_conf_set_opaque(rd_kafka_conf_t *conf, void *opaque);</span>
<span class="s1">void *rd_kafka_opaque(const rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_conf_set_default_topic_conf(rd_kafka_conf_t *conf, rd_kafka_topic_conf_t *tconf);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_get(const rd_kafka_conf_t *conf, const char *name, char *dest, size_t *dest_size);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_topic_conf_get(const rd_kafka_topic_conf_t *conf, const char *name, char *dest, size_t *dest_size);</span>
<span class="s1">const char **rd_kafka_conf_dump(rd_kafka_conf_t *conf, size_t *cntp);</span>
<span class="s1">const char **rd_kafka_topic_conf_dump(rd_kafka_topic_conf_t *conf, size_t *cntp);</span>
<span class="s1">void rd_kafka_conf_dump_free(const char **arr, size_t cnt);</span>
<span class="s1">void rd_kafka_conf_properties_show(FILE *fp);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_topic_conf_new(void);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_topic_conf_dup(const rd_kafka_topic_conf_t *conf);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_default_topic_conf_dup(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_topic_conf_destroy(rd_kafka_topic_conf_t *topic_conf);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_topic_conf_set(rd_kafka_topic_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_topic_conf_set_opaque(rd_kafka_topic_conf_t *conf, void *rkt_opaque);</span>
<span class="s1">void rd_kafka_topic_conf_set_partitioner_cb(rd_kafka_topic_conf_t *topic_conf, int32_t (*partitioner)(const rd_kafka_topic_t *rkt, const void *keydata, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque));</span>
<span class="s1">void rd_kafka_topic_conf_set_msg_order_cmp(rd_kafka_topic_conf_t *topic_conf, int (*msg_order_cmp)(const rd_kafka_message_t *a, const rd_kafka_message_t *b));</span>
<span class="s1">int rd_kafka_topic_partition_available(const rd_kafka_topic_t *rkt, int32_t partition);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_consistent(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_consistent_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_murmur2(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_murmur2_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_fnv1a(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_fnv1a_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">rd_kafka_t *rd_kafka_new(rd_kafka_type_t type, rd_kafka_conf_t *conf, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_destroy(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_destroy_flags(rd_kafka_t *rk, int flags);</span>
<span class="s1">const char *rd_kafka_name(const rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_type_t rd_kafka_type(const rd_kafka_t *rk);</span>
<span class="s1">char *rd_kafka_memberid(const rd_kafka_t *rk);</span>
<span class="s1">char *rd_kafka_clusterid(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">int32_t rd_kafka_controllerid(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_topic_t *rd_kafka_topic_new(rd_kafka_t *rk, const char *topic, rd_kafka_topic_conf_t *conf);</span>
<span class="s1">void rd_kafka_topic_destroy(rd_kafka_topic_t *rkt);</span>
<span class="s1">const char *rd_kafka_topic_name(const rd_kafka_topic_t *rkt);</span>
<span class="s1">void *rd_kafka_topic_opaque(const rd_kafka_topic_t *rkt);</span>
<span class="s1">int rd_kafka_poll(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">void rd_kafka_yield(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_pause_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_resume_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_query_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_get_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offsets_for_times(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets, int timeout_ms);</span>
<span class="s1">void rd_kafka_mem_free(rd_kafka_t *rk, void *ptr);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_new(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_queue_destroy(rd_kafka_queue_t *rkqu);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_main(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_consumer(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_partition(rd_kafka_t *rk, const char *topic, int32_t partition);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_background(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_queue_forward(rd_kafka_queue_t *src, rd_kafka_queue_t *dst);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_set_log_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu);</span>
<span class="s1">size_t rd_kafka_queue_length(rd_kafka_queue_t *rkqu);</span>
<span class="s1">void rd_kafka_queue_io_event_enable(rd_kafka_queue_t *rkqu, int fd, const void *payload, size_t size);</span>
<span class="s1">void rd_kafka_queue_cb_event_enable(rd_kafka_queue_t *rkqu, void (*event_cb)(rd_kafka_t *rk, void *qev_opaque), void *qev_opaque);</span>
<span class="s1">int rd_kafka_consume_start(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);</span>
<span class="s1">int rd_kafka_consume_start_queue(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, rd_kafka_queue_t *rkqu);</span>
<span class="s1">int rd_kafka_consume_stop(rd_kafka_topic_t *rkt, int32_t partition);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_seek(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, int timeout_ms);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consume(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms);</span>
<span class="s1">ssize_t rd_kafka_consume_batch(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);</span>
<span class="s1">int rd_kafka_consume_callback(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consume_queue(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">ssize_t rd_kafka_consume_batch_queue(rd_kafka_queue_t *rkqu, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);</span>
<span class="s1">int rd_kafka_consume_callback_queue(rd_kafka_queue_t *rkqu, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offset_store(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offsets_store(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_subscribe(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *topics);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_unsubscribe(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_subscription(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **topics);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consumer_poll(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_consumer_close(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_assignment(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, int async);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit_message(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, int async);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit_queue(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_queue_t *rkqu, void (*cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *commit_opaque), void *commit_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_committed(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_position(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata_new(const char *group_id);</span>
<span class="s1">void rd_kafka_consumer_group_metadata_destroy(rd_kafka_consumer_group_metadata_t *);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_consumer_group_metadata_write(const rd_kafka_consumer_group_metadata_t *cgmd, void **bufferp, size_t *sizep);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_consumer_group_metadata_read(rd_kafka_consumer_group_metadata_t **cgmdp, const void *buffer, size_t size);</span>
<span class="s1">int rd_kafka_produce(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, void *payload, size_t len, const void *key, size_t keylen, void *msg_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_producev(rd_kafka_t *rk, ...);</span>
<span class="s1">int rd_kafka_produce_batch(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, rd_kafka_message_t *rkmessages, int message_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_flush(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_purge(rd_kafka_t *rk, int purge_flags);</span>
<span class="s1">typedef struct rd_kafka_metadata_broker {</span>
<span class="s1">  int32_t id;</span>
<span class="s1">  char *host;</span>
<span class="s1">  int port;</span>
<span class="s1">} rd_kafka_metadata_broker_t;</span>
<span class="s1">typedef struct rd_kafka_metadata_partition {</span>
<span class="s1">  int32_t id;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  int32_t leader;</span>
<span class="s1">  int replica_cnt;</span>
<span class="s1">  int32_t *replicas;</span>
<span class="s1">  int isr_cnt;</span>
<span class="s1">  int32_t *isrs;</span>
<span class="s1">} rd_kafka_metadata_partition_t;</span>
<span class="s1">typedef struct rd_kafka_metadata_topic {</span>
<span class="s1">  char *topic;</span>
<span class="s1">  int partition_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_partition *partitions;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">} rd_kafka_metadata_topic_t;</span>
<span class="s1">typedef struct rd_kafka_metadata {</span>
<span class="s1">  int broker_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_broker *brokers;</span>
<span class="s1">  int topic_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_topic *topics;</span>
<span class="s1">  int32_t orig_broker_id;</span>
<span class="s1">  char *orig_broker_name;</span>
<span class="s1">} rd_kafka_metadata_t;</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_metadata(rd_kafka_t *rk, int all_topics, rd_kafka_topic_t *only_rkt, const struct rd_kafka_metadata **metadatap, int timeout_ms);</span>
<span class="s1">void rd_kafka_metadata_destroy(const struct rd_kafka_metadata *metadata);</span>
<span class="s1">struct rd_kafka_group_member_info {</span>
<span class="s1">  char *member_id;</span>
<span class="s1">  char *client_id;</span>
<span class="s1">  char *client_host;</span>
<span class="s1">  void *member_metadata;</span>
<span class="s1">  int member_metadata_size;</span>
<span class="s1">  void *member_assignment;</span>
<span class="s1">  int member_assignment_size;</span>
<span class="s1">};</span>
<span class="s1">struct rd_kafka_group_info {</span>
<span class="s1">  struct rd_kafka_metadata_broker broker;</span>
<span class="s1">  char *group;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  char *state;</span>
<span class="s1">  char *protocol_type;</span>
<span class="s1">  char *protocol;</span>
<span class="s1">  struct rd_kafka_group_member_info *members;</span>
<span class="s1">  int member_cnt;</span>
<span class="s1">};</span>
<span class="s1">struct rd_kafka_group_list {</span>
<span class="s1">  struct rd_kafka_group_info *groups;</span>
<span class="s1">  int group_cnt;</span>
<span class="s1">};</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_list_groups(rd_kafka_t *rk, const char *group, const struct rd_kafka_group_list **grplistp, int timeout_ms);</span>
<span class="s1">void rd_kafka_group_list_destroy(const struct rd_kafka_group_list *grplist);</span>
<span class="s1">int rd_kafka_brokers_add(rd_kafka_t *rk, const char *brokerlist);</span>
<span class="s1">void rd_kafka_set_logger(rd_kafka_t *rk, void (*func)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));</span>
<span class="s1">void rd_kafka_set_log_level(rd_kafka_t *rk, int level);</span>
<span class="s1">void rd_kafka_log_print(const rd_kafka_t *rk, int level, const char *fac, const char *buf);</span>
<span class="s1">void rd_kafka_log_syslog(const rd_kafka_t *rk, int level, const char *fac, const char *buf);</span>
<span class="s1">int rd_kafka_outq_len(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_dump(FILE *fp, rd_kafka_t *rk);</span>
<span class="s1">int rd_kafka_thread_cnt(void);</span>
<span class="s1">typedef enum rd_kafka_thread_type_t {</span>
<span class="s1">  RD_KAFKA_THREAD_MAIN,</span>
<span class="s1">  RD_KAFKA_THREAD_BACKGROUND,</span>
<span class="s1">  RD_KAFKA_THREAD_BROKER,</span>
<span class="s1">} rd_kafka_thread_type_t;</span>
<span class="s1">int rd_kafka_wait_destroyed(int timeout_ms);</span>
<span class="s1">int rd_kafka_unittest(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_poll_set_consumer(rd_kafka_t *rk);</span>
<span class="s1">typedef int rd_kafka_event_type_t;</span>
<span class="s1">rd_kafka_event_type_t rd_kafka_event_type(const rd_kafka_event_t *rkev);</span>
<span class="s1">const char *rd_kafka_event_name(const rd_kafka_event_t *rkev);</span>
<span class="s1">void rd_kafka_event_destroy(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_message_t *rd_kafka_event_message_next(rd_kafka_event_t *rkev);</span>
<span class="s1">size_t rd_kafka_event_message_array(rd_kafka_event_t *rkev, const rd_kafka_message_t **rkmessages, size_t size);</span>
<span class="s1">size_t rd_kafka_event_message_count(rd_kafka_event_t *rkev);</span>
<span class="s1">const char *rd_kafka_event_config_string(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_event_error(rd_kafka_event_t *rkev);</span>
<span class="s1">const char *rd_kafka_event_error_string(rd_kafka_event_t *rkev);</span>
<span class="s1">int rd_kafka_event_error_is_fatal(rd_kafka_event_t *rkev);</span>
<span class="s1">void *rd_kafka_event_opaque(rd_kafka_event_t *rkev);</span>
<span class="s1">int rd_kafka_event_log(rd_kafka_event_t *rkev, const char **fac, const char **str, int *level);</span>
<span class="s1">const char *rd_kafka_event_stats(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_event_topic_partition_list(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_event_topic_partition(rd_kafka_event_t *rkev);</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_CreateTopics_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DeleteTopics_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_CreatePartitions_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_AlterConfigs_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DescribeConfigs_result_t;</span>
<span class="s1">const rd_kafka_CreateTopics_result_t *rd_kafka_event_CreateTopics_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DeleteTopics_result_t *rd_kafka_event_DeleteTopics_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_CreatePartitions_result_t *rd_kafka_event_CreatePartitions_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_AlterConfigs_result_t *rd_kafka_event_AlterConfigs_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DescribeConfigs_result_t *rd_kafka_event_DescribeConfigs_result(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_event_t *rd_kafka_queue_poll(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">int rd_kafka_queue_poll_callback(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_plugin_f_conf_init_t)(rd_kafka_conf_t *conf, void **plug_opaquep, char *errstr, size_t errstr_size);</span>
<span class="s1">typedef rd_kafka_conf_res_t (rd_kafka_interceptor_f_on_conf_set_t)(rd_kafka_conf_t *conf, const char *name, const char *val, char *errstr, size_t errstr_size, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_dup_t)(rd_kafka_conf_t *new_conf, const rd_kafka_conf_t *old_conf, size_t filter_cnt, const char **filter, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_destroy_t)(void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_new_t)(rd_kafka_t *rk, const rd_kafka_conf_t *conf, void *ic_opaque, char *errstr, size_t errstr_size);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_destroy_t)(rd_kafka_t *rk, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_send_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_acknowledgement_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_consume_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_commit_t)(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_resp_err_t err, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_request_sent_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_start_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_exit_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_set(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_set_t *on_conf_set, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_dup(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_dup_t *on_conf_dup, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_destroy(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_destroy_t *on_conf_destroy, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_new(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_new_t *on_new, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_destroy(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_destroy_t *on_destroy, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_send(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_send_t *on_send, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_acknowledgement(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_acknowledgement_t *on_acknowledgement, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_consume(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_consume_t *on_consume, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_commit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_commit_t *on_commit, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_request_sent(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_request_sent_t *on_request_sent, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_start(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_start_t *on_thread_start, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_exit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_exit_t *on_thread_exit, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_topic_result_error(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">const char *rd_kafka_topic_result_error_string(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">const char *rd_kafka_topic_result_name(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">typedef enum rd_kafka_admin_op_t {</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_ANY = 0,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_CREATETOPICS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DELETETOPICS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_CREATEPARTITIONS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_ALTERCONFIGS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DESCRIBECONFIGS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP__CNT,</span>
<span class="s1">} rd_kafka_admin_op_t;</span>
<span class="s1">typedef struct rd_kafka_AdminOptions_s rd_kafka_AdminOptions_t;</span>
<span class="s1">rd_kafka_AdminOptions_t *rd_kafka_AdminOptions_new(rd_kafka_t *rk, rd_kafka_admin_op_t for_api);</span>
<span class="s1">void rd_kafka_AdminOptions_destroy(rd_kafka_AdminOptions_t *options);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_request_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_operation_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_validate_only(rd_kafka_AdminOptions_t *options, int true_or_false, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_broker(rd_kafka_AdminOptions_t *options, int32_t broker_id, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_AdminOptions_set_opaque(rd_kafka_AdminOptions_t *options, void *ev_opaque);</span>
<span class="s1">typedef struct rd_kafka_NewTopic_s rd_kafka_NewTopic_t;</span>
<span class="s1">rd_kafka_NewTopic_t *rd_kafka_NewTopic_new(const char *topic, int num_partitions, int replication_factor, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_NewTopic_destroy(rd_kafka_NewTopic_t *new_topic);</span>
<span class="s1">void rd_kafka_NewTopic_destroy_array(rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewTopic_set_replica_assignment(rd_kafka_NewTopic_t *new_topic, int32_t partition, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewTopic_set_config(rd_kafka_NewTopic_t *new_topic, const char *name, const char *value);</span>
<span class="s1">void rd_kafka_CreateTopics(rd_kafka_t *rk, rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_CreateTopics_result_topics(const rd_kafka_CreateTopics_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_DeleteTopic_s rd_kafka_DeleteTopic_t;</span>
<span class="s1">rd_kafka_DeleteTopic_t *rd_kafka_DeleteTopic_new(const char *topic);</span>
<span class="s1">void rd_kafka_DeleteTopic_destroy(rd_kafka_DeleteTopic_t *del_topic);</span>
<span class="s1">void rd_kafka_DeleteTopic_destroy_array(rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt);</span>
<span class="s1">void rd_kafka_DeleteTopics(rd_kafka_t *rk, rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_DeleteTopics_result_topics(const rd_kafka_DeleteTopics_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_NewPartitions_s rd_kafka_NewPartitions_t;</span>
<span class="s1">rd_kafka_NewPartitions_t *rd_kafka_NewPartitions_new(const char *topic, size_t new_total_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_NewPartitions_destroy(rd_kafka_NewPartitions_t *new_parts);</span>
<span class="s1">void rd_kafka_NewPartitions_destroy_array(rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewPartitions_set_replica_assignment(rd_kafka_NewPartitions_t *new_parts, int32_t new_partition_idx, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_CreatePartitions(rd_kafka_t *rk, rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_CreatePartitions_result_topics(const rd_kafka_CreatePartitions_result_t *result, size_t *cntp);</span>
<span class="s1">typedef enum rd_kafka_ConfigSource_t {</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_UNKNOWN_CONFIG = 0,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_TOPIC_CONFIG = 1,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_BROKER_CONFIG = 2,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_DEFAULT_BROKER_CONFIG = 3,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_STATIC_BROKER_CONFIG = 4,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DEFAULT_CONFIG = 5,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE__CNT,</span>
<span class="s1">} rd_kafka_ConfigSource_t;</span>
<span class="s1">const char *rd_kafka_ConfigSource_name(rd_kafka_ConfigSource_t confsource);</span>
<span class="s1">typedef struct rd_kafka_ConfigEntry_s rd_kafka_ConfigEntry_t;</span>
<span class="s1">const char *rd_kafka_ConfigEntry_name(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">const char *rd_kafka_ConfigEntry_value(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">rd_kafka_ConfigSource_t rd_kafka_ConfigEntry_source(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_read_only(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_default(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_sensitive(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_synonym(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">const rd_kafka_ConfigEntry_t **rd_kafka_ConfigEntry_synonyms(const rd_kafka_ConfigEntry_t *entry, size_t *cntp);</span>
<span class="s1">typedef enum rd_kafka_ResourceType_t {</span>
<span class="s1">  RD_KAFKA_RESOURCE_UNKNOWN = 0,</span>
<span class="s1">  RD_KAFKA_RESOURCE_ANY = 1,</span>
<span class="s1">  RD_KAFKA_RESOURCE_TOPIC = 2,</span>
<span class="s1">  RD_KAFKA_RESOURCE_GROUP = 3,</span>
<span class="s1">  RD_KAFKA_RESOURCE_BROKER = 4,</span>
<span class="s1">  RD_KAFKA_RESOURCE__CNT,</span>
<span class="s1">} rd_kafka_ResourceType_t;</span>
<span class="s1">const char *rd_kafka_ResourceType_name(rd_kafka_ResourceType_t restype);</span>
<span class="s1">typedef struct rd_kafka_ConfigResource_s rd_kafka_ConfigResource_t;</span>
<span class="s1">rd_kafka_ConfigResource_t *rd_kafka_ConfigResource_new(rd_kafka_ResourceType_t restype, const char *resname);</span>
<span class="s1">void rd_kafka_ConfigResource_destroy(rd_kafka_ConfigResource_t *config);</span>
<span class="s1">void rd_kafka_ConfigResource_destroy_array(rd_kafka_ConfigResource_t **config, size_t config_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_ConfigResource_set_config(rd_kafka_ConfigResource_t *config, const char *name, const char *value);</span>
<span class="s1">const rd_kafka_ConfigEntry_t **rd_kafka_ConfigResource_configs(const rd_kafka_ConfigResource_t *config, size_t *cntp);</span>
<span class="s1">rd_kafka_ResourceType_t rd_kafka_ConfigResource_type(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">const char *rd_kafka_ConfigResource_name(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_ConfigResource_error(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">const char *rd_kafka_ConfigResource_error_string(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">void rd_kafka_AlterConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_ConfigResource_t **rd_kafka_AlterConfigs_result_resources(const rd_kafka_AlterConfigs_result_t *result, size_t *cntp);</span>
<span class="s1">void rd_kafka_DescribeConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_ConfigResource_t **rd_kafka_DescribeConfigs_result_resources(const rd_kafka_DescribeConfigs_result_t *result, size_t *cntp);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token(rd_kafka_t *rk, const char *token_value, int64_t md_lifetime_ms, const char *md_principal_name, const char **extensions, size_t extension_size, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token_failure(rd_kafka_t *rk, const char *errstr);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_init_transactions(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_begin_transaction(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_send_offsets_to_transaction(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, const rd_kafka_consumer_group_metadata_t *cgmetadata, int timeout_ms);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_commit_transaction(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_abort_transaction(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">typedef struct rd_kafka_mock_cluster_s rd_kafka_mock_cluster_t;</span>
<span class="s1">rd_kafka_mock_cluster_t *rd_kafka_mock_cluster_new(rd_kafka_t *rk, int broker_cnt);</span>
<span class="s1">void rd_kafka_mock_cluster_destroy(rd_kafka_mock_cluster_t *mcluster);</span>
<span class="s1">rd_kafka_t *rd_kafka_mock_cluster_handle(const rd_kafka_mock_cluster_t *mcluster);</span>
<span class="s1">rd_kafka_mock_cluster_t *rd_kafka_handle_mock_cluster(const rd_kafka_t *rk);</span>
<span class="s1">const char *rd_kafka_mock_cluster_bootstraps(const rd_kafka_mock_cluster_t *mcluster);</span>
<span class="s1">void rd_kafka_mock_push_request_errors(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, size_t cnt, ...);</span>
<span class="s1">void rd_kafka_mock_topic_set_error(rd_kafka_mock_cluster_t *mcluster, const char *topic, rd_kafka_resp_err_t err);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_topic_create(rd_kafka_mock_cluster_t *mcluster, const char *topic, int partition_cnt, int replication_factor);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_partition_set_leader(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_partition_set_follower(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_partition_set_follower_wmarks(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int64_t lo, int64_t hi);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_set_down(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_set_up(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_set_rack(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, const char *rack);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_coordinator_set(rd_kafka_mock_cluster_t *mcluster, const char *key_type, const char *key, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_set_apiversion(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, int16_t MinVersion, int16_t MaxVersion);</span>
<span class="s1">&#39;</span>
</code></pre></div>
rdkafka.h, rdkafka_mock.h</p>
<h3 id="rd_kafka_version_8">RD_KAFKA_VERSION<a class="headerlink" href="#rd_kafka_version_8" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_VERSION</span> <span class="o">=</span> <span class="mi">17040127</span>
</code></pre></div>
<p>librdkafka version </p>
<p>Interpreted as hex <code>MM.mm.rr.xx</code>:</p>
<ul>
<li>MM = Major</li>
<li>mm = minor</li>
<li>rr = revision</li>
<li>xx = pre-release id (0xff is the final release)</li>
</ul>
<p>E.g.: <code>0x000801ff</code> = 0.8.1</p>
<dl class="section remark"><dt>Remarks</dt><dd>This value should only be used during compile time, for runtime checks of version use rd_kafka_version() </dd></dl>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_unsupported_compression_type_8">RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE<a class="headerlink" href="#rd_kafka_resp_err_unsupported_compression_type_8" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE</span> <span class="o">=</span> <span class="mi">76</span>
</code></pre></div>
<p>Unsupported compression type </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_end_all_8">RD_KAFKA_RESP_ERR_END_ALL<a class="headerlink" href="#rd_kafka_resp_err_end_all_8" title="Permanent link">&para;</a></h3>
<p><div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_END_ALL</span> <span class="o">=</span> <span class="mi">83</span>
</code></pre></div>
enum rd_kafka_resp_err_t</p>
<h3 id="rd_kafka_admin_op__cnt_8">RD_KAFKA_ADMIN_OP__CNT<a class="headerlink" href="#rd_kafka_admin_op__cnt_8" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_ADMIN_OP__CNT</span> <span class="o">=</span> <span class="mi">6</span>
</code></pre></div>
<p>Number of ops defined </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe </a></li>
</ul>
</div>
<h3 id="rd_kafka_resource__cnt_8">RD_KAFKA_RESOURCE__CNT<a class="headerlink" href="#rd_kafka_resource__cnt_8" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESOURCE__CNT</span> <span class="o">=</span> <span class="mi">5</span>
</code></pre></div>
<p>Number of resource types defined </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#acca83a66d7783ff7683ed2691cc907c9"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#acca83a66d7783ff7683ed2691cc907c9 </a></li>
</ul>
</div>
<h3 id="rd_kafka_cdef_8">RD_KAFKA_CDEF<a class="headerlink" href="#rd_kafka_cdef_8" title="Permanent link">&para;</a></h3>
<p><div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_CDEF</span> <span class="o">=</span> <span class="s1">&#39;typedef long int ssize_t;</span>
<span class="s1">typedef struct _IO_FILE FILE;</span>
<span class="s1">typedef long int mode_t;</span>
<span class="s1">typedef signed int int16_t;</span>
<span class="s1">typedef unsigned int uint16_t;</span>
<span class="s1">typedef signed int int32_t;</span>
<span class="s1">typedef signed long int int64_t;</span>
<span class="s1">int rd_kafka_version(void);</span>
<span class="s1">const char *rd_kafka_version_str(void);</span>
<span class="s1">typedef enum rd_kafka_type_t {</span>
<span class="s1">  RD_KAFKA_PRODUCER,</span>
<span class="s1">  RD_KAFKA_CONSUMER,</span>
<span class="s1">} rd_kafka_type_t;</span>
<span class="s1">typedef enum rd_kafka_timestamp_type_t {</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_NOT_AVAILABLE,</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_CREATE_TIME,</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_LOG_APPEND_TIME,</span>
<span class="s1">} rd_kafka_timestamp_type_t;</span>
<span class="s1">const char *rd_kafka_get_debug_contexts(void);</span>
<span class="s1">typedef struct rd_kafka_s rd_kafka_t;</span>
<span class="s1">typedef struct rd_kafka_topic_s rd_kafka_topic_t;</span>
<span class="s1">typedef struct rd_kafka_conf_s rd_kafka_conf_t;</span>
<span class="s1">typedef struct rd_kafka_topic_conf_s rd_kafka_topic_conf_t;</span>
<span class="s1">typedef struct rd_kafka_queue_s rd_kafka_queue_t;</span>
<span class="s1">typedef struct rd_kafka_op_s rd_kafka_event_t;</span>
<span class="s1">typedef struct rd_kafka_topic_result_s rd_kafka_topic_result_t;</span>
<span class="s1">typedef struct rd_kafka_consumer_group_metadata_s rd_kafka_consumer_group_metadata_t;</span>
<span class="s1">typedef struct rd_kafka_error_s {</span>
<span class="s1">  unsigned int code;</span>
<span class="s1">  char *errstr;</span>
<span class="s1">  unsigned char fatal;</span>
<span class="s1">  unsigned char retriable;</span>
<span class="s1">  unsigned char txn_requires_abort;</span>
<span class="s1">} rd_kafka_error_t;</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BEGIN = (- 200),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BAD_MSG = (- 199),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BAD_COMPRESSION = (- 198),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__DESTROY = (- 197),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FAIL = (- 196),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TRANSPORT = (- 195),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__CRIT_SYS_RESOURCE = (- 194),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__RESOLVE = (- 193),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__MSG_TIMED_OUT = (- 192),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PARTITION_EOF = (- 191),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION = (- 190),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FS = (- 189),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC = (- 188),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ALL_BROKERS_DOWN = (- 187),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INVALID_ARG = (- 186),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TIMED_OUT = (- 185),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__QUEUE_FULL = (- 184),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ISR_INSUFF = (- 183),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NODE_UPDATE = (- 182),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__SSL = (- 181),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__WAIT_COORD = (- 180),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_GROUP = (- 179),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__IN_PROGRESS = (- 178),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PREV_IN_PROGRESS = (- 177),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__EXISTING_SUBSCRIPTION = (- 176),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS = (- 175),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS = (- 174),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__CONFLICT = (- 173),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__STATE = (- 172),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_PROTOCOL = (- 171),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED = (- 170),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__AUTHENTICATION = (- 169),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NO_OFFSET = (- 168),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__OUTDATED = (- 167),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TIMED_OUT_QUEUE = (- 166),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNSUPPORTED_FEATURE = (- 165),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__WAIT_CACHE = (- 164),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INTR = (- 163),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__KEY_SERIALIZATION = (- 162),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__VALUE_SERIALIZATION = (- 161),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__KEY_DESERIALIZATION = (- 160),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__VALUE_DESERIALIZATION = (- 159),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PARTIAL = (- 158),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__READ_ONLY = (- 157),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOENT = (- 156),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNDERFLOW = (- 155),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INVALID_TYPE = (- 154),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__RETRY = (- 153),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PURGE_QUEUE = (- 152),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PURGE_INFLIGHT = (- 151),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FATAL = (- 150),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INCONSISTENT = (- 149),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__GAPLESS_GUARANTEE = (- 148),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__MAX_POLL_EXCEEDED = (- 147),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_BROKER = (- 146),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOT_CONFIGURED = (- 145),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FENCED = (- 144),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__APPLICATION = (- 143),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__END = (- 100),</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN = (- 1),</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NO_ERROR = 0,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_OUT_OF_RANGE = 1,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_MSG = 2,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART = 3,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_MSG_SIZE = 4,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE = 5,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_LEADER_FOR_PARTITION = 6,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REQUEST_TIMED_OUT = 7,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_BROKER_NOT_AVAILABLE = 8,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REPLICA_NOT_AVAILABLE = 9,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE = 10,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_STALE_CTRL_EPOCH = 11,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_METADATA_TOO_LARGE = 12,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NETWORK_EXCEPTION = 13,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_COORDINATOR_LOAD_IN_PROGRESS = 14,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_COORDINATOR_NOT_AVAILABLE = 15,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_COORDINATOR = 16,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_EXCEPTION = 17,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_RECORD_LIST_TOO_LARGE = 18,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS = 19,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS_AFTER_APPEND = 20,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REQUIRED_ACKS = 21,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ILLEGAL_GENERATION = 22,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INCONSISTENT_GROUP_PROTOCOL = 23,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_GROUP_ID = 24,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_MEMBER_ID = 25,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_SESSION_TIMEOUT = 26,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REBALANCE_IN_PROGRESS = 27,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_COMMIT_OFFSET_SIZE = 28,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_AUTHORIZATION_FAILED = 29,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_AUTHORIZATION_FAILED = 30,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_CLUSTER_AUTHORIZATION_FAILED = 31,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TIMESTAMP = 32,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_SASL_MECHANISM = 33,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ILLEGAL_SASL_STATE = 34,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_VERSION = 35,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_ALREADY_EXISTS = 36,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PARTITIONS = 37,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REPLICATION_FACTOR = 38,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REPLICA_ASSIGNMENT = 39,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_CONFIG = 40,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_CONTROLLER = 41,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REQUEST = 42,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_FOR_MESSAGE_FORMAT = 43,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_POLICY_VIOLATION = 44,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OUT_OF_ORDER_SEQUENCE_NUMBER = 45,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DUPLICATE_SEQUENCE_NUMBER = 46,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_EPOCH = 47,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TXN_STATE = 48,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_ID_MAPPING = 49,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TRANSACTION_TIMEOUT = 50,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_CONCURRENT_TRANSACTIONS = 51,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TRANSACTION_COORDINATOR_FENCED = 52,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TRANSACTIONAL_ID_AUTHORIZATION_FAILED = 53,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_SECURITY_DISABLED = 54,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OPERATION_NOT_ATTEMPTED = 55,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_KAFKA_STORAGE_ERROR = 56,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LOG_DIR_NOT_FOUND = 57,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_SASL_AUTHENTICATION_FAILED = 58,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_PRODUCER_ID = 59,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REASSIGNMENT_IN_PROGRESS = 60,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTH_DISABLED = 61,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_NOT_FOUND = 62,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_OWNER_MISMATCH = 63,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_REQUEST_NOT_ALLOWED = 64,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTHORIZATION_FAILED = 65,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_EXPIRED = 66,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRINCIPAL_TYPE = 67,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NON_EMPTY_GROUP = 68,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_ID_NOT_FOUND = 69,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FETCH_SESSION_ID_NOT_FOUND = 70,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_FETCH_SESSION_EPOCH = 71,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LISTENER_NOT_FOUND = 72,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_DELETION_DISABLED = 73,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FENCED_LEADER_EPOCH = 74,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_LEADER_EPOCH = 75,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_STALE_BROKER_EPOCH = 77,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_NOT_AVAILABLE = 78,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_MEMBER_ID_REQUIRED = 79,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_PREFERRED_LEADER_NOT_AVAILABLE = 80,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_MAX_SIZE_REACHED = 81,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FENCED_INSTANCE_ID = 82,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_END_ALL,</span>
<span class="s1">} rd_kafka_resp_err_t;</span>
<span class="s1">struct rd_kafka_err_desc {</span>
<span class="s1">  rd_kafka_resp_err_t code;</span>
<span class="s1">  char *name;</span>
<span class="s1">  char *desc;</span>
<span class="s1">};</span>
<span class="s1">void rd_kafka_get_err_descs(const struct rd_kafka_err_desc **errdescs, size_t *cntp);</span>
<span class="s1">const char *rd_kafka_err2str(rd_kafka_resp_err_t err);</span>
<span class="s1">const char *rd_kafka_err2name(rd_kafka_resp_err_t err);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_last_error(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_errno2err(int errnox);</span>
<span class="s1">int rd_kafka_errno(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_fatal_error(rd_kafka_t *rk, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_test_fatal_error(rd_kafka_t *rk, rd_kafka_resp_err_t err, const char *reason);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_error_code(const rd_kafka_error_t *error);</span>
<span class="s1">const char *rd_kafka_error_name(const rd_kafka_error_t *error);</span>
<span class="s1">const char *rd_kafka_error_string(const rd_kafka_error_t *error);</span>
<span class="s1">int rd_kafka_error_is_fatal(const rd_kafka_error_t *error);</span>
<span class="s1">int rd_kafka_error_is_retriable(const rd_kafka_error_t *error);</span>
<span class="s1">int rd_kafka_error_txn_requires_abort(const rd_kafka_error_t *error);</span>
<span class="s1">void rd_kafka_error_destroy(rd_kafka_error_t *error);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_error_new(rd_kafka_resp_err_t code, const char *fmt, ...);</span>
<span class="s1">typedef struct rd_kafka_topic_partition_s {</span>
<span class="s1">  char *topic;</span>
<span class="s1">  int32_t partition;</span>
<span class="s1">  int64_t offset;</span>
<span class="s1">  void *metadata;</span>
<span class="s1">  size_t metadata_size;</span>
<span class="s1">  void *opaque;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  void *_private;</span>
<span class="s1">} rd_kafka_topic_partition_t;</span>
<span class="s1">void rd_kafka_topic_partition_destroy(rd_kafka_topic_partition_t *rktpar);</span>
<span class="s1">typedef struct rd_kafka_topic_partition_list_s {</span>
<span class="s1">  int cnt;</span>
<span class="s1">  int size;</span>
<span class="s1">  rd_kafka_topic_partition_t *elems;</span>
<span class="s1">} rd_kafka_topic_partition_list_t;</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_new(int size);</span>
<span class="s1">void rd_kafka_topic_partition_list_destroy(rd_kafka_topic_partition_list_t *rkparlist);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_add(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">void rd_kafka_topic_partition_list_add_range(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t start, int32_t stop);</span>
<span class="s1">int rd_kafka_topic_partition_list_del(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">int rd_kafka_topic_partition_list_del_by_idx(rd_kafka_topic_partition_list_t *rktparlist, int idx);</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_copy(const rd_kafka_topic_partition_list_t *src);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_topic_partition_list_set_offset(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition, int64_t offset);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_find(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">void rd_kafka_topic_partition_list_sort(rd_kafka_topic_partition_list_t *rktparlist, int (*cmp)(const void *a, const void *b, void *cmp_opaque), void *cmp_opaque);</span>
<span class="s1">typedef enum rd_kafka_vtype_t {</span>
<span class="s1">  RD_KAFKA_VTYPE_END,</span>
<span class="s1">  RD_KAFKA_VTYPE_TOPIC,</span>
<span class="s1">  RD_KAFKA_VTYPE_RKT,</span>
<span class="s1">  RD_KAFKA_VTYPE_PARTITION,</span>
<span class="s1">  RD_KAFKA_VTYPE_VALUE,</span>
<span class="s1">  RD_KAFKA_VTYPE_KEY,</span>
<span class="s1">  RD_KAFKA_VTYPE_OPAQUE,</span>
<span class="s1">  RD_KAFKA_VTYPE_MSGFLAGS,</span>
<span class="s1">  RD_KAFKA_VTYPE_TIMESTAMP,</span>
<span class="s1">  RD_KAFKA_VTYPE_HEADER,</span>
<span class="s1">  RD_KAFKA_VTYPE_HEADERS,</span>
<span class="s1">} rd_kafka_vtype_t;</span>
<span class="s1">typedef struct rd_kafka_headers_s rd_kafka_headers_t;</span>
<span class="s1">rd_kafka_headers_t *rd_kafka_headers_new(size_t initial_count);</span>
<span class="s1">void rd_kafka_headers_destroy(rd_kafka_headers_t *hdrs);</span>
<span class="s1">rd_kafka_headers_t *rd_kafka_headers_copy(const rd_kafka_headers_t *src);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_add(rd_kafka_headers_t *hdrs, const char *name, ssize_t name_size, const void *value, ssize_t value_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_remove(rd_kafka_headers_t *hdrs, const char *name);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get_last(const rd_kafka_headers_t *hdrs, const char *name, const void **valuep, size_t *sizep);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get(const rd_kafka_headers_t *hdrs, size_t idx, const char *name, const void **valuep, size_t *sizep);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get_all(const rd_kafka_headers_t *hdrs, size_t idx, const char **namep, const void **valuep, size_t *sizep);</span>
<span class="s1">typedef struct rd_kafka_message_s {</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  rd_kafka_topic_t *rkt;</span>
<span class="s1">  int32_t partition;</span>
<span class="s1">  void *payload;</span>
<span class="s1">  size_t len;</span>
<span class="s1">  void *key;</span>
<span class="s1">  size_t key_len;</span>
<span class="s1">  int64_t offset;</span>
<span class="s1">  void *_private;</span>
<span class="s1">} rd_kafka_message_t;</span>
<span class="s1">void rd_kafka_message_destroy(rd_kafka_message_t *rkmessage);</span>
<span class="s1">int64_t rd_kafka_message_timestamp(const rd_kafka_message_t *rkmessage, rd_kafka_timestamp_type_t *tstype);</span>
<span class="s1">int64_t rd_kafka_message_latency(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_message_headers(const rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_message_detach_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);</span>
<span class="s1">void rd_kafka_message_set_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t *hdrs);</span>
<span class="s1">size_t rd_kafka_header_cnt(const rd_kafka_headers_t *hdrs);</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_NOT_PERSISTED = 0,</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_POSSIBLY_PERSISTED = 1,</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_PERSISTED = 2,</span>
<span class="s1">} rd_kafka_msg_status_t;</span>
<span class="s1">rd_kafka_msg_status_t rd_kafka_message_status(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_CONF_UNKNOWN = (- 2),</span>
<span class="s1">  RD_KAFKA_CONF_INVALID = (- 1),</span>
<span class="s1">  RD_KAFKA_CONF_OK = 0,</span>
<span class="s1">} rd_kafka_conf_res_t;</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_new(void);</span>
<span class="s1">void rd_kafka_conf_destroy(rd_kafka_conf_t *conf);</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_dup(const rd_kafka_conf_t *conf);</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_dup_filter(const rd_kafka_conf_t *conf, size_t filter_cnt, const char **filter);</span>
<span class="s1">const rd_kafka_conf_t *rd_kafka_conf(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_set(rd_kafka_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_conf_set_events(rd_kafka_conf_t *conf, int events);</span>
<span class="s1">void rd_kafka_conf_set_background_event_cb(rd_kafka_conf_t *conf, void (*event_cb)(rd_kafka_t *rk, rd_kafka_event_t *rkev, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_dr_cb(rd_kafka_conf_t *conf, void (*dr_cb)(rd_kafka_t *rk, void *payload, size_t len, rd_kafka_resp_err_t err, void *opaque, void *msg_opaque));</span>
<span class="s1">void rd_kafka_conf_set_dr_msg_cb(rd_kafka_conf_t *conf, void (*dr_msg_cb)(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_consume_cb(rd_kafka_conf_t *conf, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_rebalance_cb(rd_kafka_conf_t *conf, void (*rebalance_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *partitions, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_offset_commit_cb(rd_kafka_conf_t *conf, void (*offset_commit_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_error_cb(rd_kafka_conf_t *conf, void (*error_cb)(rd_kafka_t *rk, int err, const char *reason, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_throttle_cb(rd_kafka_conf_t *conf, void (*throttle_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int throttle_time_ms, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_log_cb(rd_kafka_conf_t *conf, void (*log_cb)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));</span>
<span class="s1">void rd_kafka_conf_set_stats_cb(rd_kafka_conf_t *conf, int (*stats_cb)(rd_kafka_t *rk, char *json, size_t json_len, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_oauthbearer_token_refresh_cb(rd_kafka_conf_t *conf, void (*oauthbearer_token_refresh_cb)(rd_kafka_t *rk, const char *oauthbearer_config, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_socket_cb(rd_kafka_conf_t *conf, int (*socket_cb)(int domain, int type, int protocol, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_connect_cb(rd_kafka_conf_t *conf, int (*connect_cb)(int sockfd, const struct sockaddr *addr, int addrlen, const char *id, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_closesocket_cb(rd_kafka_conf_t *conf, int (*closesocket_cb)(int sockfd, void *opaque));</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert_verify_cb(rd_kafka_conf_t *conf, int (*ssl_cert_verify_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int *x509_error, int depth, const char *buf, size_t size, char *errstr, size_t errstr_size, void *opaque));</span>
<span class="s1">typedef enum rd_kafka_cert_type_t {</span>
<span class="s1">  RD_KAFKA_CERT_PUBLIC_KEY,</span>
<span class="s1">  RD_KAFKA_CERT_PRIVATE_KEY,</span>
<span class="s1">  RD_KAFKA_CERT_CA,</span>
<span class="s1">  RD_KAFKA_CERT__CNT,</span>
<span class="s1">} rd_kafka_cert_type_t;</span>
<span class="s1">typedef enum rd_kafka_cert_enc_t {</span>
<span class="s1">  RD_KAFKA_CERT_ENC_PKCS12,</span>
<span class="s1">  RD_KAFKA_CERT_ENC_DER,</span>
<span class="s1">  RD_KAFKA_CERT_ENC_PEM,</span>
<span class="s1">  RD_KAFKA_CERT_ENC__CNT,</span>
<span class="s1">} rd_kafka_cert_enc_t;</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert(rd_kafka_conf_t *conf, rd_kafka_cert_type_t cert_type, rd_kafka_cert_enc_t cert_enc, const void *buffer, size_t size, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_conf_set_opaque(rd_kafka_conf_t *conf, void *opaque);</span>
<span class="s1">void *rd_kafka_opaque(const rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_conf_set_default_topic_conf(rd_kafka_conf_t *conf, rd_kafka_topic_conf_t *tconf);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_get(const rd_kafka_conf_t *conf, const char *name, char *dest, size_t *dest_size);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_topic_conf_get(const rd_kafka_topic_conf_t *conf, const char *name, char *dest, size_t *dest_size);</span>
<span class="s1">const char **rd_kafka_conf_dump(rd_kafka_conf_t *conf, size_t *cntp);</span>
<span class="s1">const char **rd_kafka_topic_conf_dump(rd_kafka_topic_conf_t *conf, size_t *cntp);</span>
<span class="s1">void rd_kafka_conf_dump_free(const char **arr, size_t cnt);</span>
<span class="s1">void rd_kafka_conf_properties_show(FILE *fp);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_topic_conf_new(void);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_topic_conf_dup(const rd_kafka_topic_conf_t *conf);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_default_topic_conf_dup(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_topic_conf_destroy(rd_kafka_topic_conf_t *topic_conf);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_topic_conf_set(rd_kafka_topic_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_topic_conf_set_opaque(rd_kafka_topic_conf_t *conf, void *rkt_opaque);</span>
<span class="s1">void rd_kafka_topic_conf_set_partitioner_cb(rd_kafka_topic_conf_t *topic_conf, int32_t (*partitioner)(const rd_kafka_topic_t *rkt, const void *keydata, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque));</span>
<span class="s1">void rd_kafka_topic_conf_set_msg_order_cmp(rd_kafka_topic_conf_t *topic_conf, int (*msg_order_cmp)(const rd_kafka_message_t *a, const rd_kafka_message_t *b));</span>
<span class="s1">int rd_kafka_topic_partition_available(const rd_kafka_topic_t *rkt, int32_t partition);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_consistent(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_consistent_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_murmur2(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_murmur2_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_fnv1a(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_fnv1a_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">rd_kafka_t *rd_kafka_new(rd_kafka_type_t type, rd_kafka_conf_t *conf, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_destroy(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_destroy_flags(rd_kafka_t *rk, int flags);</span>
<span class="s1">const char *rd_kafka_name(const rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_type_t rd_kafka_type(const rd_kafka_t *rk);</span>
<span class="s1">char *rd_kafka_memberid(const rd_kafka_t *rk);</span>
<span class="s1">char *rd_kafka_clusterid(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">int32_t rd_kafka_controllerid(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_topic_t *rd_kafka_topic_new(rd_kafka_t *rk, const char *topic, rd_kafka_topic_conf_t *conf);</span>
<span class="s1">void rd_kafka_topic_destroy(rd_kafka_topic_t *rkt);</span>
<span class="s1">const char *rd_kafka_topic_name(const rd_kafka_topic_t *rkt);</span>
<span class="s1">void *rd_kafka_topic_opaque(const rd_kafka_topic_t *rkt);</span>
<span class="s1">int rd_kafka_poll(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">void rd_kafka_yield(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_pause_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_resume_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_query_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_get_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offsets_for_times(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets, int timeout_ms);</span>
<span class="s1">void rd_kafka_mem_free(rd_kafka_t *rk, void *ptr);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_new(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_queue_destroy(rd_kafka_queue_t *rkqu);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_main(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_consumer(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_partition(rd_kafka_t *rk, const char *topic, int32_t partition);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_background(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_queue_forward(rd_kafka_queue_t *src, rd_kafka_queue_t *dst);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_set_log_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu);</span>
<span class="s1">size_t rd_kafka_queue_length(rd_kafka_queue_t *rkqu);</span>
<span class="s1">void rd_kafka_queue_io_event_enable(rd_kafka_queue_t *rkqu, int fd, const void *payload, size_t size);</span>
<span class="s1">void rd_kafka_queue_cb_event_enable(rd_kafka_queue_t *rkqu, void (*event_cb)(rd_kafka_t *rk, void *qev_opaque), void *qev_opaque);</span>
<span class="s1">int rd_kafka_consume_start(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);</span>
<span class="s1">int rd_kafka_consume_start_queue(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, rd_kafka_queue_t *rkqu);</span>
<span class="s1">int rd_kafka_consume_stop(rd_kafka_topic_t *rkt, int32_t partition);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_seek(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, int timeout_ms);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consume(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms);</span>
<span class="s1">ssize_t rd_kafka_consume_batch(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);</span>
<span class="s1">int rd_kafka_consume_callback(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consume_queue(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">ssize_t rd_kafka_consume_batch_queue(rd_kafka_queue_t *rkqu, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);</span>
<span class="s1">int rd_kafka_consume_callback_queue(rd_kafka_queue_t *rkqu, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offset_store(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offsets_store(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_subscribe(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *topics);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_unsubscribe(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_subscription(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **topics);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consumer_poll(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_consumer_close(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_assignment(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, int async);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit_message(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, int async);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit_queue(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_queue_t *rkqu, void (*cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *commit_opaque), void *commit_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_committed(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_position(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata_new(const char *group_id);</span>
<span class="s1">void rd_kafka_consumer_group_metadata_destroy(rd_kafka_consumer_group_metadata_t *);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_consumer_group_metadata_write(const rd_kafka_consumer_group_metadata_t *cgmd, void **bufferp, size_t *sizep);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_consumer_group_metadata_read(rd_kafka_consumer_group_metadata_t **cgmdp, const void *buffer, size_t size);</span>
<span class="s1">int rd_kafka_produce(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, void *payload, size_t len, const void *key, size_t keylen, void *msg_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_producev(rd_kafka_t *rk, ...);</span>
<span class="s1">int rd_kafka_produce_batch(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, rd_kafka_message_t *rkmessages, int message_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_flush(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_purge(rd_kafka_t *rk, int purge_flags);</span>
<span class="s1">typedef struct rd_kafka_metadata_broker {</span>
<span class="s1">  int32_t id;</span>
<span class="s1">  char *host;</span>
<span class="s1">  int port;</span>
<span class="s1">} rd_kafka_metadata_broker_t;</span>
<span class="s1">typedef struct rd_kafka_metadata_partition {</span>
<span class="s1">  int32_t id;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  int32_t leader;</span>
<span class="s1">  int replica_cnt;</span>
<span class="s1">  int32_t *replicas;</span>
<span class="s1">  int isr_cnt;</span>
<span class="s1">  int32_t *isrs;</span>
<span class="s1">} rd_kafka_metadata_partition_t;</span>
<span class="s1">typedef struct rd_kafka_metadata_topic {</span>
<span class="s1">  char *topic;</span>
<span class="s1">  int partition_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_partition *partitions;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">} rd_kafka_metadata_topic_t;</span>
<span class="s1">typedef struct rd_kafka_metadata {</span>
<span class="s1">  int broker_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_broker *brokers;</span>
<span class="s1">  int topic_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_topic *topics;</span>
<span class="s1">  int32_t orig_broker_id;</span>
<span class="s1">  char *orig_broker_name;</span>
<span class="s1">} rd_kafka_metadata_t;</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_metadata(rd_kafka_t *rk, int all_topics, rd_kafka_topic_t *only_rkt, const struct rd_kafka_metadata **metadatap, int timeout_ms);</span>
<span class="s1">void rd_kafka_metadata_destroy(const struct rd_kafka_metadata *metadata);</span>
<span class="s1">struct rd_kafka_group_member_info {</span>
<span class="s1">  char *member_id;</span>
<span class="s1">  char *client_id;</span>
<span class="s1">  char *client_host;</span>
<span class="s1">  void *member_metadata;</span>
<span class="s1">  int member_metadata_size;</span>
<span class="s1">  void *member_assignment;</span>
<span class="s1">  int member_assignment_size;</span>
<span class="s1">};</span>
<span class="s1">struct rd_kafka_group_info {</span>
<span class="s1">  struct rd_kafka_metadata_broker broker;</span>
<span class="s1">  char *group;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  char *state;</span>
<span class="s1">  char *protocol_type;</span>
<span class="s1">  char *protocol;</span>
<span class="s1">  struct rd_kafka_group_member_info *members;</span>
<span class="s1">  int member_cnt;</span>
<span class="s1">};</span>
<span class="s1">struct rd_kafka_group_list {</span>
<span class="s1">  struct rd_kafka_group_info *groups;</span>
<span class="s1">  int group_cnt;</span>
<span class="s1">};</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_list_groups(rd_kafka_t *rk, const char *group, const struct rd_kafka_group_list **grplistp, int timeout_ms);</span>
<span class="s1">void rd_kafka_group_list_destroy(const struct rd_kafka_group_list *grplist);</span>
<span class="s1">int rd_kafka_brokers_add(rd_kafka_t *rk, const char *brokerlist);</span>
<span class="s1">void rd_kafka_set_logger(rd_kafka_t *rk, void (*func)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));</span>
<span class="s1">void rd_kafka_set_log_level(rd_kafka_t *rk, int level);</span>
<span class="s1">void rd_kafka_log_print(const rd_kafka_t *rk, int level, const char *fac, const char *buf);</span>
<span class="s1">void rd_kafka_log_syslog(const rd_kafka_t *rk, int level, const char *fac, const char *buf);</span>
<span class="s1">int rd_kafka_outq_len(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_dump(FILE *fp, rd_kafka_t *rk);</span>
<span class="s1">int rd_kafka_thread_cnt(void);</span>
<span class="s1">typedef enum rd_kafka_thread_type_t {</span>
<span class="s1">  RD_KAFKA_THREAD_MAIN,</span>
<span class="s1">  RD_KAFKA_THREAD_BACKGROUND,</span>
<span class="s1">  RD_KAFKA_THREAD_BROKER,</span>
<span class="s1">} rd_kafka_thread_type_t;</span>
<span class="s1">int rd_kafka_wait_destroyed(int timeout_ms);</span>
<span class="s1">int rd_kafka_unittest(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_poll_set_consumer(rd_kafka_t *rk);</span>
<span class="s1">typedef int rd_kafka_event_type_t;</span>
<span class="s1">rd_kafka_event_type_t rd_kafka_event_type(const rd_kafka_event_t *rkev);</span>
<span class="s1">const char *rd_kafka_event_name(const rd_kafka_event_t *rkev);</span>
<span class="s1">void rd_kafka_event_destroy(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_message_t *rd_kafka_event_message_next(rd_kafka_event_t *rkev);</span>
<span class="s1">size_t rd_kafka_event_message_array(rd_kafka_event_t *rkev, const rd_kafka_message_t **rkmessages, size_t size);</span>
<span class="s1">size_t rd_kafka_event_message_count(rd_kafka_event_t *rkev);</span>
<span class="s1">const char *rd_kafka_event_config_string(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_event_error(rd_kafka_event_t *rkev);</span>
<span class="s1">const char *rd_kafka_event_error_string(rd_kafka_event_t *rkev);</span>
<span class="s1">int rd_kafka_event_error_is_fatal(rd_kafka_event_t *rkev);</span>
<span class="s1">void *rd_kafka_event_opaque(rd_kafka_event_t *rkev);</span>
<span class="s1">int rd_kafka_event_log(rd_kafka_event_t *rkev, const char **fac, const char **str, int *level);</span>
<span class="s1">const char *rd_kafka_event_stats(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_event_topic_partition_list(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_event_topic_partition(rd_kafka_event_t *rkev);</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_CreateTopics_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DeleteTopics_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_CreatePartitions_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_AlterConfigs_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DescribeConfigs_result_t;</span>
<span class="s1">const rd_kafka_CreateTopics_result_t *rd_kafka_event_CreateTopics_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DeleteTopics_result_t *rd_kafka_event_DeleteTopics_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_CreatePartitions_result_t *rd_kafka_event_CreatePartitions_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_AlterConfigs_result_t *rd_kafka_event_AlterConfigs_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DescribeConfigs_result_t *rd_kafka_event_DescribeConfigs_result(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_event_t *rd_kafka_queue_poll(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">int rd_kafka_queue_poll_callback(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_plugin_f_conf_init_t)(rd_kafka_conf_t *conf, void **plug_opaquep, char *errstr, size_t errstr_size);</span>
<span class="s1">typedef rd_kafka_conf_res_t (rd_kafka_interceptor_f_on_conf_set_t)(rd_kafka_conf_t *conf, const char *name, const char *val, char *errstr, size_t errstr_size, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_dup_t)(rd_kafka_conf_t *new_conf, const rd_kafka_conf_t *old_conf, size_t filter_cnt, const char **filter, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_destroy_t)(void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_new_t)(rd_kafka_t *rk, const rd_kafka_conf_t *conf, void *ic_opaque, char *errstr, size_t errstr_size);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_destroy_t)(rd_kafka_t *rk, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_send_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_acknowledgement_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_consume_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_commit_t)(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_resp_err_t err, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_request_sent_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_start_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_exit_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_set(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_set_t *on_conf_set, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_dup(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_dup_t *on_conf_dup, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_destroy(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_destroy_t *on_conf_destroy, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_new(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_new_t *on_new, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_destroy(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_destroy_t *on_destroy, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_send(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_send_t *on_send, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_acknowledgement(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_acknowledgement_t *on_acknowledgement, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_consume(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_consume_t *on_consume, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_commit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_commit_t *on_commit, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_request_sent(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_request_sent_t *on_request_sent, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_start(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_start_t *on_thread_start, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_exit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_exit_t *on_thread_exit, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_topic_result_error(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">const char *rd_kafka_topic_result_error_string(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">const char *rd_kafka_topic_result_name(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">typedef enum rd_kafka_admin_op_t {</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_ANY = 0,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_CREATETOPICS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DELETETOPICS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_CREATEPARTITIONS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_ALTERCONFIGS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DESCRIBECONFIGS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP__CNT,</span>
<span class="s1">} rd_kafka_admin_op_t;</span>
<span class="s1">typedef struct rd_kafka_AdminOptions_s rd_kafka_AdminOptions_t;</span>
<span class="s1">rd_kafka_AdminOptions_t *rd_kafka_AdminOptions_new(rd_kafka_t *rk, rd_kafka_admin_op_t for_api);</span>
<span class="s1">void rd_kafka_AdminOptions_destroy(rd_kafka_AdminOptions_t *options);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_request_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_operation_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_validate_only(rd_kafka_AdminOptions_t *options, int true_or_false, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_broker(rd_kafka_AdminOptions_t *options, int32_t broker_id, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_AdminOptions_set_opaque(rd_kafka_AdminOptions_t *options, void *ev_opaque);</span>
<span class="s1">typedef struct rd_kafka_NewTopic_s rd_kafka_NewTopic_t;</span>
<span class="s1">rd_kafka_NewTopic_t *rd_kafka_NewTopic_new(const char *topic, int num_partitions, int replication_factor, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_NewTopic_destroy(rd_kafka_NewTopic_t *new_topic);</span>
<span class="s1">void rd_kafka_NewTopic_destroy_array(rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewTopic_set_replica_assignment(rd_kafka_NewTopic_t *new_topic, int32_t partition, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewTopic_set_config(rd_kafka_NewTopic_t *new_topic, const char *name, const char *value);</span>
<span class="s1">void rd_kafka_CreateTopics(rd_kafka_t *rk, rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_CreateTopics_result_topics(const rd_kafka_CreateTopics_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_DeleteTopic_s rd_kafka_DeleteTopic_t;</span>
<span class="s1">rd_kafka_DeleteTopic_t *rd_kafka_DeleteTopic_new(const char *topic);</span>
<span class="s1">void rd_kafka_DeleteTopic_destroy(rd_kafka_DeleteTopic_t *del_topic);</span>
<span class="s1">void rd_kafka_DeleteTopic_destroy_array(rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt);</span>
<span class="s1">void rd_kafka_DeleteTopics(rd_kafka_t *rk, rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_DeleteTopics_result_topics(const rd_kafka_DeleteTopics_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_NewPartitions_s rd_kafka_NewPartitions_t;</span>
<span class="s1">rd_kafka_NewPartitions_t *rd_kafka_NewPartitions_new(const char *topic, size_t new_total_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_NewPartitions_destroy(rd_kafka_NewPartitions_t *new_parts);</span>
<span class="s1">void rd_kafka_NewPartitions_destroy_array(rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewPartitions_set_replica_assignment(rd_kafka_NewPartitions_t *new_parts, int32_t new_partition_idx, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_CreatePartitions(rd_kafka_t *rk, rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_CreatePartitions_result_topics(const rd_kafka_CreatePartitions_result_t *result, size_t *cntp);</span>
<span class="s1">typedef enum rd_kafka_ConfigSource_t {</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_UNKNOWN_CONFIG = 0,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_TOPIC_CONFIG = 1,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_BROKER_CONFIG = 2,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_DEFAULT_BROKER_CONFIG = 3,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_STATIC_BROKER_CONFIG = 4,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DEFAULT_CONFIG = 5,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE__CNT,</span>
<span class="s1">} rd_kafka_ConfigSource_t;</span>
<span class="s1">const char *rd_kafka_ConfigSource_name(rd_kafka_ConfigSource_t confsource);</span>
<span class="s1">typedef struct rd_kafka_ConfigEntry_s rd_kafka_ConfigEntry_t;</span>
<span class="s1">const char *rd_kafka_ConfigEntry_name(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">const char *rd_kafka_ConfigEntry_value(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">rd_kafka_ConfigSource_t rd_kafka_ConfigEntry_source(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_read_only(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_default(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_sensitive(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_synonym(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">const rd_kafka_ConfigEntry_t **rd_kafka_ConfigEntry_synonyms(const rd_kafka_ConfigEntry_t *entry, size_t *cntp);</span>
<span class="s1">typedef enum rd_kafka_ResourceType_t {</span>
<span class="s1">  RD_KAFKA_RESOURCE_UNKNOWN = 0,</span>
<span class="s1">  RD_KAFKA_RESOURCE_ANY = 1,</span>
<span class="s1">  RD_KAFKA_RESOURCE_TOPIC = 2,</span>
<span class="s1">  RD_KAFKA_RESOURCE_GROUP = 3,</span>
<span class="s1">  RD_KAFKA_RESOURCE_BROKER = 4,</span>
<span class="s1">  RD_KAFKA_RESOURCE__CNT,</span>
<span class="s1">} rd_kafka_ResourceType_t;</span>
<span class="s1">const char *rd_kafka_ResourceType_name(rd_kafka_ResourceType_t restype);</span>
<span class="s1">typedef struct rd_kafka_ConfigResource_s rd_kafka_ConfigResource_t;</span>
<span class="s1">rd_kafka_ConfigResource_t *rd_kafka_ConfigResource_new(rd_kafka_ResourceType_t restype, const char *resname);</span>
<span class="s1">void rd_kafka_ConfigResource_destroy(rd_kafka_ConfigResource_t *config);</span>
<span class="s1">void rd_kafka_ConfigResource_destroy_array(rd_kafka_ConfigResource_t **config, size_t config_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_ConfigResource_set_config(rd_kafka_ConfigResource_t *config, const char *name, const char *value);</span>
<span class="s1">const rd_kafka_ConfigEntry_t **rd_kafka_ConfigResource_configs(const rd_kafka_ConfigResource_t *config, size_t *cntp);</span>
<span class="s1">rd_kafka_ResourceType_t rd_kafka_ConfigResource_type(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">const char *rd_kafka_ConfigResource_name(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_ConfigResource_error(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">const char *rd_kafka_ConfigResource_error_string(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">void rd_kafka_AlterConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_ConfigResource_t **rd_kafka_AlterConfigs_result_resources(const rd_kafka_AlterConfigs_result_t *result, size_t *cntp);</span>
<span class="s1">void rd_kafka_DescribeConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_ConfigResource_t **rd_kafka_DescribeConfigs_result_resources(const rd_kafka_DescribeConfigs_result_t *result, size_t *cntp);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token(rd_kafka_t *rk, const char *token_value, int64_t md_lifetime_ms, const char *md_principal_name, const char **extensions, size_t extension_size, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token_failure(rd_kafka_t *rk, const char *errstr);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_init_transactions(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_begin_transaction(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_send_offsets_to_transaction(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, const rd_kafka_consumer_group_metadata_t *cgmetadata, int timeout_ms);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_commit_transaction(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_abort_transaction(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">typedef struct rd_kafka_mock_cluster_s rd_kafka_mock_cluster_t;</span>
<span class="s1">rd_kafka_mock_cluster_t *rd_kafka_mock_cluster_new(rd_kafka_t *rk, int broker_cnt);</span>
<span class="s1">void rd_kafka_mock_cluster_destroy(rd_kafka_mock_cluster_t *mcluster);</span>
<span class="s1">rd_kafka_t *rd_kafka_mock_cluster_handle(const rd_kafka_mock_cluster_t *mcluster);</span>
<span class="s1">rd_kafka_mock_cluster_t *rd_kafka_handle_mock_cluster(const rd_kafka_t *rk);</span>
<span class="s1">const char *rd_kafka_mock_cluster_bootstraps(const rd_kafka_mock_cluster_t *mcluster);</span>
<span class="s1">void rd_kafka_mock_push_request_errors(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, size_t cnt, ...);</span>
<span class="s1">void rd_kafka_mock_topic_set_error(rd_kafka_mock_cluster_t *mcluster, const char *topic, rd_kafka_resp_err_t err);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_topic_create(rd_kafka_mock_cluster_t *mcluster, const char *topic, int partition_cnt, int replication_factor);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_partition_set_leader(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_partition_set_follower(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_partition_set_follower_wmarks(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int64_t lo, int64_t hi);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_set_down(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_set_up(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_set_rack(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, const char *rack);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_coordinator_set(rd_kafka_mock_cluster_t *mcluster, const char *key_type, const char *key, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_set_apiversion(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, int16_t MinVersion, int16_t MaxVersion);</span>
<span class="s1">&#39;</span>
</code></pre></div>
rdkafka.h, rdkafka_mock.h</p>
<h3 id="rd_kafka_version_9">RD_KAFKA_VERSION<a class="headerlink" href="#rd_kafka_version_9" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_VERSION</span> <span class="o">=</span> <span class="mi">17040639</span>
</code></pre></div>
<p>librdkafka version </p>
<p>Interpreted as hex <code>MM.mm.rr.xx</code>:</p>
<ul>
<li>MM = Major</li>
<li>mm = minor</li>
<li>rr = revision</li>
<li>xx = pre-release id (0xff is the final release)</li>
</ul>
<p>E.g.: <code>0x000801ff</code> = 0.8.1</p>
<dl class="section remark"><dt>Remarks</dt><dd>This value should only be used during compile time, for runtime checks of version use rd_kafka_version() </dd></dl>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_unsupported_compression_type_9">RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE<a class="headerlink" href="#rd_kafka_resp_err_unsupported_compression_type_9" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE</span> <span class="o">=</span> <span class="mi">76</span>
</code></pre></div>
<p>Unsupported compression type </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_end_all_9">RD_KAFKA_RESP_ERR_END_ALL<a class="headerlink" href="#rd_kafka_resp_err_end_all_9" title="Permanent link">&para;</a></h3>
<p><div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_END_ALL</span> <span class="o">=</span> <span class="mi">83</span>
</code></pre></div>
enum rd_kafka_resp_err_t</p>
<h3 id="rd_kafka_admin_op__cnt_9">RD_KAFKA_ADMIN_OP__CNT<a class="headerlink" href="#rd_kafka_admin_op__cnt_9" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_ADMIN_OP__CNT</span> <span class="o">=</span> <span class="mi">6</span>
</code></pre></div>
<p>Number of ops defined </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe </a></li>
</ul>
</div>
<h3 id="rd_kafka_resource__cnt_9">RD_KAFKA_RESOURCE__CNT<a class="headerlink" href="#rd_kafka_resource__cnt_9" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESOURCE__CNT</span> <span class="o">=</span> <span class="mi">5</span>
</code></pre></div>
<p>Number of resource types defined </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#acca83a66d7783ff7683ed2691cc907c9"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#acca83a66d7783ff7683ed2691cc907c9 </a></li>
</ul>
</div>
<h3 id="rd_kafka_cdef_9">RD_KAFKA_CDEF<a class="headerlink" href="#rd_kafka_cdef_9" title="Permanent link">&para;</a></h3>
<p><div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_CDEF</span> <span class="o">=</span> <span class="s1">&#39;typedef long int ssize_t;</span>
<span class="s1">typedef struct _IO_FILE FILE;</span>
<span class="s1">typedef long int mode_t;</span>
<span class="s1">typedef signed int int16_t;</span>
<span class="s1">typedef unsigned int uint16_t;</span>
<span class="s1">typedef signed int int32_t;</span>
<span class="s1">typedef signed long int int64_t;</span>
<span class="s1">int rd_kafka_version(void);</span>
<span class="s1">const char *rd_kafka_version_str(void);</span>
<span class="s1">typedef enum rd_kafka_type_t {</span>
<span class="s1">  RD_KAFKA_PRODUCER,</span>
<span class="s1">  RD_KAFKA_CONSUMER,</span>
<span class="s1">} rd_kafka_type_t;</span>
<span class="s1">typedef enum rd_kafka_timestamp_type_t {</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_NOT_AVAILABLE,</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_CREATE_TIME,</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_LOG_APPEND_TIME,</span>
<span class="s1">} rd_kafka_timestamp_type_t;</span>
<span class="s1">const char *rd_kafka_get_debug_contexts(void);</span>
<span class="s1">typedef struct rd_kafka_s rd_kafka_t;</span>
<span class="s1">typedef struct rd_kafka_topic_s rd_kafka_topic_t;</span>
<span class="s1">typedef struct rd_kafka_conf_s rd_kafka_conf_t;</span>
<span class="s1">typedef struct rd_kafka_topic_conf_s rd_kafka_topic_conf_t;</span>
<span class="s1">typedef struct rd_kafka_queue_s rd_kafka_queue_t;</span>
<span class="s1">typedef struct rd_kafka_op_s rd_kafka_event_t;</span>
<span class="s1">typedef struct rd_kafka_topic_result_s rd_kafka_topic_result_t;</span>
<span class="s1">typedef struct rd_kafka_consumer_group_metadata_s rd_kafka_consumer_group_metadata_t;</span>
<span class="s1">typedef struct rd_kafka_error_s {</span>
<span class="s1">  unsigned int code;</span>
<span class="s1">  char *errstr;</span>
<span class="s1">  unsigned char fatal;</span>
<span class="s1">  unsigned char retriable;</span>
<span class="s1">  unsigned char txn_requires_abort;</span>
<span class="s1">} rd_kafka_error_t;</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BEGIN = (- 200),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BAD_MSG = (- 199),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BAD_COMPRESSION = (- 198),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__DESTROY = (- 197),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FAIL = (- 196),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TRANSPORT = (- 195),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__CRIT_SYS_RESOURCE = (- 194),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__RESOLVE = (- 193),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__MSG_TIMED_OUT = (- 192),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PARTITION_EOF = (- 191),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION = (- 190),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FS = (- 189),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC = (- 188),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ALL_BROKERS_DOWN = (- 187),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INVALID_ARG = (- 186),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TIMED_OUT = (- 185),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__QUEUE_FULL = (- 184),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ISR_INSUFF = (- 183),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NODE_UPDATE = (- 182),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__SSL = (- 181),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__WAIT_COORD = (- 180),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_GROUP = (- 179),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__IN_PROGRESS = (- 178),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PREV_IN_PROGRESS = (- 177),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__EXISTING_SUBSCRIPTION = (- 176),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS = (- 175),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS = (- 174),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__CONFLICT = (- 173),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__STATE = (- 172),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_PROTOCOL = (- 171),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED = (- 170),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__AUTHENTICATION = (- 169),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NO_OFFSET = (- 168),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__OUTDATED = (- 167),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TIMED_OUT_QUEUE = (- 166),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNSUPPORTED_FEATURE = (- 165),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__WAIT_CACHE = (- 164),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INTR = (- 163),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__KEY_SERIALIZATION = (- 162),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__VALUE_SERIALIZATION = (- 161),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__KEY_DESERIALIZATION = (- 160),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__VALUE_DESERIALIZATION = (- 159),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PARTIAL = (- 158),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__READ_ONLY = (- 157),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOENT = (- 156),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNDERFLOW = (- 155),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INVALID_TYPE = (- 154),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__RETRY = (- 153),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PURGE_QUEUE = (- 152),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PURGE_INFLIGHT = (- 151),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FATAL = (- 150),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INCONSISTENT = (- 149),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__GAPLESS_GUARANTEE = (- 148),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__MAX_POLL_EXCEEDED = (- 147),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_BROKER = (- 146),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOT_CONFIGURED = (- 145),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FENCED = (- 144),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__APPLICATION = (- 143),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__END = (- 100),</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN = (- 1),</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NO_ERROR = 0,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_OUT_OF_RANGE = 1,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_MSG = 2,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART = 3,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_MSG_SIZE = 4,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE = 5,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_LEADER_FOR_PARTITION = 6,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REQUEST_TIMED_OUT = 7,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_BROKER_NOT_AVAILABLE = 8,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REPLICA_NOT_AVAILABLE = 9,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE = 10,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_STALE_CTRL_EPOCH = 11,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_METADATA_TOO_LARGE = 12,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NETWORK_EXCEPTION = 13,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_COORDINATOR_LOAD_IN_PROGRESS = 14,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_COORDINATOR_NOT_AVAILABLE = 15,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_COORDINATOR = 16,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_EXCEPTION = 17,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_RECORD_LIST_TOO_LARGE = 18,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS = 19,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS_AFTER_APPEND = 20,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REQUIRED_ACKS = 21,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ILLEGAL_GENERATION = 22,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INCONSISTENT_GROUP_PROTOCOL = 23,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_GROUP_ID = 24,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_MEMBER_ID = 25,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_SESSION_TIMEOUT = 26,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REBALANCE_IN_PROGRESS = 27,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_COMMIT_OFFSET_SIZE = 28,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_AUTHORIZATION_FAILED = 29,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_AUTHORIZATION_FAILED = 30,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_CLUSTER_AUTHORIZATION_FAILED = 31,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TIMESTAMP = 32,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_SASL_MECHANISM = 33,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ILLEGAL_SASL_STATE = 34,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_VERSION = 35,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_ALREADY_EXISTS = 36,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PARTITIONS = 37,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REPLICATION_FACTOR = 38,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REPLICA_ASSIGNMENT = 39,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_CONFIG = 40,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_CONTROLLER = 41,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REQUEST = 42,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_FOR_MESSAGE_FORMAT = 43,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_POLICY_VIOLATION = 44,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OUT_OF_ORDER_SEQUENCE_NUMBER = 45,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DUPLICATE_SEQUENCE_NUMBER = 46,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_EPOCH = 47,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TXN_STATE = 48,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_ID_MAPPING = 49,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TRANSACTION_TIMEOUT = 50,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_CONCURRENT_TRANSACTIONS = 51,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TRANSACTION_COORDINATOR_FENCED = 52,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TRANSACTIONAL_ID_AUTHORIZATION_FAILED = 53,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_SECURITY_DISABLED = 54,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OPERATION_NOT_ATTEMPTED = 55,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_KAFKA_STORAGE_ERROR = 56,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LOG_DIR_NOT_FOUND = 57,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_SASL_AUTHENTICATION_FAILED = 58,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_PRODUCER_ID = 59,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REASSIGNMENT_IN_PROGRESS = 60,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTH_DISABLED = 61,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_NOT_FOUND = 62,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_OWNER_MISMATCH = 63,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_REQUEST_NOT_ALLOWED = 64,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTHORIZATION_FAILED = 65,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_EXPIRED = 66,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRINCIPAL_TYPE = 67,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NON_EMPTY_GROUP = 68,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_ID_NOT_FOUND = 69,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FETCH_SESSION_ID_NOT_FOUND = 70,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_FETCH_SESSION_EPOCH = 71,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LISTENER_NOT_FOUND = 72,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_DELETION_DISABLED = 73,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FENCED_LEADER_EPOCH = 74,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_LEADER_EPOCH = 75,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_STALE_BROKER_EPOCH = 77,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_NOT_AVAILABLE = 78,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_MEMBER_ID_REQUIRED = 79,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_PREFERRED_LEADER_NOT_AVAILABLE = 80,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_MAX_SIZE_REACHED = 81,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FENCED_INSTANCE_ID = 82,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_END_ALL,</span>
<span class="s1">} rd_kafka_resp_err_t;</span>
<span class="s1">struct rd_kafka_err_desc {</span>
<span class="s1">  rd_kafka_resp_err_t code;</span>
<span class="s1">  char *name;</span>
<span class="s1">  char *desc;</span>
<span class="s1">};</span>
<span class="s1">void rd_kafka_get_err_descs(const struct rd_kafka_err_desc **errdescs, size_t *cntp);</span>
<span class="s1">const char *rd_kafka_err2str(rd_kafka_resp_err_t err);</span>
<span class="s1">const char *rd_kafka_err2name(rd_kafka_resp_err_t err);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_last_error(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_errno2err(int errnox);</span>
<span class="s1">int rd_kafka_errno(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_fatal_error(rd_kafka_t *rk, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_test_fatal_error(rd_kafka_t *rk, rd_kafka_resp_err_t err, const char *reason);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_error_code(const rd_kafka_error_t *error);</span>
<span class="s1">const char *rd_kafka_error_name(const rd_kafka_error_t *error);</span>
<span class="s1">const char *rd_kafka_error_string(const rd_kafka_error_t *error);</span>
<span class="s1">int rd_kafka_error_is_fatal(const rd_kafka_error_t *error);</span>
<span class="s1">int rd_kafka_error_is_retriable(const rd_kafka_error_t *error);</span>
<span class="s1">int rd_kafka_error_txn_requires_abort(const rd_kafka_error_t *error);</span>
<span class="s1">void rd_kafka_error_destroy(rd_kafka_error_t *error);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_error_new(rd_kafka_resp_err_t code, const char *fmt, ...);</span>
<span class="s1">typedef struct rd_kafka_topic_partition_s {</span>
<span class="s1">  char *topic;</span>
<span class="s1">  int32_t partition;</span>
<span class="s1">  int64_t offset;</span>
<span class="s1">  void *metadata;</span>
<span class="s1">  size_t metadata_size;</span>
<span class="s1">  void *opaque;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  void *_private;</span>
<span class="s1">} rd_kafka_topic_partition_t;</span>
<span class="s1">void rd_kafka_topic_partition_destroy(rd_kafka_topic_partition_t *rktpar);</span>
<span class="s1">typedef struct rd_kafka_topic_partition_list_s {</span>
<span class="s1">  int cnt;</span>
<span class="s1">  int size;</span>
<span class="s1">  rd_kafka_topic_partition_t *elems;</span>
<span class="s1">} rd_kafka_topic_partition_list_t;</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_new(int size);</span>
<span class="s1">void rd_kafka_topic_partition_list_destroy(rd_kafka_topic_partition_list_t *rkparlist);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_add(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">void rd_kafka_topic_partition_list_add_range(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t start, int32_t stop);</span>
<span class="s1">int rd_kafka_topic_partition_list_del(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">int rd_kafka_topic_partition_list_del_by_idx(rd_kafka_topic_partition_list_t *rktparlist, int idx);</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_copy(const rd_kafka_topic_partition_list_t *src);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_topic_partition_list_set_offset(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition, int64_t offset);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_find(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">void rd_kafka_topic_partition_list_sort(rd_kafka_topic_partition_list_t *rktparlist, int (*cmp)(const void *a, const void *b, void *cmp_opaque), void *cmp_opaque);</span>
<span class="s1">typedef enum rd_kafka_vtype_t {</span>
<span class="s1">  RD_KAFKA_VTYPE_END,</span>
<span class="s1">  RD_KAFKA_VTYPE_TOPIC,</span>
<span class="s1">  RD_KAFKA_VTYPE_RKT,</span>
<span class="s1">  RD_KAFKA_VTYPE_PARTITION,</span>
<span class="s1">  RD_KAFKA_VTYPE_VALUE,</span>
<span class="s1">  RD_KAFKA_VTYPE_KEY,</span>
<span class="s1">  RD_KAFKA_VTYPE_OPAQUE,</span>
<span class="s1">  RD_KAFKA_VTYPE_MSGFLAGS,</span>
<span class="s1">  RD_KAFKA_VTYPE_TIMESTAMP,</span>
<span class="s1">  RD_KAFKA_VTYPE_HEADER,</span>
<span class="s1">  RD_KAFKA_VTYPE_HEADERS,</span>
<span class="s1">} rd_kafka_vtype_t;</span>
<span class="s1">typedef struct rd_kafka_headers_s rd_kafka_headers_t;</span>
<span class="s1">rd_kafka_headers_t *rd_kafka_headers_new(size_t initial_count);</span>
<span class="s1">void rd_kafka_headers_destroy(rd_kafka_headers_t *hdrs);</span>
<span class="s1">rd_kafka_headers_t *rd_kafka_headers_copy(const rd_kafka_headers_t *src);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_add(rd_kafka_headers_t *hdrs, const char *name, ssize_t name_size, const void *value, ssize_t value_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_remove(rd_kafka_headers_t *hdrs, const char *name);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get_last(const rd_kafka_headers_t *hdrs, const char *name, const void **valuep, size_t *sizep);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get(const rd_kafka_headers_t *hdrs, size_t idx, const char *name, const void **valuep, size_t *sizep);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get_all(const rd_kafka_headers_t *hdrs, size_t idx, const char **namep, const void **valuep, size_t *sizep);</span>
<span class="s1">typedef struct rd_kafka_message_s {</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  rd_kafka_topic_t *rkt;</span>
<span class="s1">  int32_t partition;</span>
<span class="s1">  void *payload;</span>
<span class="s1">  size_t len;</span>
<span class="s1">  void *key;</span>
<span class="s1">  size_t key_len;</span>
<span class="s1">  int64_t offset;</span>
<span class="s1">  void *_private;</span>
<span class="s1">} rd_kafka_message_t;</span>
<span class="s1">void rd_kafka_message_destroy(rd_kafka_message_t *rkmessage);</span>
<span class="s1">int64_t rd_kafka_message_timestamp(const rd_kafka_message_t *rkmessage, rd_kafka_timestamp_type_t *tstype);</span>
<span class="s1">int64_t rd_kafka_message_latency(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_message_headers(const rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_message_detach_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);</span>
<span class="s1">void rd_kafka_message_set_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t *hdrs);</span>
<span class="s1">size_t rd_kafka_header_cnt(const rd_kafka_headers_t *hdrs);</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_NOT_PERSISTED = 0,</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_POSSIBLY_PERSISTED = 1,</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_PERSISTED = 2,</span>
<span class="s1">} rd_kafka_msg_status_t;</span>
<span class="s1">rd_kafka_msg_status_t rd_kafka_message_status(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_CONF_UNKNOWN = (- 2),</span>
<span class="s1">  RD_KAFKA_CONF_INVALID = (- 1),</span>
<span class="s1">  RD_KAFKA_CONF_OK = 0,</span>
<span class="s1">} rd_kafka_conf_res_t;</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_new(void);</span>
<span class="s1">void rd_kafka_conf_destroy(rd_kafka_conf_t *conf);</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_dup(const rd_kafka_conf_t *conf);</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_dup_filter(const rd_kafka_conf_t *conf, size_t filter_cnt, const char **filter);</span>
<span class="s1">const rd_kafka_conf_t *rd_kafka_conf(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_set(rd_kafka_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_conf_set_events(rd_kafka_conf_t *conf, int events);</span>
<span class="s1">void rd_kafka_conf_set_background_event_cb(rd_kafka_conf_t *conf, void (*event_cb)(rd_kafka_t *rk, rd_kafka_event_t *rkev, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_dr_cb(rd_kafka_conf_t *conf, void (*dr_cb)(rd_kafka_t *rk, void *payload, size_t len, rd_kafka_resp_err_t err, void *opaque, void *msg_opaque));</span>
<span class="s1">void rd_kafka_conf_set_dr_msg_cb(rd_kafka_conf_t *conf, void (*dr_msg_cb)(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_consume_cb(rd_kafka_conf_t *conf, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_rebalance_cb(rd_kafka_conf_t *conf, void (*rebalance_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *partitions, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_offset_commit_cb(rd_kafka_conf_t *conf, void (*offset_commit_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_error_cb(rd_kafka_conf_t *conf, void (*error_cb)(rd_kafka_t *rk, int err, const char *reason, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_throttle_cb(rd_kafka_conf_t *conf, void (*throttle_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int throttle_time_ms, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_log_cb(rd_kafka_conf_t *conf, void (*log_cb)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));</span>
<span class="s1">void rd_kafka_conf_set_stats_cb(rd_kafka_conf_t *conf, int (*stats_cb)(rd_kafka_t *rk, char *json, size_t json_len, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_oauthbearer_token_refresh_cb(rd_kafka_conf_t *conf, void (*oauthbearer_token_refresh_cb)(rd_kafka_t *rk, const char *oauthbearer_config, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_socket_cb(rd_kafka_conf_t *conf, int (*socket_cb)(int domain, int type, int protocol, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_connect_cb(rd_kafka_conf_t *conf, int (*connect_cb)(int sockfd, const struct sockaddr *addr, int addrlen, const char *id, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_closesocket_cb(rd_kafka_conf_t *conf, int (*closesocket_cb)(int sockfd, void *opaque));</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert_verify_cb(rd_kafka_conf_t *conf, int (*ssl_cert_verify_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int *x509_error, int depth, const char *buf, size_t size, char *errstr, size_t errstr_size, void *opaque));</span>
<span class="s1">typedef enum rd_kafka_cert_type_t {</span>
<span class="s1">  RD_KAFKA_CERT_PUBLIC_KEY,</span>
<span class="s1">  RD_KAFKA_CERT_PRIVATE_KEY,</span>
<span class="s1">  RD_KAFKA_CERT_CA,</span>
<span class="s1">  RD_KAFKA_CERT__CNT,</span>
<span class="s1">} rd_kafka_cert_type_t;</span>
<span class="s1">typedef enum rd_kafka_cert_enc_t {</span>
<span class="s1">  RD_KAFKA_CERT_ENC_PKCS12,</span>
<span class="s1">  RD_KAFKA_CERT_ENC_DER,</span>
<span class="s1">  RD_KAFKA_CERT_ENC_PEM,</span>
<span class="s1">  RD_KAFKA_CERT_ENC__CNT,</span>
<span class="s1">} rd_kafka_cert_enc_t;</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert(rd_kafka_conf_t *conf, rd_kafka_cert_type_t cert_type, rd_kafka_cert_enc_t cert_enc, const void *buffer, size_t size, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_conf_set_opaque(rd_kafka_conf_t *conf, void *opaque);</span>
<span class="s1">void *rd_kafka_opaque(const rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_conf_set_default_topic_conf(rd_kafka_conf_t *conf, rd_kafka_topic_conf_t *tconf);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_get(const rd_kafka_conf_t *conf, const char *name, char *dest, size_t *dest_size);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_topic_conf_get(const rd_kafka_topic_conf_t *conf, const char *name, char *dest, size_t *dest_size);</span>
<span class="s1">const char **rd_kafka_conf_dump(rd_kafka_conf_t *conf, size_t *cntp);</span>
<span class="s1">const char **rd_kafka_topic_conf_dump(rd_kafka_topic_conf_t *conf, size_t *cntp);</span>
<span class="s1">void rd_kafka_conf_dump_free(const char **arr, size_t cnt);</span>
<span class="s1">void rd_kafka_conf_properties_show(FILE *fp);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_topic_conf_new(void);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_topic_conf_dup(const rd_kafka_topic_conf_t *conf);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_default_topic_conf_dup(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_topic_conf_destroy(rd_kafka_topic_conf_t *topic_conf);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_topic_conf_set(rd_kafka_topic_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_topic_conf_set_opaque(rd_kafka_topic_conf_t *conf, void *rkt_opaque);</span>
<span class="s1">void rd_kafka_topic_conf_set_partitioner_cb(rd_kafka_topic_conf_t *topic_conf, int32_t (*partitioner)(const rd_kafka_topic_t *rkt, const void *keydata, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque));</span>
<span class="s1">void rd_kafka_topic_conf_set_msg_order_cmp(rd_kafka_topic_conf_t *topic_conf, int (*msg_order_cmp)(const rd_kafka_message_t *a, const rd_kafka_message_t *b));</span>
<span class="s1">int rd_kafka_topic_partition_available(const rd_kafka_topic_t *rkt, int32_t partition);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_consistent(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_consistent_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_murmur2(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_murmur2_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_fnv1a(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_fnv1a_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">rd_kafka_t *rd_kafka_new(rd_kafka_type_t type, rd_kafka_conf_t *conf, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_destroy(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_destroy_flags(rd_kafka_t *rk, int flags);</span>
<span class="s1">const char *rd_kafka_name(const rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_type_t rd_kafka_type(const rd_kafka_t *rk);</span>
<span class="s1">char *rd_kafka_memberid(const rd_kafka_t *rk);</span>
<span class="s1">char *rd_kafka_clusterid(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">int32_t rd_kafka_controllerid(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_topic_t *rd_kafka_topic_new(rd_kafka_t *rk, const char *topic, rd_kafka_topic_conf_t *conf);</span>
<span class="s1">void rd_kafka_topic_destroy(rd_kafka_topic_t *rkt);</span>
<span class="s1">const char *rd_kafka_topic_name(const rd_kafka_topic_t *rkt);</span>
<span class="s1">void *rd_kafka_topic_opaque(const rd_kafka_topic_t *rkt);</span>
<span class="s1">int rd_kafka_poll(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">void rd_kafka_yield(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_pause_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_resume_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_query_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_get_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offsets_for_times(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets, int timeout_ms);</span>
<span class="s1">void rd_kafka_mem_free(rd_kafka_t *rk, void *ptr);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_new(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_queue_destroy(rd_kafka_queue_t *rkqu);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_main(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_consumer(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_partition(rd_kafka_t *rk, const char *topic, int32_t partition);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_background(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_queue_forward(rd_kafka_queue_t *src, rd_kafka_queue_t *dst);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_set_log_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu);</span>
<span class="s1">size_t rd_kafka_queue_length(rd_kafka_queue_t *rkqu);</span>
<span class="s1">void rd_kafka_queue_io_event_enable(rd_kafka_queue_t *rkqu, int fd, const void *payload, size_t size);</span>
<span class="s1">void rd_kafka_queue_cb_event_enable(rd_kafka_queue_t *rkqu, void (*event_cb)(rd_kafka_t *rk, void *qev_opaque), void *qev_opaque);</span>
<span class="s1">int rd_kafka_consume_start(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);</span>
<span class="s1">int rd_kafka_consume_start_queue(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, rd_kafka_queue_t *rkqu);</span>
<span class="s1">int rd_kafka_consume_stop(rd_kafka_topic_t *rkt, int32_t partition);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_seek(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, int timeout_ms);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consume(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms);</span>
<span class="s1">ssize_t rd_kafka_consume_batch(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);</span>
<span class="s1">int rd_kafka_consume_callback(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consume_queue(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">ssize_t rd_kafka_consume_batch_queue(rd_kafka_queue_t *rkqu, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);</span>
<span class="s1">int rd_kafka_consume_callback_queue(rd_kafka_queue_t *rkqu, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offset_store(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offsets_store(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_subscribe(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *topics);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_unsubscribe(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_subscription(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **topics);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consumer_poll(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_consumer_close(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_assignment(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, int async);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit_message(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, int async);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit_queue(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_queue_t *rkqu, void (*cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *commit_opaque), void *commit_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_committed(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_position(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata_new(const char *group_id);</span>
<span class="s1">void rd_kafka_consumer_group_metadata_destroy(rd_kafka_consumer_group_metadata_t *);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_consumer_group_metadata_write(const rd_kafka_consumer_group_metadata_t *cgmd, void **bufferp, size_t *sizep);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_consumer_group_metadata_read(rd_kafka_consumer_group_metadata_t **cgmdp, const void *buffer, size_t size);</span>
<span class="s1">int rd_kafka_produce(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, void *payload, size_t len, const void *key, size_t keylen, void *msg_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_producev(rd_kafka_t *rk, ...);</span>
<span class="s1">int rd_kafka_produce_batch(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, rd_kafka_message_t *rkmessages, int message_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_flush(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_purge(rd_kafka_t *rk, int purge_flags);</span>
<span class="s1">typedef struct rd_kafka_metadata_broker {</span>
<span class="s1">  int32_t id;</span>
<span class="s1">  char *host;</span>
<span class="s1">  int port;</span>
<span class="s1">} rd_kafka_metadata_broker_t;</span>
<span class="s1">typedef struct rd_kafka_metadata_partition {</span>
<span class="s1">  int32_t id;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  int32_t leader;</span>
<span class="s1">  int replica_cnt;</span>
<span class="s1">  int32_t *replicas;</span>
<span class="s1">  int isr_cnt;</span>
<span class="s1">  int32_t *isrs;</span>
<span class="s1">} rd_kafka_metadata_partition_t;</span>
<span class="s1">typedef struct rd_kafka_metadata_topic {</span>
<span class="s1">  char *topic;</span>
<span class="s1">  int partition_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_partition *partitions;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">} rd_kafka_metadata_topic_t;</span>
<span class="s1">typedef struct rd_kafka_metadata {</span>
<span class="s1">  int broker_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_broker *brokers;</span>
<span class="s1">  int topic_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_topic *topics;</span>
<span class="s1">  int32_t orig_broker_id;</span>
<span class="s1">  char *orig_broker_name;</span>
<span class="s1">} rd_kafka_metadata_t;</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_metadata(rd_kafka_t *rk, int all_topics, rd_kafka_topic_t *only_rkt, const struct rd_kafka_metadata **metadatap, int timeout_ms);</span>
<span class="s1">void rd_kafka_metadata_destroy(const struct rd_kafka_metadata *metadata);</span>
<span class="s1">struct rd_kafka_group_member_info {</span>
<span class="s1">  char *member_id;</span>
<span class="s1">  char *client_id;</span>
<span class="s1">  char *client_host;</span>
<span class="s1">  void *member_metadata;</span>
<span class="s1">  int member_metadata_size;</span>
<span class="s1">  void *member_assignment;</span>
<span class="s1">  int member_assignment_size;</span>
<span class="s1">};</span>
<span class="s1">struct rd_kafka_group_info {</span>
<span class="s1">  struct rd_kafka_metadata_broker broker;</span>
<span class="s1">  char *group;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  char *state;</span>
<span class="s1">  char *protocol_type;</span>
<span class="s1">  char *protocol;</span>
<span class="s1">  struct rd_kafka_group_member_info *members;</span>
<span class="s1">  int member_cnt;</span>
<span class="s1">};</span>
<span class="s1">struct rd_kafka_group_list {</span>
<span class="s1">  struct rd_kafka_group_info *groups;</span>
<span class="s1">  int group_cnt;</span>
<span class="s1">};</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_list_groups(rd_kafka_t *rk, const char *group, const struct rd_kafka_group_list **grplistp, int timeout_ms);</span>
<span class="s1">void rd_kafka_group_list_destroy(const struct rd_kafka_group_list *grplist);</span>
<span class="s1">int rd_kafka_brokers_add(rd_kafka_t *rk, const char *brokerlist);</span>
<span class="s1">void rd_kafka_set_logger(rd_kafka_t *rk, void (*func)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));</span>
<span class="s1">void rd_kafka_set_log_level(rd_kafka_t *rk, int level);</span>
<span class="s1">void rd_kafka_log_print(const rd_kafka_t *rk, int level, const char *fac, const char *buf);</span>
<span class="s1">void rd_kafka_log_syslog(const rd_kafka_t *rk, int level, const char *fac, const char *buf);</span>
<span class="s1">int rd_kafka_outq_len(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_dump(FILE *fp, rd_kafka_t *rk);</span>
<span class="s1">int rd_kafka_thread_cnt(void);</span>
<span class="s1">typedef enum rd_kafka_thread_type_t {</span>
<span class="s1">  RD_KAFKA_THREAD_MAIN,</span>
<span class="s1">  RD_KAFKA_THREAD_BACKGROUND,</span>
<span class="s1">  RD_KAFKA_THREAD_BROKER,</span>
<span class="s1">} rd_kafka_thread_type_t;</span>
<span class="s1">int rd_kafka_wait_destroyed(int timeout_ms);</span>
<span class="s1">int rd_kafka_unittest(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_poll_set_consumer(rd_kafka_t *rk);</span>
<span class="s1">typedef int rd_kafka_event_type_t;</span>
<span class="s1">rd_kafka_event_type_t rd_kafka_event_type(const rd_kafka_event_t *rkev);</span>
<span class="s1">const char *rd_kafka_event_name(const rd_kafka_event_t *rkev);</span>
<span class="s1">void rd_kafka_event_destroy(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_message_t *rd_kafka_event_message_next(rd_kafka_event_t *rkev);</span>
<span class="s1">size_t rd_kafka_event_message_array(rd_kafka_event_t *rkev, const rd_kafka_message_t **rkmessages, size_t size);</span>
<span class="s1">size_t rd_kafka_event_message_count(rd_kafka_event_t *rkev);</span>
<span class="s1">const char *rd_kafka_event_config_string(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_event_error(rd_kafka_event_t *rkev);</span>
<span class="s1">const char *rd_kafka_event_error_string(rd_kafka_event_t *rkev);</span>
<span class="s1">int rd_kafka_event_error_is_fatal(rd_kafka_event_t *rkev);</span>
<span class="s1">void *rd_kafka_event_opaque(rd_kafka_event_t *rkev);</span>
<span class="s1">int rd_kafka_event_log(rd_kafka_event_t *rkev, const char **fac, const char **str, int *level);</span>
<span class="s1">const char *rd_kafka_event_stats(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_event_topic_partition_list(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_event_topic_partition(rd_kafka_event_t *rkev);</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_CreateTopics_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DeleteTopics_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_CreatePartitions_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_AlterConfigs_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DescribeConfigs_result_t;</span>
<span class="s1">const rd_kafka_CreateTopics_result_t *rd_kafka_event_CreateTopics_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DeleteTopics_result_t *rd_kafka_event_DeleteTopics_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_CreatePartitions_result_t *rd_kafka_event_CreatePartitions_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_AlterConfigs_result_t *rd_kafka_event_AlterConfigs_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DescribeConfigs_result_t *rd_kafka_event_DescribeConfigs_result(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_event_t *rd_kafka_queue_poll(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">int rd_kafka_queue_poll_callback(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_plugin_f_conf_init_t)(rd_kafka_conf_t *conf, void **plug_opaquep, char *errstr, size_t errstr_size);</span>
<span class="s1">typedef rd_kafka_conf_res_t (rd_kafka_interceptor_f_on_conf_set_t)(rd_kafka_conf_t *conf, const char *name, const char *val, char *errstr, size_t errstr_size, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_dup_t)(rd_kafka_conf_t *new_conf, const rd_kafka_conf_t *old_conf, size_t filter_cnt, const char **filter, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_destroy_t)(void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_new_t)(rd_kafka_t *rk, const rd_kafka_conf_t *conf, void *ic_opaque, char *errstr, size_t errstr_size);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_destroy_t)(rd_kafka_t *rk, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_send_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_acknowledgement_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_consume_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_commit_t)(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_resp_err_t err, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_request_sent_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_start_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_exit_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_set(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_set_t *on_conf_set, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_dup(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_dup_t *on_conf_dup, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_destroy(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_destroy_t *on_conf_destroy, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_new(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_new_t *on_new, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_destroy(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_destroy_t *on_destroy, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_send(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_send_t *on_send, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_acknowledgement(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_acknowledgement_t *on_acknowledgement, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_consume(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_consume_t *on_consume, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_commit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_commit_t *on_commit, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_request_sent(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_request_sent_t *on_request_sent, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_start(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_start_t *on_thread_start, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_exit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_exit_t *on_thread_exit, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_topic_result_error(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">const char *rd_kafka_topic_result_error_string(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">const char *rd_kafka_topic_result_name(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">typedef enum rd_kafka_admin_op_t {</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_ANY = 0,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_CREATETOPICS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DELETETOPICS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_CREATEPARTITIONS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_ALTERCONFIGS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DESCRIBECONFIGS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP__CNT,</span>
<span class="s1">} rd_kafka_admin_op_t;</span>
<span class="s1">typedef struct rd_kafka_AdminOptions_s rd_kafka_AdminOptions_t;</span>
<span class="s1">rd_kafka_AdminOptions_t *rd_kafka_AdminOptions_new(rd_kafka_t *rk, rd_kafka_admin_op_t for_api);</span>
<span class="s1">void rd_kafka_AdminOptions_destroy(rd_kafka_AdminOptions_t *options);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_request_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_operation_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_validate_only(rd_kafka_AdminOptions_t *options, int true_or_false, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_broker(rd_kafka_AdminOptions_t *options, int32_t broker_id, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_AdminOptions_set_opaque(rd_kafka_AdminOptions_t *options, void *ev_opaque);</span>
<span class="s1">typedef struct rd_kafka_NewTopic_s rd_kafka_NewTopic_t;</span>
<span class="s1">rd_kafka_NewTopic_t *rd_kafka_NewTopic_new(const char *topic, int num_partitions, int replication_factor, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_NewTopic_destroy(rd_kafka_NewTopic_t *new_topic);</span>
<span class="s1">void rd_kafka_NewTopic_destroy_array(rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewTopic_set_replica_assignment(rd_kafka_NewTopic_t *new_topic, int32_t partition, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewTopic_set_config(rd_kafka_NewTopic_t *new_topic, const char *name, const char *value);</span>
<span class="s1">void rd_kafka_CreateTopics(rd_kafka_t *rk, rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_CreateTopics_result_topics(const rd_kafka_CreateTopics_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_DeleteTopic_s rd_kafka_DeleteTopic_t;</span>
<span class="s1">rd_kafka_DeleteTopic_t *rd_kafka_DeleteTopic_new(const char *topic);</span>
<span class="s1">void rd_kafka_DeleteTopic_destroy(rd_kafka_DeleteTopic_t *del_topic);</span>
<span class="s1">void rd_kafka_DeleteTopic_destroy_array(rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt);</span>
<span class="s1">void rd_kafka_DeleteTopics(rd_kafka_t *rk, rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_DeleteTopics_result_topics(const rd_kafka_DeleteTopics_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_NewPartitions_s rd_kafka_NewPartitions_t;</span>
<span class="s1">rd_kafka_NewPartitions_t *rd_kafka_NewPartitions_new(const char *topic, size_t new_total_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_NewPartitions_destroy(rd_kafka_NewPartitions_t *new_parts);</span>
<span class="s1">void rd_kafka_NewPartitions_destroy_array(rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewPartitions_set_replica_assignment(rd_kafka_NewPartitions_t *new_parts, int32_t new_partition_idx, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_CreatePartitions(rd_kafka_t *rk, rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_CreatePartitions_result_topics(const rd_kafka_CreatePartitions_result_t *result, size_t *cntp);</span>
<span class="s1">typedef enum rd_kafka_ConfigSource_t {</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_UNKNOWN_CONFIG = 0,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_TOPIC_CONFIG = 1,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_BROKER_CONFIG = 2,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_DEFAULT_BROKER_CONFIG = 3,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_STATIC_BROKER_CONFIG = 4,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DEFAULT_CONFIG = 5,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE__CNT,</span>
<span class="s1">} rd_kafka_ConfigSource_t;</span>
<span class="s1">const char *rd_kafka_ConfigSource_name(rd_kafka_ConfigSource_t confsource);</span>
<span class="s1">typedef struct rd_kafka_ConfigEntry_s rd_kafka_ConfigEntry_t;</span>
<span class="s1">const char *rd_kafka_ConfigEntry_name(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">const char *rd_kafka_ConfigEntry_value(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">rd_kafka_ConfigSource_t rd_kafka_ConfigEntry_source(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_read_only(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_default(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_sensitive(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_synonym(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">const rd_kafka_ConfigEntry_t **rd_kafka_ConfigEntry_synonyms(const rd_kafka_ConfigEntry_t *entry, size_t *cntp);</span>
<span class="s1">typedef enum rd_kafka_ResourceType_t {</span>
<span class="s1">  RD_KAFKA_RESOURCE_UNKNOWN = 0,</span>
<span class="s1">  RD_KAFKA_RESOURCE_ANY = 1,</span>
<span class="s1">  RD_KAFKA_RESOURCE_TOPIC = 2,</span>
<span class="s1">  RD_KAFKA_RESOURCE_GROUP = 3,</span>
<span class="s1">  RD_KAFKA_RESOURCE_BROKER = 4,</span>
<span class="s1">  RD_KAFKA_RESOURCE__CNT,</span>
<span class="s1">} rd_kafka_ResourceType_t;</span>
<span class="s1">const char *rd_kafka_ResourceType_name(rd_kafka_ResourceType_t restype);</span>
<span class="s1">typedef struct rd_kafka_ConfigResource_s rd_kafka_ConfigResource_t;</span>
<span class="s1">rd_kafka_ConfigResource_t *rd_kafka_ConfigResource_new(rd_kafka_ResourceType_t restype, const char *resname);</span>
<span class="s1">void rd_kafka_ConfigResource_destroy(rd_kafka_ConfigResource_t *config);</span>
<span class="s1">void rd_kafka_ConfigResource_destroy_array(rd_kafka_ConfigResource_t **config, size_t config_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_ConfigResource_set_config(rd_kafka_ConfigResource_t *config, const char *name, const char *value);</span>
<span class="s1">const rd_kafka_ConfigEntry_t **rd_kafka_ConfigResource_configs(const rd_kafka_ConfigResource_t *config, size_t *cntp);</span>
<span class="s1">rd_kafka_ResourceType_t rd_kafka_ConfigResource_type(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">const char *rd_kafka_ConfigResource_name(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_ConfigResource_error(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">const char *rd_kafka_ConfigResource_error_string(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">void rd_kafka_AlterConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_ConfigResource_t **rd_kafka_AlterConfigs_result_resources(const rd_kafka_AlterConfigs_result_t *result, size_t *cntp);</span>
<span class="s1">void rd_kafka_DescribeConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_ConfigResource_t **rd_kafka_DescribeConfigs_result_resources(const rd_kafka_DescribeConfigs_result_t *result, size_t *cntp);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token(rd_kafka_t *rk, const char *token_value, int64_t md_lifetime_ms, const char *md_principal_name, const char **extensions, size_t extension_size, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token_failure(rd_kafka_t *rk, const char *errstr);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_init_transactions(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_begin_transaction(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_send_offsets_to_transaction(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, const rd_kafka_consumer_group_metadata_t *cgmetadata, int timeout_ms);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_commit_transaction(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_abort_transaction(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">typedef struct rd_kafka_mock_cluster_s rd_kafka_mock_cluster_t;</span>
<span class="s1">rd_kafka_mock_cluster_t *rd_kafka_mock_cluster_new(rd_kafka_t *rk, int broker_cnt);</span>
<span class="s1">void rd_kafka_mock_cluster_destroy(rd_kafka_mock_cluster_t *mcluster);</span>
<span class="s1">rd_kafka_t *rd_kafka_mock_cluster_handle(const rd_kafka_mock_cluster_t *mcluster);</span>
<span class="s1">rd_kafka_mock_cluster_t *rd_kafka_handle_mock_cluster(const rd_kafka_t *rk);</span>
<span class="s1">const char *rd_kafka_mock_cluster_bootstraps(const rd_kafka_mock_cluster_t *mcluster);</span>
<span class="s1">void rd_kafka_mock_push_request_errors(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, size_t cnt, ...);</span>
<span class="s1">void rd_kafka_mock_topic_set_error(rd_kafka_mock_cluster_t *mcluster, const char *topic, rd_kafka_resp_err_t err);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_topic_create(rd_kafka_mock_cluster_t *mcluster, const char *topic, int partition_cnt, int replication_factor);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_partition_set_leader(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_partition_set_follower(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_partition_set_follower_wmarks(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int64_t lo, int64_t hi);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_set_down(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_set_up(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_set_rtt(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int rtt_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_set_rack(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, const char *rack);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_coordinator_set(rd_kafka_mock_cluster_t *mcluster, const char *key_type, const char *key, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_set_apiversion(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, int16_t MinVersion, int16_t MaxVersion);</span>
<span class="s1">&#39;</span>
</code></pre></div>
rdkafka.h, rdkafka_mock.h</p>
<h3 id="rd_kafka_version_10">RD_KAFKA_VERSION<a class="headerlink" href="#rd_kafka_version_10" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_VERSION</span> <span class="o">=</span> <span class="mi">17105151</span>
</code></pre></div>
<p>librdkafka version </p>
<p>Interpreted as hex <code>MM.mm.rr.xx</code>:</p>
<ul>
<li>MM = Major</li>
<li>mm = minor</li>
<li>rr = revision</li>
<li>xx = pre-release id (0xff is the final release)</li>
</ul>
<p>E.g.: <code>0x000801ff</code> = 0.8.1</p>
<dl class="section remark"><dt>Remarks</dt><dd>This value should only be used during compile time, for runtime checks of version use rd_kafka_version() </dd></dl>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_unsupported_compression_type_10">RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE<a class="headerlink" href="#rd_kafka_resp_err_unsupported_compression_type_10" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE</span> <span class="o">=</span> <span class="mi">76</span>
</code></pre></div>
<p>Unsupported compression type </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_end_all_10">RD_KAFKA_RESP_ERR_END_ALL<a class="headerlink" href="#rd_kafka_resp_err_end_all_10" title="Permanent link">&para;</a></h3>
<p><div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_END_ALL</span> <span class="o">=</span> <span class="mi">83</span>
</code></pre></div>
enum rd_kafka_resp_err_t</p>
<h3 id="rd_kafka_admin_op__cnt_10">RD_KAFKA_ADMIN_OP__CNT<a class="headerlink" href="#rd_kafka_admin_op__cnt_10" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_ADMIN_OP__CNT</span> <span class="o">=</span> <span class="mi">6</span>
</code></pre></div>
<p>Number of ops defined </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe </a></li>
</ul>
</div>
<h3 id="rd_kafka_resource__cnt_10">RD_KAFKA_RESOURCE__CNT<a class="headerlink" href="#rd_kafka_resource__cnt_10" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESOURCE__CNT</span> <span class="o">=</span> <span class="mi">5</span>
</code></pre></div>
<p>Number of resource types defined </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#acca83a66d7783ff7683ed2691cc907c9"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#acca83a66d7783ff7683ed2691cc907c9 </a></li>
</ul>
</div>
<h3 id="rd_kafka_cdef_10">RD_KAFKA_CDEF<a class="headerlink" href="#rd_kafka_cdef_10" title="Permanent link">&para;</a></h3>
<p><div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_CDEF</span> <span class="o">=</span> <span class="s1">&#39;typedef long int ssize_t;</span>
<span class="s1">typedef struct _IO_FILE FILE;</span>
<span class="s1">typedef long int mode_t;</span>
<span class="s1">typedef signed int int16_t;</span>
<span class="s1">typedef unsigned int uint16_t;</span>
<span class="s1">typedef signed int int32_t;</span>
<span class="s1">typedef signed long int int64_t;</span>
<span class="s1">int rd_kafka_version(void);</span>
<span class="s1">const char *rd_kafka_version_str(void);</span>
<span class="s1">typedef enum rd_kafka_type_t {</span>
<span class="s1">  RD_KAFKA_PRODUCER,</span>
<span class="s1">  RD_KAFKA_CONSUMER,</span>
<span class="s1">} rd_kafka_type_t;</span>
<span class="s1">typedef enum rd_kafka_timestamp_type_t {</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_NOT_AVAILABLE,</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_CREATE_TIME,</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_LOG_APPEND_TIME,</span>
<span class="s1">} rd_kafka_timestamp_type_t;</span>
<span class="s1">const char *rd_kafka_get_debug_contexts(void);</span>
<span class="s1">typedef struct rd_kafka_s rd_kafka_t;</span>
<span class="s1">typedef struct rd_kafka_topic_s rd_kafka_topic_t;</span>
<span class="s1">typedef struct rd_kafka_conf_s rd_kafka_conf_t;</span>
<span class="s1">typedef struct rd_kafka_topic_conf_s rd_kafka_topic_conf_t;</span>
<span class="s1">typedef struct rd_kafka_queue_s rd_kafka_queue_t;</span>
<span class="s1">typedef struct rd_kafka_op_s rd_kafka_event_t;</span>
<span class="s1">typedef struct rd_kafka_topic_result_s rd_kafka_topic_result_t;</span>
<span class="s1">typedef struct rd_kafka_consumer_group_metadata_s rd_kafka_consumer_group_metadata_t;</span>
<span class="s1">typedef struct rd_kafka_error_s {</span>
<span class="s1">  unsigned int code;</span>
<span class="s1">  char *errstr;</span>
<span class="s1">  unsigned char fatal;</span>
<span class="s1">  unsigned char retriable;</span>
<span class="s1">  unsigned char txn_requires_abort;</span>
<span class="s1">} rd_kafka_error_t;</span>
<span class="s1">typedef struct rd_kafka_headers_s rd_kafka_headers_t;</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BEGIN = (- 200),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BAD_MSG = (- 199),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BAD_COMPRESSION = (- 198),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__DESTROY = (- 197),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FAIL = (- 196),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TRANSPORT = (- 195),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__CRIT_SYS_RESOURCE = (- 194),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__RESOLVE = (- 193),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__MSG_TIMED_OUT = (- 192),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PARTITION_EOF = (- 191),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION = (- 190),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FS = (- 189),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC = (- 188),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ALL_BROKERS_DOWN = (- 187),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INVALID_ARG = (- 186),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TIMED_OUT = (- 185),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__QUEUE_FULL = (- 184),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ISR_INSUFF = (- 183),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NODE_UPDATE = (- 182),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__SSL = (- 181),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__WAIT_COORD = (- 180),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_GROUP = (- 179),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__IN_PROGRESS = (- 178),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PREV_IN_PROGRESS = (- 177),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__EXISTING_SUBSCRIPTION = (- 176),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS = (- 175),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS = (- 174),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__CONFLICT = (- 173),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__STATE = (- 172),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_PROTOCOL = (- 171),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED = (- 170),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__AUTHENTICATION = (- 169),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NO_OFFSET = (- 168),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__OUTDATED = (- 167),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TIMED_OUT_QUEUE = (- 166),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNSUPPORTED_FEATURE = (- 165),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__WAIT_CACHE = (- 164),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INTR = (- 163),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__KEY_SERIALIZATION = (- 162),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__VALUE_SERIALIZATION = (- 161),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__KEY_DESERIALIZATION = (- 160),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__VALUE_DESERIALIZATION = (- 159),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PARTIAL = (- 158),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__READ_ONLY = (- 157),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOENT = (- 156),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNDERFLOW = (- 155),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INVALID_TYPE = (- 154),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__RETRY = (- 153),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PURGE_QUEUE = (- 152),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PURGE_INFLIGHT = (- 151),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FATAL = (- 150),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INCONSISTENT = (- 149),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__GAPLESS_GUARANTEE = (- 148),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__MAX_POLL_EXCEEDED = (- 147),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_BROKER = (- 146),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOT_CONFIGURED = (- 145),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FENCED = (- 144),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__APPLICATION = (- 143),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__END = (- 100),</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN = (- 1),</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NO_ERROR = 0,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_OUT_OF_RANGE = 1,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_MSG = 2,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART = 3,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_MSG_SIZE = 4,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE = 5,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_LEADER_FOR_PARTITION = 6,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REQUEST_TIMED_OUT = 7,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_BROKER_NOT_AVAILABLE = 8,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REPLICA_NOT_AVAILABLE = 9,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE = 10,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_STALE_CTRL_EPOCH = 11,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_METADATA_TOO_LARGE = 12,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NETWORK_EXCEPTION = 13,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_COORDINATOR_LOAD_IN_PROGRESS = 14,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_COORDINATOR_NOT_AVAILABLE = 15,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_COORDINATOR = 16,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_EXCEPTION = 17,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_RECORD_LIST_TOO_LARGE = 18,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS = 19,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS_AFTER_APPEND = 20,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REQUIRED_ACKS = 21,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ILLEGAL_GENERATION = 22,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INCONSISTENT_GROUP_PROTOCOL = 23,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_GROUP_ID = 24,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_MEMBER_ID = 25,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_SESSION_TIMEOUT = 26,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REBALANCE_IN_PROGRESS = 27,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_COMMIT_OFFSET_SIZE = 28,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_AUTHORIZATION_FAILED = 29,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_AUTHORIZATION_FAILED = 30,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_CLUSTER_AUTHORIZATION_FAILED = 31,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TIMESTAMP = 32,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_SASL_MECHANISM = 33,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ILLEGAL_SASL_STATE = 34,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_VERSION = 35,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_ALREADY_EXISTS = 36,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PARTITIONS = 37,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REPLICATION_FACTOR = 38,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REPLICA_ASSIGNMENT = 39,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_CONFIG = 40,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_CONTROLLER = 41,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REQUEST = 42,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_FOR_MESSAGE_FORMAT = 43,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_POLICY_VIOLATION = 44,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OUT_OF_ORDER_SEQUENCE_NUMBER = 45,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DUPLICATE_SEQUENCE_NUMBER = 46,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_EPOCH = 47,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TXN_STATE = 48,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_ID_MAPPING = 49,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TRANSACTION_TIMEOUT = 50,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_CONCURRENT_TRANSACTIONS = 51,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TRANSACTION_COORDINATOR_FENCED = 52,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TRANSACTIONAL_ID_AUTHORIZATION_FAILED = 53,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_SECURITY_DISABLED = 54,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OPERATION_NOT_ATTEMPTED = 55,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_KAFKA_STORAGE_ERROR = 56,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LOG_DIR_NOT_FOUND = 57,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_SASL_AUTHENTICATION_FAILED = 58,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_PRODUCER_ID = 59,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REASSIGNMENT_IN_PROGRESS = 60,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTH_DISABLED = 61,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_NOT_FOUND = 62,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_OWNER_MISMATCH = 63,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_REQUEST_NOT_ALLOWED = 64,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTHORIZATION_FAILED = 65,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_EXPIRED = 66,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRINCIPAL_TYPE = 67,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NON_EMPTY_GROUP = 68,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_ID_NOT_FOUND = 69,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FETCH_SESSION_ID_NOT_FOUND = 70,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_FETCH_SESSION_EPOCH = 71,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LISTENER_NOT_FOUND = 72,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_DELETION_DISABLED = 73,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FENCED_LEADER_EPOCH = 74,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_LEADER_EPOCH = 75,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_STALE_BROKER_EPOCH = 77,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_NOT_AVAILABLE = 78,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_MEMBER_ID_REQUIRED = 79,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_PREFERRED_LEADER_NOT_AVAILABLE = 80,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_MAX_SIZE_REACHED = 81,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FENCED_INSTANCE_ID = 82,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_END_ALL,</span>
<span class="s1">} rd_kafka_resp_err_t;</span>
<span class="s1">struct rd_kafka_err_desc {</span>
<span class="s1">  rd_kafka_resp_err_t code;</span>
<span class="s1">  char *name;</span>
<span class="s1">  char *desc;</span>
<span class="s1">};</span>
<span class="s1">void rd_kafka_get_err_descs(const struct rd_kafka_err_desc **errdescs, size_t *cntp);</span>
<span class="s1">const char *rd_kafka_err2str(rd_kafka_resp_err_t err);</span>
<span class="s1">const char *rd_kafka_err2name(rd_kafka_resp_err_t err);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_last_error(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_errno2err(int errnox);</span>
<span class="s1">int rd_kafka_errno(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_fatal_error(rd_kafka_t *rk, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_test_fatal_error(rd_kafka_t *rk, rd_kafka_resp_err_t err, const char *reason);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_error_code(const rd_kafka_error_t *error);</span>
<span class="s1">const char *rd_kafka_error_name(const rd_kafka_error_t *error);</span>
<span class="s1">const char *rd_kafka_error_string(const rd_kafka_error_t *error);</span>
<span class="s1">int rd_kafka_error_is_fatal(const rd_kafka_error_t *error);</span>
<span class="s1">int rd_kafka_error_is_retriable(const rd_kafka_error_t *error);</span>
<span class="s1">int rd_kafka_error_txn_requires_abort(const rd_kafka_error_t *error);</span>
<span class="s1">void rd_kafka_error_destroy(rd_kafka_error_t *error);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_error_new(rd_kafka_resp_err_t code, const char *fmt, ...);</span>
<span class="s1">typedef struct rd_kafka_topic_partition_s {</span>
<span class="s1">  char *topic;</span>
<span class="s1">  int32_t partition;</span>
<span class="s1">  int64_t offset;</span>
<span class="s1">  void *metadata;</span>
<span class="s1">  size_t metadata_size;</span>
<span class="s1">  void *opaque;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  void *_private;</span>
<span class="s1">} rd_kafka_topic_partition_t;</span>
<span class="s1">void rd_kafka_topic_partition_destroy(rd_kafka_topic_partition_t *rktpar);</span>
<span class="s1">typedef struct rd_kafka_topic_partition_list_s {</span>
<span class="s1">  int cnt;</span>
<span class="s1">  int size;</span>
<span class="s1">  rd_kafka_topic_partition_t *elems;</span>
<span class="s1">} rd_kafka_topic_partition_list_t;</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_new(int size);</span>
<span class="s1">void rd_kafka_topic_partition_list_destroy(rd_kafka_topic_partition_list_t *rkparlist);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_add(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">void rd_kafka_topic_partition_list_add_range(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t start, int32_t stop);</span>
<span class="s1">int rd_kafka_topic_partition_list_del(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">int rd_kafka_topic_partition_list_del_by_idx(rd_kafka_topic_partition_list_t *rktparlist, int idx);</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_copy(const rd_kafka_topic_partition_list_t *src);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_topic_partition_list_set_offset(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition, int64_t offset);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_find(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">void rd_kafka_topic_partition_list_sort(rd_kafka_topic_partition_list_t *rktparlist, int (*cmp)(const void *a, const void *b, void *cmp_opaque), void *cmp_opaque);</span>
<span class="s1">typedef enum rd_kafka_vtype_t {</span>
<span class="s1">  RD_KAFKA_VTYPE_END,</span>
<span class="s1">  RD_KAFKA_VTYPE_TOPIC,</span>
<span class="s1">  RD_KAFKA_VTYPE_RKT,</span>
<span class="s1">  RD_KAFKA_VTYPE_PARTITION,</span>
<span class="s1">  RD_KAFKA_VTYPE_VALUE,</span>
<span class="s1">  RD_KAFKA_VTYPE_KEY,</span>
<span class="s1">  RD_KAFKA_VTYPE_OPAQUE,</span>
<span class="s1">  RD_KAFKA_VTYPE_MSGFLAGS,</span>
<span class="s1">  RD_KAFKA_VTYPE_TIMESTAMP,</span>
<span class="s1">  RD_KAFKA_VTYPE_HEADER,</span>
<span class="s1">  RD_KAFKA_VTYPE_HEADERS,</span>
<span class="s1">} rd_kafka_vtype_t;</span>
<span class="s1">typedef struct rd_kafka_vu_s {</span>
<span class="s1">  rd_kafka_vtype_t vtype;</span>
<span class="s1">  union {</span>
<span class="s1">    char *cstr;</span>
<span class="s1">    rd_kafka_topic_t *rkt;</span>
<span class="s1">    int i;</span>
<span class="s1">    int32_t i32;</span>
<span class="s1">    int64_t i64;</span>
<span class="s1">    struct {</span>
<span class="s1">      void *ptr;</span>
<span class="s1">      size_t size;</span>
<span class="s1">    } mem;</span>
<span class="s1">    struct {</span>
<span class="s1">      char *name;</span>
<span class="s1">      void *val;</span>
<span class="s1">      ssize_t size;</span>
<span class="s1">    } header;</span>
<span class="s1">    rd_kafka_headers_t *headers;</span>
<span class="s1">    void *ptr;</span>
<span class="s1">    char _pad[64];</span>
<span class="s1">  } u;</span>
<span class="s1">} rd_kafka_vu_t;</span>
<span class="s1">rd_kafka_headers_t *rd_kafka_headers_new(size_t initial_count);</span>
<span class="s1">void rd_kafka_headers_destroy(rd_kafka_headers_t *hdrs);</span>
<span class="s1">rd_kafka_headers_t *rd_kafka_headers_copy(const rd_kafka_headers_t *src);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_add(rd_kafka_headers_t *hdrs, const char *name, ssize_t name_size, const void *value, ssize_t value_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_remove(rd_kafka_headers_t *hdrs, const char *name);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get_last(const rd_kafka_headers_t *hdrs, const char *name, const void **valuep, size_t *sizep);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get(const rd_kafka_headers_t *hdrs, size_t idx, const char *name, const void **valuep, size_t *sizep);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get_all(const rd_kafka_headers_t *hdrs, size_t idx, const char **namep, const void **valuep, size_t *sizep);</span>
<span class="s1">typedef struct rd_kafka_message_s {</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  rd_kafka_topic_t *rkt;</span>
<span class="s1">  int32_t partition;</span>
<span class="s1">  void *payload;</span>
<span class="s1">  size_t len;</span>
<span class="s1">  void *key;</span>
<span class="s1">  size_t key_len;</span>
<span class="s1">  int64_t offset;</span>
<span class="s1">  void *_private;</span>
<span class="s1">} rd_kafka_message_t;</span>
<span class="s1">void rd_kafka_message_destroy(rd_kafka_message_t *rkmessage);</span>
<span class="s1">const char *rd_kafka_message_errstr(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">int64_t rd_kafka_message_timestamp(const rd_kafka_message_t *rkmessage, rd_kafka_timestamp_type_t *tstype);</span>
<span class="s1">int64_t rd_kafka_message_latency(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">int32_t rd_kafka_message_broker_id(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_message_headers(const rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_message_detach_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);</span>
<span class="s1">void rd_kafka_message_set_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t *hdrs);</span>
<span class="s1">size_t rd_kafka_header_cnt(const rd_kafka_headers_t *hdrs);</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_NOT_PERSISTED = 0,</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_POSSIBLY_PERSISTED = 1,</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_PERSISTED = 2,</span>
<span class="s1">} rd_kafka_msg_status_t;</span>
<span class="s1">rd_kafka_msg_status_t rd_kafka_message_status(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_CONF_UNKNOWN = (- 2),</span>
<span class="s1">  RD_KAFKA_CONF_INVALID = (- 1),</span>
<span class="s1">  RD_KAFKA_CONF_OK = 0,</span>
<span class="s1">} rd_kafka_conf_res_t;</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_new(void);</span>
<span class="s1">void rd_kafka_conf_destroy(rd_kafka_conf_t *conf);</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_dup(const rd_kafka_conf_t *conf);</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_dup_filter(const rd_kafka_conf_t *conf, size_t filter_cnt, const char **filter);</span>
<span class="s1">const rd_kafka_conf_t *rd_kafka_conf(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_set(rd_kafka_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_conf_set_events(rd_kafka_conf_t *conf, int events);</span>
<span class="s1">void rd_kafka_conf_set_background_event_cb(rd_kafka_conf_t *conf, void (*event_cb)(rd_kafka_t *rk, rd_kafka_event_t *rkev, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_dr_cb(rd_kafka_conf_t *conf, void (*dr_cb)(rd_kafka_t *rk, void *payload, size_t len, rd_kafka_resp_err_t err, void *opaque, void *msg_opaque));</span>
<span class="s1">void rd_kafka_conf_set_dr_msg_cb(rd_kafka_conf_t *conf, void (*dr_msg_cb)(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_consume_cb(rd_kafka_conf_t *conf, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_rebalance_cb(rd_kafka_conf_t *conf, void (*rebalance_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *partitions, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_offset_commit_cb(rd_kafka_conf_t *conf, void (*offset_commit_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_error_cb(rd_kafka_conf_t *conf, void (*error_cb)(rd_kafka_t *rk, int err, const char *reason, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_throttle_cb(rd_kafka_conf_t *conf, void (*throttle_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int throttle_time_ms, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_log_cb(rd_kafka_conf_t *conf, void (*log_cb)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));</span>
<span class="s1">void rd_kafka_conf_set_stats_cb(rd_kafka_conf_t *conf, int (*stats_cb)(rd_kafka_t *rk, char *json, size_t json_len, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_oauthbearer_token_refresh_cb(rd_kafka_conf_t *conf, void (*oauthbearer_token_refresh_cb)(rd_kafka_t *rk, const char *oauthbearer_config, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_socket_cb(rd_kafka_conf_t *conf, int (*socket_cb)(int domain, int type, int protocol, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_connect_cb(rd_kafka_conf_t *conf, int (*connect_cb)(int sockfd, const struct sockaddr *addr, int addrlen, const char *id, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_closesocket_cb(rd_kafka_conf_t *conf, int (*closesocket_cb)(int sockfd, void *opaque));</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert_verify_cb(rd_kafka_conf_t *conf, int (*ssl_cert_verify_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int *x509_error, int depth, const char *buf, size_t size, char *errstr, size_t errstr_size, void *opaque));</span>
<span class="s1">typedef enum rd_kafka_cert_type_t {</span>
<span class="s1">  RD_KAFKA_CERT_PUBLIC_KEY,</span>
<span class="s1">  RD_KAFKA_CERT_PRIVATE_KEY,</span>
<span class="s1">  RD_KAFKA_CERT_CA,</span>
<span class="s1">  RD_KAFKA_CERT__CNT,</span>
<span class="s1">} rd_kafka_cert_type_t;</span>
<span class="s1">typedef enum rd_kafka_cert_enc_t {</span>
<span class="s1">  RD_KAFKA_CERT_ENC_PKCS12,</span>
<span class="s1">  RD_KAFKA_CERT_ENC_DER,</span>
<span class="s1">  RD_KAFKA_CERT_ENC_PEM,</span>
<span class="s1">  RD_KAFKA_CERT_ENC__CNT,</span>
<span class="s1">} rd_kafka_cert_enc_t;</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert(rd_kafka_conf_t *conf, rd_kafka_cert_type_t cert_type, rd_kafka_cert_enc_t cert_enc, const void *buffer, size_t size, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_conf_set_opaque(rd_kafka_conf_t *conf, void *opaque);</span>
<span class="s1">void *rd_kafka_opaque(const rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_conf_set_default_topic_conf(rd_kafka_conf_t *conf, rd_kafka_topic_conf_t *tconf);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_get(const rd_kafka_conf_t *conf, const char *name, char *dest, size_t *dest_size);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_topic_conf_get(const rd_kafka_topic_conf_t *conf, const char *name, char *dest, size_t *dest_size);</span>
<span class="s1">const char **rd_kafka_conf_dump(rd_kafka_conf_t *conf, size_t *cntp);</span>
<span class="s1">const char **rd_kafka_topic_conf_dump(rd_kafka_topic_conf_t *conf, size_t *cntp);</span>
<span class="s1">void rd_kafka_conf_dump_free(const char **arr, size_t cnt);</span>
<span class="s1">void rd_kafka_conf_properties_show(FILE *fp);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_topic_conf_new(void);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_topic_conf_dup(const rd_kafka_topic_conf_t *conf);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_default_topic_conf_dup(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_topic_conf_destroy(rd_kafka_topic_conf_t *topic_conf);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_topic_conf_set(rd_kafka_topic_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_topic_conf_set_opaque(rd_kafka_topic_conf_t *conf, void *rkt_opaque);</span>
<span class="s1">void rd_kafka_topic_conf_set_partitioner_cb(rd_kafka_topic_conf_t *topic_conf, int32_t (*partitioner)(const rd_kafka_topic_t *rkt, const void *keydata, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque));</span>
<span class="s1">void rd_kafka_topic_conf_set_msg_order_cmp(rd_kafka_topic_conf_t *topic_conf, int (*msg_order_cmp)(const rd_kafka_message_t *a, const rd_kafka_message_t *b));</span>
<span class="s1">int rd_kafka_topic_partition_available(const rd_kafka_topic_t *rkt, int32_t partition);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_consistent(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_consistent_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_murmur2(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_murmur2_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_fnv1a(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_fnv1a_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">rd_kafka_t *rd_kafka_new(rd_kafka_type_t type, rd_kafka_conf_t *conf, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_destroy(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_destroy_flags(rd_kafka_t *rk, int flags);</span>
<span class="s1">const char *rd_kafka_name(const rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_type_t rd_kafka_type(const rd_kafka_t *rk);</span>
<span class="s1">char *rd_kafka_memberid(const rd_kafka_t *rk);</span>
<span class="s1">char *rd_kafka_clusterid(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">int32_t rd_kafka_controllerid(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_topic_t *rd_kafka_topic_new(rd_kafka_t *rk, const char *topic, rd_kafka_topic_conf_t *conf);</span>
<span class="s1">void rd_kafka_topic_destroy(rd_kafka_topic_t *rkt);</span>
<span class="s1">const char *rd_kafka_topic_name(const rd_kafka_topic_t *rkt);</span>
<span class="s1">void *rd_kafka_topic_opaque(const rd_kafka_topic_t *rkt);</span>
<span class="s1">int rd_kafka_poll(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">void rd_kafka_yield(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_pause_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_resume_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_query_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_get_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offsets_for_times(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets, int timeout_ms);</span>
<span class="s1">void rd_kafka_mem_free(rd_kafka_t *rk, void *ptr);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_new(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_queue_destroy(rd_kafka_queue_t *rkqu);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_main(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_consumer(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_partition(rd_kafka_t *rk, const char *topic, int32_t partition);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_background(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_queue_forward(rd_kafka_queue_t *src, rd_kafka_queue_t *dst);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_set_log_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu);</span>
<span class="s1">size_t rd_kafka_queue_length(rd_kafka_queue_t *rkqu);</span>
<span class="s1">void rd_kafka_queue_io_event_enable(rd_kafka_queue_t *rkqu, int fd, const void *payload, size_t size);</span>
<span class="s1">void rd_kafka_queue_cb_event_enable(rd_kafka_queue_t *rkqu, void (*event_cb)(rd_kafka_t *rk, void *qev_opaque), void *qev_opaque);</span>
<span class="s1">int rd_kafka_consume_start(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);</span>
<span class="s1">int rd_kafka_consume_start_queue(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, rd_kafka_queue_t *rkqu);</span>
<span class="s1">int rd_kafka_consume_stop(rd_kafka_topic_t *rkt, int32_t partition);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_seek(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, int timeout_ms);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consume(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms);</span>
<span class="s1">ssize_t rd_kafka_consume_batch(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);</span>
<span class="s1">int rd_kafka_consume_callback(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consume_queue(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">ssize_t rd_kafka_consume_batch_queue(rd_kafka_queue_t *rkqu, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);</span>
<span class="s1">int rd_kafka_consume_callback_queue(rd_kafka_queue_t *rkqu, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offset_store(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offsets_store(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_subscribe(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *topics);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_unsubscribe(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_subscription(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **topics);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consumer_poll(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_consumer_close(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_assignment(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, int async);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit_message(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, int async);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit_queue(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_queue_t *rkqu, void (*cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *commit_opaque), void *commit_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_committed(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_position(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata_new(const char *group_id);</span>
<span class="s1">void rd_kafka_consumer_group_metadata_destroy(rd_kafka_consumer_group_metadata_t *);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_consumer_group_metadata_write(const rd_kafka_consumer_group_metadata_t *cgmd, void **bufferp, size_t *sizep);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_consumer_group_metadata_read(rd_kafka_consumer_group_metadata_t **cgmdp, const void *buffer, size_t size);</span>
<span class="s1">int rd_kafka_produce(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, void *payload, size_t len, const void *key, size_t keylen, void *msg_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_producev(rd_kafka_t *rk, ...);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_produceva(rd_kafka_t *rk, const rd_kafka_vu_t *vus, size_t cnt);</span>
<span class="s1">int rd_kafka_produce_batch(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, rd_kafka_message_t *rkmessages, int message_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_flush(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_purge(rd_kafka_t *rk, int purge_flags);</span>
<span class="s1">typedef struct rd_kafka_metadata_broker {</span>
<span class="s1">  int32_t id;</span>
<span class="s1">  char *host;</span>
<span class="s1">  int port;</span>
<span class="s1">} rd_kafka_metadata_broker_t;</span>
<span class="s1">typedef struct rd_kafka_metadata_partition {</span>
<span class="s1">  int32_t id;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  int32_t leader;</span>
<span class="s1">  int replica_cnt;</span>
<span class="s1">  int32_t *replicas;</span>
<span class="s1">  int isr_cnt;</span>
<span class="s1">  int32_t *isrs;</span>
<span class="s1">} rd_kafka_metadata_partition_t;</span>
<span class="s1">typedef struct rd_kafka_metadata_topic {</span>
<span class="s1">  char *topic;</span>
<span class="s1">  int partition_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_partition *partitions;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">} rd_kafka_metadata_topic_t;</span>
<span class="s1">typedef struct rd_kafka_metadata {</span>
<span class="s1">  int broker_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_broker *brokers;</span>
<span class="s1">  int topic_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_topic *topics;</span>
<span class="s1">  int32_t orig_broker_id;</span>
<span class="s1">  char *orig_broker_name;</span>
<span class="s1">} rd_kafka_metadata_t;</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_metadata(rd_kafka_t *rk, int all_topics, rd_kafka_topic_t *only_rkt, const struct rd_kafka_metadata **metadatap, int timeout_ms);</span>
<span class="s1">void rd_kafka_metadata_destroy(const struct rd_kafka_metadata *metadata);</span>
<span class="s1">struct rd_kafka_group_member_info {</span>
<span class="s1">  char *member_id;</span>
<span class="s1">  char *client_id;</span>
<span class="s1">  char *client_host;</span>
<span class="s1">  void *member_metadata;</span>
<span class="s1">  int member_metadata_size;</span>
<span class="s1">  void *member_assignment;</span>
<span class="s1">  int member_assignment_size;</span>
<span class="s1">};</span>
<span class="s1">struct rd_kafka_group_info {</span>
<span class="s1">  struct rd_kafka_metadata_broker broker;</span>
<span class="s1">  char *group;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  char *state;</span>
<span class="s1">  char *protocol_type;</span>
<span class="s1">  char *protocol;</span>
<span class="s1">  struct rd_kafka_group_member_info *members;</span>
<span class="s1">  int member_cnt;</span>
<span class="s1">};</span>
<span class="s1">struct rd_kafka_group_list {</span>
<span class="s1">  struct rd_kafka_group_info *groups;</span>
<span class="s1">  int group_cnt;</span>
<span class="s1">};</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_list_groups(rd_kafka_t *rk, const char *group, const struct rd_kafka_group_list **grplistp, int timeout_ms);</span>
<span class="s1">void rd_kafka_group_list_destroy(const struct rd_kafka_group_list *grplist);</span>
<span class="s1">int rd_kafka_brokers_add(rd_kafka_t *rk, const char *brokerlist);</span>
<span class="s1">void rd_kafka_set_logger(rd_kafka_t *rk, void (*func)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));</span>
<span class="s1">void rd_kafka_set_log_level(rd_kafka_t *rk, int level);</span>
<span class="s1">void rd_kafka_log_print(const rd_kafka_t *rk, int level, const char *fac, const char *buf);</span>
<span class="s1">void rd_kafka_log_syslog(const rd_kafka_t *rk, int level, const char *fac, const char *buf);</span>
<span class="s1">int rd_kafka_outq_len(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_dump(FILE *fp, rd_kafka_t *rk);</span>
<span class="s1">int rd_kafka_thread_cnt(void);</span>
<span class="s1">typedef enum rd_kafka_thread_type_t {</span>
<span class="s1">  RD_KAFKA_THREAD_MAIN,</span>
<span class="s1">  RD_KAFKA_THREAD_BACKGROUND,</span>
<span class="s1">  RD_KAFKA_THREAD_BROKER,</span>
<span class="s1">} rd_kafka_thread_type_t;</span>
<span class="s1">int rd_kafka_wait_destroyed(int timeout_ms);</span>
<span class="s1">int rd_kafka_unittest(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_poll_set_consumer(rd_kafka_t *rk);</span>
<span class="s1">typedef int rd_kafka_event_type_t;</span>
<span class="s1">rd_kafka_event_type_t rd_kafka_event_type(const rd_kafka_event_t *rkev);</span>
<span class="s1">const char *rd_kafka_event_name(const rd_kafka_event_t *rkev);</span>
<span class="s1">void rd_kafka_event_destroy(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_message_t *rd_kafka_event_message_next(rd_kafka_event_t *rkev);</span>
<span class="s1">size_t rd_kafka_event_message_array(rd_kafka_event_t *rkev, const rd_kafka_message_t **rkmessages, size_t size);</span>
<span class="s1">size_t rd_kafka_event_message_count(rd_kafka_event_t *rkev);</span>
<span class="s1">const char *rd_kafka_event_config_string(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_event_error(rd_kafka_event_t *rkev);</span>
<span class="s1">const char *rd_kafka_event_error_string(rd_kafka_event_t *rkev);</span>
<span class="s1">int rd_kafka_event_error_is_fatal(rd_kafka_event_t *rkev);</span>
<span class="s1">void *rd_kafka_event_opaque(rd_kafka_event_t *rkev);</span>
<span class="s1">int rd_kafka_event_log(rd_kafka_event_t *rkev, const char **fac, const char **str, int *level);</span>
<span class="s1">int rd_kafka_event_debug_contexts(rd_kafka_event_t *rkev, char *dst, size_t dstsize);</span>
<span class="s1">const char *rd_kafka_event_stats(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_event_topic_partition_list(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_event_topic_partition(rd_kafka_event_t *rkev);</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_CreateTopics_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DeleteTopics_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_CreatePartitions_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_AlterConfigs_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DescribeConfigs_result_t;</span>
<span class="s1">const rd_kafka_CreateTopics_result_t *rd_kafka_event_CreateTopics_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DeleteTopics_result_t *rd_kafka_event_DeleteTopics_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_CreatePartitions_result_t *rd_kafka_event_CreatePartitions_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_AlterConfigs_result_t *rd_kafka_event_AlterConfigs_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DescribeConfigs_result_t *rd_kafka_event_DescribeConfigs_result(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_event_t *rd_kafka_queue_poll(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">int rd_kafka_queue_poll_callback(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_plugin_f_conf_init_t)(rd_kafka_conf_t *conf, void **plug_opaquep, char *errstr, size_t errstr_size);</span>
<span class="s1">typedef rd_kafka_conf_res_t (rd_kafka_interceptor_f_on_conf_set_t)(rd_kafka_conf_t *conf, const char *name, const char *val, char *errstr, size_t errstr_size, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_dup_t)(rd_kafka_conf_t *new_conf, const rd_kafka_conf_t *old_conf, size_t filter_cnt, const char **filter, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_destroy_t)(void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_new_t)(rd_kafka_t *rk, const rd_kafka_conf_t *conf, void *ic_opaque, char *errstr, size_t errstr_size);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_destroy_t)(rd_kafka_t *rk, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_send_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_acknowledgement_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_consume_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_commit_t)(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_resp_err_t err, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_request_sent_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_start_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_exit_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_set(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_set_t *on_conf_set, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_dup(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_dup_t *on_conf_dup, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_destroy(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_destroy_t *on_conf_destroy, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_new(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_new_t *on_new, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_destroy(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_destroy_t *on_destroy, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_send(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_send_t *on_send, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_acknowledgement(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_acknowledgement_t *on_acknowledgement, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_consume(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_consume_t *on_consume, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_commit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_commit_t *on_commit, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_request_sent(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_request_sent_t *on_request_sent, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_start(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_start_t *on_thread_start, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_exit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_exit_t *on_thread_exit, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_topic_result_error(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">const char *rd_kafka_topic_result_error_string(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">const char *rd_kafka_topic_result_name(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">typedef enum rd_kafka_admin_op_t {</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_ANY = 0,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_CREATETOPICS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DELETETOPICS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_CREATEPARTITIONS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_ALTERCONFIGS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DESCRIBECONFIGS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP__CNT,</span>
<span class="s1">} rd_kafka_admin_op_t;</span>
<span class="s1">typedef struct rd_kafka_AdminOptions_s rd_kafka_AdminOptions_t;</span>
<span class="s1">rd_kafka_AdminOptions_t *rd_kafka_AdminOptions_new(rd_kafka_t *rk, rd_kafka_admin_op_t for_api);</span>
<span class="s1">void rd_kafka_AdminOptions_destroy(rd_kafka_AdminOptions_t *options);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_request_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_operation_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_validate_only(rd_kafka_AdminOptions_t *options, int true_or_false, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_broker(rd_kafka_AdminOptions_t *options, int32_t broker_id, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_AdminOptions_set_opaque(rd_kafka_AdminOptions_t *options, void *ev_opaque);</span>
<span class="s1">typedef struct rd_kafka_NewTopic_s rd_kafka_NewTopic_t;</span>
<span class="s1">rd_kafka_NewTopic_t *rd_kafka_NewTopic_new(const char *topic, int num_partitions, int replication_factor, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_NewTopic_destroy(rd_kafka_NewTopic_t *new_topic);</span>
<span class="s1">void rd_kafka_NewTopic_destroy_array(rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewTopic_set_replica_assignment(rd_kafka_NewTopic_t *new_topic, int32_t partition, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewTopic_set_config(rd_kafka_NewTopic_t *new_topic, const char *name, const char *value);</span>
<span class="s1">void rd_kafka_CreateTopics(rd_kafka_t *rk, rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_CreateTopics_result_topics(const rd_kafka_CreateTopics_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_DeleteTopic_s rd_kafka_DeleteTopic_t;</span>
<span class="s1">rd_kafka_DeleteTopic_t *rd_kafka_DeleteTopic_new(const char *topic);</span>
<span class="s1">void rd_kafka_DeleteTopic_destroy(rd_kafka_DeleteTopic_t *del_topic);</span>
<span class="s1">void rd_kafka_DeleteTopic_destroy_array(rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt);</span>
<span class="s1">void rd_kafka_DeleteTopics(rd_kafka_t *rk, rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_DeleteTopics_result_topics(const rd_kafka_DeleteTopics_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_NewPartitions_s rd_kafka_NewPartitions_t;</span>
<span class="s1">rd_kafka_NewPartitions_t *rd_kafka_NewPartitions_new(const char *topic, size_t new_total_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_NewPartitions_destroy(rd_kafka_NewPartitions_t *new_parts);</span>
<span class="s1">void rd_kafka_NewPartitions_destroy_array(rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewPartitions_set_replica_assignment(rd_kafka_NewPartitions_t *new_parts, int32_t new_partition_idx, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_CreatePartitions(rd_kafka_t *rk, rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_CreatePartitions_result_topics(const rd_kafka_CreatePartitions_result_t *result, size_t *cntp);</span>
<span class="s1">typedef enum rd_kafka_ConfigSource_t {</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_UNKNOWN_CONFIG = 0,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_TOPIC_CONFIG = 1,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_BROKER_CONFIG = 2,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_DEFAULT_BROKER_CONFIG = 3,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_STATIC_BROKER_CONFIG = 4,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DEFAULT_CONFIG = 5,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE__CNT,</span>
<span class="s1">} rd_kafka_ConfigSource_t;</span>
<span class="s1">const char *rd_kafka_ConfigSource_name(rd_kafka_ConfigSource_t confsource);</span>
<span class="s1">typedef struct rd_kafka_ConfigEntry_s rd_kafka_ConfigEntry_t;</span>
<span class="s1">const char *rd_kafka_ConfigEntry_name(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">const char *rd_kafka_ConfigEntry_value(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">rd_kafka_ConfigSource_t rd_kafka_ConfigEntry_source(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_read_only(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_default(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_sensitive(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_synonym(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">const rd_kafka_ConfigEntry_t **rd_kafka_ConfigEntry_synonyms(const rd_kafka_ConfigEntry_t *entry, size_t *cntp);</span>
<span class="s1">typedef enum rd_kafka_ResourceType_t {</span>
<span class="s1">  RD_KAFKA_RESOURCE_UNKNOWN = 0,</span>
<span class="s1">  RD_KAFKA_RESOURCE_ANY = 1,</span>
<span class="s1">  RD_KAFKA_RESOURCE_TOPIC = 2,</span>
<span class="s1">  RD_KAFKA_RESOURCE_GROUP = 3,</span>
<span class="s1">  RD_KAFKA_RESOURCE_BROKER = 4,</span>
<span class="s1">  RD_KAFKA_RESOURCE__CNT,</span>
<span class="s1">} rd_kafka_ResourceType_t;</span>
<span class="s1">const char *rd_kafka_ResourceType_name(rd_kafka_ResourceType_t restype);</span>
<span class="s1">typedef struct rd_kafka_ConfigResource_s rd_kafka_ConfigResource_t;</span>
<span class="s1">rd_kafka_ConfigResource_t *rd_kafka_ConfigResource_new(rd_kafka_ResourceType_t restype, const char *resname);</span>
<span class="s1">void rd_kafka_ConfigResource_destroy(rd_kafka_ConfigResource_t *config);</span>
<span class="s1">void rd_kafka_ConfigResource_destroy_array(rd_kafka_ConfigResource_t **config, size_t config_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_ConfigResource_set_config(rd_kafka_ConfigResource_t *config, const char *name, const char *value);</span>
<span class="s1">const rd_kafka_ConfigEntry_t **rd_kafka_ConfigResource_configs(const rd_kafka_ConfigResource_t *config, size_t *cntp);</span>
<span class="s1">rd_kafka_ResourceType_t rd_kafka_ConfigResource_type(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">const char *rd_kafka_ConfigResource_name(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_ConfigResource_error(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">const char *rd_kafka_ConfigResource_error_string(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">void rd_kafka_AlterConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_ConfigResource_t **rd_kafka_AlterConfigs_result_resources(const rd_kafka_AlterConfigs_result_t *result, size_t *cntp);</span>
<span class="s1">void rd_kafka_DescribeConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_ConfigResource_t **rd_kafka_DescribeConfigs_result_resources(const rd_kafka_DescribeConfigs_result_t *result, size_t *cntp);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token(rd_kafka_t *rk, const char *token_value, int64_t md_lifetime_ms, const char *md_principal_name, const char **extensions, size_t extension_size, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token_failure(rd_kafka_t *rk, const char *errstr);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_init_transactions(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_begin_transaction(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_send_offsets_to_transaction(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, const rd_kafka_consumer_group_metadata_t *cgmetadata, int timeout_ms);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_commit_transaction(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_abort_transaction(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">typedef struct rd_kafka_mock_cluster_s rd_kafka_mock_cluster_t;</span>
<span class="s1">rd_kafka_mock_cluster_t *rd_kafka_mock_cluster_new(rd_kafka_t *rk, int broker_cnt);</span>
<span class="s1">void rd_kafka_mock_cluster_destroy(rd_kafka_mock_cluster_t *mcluster);</span>
<span class="s1">rd_kafka_t *rd_kafka_mock_cluster_handle(const rd_kafka_mock_cluster_t *mcluster);</span>
<span class="s1">rd_kafka_mock_cluster_t *rd_kafka_handle_mock_cluster(const rd_kafka_t *rk);</span>
<span class="s1">const char *rd_kafka_mock_cluster_bootstraps(const rd_kafka_mock_cluster_t *mcluster);</span>
<span class="s1">void rd_kafka_mock_push_request_errors(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, size_t cnt, ...);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_push_request_errors(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int16_t ApiKey, size_t cnt, ...);</span>
<span class="s1">void rd_kafka_mock_topic_set_error(rd_kafka_mock_cluster_t *mcluster, const char *topic, rd_kafka_resp_err_t err);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_topic_create(rd_kafka_mock_cluster_t *mcluster, const char *topic, int partition_cnt, int replication_factor);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_partition_set_leader(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_partition_set_follower(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_partition_set_follower_wmarks(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int64_t lo, int64_t hi);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_set_down(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_set_up(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_set_rtt(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int rtt_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_set_rack(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, const char *rack);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_coordinator_set(rd_kafka_mock_cluster_t *mcluster, const char *key_type, const char *key, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_set_apiversion(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, int16_t MinVersion, int16_t MaxVersion);</span>
<span class="s1">&#39;</span>
</code></pre></div>
rdkafka.h, rdkafka_mock.h</p>
<h3 id="rd_kafka_version_11">RD_KAFKA_VERSION<a class="headerlink" href="#rd_kafka_version_11" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_VERSION</span> <span class="o">=</span> <span class="mi">17105663</span>
</code></pre></div>
<p>librdkafka version </p>
<p>Interpreted as hex <code>MM.mm.rr.xx</code>:</p>
<ul>
<li>MM = Major</li>
<li>mm = minor</li>
<li>rr = revision</li>
<li>xx = pre-release id (0xff is the final release)</li>
</ul>
<p>E.g.: <code>0x000801ff</code> = 0.8.1</p>
<dl class="section remark"><dt>Remarks</dt><dd>This value should only be used during compile time, for runtime checks of version use rd_kafka_version() </dd></dl>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_unsupported_compression_type_11">RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE<a class="headerlink" href="#rd_kafka_resp_err_unsupported_compression_type_11" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE</span> <span class="o">=</span> <span class="mi">76</span>
</code></pre></div>
<p>Unsupported compression type </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_end_all_11">RD_KAFKA_RESP_ERR_END_ALL<a class="headerlink" href="#rd_kafka_resp_err_end_all_11" title="Permanent link">&para;</a></h3>
<p><div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_END_ALL</span> <span class="o">=</span> <span class="mi">89</span>
</code></pre></div>
enum rd_kafka_resp_err_t</p>
<h3 id="rd_kafka_admin_op__cnt_11">RD_KAFKA_ADMIN_OP__CNT<a class="headerlink" href="#rd_kafka_admin_op__cnt_11" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_ADMIN_OP__CNT</span> <span class="o">=</span> <span class="mi">6</span>
</code></pre></div>
<p>Number of ops defined </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe </a></li>
</ul>
</div>
<h3 id="rd_kafka_resource__cnt_11">RD_KAFKA_RESOURCE__CNT<a class="headerlink" href="#rd_kafka_resource__cnt_11" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESOURCE__CNT</span> <span class="o">=</span> <span class="mi">5</span>
</code></pre></div>
<p>Number of resource types defined </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#acca83a66d7783ff7683ed2691cc907c9"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#acca83a66d7783ff7683ed2691cc907c9 </a></li>
</ul>
</div>
<h3 id="rd_kafka_cdef_11">RD_KAFKA_CDEF<a class="headerlink" href="#rd_kafka_cdef_11" title="Permanent link">&para;</a></h3>
<p><div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_CDEF</span> <span class="o">=</span> <span class="s1">&#39;typedef long int ssize_t;</span>
<span class="s1">typedef struct _IO_FILE FILE;</span>
<span class="s1">typedef long int mode_t;</span>
<span class="s1">typedef signed int int16_t;</span>
<span class="s1">typedef unsigned int uint16_t;</span>
<span class="s1">typedef signed int int32_t;</span>
<span class="s1">typedef signed long int int64_t;</span>
<span class="s1">int rd_kafka_version(void);</span>
<span class="s1">const char *rd_kafka_version_str(void);</span>
<span class="s1">typedef enum rd_kafka_type_t {</span>
<span class="s1">  RD_KAFKA_PRODUCER,</span>
<span class="s1">  RD_KAFKA_CONSUMER,</span>
<span class="s1">} rd_kafka_type_t;</span>
<span class="s1">typedef enum rd_kafka_timestamp_type_t {</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_NOT_AVAILABLE,</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_CREATE_TIME,</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_LOG_APPEND_TIME,</span>
<span class="s1">} rd_kafka_timestamp_type_t;</span>
<span class="s1">const char *rd_kafka_get_debug_contexts(void);</span>
<span class="s1">typedef struct rd_kafka_s rd_kafka_t;</span>
<span class="s1">typedef struct rd_kafka_topic_s rd_kafka_topic_t;</span>
<span class="s1">typedef struct rd_kafka_conf_s rd_kafka_conf_t;</span>
<span class="s1">typedef struct rd_kafka_topic_conf_s rd_kafka_topic_conf_t;</span>
<span class="s1">typedef struct rd_kafka_queue_s rd_kafka_queue_t;</span>
<span class="s1">typedef struct rd_kafka_op_s rd_kafka_event_t;</span>
<span class="s1">typedef struct rd_kafka_topic_result_s rd_kafka_topic_result_t;</span>
<span class="s1">typedef struct rd_kafka_consumer_group_metadata_s rd_kafka_consumer_group_metadata_t;</span>
<span class="s1">typedef struct rd_kafka_error_s {</span>
<span class="s1">  unsigned int code;</span>
<span class="s1">  char *errstr;</span>
<span class="s1">  unsigned char fatal;</span>
<span class="s1">  unsigned char retriable;</span>
<span class="s1">  unsigned char txn_requires_abort;</span>
<span class="s1">} rd_kafka_error_t;</span>
<span class="s1">typedef struct rd_kafka_headers_s rd_kafka_headers_t;</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BEGIN = (- 200),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BAD_MSG = (- 199),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BAD_COMPRESSION = (- 198),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__DESTROY = (- 197),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FAIL = (- 196),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TRANSPORT = (- 195),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__CRIT_SYS_RESOURCE = (- 194),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__RESOLVE = (- 193),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__MSG_TIMED_OUT = (- 192),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PARTITION_EOF = (- 191),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION = (- 190),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FS = (- 189),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC = (- 188),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ALL_BROKERS_DOWN = (- 187),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INVALID_ARG = (- 186),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TIMED_OUT = (- 185),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__QUEUE_FULL = (- 184),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ISR_INSUFF = (- 183),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NODE_UPDATE = (- 182),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__SSL = (- 181),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__WAIT_COORD = (- 180),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_GROUP = (- 179),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__IN_PROGRESS = (- 178),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PREV_IN_PROGRESS = (- 177),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__EXISTING_SUBSCRIPTION = (- 176),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS = (- 175),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS = (- 174),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__CONFLICT = (- 173),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__STATE = (- 172),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_PROTOCOL = (- 171),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED = (- 170),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__AUTHENTICATION = (- 169),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NO_OFFSET = (- 168),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__OUTDATED = (- 167),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TIMED_OUT_QUEUE = (- 166),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNSUPPORTED_FEATURE = (- 165),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__WAIT_CACHE = (- 164),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INTR = (- 163),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__KEY_SERIALIZATION = (- 162),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__VALUE_SERIALIZATION = (- 161),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__KEY_DESERIALIZATION = (- 160),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__VALUE_DESERIALIZATION = (- 159),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PARTIAL = (- 158),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__READ_ONLY = (- 157),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOENT = (- 156),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNDERFLOW = (- 155),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INVALID_TYPE = (- 154),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__RETRY = (- 153),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PURGE_QUEUE = (- 152),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PURGE_INFLIGHT = (- 151),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FATAL = (- 150),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INCONSISTENT = (- 149),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__GAPLESS_GUARANTEE = (- 148),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__MAX_POLL_EXCEEDED = (- 147),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_BROKER = (- 146),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOT_CONFIGURED = (- 145),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FENCED = (- 144),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__APPLICATION = (- 143),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__END = (- 100),</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN = (- 1),</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NO_ERROR = 0,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_OUT_OF_RANGE = 1,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_MSG = 2,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART = 3,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_MSG_SIZE = 4,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE = 5,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_LEADER_FOR_PARTITION = 6,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REQUEST_TIMED_OUT = 7,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_BROKER_NOT_AVAILABLE = 8,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REPLICA_NOT_AVAILABLE = 9,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE = 10,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_STALE_CTRL_EPOCH = 11,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_METADATA_TOO_LARGE = 12,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NETWORK_EXCEPTION = 13,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_COORDINATOR_LOAD_IN_PROGRESS = 14,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_COORDINATOR_NOT_AVAILABLE = 15,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_COORDINATOR = 16,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_EXCEPTION = 17,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_RECORD_LIST_TOO_LARGE = 18,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS = 19,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS_AFTER_APPEND = 20,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REQUIRED_ACKS = 21,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ILLEGAL_GENERATION = 22,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INCONSISTENT_GROUP_PROTOCOL = 23,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_GROUP_ID = 24,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_MEMBER_ID = 25,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_SESSION_TIMEOUT = 26,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REBALANCE_IN_PROGRESS = 27,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_COMMIT_OFFSET_SIZE = 28,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_AUTHORIZATION_FAILED = 29,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_AUTHORIZATION_FAILED = 30,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_CLUSTER_AUTHORIZATION_FAILED = 31,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TIMESTAMP = 32,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_SASL_MECHANISM = 33,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ILLEGAL_SASL_STATE = 34,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_VERSION = 35,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_ALREADY_EXISTS = 36,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PARTITIONS = 37,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REPLICATION_FACTOR = 38,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REPLICA_ASSIGNMENT = 39,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_CONFIG = 40,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_CONTROLLER = 41,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REQUEST = 42,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_FOR_MESSAGE_FORMAT = 43,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_POLICY_VIOLATION = 44,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OUT_OF_ORDER_SEQUENCE_NUMBER = 45,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DUPLICATE_SEQUENCE_NUMBER = 46,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_EPOCH = 47,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TXN_STATE = 48,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_ID_MAPPING = 49,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TRANSACTION_TIMEOUT = 50,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_CONCURRENT_TRANSACTIONS = 51,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TRANSACTION_COORDINATOR_FENCED = 52,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TRANSACTIONAL_ID_AUTHORIZATION_FAILED = 53,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_SECURITY_DISABLED = 54,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OPERATION_NOT_ATTEMPTED = 55,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_KAFKA_STORAGE_ERROR = 56,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LOG_DIR_NOT_FOUND = 57,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_SASL_AUTHENTICATION_FAILED = 58,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_PRODUCER_ID = 59,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REASSIGNMENT_IN_PROGRESS = 60,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTH_DISABLED = 61,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_NOT_FOUND = 62,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_OWNER_MISMATCH = 63,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_REQUEST_NOT_ALLOWED = 64,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTHORIZATION_FAILED = 65,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_EXPIRED = 66,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRINCIPAL_TYPE = 67,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NON_EMPTY_GROUP = 68,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_ID_NOT_FOUND = 69,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FETCH_SESSION_ID_NOT_FOUND = 70,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_FETCH_SESSION_EPOCH = 71,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LISTENER_NOT_FOUND = 72,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_DELETION_DISABLED = 73,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FENCED_LEADER_EPOCH = 74,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_LEADER_EPOCH = 75,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_STALE_BROKER_EPOCH = 77,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_NOT_AVAILABLE = 78,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_MEMBER_ID_REQUIRED = 79,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_PREFERRED_LEADER_NOT_AVAILABLE = 80,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_MAX_SIZE_REACHED = 81,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FENCED_INSTANCE_ID = 82,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ELIGIBLE_LEADERS_NOT_AVAILABLE = 83,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ELECTION_NOT_NEEDED = 84,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NO_REASSIGNMENT_IN_PROGRESS = 85,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_SUBSCRIBED_TO_TOPIC = 86,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_RECORD = 87,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSTABLE_OFFSET_COMMIT = 88,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_END_ALL,</span>
<span class="s1">} rd_kafka_resp_err_t;</span>
<span class="s1">struct rd_kafka_err_desc {</span>
<span class="s1">  rd_kafka_resp_err_t code;</span>
<span class="s1">  char *name;</span>
<span class="s1">  char *desc;</span>
<span class="s1">};</span>
<span class="s1">void rd_kafka_get_err_descs(const struct rd_kafka_err_desc **errdescs, size_t *cntp);</span>
<span class="s1">const char *rd_kafka_err2str(rd_kafka_resp_err_t err);</span>
<span class="s1">const char *rd_kafka_err2name(rd_kafka_resp_err_t err);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_last_error(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_errno2err(int errnox);</span>
<span class="s1">int rd_kafka_errno(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_fatal_error(rd_kafka_t *rk, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_test_fatal_error(rd_kafka_t *rk, rd_kafka_resp_err_t err, const char *reason);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_error_code(const rd_kafka_error_t *error);</span>
<span class="s1">const char *rd_kafka_error_name(const rd_kafka_error_t *error);</span>
<span class="s1">const char *rd_kafka_error_string(const rd_kafka_error_t *error);</span>
<span class="s1">int rd_kafka_error_is_fatal(const rd_kafka_error_t *error);</span>
<span class="s1">int rd_kafka_error_is_retriable(const rd_kafka_error_t *error);</span>
<span class="s1">int rd_kafka_error_txn_requires_abort(const rd_kafka_error_t *error);</span>
<span class="s1">void rd_kafka_error_destroy(rd_kafka_error_t *error);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_error_new(rd_kafka_resp_err_t code, const char *fmt, ...);</span>
<span class="s1">typedef struct rd_kafka_topic_partition_s {</span>
<span class="s1">  char *topic;</span>
<span class="s1">  int32_t partition;</span>
<span class="s1">  int64_t offset;</span>
<span class="s1">  void *metadata;</span>
<span class="s1">  size_t metadata_size;</span>
<span class="s1">  void *opaque;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  void *_private;</span>
<span class="s1">} rd_kafka_topic_partition_t;</span>
<span class="s1">void rd_kafka_topic_partition_destroy(rd_kafka_topic_partition_t *rktpar);</span>
<span class="s1">typedef struct rd_kafka_topic_partition_list_s {</span>
<span class="s1">  int cnt;</span>
<span class="s1">  int size;</span>
<span class="s1">  rd_kafka_topic_partition_t *elems;</span>
<span class="s1">} rd_kafka_topic_partition_list_t;</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_new(int size);</span>
<span class="s1">void rd_kafka_topic_partition_list_destroy(rd_kafka_topic_partition_list_t *rkparlist);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_add(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">void rd_kafka_topic_partition_list_add_range(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t start, int32_t stop);</span>
<span class="s1">int rd_kafka_topic_partition_list_del(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">int rd_kafka_topic_partition_list_del_by_idx(rd_kafka_topic_partition_list_t *rktparlist, int idx);</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_copy(const rd_kafka_topic_partition_list_t *src);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_topic_partition_list_set_offset(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition, int64_t offset);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_find(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">void rd_kafka_topic_partition_list_sort(rd_kafka_topic_partition_list_t *rktparlist, int (*cmp)(const void *a, const void *b, void *cmp_opaque), void *cmp_opaque);</span>
<span class="s1">typedef enum rd_kafka_vtype_t {</span>
<span class="s1">  RD_KAFKA_VTYPE_END,</span>
<span class="s1">  RD_KAFKA_VTYPE_TOPIC,</span>
<span class="s1">  RD_KAFKA_VTYPE_RKT,</span>
<span class="s1">  RD_KAFKA_VTYPE_PARTITION,</span>
<span class="s1">  RD_KAFKA_VTYPE_VALUE,</span>
<span class="s1">  RD_KAFKA_VTYPE_KEY,</span>
<span class="s1">  RD_KAFKA_VTYPE_OPAQUE,</span>
<span class="s1">  RD_KAFKA_VTYPE_MSGFLAGS,</span>
<span class="s1">  RD_KAFKA_VTYPE_TIMESTAMP,</span>
<span class="s1">  RD_KAFKA_VTYPE_HEADER,</span>
<span class="s1">  RD_KAFKA_VTYPE_HEADERS,</span>
<span class="s1">} rd_kafka_vtype_t;</span>
<span class="s1">typedef struct rd_kafka_vu_s {</span>
<span class="s1">  rd_kafka_vtype_t vtype;</span>
<span class="s1">  union {</span>
<span class="s1">    char *cstr;</span>
<span class="s1">    rd_kafka_topic_t *rkt;</span>
<span class="s1">    int i;</span>
<span class="s1">    int32_t i32;</span>
<span class="s1">    int64_t i64;</span>
<span class="s1">    struct {</span>
<span class="s1">      void *ptr;</span>
<span class="s1">      size_t size;</span>
<span class="s1">    } mem;</span>
<span class="s1">    struct {</span>
<span class="s1">      char *name;</span>
<span class="s1">      void *val;</span>
<span class="s1">      ssize_t size;</span>
<span class="s1">    } header;</span>
<span class="s1">    rd_kafka_headers_t *headers;</span>
<span class="s1">    void *ptr;</span>
<span class="s1">    char _pad[64];</span>
<span class="s1">  } u;</span>
<span class="s1">} rd_kafka_vu_t;</span>
<span class="s1">rd_kafka_headers_t *rd_kafka_headers_new(size_t initial_count);</span>
<span class="s1">void rd_kafka_headers_destroy(rd_kafka_headers_t *hdrs);</span>
<span class="s1">rd_kafka_headers_t *rd_kafka_headers_copy(const rd_kafka_headers_t *src);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_add(rd_kafka_headers_t *hdrs, const char *name, ssize_t name_size, const void *value, ssize_t value_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_remove(rd_kafka_headers_t *hdrs, const char *name);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get_last(const rd_kafka_headers_t *hdrs, const char *name, const void **valuep, size_t *sizep);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get(const rd_kafka_headers_t *hdrs, size_t idx, const char *name, const void **valuep, size_t *sizep);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get_all(const rd_kafka_headers_t *hdrs, size_t idx, const char **namep, const void **valuep, size_t *sizep);</span>
<span class="s1">typedef struct rd_kafka_message_s {</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  rd_kafka_topic_t *rkt;</span>
<span class="s1">  int32_t partition;</span>
<span class="s1">  void *payload;</span>
<span class="s1">  size_t len;</span>
<span class="s1">  void *key;</span>
<span class="s1">  size_t key_len;</span>
<span class="s1">  int64_t offset;</span>
<span class="s1">  void *_private;</span>
<span class="s1">} rd_kafka_message_t;</span>
<span class="s1">void rd_kafka_message_destroy(rd_kafka_message_t *rkmessage);</span>
<span class="s1">const char *rd_kafka_message_errstr(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">int64_t rd_kafka_message_timestamp(const rd_kafka_message_t *rkmessage, rd_kafka_timestamp_type_t *tstype);</span>
<span class="s1">int64_t rd_kafka_message_latency(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">int32_t rd_kafka_message_broker_id(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_message_headers(const rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_message_detach_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);</span>
<span class="s1">void rd_kafka_message_set_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t *hdrs);</span>
<span class="s1">size_t rd_kafka_header_cnt(const rd_kafka_headers_t *hdrs);</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_NOT_PERSISTED = 0,</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_POSSIBLY_PERSISTED = 1,</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_PERSISTED = 2,</span>
<span class="s1">} rd_kafka_msg_status_t;</span>
<span class="s1">rd_kafka_msg_status_t rd_kafka_message_status(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_CONF_UNKNOWN = (- 2),</span>
<span class="s1">  RD_KAFKA_CONF_INVALID = (- 1),</span>
<span class="s1">  RD_KAFKA_CONF_OK = 0,</span>
<span class="s1">} rd_kafka_conf_res_t;</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_new(void);</span>
<span class="s1">void rd_kafka_conf_destroy(rd_kafka_conf_t *conf);</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_dup(const rd_kafka_conf_t *conf);</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_dup_filter(const rd_kafka_conf_t *conf, size_t filter_cnt, const char **filter);</span>
<span class="s1">const rd_kafka_conf_t *rd_kafka_conf(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_set(rd_kafka_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_conf_set_events(rd_kafka_conf_t *conf, int events);</span>
<span class="s1">void rd_kafka_conf_set_background_event_cb(rd_kafka_conf_t *conf, void (*event_cb)(rd_kafka_t *rk, rd_kafka_event_t *rkev, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_dr_cb(rd_kafka_conf_t *conf, void (*dr_cb)(rd_kafka_t *rk, void *payload, size_t len, rd_kafka_resp_err_t err, void *opaque, void *msg_opaque));</span>
<span class="s1">void rd_kafka_conf_set_dr_msg_cb(rd_kafka_conf_t *conf, void (*dr_msg_cb)(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_consume_cb(rd_kafka_conf_t *conf, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_rebalance_cb(rd_kafka_conf_t *conf, void (*rebalance_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *partitions, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_offset_commit_cb(rd_kafka_conf_t *conf, void (*offset_commit_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_error_cb(rd_kafka_conf_t *conf, void (*error_cb)(rd_kafka_t *rk, int err, const char *reason, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_throttle_cb(rd_kafka_conf_t *conf, void (*throttle_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int throttle_time_ms, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_log_cb(rd_kafka_conf_t *conf, void (*log_cb)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));</span>
<span class="s1">void rd_kafka_conf_set_stats_cb(rd_kafka_conf_t *conf, int (*stats_cb)(rd_kafka_t *rk, char *json, size_t json_len, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_oauthbearer_token_refresh_cb(rd_kafka_conf_t *conf, void (*oauthbearer_token_refresh_cb)(rd_kafka_t *rk, const char *oauthbearer_config, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_socket_cb(rd_kafka_conf_t *conf, int (*socket_cb)(int domain, int type, int protocol, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_connect_cb(rd_kafka_conf_t *conf, int (*connect_cb)(int sockfd, const struct sockaddr *addr, int addrlen, const char *id, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_closesocket_cb(rd_kafka_conf_t *conf, int (*closesocket_cb)(int sockfd, void *opaque));</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert_verify_cb(rd_kafka_conf_t *conf, int (*ssl_cert_verify_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int *x509_error, int depth, const char *buf, size_t size, char *errstr, size_t errstr_size, void *opaque));</span>
<span class="s1">typedef enum rd_kafka_cert_type_t {</span>
<span class="s1">  RD_KAFKA_CERT_PUBLIC_KEY,</span>
<span class="s1">  RD_KAFKA_CERT_PRIVATE_KEY,</span>
<span class="s1">  RD_KAFKA_CERT_CA,</span>
<span class="s1">  RD_KAFKA_CERT__CNT,</span>
<span class="s1">} rd_kafka_cert_type_t;</span>
<span class="s1">typedef enum rd_kafka_cert_enc_t {</span>
<span class="s1">  RD_KAFKA_CERT_ENC_PKCS12,</span>
<span class="s1">  RD_KAFKA_CERT_ENC_DER,</span>
<span class="s1">  RD_KAFKA_CERT_ENC_PEM,</span>
<span class="s1">  RD_KAFKA_CERT_ENC__CNT,</span>
<span class="s1">} rd_kafka_cert_enc_t;</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert(rd_kafka_conf_t *conf, rd_kafka_cert_type_t cert_type, rd_kafka_cert_enc_t cert_enc, const void *buffer, size_t size, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_conf_set_opaque(rd_kafka_conf_t *conf, void *opaque);</span>
<span class="s1">void *rd_kafka_opaque(const rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_conf_set_default_topic_conf(rd_kafka_conf_t *conf, rd_kafka_topic_conf_t *tconf);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_get(const rd_kafka_conf_t *conf, const char *name, char *dest, size_t *dest_size);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_topic_conf_get(const rd_kafka_topic_conf_t *conf, const char *name, char *dest, size_t *dest_size);</span>
<span class="s1">const char **rd_kafka_conf_dump(rd_kafka_conf_t *conf, size_t *cntp);</span>
<span class="s1">const char **rd_kafka_topic_conf_dump(rd_kafka_topic_conf_t *conf, size_t *cntp);</span>
<span class="s1">void rd_kafka_conf_dump_free(const char **arr, size_t cnt);</span>
<span class="s1">void rd_kafka_conf_properties_show(FILE *fp);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_topic_conf_new(void);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_topic_conf_dup(const rd_kafka_topic_conf_t *conf);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_default_topic_conf_dup(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_topic_conf_destroy(rd_kafka_topic_conf_t *topic_conf);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_topic_conf_set(rd_kafka_topic_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_topic_conf_set_opaque(rd_kafka_topic_conf_t *conf, void *rkt_opaque);</span>
<span class="s1">void rd_kafka_topic_conf_set_partitioner_cb(rd_kafka_topic_conf_t *topic_conf, int32_t (*partitioner)(const rd_kafka_topic_t *rkt, const void *keydata, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque));</span>
<span class="s1">void rd_kafka_topic_conf_set_msg_order_cmp(rd_kafka_topic_conf_t *topic_conf, int (*msg_order_cmp)(const rd_kafka_message_t *a, const rd_kafka_message_t *b));</span>
<span class="s1">int rd_kafka_topic_partition_available(const rd_kafka_topic_t *rkt, int32_t partition);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_consistent(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_consistent_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_murmur2(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_murmur2_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_fnv1a(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_fnv1a_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">rd_kafka_t *rd_kafka_new(rd_kafka_type_t type, rd_kafka_conf_t *conf, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_destroy(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_destroy_flags(rd_kafka_t *rk, int flags);</span>
<span class="s1">const char *rd_kafka_name(const rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_type_t rd_kafka_type(const rd_kafka_t *rk);</span>
<span class="s1">char *rd_kafka_memberid(const rd_kafka_t *rk);</span>
<span class="s1">char *rd_kafka_clusterid(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">int32_t rd_kafka_controllerid(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_topic_t *rd_kafka_topic_new(rd_kafka_t *rk, const char *topic, rd_kafka_topic_conf_t *conf);</span>
<span class="s1">void rd_kafka_topic_destroy(rd_kafka_topic_t *rkt);</span>
<span class="s1">const char *rd_kafka_topic_name(const rd_kafka_topic_t *rkt);</span>
<span class="s1">void *rd_kafka_topic_opaque(const rd_kafka_topic_t *rkt);</span>
<span class="s1">int rd_kafka_poll(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">void rd_kafka_yield(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_pause_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_resume_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_query_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_get_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offsets_for_times(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets, int timeout_ms);</span>
<span class="s1">void rd_kafka_mem_free(rd_kafka_t *rk, void *ptr);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_new(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_queue_destroy(rd_kafka_queue_t *rkqu);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_main(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_consumer(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_partition(rd_kafka_t *rk, const char *topic, int32_t partition);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_background(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_queue_forward(rd_kafka_queue_t *src, rd_kafka_queue_t *dst);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_set_log_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu);</span>
<span class="s1">size_t rd_kafka_queue_length(rd_kafka_queue_t *rkqu);</span>
<span class="s1">void rd_kafka_queue_io_event_enable(rd_kafka_queue_t *rkqu, int fd, const void *payload, size_t size);</span>
<span class="s1">void rd_kafka_queue_cb_event_enable(rd_kafka_queue_t *rkqu, void (*event_cb)(rd_kafka_t *rk, void *qev_opaque), void *qev_opaque);</span>
<span class="s1">int rd_kafka_consume_start(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);</span>
<span class="s1">int rd_kafka_consume_start_queue(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, rd_kafka_queue_t *rkqu);</span>
<span class="s1">int rd_kafka_consume_stop(rd_kafka_topic_t *rkt, int32_t partition);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_seek(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, int timeout_ms);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consume(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms);</span>
<span class="s1">ssize_t rd_kafka_consume_batch(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);</span>
<span class="s1">int rd_kafka_consume_callback(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consume_queue(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">ssize_t rd_kafka_consume_batch_queue(rd_kafka_queue_t *rkqu, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);</span>
<span class="s1">int rd_kafka_consume_callback_queue(rd_kafka_queue_t *rkqu, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offset_store(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offsets_store(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_subscribe(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *topics);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_unsubscribe(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_subscription(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **topics);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consumer_poll(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_consumer_close(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_assignment(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, int async);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit_message(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, int async);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit_queue(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_queue_t *rkqu, void (*cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *commit_opaque), void *commit_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_committed(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_position(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata_new(const char *group_id);</span>
<span class="s1">void rd_kafka_consumer_group_metadata_destroy(rd_kafka_consumer_group_metadata_t *);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_consumer_group_metadata_write(const rd_kafka_consumer_group_metadata_t *cgmd, void **bufferp, size_t *sizep);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_consumer_group_metadata_read(rd_kafka_consumer_group_metadata_t **cgmdp, const void *buffer, size_t size);</span>
<span class="s1">int rd_kafka_produce(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, void *payload, size_t len, const void *key, size_t keylen, void *msg_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_producev(rd_kafka_t *rk, ...);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_produceva(rd_kafka_t *rk, const rd_kafka_vu_t *vus, size_t cnt);</span>
<span class="s1">int rd_kafka_produce_batch(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, rd_kafka_message_t *rkmessages, int message_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_flush(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_purge(rd_kafka_t *rk, int purge_flags);</span>
<span class="s1">typedef struct rd_kafka_metadata_broker {</span>
<span class="s1">  int32_t id;</span>
<span class="s1">  char *host;</span>
<span class="s1">  int port;</span>
<span class="s1">} rd_kafka_metadata_broker_t;</span>
<span class="s1">typedef struct rd_kafka_metadata_partition {</span>
<span class="s1">  int32_t id;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  int32_t leader;</span>
<span class="s1">  int replica_cnt;</span>
<span class="s1">  int32_t *replicas;</span>
<span class="s1">  int isr_cnt;</span>
<span class="s1">  int32_t *isrs;</span>
<span class="s1">} rd_kafka_metadata_partition_t;</span>
<span class="s1">typedef struct rd_kafka_metadata_topic {</span>
<span class="s1">  char *topic;</span>
<span class="s1">  int partition_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_partition *partitions;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">} rd_kafka_metadata_topic_t;</span>
<span class="s1">typedef struct rd_kafka_metadata {</span>
<span class="s1">  int broker_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_broker *brokers;</span>
<span class="s1">  int topic_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_topic *topics;</span>
<span class="s1">  int32_t orig_broker_id;</span>
<span class="s1">  char *orig_broker_name;</span>
<span class="s1">} rd_kafka_metadata_t;</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_metadata(rd_kafka_t *rk, int all_topics, rd_kafka_topic_t *only_rkt, const struct rd_kafka_metadata **metadatap, int timeout_ms);</span>
<span class="s1">void rd_kafka_metadata_destroy(const struct rd_kafka_metadata *metadata);</span>
<span class="s1">struct rd_kafka_group_member_info {</span>
<span class="s1">  char *member_id;</span>
<span class="s1">  char *client_id;</span>
<span class="s1">  char *client_host;</span>
<span class="s1">  void *member_metadata;</span>
<span class="s1">  int member_metadata_size;</span>
<span class="s1">  void *member_assignment;</span>
<span class="s1">  int member_assignment_size;</span>
<span class="s1">};</span>
<span class="s1">struct rd_kafka_group_info {</span>
<span class="s1">  struct rd_kafka_metadata_broker broker;</span>
<span class="s1">  char *group;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  char *state;</span>
<span class="s1">  char *protocol_type;</span>
<span class="s1">  char *protocol;</span>
<span class="s1">  struct rd_kafka_group_member_info *members;</span>
<span class="s1">  int member_cnt;</span>
<span class="s1">};</span>
<span class="s1">struct rd_kafka_group_list {</span>
<span class="s1">  struct rd_kafka_group_info *groups;</span>
<span class="s1">  int group_cnt;</span>
<span class="s1">};</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_list_groups(rd_kafka_t *rk, const char *group, const struct rd_kafka_group_list **grplistp, int timeout_ms);</span>
<span class="s1">void rd_kafka_group_list_destroy(const struct rd_kafka_group_list *grplist);</span>
<span class="s1">int rd_kafka_brokers_add(rd_kafka_t *rk, const char *brokerlist);</span>
<span class="s1">void rd_kafka_set_logger(rd_kafka_t *rk, void (*func)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));</span>
<span class="s1">void rd_kafka_set_log_level(rd_kafka_t *rk, int level);</span>
<span class="s1">void rd_kafka_log_print(const rd_kafka_t *rk, int level, const char *fac, const char *buf);</span>
<span class="s1">void rd_kafka_log_syslog(const rd_kafka_t *rk, int level, const char *fac, const char *buf);</span>
<span class="s1">int rd_kafka_outq_len(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_dump(FILE *fp, rd_kafka_t *rk);</span>
<span class="s1">int rd_kafka_thread_cnt(void);</span>
<span class="s1">typedef enum rd_kafka_thread_type_t {</span>
<span class="s1">  RD_KAFKA_THREAD_MAIN,</span>
<span class="s1">  RD_KAFKA_THREAD_BACKGROUND,</span>
<span class="s1">  RD_KAFKA_THREAD_BROKER,</span>
<span class="s1">} rd_kafka_thread_type_t;</span>
<span class="s1">int rd_kafka_wait_destroyed(int timeout_ms);</span>
<span class="s1">int rd_kafka_unittest(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_poll_set_consumer(rd_kafka_t *rk);</span>
<span class="s1">typedef int rd_kafka_event_type_t;</span>
<span class="s1">rd_kafka_event_type_t rd_kafka_event_type(const rd_kafka_event_t *rkev);</span>
<span class="s1">const char *rd_kafka_event_name(const rd_kafka_event_t *rkev);</span>
<span class="s1">void rd_kafka_event_destroy(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_message_t *rd_kafka_event_message_next(rd_kafka_event_t *rkev);</span>
<span class="s1">size_t rd_kafka_event_message_array(rd_kafka_event_t *rkev, const rd_kafka_message_t **rkmessages, size_t size);</span>
<span class="s1">size_t rd_kafka_event_message_count(rd_kafka_event_t *rkev);</span>
<span class="s1">const char *rd_kafka_event_config_string(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_event_error(rd_kafka_event_t *rkev);</span>
<span class="s1">const char *rd_kafka_event_error_string(rd_kafka_event_t *rkev);</span>
<span class="s1">int rd_kafka_event_error_is_fatal(rd_kafka_event_t *rkev);</span>
<span class="s1">void *rd_kafka_event_opaque(rd_kafka_event_t *rkev);</span>
<span class="s1">int rd_kafka_event_log(rd_kafka_event_t *rkev, const char **fac, const char **str, int *level);</span>
<span class="s1">int rd_kafka_event_debug_contexts(rd_kafka_event_t *rkev, char *dst, size_t dstsize);</span>
<span class="s1">const char *rd_kafka_event_stats(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_event_topic_partition_list(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_event_topic_partition(rd_kafka_event_t *rkev);</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_CreateTopics_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DeleteTopics_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_CreatePartitions_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_AlterConfigs_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DescribeConfigs_result_t;</span>
<span class="s1">const rd_kafka_CreateTopics_result_t *rd_kafka_event_CreateTopics_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DeleteTopics_result_t *rd_kafka_event_DeleteTopics_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_CreatePartitions_result_t *rd_kafka_event_CreatePartitions_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_AlterConfigs_result_t *rd_kafka_event_AlterConfigs_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DescribeConfigs_result_t *rd_kafka_event_DescribeConfigs_result(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_event_t *rd_kafka_queue_poll(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">int rd_kafka_queue_poll_callback(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_plugin_f_conf_init_t)(rd_kafka_conf_t *conf, void **plug_opaquep, char *errstr, size_t errstr_size);</span>
<span class="s1">typedef rd_kafka_conf_res_t (rd_kafka_interceptor_f_on_conf_set_t)(rd_kafka_conf_t *conf, const char *name, const char *val, char *errstr, size_t errstr_size, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_dup_t)(rd_kafka_conf_t *new_conf, const rd_kafka_conf_t *old_conf, size_t filter_cnt, const char **filter, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_destroy_t)(void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_new_t)(rd_kafka_t *rk, const rd_kafka_conf_t *conf, void *ic_opaque, char *errstr, size_t errstr_size);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_destroy_t)(rd_kafka_t *rk, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_send_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_acknowledgement_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_consume_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_commit_t)(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_resp_err_t err, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_request_sent_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_start_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_exit_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_set(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_set_t *on_conf_set, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_dup(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_dup_t *on_conf_dup, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_destroy(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_destroy_t *on_conf_destroy, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_new(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_new_t *on_new, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_destroy(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_destroy_t *on_destroy, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_send(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_send_t *on_send, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_acknowledgement(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_acknowledgement_t *on_acknowledgement, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_consume(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_consume_t *on_consume, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_commit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_commit_t *on_commit, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_request_sent(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_request_sent_t *on_request_sent, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_start(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_start_t *on_thread_start, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_exit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_exit_t *on_thread_exit, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_topic_result_error(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">const char *rd_kafka_topic_result_error_string(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">const char *rd_kafka_topic_result_name(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">typedef enum rd_kafka_admin_op_t {</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_ANY = 0,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_CREATETOPICS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DELETETOPICS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_CREATEPARTITIONS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_ALTERCONFIGS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DESCRIBECONFIGS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP__CNT,</span>
<span class="s1">} rd_kafka_admin_op_t;</span>
<span class="s1">typedef struct rd_kafka_AdminOptions_s rd_kafka_AdminOptions_t;</span>
<span class="s1">rd_kafka_AdminOptions_t *rd_kafka_AdminOptions_new(rd_kafka_t *rk, rd_kafka_admin_op_t for_api);</span>
<span class="s1">void rd_kafka_AdminOptions_destroy(rd_kafka_AdminOptions_t *options);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_request_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_operation_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_validate_only(rd_kafka_AdminOptions_t *options, int true_or_false, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_broker(rd_kafka_AdminOptions_t *options, int32_t broker_id, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_AdminOptions_set_opaque(rd_kafka_AdminOptions_t *options, void *ev_opaque);</span>
<span class="s1">typedef struct rd_kafka_NewTopic_s rd_kafka_NewTopic_t;</span>
<span class="s1">rd_kafka_NewTopic_t *rd_kafka_NewTopic_new(const char *topic, int num_partitions, int replication_factor, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_NewTopic_destroy(rd_kafka_NewTopic_t *new_topic);</span>
<span class="s1">void rd_kafka_NewTopic_destroy_array(rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewTopic_set_replica_assignment(rd_kafka_NewTopic_t *new_topic, int32_t partition, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewTopic_set_config(rd_kafka_NewTopic_t *new_topic, const char *name, const char *value);</span>
<span class="s1">void rd_kafka_CreateTopics(rd_kafka_t *rk, rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_CreateTopics_result_topics(const rd_kafka_CreateTopics_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_DeleteTopic_s rd_kafka_DeleteTopic_t;</span>
<span class="s1">rd_kafka_DeleteTopic_t *rd_kafka_DeleteTopic_new(const char *topic);</span>
<span class="s1">void rd_kafka_DeleteTopic_destroy(rd_kafka_DeleteTopic_t *del_topic);</span>
<span class="s1">void rd_kafka_DeleteTopic_destroy_array(rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt);</span>
<span class="s1">void rd_kafka_DeleteTopics(rd_kafka_t *rk, rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_DeleteTopics_result_topics(const rd_kafka_DeleteTopics_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_NewPartitions_s rd_kafka_NewPartitions_t;</span>
<span class="s1">rd_kafka_NewPartitions_t *rd_kafka_NewPartitions_new(const char *topic, size_t new_total_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_NewPartitions_destroy(rd_kafka_NewPartitions_t *new_parts);</span>
<span class="s1">void rd_kafka_NewPartitions_destroy_array(rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewPartitions_set_replica_assignment(rd_kafka_NewPartitions_t *new_parts, int32_t new_partition_idx, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_CreatePartitions(rd_kafka_t *rk, rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_CreatePartitions_result_topics(const rd_kafka_CreatePartitions_result_t *result, size_t *cntp);</span>
<span class="s1">typedef enum rd_kafka_ConfigSource_t {</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_UNKNOWN_CONFIG = 0,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_TOPIC_CONFIG = 1,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_BROKER_CONFIG = 2,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_DEFAULT_BROKER_CONFIG = 3,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_STATIC_BROKER_CONFIG = 4,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DEFAULT_CONFIG = 5,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE__CNT,</span>
<span class="s1">} rd_kafka_ConfigSource_t;</span>
<span class="s1">const char *rd_kafka_ConfigSource_name(rd_kafka_ConfigSource_t confsource);</span>
<span class="s1">typedef struct rd_kafka_ConfigEntry_s rd_kafka_ConfigEntry_t;</span>
<span class="s1">const char *rd_kafka_ConfigEntry_name(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">const char *rd_kafka_ConfigEntry_value(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">rd_kafka_ConfigSource_t rd_kafka_ConfigEntry_source(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_read_only(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_default(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_sensitive(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_synonym(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">const rd_kafka_ConfigEntry_t **rd_kafka_ConfigEntry_synonyms(const rd_kafka_ConfigEntry_t *entry, size_t *cntp);</span>
<span class="s1">typedef enum rd_kafka_ResourceType_t {</span>
<span class="s1">  RD_KAFKA_RESOURCE_UNKNOWN = 0,</span>
<span class="s1">  RD_KAFKA_RESOURCE_ANY = 1,</span>
<span class="s1">  RD_KAFKA_RESOURCE_TOPIC = 2,</span>
<span class="s1">  RD_KAFKA_RESOURCE_GROUP = 3,</span>
<span class="s1">  RD_KAFKA_RESOURCE_BROKER = 4,</span>
<span class="s1">  RD_KAFKA_RESOURCE__CNT,</span>
<span class="s1">} rd_kafka_ResourceType_t;</span>
<span class="s1">const char *rd_kafka_ResourceType_name(rd_kafka_ResourceType_t restype);</span>
<span class="s1">typedef struct rd_kafka_ConfigResource_s rd_kafka_ConfigResource_t;</span>
<span class="s1">rd_kafka_ConfigResource_t *rd_kafka_ConfigResource_new(rd_kafka_ResourceType_t restype, const char *resname);</span>
<span class="s1">void rd_kafka_ConfigResource_destroy(rd_kafka_ConfigResource_t *config);</span>
<span class="s1">void rd_kafka_ConfigResource_destroy_array(rd_kafka_ConfigResource_t **config, size_t config_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_ConfigResource_set_config(rd_kafka_ConfigResource_t *config, const char *name, const char *value);</span>
<span class="s1">const rd_kafka_ConfigEntry_t **rd_kafka_ConfigResource_configs(const rd_kafka_ConfigResource_t *config, size_t *cntp);</span>
<span class="s1">rd_kafka_ResourceType_t rd_kafka_ConfigResource_type(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">const char *rd_kafka_ConfigResource_name(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_ConfigResource_error(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">const char *rd_kafka_ConfigResource_error_string(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">void rd_kafka_AlterConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_ConfigResource_t **rd_kafka_AlterConfigs_result_resources(const rd_kafka_AlterConfigs_result_t *result, size_t *cntp);</span>
<span class="s1">void rd_kafka_DescribeConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_ConfigResource_t **rd_kafka_DescribeConfigs_result_resources(const rd_kafka_DescribeConfigs_result_t *result, size_t *cntp);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token(rd_kafka_t *rk, const char *token_value, int64_t md_lifetime_ms, const char *md_principal_name, const char **extensions, size_t extension_size, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token_failure(rd_kafka_t *rk, const char *errstr);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_init_transactions(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_begin_transaction(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_send_offsets_to_transaction(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, const rd_kafka_consumer_group_metadata_t *cgmetadata, int timeout_ms);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_commit_transaction(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_abort_transaction(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">typedef struct rd_kafka_mock_cluster_s rd_kafka_mock_cluster_t;</span>
<span class="s1">rd_kafka_mock_cluster_t *rd_kafka_mock_cluster_new(rd_kafka_t *rk, int broker_cnt);</span>
<span class="s1">void rd_kafka_mock_cluster_destroy(rd_kafka_mock_cluster_t *mcluster);</span>
<span class="s1">rd_kafka_t *rd_kafka_mock_cluster_handle(const rd_kafka_mock_cluster_t *mcluster);</span>
<span class="s1">rd_kafka_mock_cluster_t *rd_kafka_handle_mock_cluster(const rd_kafka_t *rk);</span>
<span class="s1">const char *rd_kafka_mock_cluster_bootstraps(const rd_kafka_mock_cluster_t *mcluster);</span>
<span class="s1">void rd_kafka_mock_push_request_errors(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, size_t cnt, ...);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_push_request_errors(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int16_t ApiKey, size_t cnt, ...);</span>
<span class="s1">void rd_kafka_mock_topic_set_error(rd_kafka_mock_cluster_t *mcluster, const char *topic, rd_kafka_resp_err_t err);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_topic_create(rd_kafka_mock_cluster_t *mcluster, const char *topic, int partition_cnt, int replication_factor);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_partition_set_leader(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_partition_set_follower(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_partition_set_follower_wmarks(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int64_t lo, int64_t hi);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_set_down(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_set_up(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_set_rtt(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int rtt_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_set_rack(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, const char *rack);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_coordinator_set(rd_kafka_mock_cluster_t *mcluster, const char *key_type, const char *key, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_set_apiversion(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, int16_t MinVersion, int16_t MaxVersion);</span>
<span class="s1">&#39;</span>
</code></pre></div>
rdkafka.h, rdkafka_mock.h</p>
<h3 id="rd_kafka_version_12">RD_KAFKA_VERSION<a class="headerlink" href="#rd_kafka_version_12" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_VERSION</span> <span class="o">=</span> <span class="mi">17105919</span>
</code></pre></div>
<p>librdkafka version </p>
<p>Interpreted as hex <code>MM.mm.rr.xx</code>:</p>
<ul>
<li>MM = Major</li>
<li>mm = minor</li>
<li>rr = revision</li>
<li>xx = pre-release id (0xff is the final release)</li>
</ul>
<p>E.g.: <code>0x000801ff</code> = 0.8.1</p>
<dl class="section remark"><dt>Remarks</dt><dd>This value should only be used during compile time, for runtime checks of version use rd_kafka_version() </dd></dl>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_unsupported_compression_type_12">RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE<a class="headerlink" href="#rd_kafka_resp_err_unsupported_compression_type_12" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE</span> <span class="o">=</span> <span class="mi">76</span>
</code></pre></div>
<p>Unsupported compression type </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_end_all_12">RD_KAFKA_RESP_ERR_END_ALL<a class="headerlink" href="#rd_kafka_resp_err_end_all_12" title="Permanent link">&para;</a></h3>
<p><div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_END_ALL</span> <span class="o">=</span> <span class="mi">89</span>
</code></pre></div>
enum rd_kafka_resp_err_t</p>
<h3 id="rd_kafka_admin_op__cnt_12">RD_KAFKA_ADMIN_OP__CNT<a class="headerlink" href="#rd_kafka_admin_op__cnt_12" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_ADMIN_OP__CNT</span> <span class="o">=</span> <span class="mi">6</span>
</code></pre></div>
<p>Number of ops defined </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe </a></li>
</ul>
</div>
<h3 id="rd_kafka_resource__cnt_12">RD_KAFKA_RESOURCE__CNT<a class="headerlink" href="#rd_kafka_resource__cnt_12" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESOURCE__CNT</span> <span class="o">=</span> <span class="mi">5</span>
</code></pre></div>
<p>Number of resource types defined </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#acca83a66d7783ff7683ed2691cc907c9"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#acca83a66d7783ff7683ed2691cc907c9 </a></li>
</ul>
</div>
<h3 id="rd_kafka_cdef_12">RD_KAFKA_CDEF<a class="headerlink" href="#rd_kafka_cdef_12" title="Permanent link">&para;</a></h3>
<p><div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_CDEF</span> <span class="o">=</span> <span class="s1">&#39;typedef long int ssize_t;</span>
<span class="s1">typedef struct _IO_FILE FILE;</span>
<span class="s1">typedef long int mode_t;</span>
<span class="s1">typedef signed int int16_t;</span>
<span class="s1">typedef unsigned int uint16_t;</span>
<span class="s1">typedef signed int int32_t;</span>
<span class="s1">typedef signed long int int64_t;</span>
<span class="s1">int rd_kafka_version(void);</span>
<span class="s1">const char *rd_kafka_version_str(void);</span>
<span class="s1">typedef enum rd_kafka_type_t {</span>
<span class="s1">  RD_KAFKA_PRODUCER,</span>
<span class="s1">  RD_KAFKA_CONSUMER,</span>
<span class="s1">} rd_kafka_type_t;</span>
<span class="s1">typedef enum rd_kafka_timestamp_type_t {</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_NOT_AVAILABLE,</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_CREATE_TIME,</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_LOG_APPEND_TIME,</span>
<span class="s1">} rd_kafka_timestamp_type_t;</span>
<span class="s1">const char *rd_kafka_get_debug_contexts(void);</span>
<span class="s1">typedef struct rd_kafka_s rd_kafka_t;</span>
<span class="s1">typedef struct rd_kafka_topic_s rd_kafka_topic_t;</span>
<span class="s1">typedef struct rd_kafka_conf_s rd_kafka_conf_t;</span>
<span class="s1">typedef struct rd_kafka_topic_conf_s rd_kafka_topic_conf_t;</span>
<span class="s1">typedef struct rd_kafka_queue_s rd_kafka_queue_t;</span>
<span class="s1">typedef struct rd_kafka_op_s rd_kafka_event_t;</span>
<span class="s1">typedef struct rd_kafka_topic_result_s rd_kafka_topic_result_t;</span>
<span class="s1">typedef struct rd_kafka_consumer_group_metadata_s rd_kafka_consumer_group_metadata_t;</span>
<span class="s1">typedef struct rd_kafka_error_s {</span>
<span class="s1">  unsigned int code;</span>
<span class="s1">  char *errstr;</span>
<span class="s1">  unsigned char fatal;</span>
<span class="s1">  unsigned char retriable;</span>
<span class="s1">  unsigned char txn_requires_abort;</span>
<span class="s1">} rd_kafka_error_t;</span>
<span class="s1">typedef struct rd_kafka_headers_s rd_kafka_headers_t;</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BEGIN = (- 200),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BAD_MSG = (- 199),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BAD_COMPRESSION = (- 198),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__DESTROY = (- 197),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FAIL = (- 196),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TRANSPORT = (- 195),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__CRIT_SYS_RESOURCE = (- 194),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__RESOLVE = (- 193),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__MSG_TIMED_OUT = (- 192),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PARTITION_EOF = (- 191),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION = (- 190),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FS = (- 189),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC = (- 188),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ALL_BROKERS_DOWN = (- 187),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INVALID_ARG = (- 186),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TIMED_OUT = (- 185),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__QUEUE_FULL = (- 184),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ISR_INSUFF = (- 183),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NODE_UPDATE = (- 182),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__SSL = (- 181),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__WAIT_COORD = (- 180),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_GROUP = (- 179),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__IN_PROGRESS = (- 178),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PREV_IN_PROGRESS = (- 177),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__EXISTING_SUBSCRIPTION = (- 176),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS = (- 175),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS = (- 174),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__CONFLICT = (- 173),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__STATE = (- 172),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_PROTOCOL = (- 171),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED = (- 170),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__AUTHENTICATION = (- 169),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NO_OFFSET = (- 168),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__OUTDATED = (- 167),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TIMED_OUT_QUEUE = (- 166),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNSUPPORTED_FEATURE = (- 165),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__WAIT_CACHE = (- 164),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INTR = (- 163),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__KEY_SERIALIZATION = (- 162),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__VALUE_SERIALIZATION = (- 161),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__KEY_DESERIALIZATION = (- 160),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__VALUE_DESERIALIZATION = (- 159),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PARTIAL = (- 158),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__READ_ONLY = (- 157),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOENT = (- 156),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNDERFLOW = (- 155),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INVALID_TYPE = (- 154),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__RETRY = (- 153),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PURGE_QUEUE = (- 152),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PURGE_INFLIGHT = (- 151),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FATAL = (- 150),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INCONSISTENT = (- 149),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__GAPLESS_GUARANTEE = (- 148),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__MAX_POLL_EXCEEDED = (- 147),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_BROKER = (- 146),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOT_CONFIGURED = (- 145),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FENCED = (- 144),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__APPLICATION = (- 143),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__END = (- 100),</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN = (- 1),</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NO_ERROR = 0,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_OUT_OF_RANGE = 1,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_MSG = 2,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART = 3,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_MSG_SIZE = 4,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE = 5,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_LEADER_FOR_PARTITION = 6,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REQUEST_TIMED_OUT = 7,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_BROKER_NOT_AVAILABLE = 8,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REPLICA_NOT_AVAILABLE = 9,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE = 10,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_STALE_CTRL_EPOCH = 11,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_METADATA_TOO_LARGE = 12,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NETWORK_EXCEPTION = 13,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_COORDINATOR_LOAD_IN_PROGRESS = 14,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_COORDINATOR_NOT_AVAILABLE = 15,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_COORDINATOR = 16,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_EXCEPTION = 17,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_RECORD_LIST_TOO_LARGE = 18,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS = 19,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS_AFTER_APPEND = 20,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REQUIRED_ACKS = 21,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ILLEGAL_GENERATION = 22,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INCONSISTENT_GROUP_PROTOCOL = 23,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_GROUP_ID = 24,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_MEMBER_ID = 25,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_SESSION_TIMEOUT = 26,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REBALANCE_IN_PROGRESS = 27,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_COMMIT_OFFSET_SIZE = 28,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_AUTHORIZATION_FAILED = 29,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_AUTHORIZATION_FAILED = 30,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_CLUSTER_AUTHORIZATION_FAILED = 31,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TIMESTAMP = 32,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_SASL_MECHANISM = 33,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ILLEGAL_SASL_STATE = 34,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_VERSION = 35,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_ALREADY_EXISTS = 36,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PARTITIONS = 37,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REPLICATION_FACTOR = 38,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REPLICA_ASSIGNMENT = 39,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_CONFIG = 40,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_CONTROLLER = 41,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REQUEST = 42,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_FOR_MESSAGE_FORMAT = 43,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_POLICY_VIOLATION = 44,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OUT_OF_ORDER_SEQUENCE_NUMBER = 45,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DUPLICATE_SEQUENCE_NUMBER = 46,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_EPOCH = 47,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TXN_STATE = 48,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_ID_MAPPING = 49,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TRANSACTION_TIMEOUT = 50,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_CONCURRENT_TRANSACTIONS = 51,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TRANSACTION_COORDINATOR_FENCED = 52,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TRANSACTIONAL_ID_AUTHORIZATION_FAILED = 53,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_SECURITY_DISABLED = 54,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OPERATION_NOT_ATTEMPTED = 55,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_KAFKA_STORAGE_ERROR = 56,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LOG_DIR_NOT_FOUND = 57,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_SASL_AUTHENTICATION_FAILED = 58,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_PRODUCER_ID = 59,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REASSIGNMENT_IN_PROGRESS = 60,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTH_DISABLED = 61,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_NOT_FOUND = 62,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_OWNER_MISMATCH = 63,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_REQUEST_NOT_ALLOWED = 64,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTHORIZATION_FAILED = 65,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_EXPIRED = 66,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRINCIPAL_TYPE = 67,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NON_EMPTY_GROUP = 68,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_ID_NOT_FOUND = 69,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FETCH_SESSION_ID_NOT_FOUND = 70,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_FETCH_SESSION_EPOCH = 71,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LISTENER_NOT_FOUND = 72,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_DELETION_DISABLED = 73,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FENCED_LEADER_EPOCH = 74,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_LEADER_EPOCH = 75,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_STALE_BROKER_EPOCH = 77,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_NOT_AVAILABLE = 78,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_MEMBER_ID_REQUIRED = 79,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_PREFERRED_LEADER_NOT_AVAILABLE = 80,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_MAX_SIZE_REACHED = 81,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FENCED_INSTANCE_ID = 82,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ELIGIBLE_LEADERS_NOT_AVAILABLE = 83,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ELECTION_NOT_NEEDED = 84,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NO_REASSIGNMENT_IN_PROGRESS = 85,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_SUBSCRIBED_TO_TOPIC = 86,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_RECORD = 87,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSTABLE_OFFSET_COMMIT = 88,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_END_ALL,</span>
<span class="s1">} rd_kafka_resp_err_t;</span>
<span class="s1">struct rd_kafka_err_desc {</span>
<span class="s1">  rd_kafka_resp_err_t code;</span>
<span class="s1">  char *name;</span>
<span class="s1">  char *desc;</span>
<span class="s1">};</span>
<span class="s1">void rd_kafka_get_err_descs(const struct rd_kafka_err_desc **errdescs, size_t *cntp);</span>
<span class="s1">const char *rd_kafka_err2str(rd_kafka_resp_err_t err);</span>
<span class="s1">const char *rd_kafka_err2name(rd_kafka_resp_err_t err);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_last_error(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_errno2err(int errnox);</span>
<span class="s1">int rd_kafka_errno(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_fatal_error(rd_kafka_t *rk, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_test_fatal_error(rd_kafka_t *rk, rd_kafka_resp_err_t err, const char *reason);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_error_code(const rd_kafka_error_t *error);</span>
<span class="s1">const char *rd_kafka_error_name(const rd_kafka_error_t *error);</span>
<span class="s1">const char *rd_kafka_error_string(const rd_kafka_error_t *error);</span>
<span class="s1">int rd_kafka_error_is_fatal(const rd_kafka_error_t *error);</span>
<span class="s1">int rd_kafka_error_is_retriable(const rd_kafka_error_t *error);</span>
<span class="s1">int rd_kafka_error_txn_requires_abort(const rd_kafka_error_t *error);</span>
<span class="s1">void rd_kafka_error_destroy(rd_kafka_error_t *error);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_error_new(rd_kafka_resp_err_t code, const char *fmt, ...);</span>
<span class="s1">typedef struct rd_kafka_topic_partition_s {</span>
<span class="s1">  char *topic;</span>
<span class="s1">  int32_t partition;</span>
<span class="s1">  int64_t offset;</span>
<span class="s1">  void *metadata;</span>
<span class="s1">  size_t metadata_size;</span>
<span class="s1">  void *opaque;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  void *_private;</span>
<span class="s1">} rd_kafka_topic_partition_t;</span>
<span class="s1">void rd_kafka_topic_partition_destroy(rd_kafka_topic_partition_t *rktpar);</span>
<span class="s1">typedef struct rd_kafka_topic_partition_list_s {</span>
<span class="s1">  int cnt;</span>
<span class="s1">  int size;</span>
<span class="s1">  rd_kafka_topic_partition_t *elems;</span>
<span class="s1">} rd_kafka_topic_partition_list_t;</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_new(int size);</span>
<span class="s1">void rd_kafka_topic_partition_list_destroy(rd_kafka_topic_partition_list_t *rkparlist);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_add(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">void rd_kafka_topic_partition_list_add_range(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t start, int32_t stop);</span>
<span class="s1">int rd_kafka_topic_partition_list_del(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">int rd_kafka_topic_partition_list_del_by_idx(rd_kafka_topic_partition_list_t *rktparlist, int idx);</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_copy(const rd_kafka_topic_partition_list_t *src);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_topic_partition_list_set_offset(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition, int64_t offset);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_find(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">void rd_kafka_topic_partition_list_sort(rd_kafka_topic_partition_list_t *rktparlist, int (*cmp)(const void *a, const void *b, void *cmp_opaque), void *cmp_opaque);</span>
<span class="s1">typedef enum rd_kafka_vtype_t {</span>
<span class="s1">  RD_KAFKA_VTYPE_END,</span>
<span class="s1">  RD_KAFKA_VTYPE_TOPIC,</span>
<span class="s1">  RD_KAFKA_VTYPE_RKT,</span>
<span class="s1">  RD_KAFKA_VTYPE_PARTITION,</span>
<span class="s1">  RD_KAFKA_VTYPE_VALUE,</span>
<span class="s1">  RD_KAFKA_VTYPE_KEY,</span>
<span class="s1">  RD_KAFKA_VTYPE_OPAQUE,</span>
<span class="s1">  RD_KAFKA_VTYPE_MSGFLAGS,</span>
<span class="s1">  RD_KAFKA_VTYPE_TIMESTAMP,</span>
<span class="s1">  RD_KAFKA_VTYPE_HEADER,</span>
<span class="s1">  RD_KAFKA_VTYPE_HEADERS,</span>
<span class="s1">} rd_kafka_vtype_t;</span>
<span class="s1">typedef struct rd_kafka_vu_s {</span>
<span class="s1">  rd_kafka_vtype_t vtype;</span>
<span class="s1">  union {</span>
<span class="s1">    char *cstr;</span>
<span class="s1">    rd_kafka_topic_t *rkt;</span>
<span class="s1">    int i;</span>
<span class="s1">    int32_t i32;</span>
<span class="s1">    int64_t i64;</span>
<span class="s1">    struct {</span>
<span class="s1">      void *ptr;</span>
<span class="s1">      size_t size;</span>
<span class="s1">    } mem;</span>
<span class="s1">    struct {</span>
<span class="s1">      char *name;</span>
<span class="s1">      void *val;</span>
<span class="s1">      ssize_t size;</span>
<span class="s1">    } header;</span>
<span class="s1">    rd_kafka_headers_t *headers;</span>
<span class="s1">    void *ptr;</span>
<span class="s1">    char _pad[64];</span>
<span class="s1">  } u;</span>
<span class="s1">} rd_kafka_vu_t;</span>
<span class="s1">rd_kafka_headers_t *rd_kafka_headers_new(size_t initial_count);</span>
<span class="s1">void rd_kafka_headers_destroy(rd_kafka_headers_t *hdrs);</span>
<span class="s1">rd_kafka_headers_t *rd_kafka_headers_copy(const rd_kafka_headers_t *src);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_add(rd_kafka_headers_t *hdrs, const char *name, ssize_t name_size, const void *value, ssize_t value_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_remove(rd_kafka_headers_t *hdrs, const char *name);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get_last(const rd_kafka_headers_t *hdrs, const char *name, const void **valuep, size_t *sizep);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get(const rd_kafka_headers_t *hdrs, size_t idx, const char *name, const void **valuep, size_t *sizep);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get_all(const rd_kafka_headers_t *hdrs, size_t idx, const char **namep, const void **valuep, size_t *sizep);</span>
<span class="s1">typedef struct rd_kafka_message_s {</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  rd_kafka_topic_t *rkt;</span>
<span class="s1">  int32_t partition;</span>
<span class="s1">  void *payload;</span>
<span class="s1">  size_t len;</span>
<span class="s1">  void *key;</span>
<span class="s1">  size_t key_len;</span>
<span class="s1">  int64_t offset;</span>
<span class="s1">  void *_private;</span>
<span class="s1">} rd_kafka_message_t;</span>
<span class="s1">void rd_kafka_message_destroy(rd_kafka_message_t *rkmessage);</span>
<span class="s1">const char *rd_kafka_message_errstr(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">int64_t rd_kafka_message_timestamp(const rd_kafka_message_t *rkmessage, rd_kafka_timestamp_type_t *tstype);</span>
<span class="s1">int64_t rd_kafka_message_latency(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">int32_t rd_kafka_message_broker_id(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_message_headers(const rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_message_detach_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);</span>
<span class="s1">void rd_kafka_message_set_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t *hdrs);</span>
<span class="s1">size_t rd_kafka_header_cnt(const rd_kafka_headers_t *hdrs);</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_NOT_PERSISTED = 0,</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_POSSIBLY_PERSISTED = 1,</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_PERSISTED = 2,</span>
<span class="s1">} rd_kafka_msg_status_t;</span>
<span class="s1">rd_kafka_msg_status_t rd_kafka_message_status(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_CONF_UNKNOWN = (- 2),</span>
<span class="s1">  RD_KAFKA_CONF_INVALID = (- 1),</span>
<span class="s1">  RD_KAFKA_CONF_OK = 0,</span>
<span class="s1">} rd_kafka_conf_res_t;</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_new(void);</span>
<span class="s1">void rd_kafka_conf_destroy(rd_kafka_conf_t *conf);</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_dup(const rd_kafka_conf_t *conf);</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_dup_filter(const rd_kafka_conf_t *conf, size_t filter_cnt, const char **filter);</span>
<span class="s1">const rd_kafka_conf_t *rd_kafka_conf(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_set(rd_kafka_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_conf_set_events(rd_kafka_conf_t *conf, int events);</span>
<span class="s1">void rd_kafka_conf_set_background_event_cb(rd_kafka_conf_t *conf, void (*event_cb)(rd_kafka_t *rk, rd_kafka_event_t *rkev, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_dr_cb(rd_kafka_conf_t *conf, void (*dr_cb)(rd_kafka_t *rk, void *payload, size_t len, rd_kafka_resp_err_t err, void *opaque, void *msg_opaque));</span>
<span class="s1">void rd_kafka_conf_set_dr_msg_cb(rd_kafka_conf_t *conf, void (*dr_msg_cb)(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_consume_cb(rd_kafka_conf_t *conf, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_rebalance_cb(rd_kafka_conf_t *conf, void (*rebalance_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *partitions, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_offset_commit_cb(rd_kafka_conf_t *conf, void (*offset_commit_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_error_cb(rd_kafka_conf_t *conf, void (*error_cb)(rd_kafka_t *rk, int err, const char *reason, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_throttle_cb(rd_kafka_conf_t *conf, void (*throttle_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int throttle_time_ms, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_log_cb(rd_kafka_conf_t *conf, void (*log_cb)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));</span>
<span class="s1">void rd_kafka_conf_set_stats_cb(rd_kafka_conf_t *conf, int (*stats_cb)(rd_kafka_t *rk, char *json, size_t json_len, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_oauthbearer_token_refresh_cb(rd_kafka_conf_t *conf, void (*oauthbearer_token_refresh_cb)(rd_kafka_t *rk, const char *oauthbearer_config, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_socket_cb(rd_kafka_conf_t *conf, int (*socket_cb)(int domain, int type, int protocol, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_connect_cb(rd_kafka_conf_t *conf, int (*connect_cb)(int sockfd, const struct sockaddr *addr, int addrlen, const char *id, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_closesocket_cb(rd_kafka_conf_t *conf, int (*closesocket_cb)(int sockfd, void *opaque));</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert_verify_cb(rd_kafka_conf_t *conf, int (*ssl_cert_verify_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int *x509_error, int depth, const char *buf, size_t size, char *errstr, size_t errstr_size, void *opaque));</span>
<span class="s1">typedef enum rd_kafka_cert_type_t {</span>
<span class="s1">  RD_KAFKA_CERT_PUBLIC_KEY,</span>
<span class="s1">  RD_KAFKA_CERT_PRIVATE_KEY,</span>
<span class="s1">  RD_KAFKA_CERT_CA,</span>
<span class="s1">  RD_KAFKA_CERT__CNT,</span>
<span class="s1">} rd_kafka_cert_type_t;</span>
<span class="s1">typedef enum rd_kafka_cert_enc_t {</span>
<span class="s1">  RD_KAFKA_CERT_ENC_PKCS12,</span>
<span class="s1">  RD_KAFKA_CERT_ENC_DER,</span>
<span class="s1">  RD_KAFKA_CERT_ENC_PEM,</span>
<span class="s1">  RD_KAFKA_CERT_ENC__CNT,</span>
<span class="s1">} rd_kafka_cert_enc_t;</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert(rd_kafka_conf_t *conf, rd_kafka_cert_type_t cert_type, rd_kafka_cert_enc_t cert_enc, const void *buffer, size_t size, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_conf_set_opaque(rd_kafka_conf_t *conf, void *opaque);</span>
<span class="s1">void *rd_kafka_opaque(const rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_conf_set_default_topic_conf(rd_kafka_conf_t *conf, rd_kafka_topic_conf_t *tconf);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_get(const rd_kafka_conf_t *conf, const char *name, char *dest, size_t *dest_size);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_topic_conf_get(const rd_kafka_topic_conf_t *conf, const char *name, char *dest, size_t *dest_size);</span>
<span class="s1">const char **rd_kafka_conf_dump(rd_kafka_conf_t *conf, size_t *cntp);</span>
<span class="s1">const char **rd_kafka_topic_conf_dump(rd_kafka_topic_conf_t *conf, size_t *cntp);</span>
<span class="s1">void rd_kafka_conf_dump_free(const char **arr, size_t cnt);</span>
<span class="s1">void rd_kafka_conf_properties_show(FILE *fp);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_topic_conf_new(void);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_topic_conf_dup(const rd_kafka_topic_conf_t *conf);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_default_topic_conf_dup(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_topic_conf_destroy(rd_kafka_topic_conf_t *topic_conf);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_topic_conf_set(rd_kafka_topic_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_topic_conf_set_opaque(rd_kafka_topic_conf_t *conf, void *rkt_opaque);</span>
<span class="s1">void rd_kafka_topic_conf_set_partitioner_cb(rd_kafka_topic_conf_t *topic_conf, int32_t (*partitioner)(const rd_kafka_topic_t *rkt, const void *keydata, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque));</span>
<span class="s1">void rd_kafka_topic_conf_set_msg_order_cmp(rd_kafka_topic_conf_t *topic_conf, int (*msg_order_cmp)(const rd_kafka_message_t *a, const rd_kafka_message_t *b));</span>
<span class="s1">int rd_kafka_topic_partition_available(const rd_kafka_topic_t *rkt, int32_t partition);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_consistent(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_consistent_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_murmur2(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_murmur2_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_fnv1a(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_fnv1a_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">rd_kafka_t *rd_kafka_new(rd_kafka_type_t type, rd_kafka_conf_t *conf, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_destroy(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_destroy_flags(rd_kafka_t *rk, int flags);</span>
<span class="s1">const char *rd_kafka_name(const rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_type_t rd_kafka_type(const rd_kafka_t *rk);</span>
<span class="s1">char *rd_kafka_memberid(const rd_kafka_t *rk);</span>
<span class="s1">char *rd_kafka_clusterid(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">int32_t rd_kafka_controllerid(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_topic_t *rd_kafka_topic_new(rd_kafka_t *rk, const char *topic, rd_kafka_topic_conf_t *conf);</span>
<span class="s1">void rd_kafka_topic_destroy(rd_kafka_topic_t *rkt);</span>
<span class="s1">const char *rd_kafka_topic_name(const rd_kafka_topic_t *rkt);</span>
<span class="s1">void *rd_kafka_topic_opaque(const rd_kafka_topic_t *rkt);</span>
<span class="s1">int rd_kafka_poll(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">void rd_kafka_yield(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_pause_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_resume_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_query_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_get_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offsets_for_times(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets, int timeout_ms);</span>
<span class="s1">void rd_kafka_mem_free(rd_kafka_t *rk, void *ptr);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_new(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_queue_destroy(rd_kafka_queue_t *rkqu);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_main(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_consumer(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_partition(rd_kafka_t *rk, const char *topic, int32_t partition);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_background(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_queue_forward(rd_kafka_queue_t *src, rd_kafka_queue_t *dst);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_set_log_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu);</span>
<span class="s1">size_t rd_kafka_queue_length(rd_kafka_queue_t *rkqu);</span>
<span class="s1">void rd_kafka_queue_io_event_enable(rd_kafka_queue_t *rkqu, int fd, const void *payload, size_t size);</span>
<span class="s1">void rd_kafka_queue_cb_event_enable(rd_kafka_queue_t *rkqu, void (*event_cb)(rd_kafka_t *rk, void *qev_opaque), void *qev_opaque);</span>
<span class="s1">int rd_kafka_consume_start(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);</span>
<span class="s1">int rd_kafka_consume_start_queue(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, rd_kafka_queue_t *rkqu);</span>
<span class="s1">int rd_kafka_consume_stop(rd_kafka_topic_t *rkt, int32_t partition);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_seek(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, int timeout_ms);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consume(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms);</span>
<span class="s1">ssize_t rd_kafka_consume_batch(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);</span>
<span class="s1">int rd_kafka_consume_callback(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consume_queue(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">ssize_t rd_kafka_consume_batch_queue(rd_kafka_queue_t *rkqu, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);</span>
<span class="s1">int rd_kafka_consume_callback_queue(rd_kafka_queue_t *rkqu, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offset_store(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offsets_store(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_subscribe(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *topics);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_unsubscribe(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_subscription(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **topics);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consumer_poll(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_consumer_close(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_assignment(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, int async);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit_message(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, int async);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit_queue(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_queue_t *rkqu, void (*cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *commit_opaque), void *commit_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_committed(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_position(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata_new(const char *group_id);</span>
<span class="s1">void rd_kafka_consumer_group_metadata_destroy(rd_kafka_consumer_group_metadata_t *);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_consumer_group_metadata_write(const rd_kafka_consumer_group_metadata_t *cgmd, void **bufferp, size_t *sizep);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_consumer_group_metadata_read(rd_kafka_consumer_group_metadata_t **cgmdp, const void *buffer, size_t size);</span>
<span class="s1">int rd_kafka_produce(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, void *payload, size_t len, const void *key, size_t keylen, void *msg_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_producev(rd_kafka_t *rk, ...);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_produceva(rd_kafka_t *rk, const rd_kafka_vu_t *vus, size_t cnt);</span>
<span class="s1">int rd_kafka_produce_batch(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, rd_kafka_message_t *rkmessages, int message_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_flush(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_purge(rd_kafka_t *rk, int purge_flags);</span>
<span class="s1">typedef struct rd_kafka_metadata_broker {</span>
<span class="s1">  int32_t id;</span>
<span class="s1">  char *host;</span>
<span class="s1">  int port;</span>
<span class="s1">} rd_kafka_metadata_broker_t;</span>
<span class="s1">typedef struct rd_kafka_metadata_partition {</span>
<span class="s1">  int32_t id;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  int32_t leader;</span>
<span class="s1">  int replica_cnt;</span>
<span class="s1">  int32_t *replicas;</span>
<span class="s1">  int isr_cnt;</span>
<span class="s1">  int32_t *isrs;</span>
<span class="s1">} rd_kafka_metadata_partition_t;</span>
<span class="s1">typedef struct rd_kafka_metadata_topic {</span>
<span class="s1">  char *topic;</span>
<span class="s1">  int partition_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_partition *partitions;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">} rd_kafka_metadata_topic_t;</span>
<span class="s1">typedef struct rd_kafka_metadata {</span>
<span class="s1">  int broker_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_broker *brokers;</span>
<span class="s1">  int topic_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_topic *topics;</span>
<span class="s1">  int32_t orig_broker_id;</span>
<span class="s1">  char *orig_broker_name;</span>
<span class="s1">} rd_kafka_metadata_t;</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_metadata(rd_kafka_t *rk, int all_topics, rd_kafka_topic_t *only_rkt, const struct rd_kafka_metadata **metadatap, int timeout_ms);</span>
<span class="s1">void rd_kafka_metadata_destroy(const struct rd_kafka_metadata *metadata);</span>
<span class="s1">struct rd_kafka_group_member_info {</span>
<span class="s1">  char *member_id;</span>
<span class="s1">  char *client_id;</span>
<span class="s1">  char *client_host;</span>
<span class="s1">  void *member_metadata;</span>
<span class="s1">  int member_metadata_size;</span>
<span class="s1">  void *member_assignment;</span>
<span class="s1">  int member_assignment_size;</span>
<span class="s1">};</span>
<span class="s1">struct rd_kafka_group_info {</span>
<span class="s1">  struct rd_kafka_metadata_broker broker;</span>
<span class="s1">  char *group;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  char *state;</span>
<span class="s1">  char *protocol_type;</span>
<span class="s1">  char *protocol;</span>
<span class="s1">  struct rd_kafka_group_member_info *members;</span>
<span class="s1">  int member_cnt;</span>
<span class="s1">};</span>
<span class="s1">struct rd_kafka_group_list {</span>
<span class="s1">  struct rd_kafka_group_info *groups;</span>
<span class="s1">  int group_cnt;</span>
<span class="s1">};</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_list_groups(rd_kafka_t *rk, const char *group, const struct rd_kafka_group_list **grplistp, int timeout_ms);</span>
<span class="s1">void rd_kafka_group_list_destroy(const struct rd_kafka_group_list *grplist);</span>
<span class="s1">int rd_kafka_brokers_add(rd_kafka_t *rk, const char *brokerlist);</span>
<span class="s1">void rd_kafka_set_logger(rd_kafka_t *rk, void (*func)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));</span>
<span class="s1">void rd_kafka_set_log_level(rd_kafka_t *rk, int level);</span>
<span class="s1">void rd_kafka_log_print(const rd_kafka_t *rk, int level, const char *fac, const char *buf);</span>
<span class="s1">void rd_kafka_log_syslog(const rd_kafka_t *rk, int level, const char *fac, const char *buf);</span>
<span class="s1">int rd_kafka_outq_len(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_dump(FILE *fp, rd_kafka_t *rk);</span>
<span class="s1">int rd_kafka_thread_cnt(void);</span>
<span class="s1">typedef enum rd_kafka_thread_type_t {</span>
<span class="s1">  RD_KAFKA_THREAD_MAIN,</span>
<span class="s1">  RD_KAFKA_THREAD_BACKGROUND,</span>
<span class="s1">  RD_KAFKA_THREAD_BROKER,</span>
<span class="s1">} rd_kafka_thread_type_t;</span>
<span class="s1">int rd_kafka_wait_destroyed(int timeout_ms);</span>
<span class="s1">int rd_kafka_unittest(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_poll_set_consumer(rd_kafka_t *rk);</span>
<span class="s1">typedef int rd_kafka_event_type_t;</span>
<span class="s1">rd_kafka_event_type_t rd_kafka_event_type(const rd_kafka_event_t *rkev);</span>
<span class="s1">const char *rd_kafka_event_name(const rd_kafka_event_t *rkev);</span>
<span class="s1">void rd_kafka_event_destroy(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_message_t *rd_kafka_event_message_next(rd_kafka_event_t *rkev);</span>
<span class="s1">size_t rd_kafka_event_message_array(rd_kafka_event_t *rkev, const rd_kafka_message_t **rkmessages, size_t size);</span>
<span class="s1">size_t rd_kafka_event_message_count(rd_kafka_event_t *rkev);</span>
<span class="s1">const char *rd_kafka_event_config_string(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_event_error(rd_kafka_event_t *rkev);</span>
<span class="s1">const char *rd_kafka_event_error_string(rd_kafka_event_t *rkev);</span>
<span class="s1">int rd_kafka_event_error_is_fatal(rd_kafka_event_t *rkev);</span>
<span class="s1">void *rd_kafka_event_opaque(rd_kafka_event_t *rkev);</span>
<span class="s1">int rd_kafka_event_log(rd_kafka_event_t *rkev, const char **fac, const char **str, int *level);</span>
<span class="s1">int rd_kafka_event_debug_contexts(rd_kafka_event_t *rkev, char *dst, size_t dstsize);</span>
<span class="s1">const char *rd_kafka_event_stats(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_event_topic_partition_list(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_event_topic_partition(rd_kafka_event_t *rkev);</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_CreateTopics_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DeleteTopics_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_CreatePartitions_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_AlterConfigs_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DescribeConfigs_result_t;</span>
<span class="s1">const rd_kafka_CreateTopics_result_t *rd_kafka_event_CreateTopics_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DeleteTopics_result_t *rd_kafka_event_DeleteTopics_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_CreatePartitions_result_t *rd_kafka_event_CreatePartitions_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_AlterConfigs_result_t *rd_kafka_event_AlterConfigs_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DescribeConfigs_result_t *rd_kafka_event_DescribeConfigs_result(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_event_t *rd_kafka_queue_poll(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">int rd_kafka_queue_poll_callback(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_plugin_f_conf_init_t)(rd_kafka_conf_t *conf, void **plug_opaquep, char *errstr, size_t errstr_size);</span>
<span class="s1">typedef rd_kafka_conf_res_t (rd_kafka_interceptor_f_on_conf_set_t)(rd_kafka_conf_t *conf, const char *name, const char *val, char *errstr, size_t errstr_size, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_dup_t)(rd_kafka_conf_t *new_conf, const rd_kafka_conf_t *old_conf, size_t filter_cnt, const char **filter, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_destroy_t)(void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_new_t)(rd_kafka_t *rk, const rd_kafka_conf_t *conf, void *ic_opaque, char *errstr, size_t errstr_size);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_destroy_t)(rd_kafka_t *rk, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_send_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_acknowledgement_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_consume_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_commit_t)(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_resp_err_t err, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_request_sent_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_start_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_exit_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_set(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_set_t *on_conf_set, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_dup(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_dup_t *on_conf_dup, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_destroy(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_destroy_t *on_conf_destroy, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_new(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_new_t *on_new, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_destroy(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_destroy_t *on_destroy, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_send(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_send_t *on_send, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_acknowledgement(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_acknowledgement_t *on_acknowledgement, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_consume(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_consume_t *on_consume, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_commit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_commit_t *on_commit, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_request_sent(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_request_sent_t *on_request_sent, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_start(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_start_t *on_thread_start, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_exit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_exit_t *on_thread_exit, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_topic_result_error(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">const char *rd_kafka_topic_result_error_string(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">const char *rd_kafka_topic_result_name(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">typedef enum rd_kafka_admin_op_t {</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_ANY = 0,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_CREATETOPICS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DELETETOPICS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_CREATEPARTITIONS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_ALTERCONFIGS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DESCRIBECONFIGS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP__CNT,</span>
<span class="s1">} rd_kafka_admin_op_t;</span>
<span class="s1">typedef struct rd_kafka_AdminOptions_s rd_kafka_AdminOptions_t;</span>
<span class="s1">rd_kafka_AdminOptions_t *rd_kafka_AdminOptions_new(rd_kafka_t *rk, rd_kafka_admin_op_t for_api);</span>
<span class="s1">void rd_kafka_AdminOptions_destroy(rd_kafka_AdminOptions_t *options);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_request_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_operation_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_validate_only(rd_kafka_AdminOptions_t *options, int true_or_false, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_broker(rd_kafka_AdminOptions_t *options, int32_t broker_id, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_AdminOptions_set_opaque(rd_kafka_AdminOptions_t *options, void *ev_opaque);</span>
<span class="s1">typedef struct rd_kafka_NewTopic_s rd_kafka_NewTopic_t;</span>
<span class="s1">rd_kafka_NewTopic_t *rd_kafka_NewTopic_new(const char *topic, int num_partitions, int replication_factor, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_NewTopic_destroy(rd_kafka_NewTopic_t *new_topic);</span>
<span class="s1">void rd_kafka_NewTopic_destroy_array(rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewTopic_set_replica_assignment(rd_kafka_NewTopic_t *new_topic, int32_t partition, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewTopic_set_config(rd_kafka_NewTopic_t *new_topic, const char *name, const char *value);</span>
<span class="s1">void rd_kafka_CreateTopics(rd_kafka_t *rk, rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_CreateTopics_result_topics(const rd_kafka_CreateTopics_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_DeleteTopic_s rd_kafka_DeleteTopic_t;</span>
<span class="s1">rd_kafka_DeleteTopic_t *rd_kafka_DeleteTopic_new(const char *topic);</span>
<span class="s1">void rd_kafka_DeleteTopic_destroy(rd_kafka_DeleteTopic_t *del_topic);</span>
<span class="s1">void rd_kafka_DeleteTopic_destroy_array(rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt);</span>
<span class="s1">void rd_kafka_DeleteTopics(rd_kafka_t *rk, rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_DeleteTopics_result_topics(const rd_kafka_DeleteTopics_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_NewPartitions_s rd_kafka_NewPartitions_t;</span>
<span class="s1">rd_kafka_NewPartitions_t *rd_kafka_NewPartitions_new(const char *topic, size_t new_total_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_NewPartitions_destroy(rd_kafka_NewPartitions_t *new_parts);</span>
<span class="s1">void rd_kafka_NewPartitions_destroy_array(rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewPartitions_set_replica_assignment(rd_kafka_NewPartitions_t *new_parts, int32_t new_partition_idx, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_CreatePartitions(rd_kafka_t *rk, rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_CreatePartitions_result_topics(const rd_kafka_CreatePartitions_result_t *result, size_t *cntp);</span>
<span class="s1">typedef enum rd_kafka_ConfigSource_t {</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_UNKNOWN_CONFIG = 0,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_TOPIC_CONFIG = 1,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_BROKER_CONFIG = 2,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_DEFAULT_BROKER_CONFIG = 3,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_STATIC_BROKER_CONFIG = 4,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DEFAULT_CONFIG = 5,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE__CNT,</span>
<span class="s1">} rd_kafka_ConfigSource_t;</span>
<span class="s1">const char *rd_kafka_ConfigSource_name(rd_kafka_ConfigSource_t confsource);</span>
<span class="s1">typedef struct rd_kafka_ConfigEntry_s rd_kafka_ConfigEntry_t;</span>
<span class="s1">const char *rd_kafka_ConfigEntry_name(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">const char *rd_kafka_ConfigEntry_value(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">rd_kafka_ConfigSource_t rd_kafka_ConfigEntry_source(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_read_only(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_default(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_sensitive(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_synonym(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">const rd_kafka_ConfigEntry_t **rd_kafka_ConfigEntry_synonyms(const rd_kafka_ConfigEntry_t *entry, size_t *cntp);</span>
<span class="s1">typedef enum rd_kafka_ResourceType_t {</span>
<span class="s1">  RD_KAFKA_RESOURCE_UNKNOWN = 0,</span>
<span class="s1">  RD_KAFKA_RESOURCE_ANY = 1,</span>
<span class="s1">  RD_KAFKA_RESOURCE_TOPIC = 2,</span>
<span class="s1">  RD_KAFKA_RESOURCE_GROUP = 3,</span>
<span class="s1">  RD_KAFKA_RESOURCE_BROKER = 4,</span>
<span class="s1">  RD_KAFKA_RESOURCE__CNT,</span>
<span class="s1">} rd_kafka_ResourceType_t;</span>
<span class="s1">const char *rd_kafka_ResourceType_name(rd_kafka_ResourceType_t restype);</span>
<span class="s1">typedef struct rd_kafka_ConfigResource_s rd_kafka_ConfigResource_t;</span>
<span class="s1">rd_kafka_ConfigResource_t *rd_kafka_ConfigResource_new(rd_kafka_ResourceType_t restype, const char *resname);</span>
<span class="s1">void rd_kafka_ConfigResource_destroy(rd_kafka_ConfigResource_t *config);</span>
<span class="s1">void rd_kafka_ConfigResource_destroy_array(rd_kafka_ConfigResource_t **config, size_t config_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_ConfigResource_set_config(rd_kafka_ConfigResource_t *config, const char *name, const char *value);</span>
<span class="s1">const rd_kafka_ConfigEntry_t **rd_kafka_ConfigResource_configs(const rd_kafka_ConfigResource_t *config, size_t *cntp);</span>
<span class="s1">rd_kafka_ResourceType_t rd_kafka_ConfigResource_type(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">const char *rd_kafka_ConfigResource_name(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_ConfigResource_error(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">const char *rd_kafka_ConfigResource_error_string(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">void rd_kafka_AlterConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_ConfigResource_t **rd_kafka_AlterConfigs_result_resources(const rd_kafka_AlterConfigs_result_t *result, size_t *cntp);</span>
<span class="s1">void rd_kafka_DescribeConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_ConfigResource_t **rd_kafka_DescribeConfigs_result_resources(const rd_kafka_DescribeConfigs_result_t *result, size_t *cntp);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token(rd_kafka_t *rk, const char *token_value, int64_t md_lifetime_ms, const char *md_principal_name, const char **extensions, size_t extension_size, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token_failure(rd_kafka_t *rk, const char *errstr);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_init_transactions(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_begin_transaction(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_send_offsets_to_transaction(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, const rd_kafka_consumer_group_metadata_t *cgmetadata, int timeout_ms);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_commit_transaction(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_abort_transaction(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">typedef struct rd_kafka_mock_cluster_s rd_kafka_mock_cluster_t;</span>
<span class="s1">rd_kafka_mock_cluster_t *rd_kafka_mock_cluster_new(rd_kafka_t *rk, int broker_cnt);</span>
<span class="s1">void rd_kafka_mock_cluster_destroy(rd_kafka_mock_cluster_t *mcluster);</span>
<span class="s1">rd_kafka_t *rd_kafka_mock_cluster_handle(const rd_kafka_mock_cluster_t *mcluster);</span>
<span class="s1">rd_kafka_mock_cluster_t *rd_kafka_handle_mock_cluster(const rd_kafka_t *rk);</span>
<span class="s1">const char *rd_kafka_mock_cluster_bootstraps(const rd_kafka_mock_cluster_t *mcluster);</span>
<span class="s1">void rd_kafka_mock_push_request_errors(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, size_t cnt, ...);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_push_request_errors(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int16_t ApiKey, size_t cnt, ...);</span>
<span class="s1">void rd_kafka_mock_topic_set_error(rd_kafka_mock_cluster_t *mcluster, const char *topic, rd_kafka_resp_err_t err);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_topic_create(rd_kafka_mock_cluster_t *mcluster, const char *topic, int partition_cnt, int replication_factor);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_partition_set_leader(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_partition_set_follower(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_partition_set_follower_wmarks(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int64_t lo, int64_t hi);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_set_down(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_set_up(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_set_rtt(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int rtt_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_set_rack(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, const char *rack);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_coordinator_set(rd_kafka_mock_cluster_t *mcluster, const char *key_type, const char *key, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_set_apiversion(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, int16_t MinVersion, int16_t MaxVersion);</span>
<span class="s1">&#39;</span>
</code></pre></div>
rdkafka.h, rdkafka_mock.h</p>
<h3 id="rd_kafka_version_13">RD_KAFKA_VERSION<a class="headerlink" href="#rd_kafka_version_13" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_VERSION</span> <span class="o">=</span> <span class="mi">17170687</span>
</code></pre></div>
<p>librdkafka version </p>
<p>Interpreted as hex <code>MM.mm.rr.xx</code>:</p>
<ul>
<li>MM = Major</li>
<li>mm = minor</li>
<li>rr = revision</li>
<li>xx = pre-release id (0xff is the final release)</li>
</ul>
<p>E.g.: <code>0x000801ff</code> = 0.8.1</p>
<dl class="section remark"><dt>Remarks</dt><dd>This value should only be used during compile time, for runtime checks of version use rd_kafka_version() </dd></dl>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_unsupported_compression_type_13">RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE<a class="headerlink" href="#rd_kafka_resp_err_unsupported_compression_type_13" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE</span> <span class="o">=</span> <span class="mi">76</span>
</code></pre></div>
<p>Unsupported compression type </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_end_all_13">RD_KAFKA_RESP_ERR_END_ALL<a class="headerlink" href="#rd_kafka_resp_err_end_all_13" title="Permanent link">&para;</a></h3>
<p><div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_END_ALL</span> <span class="o">=</span> <span class="mi">98</span>
</code></pre></div>
enum rd_kafka_resp_err_t</p>
<h3 id="rd_kafka_admin_op__cnt_13">RD_KAFKA_ADMIN_OP__CNT<a class="headerlink" href="#rd_kafka_admin_op__cnt_13" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_ADMIN_OP__CNT</span> <span class="o">=</span> <span class="mi">9</span>
</code></pre></div>
<p>Number of ops defined </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe </a></li>
</ul>
</div>
<h3 id="rd_kafka_resource__cnt_13">RD_KAFKA_RESOURCE__CNT<a class="headerlink" href="#rd_kafka_resource__cnt_13" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESOURCE__CNT</span> <span class="o">=</span> <span class="mi">5</span>
</code></pre></div>
<p>Number of resource types defined </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#acca83a66d7783ff7683ed2691cc907c9"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#acca83a66d7783ff7683ed2691cc907c9 </a></li>
</ul>
</div>
<h3 id="rd_kafka_cdef_13">RD_KAFKA_CDEF<a class="headerlink" href="#rd_kafka_cdef_13" title="Permanent link">&para;</a></h3>
<p><div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_CDEF</span> <span class="o">=</span> <span class="s1">&#39;typedef long int ssize_t;</span>
<span class="s1">typedef struct _IO_FILE FILE;</span>
<span class="s1">typedef long int mode_t;</span>
<span class="s1">typedef signed int int16_t;</span>
<span class="s1">typedef unsigned int uint16_t;</span>
<span class="s1">typedef signed int int32_t;</span>
<span class="s1">typedef signed long int int64_t;</span>
<span class="s1">int rd_kafka_version(void);</span>
<span class="s1">const char *rd_kafka_version_str(void);</span>
<span class="s1">typedef enum rd_kafka_type_t {</span>
<span class="s1">  RD_KAFKA_PRODUCER,</span>
<span class="s1">  RD_KAFKA_CONSUMER,</span>
<span class="s1">} rd_kafka_type_t;</span>
<span class="s1">typedef enum rd_kafka_timestamp_type_t {</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_NOT_AVAILABLE,</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_CREATE_TIME,</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_LOG_APPEND_TIME,</span>
<span class="s1">} rd_kafka_timestamp_type_t;</span>
<span class="s1">const char *rd_kafka_get_debug_contexts(void);</span>
<span class="s1">typedef struct rd_kafka_s rd_kafka_t;</span>
<span class="s1">typedef struct rd_kafka_topic_s rd_kafka_topic_t;</span>
<span class="s1">typedef struct rd_kafka_conf_s rd_kafka_conf_t;</span>
<span class="s1">typedef struct rd_kafka_topic_conf_s rd_kafka_topic_conf_t;</span>
<span class="s1">typedef struct rd_kafka_queue_s rd_kafka_queue_t;</span>
<span class="s1">typedef struct rd_kafka_op_s rd_kafka_event_t;</span>
<span class="s1">typedef struct rd_kafka_topic_result_s rd_kafka_topic_result_t;</span>
<span class="s1">typedef struct rd_kafka_consumer_group_metadata_s rd_kafka_consumer_group_metadata_t;</span>
<span class="s1">typedef struct rd_kafka_error_s {</span>
<span class="s1">  unsigned int code;</span>
<span class="s1">  char *errstr;</span>
<span class="s1">  unsigned char fatal;</span>
<span class="s1">  unsigned char retriable;</span>
<span class="s1">  unsigned char txn_requires_abort;</span>
<span class="s1">} rd_kafka_error_t;</span>
<span class="s1">typedef struct rd_kafka_headers_s rd_kafka_headers_t;</span>
<span class="s1">typedef struct rd_kafka_group_result_s rd_kafka_group_result_t;</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BEGIN = (- 200),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BAD_MSG = (- 199),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BAD_COMPRESSION = (- 198),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__DESTROY = (- 197),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FAIL = (- 196),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TRANSPORT = (- 195),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__CRIT_SYS_RESOURCE = (- 194),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__RESOLVE = (- 193),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__MSG_TIMED_OUT = (- 192),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PARTITION_EOF = (- 191),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION = (- 190),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FS = (- 189),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC = (- 188),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ALL_BROKERS_DOWN = (- 187),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INVALID_ARG = (- 186),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TIMED_OUT = (- 185),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__QUEUE_FULL = (- 184),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ISR_INSUFF = (- 183),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NODE_UPDATE = (- 182),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__SSL = (- 181),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__WAIT_COORD = (- 180),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_GROUP = (- 179),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__IN_PROGRESS = (- 178),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PREV_IN_PROGRESS = (- 177),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__EXISTING_SUBSCRIPTION = (- 176),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS = (- 175),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS = (- 174),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__CONFLICT = (- 173),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__STATE = (- 172),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_PROTOCOL = (- 171),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED = (- 170),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__AUTHENTICATION = (- 169),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NO_OFFSET = (- 168),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__OUTDATED = (- 167),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TIMED_OUT_QUEUE = (- 166),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNSUPPORTED_FEATURE = (- 165),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__WAIT_CACHE = (- 164),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INTR = (- 163),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__KEY_SERIALIZATION = (- 162),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__VALUE_SERIALIZATION = (- 161),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__KEY_DESERIALIZATION = (- 160),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__VALUE_DESERIALIZATION = (- 159),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PARTIAL = (- 158),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__READ_ONLY = (- 157),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOENT = (- 156),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNDERFLOW = (- 155),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INVALID_TYPE = (- 154),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__RETRY = (- 153),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PURGE_QUEUE = (- 152),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PURGE_INFLIGHT = (- 151),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FATAL = (- 150),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INCONSISTENT = (- 149),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__GAPLESS_GUARANTEE = (- 148),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__MAX_POLL_EXCEEDED = (- 147),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_BROKER = (- 146),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOT_CONFIGURED = (- 145),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FENCED = (- 144),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__APPLICATION = (- 143),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ASSIGNMENT_LOST = (- 142),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOOP = (- 141),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__END = (- 100),</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN = (- 1),</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NO_ERROR = 0,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_OUT_OF_RANGE = 1,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_MSG = 2,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART = 3,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_MSG_SIZE = 4,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE = 5,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_LEADER_FOR_PARTITION = 6,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REQUEST_TIMED_OUT = 7,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_BROKER_NOT_AVAILABLE = 8,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REPLICA_NOT_AVAILABLE = 9,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE = 10,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_STALE_CTRL_EPOCH = 11,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_METADATA_TOO_LARGE = 12,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NETWORK_EXCEPTION = 13,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_COORDINATOR_LOAD_IN_PROGRESS = 14,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_COORDINATOR_NOT_AVAILABLE = 15,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_COORDINATOR = 16,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_EXCEPTION = 17,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_RECORD_LIST_TOO_LARGE = 18,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS = 19,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS_AFTER_APPEND = 20,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REQUIRED_ACKS = 21,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ILLEGAL_GENERATION = 22,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INCONSISTENT_GROUP_PROTOCOL = 23,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_GROUP_ID = 24,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_MEMBER_ID = 25,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_SESSION_TIMEOUT = 26,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REBALANCE_IN_PROGRESS = 27,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_COMMIT_OFFSET_SIZE = 28,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_AUTHORIZATION_FAILED = 29,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_AUTHORIZATION_FAILED = 30,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_CLUSTER_AUTHORIZATION_FAILED = 31,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TIMESTAMP = 32,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_SASL_MECHANISM = 33,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ILLEGAL_SASL_STATE = 34,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_VERSION = 35,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_ALREADY_EXISTS = 36,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PARTITIONS = 37,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REPLICATION_FACTOR = 38,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REPLICA_ASSIGNMENT = 39,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_CONFIG = 40,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_CONTROLLER = 41,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REQUEST = 42,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_FOR_MESSAGE_FORMAT = 43,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_POLICY_VIOLATION = 44,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OUT_OF_ORDER_SEQUENCE_NUMBER = 45,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DUPLICATE_SEQUENCE_NUMBER = 46,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_EPOCH = 47,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TXN_STATE = 48,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_ID_MAPPING = 49,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TRANSACTION_TIMEOUT = 50,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_CONCURRENT_TRANSACTIONS = 51,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TRANSACTION_COORDINATOR_FENCED = 52,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TRANSACTIONAL_ID_AUTHORIZATION_FAILED = 53,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_SECURITY_DISABLED = 54,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OPERATION_NOT_ATTEMPTED = 55,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_KAFKA_STORAGE_ERROR = 56,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LOG_DIR_NOT_FOUND = 57,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_SASL_AUTHENTICATION_FAILED = 58,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_PRODUCER_ID = 59,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REASSIGNMENT_IN_PROGRESS = 60,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTH_DISABLED = 61,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_NOT_FOUND = 62,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_OWNER_MISMATCH = 63,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_REQUEST_NOT_ALLOWED = 64,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTHORIZATION_FAILED = 65,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_EXPIRED = 66,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRINCIPAL_TYPE = 67,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NON_EMPTY_GROUP = 68,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_ID_NOT_FOUND = 69,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FETCH_SESSION_ID_NOT_FOUND = 70,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_FETCH_SESSION_EPOCH = 71,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LISTENER_NOT_FOUND = 72,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_DELETION_DISABLED = 73,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FENCED_LEADER_EPOCH = 74,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_LEADER_EPOCH = 75,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_STALE_BROKER_EPOCH = 77,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_NOT_AVAILABLE = 78,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_MEMBER_ID_REQUIRED = 79,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_PREFERRED_LEADER_NOT_AVAILABLE = 80,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_MAX_SIZE_REACHED = 81,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FENCED_INSTANCE_ID = 82,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ELIGIBLE_LEADERS_NOT_AVAILABLE = 83,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ELECTION_NOT_NEEDED = 84,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NO_REASSIGNMENT_IN_PROGRESS = 85,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_SUBSCRIBED_TO_TOPIC = 86,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_RECORD = 87,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSTABLE_OFFSET_COMMIT = 88,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_THROTTLING_QUOTA_EXCEEDED = 89,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_PRODUCER_FENCED = 90,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_RESOURCE_NOT_FOUND = 91,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DUPLICATE_RESOURCE = 92,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNACCEPTABLE_CREDENTIAL = 93,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INCONSISTENT_VOTER_SET = 94,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_UPDATE_VERSION = 95,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FEATURE_UPDATE_FAILED = 96,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_PRINCIPAL_DESERIALIZATION_FAILURE = 97,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_END_ALL,</span>
<span class="s1">} rd_kafka_resp_err_t;</span>
<span class="s1">struct rd_kafka_err_desc {</span>
<span class="s1">  rd_kafka_resp_err_t code;</span>
<span class="s1">  char *name;</span>
<span class="s1">  char *desc;</span>
<span class="s1">};</span>
<span class="s1">void rd_kafka_get_err_descs(const struct rd_kafka_err_desc **errdescs, size_t *cntp);</span>
<span class="s1">const char *rd_kafka_err2str(rd_kafka_resp_err_t err);</span>
<span class="s1">const char *rd_kafka_err2name(rd_kafka_resp_err_t err);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_last_error(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_errno2err(int errnox);</span>
<span class="s1">int rd_kafka_errno(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_fatal_error(rd_kafka_t *rk, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_test_fatal_error(rd_kafka_t *rk, rd_kafka_resp_err_t err, const char *reason);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_error_code(const rd_kafka_error_t *error);</span>
<span class="s1">const char *rd_kafka_error_name(const rd_kafka_error_t *error);</span>
<span class="s1">const char *rd_kafka_error_string(const rd_kafka_error_t *error);</span>
<span class="s1">int rd_kafka_error_is_fatal(const rd_kafka_error_t *error);</span>
<span class="s1">int rd_kafka_error_is_retriable(const rd_kafka_error_t *error);</span>
<span class="s1">int rd_kafka_error_txn_requires_abort(const rd_kafka_error_t *error);</span>
<span class="s1">void rd_kafka_error_destroy(rd_kafka_error_t *error);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_error_new(rd_kafka_resp_err_t code, const char *fmt, ...);</span>
<span class="s1">typedef struct rd_kafka_topic_partition_s {</span>
<span class="s1">  char *topic;</span>
<span class="s1">  int32_t partition;</span>
<span class="s1">  int64_t offset;</span>
<span class="s1">  void *metadata;</span>
<span class="s1">  size_t metadata_size;</span>
<span class="s1">  void *opaque;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  void *_private;</span>
<span class="s1">} rd_kafka_topic_partition_t;</span>
<span class="s1">void rd_kafka_topic_partition_destroy(rd_kafka_topic_partition_t *rktpar);</span>
<span class="s1">typedef struct rd_kafka_topic_partition_list_s {</span>
<span class="s1">  int cnt;</span>
<span class="s1">  int size;</span>
<span class="s1">  rd_kafka_topic_partition_t *elems;</span>
<span class="s1">} rd_kafka_topic_partition_list_t;</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_new(int size);</span>
<span class="s1">void rd_kafka_topic_partition_list_destroy(rd_kafka_topic_partition_list_t *rkparlist);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_add(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">void rd_kafka_topic_partition_list_add_range(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t start, int32_t stop);</span>
<span class="s1">int rd_kafka_topic_partition_list_del(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">int rd_kafka_topic_partition_list_del_by_idx(rd_kafka_topic_partition_list_t *rktparlist, int idx);</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_copy(const rd_kafka_topic_partition_list_t *src);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_topic_partition_list_set_offset(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition, int64_t offset);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_find(const rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">void rd_kafka_topic_partition_list_sort(rd_kafka_topic_partition_list_t *rktparlist, int (*cmp)(const void *a, const void *b, void *cmp_opaque), void *cmp_opaque);</span>
<span class="s1">typedef enum rd_kafka_vtype_t {</span>
<span class="s1">  RD_KAFKA_VTYPE_END,</span>
<span class="s1">  RD_KAFKA_VTYPE_TOPIC,</span>
<span class="s1">  RD_KAFKA_VTYPE_RKT,</span>
<span class="s1">  RD_KAFKA_VTYPE_PARTITION,</span>
<span class="s1">  RD_KAFKA_VTYPE_VALUE,</span>
<span class="s1">  RD_KAFKA_VTYPE_KEY,</span>
<span class="s1">  RD_KAFKA_VTYPE_OPAQUE,</span>
<span class="s1">  RD_KAFKA_VTYPE_MSGFLAGS,</span>
<span class="s1">  RD_KAFKA_VTYPE_TIMESTAMP,</span>
<span class="s1">  RD_KAFKA_VTYPE_HEADER,</span>
<span class="s1">  RD_KAFKA_VTYPE_HEADERS,</span>
<span class="s1">} rd_kafka_vtype_t;</span>
<span class="s1">typedef struct rd_kafka_vu_s {</span>
<span class="s1">  rd_kafka_vtype_t vtype;</span>
<span class="s1">  union {</span>
<span class="s1">    char *cstr;</span>
<span class="s1">    rd_kafka_topic_t *rkt;</span>
<span class="s1">    int i;</span>
<span class="s1">    int32_t i32;</span>
<span class="s1">    int64_t i64;</span>
<span class="s1">    struct {</span>
<span class="s1">      void *ptr;</span>
<span class="s1">      size_t size;</span>
<span class="s1">    } mem;</span>
<span class="s1">    struct {</span>
<span class="s1">      char *name;</span>
<span class="s1">      void *val;</span>
<span class="s1">      ssize_t size;</span>
<span class="s1">    } header;</span>
<span class="s1">    rd_kafka_headers_t *headers;</span>
<span class="s1">    void *ptr;</span>
<span class="s1">    char _pad[64];</span>
<span class="s1">  } u;</span>
<span class="s1">} rd_kafka_vu_t;</span>
<span class="s1">rd_kafka_headers_t *rd_kafka_headers_new(size_t initial_count);</span>
<span class="s1">void rd_kafka_headers_destroy(rd_kafka_headers_t *hdrs);</span>
<span class="s1">rd_kafka_headers_t *rd_kafka_headers_copy(const rd_kafka_headers_t *src);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_add(rd_kafka_headers_t *hdrs, const char *name, ssize_t name_size, const void *value, ssize_t value_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_remove(rd_kafka_headers_t *hdrs, const char *name);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get_last(const rd_kafka_headers_t *hdrs, const char *name, const void **valuep, size_t *sizep);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get(const rd_kafka_headers_t *hdrs, size_t idx, const char *name, const void **valuep, size_t *sizep);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get_all(const rd_kafka_headers_t *hdrs, size_t idx, const char **namep, const void **valuep, size_t *sizep);</span>
<span class="s1">typedef struct rd_kafka_message_s {</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  rd_kafka_topic_t *rkt;</span>
<span class="s1">  int32_t partition;</span>
<span class="s1">  void *payload;</span>
<span class="s1">  size_t len;</span>
<span class="s1">  void *key;</span>
<span class="s1">  size_t key_len;</span>
<span class="s1">  int64_t offset;</span>
<span class="s1">  void *_private;</span>
<span class="s1">} rd_kafka_message_t;</span>
<span class="s1">void rd_kafka_message_destroy(rd_kafka_message_t *rkmessage);</span>
<span class="s1">const char *rd_kafka_message_errstr(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">int64_t rd_kafka_message_timestamp(const rd_kafka_message_t *rkmessage, rd_kafka_timestamp_type_t *tstype);</span>
<span class="s1">int64_t rd_kafka_message_latency(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">int32_t rd_kafka_message_broker_id(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_message_headers(const rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_message_detach_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);</span>
<span class="s1">void rd_kafka_message_set_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t *hdrs);</span>
<span class="s1">size_t rd_kafka_header_cnt(const rd_kafka_headers_t *hdrs);</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_NOT_PERSISTED = 0,</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_POSSIBLY_PERSISTED = 1,</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_PERSISTED = 2,</span>
<span class="s1">} rd_kafka_msg_status_t;</span>
<span class="s1">rd_kafka_msg_status_t rd_kafka_message_status(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_CONF_UNKNOWN = (- 2),</span>
<span class="s1">  RD_KAFKA_CONF_INVALID = (- 1),</span>
<span class="s1">  RD_KAFKA_CONF_OK = 0,</span>
<span class="s1">} rd_kafka_conf_res_t;</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_new(void);</span>
<span class="s1">void rd_kafka_conf_destroy(rd_kafka_conf_t *conf);</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_dup(const rd_kafka_conf_t *conf);</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_dup_filter(const rd_kafka_conf_t *conf, size_t filter_cnt, const char **filter);</span>
<span class="s1">const rd_kafka_conf_t *rd_kafka_conf(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_set(rd_kafka_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_conf_set_events(rd_kafka_conf_t *conf, int events);</span>
<span class="s1">void rd_kafka_conf_set_background_event_cb(rd_kafka_conf_t *conf, void (*event_cb)(rd_kafka_t *rk, rd_kafka_event_t *rkev, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_dr_cb(rd_kafka_conf_t *conf, void (*dr_cb)(rd_kafka_t *rk, void *payload, size_t len, rd_kafka_resp_err_t err, void *opaque, void *msg_opaque));</span>
<span class="s1">void rd_kafka_conf_set_dr_msg_cb(rd_kafka_conf_t *conf, void (*dr_msg_cb)(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_consume_cb(rd_kafka_conf_t *conf, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_rebalance_cb(rd_kafka_conf_t *conf, void (*rebalance_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *partitions, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_offset_commit_cb(rd_kafka_conf_t *conf, void (*offset_commit_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_error_cb(rd_kafka_conf_t *conf, void (*error_cb)(rd_kafka_t *rk, int err, const char *reason, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_throttle_cb(rd_kafka_conf_t *conf, void (*throttle_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int throttle_time_ms, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_log_cb(rd_kafka_conf_t *conf, void (*log_cb)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));</span>
<span class="s1">void rd_kafka_conf_set_stats_cb(rd_kafka_conf_t *conf, int (*stats_cb)(rd_kafka_t *rk, char *json, size_t json_len, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_oauthbearer_token_refresh_cb(rd_kafka_conf_t *conf, void (*oauthbearer_token_refresh_cb)(rd_kafka_t *rk, const char *oauthbearer_config, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_socket_cb(rd_kafka_conf_t *conf, int (*socket_cb)(int domain, int type, int protocol, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_connect_cb(rd_kafka_conf_t *conf, int (*connect_cb)(int sockfd, const struct sockaddr *addr, int addrlen, const char *id, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_closesocket_cb(rd_kafka_conf_t *conf, int (*closesocket_cb)(int sockfd, void *opaque));</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert_verify_cb(rd_kafka_conf_t *conf, int (*ssl_cert_verify_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int *x509_error, int depth, const char *buf, size_t size, char *errstr, size_t errstr_size, void *opaque));</span>
<span class="s1">typedef enum rd_kafka_cert_type_t {</span>
<span class="s1">  RD_KAFKA_CERT_PUBLIC_KEY,</span>
<span class="s1">  RD_KAFKA_CERT_PRIVATE_KEY,</span>
<span class="s1">  RD_KAFKA_CERT_CA,</span>
<span class="s1">  RD_KAFKA_CERT__CNT,</span>
<span class="s1">} rd_kafka_cert_type_t;</span>
<span class="s1">typedef enum rd_kafka_cert_enc_t {</span>
<span class="s1">  RD_KAFKA_CERT_ENC_PKCS12,</span>
<span class="s1">  RD_KAFKA_CERT_ENC_DER,</span>
<span class="s1">  RD_KAFKA_CERT_ENC_PEM,</span>
<span class="s1">  RD_KAFKA_CERT_ENC__CNT,</span>
<span class="s1">} rd_kafka_cert_enc_t;</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert(rd_kafka_conf_t *conf, rd_kafka_cert_type_t cert_type, rd_kafka_cert_enc_t cert_enc, const void *buffer, size_t size, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_conf_set_opaque(rd_kafka_conf_t *conf, void *opaque);</span>
<span class="s1">void *rd_kafka_opaque(const rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_conf_set_default_topic_conf(rd_kafka_conf_t *conf, rd_kafka_topic_conf_t *tconf);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_conf_get_default_topic_conf(rd_kafka_conf_t *conf);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_get(const rd_kafka_conf_t *conf, const char *name, char *dest, size_t *dest_size);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_topic_conf_get(const rd_kafka_topic_conf_t *conf, const char *name, char *dest, size_t *dest_size);</span>
<span class="s1">const char **rd_kafka_conf_dump(rd_kafka_conf_t *conf, size_t *cntp);</span>
<span class="s1">const char **rd_kafka_topic_conf_dump(rd_kafka_topic_conf_t *conf, size_t *cntp);</span>
<span class="s1">void rd_kafka_conf_dump_free(const char **arr, size_t cnt);</span>
<span class="s1">void rd_kafka_conf_properties_show(FILE *fp);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_topic_conf_new(void);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_topic_conf_dup(const rd_kafka_topic_conf_t *conf);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_default_topic_conf_dup(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_topic_conf_destroy(rd_kafka_topic_conf_t *topic_conf);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_topic_conf_set(rd_kafka_topic_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_topic_conf_set_opaque(rd_kafka_topic_conf_t *conf, void *rkt_opaque);</span>
<span class="s1">void rd_kafka_topic_conf_set_partitioner_cb(rd_kafka_topic_conf_t *topic_conf, int32_t (*partitioner)(const rd_kafka_topic_t *rkt, const void *keydata, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque));</span>
<span class="s1">void rd_kafka_topic_conf_set_msg_order_cmp(rd_kafka_topic_conf_t *topic_conf, int (*msg_order_cmp)(const rd_kafka_message_t *a, const rd_kafka_message_t *b));</span>
<span class="s1">int rd_kafka_topic_partition_available(const rd_kafka_topic_t *rkt, int32_t partition);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_consistent(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_consistent_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_murmur2(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_murmur2_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_fnv1a(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_fnv1a_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">rd_kafka_t *rd_kafka_new(rd_kafka_type_t type, rd_kafka_conf_t *conf, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_destroy(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_destroy_flags(rd_kafka_t *rk, int flags);</span>
<span class="s1">const char *rd_kafka_name(const rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_type_t rd_kafka_type(const rd_kafka_t *rk);</span>
<span class="s1">char *rd_kafka_memberid(const rd_kafka_t *rk);</span>
<span class="s1">char *rd_kafka_clusterid(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">int32_t rd_kafka_controllerid(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_topic_t *rd_kafka_topic_new(rd_kafka_t *rk, const char *topic, rd_kafka_topic_conf_t *conf);</span>
<span class="s1">void rd_kafka_topic_destroy(rd_kafka_topic_t *rkt);</span>
<span class="s1">const char *rd_kafka_topic_name(const rd_kafka_topic_t *rkt);</span>
<span class="s1">void *rd_kafka_topic_opaque(const rd_kafka_topic_t *rkt);</span>
<span class="s1">int rd_kafka_poll(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">void rd_kafka_yield(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_pause_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_resume_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_query_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_get_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offsets_for_times(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets, int timeout_ms);</span>
<span class="s1">void rd_kafka_mem_free(rd_kafka_t *rk, void *ptr);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_new(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_queue_destroy(rd_kafka_queue_t *rkqu);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_main(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_consumer(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_partition(rd_kafka_t *rk, const char *topic, int32_t partition);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_background(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_queue_forward(rd_kafka_queue_t *src, rd_kafka_queue_t *dst);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_set_log_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu);</span>
<span class="s1">size_t rd_kafka_queue_length(rd_kafka_queue_t *rkqu);</span>
<span class="s1">void rd_kafka_queue_io_event_enable(rd_kafka_queue_t *rkqu, int fd, const void *payload, size_t size);</span>
<span class="s1">void rd_kafka_queue_cb_event_enable(rd_kafka_queue_t *rkqu, void (*event_cb)(rd_kafka_t *rk, void *qev_opaque), void *qev_opaque);</span>
<span class="s1">void rd_kafka_queue_yield(rd_kafka_queue_t *rkqu);</span>
<span class="s1">int rd_kafka_consume_start(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);</span>
<span class="s1">int rd_kafka_consume_start_queue(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, rd_kafka_queue_t *rkqu);</span>
<span class="s1">int rd_kafka_consume_stop(rd_kafka_topic_t *rkt, int32_t partition);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_seek(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, int timeout_ms);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_seek_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consume(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms);</span>
<span class="s1">ssize_t rd_kafka_consume_batch(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);</span>
<span class="s1">int rd_kafka_consume_callback(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consume_queue(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">ssize_t rd_kafka_consume_batch_queue(rd_kafka_queue_t *rkqu, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);</span>
<span class="s1">int rd_kafka_consume_callback_queue(rd_kafka_queue_t *rkqu, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offset_store(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offsets_store(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_subscribe(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *topics);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_unsubscribe(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_subscription(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **topics);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consumer_poll(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_consumer_close(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_incremental_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_incremental_unassign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">const char *rd_kafka_rebalance_protocol(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_assignment(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **partitions);</span>
<span class="s1">int rd_kafka_assignment_lost(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, int async);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit_message(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, int async);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit_queue(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_queue_t *rkqu, void (*cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *commit_opaque), void *commit_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_committed(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_position(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata_new(const char *group_id);</span>
<span class="s1">rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata_new_with_genid(const char *group_id, int32_t generation_id, const char *member_id, const char *group_instance_id);</span>
<span class="s1">void rd_kafka_consumer_group_metadata_destroy(rd_kafka_consumer_group_metadata_t *);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_consumer_group_metadata_write(const rd_kafka_consumer_group_metadata_t *cgmd, void **bufferp, size_t *sizep);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_consumer_group_metadata_read(rd_kafka_consumer_group_metadata_t **cgmdp, const void *buffer, size_t size);</span>
<span class="s1">int rd_kafka_produce(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, void *payload, size_t len, const void *key, size_t keylen, void *msg_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_producev(rd_kafka_t *rk, ...);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_produceva(rd_kafka_t *rk, const rd_kafka_vu_t *vus, size_t cnt);</span>
<span class="s1">int rd_kafka_produce_batch(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, rd_kafka_message_t *rkmessages, int message_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_flush(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_purge(rd_kafka_t *rk, int purge_flags);</span>
<span class="s1">typedef struct rd_kafka_metadata_broker {</span>
<span class="s1">  int32_t id;</span>
<span class="s1">  char *host;</span>
<span class="s1">  int port;</span>
<span class="s1">} rd_kafka_metadata_broker_t;</span>
<span class="s1">typedef struct rd_kafka_metadata_partition {</span>
<span class="s1">  int32_t id;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  int32_t leader;</span>
<span class="s1">  int replica_cnt;</span>
<span class="s1">  int32_t *replicas;</span>
<span class="s1">  int isr_cnt;</span>
<span class="s1">  int32_t *isrs;</span>
<span class="s1">} rd_kafka_metadata_partition_t;</span>
<span class="s1">typedef struct rd_kafka_metadata_topic {</span>
<span class="s1">  char *topic;</span>
<span class="s1">  int partition_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_partition *partitions;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">} rd_kafka_metadata_topic_t;</span>
<span class="s1">typedef struct rd_kafka_metadata {</span>
<span class="s1">  int broker_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_broker *brokers;</span>
<span class="s1">  int topic_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_topic *topics;</span>
<span class="s1">  int32_t orig_broker_id;</span>
<span class="s1">  char *orig_broker_name;</span>
<span class="s1">} rd_kafka_metadata_t;</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_metadata(rd_kafka_t *rk, int all_topics, rd_kafka_topic_t *only_rkt, const struct rd_kafka_metadata **metadatap, int timeout_ms);</span>
<span class="s1">void rd_kafka_metadata_destroy(const struct rd_kafka_metadata *metadata);</span>
<span class="s1">struct rd_kafka_group_member_info {</span>
<span class="s1">  char *member_id;</span>
<span class="s1">  char *client_id;</span>
<span class="s1">  char *client_host;</span>
<span class="s1">  void *member_metadata;</span>
<span class="s1">  int member_metadata_size;</span>
<span class="s1">  void *member_assignment;</span>
<span class="s1">  int member_assignment_size;</span>
<span class="s1">};</span>
<span class="s1">struct rd_kafka_group_info {</span>
<span class="s1">  struct rd_kafka_metadata_broker broker;</span>
<span class="s1">  char *group;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  char *state;</span>
<span class="s1">  char *protocol_type;</span>
<span class="s1">  char *protocol;</span>
<span class="s1">  struct rd_kafka_group_member_info *members;</span>
<span class="s1">  int member_cnt;</span>
<span class="s1">};</span>
<span class="s1">struct rd_kafka_group_list {</span>
<span class="s1">  struct rd_kafka_group_info *groups;</span>
<span class="s1">  int group_cnt;</span>
<span class="s1">};</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_list_groups(rd_kafka_t *rk, const char *group, const struct rd_kafka_group_list **grplistp, int timeout_ms);</span>
<span class="s1">void rd_kafka_group_list_destroy(const struct rd_kafka_group_list *grplist);</span>
<span class="s1">int rd_kafka_brokers_add(rd_kafka_t *rk, const char *brokerlist);</span>
<span class="s1">void rd_kafka_set_logger(rd_kafka_t *rk, void (*func)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));</span>
<span class="s1">void rd_kafka_set_log_level(rd_kafka_t *rk, int level);</span>
<span class="s1">void rd_kafka_log_print(const rd_kafka_t *rk, int level, const char *fac, const char *buf);</span>
<span class="s1">void rd_kafka_log_syslog(const rd_kafka_t *rk, int level, const char *fac, const char *buf);</span>
<span class="s1">int rd_kafka_outq_len(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_dump(FILE *fp, rd_kafka_t *rk);</span>
<span class="s1">int rd_kafka_thread_cnt(void);</span>
<span class="s1">typedef enum rd_kafka_thread_type_t {</span>
<span class="s1">  RD_KAFKA_THREAD_MAIN,</span>
<span class="s1">  RD_KAFKA_THREAD_BACKGROUND,</span>
<span class="s1">  RD_KAFKA_THREAD_BROKER,</span>
<span class="s1">} rd_kafka_thread_type_t;</span>
<span class="s1">int rd_kafka_wait_destroyed(int timeout_ms);</span>
<span class="s1">int rd_kafka_unittest(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_poll_set_consumer(rd_kafka_t *rk);</span>
<span class="s1">typedef int rd_kafka_event_type_t;</span>
<span class="s1">rd_kafka_event_type_t rd_kafka_event_type(const rd_kafka_event_t *rkev);</span>
<span class="s1">const char *rd_kafka_event_name(const rd_kafka_event_t *rkev);</span>
<span class="s1">void rd_kafka_event_destroy(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_message_t *rd_kafka_event_message_next(rd_kafka_event_t *rkev);</span>
<span class="s1">size_t rd_kafka_event_message_array(rd_kafka_event_t *rkev, const rd_kafka_message_t **rkmessages, size_t size);</span>
<span class="s1">size_t rd_kafka_event_message_count(rd_kafka_event_t *rkev);</span>
<span class="s1">const char *rd_kafka_event_config_string(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_event_error(rd_kafka_event_t *rkev);</span>
<span class="s1">const char *rd_kafka_event_error_string(rd_kafka_event_t *rkev);</span>
<span class="s1">int rd_kafka_event_error_is_fatal(rd_kafka_event_t *rkev);</span>
<span class="s1">void *rd_kafka_event_opaque(rd_kafka_event_t *rkev);</span>
<span class="s1">int rd_kafka_event_log(rd_kafka_event_t *rkev, const char **fac, const char **str, int *level);</span>
<span class="s1">int rd_kafka_event_debug_contexts(rd_kafka_event_t *rkev, char *dst, size_t dstsize);</span>
<span class="s1">const char *rd_kafka_event_stats(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_event_topic_partition_list(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_event_topic_partition(rd_kafka_event_t *rkev);</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_CreateTopics_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DeleteTopics_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_CreatePartitions_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_AlterConfigs_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DescribeConfigs_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DeleteRecords_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DeleteGroups_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DeleteConsumerGroupOffsets_result_t;</span>
<span class="s1">const rd_kafka_CreateTopics_result_t *rd_kafka_event_CreateTopics_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DeleteTopics_result_t *rd_kafka_event_DeleteTopics_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_CreatePartitions_result_t *rd_kafka_event_CreatePartitions_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_AlterConfigs_result_t *rd_kafka_event_AlterConfigs_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DescribeConfigs_result_t *rd_kafka_event_DescribeConfigs_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DeleteRecords_result_t *rd_kafka_event_DeleteRecords_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DeleteGroups_result_t *rd_kafka_event_DeleteGroups_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DeleteConsumerGroupOffsets_result_t *rd_kafka_event_DeleteConsumerGroupOffsets_result(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_event_t *rd_kafka_queue_poll(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">int rd_kafka_queue_poll_callback(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_plugin_f_conf_init_t)(rd_kafka_conf_t *conf, void **plug_opaquep, char *errstr, size_t errstr_size);</span>
<span class="s1">typedef rd_kafka_conf_res_t (rd_kafka_interceptor_f_on_conf_set_t)(rd_kafka_conf_t *conf, const char *name, const char *val, char *errstr, size_t errstr_size, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_dup_t)(rd_kafka_conf_t *new_conf, const rd_kafka_conf_t *old_conf, size_t filter_cnt, const char **filter, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_destroy_t)(void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_new_t)(rd_kafka_t *rk, const rd_kafka_conf_t *conf, void *ic_opaque, char *errstr, size_t errstr_size);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_destroy_t)(rd_kafka_t *rk, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_send_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_acknowledgement_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_consume_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_commit_t)(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_resp_err_t err, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_request_sent_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_start_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_exit_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_set(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_set_t *on_conf_set, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_dup(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_dup_t *on_conf_dup, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_destroy(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_destroy_t *on_conf_destroy, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_new(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_new_t *on_new, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_destroy(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_destroy_t *on_destroy, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_send(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_send_t *on_send, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_acknowledgement(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_acknowledgement_t *on_acknowledgement, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_consume(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_consume_t *on_consume, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_commit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_commit_t *on_commit, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_request_sent(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_request_sent_t *on_request_sent, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_start(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_start_t *on_thread_start, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_exit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_exit_t *on_thread_exit, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_topic_result_error(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">const char *rd_kafka_topic_result_error_string(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">const char *rd_kafka_topic_result_name(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">const rd_kafka_error_t *rd_kafka_group_result_error(const rd_kafka_group_result_t *groupres);</span>
<span class="s1">const char *rd_kafka_group_result_name(const rd_kafka_group_result_t *groupres);</span>
<span class="s1">const rd_kafka_topic_partition_list_t *rd_kafka_group_result_partitions(const rd_kafka_group_result_t *groupres);</span>
<span class="s1">typedef enum rd_kafka_admin_op_t {</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_ANY = 0,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_CREATETOPICS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DELETETOPICS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_CREATEPARTITIONS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_ALTERCONFIGS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DESCRIBECONFIGS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DELETERECORDS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DELETEGROUPS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DELETECONSUMERGROUPOFFSETS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP__CNT,</span>
<span class="s1">} rd_kafka_admin_op_t;</span>
<span class="s1">typedef struct rd_kafka_AdminOptions_s rd_kafka_AdminOptions_t;</span>
<span class="s1">rd_kafka_AdminOptions_t *rd_kafka_AdminOptions_new(rd_kafka_t *rk, rd_kafka_admin_op_t for_api);</span>
<span class="s1">void rd_kafka_AdminOptions_destroy(rd_kafka_AdminOptions_t *options);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_request_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_operation_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_validate_only(rd_kafka_AdminOptions_t *options, int true_or_false, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_broker(rd_kafka_AdminOptions_t *options, int32_t broker_id, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_AdminOptions_set_opaque(rd_kafka_AdminOptions_t *options, void *ev_opaque);</span>
<span class="s1">typedef struct rd_kafka_NewTopic_s rd_kafka_NewTopic_t;</span>
<span class="s1">rd_kafka_NewTopic_t *rd_kafka_NewTopic_new(const char *topic, int num_partitions, int replication_factor, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_NewTopic_destroy(rd_kafka_NewTopic_t *new_topic);</span>
<span class="s1">void rd_kafka_NewTopic_destroy_array(rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewTopic_set_replica_assignment(rd_kafka_NewTopic_t *new_topic, int32_t partition, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewTopic_set_config(rd_kafka_NewTopic_t *new_topic, const char *name, const char *value);</span>
<span class="s1">void rd_kafka_CreateTopics(rd_kafka_t *rk, rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_CreateTopics_result_topics(const rd_kafka_CreateTopics_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_DeleteTopic_s rd_kafka_DeleteTopic_t;</span>
<span class="s1">rd_kafka_DeleteTopic_t *rd_kafka_DeleteTopic_new(const char *topic);</span>
<span class="s1">void rd_kafka_DeleteTopic_destroy(rd_kafka_DeleteTopic_t *del_topic);</span>
<span class="s1">void rd_kafka_DeleteTopic_destroy_array(rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt);</span>
<span class="s1">void rd_kafka_DeleteTopics(rd_kafka_t *rk, rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_DeleteTopics_result_topics(const rd_kafka_DeleteTopics_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_NewPartitions_s rd_kafka_NewPartitions_t;</span>
<span class="s1">rd_kafka_NewPartitions_t *rd_kafka_NewPartitions_new(const char *topic, size_t new_total_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_NewPartitions_destroy(rd_kafka_NewPartitions_t *new_parts);</span>
<span class="s1">void rd_kafka_NewPartitions_destroy_array(rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewPartitions_set_replica_assignment(rd_kafka_NewPartitions_t *new_parts, int32_t new_partition_idx, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_CreatePartitions(rd_kafka_t *rk, rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_CreatePartitions_result_topics(const rd_kafka_CreatePartitions_result_t *result, size_t *cntp);</span>
<span class="s1">typedef enum rd_kafka_ConfigSource_t {</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_UNKNOWN_CONFIG = 0,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_TOPIC_CONFIG = 1,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_BROKER_CONFIG = 2,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_DEFAULT_BROKER_CONFIG = 3,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_STATIC_BROKER_CONFIG = 4,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DEFAULT_CONFIG = 5,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE__CNT,</span>
<span class="s1">} rd_kafka_ConfigSource_t;</span>
<span class="s1">const char *rd_kafka_ConfigSource_name(rd_kafka_ConfigSource_t confsource);</span>
<span class="s1">typedef struct rd_kafka_ConfigEntry_s rd_kafka_ConfigEntry_t;</span>
<span class="s1">const char *rd_kafka_ConfigEntry_name(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">const char *rd_kafka_ConfigEntry_value(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">rd_kafka_ConfigSource_t rd_kafka_ConfigEntry_source(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_read_only(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_default(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_sensitive(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_synonym(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">const rd_kafka_ConfigEntry_t **rd_kafka_ConfigEntry_synonyms(const rd_kafka_ConfigEntry_t *entry, size_t *cntp);</span>
<span class="s1">typedef enum rd_kafka_ResourceType_t {</span>
<span class="s1">  RD_KAFKA_RESOURCE_UNKNOWN = 0,</span>
<span class="s1">  RD_KAFKA_RESOURCE_ANY = 1,</span>
<span class="s1">  RD_KAFKA_RESOURCE_TOPIC = 2,</span>
<span class="s1">  RD_KAFKA_RESOURCE_GROUP = 3,</span>
<span class="s1">  RD_KAFKA_RESOURCE_BROKER = 4,</span>
<span class="s1">  RD_KAFKA_RESOURCE__CNT,</span>
<span class="s1">} rd_kafka_ResourceType_t;</span>
<span class="s1">const char *rd_kafka_ResourceType_name(rd_kafka_ResourceType_t restype);</span>
<span class="s1">typedef struct rd_kafka_ConfigResource_s rd_kafka_ConfigResource_t;</span>
<span class="s1">rd_kafka_ConfigResource_t *rd_kafka_ConfigResource_new(rd_kafka_ResourceType_t restype, const char *resname);</span>
<span class="s1">void rd_kafka_ConfigResource_destroy(rd_kafka_ConfigResource_t *config);</span>
<span class="s1">void rd_kafka_ConfigResource_destroy_array(rd_kafka_ConfigResource_t **config, size_t config_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_ConfigResource_set_config(rd_kafka_ConfigResource_t *config, const char *name, const char *value);</span>
<span class="s1">const rd_kafka_ConfigEntry_t **rd_kafka_ConfigResource_configs(const rd_kafka_ConfigResource_t *config, size_t *cntp);</span>
<span class="s1">rd_kafka_ResourceType_t rd_kafka_ConfigResource_type(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">const char *rd_kafka_ConfigResource_name(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_ConfigResource_error(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">const char *rd_kafka_ConfigResource_error_string(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">void rd_kafka_AlterConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_ConfigResource_t **rd_kafka_AlterConfigs_result_resources(const rd_kafka_AlterConfigs_result_t *result, size_t *cntp);</span>
<span class="s1">void rd_kafka_DescribeConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_ConfigResource_t **rd_kafka_DescribeConfigs_result_resources(const rd_kafka_DescribeConfigs_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_DeleteRecords_s rd_kafka_DeleteRecords_t;</span>
<span class="s1">rd_kafka_DeleteRecords_t *rd_kafka_DeleteRecords_new(const rd_kafka_topic_partition_list_t *before_offsets);</span>
<span class="s1">void rd_kafka_DeleteRecords_destroy(rd_kafka_DeleteRecords_t *del_records);</span>
<span class="s1">void rd_kafka_DeleteRecords_destroy_array(rd_kafka_DeleteRecords_t **del_records, size_t del_record_cnt);</span>
<span class="s1">void rd_kafka_DeleteRecords(rd_kafka_t *rk, rd_kafka_DeleteRecords_t **del_records, size_t del_record_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_partition_list_t *rd_kafka_DeleteRecords_result_offsets(const rd_kafka_DeleteRecords_result_t *result);</span>
<span class="s1">typedef struct rd_kafka_DeleteGroup_s rd_kafka_DeleteGroup_t;</span>
<span class="s1">rd_kafka_DeleteGroup_t *rd_kafka_DeleteGroup_new(const char *group);</span>
<span class="s1">void rd_kafka_DeleteGroup_destroy(rd_kafka_DeleteGroup_t *del_group);</span>
<span class="s1">void rd_kafka_DeleteGroup_destroy_array(rd_kafka_DeleteGroup_t **del_groups, size_t del_group_cnt);</span>
<span class="s1">void rd_kafka_DeleteGroups(rd_kafka_t *rk, rd_kafka_DeleteGroup_t **del_groups, size_t del_group_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_group_result_t **rd_kafka_DeleteGroups_result_groups(const rd_kafka_DeleteGroups_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_DeleteConsumerGroupOffsets_s rd_kafka_DeleteConsumerGroupOffsets_t;</span>
<span class="s1">rd_kafka_DeleteConsumerGroupOffsets_t *rd_kafka_DeleteConsumerGroupOffsets_new(const char *group, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">void rd_kafka_DeleteConsumerGroupOffsets_destroy(rd_kafka_DeleteConsumerGroupOffsets_t *del_grpoffsets);</span>
<span class="s1">void rd_kafka_DeleteConsumerGroupOffsets_destroy_array(rd_kafka_DeleteConsumerGroupOffsets_t **del_grpoffsets, size_t del_grpoffset_cnt);</span>
<span class="s1">void rd_kafka_DeleteConsumerGroupOffsets(rd_kafka_t *rk, rd_kafka_DeleteConsumerGroupOffsets_t **del_grpoffsets, size_t del_grpoffsets_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_group_result_t **rd_kafka_DeleteConsumerGroupOffsets_result_groups(const rd_kafka_DeleteConsumerGroupOffsets_result_t *result, size_t *cntp);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token(rd_kafka_t *rk, const char *token_value, int64_t md_lifetime_ms, const char *md_principal_name, const char **extensions, size_t extension_size, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token_failure(rd_kafka_t *rk, const char *errstr);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_init_transactions(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_begin_transaction(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_send_offsets_to_transaction(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, const rd_kafka_consumer_group_metadata_t *cgmetadata, int timeout_ms);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_commit_transaction(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_abort_transaction(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">typedef struct rd_kafka_mock_cluster_s rd_kafka_mock_cluster_t;</span>
<span class="s1">rd_kafka_mock_cluster_t *rd_kafka_mock_cluster_new(rd_kafka_t *rk, int broker_cnt);</span>
<span class="s1">void rd_kafka_mock_cluster_destroy(rd_kafka_mock_cluster_t *mcluster);</span>
<span class="s1">rd_kafka_t *rd_kafka_mock_cluster_handle(const rd_kafka_mock_cluster_t *mcluster);</span>
<span class="s1">rd_kafka_mock_cluster_t *rd_kafka_handle_mock_cluster(const rd_kafka_t *rk);</span>
<span class="s1">const char *rd_kafka_mock_cluster_bootstraps(const rd_kafka_mock_cluster_t *mcluster);</span>
<span class="s1">void rd_kafka_mock_clear_request_errors(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey);</span>
<span class="s1">void rd_kafka_mock_push_request_errors(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, size_t cnt, ...);</span>
<span class="s1">void rd_kafka_mock_push_request_errors_array(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, size_t cnt, const rd_kafka_resp_err_t *errors);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_push_request_errors(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int16_t ApiKey, size_t cnt, ...);</span>
<span class="s1">void rd_kafka_mock_topic_set_error(rd_kafka_mock_cluster_t *mcluster, const char *topic, rd_kafka_resp_err_t err);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_topic_create(rd_kafka_mock_cluster_t *mcluster, const char *topic, int partition_cnt, int replication_factor);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_partition_set_leader(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_partition_set_follower(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_partition_set_follower_wmarks(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int64_t lo, int64_t hi);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_set_down(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_set_up(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_set_rtt(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int rtt_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_set_rack(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, const char *rack);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_coordinator_set(rd_kafka_mock_cluster_t *mcluster, const char *key_type, const char *key, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_set_apiversion(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, int16_t MinVersion, int16_t MaxVersion);</span>
<span class="s1">&#39;</span>
</code></pre></div>
rdkafka.h, rdkafka_mock.h</p>
<h3 id="rd_kafka_version_14">RD_KAFKA_VERSION<a class="headerlink" href="#rd_kafka_version_14" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_VERSION</span> <span class="o">=</span> <span class="mi">17170943</span>
</code></pre></div>
<p>librdkafka version </p>
<p>Interpreted as hex <code>MM.mm.rr.xx</code>:</p>
<ul>
<li>MM = Major</li>
<li>mm = minor</li>
<li>rr = revision</li>
<li>xx = pre-release id (0xff is the final release)</li>
</ul>
<p>E.g.: <code>0x000801ff</code> = 0.8.1</p>
<dl class="section remark"><dt>Remarks</dt><dd>This value should only be used during compile time, for runtime checks of version use rd_kafka_version() </dd></dl>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_unsupported_compression_type_14">RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE<a class="headerlink" href="#rd_kafka_resp_err_unsupported_compression_type_14" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE</span> <span class="o">=</span> <span class="mi">76</span>
</code></pre></div>
<p>Unsupported compression type </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_end_all_14">RD_KAFKA_RESP_ERR_END_ALL<a class="headerlink" href="#rd_kafka_resp_err_end_all_14" title="Permanent link">&para;</a></h3>
<p><div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_END_ALL</span> <span class="o">=</span> <span class="mi">98</span>
</code></pre></div>
enum rd_kafka_resp_err_t</p>
<h3 id="rd_kafka_admin_op__cnt_14">RD_KAFKA_ADMIN_OP__CNT<a class="headerlink" href="#rd_kafka_admin_op__cnt_14" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_ADMIN_OP__CNT</span> <span class="o">=</span> <span class="mi">9</span>
</code></pre></div>
<p>Number of ops defined </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe </a></li>
</ul>
</div>
<h3 id="rd_kafka_resource__cnt_14">RD_KAFKA_RESOURCE__CNT<a class="headerlink" href="#rd_kafka_resource__cnt_14" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESOURCE__CNT</span> <span class="o">=</span> <span class="mi">5</span>
</code></pre></div>
<p>Number of resource types defined </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#acca83a66d7783ff7683ed2691cc907c9"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#acca83a66d7783ff7683ed2691cc907c9 </a></li>
</ul>
</div>
<h3 id="rd_kafka_cdef_14">RD_KAFKA_CDEF<a class="headerlink" href="#rd_kafka_cdef_14" title="Permanent link">&para;</a></h3>
<p><div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_CDEF</span> <span class="o">=</span> <span class="s1">&#39;typedef long int ssize_t;</span>
<span class="s1">typedef struct _IO_FILE FILE;</span>
<span class="s1">typedef long int mode_t;</span>
<span class="s1">typedef signed int int16_t;</span>
<span class="s1">typedef unsigned int uint16_t;</span>
<span class="s1">typedef signed int int32_t;</span>
<span class="s1">typedef signed long int int64_t;</span>
<span class="s1">int rd_kafka_version(void);</span>
<span class="s1">const char *rd_kafka_version_str(void);</span>
<span class="s1">typedef enum rd_kafka_type_t {</span>
<span class="s1">  RD_KAFKA_PRODUCER,</span>
<span class="s1">  RD_KAFKA_CONSUMER,</span>
<span class="s1">} rd_kafka_type_t;</span>
<span class="s1">typedef enum rd_kafka_timestamp_type_t {</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_NOT_AVAILABLE,</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_CREATE_TIME,</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_LOG_APPEND_TIME,</span>
<span class="s1">} rd_kafka_timestamp_type_t;</span>
<span class="s1">const char *rd_kafka_get_debug_contexts(void);</span>
<span class="s1">typedef struct rd_kafka_s rd_kafka_t;</span>
<span class="s1">typedef struct rd_kafka_topic_s rd_kafka_topic_t;</span>
<span class="s1">typedef struct rd_kafka_conf_s rd_kafka_conf_t;</span>
<span class="s1">typedef struct rd_kafka_topic_conf_s rd_kafka_topic_conf_t;</span>
<span class="s1">typedef struct rd_kafka_queue_s rd_kafka_queue_t;</span>
<span class="s1">typedef struct rd_kafka_op_s rd_kafka_event_t;</span>
<span class="s1">typedef struct rd_kafka_topic_result_s rd_kafka_topic_result_t;</span>
<span class="s1">typedef struct rd_kafka_consumer_group_metadata_s rd_kafka_consumer_group_metadata_t;</span>
<span class="s1">typedef struct rd_kafka_error_s {</span>
<span class="s1">  unsigned int code;</span>
<span class="s1">  char *errstr;</span>
<span class="s1">  unsigned char fatal;</span>
<span class="s1">  unsigned char retriable;</span>
<span class="s1">  unsigned char txn_requires_abort;</span>
<span class="s1">} rd_kafka_error_t;</span>
<span class="s1">typedef struct rd_kafka_headers_s rd_kafka_headers_t;</span>
<span class="s1">typedef struct rd_kafka_group_result_s rd_kafka_group_result_t;</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BEGIN = (- 200),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BAD_MSG = (- 199),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BAD_COMPRESSION = (- 198),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__DESTROY = (- 197),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FAIL = (- 196),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TRANSPORT = (- 195),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__CRIT_SYS_RESOURCE = (- 194),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__RESOLVE = (- 193),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__MSG_TIMED_OUT = (- 192),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PARTITION_EOF = (- 191),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION = (- 190),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FS = (- 189),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC = (- 188),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ALL_BROKERS_DOWN = (- 187),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INVALID_ARG = (- 186),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TIMED_OUT = (- 185),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__QUEUE_FULL = (- 184),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ISR_INSUFF = (- 183),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NODE_UPDATE = (- 182),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__SSL = (- 181),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__WAIT_COORD = (- 180),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_GROUP = (- 179),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__IN_PROGRESS = (- 178),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PREV_IN_PROGRESS = (- 177),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__EXISTING_SUBSCRIPTION = (- 176),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS = (- 175),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS = (- 174),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__CONFLICT = (- 173),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__STATE = (- 172),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_PROTOCOL = (- 171),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED = (- 170),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__AUTHENTICATION = (- 169),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NO_OFFSET = (- 168),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__OUTDATED = (- 167),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TIMED_OUT_QUEUE = (- 166),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNSUPPORTED_FEATURE = (- 165),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__WAIT_CACHE = (- 164),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INTR = (- 163),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__KEY_SERIALIZATION = (- 162),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__VALUE_SERIALIZATION = (- 161),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__KEY_DESERIALIZATION = (- 160),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__VALUE_DESERIALIZATION = (- 159),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PARTIAL = (- 158),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__READ_ONLY = (- 157),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOENT = (- 156),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNDERFLOW = (- 155),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INVALID_TYPE = (- 154),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__RETRY = (- 153),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PURGE_QUEUE = (- 152),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PURGE_INFLIGHT = (- 151),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FATAL = (- 150),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INCONSISTENT = (- 149),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__GAPLESS_GUARANTEE = (- 148),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__MAX_POLL_EXCEEDED = (- 147),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_BROKER = (- 146),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOT_CONFIGURED = (- 145),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FENCED = (- 144),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__APPLICATION = (- 143),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ASSIGNMENT_LOST = (- 142),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOOP = (- 141),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__AUTO_OFFSET_RESET = (- 140),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__END = (- 100),</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN = (- 1),</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NO_ERROR = 0,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_OUT_OF_RANGE = 1,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_MSG = 2,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART = 3,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_MSG_SIZE = 4,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE = 5,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_LEADER_FOR_PARTITION = 6,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REQUEST_TIMED_OUT = 7,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_BROKER_NOT_AVAILABLE = 8,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REPLICA_NOT_AVAILABLE = 9,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE = 10,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_STALE_CTRL_EPOCH = 11,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_METADATA_TOO_LARGE = 12,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NETWORK_EXCEPTION = 13,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_COORDINATOR_LOAD_IN_PROGRESS = 14,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_COORDINATOR_NOT_AVAILABLE = 15,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_COORDINATOR = 16,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_EXCEPTION = 17,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_RECORD_LIST_TOO_LARGE = 18,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS = 19,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS_AFTER_APPEND = 20,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REQUIRED_ACKS = 21,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ILLEGAL_GENERATION = 22,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INCONSISTENT_GROUP_PROTOCOL = 23,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_GROUP_ID = 24,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_MEMBER_ID = 25,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_SESSION_TIMEOUT = 26,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REBALANCE_IN_PROGRESS = 27,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_COMMIT_OFFSET_SIZE = 28,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_AUTHORIZATION_FAILED = 29,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_AUTHORIZATION_FAILED = 30,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_CLUSTER_AUTHORIZATION_FAILED = 31,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TIMESTAMP = 32,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_SASL_MECHANISM = 33,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ILLEGAL_SASL_STATE = 34,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_VERSION = 35,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_ALREADY_EXISTS = 36,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PARTITIONS = 37,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REPLICATION_FACTOR = 38,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REPLICA_ASSIGNMENT = 39,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_CONFIG = 40,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_CONTROLLER = 41,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REQUEST = 42,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_FOR_MESSAGE_FORMAT = 43,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_POLICY_VIOLATION = 44,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OUT_OF_ORDER_SEQUENCE_NUMBER = 45,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DUPLICATE_SEQUENCE_NUMBER = 46,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_EPOCH = 47,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TXN_STATE = 48,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_ID_MAPPING = 49,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TRANSACTION_TIMEOUT = 50,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_CONCURRENT_TRANSACTIONS = 51,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TRANSACTION_COORDINATOR_FENCED = 52,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TRANSACTIONAL_ID_AUTHORIZATION_FAILED = 53,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_SECURITY_DISABLED = 54,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OPERATION_NOT_ATTEMPTED = 55,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_KAFKA_STORAGE_ERROR = 56,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LOG_DIR_NOT_FOUND = 57,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_SASL_AUTHENTICATION_FAILED = 58,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_PRODUCER_ID = 59,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REASSIGNMENT_IN_PROGRESS = 60,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTH_DISABLED = 61,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_NOT_FOUND = 62,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_OWNER_MISMATCH = 63,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_REQUEST_NOT_ALLOWED = 64,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTHORIZATION_FAILED = 65,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_EXPIRED = 66,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRINCIPAL_TYPE = 67,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NON_EMPTY_GROUP = 68,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_ID_NOT_FOUND = 69,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FETCH_SESSION_ID_NOT_FOUND = 70,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_FETCH_SESSION_EPOCH = 71,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LISTENER_NOT_FOUND = 72,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_DELETION_DISABLED = 73,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FENCED_LEADER_EPOCH = 74,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_LEADER_EPOCH = 75,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_STALE_BROKER_EPOCH = 77,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_NOT_AVAILABLE = 78,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_MEMBER_ID_REQUIRED = 79,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_PREFERRED_LEADER_NOT_AVAILABLE = 80,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_MAX_SIZE_REACHED = 81,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FENCED_INSTANCE_ID = 82,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ELIGIBLE_LEADERS_NOT_AVAILABLE = 83,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ELECTION_NOT_NEEDED = 84,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NO_REASSIGNMENT_IN_PROGRESS = 85,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_SUBSCRIBED_TO_TOPIC = 86,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_RECORD = 87,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSTABLE_OFFSET_COMMIT = 88,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_THROTTLING_QUOTA_EXCEEDED = 89,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_PRODUCER_FENCED = 90,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_RESOURCE_NOT_FOUND = 91,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DUPLICATE_RESOURCE = 92,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNACCEPTABLE_CREDENTIAL = 93,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INCONSISTENT_VOTER_SET = 94,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_UPDATE_VERSION = 95,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FEATURE_UPDATE_FAILED = 96,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_PRINCIPAL_DESERIALIZATION_FAILURE = 97,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_END_ALL,</span>
<span class="s1">} rd_kafka_resp_err_t;</span>
<span class="s1">struct rd_kafka_err_desc {</span>
<span class="s1">  rd_kafka_resp_err_t code;</span>
<span class="s1">  char *name;</span>
<span class="s1">  char *desc;</span>
<span class="s1">};</span>
<span class="s1">void rd_kafka_get_err_descs(const struct rd_kafka_err_desc **errdescs, size_t *cntp);</span>
<span class="s1">const char *rd_kafka_err2str(rd_kafka_resp_err_t err);</span>
<span class="s1">const char *rd_kafka_err2name(rd_kafka_resp_err_t err);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_last_error(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_errno2err(int errnox);</span>
<span class="s1">int rd_kafka_errno(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_fatal_error(rd_kafka_t *rk, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_test_fatal_error(rd_kafka_t *rk, rd_kafka_resp_err_t err, const char *reason);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_error_code(const rd_kafka_error_t *error);</span>
<span class="s1">const char *rd_kafka_error_name(const rd_kafka_error_t *error);</span>
<span class="s1">const char *rd_kafka_error_string(const rd_kafka_error_t *error);</span>
<span class="s1">int rd_kafka_error_is_fatal(const rd_kafka_error_t *error);</span>
<span class="s1">int rd_kafka_error_is_retriable(const rd_kafka_error_t *error);</span>
<span class="s1">int rd_kafka_error_txn_requires_abort(const rd_kafka_error_t *error);</span>
<span class="s1">void rd_kafka_error_destroy(rd_kafka_error_t *error);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_error_new(rd_kafka_resp_err_t code, const char *fmt, ...);</span>
<span class="s1">typedef struct rd_kafka_topic_partition_s {</span>
<span class="s1">  char *topic;</span>
<span class="s1">  int32_t partition;</span>
<span class="s1">  int64_t offset;</span>
<span class="s1">  void *metadata;</span>
<span class="s1">  size_t metadata_size;</span>
<span class="s1">  void *opaque;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  void *_private;</span>
<span class="s1">} rd_kafka_topic_partition_t;</span>
<span class="s1">void rd_kafka_topic_partition_destroy(rd_kafka_topic_partition_t *rktpar);</span>
<span class="s1">typedef struct rd_kafka_topic_partition_list_s {</span>
<span class="s1">  int cnt;</span>
<span class="s1">  int size;</span>
<span class="s1">  rd_kafka_topic_partition_t *elems;</span>
<span class="s1">} rd_kafka_topic_partition_list_t;</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_new(int size);</span>
<span class="s1">void rd_kafka_topic_partition_list_destroy(rd_kafka_topic_partition_list_t *rkparlist);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_add(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">void rd_kafka_topic_partition_list_add_range(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t start, int32_t stop);</span>
<span class="s1">int rd_kafka_topic_partition_list_del(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">int rd_kafka_topic_partition_list_del_by_idx(rd_kafka_topic_partition_list_t *rktparlist, int idx);</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_copy(const rd_kafka_topic_partition_list_t *src);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_topic_partition_list_set_offset(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition, int64_t offset);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_find(const rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">void rd_kafka_topic_partition_list_sort(rd_kafka_topic_partition_list_t *rktparlist, int (*cmp)(const void *a, const void *b, void *cmp_opaque), void *cmp_opaque);</span>
<span class="s1">typedef enum rd_kafka_vtype_t {</span>
<span class="s1">  RD_KAFKA_VTYPE_END,</span>
<span class="s1">  RD_KAFKA_VTYPE_TOPIC,</span>
<span class="s1">  RD_KAFKA_VTYPE_RKT,</span>
<span class="s1">  RD_KAFKA_VTYPE_PARTITION,</span>
<span class="s1">  RD_KAFKA_VTYPE_VALUE,</span>
<span class="s1">  RD_KAFKA_VTYPE_KEY,</span>
<span class="s1">  RD_KAFKA_VTYPE_OPAQUE,</span>
<span class="s1">  RD_KAFKA_VTYPE_MSGFLAGS,</span>
<span class="s1">  RD_KAFKA_VTYPE_TIMESTAMP,</span>
<span class="s1">  RD_KAFKA_VTYPE_HEADER,</span>
<span class="s1">  RD_KAFKA_VTYPE_HEADERS,</span>
<span class="s1">} rd_kafka_vtype_t;</span>
<span class="s1">typedef struct rd_kafka_vu_s {</span>
<span class="s1">  rd_kafka_vtype_t vtype;</span>
<span class="s1">  union {</span>
<span class="s1">    char *cstr;</span>
<span class="s1">    rd_kafka_topic_t *rkt;</span>
<span class="s1">    int i;</span>
<span class="s1">    int32_t i32;</span>
<span class="s1">    int64_t i64;</span>
<span class="s1">    struct {</span>
<span class="s1">      void *ptr;</span>
<span class="s1">      size_t size;</span>
<span class="s1">    } mem;</span>
<span class="s1">    struct {</span>
<span class="s1">      char *name;</span>
<span class="s1">      void *val;</span>
<span class="s1">      ssize_t size;</span>
<span class="s1">    } header;</span>
<span class="s1">    rd_kafka_headers_t *headers;</span>
<span class="s1">    void *ptr;</span>
<span class="s1">    char _pad[64];</span>
<span class="s1">  } u;</span>
<span class="s1">} rd_kafka_vu_t;</span>
<span class="s1">rd_kafka_headers_t *rd_kafka_headers_new(size_t initial_count);</span>
<span class="s1">void rd_kafka_headers_destroy(rd_kafka_headers_t *hdrs);</span>
<span class="s1">rd_kafka_headers_t *rd_kafka_headers_copy(const rd_kafka_headers_t *src);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_add(rd_kafka_headers_t *hdrs, const char *name, ssize_t name_size, const void *value, ssize_t value_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_remove(rd_kafka_headers_t *hdrs, const char *name);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get_last(const rd_kafka_headers_t *hdrs, const char *name, const void **valuep, size_t *sizep);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get(const rd_kafka_headers_t *hdrs, size_t idx, const char *name, const void **valuep, size_t *sizep);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get_all(const rd_kafka_headers_t *hdrs, size_t idx, const char **namep, const void **valuep, size_t *sizep);</span>
<span class="s1">typedef struct rd_kafka_message_s {</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  rd_kafka_topic_t *rkt;</span>
<span class="s1">  int32_t partition;</span>
<span class="s1">  void *payload;</span>
<span class="s1">  size_t len;</span>
<span class="s1">  void *key;</span>
<span class="s1">  size_t key_len;</span>
<span class="s1">  int64_t offset;</span>
<span class="s1">  void *_private;</span>
<span class="s1">} rd_kafka_message_t;</span>
<span class="s1">void rd_kafka_message_destroy(rd_kafka_message_t *rkmessage);</span>
<span class="s1">const char *rd_kafka_message_errstr(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">int64_t rd_kafka_message_timestamp(const rd_kafka_message_t *rkmessage, rd_kafka_timestamp_type_t *tstype);</span>
<span class="s1">int64_t rd_kafka_message_latency(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">int32_t rd_kafka_message_broker_id(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_message_headers(const rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_message_detach_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);</span>
<span class="s1">void rd_kafka_message_set_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t *hdrs);</span>
<span class="s1">size_t rd_kafka_header_cnt(const rd_kafka_headers_t *hdrs);</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_NOT_PERSISTED = 0,</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_POSSIBLY_PERSISTED = 1,</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_PERSISTED = 2,</span>
<span class="s1">} rd_kafka_msg_status_t;</span>
<span class="s1">rd_kafka_msg_status_t rd_kafka_message_status(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_CONF_UNKNOWN = (- 2),</span>
<span class="s1">  RD_KAFKA_CONF_INVALID = (- 1),</span>
<span class="s1">  RD_KAFKA_CONF_OK = 0,</span>
<span class="s1">} rd_kafka_conf_res_t;</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_new(void);</span>
<span class="s1">void rd_kafka_conf_destroy(rd_kafka_conf_t *conf);</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_dup(const rd_kafka_conf_t *conf);</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_dup_filter(const rd_kafka_conf_t *conf, size_t filter_cnt, const char **filter);</span>
<span class="s1">const rd_kafka_conf_t *rd_kafka_conf(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_set(rd_kafka_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_conf_set_events(rd_kafka_conf_t *conf, int events);</span>
<span class="s1">void rd_kafka_conf_set_background_event_cb(rd_kafka_conf_t *conf, void (*event_cb)(rd_kafka_t *rk, rd_kafka_event_t *rkev, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_dr_cb(rd_kafka_conf_t *conf, void (*dr_cb)(rd_kafka_t *rk, void *payload, size_t len, rd_kafka_resp_err_t err, void *opaque, void *msg_opaque));</span>
<span class="s1">void rd_kafka_conf_set_dr_msg_cb(rd_kafka_conf_t *conf, void (*dr_msg_cb)(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_consume_cb(rd_kafka_conf_t *conf, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_rebalance_cb(rd_kafka_conf_t *conf, void (*rebalance_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *partitions, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_offset_commit_cb(rd_kafka_conf_t *conf, void (*offset_commit_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_error_cb(rd_kafka_conf_t *conf, void (*error_cb)(rd_kafka_t *rk, int err, const char *reason, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_throttle_cb(rd_kafka_conf_t *conf, void (*throttle_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int throttle_time_ms, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_log_cb(rd_kafka_conf_t *conf, void (*log_cb)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));</span>
<span class="s1">void rd_kafka_conf_set_stats_cb(rd_kafka_conf_t *conf, int (*stats_cb)(rd_kafka_t *rk, char *json, size_t json_len, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_oauthbearer_token_refresh_cb(rd_kafka_conf_t *conf, void (*oauthbearer_token_refresh_cb)(rd_kafka_t *rk, const char *oauthbearer_config, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_socket_cb(rd_kafka_conf_t *conf, int (*socket_cb)(int domain, int type, int protocol, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_connect_cb(rd_kafka_conf_t *conf, int (*connect_cb)(int sockfd, const struct sockaddr *addr, int addrlen, const char *id, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_closesocket_cb(rd_kafka_conf_t *conf, int (*closesocket_cb)(int sockfd, void *opaque));</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert_verify_cb(rd_kafka_conf_t *conf, int (*ssl_cert_verify_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int *x509_error, int depth, const char *buf, size_t size, char *errstr, size_t errstr_size, void *opaque));</span>
<span class="s1">typedef enum rd_kafka_cert_type_t {</span>
<span class="s1">  RD_KAFKA_CERT_PUBLIC_KEY,</span>
<span class="s1">  RD_KAFKA_CERT_PRIVATE_KEY,</span>
<span class="s1">  RD_KAFKA_CERT_CA,</span>
<span class="s1">  RD_KAFKA_CERT__CNT,</span>
<span class="s1">} rd_kafka_cert_type_t;</span>
<span class="s1">typedef enum rd_kafka_cert_enc_t {</span>
<span class="s1">  RD_KAFKA_CERT_ENC_PKCS12,</span>
<span class="s1">  RD_KAFKA_CERT_ENC_DER,</span>
<span class="s1">  RD_KAFKA_CERT_ENC_PEM,</span>
<span class="s1">  RD_KAFKA_CERT_ENC__CNT,</span>
<span class="s1">} rd_kafka_cert_enc_t;</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert(rd_kafka_conf_t *conf, rd_kafka_cert_type_t cert_type, rd_kafka_cert_enc_t cert_enc, const void *buffer, size_t size, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_conf_set_opaque(rd_kafka_conf_t *conf, void *opaque);</span>
<span class="s1">void *rd_kafka_opaque(const rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_conf_set_default_topic_conf(rd_kafka_conf_t *conf, rd_kafka_topic_conf_t *tconf);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_conf_get_default_topic_conf(rd_kafka_conf_t *conf);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_get(const rd_kafka_conf_t *conf, const char *name, char *dest, size_t *dest_size);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_topic_conf_get(const rd_kafka_topic_conf_t *conf, const char *name, char *dest, size_t *dest_size);</span>
<span class="s1">const char **rd_kafka_conf_dump(rd_kafka_conf_t *conf, size_t *cntp);</span>
<span class="s1">const char **rd_kafka_topic_conf_dump(rd_kafka_topic_conf_t *conf, size_t *cntp);</span>
<span class="s1">void rd_kafka_conf_dump_free(const char **arr, size_t cnt);</span>
<span class="s1">void rd_kafka_conf_properties_show(FILE *fp);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_topic_conf_new(void);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_topic_conf_dup(const rd_kafka_topic_conf_t *conf);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_default_topic_conf_dup(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_topic_conf_destroy(rd_kafka_topic_conf_t *topic_conf);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_topic_conf_set(rd_kafka_topic_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_topic_conf_set_opaque(rd_kafka_topic_conf_t *conf, void *rkt_opaque);</span>
<span class="s1">void rd_kafka_topic_conf_set_partitioner_cb(rd_kafka_topic_conf_t *topic_conf, int32_t (*partitioner)(const rd_kafka_topic_t *rkt, const void *keydata, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque));</span>
<span class="s1">void rd_kafka_topic_conf_set_msg_order_cmp(rd_kafka_topic_conf_t *topic_conf, int (*msg_order_cmp)(const rd_kafka_message_t *a, const rd_kafka_message_t *b));</span>
<span class="s1">int rd_kafka_topic_partition_available(const rd_kafka_topic_t *rkt, int32_t partition);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_consistent(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_consistent_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_murmur2(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_murmur2_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_fnv1a(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_fnv1a_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">rd_kafka_t *rd_kafka_new(rd_kafka_type_t type, rd_kafka_conf_t *conf, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_destroy(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_destroy_flags(rd_kafka_t *rk, int flags);</span>
<span class="s1">const char *rd_kafka_name(const rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_type_t rd_kafka_type(const rd_kafka_t *rk);</span>
<span class="s1">char *rd_kafka_memberid(const rd_kafka_t *rk);</span>
<span class="s1">char *rd_kafka_clusterid(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">int32_t rd_kafka_controllerid(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_topic_t *rd_kafka_topic_new(rd_kafka_t *rk, const char *topic, rd_kafka_topic_conf_t *conf);</span>
<span class="s1">void rd_kafka_topic_destroy(rd_kafka_topic_t *rkt);</span>
<span class="s1">const char *rd_kafka_topic_name(const rd_kafka_topic_t *rkt);</span>
<span class="s1">void *rd_kafka_topic_opaque(const rd_kafka_topic_t *rkt);</span>
<span class="s1">int rd_kafka_poll(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">void rd_kafka_yield(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_pause_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_resume_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_query_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_get_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offsets_for_times(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets, int timeout_ms);</span>
<span class="s1">void rd_kafka_mem_free(rd_kafka_t *rk, void *ptr);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_new(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_queue_destroy(rd_kafka_queue_t *rkqu);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_main(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_consumer(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_partition(rd_kafka_t *rk, const char *topic, int32_t partition);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_background(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_queue_forward(rd_kafka_queue_t *src, rd_kafka_queue_t *dst);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_set_log_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu);</span>
<span class="s1">size_t rd_kafka_queue_length(rd_kafka_queue_t *rkqu);</span>
<span class="s1">void rd_kafka_queue_io_event_enable(rd_kafka_queue_t *rkqu, int fd, const void *payload, size_t size);</span>
<span class="s1">void rd_kafka_queue_cb_event_enable(rd_kafka_queue_t *rkqu, void (*event_cb)(rd_kafka_t *rk, void *qev_opaque), void *qev_opaque);</span>
<span class="s1">void rd_kafka_queue_yield(rd_kafka_queue_t *rkqu);</span>
<span class="s1">int rd_kafka_consume_start(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);</span>
<span class="s1">int rd_kafka_consume_start_queue(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, rd_kafka_queue_t *rkqu);</span>
<span class="s1">int rd_kafka_consume_stop(rd_kafka_topic_t *rkt, int32_t partition);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_seek(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, int timeout_ms);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_seek_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consume(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms);</span>
<span class="s1">ssize_t rd_kafka_consume_batch(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);</span>
<span class="s1">int rd_kafka_consume_callback(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consume_queue(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">ssize_t rd_kafka_consume_batch_queue(rd_kafka_queue_t *rkqu, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);</span>
<span class="s1">int rd_kafka_consume_callback_queue(rd_kafka_queue_t *rkqu, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offset_store(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offsets_store(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_subscribe(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *topics);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_unsubscribe(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_subscription(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **topics);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consumer_poll(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_consumer_close(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_incremental_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_incremental_unassign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">const char *rd_kafka_rebalance_protocol(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_assignment(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **partitions);</span>
<span class="s1">int rd_kafka_assignment_lost(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, int async);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit_message(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, int async);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit_queue(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_queue_t *rkqu, void (*cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *commit_opaque), void *commit_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_committed(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_position(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata_new(const char *group_id);</span>
<span class="s1">rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata_new_with_genid(const char *group_id, int32_t generation_id, const char *member_id, const char *group_instance_id);</span>
<span class="s1">void rd_kafka_consumer_group_metadata_destroy(rd_kafka_consumer_group_metadata_t *);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_consumer_group_metadata_write(const rd_kafka_consumer_group_metadata_t *cgmd, void **bufferp, size_t *sizep);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_consumer_group_metadata_read(rd_kafka_consumer_group_metadata_t **cgmdp, const void *buffer, size_t size);</span>
<span class="s1">int rd_kafka_produce(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, void *payload, size_t len, const void *key, size_t keylen, void *msg_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_producev(rd_kafka_t *rk, ...);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_produceva(rd_kafka_t *rk, const rd_kafka_vu_t *vus, size_t cnt);</span>
<span class="s1">int rd_kafka_produce_batch(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, rd_kafka_message_t *rkmessages, int message_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_flush(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_purge(rd_kafka_t *rk, int purge_flags);</span>
<span class="s1">typedef struct rd_kafka_metadata_broker {</span>
<span class="s1">  int32_t id;</span>
<span class="s1">  char *host;</span>
<span class="s1">  int port;</span>
<span class="s1">} rd_kafka_metadata_broker_t;</span>
<span class="s1">typedef struct rd_kafka_metadata_partition {</span>
<span class="s1">  int32_t id;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  int32_t leader;</span>
<span class="s1">  int replica_cnt;</span>
<span class="s1">  int32_t *replicas;</span>
<span class="s1">  int isr_cnt;</span>
<span class="s1">  int32_t *isrs;</span>
<span class="s1">} rd_kafka_metadata_partition_t;</span>
<span class="s1">typedef struct rd_kafka_metadata_topic {</span>
<span class="s1">  char *topic;</span>
<span class="s1">  int partition_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_partition *partitions;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">} rd_kafka_metadata_topic_t;</span>
<span class="s1">typedef struct rd_kafka_metadata {</span>
<span class="s1">  int broker_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_broker *brokers;</span>
<span class="s1">  int topic_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_topic *topics;</span>
<span class="s1">  int32_t orig_broker_id;</span>
<span class="s1">  char *orig_broker_name;</span>
<span class="s1">} rd_kafka_metadata_t;</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_metadata(rd_kafka_t *rk, int all_topics, rd_kafka_topic_t *only_rkt, const struct rd_kafka_metadata **metadatap, int timeout_ms);</span>
<span class="s1">void rd_kafka_metadata_destroy(const struct rd_kafka_metadata *metadata);</span>
<span class="s1">struct rd_kafka_group_member_info {</span>
<span class="s1">  char *member_id;</span>
<span class="s1">  char *client_id;</span>
<span class="s1">  char *client_host;</span>
<span class="s1">  void *member_metadata;</span>
<span class="s1">  int member_metadata_size;</span>
<span class="s1">  void *member_assignment;</span>
<span class="s1">  int member_assignment_size;</span>
<span class="s1">};</span>
<span class="s1">struct rd_kafka_group_info {</span>
<span class="s1">  struct rd_kafka_metadata_broker broker;</span>
<span class="s1">  char *group;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  char *state;</span>
<span class="s1">  char *protocol_type;</span>
<span class="s1">  char *protocol;</span>
<span class="s1">  struct rd_kafka_group_member_info *members;</span>
<span class="s1">  int member_cnt;</span>
<span class="s1">};</span>
<span class="s1">struct rd_kafka_group_list {</span>
<span class="s1">  struct rd_kafka_group_info *groups;</span>
<span class="s1">  int group_cnt;</span>
<span class="s1">};</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_list_groups(rd_kafka_t *rk, const char *group, const struct rd_kafka_group_list **grplistp, int timeout_ms);</span>
<span class="s1">void rd_kafka_group_list_destroy(const struct rd_kafka_group_list *grplist);</span>
<span class="s1">int rd_kafka_brokers_add(rd_kafka_t *rk, const char *brokerlist);</span>
<span class="s1">void rd_kafka_set_logger(rd_kafka_t *rk, void (*func)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));</span>
<span class="s1">void rd_kafka_set_log_level(rd_kafka_t *rk, int level);</span>
<span class="s1">void rd_kafka_log_print(const rd_kafka_t *rk, int level, const char *fac, const char *buf);</span>
<span class="s1">void rd_kafka_log_syslog(const rd_kafka_t *rk, int level, const char *fac, const char *buf);</span>
<span class="s1">int rd_kafka_outq_len(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_dump(FILE *fp, rd_kafka_t *rk);</span>
<span class="s1">int rd_kafka_thread_cnt(void);</span>
<span class="s1">typedef enum rd_kafka_thread_type_t {</span>
<span class="s1">  RD_KAFKA_THREAD_MAIN,</span>
<span class="s1">  RD_KAFKA_THREAD_BACKGROUND,</span>
<span class="s1">  RD_KAFKA_THREAD_BROKER,</span>
<span class="s1">} rd_kafka_thread_type_t;</span>
<span class="s1">int rd_kafka_wait_destroyed(int timeout_ms);</span>
<span class="s1">int rd_kafka_unittest(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_poll_set_consumer(rd_kafka_t *rk);</span>
<span class="s1">typedef int rd_kafka_event_type_t;</span>
<span class="s1">rd_kafka_event_type_t rd_kafka_event_type(const rd_kafka_event_t *rkev);</span>
<span class="s1">const char *rd_kafka_event_name(const rd_kafka_event_t *rkev);</span>
<span class="s1">void rd_kafka_event_destroy(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_message_t *rd_kafka_event_message_next(rd_kafka_event_t *rkev);</span>
<span class="s1">size_t rd_kafka_event_message_array(rd_kafka_event_t *rkev, const rd_kafka_message_t **rkmessages, size_t size);</span>
<span class="s1">size_t rd_kafka_event_message_count(rd_kafka_event_t *rkev);</span>
<span class="s1">const char *rd_kafka_event_config_string(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_event_error(rd_kafka_event_t *rkev);</span>
<span class="s1">const char *rd_kafka_event_error_string(rd_kafka_event_t *rkev);</span>
<span class="s1">int rd_kafka_event_error_is_fatal(rd_kafka_event_t *rkev);</span>
<span class="s1">void *rd_kafka_event_opaque(rd_kafka_event_t *rkev);</span>
<span class="s1">int rd_kafka_event_log(rd_kafka_event_t *rkev, const char **fac, const char **str, int *level);</span>
<span class="s1">int rd_kafka_event_debug_contexts(rd_kafka_event_t *rkev, char *dst, size_t dstsize);</span>
<span class="s1">const char *rd_kafka_event_stats(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_event_topic_partition_list(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_event_topic_partition(rd_kafka_event_t *rkev);</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_CreateTopics_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DeleteTopics_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_CreatePartitions_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_AlterConfigs_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DescribeConfigs_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DeleteRecords_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DeleteGroups_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DeleteConsumerGroupOffsets_result_t;</span>
<span class="s1">const rd_kafka_CreateTopics_result_t *rd_kafka_event_CreateTopics_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DeleteTopics_result_t *rd_kafka_event_DeleteTopics_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_CreatePartitions_result_t *rd_kafka_event_CreatePartitions_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_AlterConfigs_result_t *rd_kafka_event_AlterConfigs_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DescribeConfigs_result_t *rd_kafka_event_DescribeConfigs_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DeleteRecords_result_t *rd_kafka_event_DeleteRecords_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DeleteGroups_result_t *rd_kafka_event_DeleteGroups_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DeleteConsumerGroupOffsets_result_t *rd_kafka_event_DeleteConsumerGroupOffsets_result(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_event_t *rd_kafka_queue_poll(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">int rd_kafka_queue_poll_callback(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_plugin_f_conf_init_t)(rd_kafka_conf_t *conf, void **plug_opaquep, char *errstr, size_t errstr_size);</span>
<span class="s1">typedef rd_kafka_conf_res_t (rd_kafka_interceptor_f_on_conf_set_t)(rd_kafka_conf_t *conf, const char *name, const char *val, char *errstr, size_t errstr_size, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_dup_t)(rd_kafka_conf_t *new_conf, const rd_kafka_conf_t *old_conf, size_t filter_cnt, const char **filter, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_destroy_t)(void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_new_t)(rd_kafka_t *rk, const rd_kafka_conf_t *conf, void *ic_opaque, char *errstr, size_t errstr_size);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_destroy_t)(rd_kafka_t *rk, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_send_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_acknowledgement_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_consume_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_commit_t)(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_resp_err_t err, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_request_sent_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_response_received_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, int64_t rtt, rd_kafka_resp_err_t err, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_start_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_exit_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_set(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_set_t *on_conf_set, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_dup(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_dup_t *on_conf_dup, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_destroy(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_destroy_t *on_conf_destroy, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_new(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_new_t *on_new, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_destroy(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_destroy_t *on_destroy, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_send(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_send_t *on_send, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_acknowledgement(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_acknowledgement_t *on_acknowledgement, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_consume(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_consume_t *on_consume, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_commit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_commit_t *on_commit, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_request_sent(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_request_sent_t *on_request_sent, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_response_received(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_response_received_t *on_response_received, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_start(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_start_t *on_thread_start, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_exit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_exit_t *on_thread_exit, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_topic_result_error(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">const char *rd_kafka_topic_result_error_string(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">const char *rd_kafka_topic_result_name(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">const rd_kafka_error_t *rd_kafka_group_result_error(const rd_kafka_group_result_t *groupres);</span>
<span class="s1">const char *rd_kafka_group_result_name(const rd_kafka_group_result_t *groupres);</span>
<span class="s1">const rd_kafka_topic_partition_list_t *rd_kafka_group_result_partitions(const rd_kafka_group_result_t *groupres);</span>
<span class="s1">typedef enum rd_kafka_admin_op_t {</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_ANY = 0,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_CREATETOPICS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DELETETOPICS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_CREATEPARTITIONS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_ALTERCONFIGS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DESCRIBECONFIGS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DELETERECORDS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DELETEGROUPS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DELETECONSUMERGROUPOFFSETS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP__CNT,</span>
<span class="s1">} rd_kafka_admin_op_t;</span>
<span class="s1">typedef struct rd_kafka_AdminOptions_s rd_kafka_AdminOptions_t;</span>
<span class="s1">rd_kafka_AdminOptions_t *rd_kafka_AdminOptions_new(rd_kafka_t *rk, rd_kafka_admin_op_t for_api);</span>
<span class="s1">void rd_kafka_AdminOptions_destroy(rd_kafka_AdminOptions_t *options);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_request_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_operation_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_validate_only(rd_kafka_AdminOptions_t *options, int true_or_false, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_broker(rd_kafka_AdminOptions_t *options, int32_t broker_id, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_AdminOptions_set_opaque(rd_kafka_AdminOptions_t *options, void *ev_opaque);</span>
<span class="s1">typedef struct rd_kafka_NewTopic_s rd_kafka_NewTopic_t;</span>
<span class="s1">rd_kafka_NewTopic_t *rd_kafka_NewTopic_new(const char *topic, int num_partitions, int replication_factor, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_NewTopic_destroy(rd_kafka_NewTopic_t *new_topic);</span>
<span class="s1">void rd_kafka_NewTopic_destroy_array(rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewTopic_set_replica_assignment(rd_kafka_NewTopic_t *new_topic, int32_t partition, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewTopic_set_config(rd_kafka_NewTopic_t *new_topic, const char *name, const char *value);</span>
<span class="s1">void rd_kafka_CreateTopics(rd_kafka_t *rk, rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_CreateTopics_result_topics(const rd_kafka_CreateTopics_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_DeleteTopic_s rd_kafka_DeleteTopic_t;</span>
<span class="s1">rd_kafka_DeleteTopic_t *rd_kafka_DeleteTopic_new(const char *topic);</span>
<span class="s1">void rd_kafka_DeleteTopic_destroy(rd_kafka_DeleteTopic_t *del_topic);</span>
<span class="s1">void rd_kafka_DeleteTopic_destroy_array(rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt);</span>
<span class="s1">void rd_kafka_DeleteTopics(rd_kafka_t *rk, rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_DeleteTopics_result_topics(const rd_kafka_DeleteTopics_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_NewPartitions_s rd_kafka_NewPartitions_t;</span>
<span class="s1">rd_kafka_NewPartitions_t *rd_kafka_NewPartitions_new(const char *topic, size_t new_total_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_NewPartitions_destroy(rd_kafka_NewPartitions_t *new_parts);</span>
<span class="s1">void rd_kafka_NewPartitions_destroy_array(rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewPartitions_set_replica_assignment(rd_kafka_NewPartitions_t *new_parts, int32_t new_partition_idx, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_CreatePartitions(rd_kafka_t *rk, rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_CreatePartitions_result_topics(const rd_kafka_CreatePartitions_result_t *result, size_t *cntp);</span>
<span class="s1">typedef enum rd_kafka_ConfigSource_t {</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_UNKNOWN_CONFIG = 0,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_TOPIC_CONFIG = 1,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_BROKER_CONFIG = 2,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_DEFAULT_BROKER_CONFIG = 3,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_STATIC_BROKER_CONFIG = 4,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DEFAULT_CONFIG = 5,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE__CNT,</span>
<span class="s1">} rd_kafka_ConfigSource_t;</span>
<span class="s1">const char *rd_kafka_ConfigSource_name(rd_kafka_ConfigSource_t confsource);</span>
<span class="s1">typedef struct rd_kafka_ConfigEntry_s rd_kafka_ConfigEntry_t;</span>
<span class="s1">const char *rd_kafka_ConfigEntry_name(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">const char *rd_kafka_ConfigEntry_value(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">rd_kafka_ConfigSource_t rd_kafka_ConfigEntry_source(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_read_only(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_default(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_sensitive(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_synonym(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">const rd_kafka_ConfigEntry_t **rd_kafka_ConfigEntry_synonyms(const rd_kafka_ConfigEntry_t *entry, size_t *cntp);</span>
<span class="s1">typedef enum rd_kafka_ResourceType_t {</span>
<span class="s1">  RD_KAFKA_RESOURCE_UNKNOWN = 0,</span>
<span class="s1">  RD_KAFKA_RESOURCE_ANY = 1,</span>
<span class="s1">  RD_KAFKA_RESOURCE_TOPIC = 2,</span>
<span class="s1">  RD_KAFKA_RESOURCE_GROUP = 3,</span>
<span class="s1">  RD_KAFKA_RESOURCE_BROKER = 4,</span>
<span class="s1">  RD_KAFKA_RESOURCE__CNT,</span>
<span class="s1">} rd_kafka_ResourceType_t;</span>
<span class="s1">const char *rd_kafka_ResourceType_name(rd_kafka_ResourceType_t restype);</span>
<span class="s1">typedef struct rd_kafka_ConfigResource_s rd_kafka_ConfigResource_t;</span>
<span class="s1">rd_kafka_ConfigResource_t *rd_kafka_ConfigResource_new(rd_kafka_ResourceType_t restype, const char *resname);</span>
<span class="s1">void rd_kafka_ConfigResource_destroy(rd_kafka_ConfigResource_t *config);</span>
<span class="s1">void rd_kafka_ConfigResource_destroy_array(rd_kafka_ConfigResource_t **config, size_t config_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_ConfigResource_set_config(rd_kafka_ConfigResource_t *config, const char *name, const char *value);</span>
<span class="s1">const rd_kafka_ConfigEntry_t **rd_kafka_ConfigResource_configs(const rd_kafka_ConfigResource_t *config, size_t *cntp);</span>
<span class="s1">rd_kafka_ResourceType_t rd_kafka_ConfigResource_type(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">const char *rd_kafka_ConfigResource_name(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_ConfigResource_error(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">const char *rd_kafka_ConfigResource_error_string(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">void rd_kafka_AlterConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_ConfigResource_t **rd_kafka_AlterConfigs_result_resources(const rd_kafka_AlterConfigs_result_t *result, size_t *cntp);</span>
<span class="s1">void rd_kafka_DescribeConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_ConfigResource_t **rd_kafka_DescribeConfigs_result_resources(const rd_kafka_DescribeConfigs_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_DeleteRecords_s rd_kafka_DeleteRecords_t;</span>
<span class="s1">rd_kafka_DeleteRecords_t *rd_kafka_DeleteRecords_new(const rd_kafka_topic_partition_list_t *before_offsets);</span>
<span class="s1">void rd_kafka_DeleteRecords_destroy(rd_kafka_DeleteRecords_t *del_records);</span>
<span class="s1">void rd_kafka_DeleteRecords_destroy_array(rd_kafka_DeleteRecords_t **del_records, size_t del_record_cnt);</span>
<span class="s1">void rd_kafka_DeleteRecords(rd_kafka_t *rk, rd_kafka_DeleteRecords_t **del_records, size_t del_record_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_partition_list_t *rd_kafka_DeleteRecords_result_offsets(const rd_kafka_DeleteRecords_result_t *result);</span>
<span class="s1">typedef struct rd_kafka_DeleteGroup_s rd_kafka_DeleteGroup_t;</span>
<span class="s1">rd_kafka_DeleteGroup_t *rd_kafka_DeleteGroup_new(const char *group);</span>
<span class="s1">void rd_kafka_DeleteGroup_destroy(rd_kafka_DeleteGroup_t *del_group);</span>
<span class="s1">void rd_kafka_DeleteGroup_destroy_array(rd_kafka_DeleteGroup_t **del_groups, size_t del_group_cnt);</span>
<span class="s1">void rd_kafka_DeleteGroups(rd_kafka_t *rk, rd_kafka_DeleteGroup_t **del_groups, size_t del_group_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_group_result_t **rd_kafka_DeleteGroups_result_groups(const rd_kafka_DeleteGroups_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_DeleteConsumerGroupOffsets_s rd_kafka_DeleteConsumerGroupOffsets_t;</span>
<span class="s1">rd_kafka_DeleteConsumerGroupOffsets_t *rd_kafka_DeleteConsumerGroupOffsets_new(const char *group, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">void rd_kafka_DeleteConsumerGroupOffsets_destroy(rd_kafka_DeleteConsumerGroupOffsets_t *del_grpoffsets);</span>
<span class="s1">void rd_kafka_DeleteConsumerGroupOffsets_destroy_array(rd_kafka_DeleteConsumerGroupOffsets_t **del_grpoffsets, size_t del_grpoffset_cnt);</span>
<span class="s1">void rd_kafka_DeleteConsumerGroupOffsets(rd_kafka_t *rk, rd_kafka_DeleteConsumerGroupOffsets_t **del_grpoffsets, size_t del_grpoffsets_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_group_result_t **rd_kafka_DeleteConsumerGroupOffsets_result_groups(const rd_kafka_DeleteConsumerGroupOffsets_result_t *result, size_t *cntp);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token(rd_kafka_t *rk, const char *token_value, int64_t md_lifetime_ms, const char *md_principal_name, const char **extensions, size_t extension_size, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token_failure(rd_kafka_t *rk, const char *errstr);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_init_transactions(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_begin_transaction(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_send_offsets_to_transaction(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, const rd_kafka_consumer_group_metadata_t *cgmetadata, int timeout_ms);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_commit_transaction(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_abort_transaction(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">typedef struct rd_kafka_mock_cluster_s rd_kafka_mock_cluster_t;</span>
<span class="s1">rd_kafka_mock_cluster_t *rd_kafka_mock_cluster_new(rd_kafka_t *rk, int broker_cnt);</span>
<span class="s1">void rd_kafka_mock_cluster_destroy(rd_kafka_mock_cluster_t *mcluster);</span>
<span class="s1">rd_kafka_t *rd_kafka_mock_cluster_handle(const rd_kafka_mock_cluster_t *mcluster);</span>
<span class="s1">rd_kafka_mock_cluster_t *rd_kafka_handle_mock_cluster(const rd_kafka_t *rk);</span>
<span class="s1">const char *rd_kafka_mock_cluster_bootstraps(const rd_kafka_mock_cluster_t *mcluster);</span>
<span class="s1">void rd_kafka_mock_clear_request_errors(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey);</span>
<span class="s1">void rd_kafka_mock_push_request_errors(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, size_t cnt, ...);</span>
<span class="s1">void rd_kafka_mock_push_request_errors_array(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, size_t cnt, const rd_kafka_resp_err_t *errors);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_push_request_errors(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int16_t ApiKey, size_t cnt, ...);</span>
<span class="s1">void rd_kafka_mock_topic_set_error(rd_kafka_mock_cluster_t *mcluster, const char *topic, rd_kafka_resp_err_t err);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_topic_create(rd_kafka_mock_cluster_t *mcluster, const char *topic, int partition_cnt, int replication_factor);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_partition_set_leader(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_partition_set_follower(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_partition_set_follower_wmarks(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int64_t lo, int64_t hi);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_set_down(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_set_up(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_set_rtt(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int rtt_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_set_rack(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, const char *rack);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_coordinator_set(rd_kafka_mock_cluster_t *mcluster, const char *key_type, const char *key, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_set_apiversion(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, int16_t MinVersion, int16_t MaxVersion);</span>
<span class="s1">&#39;</span>
</code></pre></div>
rdkafka.h, rdkafka_mock.h</p>
<h3 id="rd_kafka_version_15">RD_KAFKA_VERSION<a class="headerlink" href="#rd_kafka_version_15" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_VERSION</span> <span class="o">=</span> <span class="mi">17171199</span>
</code></pre></div>
<p>librdkafka version </p>
<p>Interpreted as hex <code>MM.mm.rr.xx</code>:</p>
<ul>
<li>MM = Major</li>
<li>mm = minor</li>
<li>rr = revision</li>
<li>xx = pre-release id (0xff is the final release)</li>
</ul>
<p>E.g.: <code>0x000801ff</code> = 0.8.1</p>
<dl class="section remark"><dt>Remarks</dt><dd>This value should only be used during compile time, for runtime checks of version use rd_kafka_version() </dd></dl>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_unsupported_compression_type_15">RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE<a class="headerlink" href="#rd_kafka_resp_err_unsupported_compression_type_15" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE</span> <span class="o">=</span> <span class="mi">76</span>
</code></pre></div>
<p>Unsupported compression type </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_end_all_15">RD_KAFKA_RESP_ERR_END_ALL<a class="headerlink" href="#rd_kafka_resp_err_end_all_15" title="Permanent link">&para;</a></h3>
<p><div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_END_ALL</span> <span class="o">=</span> <span class="mi">98</span>
</code></pre></div>
enum rd_kafka_resp_err_t</p>
<h3 id="rd_kafka_admin_op__cnt_15">RD_KAFKA_ADMIN_OP__CNT<a class="headerlink" href="#rd_kafka_admin_op__cnt_15" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_ADMIN_OP__CNT</span> <span class="o">=</span> <span class="mi">9</span>
</code></pre></div>
<p>Number of ops defined </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe </a></li>
</ul>
</div>
<h3 id="rd_kafka_resource__cnt_15">RD_KAFKA_RESOURCE__CNT<a class="headerlink" href="#rd_kafka_resource__cnt_15" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESOURCE__CNT</span> <span class="o">=</span> <span class="mi">5</span>
</code></pre></div>
<p>Number of resource types defined </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#acca83a66d7783ff7683ed2691cc907c9"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#acca83a66d7783ff7683ed2691cc907c9 </a></li>
</ul>
</div>
<h3 id="rd_kafka_cdef_15">RD_KAFKA_CDEF<a class="headerlink" href="#rd_kafka_cdef_15" title="Permanent link">&para;</a></h3>
<p><div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_CDEF</span> <span class="o">=</span> <span class="s1">&#39;typedef long int ssize_t;</span>
<span class="s1">typedef struct _IO_FILE FILE;</span>
<span class="s1">typedef long int mode_t;</span>
<span class="s1">typedef signed int int16_t;</span>
<span class="s1">typedef unsigned int uint16_t;</span>
<span class="s1">typedef signed int int32_t;</span>
<span class="s1">typedef signed long int int64_t;</span>
<span class="s1">int rd_kafka_version(void);</span>
<span class="s1">const char *rd_kafka_version_str(void);</span>
<span class="s1">typedef enum rd_kafka_type_t {</span>
<span class="s1">  RD_KAFKA_PRODUCER,</span>
<span class="s1">  RD_KAFKA_CONSUMER,</span>
<span class="s1">} rd_kafka_type_t;</span>
<span class="s1">typedef enum rd_kafka_timestamp_type_t {</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_NOT_AVAILABLE,</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_CREATE_TIME,</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_LOG_APPEND_TIME,</span>
<span class="s1">} rd_kafka_timestamp_type_t;</span>
<span class="s1">const char *rd_kafka_get_debug_contexts(void);</span>
<span class="s1">typedef struct rd_kafka_s rd_kafka_t;</span>
<span class="s1">typedef struct rd_kafka_topic_s rd_kafka_topic_t;</span>
<span class="s1">typedef struct rd_kafka_conf_s rd_kafka_conf_t;</span>
<span class="s1">typedef struct rd_kafka_topic_conf_s rd_kafka_topic_conf_t;</span>
<span class="s1">typedef struct rd_kafka_queue_s rd_kafka_queue_t;</span>
<span class="s1">typedef struct rd_kafka_op_s rd_kafka_event_t;</span>
<span class="s1">typedef struct rd_kafka_topic_result_s rd_kafka_topic_result_t;</span>
<span class="s1">typedef struct rd_kafka_consumer_group_metadata_s rd_kafka_consumer_group_metadata_t;</span>
<span class="s1">typedef struct rd_kafka_error_s {</span>
<span class="s1">  unsigned int code;</span>
<span class="s1">  char *errstr;</span>
<span class="s1">  unsigned char fatal;</span>
<span class="s1">  unsigned char retriable;</span>
<span class="s1">  unsigned char txn_requires_abort;</span>
<span class="s1">} rd_kafka_error_t;</span>
<span class="s1">typedef struct rd_kafka_headers_s rd_kafka_headers_t;</span>
<span class="s1">typedef struct rd_kafka_group_result_s rd_kafka_group_result_t;</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BEGIN = (- 200),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BAD_MSG = (- 199),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BAD_COMPRESSION = (- 198),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__DESTROY = (- 197),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FAIL = (- 196),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TRANSPORT = (- 195),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__CRIT_SYS_RESOURCE = (- 194),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__RESOLVE = (- 193),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__MSG_TIMED_OUT = (- 192),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PARTITION_EOF = (- 191),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION = (- 190),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FS = (- 189),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC = (- 188),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ALL_BROKERS_DOWN = (- 187),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INVALID_ARG = (- 186),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TIMED_OUT = (- 185),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__QUEUE_FULL = (- 184),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ISR_INSUFF = (- 183),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NODE_UPDATE = (- 182),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__SSL = (- 181),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__WAIT_COORD = (- 180),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_GROUP = (- 179),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__IN_PROGRESS = (- 178),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PREV_IN_PROGRESS = (- 177),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__EXISTING_SUBSCRIPTION = (- 176),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS = (- 175),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS = (- 174),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__CONFLICT = (- 173),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__STATE = (- 172),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_PROTOCOL = (- 171),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED = (- 170),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__AUTHENTICATION = (- 169),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NO_OFFSET = (- 168),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__OUTDATED = (- 167),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TIMED_OUT_QUEUE = (- 166),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNSUPPORTED_FEATURE = (- 165),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__WAIT_CACHE = (- 164),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INTR = (- 163),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__KEY_SERIALIZATION = (- 162),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__VALUE_SERIALIZATION = (- 161),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__KEY_DESERIALIZATION = (- 160),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__VALUE_DESERIALIZATION = (- 159),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PARTIAL = (- 158),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__READ_ONLY = (- 157),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOENT = (- 156),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNDERFLOW = (- 155),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INVALID_TYPE = (- 154),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__RETRY = (- 153),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PURGE_QUEUE = (- 152),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PURGE_INFLIGHT = (- 151),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FATAL = (- 150),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INCONSISTENT = (- 149),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__GAPLESS_GUARANTEE = (- 148),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__MAX_POLL_EXCEEDED = (- 147),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_BROKER = (- 146),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOT_CONFIGURED = (- 145),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FENCED = (- 144),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__APPLICATION = (- 143),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ASSIGNMENT_LOST = (- 142),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOOP = (- 141),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__AUTO_OFFSET_RESET = (- 140),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__END = (- 100),</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN = (- 1),</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NO_ERROR = 0,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_OUT_OF_RANGE = 1,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_MSG = 2,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART = 3,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_MSG_SIZE = 4,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE = 5,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_LEADER_FOR_PARTITION = 6,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REQUEST_TIMED_OUT = 7,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_BROKER_NOT_AVAILABLE = 8,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REPLICA_NOT_AVAILABLE = 9,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE = 10,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_STALE_CTRL_EPOCH = 11,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_METADATA_TOO_LARGE = 12,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NETWORK_EXCEPTION = 13,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_COORDINATOR_LOAD_IN_PROGRESS = 14,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_COORDINATOR_NOT_AVAILABLE = 15,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_COORDINATOR = 16,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_EXCEPTION = 17,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_RECORD_LIST_TOO_LARGE = 18,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS = 19,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS_AFTER_APPEND = 20,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REQUIRED_ACKS = 21,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ILLEGAL_GENERATION = 22,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INCONSISTENT_GROUP_PROTOCOL = 23,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_GROUP_ID = 24,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_MEMBER_ID = 25,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_SESSION_TIMEOUT = 26,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REBALANCE_IN_PROGRESS = 27,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_COMMIT_OFFSET_SIZE = 28,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_AUTHORIZATION_FAILED = 29,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_AUTHORIZATION_FAILED = 30,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_CLUSTER_AUTHORIZATION_FAILED = 31,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TIMESTAMP = 32,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_SASL_MECHANISM = 33,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ILLEGAL_SASL_STATE = 34,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_VERSION = 35,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_ALREADY_EXISTS = 36,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PARTITIONS = 37,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REPLICATION_FACTOR = 38,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REPLICA_ASSIGNMENT = 39,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_CONFIG = 40,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_CONTROLLER = 41,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REQUEST = 42,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_FOR_MESSAGE_FORMAT = 43,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_POLICY_VIOLATION = 44,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OUT_OF_ORDER_SEQUENCE_NUMBER = 45,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DUPLICATE_SEQUENCE_NUMBER = 46,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_EPOCH = 47,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TXN_STATE = 48,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_ID_MAPPING = 49,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TRANSACTION_TIMEOUT = 50,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_CONCURRENT_TRANSACTIONS = 51,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TRANSACTION_COORDINATOR_FENCED = 52,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TRANSACTIONAL_ID_AUTHORIZATION_FAILED = 53,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_SECURITY_DISABLED = 54,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OPERATION_NOT_ATTEMPTED = 55,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_KAFKA_STORAGE_ERROR = 56,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LOG_DIR_NOT_FOUND = 57,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_SASL_AUTHENTICATION_FAILED = 58,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_PRODUCER_ID = 59,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REASSIGNMENT_IN_PROGRESS = 60,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTH_DISABLED = 61,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_NOT_FOUND = 62,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_OWNER_MISMATCH = 63,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_REQUEST_NOT_ALLOWED = 64,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTHORIZATION_FAILED = 65,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_EXPIRED = 66,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRINCIPAL_TYPE = 67,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NON_EMPTY_GROUP = 68,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_ID_NOT_FOUND = 69,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FETCH_SESSION_ID_NOT_FOUND = 70,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_FETCH_SESSION_EPOCH = 71,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LISTENER_NOT_FOUND = 72,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_DELETION_DISABLED = 73,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FENCED_LEADER_EPOCH = 74,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_LEADER_EPOCH = 75,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_STALE_BROKER_EPOCH = 77,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_NOT_AVAILABLE = 78,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_MEMBER_ID_REQUIRED = 79,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_PREFERRED_LEADER_NOT_AVAILABLE = 80,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_MAX_SIZE_REACHED = 81,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FENCED_INSTANCE_ID = 82,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ELIGIBLE_LEADERS_NOT_AVAILABLE = 83,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ELECTION_NOT_NEEDED = 84,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NO_REASSIGNMENT_IN_PROGRESS = 85,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_SUBSCRIBED_TO_TOPIC = 86,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_RECORD = 87,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSTABLE_OFFSET_COMMIT = 88,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_THROTTLING_QUOTA_EXCEEDED = 89,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_PRODUCER_FENCED = 90,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_RESOURCE_NOT_FOUND = 91,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DUPLICATE_RESOURCE = 92,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNACCEPTABLE_CREDENTIAL = 93,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INCONSISTENT_VOTER_SET = 94,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_UPDATE_VERSION = 95,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FEATURE_UPDATE_FAILED = 96,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_PRINCIPAL_DESERIALIZATION_FAILURE = 97,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_END_ALL,</span>
<span class="s1">} rd_kafka_resp_err_t;</span>
<span class="s1">struct rd_kafka_err_desc {</span>
<span class="s1">  rd_kafka_resp_err_t code;</span>
<span class="s1">  char *name;</span>
<span class="s1">  char *desc;</span>
<span class="s1">};</span>
<span class="s1">void rd_kafka_get_err_descs(const struct rd_kafka_err_desc **errdescs, size_t *cntp);</span>
<span class="s1">const char *rd_kafka_err2str(rd_kafka_resp_err_t err);</span>
<span class="s1">const char *rd_kafka_err2name(rd_kafka_resp_err_t err);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_last_error(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_errno2err(int errnox);</span>
<span class="s1">int rd_kafka_errno(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_fatal_error(rd_kafka_t *rk, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_test_fatal_error(rd_kafka_t *rk, rd_kafka_resp_err_t err, const char *reason);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_error_code(const rd_kafka_error_t *error);</span>
<span class="s1">const char *rd_kafka_error_name(const rd_kafka_error_t *error);</span>
<span class="s1">const char *rd_kafka_error_string(const rd_kafka_error_t *error);</span>
<span class="s1">int rd_kafka_error_is_fatal(const rd_kafka_error_t *error);</span>
<span class="s1">int rd_kafka_error_is_retriable(const rd_kafka_error_t *error);</span>
<span class="s1">int rd_kafka_error_txn_requires_abort(const rd_kafka_error_t *error);</span>
<span class="s1">void rd_kafka_error_destroy(rd_kafka_error_t *error);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_error_new(rd_kafka_resp_err_t code, const char *fmt, ...);</span>
<span class="s1">typedef struct rd_kafka_topic_partition_s {</span>
<span class="s1">  char *topic;</span>
<span class="s1">  int32_t partition;</span>
<span class="s1">  int64_t offset;</span>
<span class="s1">  void *metadata;</span>
<span class="s1">  size_t metadata_size;</span>
<span class="s1">  void *opaque;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  void *_private;</span>
<span class="s1">} rd_kafka_topic_partition_t;</span>
<span class="s1">void rd_kafka_topic_partition_destroy(rd_kafka_topic_partition_t *rktpar);</span>
<span class="s1">typedef struct rd_kafka_topic_partition_list_s {</span>
<span class="s1">  int cnt;</span>
<span class="s1">  int size;</span>
<span class="s1">  rd_kafka_topic_partition_t *elems;</span>
<span class="s1">} rd_kafka_topic_partition_list_t;</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_new(int size);</span>
<span class="s1">void rd_kafka_topic_partition_list_destroy(rd_kafka_topic_partition_list_t *rkparlist);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_add(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">void rd_kafka_topic_partition_list_add_range(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t start, int32_t stop);</span>
<span class="s1">int rd_kafka_topic_partition_list_del(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">int rd_kafka_topic_partition_list_del_by_idx(rd_kafka_topic_partition_list_t *rktparlist, int idx);</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_copy(const rd_kafka_topic_partition_list_t *src);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_topic_partition_list_set_offset(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition, int64_t offset);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_find(const rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">void rd_kafka_topic_partition_list_sort(rd_kafka_topic_partition_list_t *rktparlist, int (*cmp)(const void *a, const void *b, void *cmp_opaque), void *cmp_opaque);</span>
<span class="s1">typedef enum rd_kafka_vtype_t {</span>
<span class="s1">  RD_KAFKA_VTYPE_END,</span>
<span class="s1">  RD_KAFKA_VTYPE_TOPIC,</span>
<span class="s1">  RD_KAFKA_VTYPE_RKT,</span>
<span class="s1">  RD_KAFKA_VTYPE_PARTITION,</span>
<span class="s1">  RD_KAFKA_VTYPE_VALUE,</span>
<span class="s1">  RD_KAFKA_VTYPE_KEY,</span>
<span class="s1">  RD_KAFKA_VTYPE_OPAQUE,</span>
<span class="s1">  RD_KAFKA_VTYPE_MSGFLAGS,</span>
<span class="s1">  RD_KAFKA_VTYPE_TIMESTAMP,</span>
<span class="s1">  RD_KAFKA_VTYPE_HEADER,</span>
<span class="s1">  RD_KAFKA_VTYPE_HEADERS,</span>
<span class="s1">} rd_kafka_vtype_t;</span>
<span class="s1">typedef struct rd_kafka_vu_s {</span>
<span class="s1">  rd_kafka_vtype_t vtype;</span>
<span class="s1">  union {</span>
<span class="s1">    char *cstr;</span>
<span class="s1">    rd_kafka_topic_t *rkt;</span>
<span class="s1">    int i;</span>
<span class="s1">    int32_t i32;</span>
<span class="s1">    int64_t i64;</span>
<span class="s1">    struct {</span>
<span class="s1">      void *ptr;</span>
<span class="s1">      size_t size;</span>
<span class="s1">    } mem;</span>
<span class="s1">    struct {</span>
<span class="s1">      char *name;</span>
<span class="s1">      void *val;</span>
<span class="s1">      ssize_t size;</span>
<span class="s1">    } header;</span>
<span class="s1">    rd_kafka_headers_t *headers;</span>
<span class="s1">    void *ptr;</span>
<span class="s1">    char _pad[64];</span>
<span class="s1">  } u;</span>
<span class="s1">} rd_kafka_vu_t;</span>
<span class="s1">rd_kafka_headers_t *rd_kafka_headers_new(size_t initial_count);</span>
<span class="s1">void rd_kafka_headers_destroy(rd_kafka_headers_t *hdrs);</span>
<span class="s1">rd_kafka_headers_t *rd_kafka_headers_copy(const rd_kafka_headers_t *src);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_add(rd_kafka_headers_t *hdrs, const char *name, ssize_t name_size, const void *value, ssize_t value_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_remove(rd_kafka_headers_t *hdrs, const char *name);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get_last(const rd_kafka_headers_t *hdrs, const char *name, const void **valuep, size_t *sizep);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get(const rd_kafka_headers_t *hdrs, size_t idx, const char *name, const void **valuep, size_t *sizep);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get_all(const rd_kafka_headers_t *hdrs, size_t idx, const char **namep, const void **valuep, size_t *sizep);</span>
<span class="s1">typedef struct rd_kafka_message_s {</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  rd_kafka_topic_t *rkt;</span>
<span class="s1">  int32_t partition;</span>
<span class="s1">  void *payload;</span>
<span class="s1">  size_t len;</span>
<span class="s1">  void *key;</span>
<span class="s1">  size_t key_len;</span>
<span class="s1">  int64_t offset;</span>
<span class="s1">  void *_private;</span>
<span class="s1">} rd_kafka_message_t;</span>
<span class="s1">void rd_kafka_message_destroy(rd_kafka_message_t *rkmessage);</span>
<span class="s1">const char *rd_kafka_message_errstr(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">int64_t rd_kafka_message_timestamp(const rd_kafka_message_t *rkmessage, rd_kafka_timestamp_type_t *tstype);</span>
<span class="s1">int64_t rd_kafka_message_latency(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">int32_t rd_kafka_message_broker_id(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_message_headers(const rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_message_detach_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);</span>
<span class="s1">void rd_kafka_message_set_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t *hdrs);</span>
<span class="s1">size_t rd_kafka_header_cnt(const rd_kafka_headers_t *hdrs);</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_NOT_PERSISTED = 0,</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_POSSIBLY_PERSISTED = 1,</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_PERSISTED = 2,</span>
<span class="s1">} rd_kafka_msg_status_t;</span>
<span class="s1">rd_kafka_msg_status_t rd_kafka_message_status(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_CONF_UNKNOWN = (- 2),</span>
<span class="s1">  RD_KAFKA_CONF_INVALID = (- 1),</span>
<span class="s1">  RD_KAFKA_CONF_OK = 0,</span>
<span class="s1">} rd_kafka_conf_res_t;</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_new(void);</span>
<span class="s1">void rd_kafka_conf_destroy(rd_kafka_conf_t *conf);</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_dup(const rd_kafka_conf_t *conf);</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_dup_filter(const rd_kafka_conf_t *conf, size_t filter_cnt, const char **filter);</span>
<span class="s1">const rd_kafka_conf_t *rd_kafka_conf(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_set(rd_kafka_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_conf_set_events(rd_kafka_conf_t *conf, int events);</span>
<span class="s1">void rd_kafka_conf_set_background_event_cb(rd_kafka_conf_t *conf, void (*event_cb)(rd_kafka_t *rk, rd_kafka_event_t *rkev, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_dr_cb(rd_kafka_conf_t *conf, void (*dr_cb)(rd_kafka_t *rk, void *payload, size_t len, rd_kafka_resp_err_t err, void *opaque, void *msg_opaque));</span>
<span class="s1">void rd_kafka_conf_set_dr_msg_cb(rd_kafka_conf_t *conf, void (*dr_msg_cb)(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_consume_cb(rd_kafka_conf_t *conf, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_rebalance_cb(rd_kafka_conf_t *conf, void (*rebalance_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *partitions, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_offset_commit_cb(rd_kafka_conf_t *conf, void (*offset_commit_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_error_cb(rd_kafka_conf_t *conf, void (*error_cb)(rd_kafka_t *rk, int err, const char *reason, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_throttle_cb(rd_kafka_conf_t *conf, void (*throttle_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int throttle_time_ms, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_log_cb(rd_kafka_conf_t *conf, void (*log_cb)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));</span>
<span class="s1">void rd_kafka_conf_set_stats_cb(rd_kafka_conf_t *conf, int (*stats_cb)(rd_kafka_t *rk, char *json, size_t json_len, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_oauthbearer_token_refresh_cb(rd_kafka_conf_t *conf, void (*oauthbearer_token_refresh_cb)(rd_kafka_t *rk, const char *oauthbearer_config, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_socket_cb(rd_kafka_conf_t *conf, int (*socket_cb)(int domain, int type, int protocol, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_connect_cb(rd_kafka_conf_t *conf, int (*connect_cb)(int sockfd, const struct sockaddr *addr, int addrlen, const char *id, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_closesocket_cb(rd_kafka_conf_t *conf, int (*closesocket_cb)(int sockfd, void *opaque));</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert_verify_cb(rd_kafka_conf_t *conf, int (*ssl_cert_verify_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int *x509_error, int depth, const char *buf, size_t size, char *errstr, size_t errstr_size, void *opaque));</span>
<span class="s1">typedef enum rd_kafka_cert_type_t {</span>
<span class="s1">  RD_KAFKA_CERT_PUBLIC_KEY,</span>
<span class="s1">  RD_KAFKA_CERT_PRIVATE_KEY,</span>
<span class="s1">  RD_KAFKA_CERT_CA,</span>
<span class="s1">  RD_KAFKA_CERT__CNT,</span>
<span class="s1">} rd_kafka_cert_type_t;</span>
<span class="s1">typedef enum rd_kafka_cert_enc_t {</span>
<span class="s1">  RD_KAFKA_CERT_ENC_PKCS12,</span>
<span class="s1">  RD_KAFKA_CERT_ENC_DER,</span>
<span class="s1">  RD_KAFKA_CERT_ENC_PEM,</span>
<span class="s1">  RD_KAFKA_CERT_ENC__CNT,</span>
<span class="s1">} rd_kafka_cert_enc_t;</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert(rd_kafka_conf_t *conf, rd_kafka_cert_type_t cert_type, rd_kafka_cert_enc_t cert_enc, const void *buffer, size_t size, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_conf_set_opaque(rd_kafka_conf_t *conf, void *opaque);</span>
<span class="s1">void *rd_kafka_opaque(const rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_conf_set_default_topic_conf(rd_kafka_conf_t *conf, rd_kafka_topic_conf_t *tconf);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_conf_get_default_topic_conf(rd_kafka_conf_t *conf);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_get(const rd_kafka_conf_t *conf, const char *name, char *dest, size_t *dest_size);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_topic_conf_get(const rd_kafka_topic_conf_t *conf, const char *name, char *dest, size_t *dest_size);</span>
<span class="s1">const char **rd_kafka_conf_dump(rd_kafka_conf_t *conf, size_t *cntp);</span>
<span class="s1">const char **rd_kafka_topic_conf_dump(rd_kafka_topic_conf_t *conf, size_t *cntp);</span>
<span class="s1">void rd_kafka_conf_dump_free(const char **arr, size_t cnt);</span>
<span class="s1">void rd_kafka_conf_properties_show(FILE *fp);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_topic_conf_new(void);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_topic_conf_dup(const rd_kafka_topic_conf_t *conf);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_default_topic_conf_dup(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_topic_conf_destroy(rd_kafka_topic_conf_t *topic_conf);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_topic_conf_set(rd_kafka_topic_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_topic_conf_set_opaque(rd_kafka_topic_conf_t *conf, void *rkt_opaque);</span>
<span class="s1">void rd_kafka_topic_conf_set_partitioner_cb(rd_kafka_topic_conf_t *topic_conf, int32_t (*partitioner)(const rd_kafka_topic_t *rkt, const void *keydata, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque));</span>
<span class="s1">void rd_kafka_topic_conf_set_msg_order_cmp(rd_kafka_topic_conf_t *topic_conf, int (*msg_order_cmp)(const rd_kafka_message_t *a, const rd_kafka_message_t *b));</span>
<span class="s1">int rd_kafka_topic_partition_available(const rd_kafka_topic_t *rkt, int32_t partition);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_consistent(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_consistent_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_murmur2(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_murmur2_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_fnv1a(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_fnv1a_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">rd_kafka_t *rd_kafka_new(rd_kafka_type_t type, rd_kafka_conf_t *conf, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_destroy(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_destroy_flags(rd_kafka_t *rk, int flags);</span>
<span class="s1">const char *rd_kafka_name(const rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_type_t rd_kafka_type(const rd_kafka_t *rk);</span>
<span class="s1">char *rd_kafka_memberid(const rd_kafka_t *rk);</span>
<span class="s1">char *rd_kafka_clusterid(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">int32_t rd_kafka_controllerid(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_topic_t *rd_kafka_topic_new(rd_kafka_t *rk, const char *topic, rd_kafka_topic_conf_t *conf);</span>
<span class="s1">void rd_kafka_topic_destroy(rd_kafka_topic_t *rkt);</span>
<span class="s1">const char *rd_kafka_topic_name(const rd_kafka_topic_t *rkt);</span>
<span class="s1">void *rd_kafka_topic_opaque(const rd_kafka_topic_t *rkt);</span>
<span class="s1">int rd_kafka_poll(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">void rd_kafka_yield(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_pause_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_resume_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_query_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_get_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offsets_for_times(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets, int timeout_ms);</span>
<span class="s1">void rd_kafka_mem_free(rd_kafka_t *rk, void *ptr);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_new(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_queue_destroy(rd_kafka_queue_t *rkqu);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_main(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_consumer(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_partition(rd_kafka_t *rk, const char *topic, int32_t partition);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_background(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_queue_forward(rd_kafka_queue_t *src, rd_kafka_queue_t *dst);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_set_log_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu);</span>
<span class="s1">size_t rd_kafka_queue_length(rd_kafka_queue_t *rkqu);</span>
<span class="s1">void rd_kafka_queue_io_event_enable(rd_kafka_queue_t *rkqu, int fd, const void *payload, size_t size);</span>
<span class="s1">void rd_kafka_queue_cb_event_enable(rd_kafka_queue_t *rkqu, void (*event_cb)(rd_kafka_t *rk, void *qev_opaque), void *qev_opaque);</span>
<span class="s1">void rd_kafka_queue_yield(rd_kafka_queue_t *rkqu);</span>
<span class="s1">int rd_kafka_consume_start(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);</span>
<span class="s1">int rd_kafka_consume_start_queue(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, rd_kafka_queue_t *rkqu);</span>
<span class="s1">int rd_kafka_consume_stop(rd_kafka_topic_t *rkt, int32_t partition);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_seek(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, int timeout_ms);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_seek_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consume(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms);</span>
<span class="s1">ssize_t rd_kafka_consume_batch(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);</span>
<span class="s1">int rd_kafka_consume_callback(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consume_queue(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">ssize_t rd_kafka_consume_batch_queue(rd_kafka_queue_t *rkqu, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);</span>
<span class="s1">int rd_kafka_consume_callback_queue(rd_kafka_queue_t *rkqu, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offset_store(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offsets_store(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_subscribe(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *topics);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_unsubscribe(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_subscription(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **topics);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consumer_poll(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_consumer_close(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_incremental_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_incremental_unassign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">const char *rd_kafka_rebalance_protocol(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_assignment(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **partitions);</span>
<span class="s1">int rd_kafka_assignment_lost(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, int async);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit_message(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, int async);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit_queue(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_queue_t *rkqu, void (*cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *commit_opaque), void *commit_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_committed(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_position(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata_new(const char *group_id);</span>
<span class="s1">rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata_new_with_genid(const char *group_id, int32_t generation_id, const char *member_id, const char *group_instance_id);</span>
<span class="s1">void rd_kafka_consumer_group_metadata_destroy(rd_kafka_consumer_group_metadata_t *);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_consumer_group_metadata_write(const rd_kafka_consumer_group_metadata_t *cgmd, void **bufferp, size_t *sizep);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_consumer_group_metadata_read(rd_kafka_consumer_group_metadata_t **cgmdp, const void *buffer, size_t size);</span>
<span class="s1">int rd_kafka_produce(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, void *payload, size_t len, const void *key, size_t keylen, void *msg_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_producev(rd_kafka_t *rk, ...);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_produceva(rd_kafka_t *rk, const rd_kafka_vu_t *vus, size_t cnt);</span>
<span class="s1">int rd_kafka_produce_batch(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, rd_kafka_message_t *rkmessages, int message_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_flush(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_purge(rd_kafka_t *rk, int purge_flags);</span>
<span class="s1">typedef struct rd_kafka_metadata_broker {</span>
<span class="s1">  int32_t id;</span>
<span class="s1">  char *host;</span>
<span class="s1">  int port;</span>
<span class="s1">} rd_kafka_metadata_broker_t;</span>
<span class="s1">typedef struct rd_kafka_metadata_partition {</span>
<span class="s1">  int32_t id;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  int32_t leader;</span>
<span class="s1">  int replica_cnt;</span>
<span class="s1">  int32_t *replicas;</span>
<span class="s1">  int isr_cnt;</span>
<span class="s1">  int32_t *isrs;</span>
<span class="s1">} rd_kafka_metadata_partition_t;</span>
<span class="s1">typedef struct rd_kafka_metadata_topic {</span>
<span class="s1">  char *topic;</span>
<span class="s1">  int partition_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_partition *partitions;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">} rd_kafka_metadata_topic_t;</span>
<span class="s1">typedef struct rd_kafka_metadata {</span>
<span class="s1">  int broker_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_broker *brokers;</span>
<span class="s1">  int topic_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_topic *topics;</span>
<span class="s1">  int32_t orig_broker_id;</span>
<span class="s1">  char *orig_broker_name;</span>
<span class="s1">} rd_kafka_metadata_t;</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_metadata(rd_kafka_t *rk, int all_topics, rd_kafka_topic_t *only_rkt, const struct rd_kafka_metadata **metadatap, int timeout_ms);</span>
<span class="s1">void rd_kafka_metadata_destroy(const struct rd_kafka_metadata *metadata);</span>
<span class="s1">struct rd_kafka_group_member_info {</span>
<span class="s1">  char *member_id;</span>
<span class="s1">  char *client_id;</span>
<span class="s1">  char *client_host;</span>
<span class="s1">  void *member_metadata;</span>
<span class="s1">  int member_metadata_size;</span>
<span class="s1">  void *member_assignment;</span>
<span class="s1">  int member_assignment_size;</span>
<span class="s1">};</span>
<span class="s1">struct rd_kafka_group_info {</span>
<span class="s1">  struct rd_kafka_metadata_broker broker;</span>
<span class="s1">  char *group;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  char *state;</span>
<span class="s1">  char *protocol_type;</span>
<span class="s1">  char *protocol;</span>
<span class="s1">  struct rd_kafka_group_member_info *members;</span>
<span class="s1">  int member_cnt;</span>
<span class="s1">};</span>
<span class="s1">struct rd_kafka_group_list {</span>
<span class="s1">  struct rd_kafka_group_info *groups;</span>
<span class="s1">  int group_cnt;</span>
<span class="s1">};</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_list_groups(rd_kafka_t *rk, const char *group, const struct rd_kafka_group_list **grplistp, int timeout_ms);</span>
<span class="s1">void rd_kafka_group_list_destroy(const struct rd_kafka_group_list *grplist);</span>
<span class="s1">int rd_kafka_brokers_add(rd_kafka_t *rk, const char *brokerlist);</span>
<span class="s1">void rd_kafka_set_logger(rd_kafka_t *rk, void (*func)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));</span>
<span class="s1">void rd_kafka_set_log_level(rd_kafka_t *rk, int level);</span>
<span class="s1">void rd_kafka_log_print(const rd_kafka_t *rk, int level, const char *fac, const char *buf);</span>
<span class="s1">void rd_kafka_log_syslog(const rd_kafka_t *rk, int level, const char *fac, const char *buf);</span>
<span class="s1">int rd_kafka_outq_len(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_dump(FILE *fp, rd_kafka_t *rk);</span>
<span class="s1">int rd_kafka_thread_cnt(void);</span>
<span class="s1">typedef enum rd_kafka_thread_type_t {</span>
<span class="s1">  RD_KAFKA_THREAD_MAIN,</span>
<span class="s1">  RD_KAFKA_THREAD_BACKGROUND,</span>
<span class="s1">  RD_KAFKA_THREAD_BROKER,</span>
<span class="s1">} rd_kafka_thread_type_t;</span>
<span class="s1">int rd_kafka_wait_destroyed(int timeout_ms);</span>
<span class="s1">int rd_kafka_unittest(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_poll_set_consumer(rd_kafka_t *rk);</span>
<span class="s1">typedef int rd_kafka_event_type_t;</span>
<span class="s1">rd_kafka_event_type_t rd_kafka_event_type(const rd_kafka_event_t *rkev);</span>
<span class="s1">const char *rd_kafka_event_name(const rd_kafka_event_t *rkev);</span>
<span class="s1">void rd_kafka_event_destroy(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_message_t *rd_kafka_event_message_next(rd_kafka_event_t *rkev);</span>
<span class="s1">size_t rd_kafka_event_message_array(rd_kafka_event_t *rkev, const rd_kafka_message_t **rkmessages, size_t size);</span>
<span class="s1">size_t rd_kafka_event_message_count(rd_kafka_event_t *rkev);</span>
<span class="s1">const char *rd_kafka_event_config_string(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_event_error(rd_kafka_event_t *rkev);</span>
<span class="s1">const char *rd_kafka_event_error_string(rd_kafka_event_t *rkev);</span>
<span class="s1">int rd_kafka_event_error_is_fatal(rd_kafka_event_t *rkev);</span>
<span class="s1">void *rd_kafka_event_opaque(rd_kafka_event_t *rkev);</span>
<span class="s1">int rd_kafka_event_log(rd_kafka_event_t *rkev, const char **fac, const char **str, int *level);</span>
<span class="s1">int rd_kafka_event_debug_contexts(rd_kafka_event_t *rkev, char *dst, size_t dstsize);</span>
<span class="s1">const char *rd_kafka_event_stats(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_event_topic_partition_list(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_event_topic_partition(rd_kafka_event_t *rkev);</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_CreateTopics_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DeleteTopics_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_CreatePartitions_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_AlterConfigs_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DescribeConfigs_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DeleteRecords_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DeleteGroups_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DeleteConsumerGroupOffsets_result_t;</span>
<span class="s1">const rd_kafka_CreateTopics_result_t *rd_kafka_event_CreateTopics_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DeleteTopics_result_t *rd_kafka_event_DeleteTopics_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_CreatePartitions_result_t *rd_kafka_event_CreatePartitions_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_AlterConfigs_result_t *rd_kafka_event_AlterConfigs_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DescribeConfigs_result_t *rd_kafka_event_DescribeConfigs_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DeleteRecords_result_t *rd_kafka_event_DeleteRecords_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DeleteGroups_result_t *rd_kafka_event_DeleteGroups_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DeleteConsumerGroupOffsets_result_t *rd_kafka_event_DeleteConsumerGroupOffsets_result(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_event_t *rd_kafka_queue_poll(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">int rd_kafka_queue_poll_callback(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_plugin_f_conf_init_t)(rd_kafka_conf_t *conf, void **plug_opaquep, char *errstr, size_t errstr_size);</span>
<span class="s1">typedef rd_kafka_conf_res_t (rd_kafka_interceptor_f_on_conf_set_t)(rd_kafka_conf_t *conf, const char *name, const char *val, char *errstr, size_t errstr_size, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_dup_t)(rd_kafka_conf_t *new_conf, const rd_kafka_conf_t *old_conf, size_t filter_cnt, const char **filter, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_destroy_t)(void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_new_t)(rd_kafka_t *rk, const rd_kafka_conf_t *conf, void *ic_opaque, char *errstr, size_t errstr_size);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_destroy_t)(rd_kafka_t *rk, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_send_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_acknowledgement_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_consume_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_commit_t)(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_resp_err_t err, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_request_sent_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_response_received_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, int64_t rtt, rd_kafka_resp_err_t err, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_start_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_exit_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_set(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_set_t *on_conf_set, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_dup(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_dup_t *on_conf_dup, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_destroy(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_destroy_t *on_conf_destroy, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_new(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_new_t *on_new, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_destroy(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_destroy_t *on_destroy, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_send(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_send_t *on_send, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_acknowledgement(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_acknowledgement_t *on_acknowledgement, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_consume(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_consume_t *on_consume, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_commit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_commit_t *on_commit, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_request_sent(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_request_sent_t *on_request_sent, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_response_received(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_response_received_t *on_response_received, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_start(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_start_t *on_thread_start, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_exit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_exit_t *on_thread_exit, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_topic_result_error(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">const char *rd_kafka_topic_result_error_string(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">const char *rd_kafka_topic_result_name(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">const rd_kafka_error_t *rd_kafka_group_result_error(const rd_kafka_group_result_t *groupres);</span>
<span class="s1">const char *rd_kafka_group_result_name(const rd_kafka_group_result_t *groupres);</span>
<span class="s1">const rd_kafka_topic_partition_list_t *rd_kafka_group_result_partitions(const rd_kafka_group_result_t *groupres);</span>
<span class="s1">typedef enum rd_kafka_admin_op_t {</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_ANY = 0,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_CREATETOPICS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DELETETOPICS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_CREATEPARTITIONS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_ALTERCONFIGS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DESCRIBECONFIGS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DELETERECORDS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DELETEGROUPS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DELETECONSUMERGROUPOFFSETS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP__CNT,</span>
<span class="s1">} rd_kafka_admin_op_t;</span>
<span class="s1">typedef struct rd_kafka_AdminOptions_s rd_kafka_AdminOptions_t;</span>
<span class="s1">rd_kafka_AdminOptions_t *rd_kafka_AdminOptions_new(rd_kafka_t *rk, rd_kafka_admin_op_t for_api);</span>
<span class="s1">void rd_kafka_AdminOptions_destroy(rd_kafka_AdminOptions_t *options);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_request_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_operation_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_validate_only(rd_kafka_AdminOptions_t *options, int true_or_false, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_broker(rd_kafka_AdminOptions_t *options, int32_t broker_id, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_AdminOptions_set_opaque(rd_kafka_AdminOptions_t *options, void *ev_opaque);</span>
<span class="s1">typedef struct rd_kafka_NewTopic_s rd_kafka_NewTopic_t;</span>
<span class="s1">rd_kafka_NewTopic_t *rd_kafka_NewTopic_new(const char *topic, int num_partitions, int replication_factor, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_NewTopic_destroy(rd_kafka_NewTopic_t *new_topic);</span>
<span class="s1">void rd_kafka_NewTopic_destroy_array(rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewTopic_set_replica_assignment(rd_kafka_NewTopic_t *new_topic, int32_t partition, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewTopic_set_config(rd_kafka_NewTopic_t *new_topic, const char *name, const char *value);</span>
<span class="s1">void rd_kafka_CreateTopics(rd_kafka_t *rk, rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_CreateTopics_result_topics(const rd_kafka_CreateTopics_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_DeleteTopic_s rd_kafka_DeleteTopic_t;</span>
<span class="s1">rd_kafka_DeleteTopic_t *rd_kafka_DeleteTopic_new(const char *topic);</span>
<span class="s1">void rd_kafka_DeleteTopic_destroy(rd_kafka_DeleteTopic_t *del_topic);</span>
<span class="s1">void rd_kafka_DeleteTopic_destroy_array(rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt);</span>
<span class="s1">void rd_kafka_DeleteTopics(rd_kafka_t *rk, rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_DeleteTopics_result_topics(const rd_kafka_DeleteTopics_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_NewPartitions_s rd_kafka_NewPartitions_t;</span>
<span class="s1">rd_kafka_NewPartitions_t *rd_kafka_NewPartitions_new(const char *topic, size_t new_total_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_NewPartitions_destroy(rd_kafka_NewPartitions_t *new_parts);</span>
<span class="s1">void rd_kafka_NewPartitions_destroy_array(rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewPartitions_set_replica_assignment(rd_kafka_NewPartitions_t *new_parts, int32_t new_partition_idx, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_CreatePartitions(rd_kafka_t *rk, rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_CreatePartitions_result_topics(const rd_kafka_CreatePartitions_result_t *result, size_t *cntp);</span>
<span class="s1">typedef enum rd_kafka_ConfigSource_t {</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_UNKNOWN_CONFIG = 0,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_TOPIC_CONFIG = 1,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_BROKER_CONFIG = 2,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_DEFAULT_BROKER_CONFIG = 3,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_STATIC_BROKER_CONFIG = 4,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DEFAULT_CONFIG = 5,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE__CNT,</span>
<span class="s1">} rd_kafka_ConfigSource_t;</span>
<span class="s1">const char *rd_kafka_ConfigSource_name(rd_kafka_ConfigSource_t confsource);</span>
<span class="s1">typedef struct rd_kafka_ConfigEntry_s rd_kafka_ConfigEntry_t;</span>
<span class="s1">const char *rd_kafka_ConfigEntry_name(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">const char *rd_kafka_ConfigEntry_value(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">rd_kafka_ConfigSource_t rd_kafka_ConfigEntry_source(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_read_only(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_default(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_sensitive(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_synonym(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">const rd_kafka_ConfigEntry_t **rd_kafka_ConfigEntry_synonyms(const rd_kafka_ConfigEntry_t *entry, size_t *cntp);</span>
<span class="s1">typedef enum rd_kafka_ResourceType_t {</span>
<span class="s1">  RD_KAFKA_RESOURCE_UNKNOWN = 0,</span>
<span class="s1">  RD_KAFKA_RESOURCE_ANY = 1,</span>
<span class="s1">  RD_KAFKA_RESOURCE_TOPIC = 2,</span>
<span class="s1">  RD_KAFKA_RESOURCE_GROUP = 3,</span>
<span class="s1">  RD_KAFKA_RESOURCE_BROKER = 4,</span>
<span class="s1">  RD_KAFKA_RESOURCE__CNT,</span>
<span class="s1">} rd_kafka_ResourceType_t;</span>
<span class="s1">const char *rd_kafka_ResourceType_name(rd_kafka_ResourceType_t restype);</span>
<span class="s1">typedef struct rd_kafka_ConfigResource_s rd_kafka_ConfigResource_t;</span>
<span class="s1">rd_kafka_ConfigResource_t *rd_kafka_ConfigResource_new(rd_kafka_ResourceType_t restype, const char *resname);</span>
<span class="s1">void rd_kafka_ConfigResource_destroy(rd_kafka_ConfigResource_t *config);</span>
<span class="s1">void rd_kafka_ConfigResource_destroy_array(rd_kafka_ConfigResource_t **config, size_t config_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_ConfigResource_set_config(rd_kafka_ConfigResource_t *config, const char *name, const char *value);</span>
<span class="s1">const rd_kafka_ConfigEntry_t **rd_kafka_ConfigResource_configs(const rd_kafka_ConfigResource_t *config, size_t *cntp);</span>
<span class="s1">rd_kafka_ResourceType_t rd_kafka_ConfigResource_type(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">const char *rd_kafka_ConfigResource_name(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_ConfigResource_error(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">const char *rd_kafka_ConfigResource_error_string(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">void rd_kafka_AlterConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_ConfigResource_t **rd_kafka_AlterConfigs_result_resources(const rd_kafka_AlterConfigs_result_t *result, size_t *cntp);</span>
<span class="s1">void rd_kafka_DescribeConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_ConfigResource_t **rd_kafka_DescribeConfigs_result_resources(const rd_kafka_DescribeConfigs_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_DeleteRecords_s rd_kafka_DeleteRecords_t;</span>
<span class="s1">rd_kafka_DeleteRecords_t *rd_kafka_DeleteRecords_new(const rd_kafka_topic_partition_list_t *before_offsets);</span>
<span class="s1">void rd_kafka_DeleteRecords_destroy(rd_kafka_DeleteRecords_t *del_records);</span>
<span class="s1">void rd_kafka_DeleteRecords_destroy_array(rd_kafka_DeleteRecords_t **del_records, size_t del_record_cnt);</span>
<span class="s1">void rd_kafka_DeleteRecords(rd_kafka_t *rk, rd_kafka_DeleteRecords_t **del_records, size_t del_record_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_partition_list_t *rd_kafka_DeleteRecords_result_offsets(const rd_kafka_DeleteRecords_result_t *result);</span>
<span class="s1">typedef struct rd_kafka_DeleteGroup_s rd_kafka_DeleteGroup_t;</span>
<span class="s1">rd_kafka_DeleteGroup_t *rd_kafka_DeleteGroup_new(const char *group);</span>
<span class="s1">void rd_kafka_DeleteGroup_destroy(rd_kafka_DeleteGroup_t *del_group);</span>
<span class="s1">void rd_kafka_DeleteGroup_destroy_array(rd_kafka_DeleteGroup_t **del_groups, size_t del_group_cnt);</span>
<span class="s1">void rd_kafka_DeleteGroups(rd_kafka_t *rk, rd_kafka_DeleteGroup_t **del_groups, size_t del_group_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_group_result_t **rd_kafka_DeleteGroups_result_groups(const rd_kafka_DeleteGroups_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_DeleteConsumerGroupOffsets_s rd_kafka_DeleteConsumerGroupOffsets_t;</span>
<span class="s1">rd_kafka_DeleteConsumerGroupOffsets_t *rd_kafka_DeleteConsumerGroupOffsets_new(const char *group, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">void rd_kafka_DeleteConsumerGroupOffsets_destroy(rd_kafka_DeleteConsumerGroupOffsets_t *del_grpoffsets);</span>
<span class="s1">void rd_kafka_DeleteConsumerGroupOffsets_destroy_array(rd_kafka_DeleteConsumerGroupOffsets_t **del_grpoffsets, size_t del_grpoffset_cnt);</span>
<span class="s1">void rd_kafka_DeleteConsumerGroupOffsets(rd_kafka_t *rk, rd_kafka_DeleteConsumerGroupOffsets_t **del_grpoffsets, size_t del_grpoffsets_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_group_result_t **rd_kafka_DeleteConsumerGroupOffsets_result_groups(const rd_kafka_DeleteConsumerGroupOffsets_result_t *result, size_t *cntp);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token(rd_kafka_t *rk, const char *token_value, int64_t md_lifetime_ms, const char *md_principal_name, const char **extensions, size_t extension_size, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token_failure(rd_kafka_t *rk, const char *errstr);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_init_transactions(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_begin_transaction(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_send_offsets_to_transaction(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, const rd_kafka_consumer_group_metadata_t *cgmetadata, int timeout_ms);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_commit_transaction(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_abort_transaction(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">typedef struct rd_kafka_mock_cluster_s rd_kafka_mock_cluster_t;</span>
<span class="s1">rd_kafka_mock_cluster_t *rd_kafka_mock_cluster_new(rd_kafka_t *rk, int broker_cnt);</span>
<span class="s1">void rd_kafka_mock_cluster_destroy(rd_kafka_mock_cluster_t *mcluster);</span>
<span class="s1">rd_kafka_t *rd_kafka_mock_cluster_handle(const rd_kafka_mock_cluster_t *mcluster);</span>
<span class="s1">rd_kafka_mock_cluster_t *rd_kafka_handle_mock_cluster(const rd_kafka_t *rk);</span>
<span class="s1">const char *rd_kafka_mock_cluster_bootstraps(const rd_kafka_mock_cluster_t *mcluster);</span>
<span class="s1">void rd_kafka_mock_clear_request_errors(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey);</span>
<span class="s1">void rd_kafka_mock_push_request_errors(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, size_t cnt, ...);</span>
<span class="s1">void rd_kafka_mock_push_request_errors_array(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, size_t cnt, const rd_kafka_resp_err_t *errors);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_push_request_errors(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int16_t ApiKey, size_t cnt, ...);</span>
<span class="s1">void rd_kafka_mock_topic_set_error(rd_kafka_mock_cluster_t *mcluster, const char *topic, rd_kafka_resp_err_t err);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_topic_create(rd_kafka_mock_cluster_t *mcluster, const char *topic, int partition_cnt, int replication_factor);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_partition_set_leader(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_partition_set_follower(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_partition_set_follower_wmarks(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int64_t lo, int64_t hi);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_set_down(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_set_up(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_set_rtt(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int rtt_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_set_rack(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, const char *rack);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_coordinator_set(rd_kafka_mock_cluster_t *mcluster, const char *key_type, const char *key, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_set_apiversion(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, int16_t MinVersion, int16_t MaxVersion);</span>
<span class="s1">&#39;</span>
</code></pre></div>
rdkafka.h, rdkafka_mock.h</p>
<h3 id="rd_kafka_version_16">RD_KAFKA_VERSION<a class="headerlink" href="#rd_kafka_version_16" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_VERSION</span> <span class="o">=</span> <span class="mi">17236223</span>
</code></pre></div>
<p>librdkafka version </p>
<p>Interpreted as hex <code>MM.mm.rr.xx</code>:</p>
<ul>
<li>MM = Major</li>
<li>mm = minor</li>
<li>rr = revision</li>
<li>xx = pre-release id (0xff is the final release)</li>
</ul>
<p>E.g.: <code>0x000801ff</code> = 0.8.1</p>
<dl class="section remark"><dt>Remarks</dt><dd>This value should only be used during compile time, for runtime checks of version use rd_kafka_version() </dd></dl>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_unsupported_compression_type_16">RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE<a class="headerlink" href="#rd_kafka_resp_err_unsupported_compression_type_16" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE</span> <span class="o">=</span> <span class="mi">76</span>
</code></pre></div>
<p>Unsupported compression type </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_end_all_16">RD_KAFKA_RESP_ERR_END_ALL<a class="headerlink" href="#rd_kafka_resp_err_end_all_16" title="Permanent link">&para;</a></h3>
<p><div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_END_ALL</span> <span class="o">=</span> <span class="mi">98</span>
</code></pre></div>
enum rd_kafka_resp_err_t</p>
<h3 id="rd_kafka_admin_op__cnt_16">RD_KAFKA_ADMIN_OP__CNT<a class="headerlink" href="#rd_kafka_admin_op__cnt_16" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_ADMIN_OP__CNT</span> <span class="o">=</span> <span class="mi">9</span>
</code></pre></div>
<p>Number of ops defined </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe </a></li>
</ul>
</div>
<h3 id="rd_kafka_resource__cnt_16">RD_KAFKA_RESOURCE__CNT<a class="headerlink" href="#rd_kafka_resource__cnt_16" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESOURCE__CNT</span> <span class="o">=</span> <span class="mi">5</span>
</code></pre></div>
<p>Number of resource types defined </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#acca83a66d7783ff7683ed2691cc907c9"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#acca83a66d7783ff7683ed2691cc907c9 </a></li>
</ul>
</div>
<h3 id="rd_kafka_cdef_16">RD_KAFKA_CDEF<a class="headerlink" href="#rd_kafka_cdef_16" title="Permanent link">&para;</a></h3>
<p><div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_CDEF</span> <span class="o">=</span> <span class="s1">&#39;typedef long int ssize_t;</span>
<span class="s1">typedef struct _IO_FILE FILE;</span>
<span class="s1">typedef long int mode_t;</span>
<span class="s1">typedef signed int int16_t;</span>
<span class="s1">typedef unsigned int uint16_t;</span>
<span class="s1">typedef signed int int32_t;</span>
<span class="s1">typedef signed long int int64_t;</span>
<span class="s1">int rd_kafka_version(void);</span>
<span class="s1">const char *rd_kafka_version_str(void);</span>
<span class="s1">typedef enum rd_kafka_type_t {</span>
<span class="s1">  RD_KAFKA_PRODUCER,</span>
<span class="s1">  RD_KAFKA_CONSUMER,</span>
<span class="s1">} rd_kafka_type_t;</span>
<span class="s1">typedef enum rd_kafka_timestamp_type_t {</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_NOT_AVAILABLE,</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_CREATE_TIME,</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_LOG_APPEND_TIME,</span>
<span class="s1">} rd_kafka_timestamp_type_t;</span>
<span class="s1">const char *rd_kafka_get_debug_contexts(void);</span>
<span class="s1">typedef struct rd_kafka_s rd_kafka_t;</span>
<span class="s1">typedef struct rd_kafka_topic_s rd_kafka_topic_t;</span>
<span class="s1">typedef struct rd_kafka_conf_s rd_kafka_conf_t;</span>
<span class="s1">typedef struct rd_kafka_topic_conf_s rd_kafka_topic_conf_t;</span>
<span class="s1">typedef struct rd_kafka_queue_s rd_kafka_queue_t;</span>
<span class="s1">typedef struct rd_kafka_op_s rd_kafka_event_t;</span>
<span class="s1">typedef struct rd_kafka_topic_result_s rd_kafka_topic_result_t;</span>
<span class="s1">typedef struct rd_kafka_consumer_group_metadata_s rd_kafka_consumer_group_metadata_t;</span>
<span class="s1">typedef struct rd_kafka_error_s {</span>
<span class="s1">  unsigned int code;</span>
<span class="s1">  char *errstr;</span>
<span class="s1">  unsigned char fatal;</span>
<span class="s1">  unsigned char retriable;</span>
<span class="s1">  unsigned char txn_requires_abort;</span>
<span class="s1">} rd_kafka_error_t;</span>
<span class="s1">typedef struct rd_kafka_headers_s rd_kafka_headers_t;</span>
<span class="s1">typedef struct rd_kafka_group_result_s rd_kafka_group_result_t;</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BEGIN = (- 200),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BAD_MSG = (- 199),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BAD_COMPRESSION = (- 198),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__DESTROY = (- 197),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FAIL = (- 196),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TRANSPORT = (- 195),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__CRIT_SYS_RESOURCE = (- 194),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__RESOLVE = (- 193),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__MSG_TIMED_OUT = (- 192),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PARTITION_EOF = (- 191),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION = (- 190),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FS = (- 189),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC = (- 188),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ALL_BROKERS_DOWN = (- 187),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INVALID_ARG = (- 186),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TIMED_OUT = (- 185),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__QUEUE_FULL = (- 184),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ISR_INSUFF = (- 183),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NODE_UPDATE = (- 182),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__SSL = (- 181),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__WAIT_COORD = (- 180),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_GROUP = (- 179),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__IN_PROGRESS = (- 178),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PREV_IN_PROGRESS = (- 177),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__EXISTING_SUBSCRIPTION = (- 176),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS = (- 175),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS = (- 174),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__CONFLICT = (- 173),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__STATE = (- 172),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_PROTOCOL = (- 171),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED = (- 170),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__AUTHENTICATION = (- 169),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NO_OFFSET = (- 168),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__OUTDATED = (- 167),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TIMED_OUT_QUEUE = (- 166),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNSUPPORTED_FEATURE = (- 165),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__WAIT_CACHE = (- 164),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INTR = (- 163),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__KEY_SERIALIZATION = (- 162),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__VALUE_SERIALIZATION = (- 161),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__KEY_DESERIALIZATION = (- 160),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__VALUE_DESERIALIZATION = (- 159),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PARTIAL = (- 158),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__READ_ONLY = (- 157),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOENT = (- 156),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNDERFLOW = (- 155),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INVALID_TYPE = (- 154),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__RETRY = (- 153),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PURGE_QUEUE = (- 152),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PURGE_INFLIGHT = (- 151),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FATAL = (- 150),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INCONSISTENT = (- 149),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__GAPLESS_GUARANTEE = (- 148),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__MAX_POLL_EXCEEDED = (- 147),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_BROKER = (- 146),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOT_CONFIGURED = (- 145),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FENCED = (- 144),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__APPLICATION = (- 143),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ASSIGNMENT_LOST = (- 142),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOOP = (- 141),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__AUTO_OFFSET_RESET = (- 140),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__END = (- 100),</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN = (- 1),</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NO_ERROR = 0,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_OUT_OF_RANGE = 1,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_MSG = 2,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART = 3,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_MSG_SIZE = 4,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE = 5,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_LEADER_FOR_PARTITION = 6,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REQUEST_TIMED_OUT = 7,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_BROKER_NOT_AVAILABLE = 8,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REPLICA_NOT_AVAILABLE = 9,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE = 10,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_STALE_CTRL_EPOCH = 11,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_METADATA_TOO_LARGE = 12,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NETWORK_EXCEPTION = 13,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_COORDINATOR_LOAD_IN_PROGRESS = 14,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_COORDINATOR_NOT_AVAILABLE = 15,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_COORDINATOR = 16,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_EXCEPTION = 17,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_RECORD_LIST_TOO_LARGE = 18,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS = 19,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS_AFTER_APPEND = 20,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REQUIRED_ACKS = 21,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ILLEGAL_GENERATION = 22,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INCONSISTENT_GROUP_PROTOCOL = 23,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_GROUP_ID = 24,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_MEMBER_ID = 25,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_SESSION_TIMEOUT = 26,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REBALANCE_IN_PROGRESS = 27,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_COMMIT_OFFSET_SIZE = 28,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_AUTHORIZATION_FAILED = 29,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_AUTHORIZATION_FAILED = 30,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_CLUSTER_AUTHORIZATION_FAILED = 31,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TIMESTAMP = 32,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_SASL_MECHANISM = 33,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ILLEGAL_SASL_STATE = 34,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_VERSION = 35,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_ALREADY_EXISTS = 36,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PARTITIONS = 37,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REPLICATION_FACTOR = 38,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REPLICA_ASSIGNMENT = 39,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_CONFIG = 40,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_CONTROLLER = 41,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REQUEST = 42,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_FOR_MESSAGE_FORMAT = 43,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_POLICY_VIOLATION = 44,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OUT_OF_ORDER_SEQUENCE_NUMBER = 45,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DUPLICATE_SEQUENCE_NUMBER = 46,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_EPOCH = 47,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TXN_STATE = 48,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_ID_MAPPING = 49,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TRANSACTION_TIMEOUT = 50,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_CONCURRENT_TRANSACTIONS = 51,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TRANSACTION_COORDINATOR_FENCED = 52,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TRANSACTIONAL_ID_AUTHORIZATION_FAILED = 53,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_SECURITY_DISABLED = 54,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OPERATION_NOT_ATTEMPTED = 55,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_KAFKA_STORAGE_ERROR = 56,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LOG_DIR_NOT_FOUND = 57,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_SASL_AUTHENTICATION_FAILED = 58,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_PRODUCER_ID = 59,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REASSIGNMENT_IN_PROGRESS = 60,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTH_DISABLED = 61,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_NOT_FOUND = 62,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_OWNER_MISMATCH = 63,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_REQUEST_NOT_ALLOWED = 64,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTHORIZATION_FAILED = 65,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_EXPIRED = 66,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRINCIPAL_TYPE = 67,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NON_EMPTY_GROUP = 68,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_ID_NOT_FOUND = 69,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FETCH_SESSION_ID_NOT_FOUND = 70,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_FETCH_SESSION_EPOCH = 71,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LISTENER_NOT_FOUND = 72,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_DELETION_DISABLED = 73,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FENCED_LEADER_EPOCH = 74,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_LEADER_EPOCH = 75,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_STALE_BROKER_EPOCH = 77,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_NOT_AVAILABLE = 78,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_MEMBER_ID_REQUIRED = 79,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_PREFERRED_LEADER_NOT_AVAILABLE = 80,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_MAX_SIZE_REACHED = 81,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FENCED_INSTANCE_ID = 82,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ELIGIBLE_LEADERS_NOT_AVAILABLE = 83,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ELECTION_NOT_NEEDED = 84,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NO_REASSIGNMENT_IN_PROGRESS = 85,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_SUBSCRIBED_TO_TOPIC = 86,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_RECORD = 87,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSTABLE_OFFSET_COMMIT = 88,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_THROTTLING_QUOTA_EXCEEDED = 89,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_PRODUCER_FENCED = 90,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_RESOURCE_NOT_FOUND = 91,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DUPLICATE_RESOURCE = 92,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNACCEPTABLE_CREDENTIAL = 93,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INCONSISTENT_VOTER_SET = 94,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_UPDATE_VERSION = 95,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FEATURE_UPDATE_FAILED = 96,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_PRINCIPAL_DESERIALIZATION_FAILURE = 97,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_END_ALL,</span>
<span class="s1">} rd_kafka_resp_err_t;</span>
<span class="s1">struct rd_kafka_err_desc {</span>
<span class="s1">  rd_kafka_resp_err_t code;</span>
<span class="s1">  char *name;</span>
<span class="s1">  char *desc;</span>
<span class="s1">};</span>
<span class="s1">void rd_kafka_get_err_descs(const struct rd_kafka_err_desc **errdescs, size_t *cntp);</span>
<span class="s1">const char *rd_kafka_err2str(rd_kafka_resp_err_t err);</span>
<span class="s1">const char *rd_kafka_err2name(rd_kafka_resp_err_t err);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_last_error(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_errno2err(int errnox);</span>
<span class="s1">int rd_kafka_errno(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_fatal_error(rd_kafka_t *rk, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_test_fatal_error(rd_kafka_t *rk, rd_kafka_resp_err_t err, const char *reason);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_error_code(const rd_kafka_error_t *error);</span>
<span class="s1">const char *rd_kafka_error_name(const rd_kafka_error_t *error);</span>
<span class="s1">const char *rd_kafka_error_string(const rd_kafka_error_t *error);</span>
<span class="s1">int rd_kafka_error_is_fatal(const rd_kafka_error_t *error);</span>
<span class="s1">int rd_kafka_error_is_retriable(const rd_kafka_error_t *error);</span>
<span class="s1">int rd_kafka_error_txn_requires_abort(const rd_kafka_error_t *error);</span>
<span class="s1">void rd_kafka_error_destroy(rd_kafka_error_t *error);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_error_new(rd_kafka_resp_err_t code, const char *fmt, ...);</span>
<span class="s1">typedef struct rd_kafka_topic_partition_s {</span>
<span class="s1">  char *topic;</span>
<span class="s1">  int32_t partition;</span>
<span class="s1">  int64_t offset;</span>
<span class="s1">  void *metadata;</span>
<span class="s1">  size_t metadata_size;</span>
<span class="s1">  void *opaque;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  void *_private;</span>
<span class="s1">} rd_kafka_topic_partition_t;</span>
<span class="s1">void rd_kafka_topic_partition_destroy(rd_kafka_topic_partition_t *rktpar);</span>
<span class="s1">typedef struct rd_kafka_topic_partition_list_s {</span>
<span class="s1">  int cnt;</span>
<span class="s1">  int size;</span>
<span class="s1">  rd_kafka_topic_partition_t *elems;</span>
<span class="s1">} rd_kafka_topic_partition_list_t;</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_new(int size);</span>
<span class="s1">void rd_kafka_topic_partition_list_destroy(rd_kafka_topic_partition_list_t *rkparlist);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_add(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">void rd_kafka_topic_partition_list_add_range(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t start, int32_t stop);</span>
<span class="s1">int rd_kafka_topic_partition_list_del(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">int rd_kafka_topic_partition_list_del_by_idx(rd_kafka_topic_partition_list_t *rktparlist, int idx);</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_copy(const rd_kafka_topic_partition_list_t *src);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_topic_partition_list_set_offset(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition, int64_t offset);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_find(const rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">void rd_kafka_topic_partition_list_sort(rd_kafka_topic_partition_list_t *rktparlist, int (*cmp)(const void *a, const void *b, void *cmp_opaque), void *cmp_opaque);</span>
<span class="s1">typedef enum rd_kafka_vtype_t {</span>
<span class="s1">  RD_KAFKA_VTYPE_END,</span>
<span class="s1">  RD_KAFKA_VTYPE_TOPIC,</span>
<span class="s1">  RD_KAFKA_VTYPE_RKT,</span>
<span class="s1">  RD_KAFKA_VTYPE_PARTITION,</span>
<span class="s1">  RD_KAFKA_VTYPE_VALUE,</span>
<span class="s1">  RD_KAFKA_VTYPE_KEY,</span>
<span class="s1">  RD_KAFKA_VTYPE_OPAQUE,</span>
<span class="s1">  RD_KAFKA_VTYPE_MSGFLAGS,</span>
<span class="s1">  RD_KAFKA_VTYPE_TIMESTAMP,</span>
<span class="s1">  RD_KAFKA_VTYPE_HEADER,</span>
<span class="s1">  RD_KAFKA_VTYPE_HEADERS,</span>
<span class="s1">} rd_kafka_vtype_t;</span>
<span class="s1">typedef struct rd_kafka_vu_s {</span>
<span class="s1">  rd_kafka_vtype_t vtype;</span>
<span class="s1">  union {</span>
<span class="s1">    char *cstr;</span>
<span class="s1">    rd_kafka_topic_t *rkt;</span>
<span class="s1">    int i;</span>
<span class="s1">    int32_t i32;</span>
<span class="s1">    int64_t i64;</span>
<span class="s1">    struct {</span>
<span class="s1">      void *ptr;</span>
<span class="s1">      size_t size;</span>
<span class="s1">    } mem;</span>
<span class="s1">    struct {</span>
<span class="s1">      char *name;</span>
<span class="s1">      void *val;</span>
<span class="s1">      ssize_t size;</span>
<span class="s1">    } header;</span>
<span class="s1">    rd_kafka_headers_t *headers;</span>
<span class="s1">    void *ptr;</span>
<span class="s1">    char _pad[64];</span>
<span class="s1">  } u;</span>
<span class="s1">} rd_kafka_vu_t;</span>
<span class="s1">rd_kafka_headers_t *rd_kafka_headers_new(size_t initial_count);</span>
<span class="s1">void rd_kafka_headers_destroy(rd_kafka_headers_t *hdrs);</span>
<span class="s1">rd_kafka_headers_t *rd_kafka_headers_copy(const rd_kafka_headers_t *src);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_add(rd_kafka_headers_t *hdrs, const char *name, ssize_t name_size, const void *value, ssize_t value_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_remove(rd_kafka_headers_t *hdrs, const char *name);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get_last(const rd_kafka_headers_t *hdrs, const char *name, const void **valuep, size_t *sizep);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get(const rd_kafka_headers_t *hdrs, size_t idx, const char *name, const void **valuep, size_t *sizep);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get_all(const rd_kafka_headers_t *hdrs, size_t idx, const char **namep, const void **valuep, size_t *sizep);</span>
<span class="s1">typedef struct rd_kafka_message_s {</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  rd_kafka_topic_t *rkt;</span>
<span class="s1">  int32_t partition;</span>
<span class="s1">  void *payload;</span>
<span class="s1">  size_t len;</span>
<span class="s1">  void *key;</span>
<span class="s1">  size_t key_len;</span>
<span class="s1">  int64_t offset;</span>
<span class="s1">  void *_private;</span>
<span class="s1">} rd_kafka_message_t;</span>
<span class="s1">void rd_kafka_message_destroy(rd_kafka_message_t *rkmessage);</span>
<span class="s1">const char *rd_kafka_message_errstr(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">int64_t rd_kafka_message_timestamp(const rd_kafka_message_t *rkmessage, rd_kafka_timestamp_type_t *tstype);</span>
<span class="s1">int64_t rd_kafka_message_latency(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">int32_t rd_kafka_message_broker_id(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_message_headers(const rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_message_detach_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);</span>
<span class="s1">void rd_kafka_message_set_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t *hdrs);</span>
<span class="s1">size_t rd_kafka_header_cnt(const rd_kafka_headers_t *hdrs);</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_NOT_PERSISTED = 0,</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_POSSIBLY_PERSISTED = 1,</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_PERSISTED = 2,</span>
<span class="s1">} rd_kafka_msg_status_t;</span>
<span class="s1">rd_kafka_msg_status_t rd_kafka_message_status(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_CONF_UNKNOWN = (- 2),</span>
<span class="s1">  RD_KAFKA_CONF_INVALID = (- 1),</span>
<span class="s1">  RD_KAFKA_CONF_OK = 0,</span>
<span class="s1">} rd_kafka_conf_res_t;</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_new(void);</span>
<span class="s1">void rd_kafka_conf_destroy(rd_kafka_conf_t *conf);</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_dup(const rd_kafka_conf_t *conf);</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_dup_filter(const rd_kafka_conf_t *conf, size_t filter_cnt, const char **filter);</span>
<span class="s1">const rd_kafka_conf_t *rd_kafka_conf(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_set(rd_kafka_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_conf_set_events(rd_kafka_conf_t *conf, int events);</span>
<span class="s1">void rd_kafka_conf_set_background_event_cb(rd_kafka_conf_t *conf, void (*event_cb)(rd_kafka_t *rk, rd_kafka_event_t *rkev, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_dr_cb(rd_kafka_conf_t *conf, void (*dr_cb)(rd_kafka_t *rk, void *payload, size_t len, rd_kafka_resp_err_t err, void *opaque, void *msg_opaque));</span>
<span class="s1">void rd_kafka_conf_set_dr_msg_cb(rd_kafka_conf_t *conf, void (*dr_msg_cb)(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_consume_cb(rd_kafka_conf_t *conf, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_rebalance_cb(rd_kafka_conf_t *conf, void (*rebalance_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *partitions, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_offset_commit_cb(rd_kafka_conf_t *conf, void (*offset_commit_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_error_cb(rd_kafka_conf_t *conf, void (*error_cb)(rd_kafka_t *rk, int err, const char *reason, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_throttle_cb(rd_kafka_conf_t *conf, void (*throttle_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int throttle_time_ms, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_log_cb(rd_kafka_conf_t *conf, void (*log_cb)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));</span>
<span class="s1">void rd_kafka_conf_set_stats_cb(rd_kafka_conf_t *conf, int (*stats_cb)(rd_kafka_t *rk, char *json, size_t json_len, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_oauthbearer_token_refresh_cb(rd_kafka_conf_t *conf, void (*oauthbearer_token_refresh_cb)(rd_kafka_t *rk, const char *oauthbearer_config, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_socket_cb(rd_kafka_conf_t *conf, int (*socket_cb)(int domain, int type, int protocol, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_connect_cb(rd_kafka_conf_t *conf, int (*connect_cb)(int sockfd, const struct sockaddr *addr, int addrlen, const char *id, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_closesocket_cb(rd_kafka_conf_t *conf, int (*closesocket_cb)(int sockfd, void *opaque));</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert_verify_cb(rd_kafka_conf_t *conf, int (*ssl_cert_verify_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int *x509_error, int depth, const char *buf, size_t size, char *errstr, size_t errstr_size, void *opaque));</span>
<span class="s1">typedef enum rd_kafka_cert_type_t {</span>
<span class="s1">  RD_KAFKA_CERT_PUBLIC_KEY,</span>
<span class="s1">  RD_KAFKA_CERT_PRIVATE_KEY,</span>
<span class="s1">  RD_KAFKA_CERT_CA,</span>
<span class="s1">  RD_KAFKA_CERT__CNT,</span>
<span class="s1">} rd_kafka_cert_type_t;</span>
<span class="s1">typedef enum rd_kafka_cert_enc_t {</span>
<span class="s1">  RD_KAFKA_CERT_ENC_PKCS12,</span>
<span class="s1">  RD_KAFKA_CERT_ENC_DER,</span>
<span class="s1">  RD_KAFKA_CERT_ENC_PEM,</span>
<span class="s1">  RD_KAFKA_CERT_ENC__CNT,</span>
<span class="s1">} rd_kafka_cert_enc_t;</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert(rd_kafka_conf_t *conf, rd_kafka_cert_type_t cert_type, rd_kafka_cert_enc_t cert_enc, const void *buffer, size_t size, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_conf_set_engine_callback_data(rd_kafka_conf_t *conf, void *callback_data);</span>
<span class="s1">void rd_kafka_conf_set_opaque(rd_kafka_conf_t *conf, void *opaque);</span>
<span class="s1">void *rd_kafka_opaque(const rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_conf_set_default_topic_conf(rd_kafka_conf_t *conf, rd_kafka_topic_conf_t *tconf);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_conf_get_default_topic_conf(rd_kafka_conf_t *conf);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_get(const rd_kafka_conf_t *conf, const char *name, char *dest, size_t *dest_size);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_topic_conf_get(const rd_kafka_topic_conf_t *conf, const char *name, char *dest, size_t *dest_size);</span>
<span class="s1">const char **rd_kafka_conf_dump(rd_kafka_conf_t *conf, size_t *cntp);</span>
<span class="s1">const char **rd_kafka_topic_conf_dump(rd_kafka_topic_conf_t *conf, size_t *cntp);</span>
<span class="s1">void rd_kafka_conf_dump_free(const char **arr, size_t cnt);</span>
<span class="s1">void rd_kafka_conf_properties_show(FILE *fp);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_topic_conf_new(void);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_topic_conf_dup(const rd_kafka_topic_conf_t *conf);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_default_topic_conf_dup(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_topic_conf_destroy(rd_kafka_topic_conf_t *topic_conf);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_topic_conf_set(rd_kafka_topic_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_topic_conf_set_opaque(rd_kafka_topic_conf_t *conf, void *rkt_opaque);</span>
<span class="s1">void rd_kafka_topic_conf_set_partitioner_cb(rd_kafka_topic_conf_t *topic_conf, int32_t (*partitioner)(const rd_kafka_topic_t *rkt, const void *keydata, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque));</span>
<span class="s1">void rd_kafka_topic_conf_set_msg_order_cmp(rd_kafka_topic_conf_t *topic_conf, int (*msg_order_cmp)(const rd_kafka_message_t *a, const rd_kafka_message_t *b));</span>
<span class="s1">int rd_kafka_topic_partition_available(const rd_kafka_topic_t *rkt, int32_t partition);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_consistent(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_consistent_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_murmur2(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_murmur2_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_fnv1a(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_fnv1a_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">rd_kafka_t *rd_kafka_new(rd_kafka_type_t type, rd_kafka_conf_t *conf, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_destroy(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_destroy_flags(rd_kafka_t *rk, int flags);</span>
<span class="s1">const char *rd_kafka_name(const rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_type_t rd_kafka_type(const rd_kafka_t *rk);</span>
<span class="s1">char *rd_kafka_memberid(const rd_kafka_t *rk);</span>
<span class="s1">char *rd_kafka_clusterid(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">int32_t rd_kafka_controllerid(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_topic_t *rd_kafka_topic_new(rd_kafka_t *rk, const char *topic, rd_kafka_topic_conf_t *conf);</span>
<span class="s1">void rd_kafka_topic_destroy(rd_kafka_topic_t *rkt);</span>
<span class="s1">const char *rd_kafka_topic_name(const rd_kafka_topic_t *rkt);</span>
<span class="s1">void *rd_kafka_topic_opaque(const rd_kafka_topic_t *rkt);</span>
<span class="s1">int rd_kafka_poll(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">void rd_kafka_yield(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_pause_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_resume_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_query_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_get_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offsets_for_times(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets, int timeout_ms);</span>
<span class="s1">void *rd_kafka_mem_calloc(rd_kafka_t *rk, size_t num, size_t size);</span>
<span class="s1">void *rd_kafka_mem_malloc(rd_kafka_t *rk, size_t size);</span>
<span class="s1">void rd_kafka_mem_free(rd_kafka_t *rk, void *ptr);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_new(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_queue_destroy(rd_kafka_queue_t *rkqu);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_main(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_consumer(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_partition(rd_kafka_t *rk, const char *topic, int32_t partition);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_background(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_queue_forward(rd_kafka_queue_t *src, rd_kafka_queue_t *dst);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_set_log_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu);</span>
<span class="s1">size_t rd_kafka_queue_length(rd_kafka_queue_t *rkqu);</span>
<span class="s1">void rd_kafka_queue_io_event_enable(rd_kafka_queue_t *rkqu, int fd, const void *payload, size_t size);</span>
<span class="s1">void rd_kafka_queue_cb_event_enable(rd_kafka_queue_t *rkqu, void (*event_cb)(rd_kafka_t *rk, void *qev_opaque), void *qev_opaque);</span>
<span class="s1">void rd_kafka_queue_yield(rd_kafka_queue_t *rkqu);</span>
<span class="s1">int rd_kafka_consume_start(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);</span>
<span class="s1">int rd_kafka_consume_start_queue(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, rd_kafka_queue_t *rkqu);</span>
<span class="s1">int rd_kafka_consume_stop(rd_kafka_topic_t *rkt, int32_t partition);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_seek(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, int timeout_ms);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_seek_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consume(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms);</span>
<span class="s1">ssize_t rd_kafka_consume_batch(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);</span>
<span class="s1">int rd_kafka_consume_callback(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consume_queue(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">ssize_t rd_kafka_consume_batch_queue(rd_kafka_queue_t *rkqu, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);</span>
<span class="s1">int rd_kafka_consume_callback_queue(rd_kafka_queue_t *rkqu, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offset_store(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offsets_store(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_subscribe(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *topics);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_unsubscribe(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_subscription(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **topics);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consumer_poll(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_consumer_close(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_incremental_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_incremental_unassign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">const char *rd_kafka_rebalance_protocol(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_assignment(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **partitions);</span>
<span class="s1">int rd_kafka_assignment_lost(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, int async);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit_message(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, int async);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit_queue(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_queue_t *rkqu, void (*cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *commit_opaque), void *commit_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_committed(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_position(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata_new(const char *group_id);</span>
<span class="s1">rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata_new_with_genid(const char *group_id, int32_t generation_id, const char *member_id, const char *group_instance_id);</span>
<span class="s1">void rd_kafka_consumer_group_metadata_destroy(rd_kafka_consumer_group_metadata_t *);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_consumer_group_metadata_write(const rd_kafka_consumer_group_metadata_t *cgmd, void **bufferp, size_t *sizep);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_consumer_group_metadata_read(rd_kafka_consumer_group_metadata_t **cgmdp, const void *buffer, size_t size);</span>
<span class="s1">int rd_kafka_produce(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, void *payload, size_t len, const void *key, size_t keylen, void *msg_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_producev(rd_kafka_t *rk, ...);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_produceva(rd_kafka_t *rk, const rd_kafka_vu_t *vus, size_t cnt);</span>
<span class="s1">int rd_kafka_produce_batch(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, rd_kafka_message_t *rkmessages, int message_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_flush(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_purge(rd_kafka_t *rk, int purge_flags);</span>
<span class="s1">typedef struct rd_kafka_metadata_broker {</span>
<span class="s1">  int32_t id;</span>
<span class="s1">  char *host;</span>
<span class="s1">  int port;</span>
<span class="s1">} rd_kafka_metadata_broker_t;</span>
<span class="s1">typedef struct rd_kafka_metadata_partition {</span>
<span class="s1">  int32_t id;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  int32_t leader;</span>
<span class="s1">  int replica_cnt;</span>
<span class="s1">  int32_t *replicas;</span>
<span class="s1">  int isr_cnt;</span>
<span class="s1">  int32_t *isrs;</span>
<span class="s1">} rd_kafka_metadata_partition_t;</span>
<span class="s1">typedef struct rd_kafka_metadata_topic {</span>
<span class="s1">  char *topic;</span>
<span class="s1">  int partition_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_partition *partitions;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">} rd_kafka_metadata_topic_t;</span>
<span class="s1">typedef struct rd_kafka_metadata {</span>
<span class="s1">  int broker_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_broker *brokers;</span>
<span class="s1">  int topic_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_topic *topics;</span>
<span class="s1">  int32_t orig_broker_id;</span>
<span class="s1">  char *orig_broker_name;</span>
<span class="s1">} rd_kafka_metadata_t;</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_metadata(rd_kafka_t *rk, int all_topics, rd_kafka_topic_t *only_rkt, const struct rd_kafka_metadata **metadatap, int timeout_ms);</span>
<span class="s1">void rd_kafka_metadata_destroy(const struct rd_kafka_metadata *metadata);</span>
<span class="s1">struct rd_kafka_group_member_info {</span>
<span class="s1">  char *member_id;</span>
<span class="s1">  char *client_id;</span>
<span class="s1">  char *client_host;</span>
<span class="s1">  void *member_metadata;</span>
<span class="s1">  int member_metadata_size;</span>
<span class="s1">  void *member_assignment;</span>
<span class="s1">  int member_assignment_size;</span>
<span class="s1">};</span>
<span class="s1">struct rd_kafka_group_info {</span>
<span class="s1">  struct rd_kafka_metadata_broker broker;</span>
<span class="s1">  char *group;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  char *state;</span>
<span class="s1">  char *protocol_type;</span>
<span class="s1">  char *protocol;</span>
<span class="s1">  struct rd_kafka_group_member_info *members;</span>
<span class="s1">  int member_cnt;</span>
<span class="s1">};</span>
<span class="s1">struct rd_kafka_group_list {</span>
<span class="s1">  struct rd_kafka_group_info *groups;</span>
<span class="s1">  int group_cnt;</span>
<span class="s1">};</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_list_groups(rd_kafka_t *rk, const char *group, const struct rd_kafka_group_list **grplistp, int timeout_ms);</span>
<span class="s1">void rd_kafka_group_list_destroy(const struct rd_kafka_group_list *grplist);</span>
<span class="s1">int rd_kafka_brokers_add(rd_kafka_t *rk, const char *brokerlist);</span>
<span class="s1">void rd_kafka_set_logger(rd_kafka_t *rk, void (*func)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));</span>
<span class="s1">void rd_kafka_set_log_level(rd_kafka_t *rk, int level);</span>
<span class="s1">void rd_kafka_log_print(const rd_kafka_t *rk, int level, const char *fac, const char *buf);</span>
<span class="s1">void rd_kafka_log_syslog(const rd_kafka_t *rk, int level, const char *fac, const char *buf);</span>
<span class="s1">int rd_kafka_outq_len(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_dump(FILE *fp, rd_kafka_t *rk);</span>
<span class="s1">int rd_kafka_thread_cnt(void);</span>
<span class="s1">typedef enum rd_kafka_thread_type_t {</span>
<span class="s1">  RD_KAFKA_THREAD_MAIN,</span>
<span class="s1">  RD_KAFKA_THREAD_BACKGROUND,</span>
<span class="s1">  RD_KAFKA_THREAD_BROKER,</span>
<span class="s1">} rd_kafka_thread_type_t;</span>
<span class="s1">int rd_kafka_wait_destroyed(int timeout_ms);</span>
<span class="s1">int rd_kafka_unittest(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_poll_set_consumer(rd_kafka_t *rk);</span>
<span class="s1">typedef int rd_kafka_event_type_t;</span>
<span class="s1">rd_kafka_event_type_t rd_kafka_event_type(const rd_kafka_event_t *rkev);</span>
<span class="s1">const char *rd_kafka_event_name(const rd_kafka_event_t *rkev);</span>
<span class="s1">void rd_kafka_event_destroy(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_message_t *rd_kafka_event_message_next(rd_kafka_event_t *rkev);</span>
<span class="s1">size_t rd_kafka_event_message_array(rd_kafka_event_t *rkev, const rd_kafka_message_t **rkmessages, size_t size);</span>
<span class="s1">size_t rd_kafka_event_message_count(rd_kafka_event_t *rkev);</span>
<span class="s1">const char *rd_kafka_event_config_string(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_event_error(rd_kafka_event_t *rkev);</span>
<span class="s1">const char *rd_kafka_event_error_string(rd_kafka_event_t *rkev);</span>
<span class="s1">int rd_kafka_event_error_is_fatal(rd_kafka_event_t *rkev);</span>
<span class="s1">void *rd_kafka_event_opaque(rd_kafka_event_t *rkev);</span>
<span class="s1">int rd_kafka_event_log(rd_kafka_event_t *rkev, const char **fac, const char **str, int *level);</span>
<span class="s1">int rd_kafka_event_debug_contexts(rd_kafka_event_t *rkev, char *dst, size_t dstsize);</span>
<span class="s1">const char *rd_kafka_event_stats(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_event_topic_partition_list(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_event_topic_partition(rd_kafka_event_t *rkev);</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_CreateTopics_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DeleteTopics_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_CreatePartitions_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_AlterConfigs_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DescribeConfigs_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DeleteRecords_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DeleteGroups_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DeleteConsumerGroupOffsets_result_t;</span>
<span class="s1">const rd_kafka_CreateTopics_result_t *rd_kafka_event_CreateTopics_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DeleteTopics_result_t *rd_kafka_event_DeleteTopics_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_CreatePartitions_result_t *rd_kafka_event_CreatePartitions_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_AlterConfigs_result_t *rd_kafka_event_AlterConfigs_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DescribeConfigs_result_t *rd_kafka_event_DescribeConfigs_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DeleteRecords_result_t *rd_kafka_event_DeleteRecords_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DeleteGroups_result_t *rd_kafka_event_DeleteGroups_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DeleteConsumerGroupOffsets_result_t *rd_kafka_event_DeleteConsumerGroupOffsets_result(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_event_t *rd_kafka_queue_poll(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">int rd_kafka_queue_poll_callback(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_plugin_f_conf_init_t)(rd_kafka_conf_t *conf, void **plug_opaquep, char *errstr, size_t errstr_size);</span>
<span class="s1">typedef rd_kafka_conf_res_t (rd_kafka_interceptor_f_on_conf_set_t)(rd_kafka_conf_t *conf, const char *name, const char *val, char *errstr, size_t errstr_size, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_dup_t)(rd_kafka_conf_t *new_conf, const rd_kafka_conf_t *old_conf, size_t filter_cnt, const char **filter, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_destroy_t)(void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_new_t)(rd_kafka_t *rk, const rd_kafka_conf_t *conf, void *ic_opaque, char *errstr, size_t errstr_size);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_destroy_t)(rd_kafka_t *rk, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_send_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_acknowledgement_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_consume_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_commit_t)(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_resp_err_t err, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_request_sent_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_response_received_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, int64_t rtt, rd_kafka_resp_err_t err, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_start_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_exit_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_set(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_set_t *on_conf_set, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_dup(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_dup_t *on_conf_dup, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_destroy(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_destroy_t *on_conf_destroy, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_new(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_new_t *on_new, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_destroy(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_destroy_t *on_destroy, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_send(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_send_t *on_send, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_acknowledgement(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_acknowledgement_t *on_acknowledgement, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_consume(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_consume_t *on_consume, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_commit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_commit_t *on_commit, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_request_sent(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_request_sent_t *on_request_sent, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_response_received(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_response_received_t *on_response_received, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_start(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_start_t *on_thread_start, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_exit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_exit_t *on_thread_exit, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_topic_result_error(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">const char *rd_kafka_topic_result_error_string(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">const char *rd_kafka_topic_result_name(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">const rd_kafka_error_t *rd_kafka_group_result_error(const rd_kafka_group_result_t *groupres);</span>
<span class="s1">const char *rd_kafka_group_result_name(const rd_kafka_group_result_t *groupres);</span>
<span class="s1">const rd_kafka_topic_partition_list_t *rd_kafka_group_result_partitions(const rd_kafka_group_result_t *groupres);</span>
<span class="s1">typedef enum rd_kafka_admin_op_t {</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_ANY = 0,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_CREATETOPICS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DELETETOPICS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_CREATEPARTITIONS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_ALTERCONFIGS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DESCRIBECONFIGS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DELETERECORDS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DELETEGROUPS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DELETECONSUMERGROUPOFFSETS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP__CNT,</span>
<span class="s1">} rd_kafka_admin_op_t;</span>
<span class="s1">typedef struct rd_kafka_AdminOptions_s rd_kafka_AdminOptions_t;</span>
<span class="s1">rd_kafka_AdminOptions_t *rd_kafka_AdminOptions_new(rd_kafka_t *rk, rd_kafka_admin_op_t for_api);</span>
<span class="s1">void rd_kafka_AdminOptions_destroy(rd_kafka_AdminOptions_t *options);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_request_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_operation_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_validate_only(rd_kafka_AdminOptions_t *options, int true_or_false, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_broker(rd_kafka_AdminOptions_t *options, int32_t broker_id, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_AdminOptions_set_opaque(rd_kafka_AdminOptions_t *options, void *ev_opaque);</span>
<span class="s1">typedef struct rd_kafka_NewTopic_s rd_kafka_NewTopic_t;</span>
<span class="s1">rd_kafka_NewTopic_t *rd_kafka_NewTopic_new(const char *topic, int num_partitions, int replication_factor, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_NewTopic_destroy(rd_kafka_NewTopic_t *new_topic);</span>
<span class="s1">void rd_kafka_NewTopic_destroy_array(rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewTopic_set_replica_assignment(rd_kafka_NewTopic_t *new_topic, int32_t partition, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewTopic_set_config(rd_kafka_NewTopic_t *new_topic, const char *name, const char *value);</span>
<span class="s1">void rd_kafka_CreateTopics(rd_kafka_t *rk, rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_CreateTopics_result_topics(const rd_kafka_CreateTopics_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_DeleteTopic_s rd_kafka_DeleteTopic_t;</span>
<span class="s1">rd_kafka_DeleteTopic_t *rd_kafka_DeleteTopic_new(const char *topic);</span>
<span class="s1">void rd_kafka_DeleteTopic_destroy(rd_kafka_DeleteTopic_t *del_topic);</span>
<span class="s1">void rd_kafka_DeleteTopic_destroy_array(rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt);</span>
<span class="s1">void rd_kafka_DeleteTopics(rd_kafka_t *rk, rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_DeleteTopics_result_topics(const rd_kafka_DeleteTopics_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_NewPartitions_s rd_kafka_NewPartitions_t;</span>
<span class="s1">rd_kafka_NewPartitions_t *rd_kafka_NewPartitions_new(const char *topic, size_t new_total_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_NewPartitions_destroy(rd_kafka_NewPartitions_t *new_parts);</span>
<span class="s1">void rd_kafka_NewPartitions_destroy_array(rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewPartitions_set_replica_assignment(rd_kafka_NewPartitions_t *new_parts, int32_t new_partition_idx, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_CreatePartitions(rd_kafka_t *rk, rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_CreatePartitions_result_topics(const rd_kafka_CreatePartitions_result_t *result, size_t *cntp);</span>
<span class="s1">typedef enum rd_kafka_ConfigSource_t {</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_UNKNOWN_CONFIG = 0,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_TOPIC_CONFIG = 1,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_BROKER_CONFIG = 2,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_DEFAULT_BROKER_CONFIG = 3,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_STATIC_BROKER_CONFIG = 4,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DEFAULT_CONFIG = 5,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE__CNT,</span>
<span class="s1">} rd_kafka_ConfigSource_t;</span>
<span class="s1">const char *rd_kafka_ConfigSource_name(rd_kafka_ConfigSource_t confsource);</span>
<span class="s1">typedef struct rd_kafka_ConfigEntry_s rd_kafka_ConfigEntry_t;</span>
<span class="s1">const char *rd_kafka_ConfigEntry_name(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">const char *rd_kafka_ConfigEntry_value(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">rd_kafka_ConfigSource_t rd_kafka_ConfigEntry_source(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_read_only(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_default(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_sensitive(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_synonym(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">const rd_kafka_ConfigEntry_t **rd_kafka_ConfigEntry_synonyms(const rd_kafka_ConfigEntry_t *entry, size_t *cntp);</span>
<span class="s1">typedef enum rd_kafka_ResourceType_t {</span>
<span class="s1">  RD_KAFKA_RESOURCE_UNKNOWN = 0,</span>
<span class="s1">  RD_KAFKA_RESOURCE_ANY = 1,</span>
<span class="s1">  RD_KAFKA_RESOURCE_TOPIC = 2,</span>
<span class="s1">  RD_KAFKA_RESOURCE_GROUP = 3,</span>
<span class="s1">  RD_KAFKA_RESOURCE_BROKER = 4,</span>
<span class="s1">  RD_KAFKA_RESOURCE__CNT,</span>
<span class="s1">} rd_kafka_ResourceType_t;</span>
<span class="s1">const char *rd_kafka_ResourceType_name(rd_kafka_ResourceType_t restype);</span>
<span class="s1">typedef struct rd_kafka_ConfigResource_s rd_kafka_ConfigResource_t;</span>
<span class="s1">rd_kafka_ConfigResource_t *rd_kafka_ConfigResource_new(rd_kafka_ResourceType_t restype, const char *resname);</span>
<span class="s1">void rd_kafka_ConfigResource_destroy(rd_kafka_ConfigResource_t *config);</span>
<span class="s1">void rd_kafka_ConfigResource_destroy_array(rd_kafka_ConfigResource_t **config, size_t config_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_ConfigResource_set_config(rd_kafka_ConfigResource_t *config, const char *name, const char *value);</span>
<span class="s1">const rd_kafka_ConfigEntry_t **rd_kafka_ConfigResource_configs(const rd_kafka_ConfigResource_t *config, size_t *cntp);</span>
<span class="s1">rd_kafka_ResourceType_t rd_kafka_ConfigResource_type(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">const char *rd_kafka_ConfigResource_name(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_ConfigResource_error(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">const char *rd_kafka_ConfigResource_error_string(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">void rd_kafka_AlterConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_ConfigResource_t **rd_kafka_AlterConfigs_result_resources(const rd_kafka_AlterConfigs_result_t *result, size_t *cntp);</span>
<span class="s1">void rd_kafka_DescribeConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_ConfigResource_t **rd_kafka_DescribeConfigs_result_resources(const rd_kafka_DescribeConfigs_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_DeleteRecords_s rd_kafka_DeleteRecords_t;</span>
<span class="s1">rd_kafka_DeleteRecords_t *rd_kafka_DeleteRecords_new(const rd_kafka_topic_partition_list_t *before_offsets);</span>
<span class="s1">void rd_kafka_DeleteRecords_destroy(rd_kafka_DeleteRecords_t *del_records);</span>
<span class="s1">void rd_kafka_DeleteRecords_destroy_array(rd_kafka_DeleteRecords_t **del_records, size_t del_record_cnt);</span>
<span class="s1">void rd_kafka_DeleteRecords(rd_kafka_t *rk, rd_kafka_DeleteRecords_t **del_records, size_t del_record_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_partition_list_t *rd_kafka_DeleteRecords_result_offsets(const rd_kafka_DeleteRecords_result_t *result);</span>
<span class="s1">typedef struct rd_kafka_DeleteGroup_s rd_kafka_DeleteGroup_t;</span>
<span class="s1">rd_kafka_DeleteGroup_t *rd_kafka_DeleteGroup_new(const char *group);</span>
<span class="s1">void rd_kafka_DeleteGroup_destroy(rd_kafka_DeleteGroup_t *del_group);</span>
<span class="s1">void rd_kafka_DeleteGroup_destroy_array(rd_kafka_DeleteGroup_t **del_groups, size_t del_group_cnt);</span>
<span class="s1">void rd_kafka_DeleteGroups(rd_kafka_t *rk, rd_kafka_DeleteGroup_t **del_groups, size_t del_group_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_group_result_t **rd_kafka_DeleteGroups_result_groups(const rd_kafka_DeleteGroups_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_DeleteConsumerGroupOffsets_s rd_kafka_DeleteConsumerGroupOffsets_t;</span>
<span class="s1">rd_kafka_DeleteConsumerGroupOffsets_t *rd_kafka_DeleteConsumerGroupOffsets_new(const char *group, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">void rd_kafka_DeleteConsumerGroupOffsets_destroy(rd_kafka_DeleteConsumerGroupOffsets_t *del_grpoffsets);</span>
<span class="s1">void rd_kafka_DeleteConsumerGroupOffsets_destroy_array(rd_kafka_DeleteConsumerGroupOffsets_t **del_grpoffsets, size_t del_grpoffset_cnt);</span>
<span class="s1">void rd_kafka_DeleteConsumerGroupOffsets(rd_kafka_t *rk, rd_kafka_DeleteConsumerGroupOffsets_t **del_grpoffsets, size_t del_grpoffsets_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_group_result_t **rd_kafka_DeleteConsumerGroupOffsets_result_groups(const rd_kafka_DeleteConsumerGroupOffsets_result_t *result, size_t *cntp);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token(rd_kafka_t *rk, const char *token_value, int64_t md_lifetime_ms, const char *md_principal_name, const char **extensions, size_t extension_size, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token_failure(rd_kafka_t *rk, const char *errstr);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_init_transactions(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_begin_transaction(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_send_offsets_to_transaction(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, const rd_kafka_consumer_group_metadata_t *cgmetadata, int timeout_ms);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_commit_transaction(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_abort_transaction(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">typedef struct rd_kafka_mock_cluster_s rd_kafka_mock_cluster_t;</span>
<span class="s1">rd_kafka_mock_cluster_t *rd_kafka_mock_cluster_new(rd_kafka_t *rk, int broker_cnt);</span>
<span class="s1">void rd_kafka_mock_cluster_destroy(rd_kafka_mock_cluster_t *mcluster);</span>
<span class="s1">rd_kafka_t *rd_kafka_mock_cluster_handle(const rd_kafka_mock_cluster_t *mcluster);</span>
<span class="s1">rd_kafka_mock_cluster_t *rd_kafka_handle_mock_cluster(const rd_kafka_t *rk);</span>
<span class="s1">const char *rd_kafka_mock_cluster_bootstraps(const rd_kafka_mock_cluster_t *mcluster);</span>
<span class="s1">void rd_kafka_mock_clear_request_errors(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey);</span>
<span class="s1">void rd_kafka_mock_push_request_errors(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, size_t cnt, ...);</span>
<span class="s1">void rd_kafka_mock_push_request_errors_array(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, size_t cnt, const rd_kafka_resp_err_t *errors);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_push_request_error_rtts(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int16_t ApiKey, size_t cnt, ...);</span>
<span class="s1">void rd_kafka_mock_topic_set_error(rd_kafka_mock_cluster_t *mcluster, const char *topic, rd_kafka_resp_err_t err);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_topic_create(rd_kafka_mock_cluster_t *mcluster, const char *topic, int partition_cnt, int replication_factor);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_partition_set_leader(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_partition_set_follower(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_partition_set_follower_wmarks(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int64_t lo, int64_t hi);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_set_down(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_set_up(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_set_rtt(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int rtt_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_set_rack(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, const char *rack);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_coordinator_set(rd_kafka_mock_cluster_t *mcluster, const char *key_type, const char *key, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_set_apiversion(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, int16_t MinVersion, int16_t MaxVersion);</span>
<span class="s1">&#39;</span>
</code></pre></div>
rdkafka.h, rdkafka_mock.h</p>
<h3 id="rd_kafka_version_17">RD_KAFKA_VERSION<a class="headerlink" href="#rd_kafka_version_17" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_VERSION</span> <span class="o">=</span> <span class="mi">17301759</span>
</code></pre></div>
<p>librdkafka version </p>
<p>Interpreted as hex <code>MM.mm.rr.xx</code>:</p>
<ul>
<li>MM = Major</li>
<li>mm = minor</li>
<li>rr = revision</li>
<li>xx = pre-release id (0xff is the final release)</li>
</ul>
<p>E.g.: <code>0x000801ff</code> = 0.8.1</p>
<dl class="section remark"><dt>Remarks</dt><dd>This value should only be used during compile time, for runtime checks of version use rd_kafka_version() </dd></dl>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_unsupported_compression_type_17">RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE<a class="headerlink" href="#rd_kafka_resp_err_unsupported_compression_type_17" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE</span> <span class="o">=</span> <span class="mi">76</span>
</code></pre></div>
<p>Unsupported compression type </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_end_all_17">RD_KAFKA_RESP_ERR_END_ALL<a class="headerlink" href="#rd_kafka_resp_err_end_all_17" title="Permanent link">&para;</a></h3>
<p><div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_END_ALL</span> <span class="o">=</span> <span class="mi">98</span>
</code></pre></div>
enum rd_kafka_resp_err_t</p>
<h3 id="rd_kafka_admin_op__cnt_17">RD_KAFKA_ADMIN_OP__CNT<a class="headerlink" href="#rd_kafka_admin_op__cnt_17" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_ADMIN_OP__CNT</span> <span class="o">=</span> <span class="mi">9</span>
</code></pre></div>
<p>Number of ops defined </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe </a></li>
</ul>
</div>
<h3 id="rd_kafka_resource__cnt_17">RD_KAFKA_RESOURCE__CNT<a class="headerlink" href="#rd_kafka_resource__cnt_17" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESOURCE__CNT</span> <span class="o">=</span> <span class="mi">5</span>
</code></pre></div>
<p>Number of resource types defined </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#acca83a66d7783ff7683ed2691cc907c9"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#acca83a66d7783ff7683ed2691cc907c9 </a></li>
</ul>
</div>
<h3 id="rd_kafka_cdef_17">RD_KAFKA_CDEF<a class="headerlink" href="#rd_kafka_cdef_17" title="Permanent link">&para;</a></h3>
<p><div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_CDEF</span> <span class="o">=</span> <span class="s1">&#39;typedef long int ssize_t;</span>
<span class="s1">typedef struct _IO_FILE FILE;</span>
<span class="s1">typedef long int mode_t;</span>
<span class="s1">typedef signed int int16_t;</span>
<span class="s1">typedef unsigned int uint16_t;</span>
<span class="s1">typedef signed int int32_t;</span>
<span class="s1">typedef signed long int int64_t;</span>
<span class="s1">int rd_kafka_version(void);</span>
<span class="s1">const char *rd_kafka_version_str(void);</span>
<span class="s1">typedef enum rd_kafka_type_t {</span>
<span class="s1">  RD_KAFKA_PRODUCER,</span>
<span class="s1">  RD_KAFKA_CONSUMER,</span>
<span class="s1">} rd_kafka_type_t;</span>
<span class="s1">typedef enum rd_kafka_timestamp_type_t {</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_NOT_AVAILABLE,</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_CREATE_TIME,</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_LOG_APPEND_TIME,</span>
<span class="s1">} rd_kafka_timestamp_type_t;</span>
<span class="s1">const char *rd_kafka_get_debug_contexts(void);</span>
<span class="s1">typedef struct rd_kafka_s rd_kafka_t;</span>
<span class="s1">typedef struct rd_kafka_topic_s rd_kafka_topic_t;</span>
<span class="s1">typedef struct rd_kafka_conf_s rd_kafka_conf_t;</span>
<span class="s1">typedef struct rd_kafka_topic_conf_s rd_kafka_topic_conf_t;</span>
<span class="s1">typedef struct rd_kafka_queue_s rd_kafka_queue_t;</span>
<span class="s1">typedef struct rd_kafka_op_s rd_kafka_event_t;</span>
<span class="s1">typedef struct rd_kafka_topic_result_s rd_kafka_topic_result_t;</span>
<span class="s1">typedef struct rd_kafka_consumer_group_metadata_s rd_kafka_consumer_group_metadata_t;</span>
<span class="s1">typedef struct rd_kafka_error_s {</span>
<span class="s1">  unsigned int code;</span>
<span class="s1">  char *errstr;</span>
<span class="s1">  unsigned char fatal;</span>
<span class="s1">  unsigned char retriable;</span>
<span class="s1">  unsigned char txn_requires_abort;</span>
<span class="s1">} rd_kafka_error_t;</span>
<span class="s1">typedef struct rd_kafka_headers_s rd_kafka_headers_t;</span>
<span class="s1">typedef struct rd_kafka_group_result_s rd_kafka_group_result_t;</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BEGIN = (- 200),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BAD_MSG = (- 199),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BAD_COMPRESSION = (- 198),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__DESTROY = (- 197),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FAIL = (- 196),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TRANSPORT = (- 195),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__CRIT_SYS_RESOURCE = (- 194),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__RESOLVE = (- 193),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__MSG_TIMED_OUT = (- 192),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PARTITION_EOF = (- 191),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION = (- 190),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FS = (- 189),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC = (- 188),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ALL_BROKERS_DOWN = (- 187),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INVALID_ARG = (- 186),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TIMED_OUT = (- 185),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__QUEUE_FULL = (- 184),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ISR_INSUFF = (- 183),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NODE_UPDATE = (- 182),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__SSL = (- 181),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__WAIT_COORD = (- 180),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_GROUP = (- 179),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__IN_PROGRESS = (- 178),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PREV_IN_PROGRESS = (- 177),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__EXISTING_SUBSCRIPTION = (- 176),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS = (- 175),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS = (- 174),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__CONFLICT = (- 173),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__STATE = (- 172),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_PROTOCOL = (- 171),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED = (- 170),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__AUTHENTICATION = (- 169),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NO_OFFSET = (- 168),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__OUTDATED = (- 167),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TIMED_OUT_QUEUE = (- 166),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNSUPPORTED_FEATURE = (- 165),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__WAIT_CACHE = (- 164),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INTR = (- 163),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__KEY_SERIALIZATION = (- 162),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__VALUE_SERIALIZATION = (- 161),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__KEY_DESERIALIZATION = (- 160),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__VALUE_DESERIALIZATION = (- 159),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PARTIAL = (- 158),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__READ_ONLY = (- 157),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOENT = (- 156),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNDERFLOW = (- 155),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INVALID_TYPE = (- 154),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__RETRY = (- 153),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PURGE_QUEUE = (- 152),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PURGE_INFLIGHT = (- 151),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FATAL = (- 150),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INCONSISTENT = (- 149),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__GAPLESS_GUARANTEE = (- 148),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__MAX_POLL_EXCEEDED = (- 147),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_BROKER = (- 146),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOT_CONFIGURED = (- 145),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FENCED = (- 144),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__APPLICATION = (- 143),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ASSIGNMENT_LOST = (- 142),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOOP = (- 141),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__AUTO_OFFSET_RESET = (- 140),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__END = (- 100),</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN = (- 1),</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NO_ERROR = 0,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_OUT_OF_RANGE = 1,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_MSG = 2,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART = 3,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_MSG_SIZE = 4,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE = 5,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_LEADER_FOR_PARTITION = 6,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REQUEST_TIMED_OUT = 7,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_BROKER_NOT_AVAILABLE = 8,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REPLICA_NOT_AVAILABLE = 9,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE = 10,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_STALE_CTRL_EPOCH = 11,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_METADATA_TOO_LARGE = 12,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NETWORK_EXCEPTION = 13,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_COORDINATOR_LOAD_IN_PROGRESS = 14,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_COORDINATOR_NOT_AVAILABLE = 15,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_COORDINATOR = 16,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_EXCEPTION = 17,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_RECORD_LIST_TOO_LARGE = 18,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS = 19,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS_AFTER_APPEND = 20,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REQUIRED_ACKS = 21,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ILLEGAL_GENERATION = 22,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INCONSISTENT_GROUP_PROTOCOL = 23,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_GROUP_ID = 24,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_MEMBER_ID = 25,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_SESSION_TIMEOUT = 26,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REBALANCE_IN_PROGRESS = 27,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_COMMIT_OFFSET_SIZE = 28,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_AUTHORIZATION_FAILED = 29,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_AUTHORIZATION_FAILED = 30,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_CLUSTER_AUTHORIZATION_FAILED = 31,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TIMESTAMP = 32,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_SASL_MECHANISM = 33,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ILLEGAL_SASL_STATE = 34,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_VERSION = 35,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_ALREADY_EXISTS = 36,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PARTITIONS = 37,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REPLICATION_FACTOR = 38,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REPLICA_ASSIGNMENT = 39,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_CONFIG = 40,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_CONTROLLER = 41,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REQUEST = 42,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_FOR_MESSAGE_FORMAT = 43,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_POLICY_VIOLATION = 44,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OUT_OF_ORDER_SEQUENCE_NUMBER = 45,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DUPLICATE_SEQUENCE_NUMBER = 46,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_EPOCH = 47,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TXN_STATE = 48,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_ID_MAPPING = 49,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TRANSACTION_TIMEOUT = 50,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_CONCURRENT_TRANSACTIONS = 51,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TRANSACTION_COORDINATOR_FENCED = 52,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TRANSACTIONAL_ID_AUTHORIZATION_FAILED = 53,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_SECURITY_DISABLED = 54,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OPERATION_NOT_ATTEMPTED = 55,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_KAFKA_STORAGE_ERROR = 56,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LOG_DIR_NOT_FOUND = 57,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_SASL_AUTHENTICATION_FAILED = 58,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_PRODUCER_ID = 59,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REASSIGNMENT_IN_PROGRESS = 60,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTH_DISABLED = 61,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_NOT_FOUND = 62,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_OWNER_MISMATCH = 63,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_REQUEST_NOT_ALLOWED = 64,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTHORIZATION_FAILED = 65,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_EXPIRED = 66,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRINCIPAL_TYPE = 67,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NON_EMPTY_GROUP = 68,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_ID_NOT_FOUND = 69,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FETCH_SESSION_ID_NOT_FOUND = 70,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_FETCH_SESSION_EPOCH = 71,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LISTENER_NOT_FOUND = 72,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_DELETION_DISABLED = 73,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FENCED_LEADER_EPOCH = 74,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_LEADER_EPOCH = 75,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_STALE_BROKER_EPOCH = 77,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_NOT_AVAILABLE = 78,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_MEMBER_ID_REQUIRED = 79,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_PREFERRED_LEADER_NOT_AVAILABLE = 80,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_MAX_SIZE_REACHED = 81,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FENCED_INSTANCE_ID = 82,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ELIGIBLE_LEADERS_NOT_AVAILABLE = 83,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ELECTION_NOT_NEEDED = 84,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NO_REASSIGNMENT_IN_PROGRESS = 85,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_SUBSCRIBED_TO_TOPIC = 86,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_RECORD = 87,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSTABLE_OFFSET_COMMIT = 88,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_THROTTLING_QUOTA_EXCEEDED = 89,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_PRODUCER_FENCED = 90,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_RESOURCE_NOT_FOUND = 91,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DUPLICATE_RESOURCE = 92,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNACCEPTABLE_CREDENTIAL = 93,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INCONSISTENT_VOTER_SET = 94,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_UPDATE_VERSION = 95,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FEATURE_UPDATE_FAILED = 96,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_PRINCIPAL_DESERIALIZATION_FAILURE = 97,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_END_ALL,</span>
<span class="s1">} rd_kafka_resp_err_t;</span>
<span class="s1">struct rd_kafka_err_desc {</span>
<span class="s1">  rd_kafka_resp_err_t code;</span>
<span class="s1">  char *name;</span>
<span class="s1">  char *desc;</span>
<span class="s1">};</span>
<span class="s1">void rd_kafka_get_err_descs(const struct rd_kafka_err_desc **errdescs, size_t *cntp);</span>
<span class="s1">const char *rd_kafka_err2str(rd_kafka_resp_err_t err);</span>
<span class="s1">const char *rd_kafka_err2name(rd_kafka_resp_err_t err);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_last_error(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_errno2err(int errnox);</span>
<span class="s1">int rd_kafka_errno(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_fatal_error(rd_kafka_t *rk, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_test_fatal_error(rd_kafka_t *rk, rd_kafka_resp_err_t err, const char *reason);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_error_code(const rd_kafka_error_t *error);</span>
<span class="s1">const char *rd_kafka_error_name(const rd_kafka_error_t *error);</span>
<span class="s1">const char *rd_kafka_error_string(const rd_kafka_error_t *error);</span>
<span class="s1">int rd_kafka_error_is_fatal(const rd_kafka_error_t *error);</span>
<span class="s1">int rd_kafka_error_is_retriable(const rd_kafka_error_t *error);</span>
<span class="s1">int rd_kafka_error_txn_requires_abort(const rd_kafka_error_t *error);</span>
<span class="s1">void rd_kafka_error_destroy(rd_kafka_error_t *error);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_error_new(rd_kafka_resp_err_t code, const char *fmt, ...);</span>
<span class="s1">typedef struct rd_kafka_topic_partition_s {</span>
<span class="s1">  char *topic;</span>
<span class="s1">  int32_t partition;</span>
<span class="s1">  int64_t offset;</span>
<span class="s1">  void *metadata;</span>
<span class="s1">  size_t metadata_size;</span>
<span class="s1">  void *opaque;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  void *_private;</span>
<span class="s1">} rd_kafka_topic_partition_t;</span>
<span class="s1">void rd_kafka_topic_partition_destroy(rd_kafka_topic_partition_t *rktpar);</span>
<span class="s1">typedef struct rd_kafka_topic_partition_list_s {</span>
<span class="s1">  int cnt;</span>
<span class="s1">  int size;</span>
<span class="s1">  rd_kafka_topic_partition_t *elems;</span>
<span class="s1">} rd_kafka_topic_partition_list_t;</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_new(int size);</span>
<span class="s1">void rd_kafka_topic_partition_list_destroy(rd_kafka_topic_partition_list_t *rkparlist);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_add(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">void rd_kafka_topic_partition_list_add_range(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t start, int32_t stop);</span>
<span class="s1">int rd_kafka_topic_partition_list_del(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">int rd_kafka_topic_partition_list_del_by_idx(rd_kafka_topic_partition_list_t *rktparlist, int idx);</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_copy(const rd_kafka_topic_partition_list_t *src);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_topic_partition_list_set_offset(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition, int64_t offset);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_find(const rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">void rd_kafka_topic_partition_list_sort(rd_kafka_topic_partition_list_t *rktparlist, int (*cmp)(const void *a, const void *b, void *cmp_opaque), void *cmp_opaque);</span>
<span class="s1">typedef enum rd_kafka_vtype_t {</span>
<span class="s1">  RD_KAFKA_VTYPE_END,</span>
<span class="s1">  RD_KAFKA_VTYPE_TOPIC,</span>
<span class="s1">  RD_KAFKA_VTYPE_RKT,</span>
<span class="s1">  RD_KAFKA_VTYPE_PARTITION,</span>
<span class="s1">  RD_KAFKA_VTYPE_VALUE,</span>
<span class="s1">  RD_KAFKA_VTYPE_KEY,</span>
<span class="s1">  RD_KAFKA_VTYPE_OPAQUE,</span>
<span class="s1">  RD_KAFKA_VTYPE_MSGFLAGS,</span>
<span class="s1">  RD_KAFKA_VTYPE_TIMESTAMP,</span>
<span class="s1">  RD_KAFKA_VTYPE_HEADER,</span>
<span class="s1">  RD_KAFKA_VTYPE_HEADERS,</span>
<span class="s1">} rd_kafka_vtype_t;</span>
<span class="s1">typedef struct rd_kafka_vu_s {</span>
<span class="s1">  rd_kafka_vtype_t vtype;</span>
<span class="s1">  union {</span>
<span class="s1">    char *cstr;</span>
<span class="s1">    rd_kafka_topic_t *rkt;</span>
<span class="s1">    int i;</span>
<span class="s1">    int32_t i32;</span>
<span class="s1">    int64_t i64;</span>
<span class="s1">    struct {</span>
<span class="s1">      void *ptr;</span>
<span class="s1">      size_t size;</span>
<span class="s1">    } mem;</span>
<span class="s1">    struct {</span>
<span class="s1">      char *name;</span>
<span class="s1">      void *val;</span>
<span class="s1">      ssize_t size;</span>
<span class="s1">    } header;</span>
<span class="s1">    rd_kafka_headers_t *headers;</span>
<span class="s1">    void *ptr;</span>
<span class="s1">    char _pad[64];</span>
<span class="s1">  } u;</span>
<span class="s1">} rd_kafka_vu_t;</span>
<span class="s1">rd_kafka_headers_t *rd_kafka_headers_new(size_t initial_count);</span>
<span class="s1">void rd_kafka_headers_destroy(rd_kafka_headers_t *hdrs);</span>
<span class="s1">rd_kafka_headers_t *rd_kafka_headers_copy(const rd_kafka_headers_t *src);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_add(rd_kafka_headers_t *hdrs, const char *name, ssize_t name_size, const void *value, ssize_t value_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_remove(rd_kafka_headers_t *hdrs, const char *name);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get_last(const rd_kafka_headers_t *hdrs, const char *name, const void **valuep, size_t *sizep);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get(const rd_kafka_headers_t *hdrs, size_t idx, const char *name, const void **valuep, size_t *sizep);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get_all(const rd_kafka_headers_t *hdrs, size_t idx, const char **namep, const void **valuep, size_t *sizep);</span>
<span class="s1">typedef struct rd_kafka_message_s {</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  rd_kafka_topic_t *rkt;</span>
<span class="s1">  int32_t partition;</span>
<span class="s1">  void *payload;</span>
<span class="s1">  size_t len;</span>
<span class="s1">  void *key;</span>
<span class="s1">  size_t key_len;</span>
<span class="s1">  int64_t offset;</span>
<span class="s1">  void *_private;</span>
<span class="s1">} rd_kafka_message_t;</span>
<span class="s1">void rd_kafka_message_destroy(rd_kafka_message_t *rkmessage);</span>
<span class="s1">const char *rd_kafka_message_errstr(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">int64_t rd_kafka_message_timestamp(const rd_kafka_message_t *rkmessage, rd_kafka_timestamp_type_t *tstype);</span>
<span class="s1">int64_t rd_kafka_message_latency(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">int32_t rd_kafka_message_broker_id(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_message_headers(const rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_message_detach_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);</span>
<span class="s1">void rd_kafka_message_set_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t *hdrs);</span>
<span class="s1">size_t rd_kafka_header_cnt(const rd_kafka_headers_t *hdrs);</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_NOT_PERSISTED = 0,</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_POSSIBLY_PERSISTED = 1,</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_PERSISTED = 2,</span>
<span class="s1">} rd_kafka_msg_status_t;</span>
<span class="s1">rd_kafka_msg_status_t rd_kafka_message_status(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_CONF_UNKNOWN = (- 2),</span>
<span class="s1">  RD_KAFKA_CONF_INVALID = (- 1),</span>
<span class="s1">  RD_KAFKA_CONF_OK = 0,</span>
<span class="s1">} rd_kafka_conf_res_t;</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_new(void);</span>
<span class="s1">void rd_kafka_conf_destroy(rd_kafka_conf_t *conf);</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_dup(const rd_kafka_conf_t *conf);</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_dup_filter(const rd_kafka_conf_t *conf, size_t filter_cnt, const char **filter);</span>
<span class="s1">const rd_kafka_conf_t *rd_kafka_conf(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_set(rd_kafka_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_conf_set_events(rd_kafka_conf_t *conf, int events);</span>
<span class="s1">void rd_kafka_conf_set_background_event_cb(rd_kafka_conf_t *conf, void (*event_cb)(rd_kafka_t *rk, rd_kafka_event_t *rkev, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_dr_cb(rd_kafka_conf_t *conf, void (*dr_cb)(rd_kafka_t *rk, void *payload, size_t len, rd_kafka_resp_err_t err, void *opaque, void *msg_opaque));</span>
<span class="s1">void rd_kafka_conf_set_dr_msg_cb(rd_kafka_conf_t *conf, void (*dr_msg_cb)(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_consume_cb(rd_kafka_conf_t *conf, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_rebalance_cb(rd_kafka_conf_t *conf, void (*rebalance_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *partitions, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_offset_commit_cb(rd_kafka_conf_t *conf, void (*offset_commit_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_error_cb(rd_kafka_conf_t *conf, void (*error_cb)(rd_kafka_t *rk, int err, const char *reason, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_throttle_cb(rd_kafka_conf_t *conf, void (*throttle_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int throttle_time_ms, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_log_cb(rd_kafka_conf_t *conf, void (*log_cb)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));</span>
<span class="s1">void rd_kafka_conf_set_stats_cb(rd_kafka_conf_t *conf, int (*stats_cb)(rd_kafka_t *rk, char *json, size_t json_len, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_oauthbearer_token_refresh_cb(rd_kafka_conf_t *conf, void (*oauthbearer_token_refresh_cb)(rd_kafka_t *rk, const char *oauthbearer_config, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_socket_cb(rd_kafka_conf_t *conf, int (*socket_cb)(int domain, int type, int protocol, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_connect_cb(rd_kafka_conf_t *conf, int (*connect_cb)(int sockfd, const struct sockaddr *addr, int addrlen, const char *id, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_closesocket_cb(rd_kafka_conf_t *conf, int (*closesocket_cb)(int sockfd, void *opaque));</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert_verify_cb(rd_kafka_conf_t *conf, int (*ssl_cert_verify_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int *x509_error, int depth, const char *buf, size_t size, char *errstr, size_t errstr_size, void *opaque));</span>
<span class="s1">typedef enum rd_kafka_cert_type_t {</span>
<span class="s1">  RD_KAFKA_CERT_PUBLIC_KEY,</span>
<span class="s1">  RD_KAFKA_CERT_PRIVATE_KEY,</span>
<span class="s1">  RD_KAFKA_CERT_CA,</span>
<span class="s1">  RD_KAFKA_CERT__CNT,</span>
<span class="s1">} rd_kafka_cert_type_t;</span>
<span class="s1">typedef enum rd_kafka_cert_enc_t {</span>
<span class="s1">  RD_KAFKA_CERT_ENC_PKCS12,</span>
<span class="s1">  RD_KAFKA_CERT_ENC_DER,</span>
<span class="s1">  RD_KAFKA_CERT_ENC_PEM,</span>
<span class="s1">  RD_KAFKA_CERT_ENC__CNT,</span>
<span class="s1">} rd_kafka_cert_enc_t;</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert(rd_kafka_conf_t *conf, rd_kafka_cert_type_t cert_type, rd_kafka_cert_enc_t cert_enc, const void *buffer, size_t size, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_conf_set_engine_callback_data(rd_kafka_conf_t *conf, void *callback_data);</span>
<span class="s1">void rd_kafka_conf_set_opaque(rd_kafka_conf_t *conf, void *opaque);</span>
<span class="s1">void *rd_kafka_opaque(const rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_conf_set_default_topic_conf(rd_kafka_conf_t *conf, rd_kafka_topic_conf_t *tconf);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_conf_get_default_topic_conf(rd_kafka_conf_t *conf);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_get(const rd_kafka_conf_t *conf, const char *name, char *dest, size_t *dest_size);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_topic_conf_get(const rd_kafka_topic_conf_t *conf, const char *name, char *dest, size_t *dest_size);</span>
<span class="s1">const char **rd_kafka_conf_dump(rd_kafka_conf_t *conf, size_t *cntp);</span>
<span class="s1">const char **rd_kafka_topic_conf_dump(rd_kafka_topic_conf_t *conf, size_t *cntp);</span>
<span class="s1">void rd_kafka_conf_dump_free(const char **arr, size_t cnt);</span>
<span class="s1">void rd_kafka_conf_properties_show(FILE *fp);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_topic_conf_new(void);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_topic_conf_dup(const rd_kafka_topic_conf_t *conf);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_default_topic_conf_dup(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_topic_conf_destroy(rd_kafka_topic_conf_t *topic_conf);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_topic_conf_set(rd_kafka_topic_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_topic_conf_set_opaque(rd_kafka_topic_conf_t *conf, void *rkt_opaque);</span>
<span class="s1">void rd_kafka_topic_conf_set_partitioner_cb(rd_kafka_topic_conf_t *topic_conf, int32_t (*partitioner)(const rd_kafka_topic_t *rkt, const void *keydata, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque));</span>
<span class="s1">void rd_kafka_topic_conf_set_msg_order_cmp(rd_kafka_topic_conf_t *topic_conf, int (*msg_order_cmp)(const rd_kafka_message_t *a, const rd_kafka_message_t *b));</span>
<span class="s1">int rd_kafka_topic_partition_available(const rd_kafka_topic_t *rkt, int32_t partition);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_consistent(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_consistent_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_murmur2(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_murmur2_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_fnv1a(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_fnv1a_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">rd_kafka_t *rd_kafka_new(rd_kafka_type_t type, rd_kafka_conf_t *conf, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_destroy(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_destroy_flags(rd_kafka_t *rk, int flags);</span>
<span class="s1">const char *rd_kafka_name(const rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_type_t rd_kafka_type(const rd_kafka_t *rk);</span>
<span class="s1">char *rd_kafka_memberid(const rd_kafka_t *rk);</span>
<span class="s1">char *rd_kafka_clusterid(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">int32_t rd_kafka_controllerid(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_topic_t *rd_kafka_topic_new(rd_kafka_t *rk, const char *topic, rd_kafka_topic_conf_t *conf);</span>
<span class="s1">void rd_kafka_topic_destroy(rd_kafka_topic_t *rkt);</span>
<span class="s1">const char *rd_kafka_topic_name(const rd_kafka_topic_t *rkt);</span>
<span class="s1">void *rd_kafka_topic_opaque(const rd_kafka_topic_t *rkt);</span>
<span class="s1">int rd_kafka_poll(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">void rd_kafka_yield(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_pause_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_resume_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_query_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_get_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offsets_for_times(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets, int timeout_ms);</span>
<span class="s1">void *rd_kafka_mem_calloc(rd_kafka_t *rk, size_t num, size_t size);</span>
<span class="s1">void *rd_kafka_mem_malloc(rd_kafka_t *rk, size_t size);</span>
<span class="s1">void rd_kafka_mem_free(rd_kafka_t *rk, void *ptr);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_new(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_queue_destroy(rd_kafka_queue_t *rkqu);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_main(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_consumer(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_partition(rd_kafka_t *rk, const char *topic, int32_t partition);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_background(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_queue_forward(rd_kafka_queue_t *src, rd_kafka_queue_t *dst);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_set_log_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu);</span>
<span class="s1">size_t rd_kafka_queue_length(rd_kafka_queue_t *rkqu);</span>
<span class="s1">void rd_kafka_queue_io_event_enable(rd_kafka_queue_t *rkqu, int fd, const void *payload, size_t size);</span>
<span class="s1">void rd_kafka_queue_cb_event_enable(rd_kafka_queue_t *rkqu, void (*event_cb)(rd_kafka_t *rk, void *qev_opaque), void *qev_opaque);</span>
<span class="s1">void rd_kafka_queue_yield(rd_kafka_queue_t *rkqu);</span>
<span class="s1">int rd_kafka_consume_start(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);</span>
<span class="s1">int rd_kafka_consume_start_queue(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, rd_kafka_queue_t *rkqu);</span>
<span class="s1">int rd_kafka_consume_stop(rd_kafka_topic_t *rkt, int32_t partition);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_seek(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, int timeout_ms);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_seek_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consume(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms);</span>
<span class="s1">ssize_t rd_kafka_consume_batch(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);</span>
<span class="s1">int rd_kafka_consume_callback(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consume_queue(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">ssize_t rd_kafka_consume_batch_queue(rd_kafka_queue_t *rkqu, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);</span>
<span class="s1">int rd_kafka_consume_callback_queue(rd_kafka_queue_t *rkqu, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offset_store(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offsets_store(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_subscribe(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *topics);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_unsubscribe(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_subscription(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **topics);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consumer_poll(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_consumer_close(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_incremental_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_incremental_unassign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">const char *rd_kafka_rebalance_protocol(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_assignment(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **partitions);</span>
<span class="s1">int rd_kafka_assignment_lost(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, int async);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit_message(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, int async);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit_queue(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_queue_t *rkqu, void (*cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *commit_opaque), void *commit_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_committed(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_position(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata_new(const char *group_id);</span>
<span class="s1">rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata_new_with_genid(const char *group_id, int32_t generation_id, const char *member_id, const char *group_instance_id);</span>
<span class="s1">void rd_kafka_consumer_group_metadata_destroy(rd_kafka_consumer_group_metadata_t *);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_consumer_group_metadata_write(const rd_kafka_consumer_group_metadata_t *cgmd, void **bufferp, size_t *sizep);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_consumer_group_metadata_read(rd_kafka_consumer_group_metadata_t **cgmdp, const void *buffer, size_t size);</span>
<span class="s1">int rd_kafka_produce(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, void *payload, size_t len, const void *key, size_t keylen, void *msg_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_producev(rd_kafka_t *rk, ...);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_produceva(rd_kafka_t *rk, const rd_kafka_vu_t *vus, size_t cnt);</span>
<span class="s1">int rd_kafka_produce_batch(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, rd_kafka_message_t *rkmessages, int message_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_flush(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_purge(rd_kafka_t *rk, int purge_flags);</span>
<span class="s1">typedef struct rd_kafka_metadata_broker {</span>
<span class="s1">  int32_t id;</span>
<span class="s1">  char *host;</span>
<span class="s1">  int port;</span>
<span class="s1">} rd_kafka_metadata_broker_t;</span>
<span class="s1">typedef struct rd_kafka_metadata_partition {</span>
<span class="s1">  int32_t id;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  int32_t leader;</span>
<span class="s1">  int replica_cnt;</span>
<span class="s1">  int32_t *replicas;</span>
<span class="s1">  int isr_cnt;</span>
<span class="s1">  int32_t *isrs;</span>
<span class="s1">} rd_kafka_metadata_partition_t;</span>
<span class="s1">typedef struct rd_kafka_metadata_topic {</span>
<span class="s1">  char *topic;</span>
<span class="s1">  int partition_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_partition *partitions;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">} rd_kafka_metadata_topic_t;</span>
<span class="s1">typedef struct rd_kafka_metadata {</span>
<span class="s1">  int broker_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_broker *brokers;</span>
<span class="s1">  int topic_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_topic *topics;</span>
<span class="s1">  int32_t orig_broker_id;</span>
<span class="s1">  char *orig_broker_name;</span>
<span class="s1">} rd_kafka_metadata_t;</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_metadata(rd_kafka_t *rk, int all_topics, rd_kafka_topic_t *only_rkt, const struct rd_kafka_metadata **metadatap, int timeout_ms);</span>
<span class="s1">void rd_kafka_metadata_destroy(const struct rd_kafka_metadata *metadata);</span>
<span class="s1">struct rd_kafka_group_member_info {</span>
<span class="s1">  char *member_id;</span>
<span class="s1">  char *client_id;</span>
<span class="s1">  char *client_host;</span>
<span class="s1">  void *member_metadata;</span>
<span class="s1">  int member_metadata_size;</span>
<span class="s1">  void *member_assignment;</span>
<span class="s1">  int member_assignment_size;</span>
<span class="s1">};</span>
<span class="s1">struct rd_kafka_group_info {</span>
<span class="s1">  struct rd_kafka_metadata_broker broker;</span>
<span class="s1">  char *group;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  char *state;</span>
<span class="s1">  char *protocol_type;</span>
<span class="s1">  char *protocol;</span>
<span class="s1">  struct rd_kafka_group_member_info *members;</span>
<span class="s1">  int member_cnt;</span>
<span class="s1">};</span>
<span class="s1">struct rd_kafka_group_list {</span>
<span class="s1">  struct rd_kafka_group_info *groups;</span>
<span class="s1">  int group_cnt;</span>
<span class="s1">};</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_list_groups(rd_kafka_t *rk, const char *group, const struct rd_kafka_group_list **grplistp, int timeout_ms);</span>
<span class="s1">void rd_kafka_group_list_destroy(const struct rd_kafka_group_list *grplist);</span>
<span class="s1">int rd_kafka_brokers_add(rd_kafka_t *rk, const char *brokerlist);</span>
<span class="s1">void rd_kafka_set_logger(rd_kafka_t *rk, void (*func)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));</span>
<span class="s1">void rd_kafka_set_log_level(rd_kafka_t *rk, int level);</span>
<span class="s1">void rd_kafka_log_print(const rd_kafka_t *rk, int level, const char *fac, const char *buf);</span>
<span class="s1">void rd_kafka_log_syslog(const rd_kafka_t *rk, int level, const char *fac, const char *buf);</span>
<span class="s1">int rd_kafka_outq_len(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_dump(FILE *fp, rd_kafka_t *rk);</span>
<span class="s1">int rd_kafka_thread_cnt(void);</span>
<span class="s1">typedef enum rd_kafka_thread_type_t {</span>
<span class="s1">  RD_KAFKA_THREAD_MAIN,</span>
<span class="s1">  RD_KAFKA_THREAD_BACKGROUND,</span>
<span class="s1">  RD_KAFKA_THREAD_BROKER,</span>
<span class="s1">} rd_kafka_thread_type_t;</span>
<span class="s1">int rd_kafka_wait_destroyed(int timeout_ms);</span>
<span class="s1">int rd_kafka_unittest(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_poll_set_consumer(rd_kafka_t *rk);</span>
<span class="s1">typedef int rd_kafka_event_type_t;</span>
<span class="s1">rd_kafka_event_type_t rd_kafka_event_type(const rd_kafka_event_t *rkev);</span>
<span class="s1">const char *rd_kafka_event_name(const rd_kafka_event_t *rkev);</span>
<span class="s1">void rd_kafka_event_destroy(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_message_t *rd_kafka_event_message_next(rd_kafka_event_t *rkev);</span>
<span class="s1">size_t rd_kafka_event_message_array(rd_kafka_event_t *rkev, const rd_kafka_message_t **rkmessages, size_t size);</span>
<span class="s1">size_t rd_kafka_event_message_count(rd_kafka_event_t *rkev);</span>
<span class="s1">const char *rd_kafka_event_config_string(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_event_error(rd_kafka_event_t *rkev);</span>
<span class="s1">const char *rd_kafka_event_error_string(rd_kafka_event_t *rkev);</span>
<span class="s1">int rd_kafka_event_error_is_fatal(rd_kafka_event_t *rkev);</span>
<span class="s1">void *rd_kafka_event_opaque(rd_kafka_event_t *rkev);</span>
<span class="s1">int rd_kafka_event_log(rd_kafka_event_t *rkev, const char **fac, const char **str, int *level);</span>
<span class="s1">int rd_kafka_event_debug_contexts(rd_kafka_event_t *rkev, char *dst, size_t dstsize);</span>
<span class="s1">const char *rd_kafka_event_stats(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_event_topic_partition_list(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_event_topic_partition(rd_kafka_event_t *rkev);</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_CreateTopics_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DeleteTopics_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_CreatePartitions_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_AlterConfigs_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DescribeConfigs_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DeleteRecords_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DeleteGroups_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DeleteConsumerGroupOffsets_result_t;</span>
<span class="s1">const rd_kafka_CreateTopics_result_t *rd_kafka_event_CreateTopics_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DeleteTopics_result_t *rd_kafka_event_DeleteTopics_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_CreatePartitions_result_t *rd_kafka_event_CreatePartitions_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_AlterConfigs_result_t *rd_kafka_event_AlterConfigs_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DescribeConfigs_result_t *rd_kafka_event_DescribeConfigs_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DeleteRecords_result_t *rd_kafka_event_DeleteRecords_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DeleteGroups_result_t *rd_kafka_event_DeleteGroups_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DeleteConsumerGroupOffsets_result_t *rd_kafka_event_DeleteConsumerGroupOffsets_result(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_event_t *rd_kafka_queue_poll(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">int rd_kafka_queue_poll_callback(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_plugin_f_conf_init_t)(rd_kafka_conf_t *conf, void **plug_opaquep, char *errstr, size_t errstr_size);</span>
<span class="s1">typedef rd_kafka_conf_res_t (rd_kafka_interceptor_f_on_conf_set_t)(rd_kafka_conf_t *conf, const char *name, const char *val, char *errstr, size_t errstr_size, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_dup_t)(rd_kafka_conf_t *new_conf, const rd_kafka_conf_t *old_conf, size_t filter_cnt, const char **filter, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_destroy_t)(void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_new_t)(rd_kafka_t *rk, const rd_kafka_conf_t *conf, void *ic_opaque, char *errstr, size_t errstr_size);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_destroy_t)(rd_kafka_t *rk, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_send_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_acknowledgement_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_consume_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_commit_t)(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_resp_err_t err, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_request_sent_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_response_received_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, int64_t rtt, rd_kafka_resp_err_t err, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_start_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_exit_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_set(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_set_t *on_conf_set, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_dup(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_dup_t *on_conf_dup, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_destroy(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_destroy_t *on_conf_destroy, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_new(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_new_t *on_new, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_destroy(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_destroy_t *on_destroy, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_send(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_send_t *on_send, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_acknowledgement(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_acknowledgement_t *on_acknowledgement, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_consume(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_consume_t *on_consume, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_commit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_commit_t *on_commit, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_request_sent(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_request_sent_t *on_request_sent, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_response_received(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_response_received_t *on_response_received, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_start(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_start_t *on_thread_start, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_exit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_exit_t *on_thread_exit, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_topic_result_error(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">const char *rd_kafka_topic_result_error_string(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">const char *rd_kafka_topic_result_name(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">const rd_kafka_error_t *rd_kafka_group_result_error(const rd_kafka_group_result_t *groupres);</span>
<span class="s1">const char *rd_kafka_group_result_name(const rd_kafka_group_result_t *groupres);</span>
<span class="s1">const rd_kafka_topic_partition_list_t *rd_kafka_group_result_partitions(const rd_kafka_group_result_t *groupres);</span>
<span class="s1">typedef enum rd_kafka_admin_op_t {</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_ANY = 0,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_CREATETOPICS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DELETETOPICS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_CREATEPARTITIONS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_ALTERCONFIGS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DESCRIBECONFIGS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DELETERECORDS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DELETEGROUPS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DELETECONSUMERGROUPOFFSETS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP__CNT,</span>
<span class="s1">} rd_kafka_admin_op_t;</span>
<span class="s1">typedef struct rd_kafka_AdminOptions_s rd_kafka_AdminOptions_t;</span>
<span class="s1">rd_kafka_AdminOptions_t *rd_kafka_AdminOptions_new(rd_kafka_t *rk, rd_kafka_admin_op_t for_api);</span>
<span class="s1">void rd_kafka_AdminOptions_destroy(rd_kafka_AdminOptions_t *options);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_request_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_operation_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_validate_only(rd_kafka_AdminOptions_t *options, int true_or_false, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_broker(rd_kafka_AdminOptions_t *options, int32_t broker_id, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_AdminOptions_set_opaque(rd_kafka_AdminOptions_t *options, void *ev_opaque);</span>
<span class="s1">typedef struct rd_kafka_NewTopic_s rd_kafka_NewTopic_t;</span>
<span class="s1">rd_kafka_NewTopic_t *rd_kafka_NewTopic_new(const char *topic, int num_partitions, int replication_factor, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_NewTopic_destroy(rd_kafka_NewTopic_t *new_topic);</span>
<span class="s1">void rd_kafka_NewTopic_destroy_array(rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewTopic_set_replica_assignment(rd_kafka_NewTopic_t *new_topic, int32_t partition, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewTopic_set_config(rd_kafka_NewTopic_t *new_topic, const char *name, const char *value);</span>
<span class="s1">void rd_kafka_CreateTopics(rd_kafka_t *rk, rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_CreateTopics_result_topics(const rd_kafka_CreateTopics_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_DeleteTopic_s rd_kafka_DeleteTopic_t;</span>
<span class="s1">rd_kafka_DeleteTopic_t *rd_kafka_DeleteTopic_new(const char *topic);</span>
<span class="s1">void rd_kafka_DeleteTopic_destroy(rd_kafka_DeleteTopic_t *del_topic);</span>
<span class="s1">void rd_kafka_DeleteTopic_destroy_array(rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt);</span>
<span class="s1">void rd_kafka_DeleteTopics(rd_kafka_t *rk, rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_DeleteTopics_result_topics(const rd_kafka_DeleteTopics_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_NewPartitions_s rd_kafka_NewPartitions_t;</span>
<span class="s1">rd_kafka_NewPartitions_t *rd_kafka_NewPartitions_new(const char *topic, size_t new_total_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_NewPartitions_destroy(rd_kafka_NewPartitions_t *new_parts);</span>
<span class="s1">void rd_kafka_NewPartitions_destroy_array(rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewPartitions_set_replica_assignment(rd_kafka_NewPartitions_t *new_parts, int32_t new_partition_idx, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_CreatePartitions(rd_kafka_t *rk, rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_CreatePartitions_result_topics(const rd_kafka_CreatePartitions_result_t *result, size_t *cntp);</span>
<span class="s1">typedef enum rd_kafka_ConfigSource_t {</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_UNKNOWN_CONFIG = 0,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_TOPIC_CONFIG = 1,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_BROKER_CONFIG = 2,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_DEFAULT_BROKER_CONFIG = 3,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_STATIC_BROKER_CONFIG = 4,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DEFAULT_CONFIG = 5,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE__CNT,</span>
<span class="s1">} rd_kafka_ConfigSource_t;</span>
<span class="s1">const char *rd_kafka_ConfigSource_name(rd_kafka_ConfigSource_t confsource);</span>
<span class="s1">typedef struct rd_kafka_ConfigEntry_s rd_kafka_ConfigEntry_t;</span>
<span class="s1">const char *rd_kafka_ConfigEntry_name(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">const char *rd_kafka_ConfigEntry_value(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">rd_kafka_ConfigSource_t rd_kafka_ConfigEntry_source(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_read_only(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_default(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_sensitive(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_synonym(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">const rd_kafka_ConfigEntry_t **rd_kafka_ConfigEntry_synonyms(const rd_kafka_ConfigEntry_t *entry, size_t *cntp);</span>
<span class="s1">typedef enum rd_kafka_ResourceType_t {</span>
<span class="s1">  RD_KAFKA_RESOURCE_UNKNOWN = 0,</span>
<span class="s1">  RD_KAFKA_RESOURCE_ANY = 1,</span>
<span class="s1">  RD_KAFKA_RESOURCE_TOPIC = 2,</span>
<span class="s1">  RD_KAFKA_RESOURCE_GROUP = 3,</span>
<span class="s1">  RD_KAFKA_RESOURCE_BROKER = 4,</span>
<span class="s1">  RD_KAFKA_RESOURCE__CNT,</span>
<span class="s1">} rd_kafka_ResourceType_t;</span>
<span class="s1">const char *rd_kafka_ResourceType_name(rd_kafka_ResourceType_t restype);</span>
<span class="s1">typedef struct rd_kafka_ConfigResource_s rd_kafka_ConfigResource_t;</span>
<span class="s1">rd_kafka_ConfigResource_t *rd_kafka_ConfigResource_new(rd_kafka_ResourceType_t restype, const char *resname);</span>
<span class="s1">void rd_kafka_ConfigResource_destroy(rd_kafka_ConfigResource_t *config);</span>
<span class="s1">void rd_kafka_ConfigResource_destroy_array(rd_kafka_ConfigResource_t **config, size_t config_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_ConfigResource_set_config(rd_kafka_ConfigResource_t *config, const char *name, const char *value);</span>
<span class="s1">const rd_kafka_ConfigEntry_t **rd_kafka_ConfigResource_configs(const rd_kafka_ConfigResource_t *config, size_t *cntp);</span>
<span class="s1">rd_kafka_ResourceType_t rd_kafka_ConfigResource_type(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">const char *rd_kafka_ConfigResource_name(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_ConfigResource_error(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">const char *rd_kafka_ConfigResource_error_string(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">void rd_kafka_AlterConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_ConfigResource_t **rd_kafka_AlterConfigs_result_resources(const rd_kafka_AlterConfigs_result_t *result, size_t *cntp);</span>
<span class="s1">void rd_kafka_DescribeConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_ConfigResource_t **rd_kafka_DescribeConfigs_result_resources(const rd_kafka_DescribeConfigs_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_DeleteRecords_s rd_kafka_DeleteRecords_t;</span>
<span class="s1">rd_kafka_DeleteRecords_t *rd_kafka_DeleteRecords_new(const rd_kafka_topic_partition_list_t *before_offsets);</span>
<span class="s1">void rd_kafka_DeleteRecords_destroy(rd_kafka_DeleteRecords_t *del_records);</span>
<span class="s1">void rd_kafka_DeleteRecords_destroy_array(rd_kafka_DeleteRecords_t **del_records, size_t del_record_cnt);</span>
<span class="s1">void rd_kafka_DeleteRecords(rd_kafka_t *rk, rd_kafka_DeleteRecords_t **del_records, size_t del_record_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_partition_list_t *rd_kafka_DeleteRecords_result_offsets(const rd_kafka_DeleteRecords_result_t *result);</span>
<span class="s1">typedef struct rd_kafka_DeleteGroup_s rd_kafka_DeleteGroup_t;</span>
<span class="s1">rd_kafka_DeleteGroup_t *rd_kafka_DeleteGroup_new(const char *group);</span>
<span class="s1">void rd_kafka_DeleteGroup_destroy(rd_kafka_DeleteGroup_t *del_group);</span>
<span class="s1">void rd_kafka_DeleteGroup_destroy_array(rd_kafka_DeleteGroup_t **del_groups, size_t del_group_cnt);</span>
<span class="s1">void rd_kafka_DeleteGroups(rd_kafka_t *rk, rd_kafka_DeleteGroup_t **del_groups, size_t del_group_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_group_result_t **rd_kafka_DeleteGroups_result_groups(const rd_kafka_DeleteGroups_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_DeleteConsumerGroupOffsets_s rd_kafka_DeleteConsumerGroupOffsets_t;</span>
<span class="s1">rd_kafka_DeleteConsumerGroupOffsets_t *rd_kafka_DeleteConsumerGroupOffsets_new(const char *group, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">void rd_kafka_DeleteConsumerGroupOffsets_destroy(rd_kafka_DeleteConsumerGroupOffsets_t *del_grpoffsets);</span>
<span class="s1">void rd_kafka_DeleteConsumerGroupOffsets_destroy_array(rd_kafka_DeleteConsumerGroupOffsets_t **del_grpoffsets, size_t del_grpoffset_cnt);</span>
<span class="s1">void rd_kafka_DeleteConsumerGroupOffsets(rd_kafka_t *rk, rd_kafka_DeleteConsumerGroupOffsets_t **del_grpoffsets, size_t del_grpoffsets_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_group_result_t **rd_kafka_DeleteConsumerGroupOffsets_result_groups(const rd_kafka_DeleteConsumerGroupOffsets_result_t *result, size_t *cntp);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token(rd_kafka_t *rk, const char *token_value, int64_t md_lifetime_ms, const char *md_principal_name, const char **extensions, size_t extension_size, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token_failure(rd_kafka_t *rk, const char *errstr);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_init_transactions(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_begin_transaction(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_send_offsets_to_transaction(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, const rd_kafka_consumer_group_metadata_t *cgmetadata, int timeout_ms);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_commit_transaction(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_abort_transaction(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">typedef struct rd_kafka_mock_cluster_s rd_kafka_mock_cluster_t;</span>
<span class="s1">rd_kafka_mock_cluster_t *rd_kafka_mock_cluster_new(rd_kafka_t *rk, int broker_cnt);</span>
<span class="s1">void rd_kafka_mock_cluster_destroy(rd_kafka_mock_cluster_t *mcluster);</span>
<span class="s1">rd_kafka_t *rd_kafka_mock_cluster_handle(const rd_kafka_mock_cluster_t *mcluster);</span>
<span class="s1">rd_kafka_mock_cluster_t *rd_kafka_handle_mock_cluster(const rd_kafka_t *rk);</span>
<span class="s1">const char *rd_kafka_mock_cluster_bootstraps(const rd_kafka_mock_cluster_t *mcluster);</span>
<span class="s1">void rd_kafka_mock_clear_request_errors(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey);</span>
<span class="s1">void rd_kafka_mock_push_request_errors(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, size_t cnt, ...);</span>
<span class="s1">void rd_kafka_mock_push_request_errors_array(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, size_t cnt, const rd_kafka_resp_err_t *errors);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_push_request_error_rtts(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int16_t ApiKey, size_t cnt, ...);</span>
<span class="s1">void rd_kafka_mock_topic_set_error(rd_kafka_mock_cluster_t *mcluster, const char *topic, rd_kafka_resp_err_t err);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_topic_create(rd_kafka_mock_cluster_t *mcluster, const char *topic, int partition_cnt, int replication_factor);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_partition_set_leader(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_partition_set_follower(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_partition_set_follower_wmarks(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int64_t lo, int64_t hi);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_set_down(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_set_up(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_set_rtt(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int rtt_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_set_rack(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, const char *rack);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_coordinator_set(rd_kafka_mock_cluster_t *mcluster, const char *key_type, const char *key, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_set_apiversion(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, int16_t MinVersion, int16_t MaxVersion);</span>
<span class="s1">&#39;</span>
</code></pre></div>
rdkafka.h, rdkafka_mock.h</p>
<h3 id="rd_kafka_version_18">RD_KAFKA_VERSION<a class="headerlink" href="#rd_kafka_version_18" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_VERSION</span> <span class="o">=</span> <span class="mi">17302271</span>
</code></pre></div>
<p>librdkafka version </p>
<p>Interpreted as hex <code>MM.mm.rr.xx</code>:</p>
<ul>
<li>MM = Major</li>
<li>mm = minor</li>
<li>rr = revision</li>
<li>xx = pre-release id (0xff is the final release)</li>
</ul>
<p>E.g.: <code>0x000801ff</code> = 0.8.1</p>
<dl class="section remark"><dt>Remarks</dt><dd>This value should only be used during compile time, for runtime checks of version use rd_kafka_version() </dd></dl>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_unsupported_compression_type_18">RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE<a class="headerlink" href="#rd_kafka_resp_err_unsupported_compression_type_18" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE</span> <span class="o">=</span> <span class="mi">76</span>
</code></pre></div>
<p>Unsupported compression type </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_end_all_18">RD_KAFKA_RESP_ERR_END_ALL<a class="headerlink" href="#rd_kafka_resp_err_end_all_18" title="Permanent link">&para;</a></h3>
<p><div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_END_ALL</span> <span class="o">=</span> <span class="mi">98</span>
</code></pre></div>
enum rd_kafka_resp_err_t</p>
<h3 id="rd_kafka_admin_op__cnt_18">RD_KAFKA_ADMIN_OP__CNT<a class="headerlink" href="#rd_kafka_admin_op__cnt_18" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_ADMIN_OP__CNT</span> <span class="o">=</span> <span class="mi">9</span>
</code></pre></div>
<p>Number of ops defined </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe </a></li>
</ul>
</div>
<h3 id="rd_kafka_resource__cnt_18">RD_KAFKA_RESOURCE__CNT<a class="headerlink" href="#rd_kafka_resource__cnt_18" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESOURCE__CNT</span> <span class="o">=</span> <span class="mi">5</span>
</code></pre></div>
<p>Number of resource types defined </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#acca83a66d7783ff7683ed2691cc907c9"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#acca83a66d7783ff7683ed2691cc907c9 </a></li>
</ul>
</div>
<h3 id="rd_kafka_cdef_18">RD_KAFKA_CDEF<a class="headerlink" href="#rd_kafka_cdef_18" title="Permanent link">&para;</a></h3>
<p><div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_CDEF</span> <span class="o">=</span> <span class="s1">&#39;typedef long int ssize_t;</span>
<span class="s1">typedef struct _IO_FILE FILE;</span>
<span class="s1">typedef long int mode_t;</span>
<span class="s1">typedef signed int int16_t;</span>
<span class="s1">typedef unsigned int uint16_t;</span>
<span class="s1">typedef signed int int32_t;</span>
<span class="s1">typedef signed long int int64_t;</span>
<span class="s1">int rd_kafka_version(void);</span>
<span class="s1">const char *rd_kafka_version_str(void);</span>
<span class="s1">typedef enum rd_kafka_type_t {</span>
<span class="s1">  RD_KAFKA_PRODUCER,</span>
<span class="s1">  RD_KAFKA_CONSUMER,</span>
<span class="s1">} rd_kafka_type_t;</span>
<span class="s1">typedef enum rd_kafka_timestamp_type_t {</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_NOT_AVAILABLE,</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_CREATE_TIME,</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_LOG_APPEND_TIME,</span>
<span class="s1">} rd_kafka_timestamp_type_t;</span>
<span class="s1">const char *rd_kafka_get_debug_contexts(void);</span>
<span class="s1">typedef struct rd_kafka_s rd_kafka_t;</span>
<span class="s1">typedef struct rd_kafka_topic_s rd_kafka_topic_t;</span>
<span class="s1">typedef struct rd_kafka_conf_s rd_kafka_conf_t;</span>
<span class="s1">typedef struct rd_kafka_topic_conf_s rd_kafka_topic_conf_t;</span>
<span class="s1">typedef struct rd_kafka_queue_s rd_kafka_queue_t;</span>
<span class="s1">typedef struct rd_kafka_op_s rd_kafka_event_t;</span>
<span class="s1">typedef struct rd_kafka_topic_result_s rd_kafka_topic_result_t;</span>
<span class="s1">typedef struct rd_kafka_consumer_group_metadata_s rd_kafka_consumer_group_metadata_t;</span>
<span class="s1">typedef struct rd_kafka_error_s {</span>
<span class="s1">  unsigned int code;</span>
<span class="s1">  char *errstr;</span>
<span class="s1">  unsigned char fatal;</span>
<span class="s1">  unsigned char retriable;</span>
<span class="s1">  unsigned char txn_requires_abort;</span>
<span class="s1">} rd_kafka_error_t;</span>
<span class="s1">typedef struct rd_kafka_headers_s rd_kafka_headers_t;</span>
<span class="s1">typedef struct rd_kafka_group_result_s rd_kafka_group_result_t;</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BEGIN = (- 200),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BAD_MSG = (- 199),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BAD_COMPRESSION = (- 198),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__DESTROY = (- 197),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FAIL = (- 196),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TRANSPORT = (- 195),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__CRIT_SYS_RESOURCE = (- 194),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__RESOLVE = (- 193),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__MSG_TIMED_OUT = (- 192),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PARTITION_EOF = (- 191),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION = (- 190),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FS = (- 189),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC = (- 188),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ALL_BROKERS_DOWN = (- 187),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INVALID_ARG = (- 186),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TIMED_OUT = (- 185),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__QUEUE_FULL = (- 184),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ISR_INSUFF = (- 183),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NODE_UPDATE = (- 182),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__SSL = (- 181),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__WAIT_COORD = (- 180),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_GROUP = (- 179),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__IN_PROGRESS = (- 178),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PREV_IN_PROGRESS = (- 177),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__EXISTING_SUBSCRIPTION = (- 176),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS = (- 175),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS = (- 174),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__CONFLICT = (- 173),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__STATE = (- 172),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_PROTOCOL = (- 171),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED = (- 170),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__AUTHENTICATION = (- 169),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NO_OFFSET = (- 168),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__OUTDATED = (- 167),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TIMED_OUT_QUEUE = (- 166),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNSUPPORTED_FEATURE = (- 165),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__WAIT_CACHE = (- 164),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INTR = (- 163),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__KEY_SERIALIZATION = (- 162),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__VALUE_SERIALIZATION = (- 161),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__KEY_DESERIALIZATION = (- 160),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__VALUE_DESERIALIZATION = (- 159),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PARTIAL = (- 158),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__READ_ONLY = (- 157),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOENT = (- 156),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNDERFLOW = (- 155),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INVALID_TYPE = (- 154),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__RETRY = (- 153),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PURGE_QUEUE = (- 152),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PURGE_INFLIGHT = (- 151),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FATAL = (- 150),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INCONSISTENT = (- 149),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__GAPLESS_GUARANTEE = (- 148),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__MAX_POLL_EXCEEDED = (- 147),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_BROKER = (- 146),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOT_CONFIGURED = (- 145),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FENCED = (- 144),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__APPLICATION = (- 143),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ASSIGNMENT_LOST = (- 142),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOOP = (- 141),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__AUTO_OFFSET_RESET = (- 140),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__END = (- 100),</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN = (- 1),</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NO_ERROR = 0,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_OUT_OF_RANGE = 1,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_MSG = 2,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART = 3,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_MSG_SIZE = 4,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE = 5,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_LEADER_FOR_PARTITION = 6,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REQUEST_TIMED_OUT = 7,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_BROKER_NOT_AVAILABLE = 8,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REPLICA_NOT_AVAILABLE = 9,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE = 10,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_STALE_CTRL_EPOCH = 11,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_METADATA_TOO_LARGE = 12,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NETWORK_EXCEPTION = 13,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_COORDINATOR_LOAD_IN_PROGRESS = 14,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_COORDINATOR_NOT_AVAILABLE = 15,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_COORDINATOR = 16,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_EXCEPTION = 17,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_RECORD_LIST_TOO_LARGE = 18,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS = 19,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS_AFTER_APPEND = 20,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REQUIRED_ACKS = 21,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ILLEGAL_GENERATION = 22,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INCONSISTENT_GROUP_PROTOCOL = 23,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_GROUP_ID = 24,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_MEMBER_ID = 25,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_SESSION_TIMEOUT = 26,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REBALANCE_IN_PROGRESS = 27,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_COMMIT_OFFSET_SIZE = 28,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_AUTHORIZATION_FAILED = 29,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_AUTHORIZATION_FAILED = 30,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_CLUSTER_AUTHORIZATION_FAILED = 31,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TIMESTAMP = 32,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_SASL_MECHANISM = 33,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ILLEGAL_SASL_STATE = 34,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_VERSION = 35,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_ALREADY_EXISTS = 36,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PARTITIONS = 37,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REPLICATION_FACTOR = 38,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REPLICA_ASSIGNMENT = 39,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_CONFIG = 40,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_CONTROLLER = 41,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REQUEST = 42,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_FOR_MESSAGE_FORMAT = 43,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_POLICY_VIOLATION = 44,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OUT_OF_ORDER_SEQUENCE_NUMBER = 45,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DUPLICATE_SEQUENCE_NUMBER = 46,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_EPOCH = 47,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TXN_STATE = 48,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_ID_MAPPING = 49,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TRANSACTION_TIMEOUT = 50,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_CONCURRENT_TRANSACTIONS = 51,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TRANSACTION_COORDINATOR_FENCED = 52,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TRANSACTIONAL_ID_AUTHORIZATION_FAILED = 53,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_SECURITY_DISABLED = 54,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OPERATION_NOT_ATTEMPTED = 55,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_KAFKA_STORAGE_ERROR = 56,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LOG_DIR_NOT_FOUND = 57,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_SASL_AUTHENTICATION_FAILED = 58,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_PRODUCER_ID = 59,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REASSIGNMENT_IN_PROGRESS = 60,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTH_DISABLED = 61,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_NOT_FOUND = 62,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_OWNER_MISMATCH = 63,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_REQUEST_NOT_ALLOWED = 64,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTHORIZATION_FAILED = 65,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_EXPIRED = 66,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRINCIPAL_TYPE = 67,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NON_EMPTY_GROUP = 68,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_ID_NOT_FOUND = 69,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FETCH_SESSION_ID_NOT_FOUND = 70,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_FETCH_SESSION_EPOCH = 71,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LISTENER_NOT_FOUND = 72,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_DELETION_DISABLED = 73,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FENCED_LEADER_EPOCH = 74,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_LEADER_EPOCH = 75,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_STALE_BROKER_EPOCH = 77,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_NOT_AVAILABLE = 78,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_MEMBER_ID_REQUIRED = 79,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_PREFERRED_LEADER_NOT_AVAILABLE = 80,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_MAX_SIZE_REACHED = 81,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FENCED_INSTANCE_ID = 82,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ELIGIBLE_LEADERS_NOT_AVAILABLE = 83,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ELECTION_NOT_NEEDED = 84,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NO_REASSIGNMENT_IN_PROGRESS = 85,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_SUBSCRIBED_TO_TOPIC = 86,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_RECORD = 87,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSTABLE_OFFSET_COMMIT = 88,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_THROTTLING_QUOTA_EXCEEDED = 89,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_PRODUCER_FENCED = 90,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_RESOURCE_NOT_FOUND = 91,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DUPLICATE_RESOURCE = 92,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNACCEPTABLE_CREDENTIAL = 93,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INCONSISTENT_VOTER_SET = 94,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_UPDATE_VERSION = 95,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FEATURE_UPDATE_FAILED = 96,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_PRINCIPAL_DESERIALIZATION_FAILURE = 97,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_END_ALL,</span>
<span class="s1">} rd_kafka_resp_err_t;</span>
<span class="s1">struct rd_kafka_err_desc {</span>
<span class="s1">  rd_kafka_resp_err_t code;</span>
<span class="s1">  char *name;</span>
<span class="s1">  char *desc;</span>
<span class="s1">};</span>
<span class="s1">void rd_kafka_get_err_descs(const struct rd_kafka_err_desc **errdescs, size_t *cntp);</span>
<span class="s1">const char *rd_kafka_err2str(rd_kafka_resp_err_t err);</span>
<span class="s1">const char *rd_kafka_err2name(rd_kafka_resp_err_t err);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_last_error(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_errno2err(int errnox);</span>
<span class="s1">int rd_kafka_errno(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_fatal_error(rd_kafka_t *rk, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_test_fatal_error(rd_kafka_t *rk, rd_kafka_resp_err_t err, const char *reason);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_error_code(const rd_kafka_error_t *error);</span>
<span class="s1">const char *rd_kafka_error_name(const rd_kafka_error_t *error);</span>
<span class="s1">const char *rd_kafka_error_string(const rd_kafka_error_t *error);</span>
<span class="s1">int rd_kafka_error_is_fatal(const rd_kafka_error_t *error);</span>
<span class="s1">int rd_kafka_error_is_retriable(const rd_kafka_error_t *error);</span>
<span class="s1">int rd_kafka_error_txn_requires_abort(const rd_kafka_error_t *error);</span>
<span class="s1">void rd_kafka_error_destroy(rd_kafka_error_t *error);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_error_new(rd_kafka_resp_err_t code, const char *fmt, ...);</span>
<span class="s1">typedef struct rd_kafka_topic_partition_s {</span>
<span class="s1">  char *topic;</span>
<span class="s1">  int32_t partition;</span>
<span class="s1">  int64_t offset;</span>
<span class="s1">  void *metadata;</span>
<span class="s1">  size_t metadata_size;</span>
<span class="s1">  void *opaque;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  void *_private;</span>
<span class="s1">} rd_kafka_topic_partition_t;</span>
<span class="s1">void rd_kafka_topic_partition_destroy(rd_kafka_topic_partition_t *rktpar);</span>
<span class="s1">typedef struct rd_kafka_topic_partition_list_s {</span>
<span class="s1">  int cnt;</span>
<span class="s1">  int size;</span>
<span class="s1">  rd_kafka_topic_partition_t *elems;</span>
<span class="s1">} rd_kafka_topic_partition_list_t;</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_new(int size);</span>
<span class="s1">void rd_kafka_topic_partition_list_destroy(rd_kafka_topic_partition_list_t *rkparlist);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_add(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">void rd_kafka_topic_partition_list_add_range(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t start, int32_t stop);</span>
<span class="s1">int rd_kafka_topic_partition_list_del(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">int rd_kafka_topic_partition_list_del_by_idx(rd_kafka_topic_partition_list_t *rktparlist, int idx);</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_copy(const rd_kafka_topic_partition_list_t *src);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_topic_partition_list_set_offset(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition, int64_t offset);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_find(const rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">void rd_kafka_topic_partition_list_sort(rd_kafka_topic_partition_list_t *rktparlist, int (*cmp)(const void *a, const void *b, void *cmp_opaque), void *cmp_opaque);</span>
<span class="s1">typedef enum rd_kafka_vtype_t {</span>
<span class="s1">  RD_KAFKA_VTYPE_END,</span>
<span class="s1">  RD_KAFKA_VTYPE_TOPIC,</span>
<span class="s1">  RD_KAFKA_VTYPE_RKT,</span>
<span class="s1">  RD_KAFKA_VTYPE_PARTITION,</span>
<span class="s1">  RD_KAFKA_VTYPE_VALUE,</span>
<span class="s1">  RD_KAFKA_VTYPE_KEY,</span>
<span class="s1">  RD_KAFKA_VTYPE_OPAQUE,</span>
<span class="s1">  RD_KAFKA_VTYPE_MSGFLAGS,</span>
<span class="s1">  RD_KAFKA_VTYPE_TIMESTAMP,</span>
<span class="s1">  RD_KAFKA_VTYPE_HEADER,</span>
<span class="s1">  RD_KAFKA_VTYPE_HEADERS,</span>
<span class="s1">} rd_kafka_vtype_t;</span>
<span class="s1">typedef struct rd_kafka_vu_s {</span>
<span class="s1">  rd_kafka_vtype_t vtype;</span>
<span class="s1">  union {</span>
<span class="s1">    char *cstr;</span>
<span class="s1">    rd_kafka_topic_t *rkt;</span>
<span class="s1">    int i;</span>
<span class="s1">    int32_t i32;</span>
<span class="s1">    int64_t i64;</span>
<span class="s1">    struct {</span>
<span class="s1">      void *ptr;</span>
<span class="s1">      size_t size;</span>
<span class="s1">    } mem;</span>
<span class="s1">    struct {</span>
<span class="s1">      char *name;</span>
<span class="s1">      void *val;</span>
<span class="s1">      ssize_t size;</span>
<span class="s1">    } header;</span>
<span class="s1">    rd_kafka_headers_t *headers;</span>
<span class="s1">    void *ptr;</span>
<span class="s1">    char _pad[64];</span>
<span class="s1">  } u;</span>
<span class="s1">} rd_kafka_vu_t;</span>
<span class="s1">rd_kafka_headers_t *rd_kafka_headers_new(size_t initial_count);</span>
<span class="s1">void rd_kafka_headers_destroy(rd_kafka_headers_t *hdrs);</span>
<span class="s1">rd_kafka_headers_t *rd_kafka_headers_copy(const rd_kafka_headers_t *src);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_add(rd_kafka_headers_t *hdrs, const char *name, ssize_t name_size, const void *value, ssize_t value_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_remove(rd_kafka_headers_t *hdrs, const char *name);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get_last(const rd_kafka_headers_t *hdrs, const char *name, const void **valuep, size_t *sizep);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get(const rd_kafka_headers_t *hdrs, size_t idx, const char *name, const void **valuep, size_t *sizep);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get_all(const rd_kafka_headers_t *hdrs, size_t idx, const char **namep, const void **valuep, size_t *sizep);</span>
<span class="s1">typedef struct rd_kafka_message_s {</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  rd_kafka_topic_t *rkt;</span>
<span class="s1">  int32_t partition;</span>
<span class="s1">  void *payload;</span>
<span class="s1">  size_t len;</span>
<span class="s1">  void *key;</span>
<span class="s1">  size_t key_len;</span>
<span class="s1">  int64_t offset;</span>
<span class="s1">  void *_private;</span>
<span class="s1">} rd_kafka_message_t;</span>
<span class="s1">void rd_kafka_message_destroy(rd_kafka_message_t *rkmessage);</span>
<span class="s1">const char *rd_kafka_message_errstr(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">int64_t rd_kafka_message_timestamp(const rd_kafka_message_t *rkmessage, rd_kafka_timestamp_type_t *tstype);</span>
<span class="s1">int64_t rd_kafka_message_latency(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">int32_t rd_kafka_message_broker_id(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_message_headers(const rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_message_detach_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);</span>
<span class="s1">void rd_kafka_message_set_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t *hdrs);</span>
<span class="s1">size_t rd_kafka_header_cnt(const rd_kafka_headers_t *hdrs);</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_NOT_PERSISTED = 0,</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_POSSIBLY_PERSISTED = 1,</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_PERSISTED = 2,</span>
<span class="s1">} rd_kafka_msg_status_t;</span>
<span class="s1">rd_kafka_msg_status_t rd_kafka_message_status(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_CONF_UNKNOWN = (- 2),</span>
<span class="s1">  RD_KAFKA_CONF_INVALID = (- 1),</span>
<span class="s1">  RD_KAFKA_CONF_OK = 0,</span>
<span class="s1">} rd_kafka_conf_res_t;</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_new(void);</span>
<span class="s1">void rd_kafka_conf_destroy(rd_kafka_conf_t *conf);</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_dup(const rd_kafka_conf_t *conf);</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_dup_filter(const rd_kafka_conf_t *conf, size_t filter_cnt, const char **filter);</span>
<span class="s1">const rd_kafka_conf_t *rd_kafka_conf(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_set(rd_kafka_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_conf_set_events(rd_kafka_conf_t *conf, int events);</span>
<span class="s1">void rd_kafka_conf_set_background_event_cb(rd_kafka_conf_t *conf, void (*event_cb)(rd_kafka_t *rk, rd_kafka_event_t *rkev, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_dr_cb(rd_kafka_conf_t *conf, void (*dr_cb)(rd_kafka_t *rk, void *payload, size_t len, rd_kafka_resp_err_t err, void *opaque, void *msg_opaque));</span>
<span class="s1">void rd_kafka_conf_set_dr_msg_cb(rd_kafka_conf_t *conf, void (*dr_msg_cb)(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_consume_cb(rd_kafka_conf_t *conf, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_rebalance_cb(rd_kafka_conf_t *conf, void (*rebalance_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *partitions, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_offset_commit_cb(rd_kafka_conf_t *conf, void (*offset_commit_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_error_cb(rd_kafka_conf_t *conf, void (*error_cb)(rd_kafka_t *rk, int err, const char *reason, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_throttle_cb(rd_kafka_conf_t *conf, void (*throttle_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int throttle_time_ms, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_log_cb(rd_kafka_conf_t *conf, void (*log_cb)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));</span>
<span class="s1">void rd_kafka_conf_set_stats_cb(rd_kafka_conf_t *conf, int (*stats_cb)(rd_kafka_t *rk, char *json, size_t json_len, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_oauthbearer_token_refresh_cb(rd_kafka_conf_t *conf, void (*oauthbearer_token_refresh_cb)(rd_kafka_t *rk, const char *oauthbearer_config, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_socket_cb(rd_kafka_conf_t *conf, int (*socket_cb)(int domain, int type, int protocol, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_connect_cb(rd_kafka_conf_t *conf, int (*connect_cb)(int sockfd, const struct sockaddr *addr, int addrlen, const char *id, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_closesocket_cb(rd_kafka_conf_t *conf, int (*closesocket_cb)(int sockfd, void *opaque));</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert_verify_cb(rd_kafka_conf_t *conf, int (*ssl_cert_verify_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int *x509_error, int depth, const char *buf, size_t size, char *errstr, size_t errstr_size, void *opaque));</span>
<span class="s1">typedef enum rd_kafka_cert_type_t {</span>
<span class="s1">  RD_KAFKA_CERT_PUBLIC_KEY,</span>
<span class="s1">  RD_KAFKA_CERT_PRIVATE_KEY,</span>
<span class="s1">  RD_KAFKA_CERT_CA,</span>
<span class="s1">  RD_KAFKA_CERT__CNT,</span>
<span class="s1">} rd_kafka_cert_type_t;</span>
<span class="s1">typedef enum rd_kafka_cert_enc_t {</span>
<span class="s1">  RD_KAFKA_CERT_ENC_PKCS12,</span>
<span class="s1">  RD_KAFKA_CERT_ENC_DER,</span>
<span class="s1">  RD_KAFKA_CERT_ENC_PEM,</span>
<span class="s1">  RD_KAFKA_CERT_ENC__CNT,</span>
<span class="s1">} rd_kafka_cert_enc_t;</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert(rd_kafka_conf_t *conf, rd_kafka_cert_type_t cert_type, rd_kafka_cert_enc_t cert_enc, const void *buffer, size_t size, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_conf_set_engine_callback_data(rd_kafka_conf_t *conf, void *callback_data);</span>
<span class="s1">void rd_kafka_conf_set_opaque(rd_kafka_conf_t *conf, void *opaque);</span>
<span class="s1">void *rd_kafka_opaque(const rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_conf_set_default_topic_conf(rd_kafka_conf_t *conf, rd_kafka_topic_conf_t *tconf);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_conf_get_default_topic_conf(rd_kafka_conf_t *conf);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_get(const rd_kafka_conf_t *conf, const char *name, char *dest, size_t *dest_size);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_topic_conf_get(const rd_kafka_topic_conf_t *conf, const char *name, char *dest, size_t *dest_size);</span>
<span class="s1">const char **rd_kafka_conf_dump(rd_kafka_conf_t *conf, size_t *cntp);</span>
<span class="s1">const char **rd_kafka_topic_conf_dump(rd_kafka_topic_conf_t *conf, size_t *cntp);</span>
<span class="s1">void rd_kafka_conf_dump_free(const char **arr, size_t cnt);</span>
<span class="s1">void rd_kafka_conf_properties_show(FILE *fp);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_topic_conf_new(void);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_topic_conf_dup(const rd_kafka_topic_conf_t *conf);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_default_topic_conf_dup(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_topic_conf_destroy(rd_kafka_topic_conf_t *topic_conf);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_topic_conf_set(rd_kafka_topic_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_topic_conf_set_opaque(rd_kafka_topic_conf_t *conf, void *rkt_opaque);</span>
<span class="s1">void rd_kafka_topic_conf_set_partitioner_cb(rd_kafka_topic_conf_t *topic_conf, int32_t (*partitioner)(const rd_kafka_topic_t *rkt, const void *keydata, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque));</span>
<span class="s1">void rd_kafka_topic_conf_set_msg_order_cmp(rd_kafka_topic_conf_t *topic_conf, int (*msg_order_cmp)(const rd_kafka_message_t *a, const rd_kafka_message_t *b));</span>
<span class="s1">int rd_kafka_topic_partition_available(const rd_kafka_topic_t *rkt, int32_t partition);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_consistent(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_consistent_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_murmur2(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_murmur2_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_fnv1a(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_fnv1a_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">rd_kafka_t *rd_kafka_new(rd_kafka_type_t type, rd_kafka_conf_t *conf, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_destroy(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_destroy_flags(rd_kafka_t *rk, int flags);</span>
<span class="s1">const char *rd_kafka_name(const rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_type_t rd_kafka_type(const rd_kafka_t *rk);</span>
<span class="s1">char *rd_kafka_memberid(const rd_kafka_t *rk);</span>
<span class="s1">char *rd_kafka_clusterid(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">int32_t rd_kafka_controllerid(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_topic_t *rd_kafka_topic_new(rd_kafka_t *rk, const char *topic, rd_kafka_topic_conf_t *conf);</span>
<span class="s1">void rd_kafka_topic_destroy(rd_kafka_topic_t *rkt);</span>
<span class="s1">const char *rd_kafka_topic_name(const rd_kafka_topic_t *rkt);</span>
<span class="s1">void *rd_kafka_topic_opaque(const rd_kafka_topic_t *rkt);</span>
<span class="s1">int rd_kafka_poll(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">void rd_kafka_yield(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_pause_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_resume_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_query_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_get_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offsets_for_times(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets, int timeout_ms);</span>
<span class="s1">void *rd_kafka_mem_calloc(rd_kafka_t *rk, size_t num, size_t size);</span>
<span class="s1">void *rd_kafka_mem_malloc(rd_kafka_t *rk, size_t size);</span>
<span class="s1">void rd_kafka_mem_free(rd_kafka_t *rk, void *ptr);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_new(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_queue_destroy(rd_kafka_queue_t *rkqu);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_main(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_consumer(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_partition(rd_kafka_t *rk, const char *topic, int32_t partition);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_background(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_queue_forward(rd_kafka_queue_t *src, rd_kafka_queue_t *dst);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_set_log_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu);</span>
<span class="s1">size_t rd_kafka_queue_length(rd_kafka_queue_t *rkqu);</span>
<span class="s1">void rd_kafka_queue_io_event_enable(rd_kafka_queue_t *rkqu, int fd, const void *payload, size_t size);</span>
<span class="s1">void rd_kafka_queue_cb_event_enable(rd_kafka_queue_t *rkqu, void (*event_cb)(rd_kafka_t *rk, void *qev_opaque), void *qev_opaque);</span>
<span class="s1">void rd_kafka_queue_yield(rd_kafka_queue_t *rkqu);</span>
<span class="s1">int rd_kafka_consume_start(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);</span>
<span class="s1">int rd_kafka_consume_start_queue(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, rd_kafka_queue_t *rkqu);</span>
<span class="s1">int rd_kafka_consume_stop(rd_kafka_topic_t *rkt, int32_t partition);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_seek(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, int timeout_ms);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_seek_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consume(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms);</span>
<span class="s1">ssize_t rd_kafka_consume_batch(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);</span>
<span class="s1">int rd_kafka_consume_callback(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consume_queue(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">ssize_t rd_kafka_consume_batch_queue(rd_kafka_queue_t *rkqu, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);</span>
<span class="s1">int rd_kafka_consume_callback_queue(rd_kafka_queue_t *rkqu, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offset_store(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offsets_store(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_subscribe(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *topics);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_unsubscribe(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_subscription(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **topics);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consumer_poll(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_consumer_close(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_incremental_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_incremental_unassign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">const char *rd_kafka_rebalance_protocol(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_assignment(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **partitions);</span>
<span class="s1">int rd_kafka_assignment_lost(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, int async);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit_message(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, int async);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit_queue(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_queue_t *rkqu, void (*cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *commit_opaque), void *commit_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_committed(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_position(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata_new(const char *group_id);</span>
<span class="s1">rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata_new_with_genid(const char *group_id, int32_t generation_id, const char *member_id, const char *group_instance_id);</span>
<span class="s1">void rd_kafka_consumer_group_metadata_destroy(rd_kafka_consumer_group_metadata_t *);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_consumer_group_metadata_write(const rd_kafka_consumer_group_metadata_t *cgmd, void **bufferp, size_t *sizep);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_consumer_group_metadata_read(rd_kafka_consumer_group_metadata_t **cgmdp, const void *buffer, size_t size);</span>
<span class="s1">int rd_kafka_produce(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, void *payload, size_t len, const void *key, size_t keylen, void *msg_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_producev(rd_kafka_t *rk, ...);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_produceva(rd_kafka_t *rk, const rd_kafka_vu_t *vus, size_t cnt);</span>
<span class="s1">int rd_kafka_produce_batch(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, rd_kafka_message_t *rkmessages, int message_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_flush(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_purge(rd_kafka_t *rk, int purge_flags);</span>
<span class="s1">typedef struct rd_kafka_metadata_broker {</span>
<span class="s1">  int32_t id;</span>
<span class="s1">  char *host;</span>
<span class="s1">  int port;</span>
<span class="s1">} rd_kafka_metadata_broker_t;</span>
<span class="s1">typedef struct rd_kafka_metadata_partition {</span>
<span class="s1">  int32_t id;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  int32_t leader;</span>
<span class="s1">  int replica_cnt;</span>
<span class="s1">  int32_t *replicas;</span>
<span class="s1">  int isr_cnt;</span>
<span class="s1">  int32_t *isrs;</span>
<span class="s1">} rd_kafka_metadata_partition_t;</span>
<span class="s1">typedef struct rd_kafka_metadata_topic {</span>
<span class="s1">  char *topic;</span>
<span class="s1">  int partition_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_partition *partitions;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">} rd_kafka_metadata_topic_t;</span>
<span class="s1">typedef struct rd_kafka_metadata {</span>
<span class="s1">  int broker_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_broker *brokers;</span>
<span class="s1">  int topic_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_topic *topics;</span>
<span class="s1">  int32_t orig_broker_id;</span>
<span class="s1">  char *orig_broker_name;</span>
<span class="s1">} rd_kafka_metadata_t;</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_metadata(rd_kafka_t *rk, int all_topics, rd_kafka_topic_t *only_rkt, const struct rd_kafka_metadata **metadatap, int timeout_ms);</span>
<span class="s1">void rd_kafka_metadata_destroy(const struct rd_kafka_metadata *metadata);</span>
<span class="s1">struct rd_kafka_group_member_info {</span>
<span class="s1">  char *member_id;</span>
<span class="s1">  char *client_id;</span>
<span class="s1">  char *client_host;</span>
<span class="s1">  void *member_metadata;</span>
<span class="s1">  int member_metadata_size;</span>
<span class="s1">  void *member_assignment;</span>
<span class="s1">  int member_assignment_size;</span>
<span class="s1">};</span>
<span class="s1">struct rd_kafka_group_info {</span>
<span class="s1">  struct rd_kafka_metadata_broker broker;</span>
<span class="s1">  char *group;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  char *state;</span>
<span class="s1">  char *protocol_type;</span>
<span class="s1">  char *protocol;</span>
<span class="s1">  struct rd_kafka_group_member_info *members;</span>
<span class="s1">  int member_cnt;</span>
<span class="s1">};</span>
<span class="s1">struct rd_kafka_group_list {</span>
<span class="s1">  struct rd_kafka_group_info *groups;</span>
<span class="s1">  int group_cnt;</span>
<span class="s1">};</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_list_groups(rd_kafka_t *rk, const char *group, const struct rd_kafka_group_list **grplistp, int timeout_ms);</span>
<span class="s1">void rd_kafka_group_list_destroy(const struct rd_kafka_group_list *grplist);</span>
<span class="s1">int rd_kafka_brokers_add(rd_kafka_t *rk, const char *brokerlist);</span>
<span class="s1">void rd_kafka_set_logger(rd_kafka_t *rk, void (*func)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));</span>
<span class="s1">void rd_kafka_set_log_level(rd_kafka_t *rk, int level);</span>
<span class="s1">void rd_kafka_log_print(const rd_kafka_t *rk, int level, const char *fac, const char *buf);</span>
<span class="s1">void rd_kafka_log_syslog(const rd_kafka_t *rk, int level, const char *fac, const char *buf);</span>
<span class="s1">int rd_kafka_outq_len(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_dump(FILE *fp, rd_kafka_t *rk);</span>
<span class="s1">int rd_kafka_thread_cnt(void);</span>
<span class="s1">typedef enum rd_kafka_thread_type_t {</span>
<span class="s1">  RD_KAFKA_THREAD_MAIN,</span>
<span class="s1">  RD_KAFKA_THREAD_BACKGROUND,</span>
<span class="s1">  RD_KAFKA_THREAD_BROKER,</span>
<span class="s1">} rd_kafka_thread_type_t;</span>
<span class="s1">int rd_kafka_wait_destroyed(int timeout_ms);</span>
<span class="s1">int rd_kafka_unittest(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_poll_set_consumer(rd_kafka_t *rk);</span>
<span class="s1">typedef int rd_kafka_event_type_t;</span>
<span class="s1">rd_kafka_event_type_t rd_kafka_event_type(const rd_kafka_event_t *rkev);</span>
<span class="s1">const char *rd_kafka_event_name(const rd_kafka_event_t *rkev);</span>
<span class="s1">void rd_kafka_event_destroy(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_message_t *rd_kafka_event_message_next(rd_kafka_event_t *rkev);</span>
<span class="s1">size_t rd_kafka_event_message_array(rd_kafka_event_t *rkev, const rd_kafka_message_t **rkmessages, size_t size);</span>
<span class="s1">size_t rd_kafka_event_message_count(rd_kafka_event_t *rkev);</span>
<span class="s1">const char *rd_kafka_event_config_string(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_event_error(rd_kafka_event_t *rkev);</span>
<span class="s1">const char *rd_kafka_event_error_string(rd_kafka_event_t *rkev);</span>
<span class="s1">int rd_kafka_event_error_is_fatal(rd_kafka_event_t *rkev);</span>
<span class="s1">void *rd_kafka_event_opaque(rd_kafka_event_t *rkev);</span>
<span class="s1">int rd_kafka_event_log(rd_kafka_event_t *rkev, const char **fac, const char **str, int *level);</span>
<span class="s1">int rd_kafka_event_debug_contexts(rd_kafka_event_t *rkev, char *dst, size_t dstsize);</span>
<span class="s1">const char *rd_kafka_event_stats(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_event_topic_partition_list(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_event_topic_partition(rd_kafka_event_t *rkev);</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_CreateTopics_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DeleteTopics_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_CreatePartitions_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_AlterConfigs_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DescribeConfigs_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DeleteRecords_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DeleteGroups_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DeleteConsumerGroupOffsets_result_t;</span>
<span class="s1">const rd_kafka_CreateTopics_result_t *rd_kafka_event_CreateTopics_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DeleteTopics_result_t *rd_kafka_event_DeleteTopics_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_CreatePartitions_result_t *rd_kafka_event_CreatePartitions_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_AlterConfigs_result_t *rd_kafka_event_AlterConfigs_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DescribeConfigs_result_t *rd_kafka_event_DescribeConfigs_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DeleteRecords_result_t *rd_kafka_event_DeleteRecords_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DeleteGroups_result_t *rd_kafka_event_DeleteGroups_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DeleteConsumerGroupOffsets_result_t *rd_kafka_event_DeleteConsumerGroupOffsets_result(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_event_t *rd_kafka_queue_poll(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">int rd_kafka_queue_poll_callback(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_plugin_f_conf_init_t)(rd_kafka_conf_t *conf, void **plug_opaquep, char *errstr, size_t errstr_size);</span>
<span class="s1">typedef rd_kafka_conf_res_t (rd_kafka_interceptor_f_on_conf_set_t)(rd_kafka_conf_t *conf, const char *name, const char *val, char *errstr, size_t errstr_size, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_dup_t)(rd_kafka_conf_t *new_conf, const rd_kafka_conf_t *old_conf, size_t filter_cnt, const char **filter, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_destroy_t)(void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_new_t)(rd_kafka_t *rk, const rd_kafka_conf_t *conf, void *ic_opaque, char *errstr, size_t errstr_size);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_destroy_t)(rd_kafka_t *rk, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_send_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_acknowledgement_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_consume_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_commit_t)(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_resp_err_t err, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_request_sent_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_response_received_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, int64_t rtt, rd_kafka_resp_err_t err, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_start_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_exit_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_set(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_set_t *on_conf_set, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_dup(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_dup_t *on_conf_dup, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_destroy(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_destroy_t *on_conf_destroy, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_new(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_new_t *on_new, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_destroy(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_destroy_t *on_destroy, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_send(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_send_t *on_send, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_acknowledgement(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_acknowledgement_t *on_acknowledgement, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_consume(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_consume_t *on_consume, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_commit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_commit_t *on_commit, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_request_sent(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_request_sent_t *on_request_sent, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_response_received(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_response_received_t *on_response_received, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_start(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_start_t *on_thread_start, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_exit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_exit_t *on_thread_exit, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_topic_result_error(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">const char *rd_kafka_topic_result_error_string(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">const char *rd_kafka_topic_result_name(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">const rd_kafka_error_t *rd_kafka_group_result_error(const rd_kafka_group_result_t *groupres);</span>
<span class="s1">const char *rd_kafka_group_result_name(const rd_kafka_group_result_t *groupres);</span>
<span class="s1">const rd_kafka_topic_partition_list_t *rd_kafka_group_result_partitions(const rd_kafka_group_result_t *groupres);</span>
<span class="s1">typedef enum rd_kafka_admin_op_t {</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_ANY = 0,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_CREATETOPICS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DELETETOPICS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_CREATEPARTITIONS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_ALTERCONFIGS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DESCRIBECONFIGS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DELETERECORDS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DELETEGROUPS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DELETECONSUMERGROUPOFFSETS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP__CNT,</span>
<span class="s1">} rd_kafka_admin_op_t;</span>
<span class="s1">typedef struct rd_kafka_AdminOptions_s rd_kafka_AdminOptions_t;</span>
<span class="s1">rd_kafka_AdminOptions_t *rd_kafka_AdminOptions_new(rd_kafka_t *rk, rd_kafka_admin_op_t for_api);</span>
<span class="s1">void rd_kafka_AdminOptions_destroy(rd_kafka_AdminOptions_t *options);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_request_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_operation_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_validate_only(rd_kafka_AdminOptions_t *options, int true_or_false, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_broker(rd_kafka_AdminOptions_t *options, int32_t broker_id, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_AdminOptions_set_opaque(rd_kafka_AdminOptions_t *options, void *ev_opaque);</span>
<span class="s1">typedef struct rd_kafka_NewTopic_s rd_kafka_NewTopic_t;</span>
<span class="s1">rd_kafka_NewTopic_t *rd_kafka_NewTopic_new(const char *topic, int num_partitions, int replication_factor, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_NewTopic_destroy(rd_kafka_NewTopic_t *new_topic);</span>
<span class="s1">void rd_kafka_NewTopic_destroy_array(rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewTopic_set_replica_assignment(rd_kafka_NewTopic_t *new_topic, int32_t partition, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewTopic_set_config(rd_kafka_NewTopic_t *new_topic, const char *name, const char *value);</span>
<span class="s1">void rd_kafka_CreateTopics(rd_kafka_t *rk, rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_CreateTopics_result_topics(const rd_kafka_CreateTopics_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_DeleteTopic_s rd_kafka_DeleteTopic_t;</span>
<span class="s1">rd_kafka_DeleteTopic_t *rd_kafka_DeleteTopic_new(const char *topic);</span>
<span class="s1">void rd_kafka_DeleteTopic_destroy(rd_kafka_DeleteTopic_t *del_topic);</span>
<span class="s1">void rd_kafka_DeleteTopic_destroy_array(rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt);</span>
<span class="s1">void rd_kafka_DeleteTopics(rd_kafka_t *rk, rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_DeleteTopics_result_topics(const rd_kafka_DeleteTopics_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_NewPartitions_s rd_kafka_NewPartitions_t;</span>
<span class="s1">rd_kafka_NewPartitions_t *rd_kafka_NewPartitions_new(const char *topic, size_t new_total_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_NewPartitions_destroy(rd_kafka_NewPartitions_t *new_parts);</span>
<span class="s1">void rd_kafka_NewPartitions_destroy_array(rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewPartitions_set_replica_assignment(rd_kafka_NewPartitions_t *new_parts, int32_t new_partition_idx, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_CreatePartitions(rd_kafka_t *rk, rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_CreatePartitions_result_topics(const rd_kafka_CreatePartitions_result_t *result, size_t *cntp);</span>
<span class="s1">typedef enum rd_kafka_ConfigSource_t {</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_UNKNOWN_CONFIG = 0,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_TOPIC_CONFIG = 1,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_BROKER_CONFIG = 2,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_DEFAULT_BROKER_CONFIG = 3,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_STATIC_BROKER_CONFIG = 4,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DEFAULT_CONFIG = 5,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE__CNT,</span>
<span class="s1">} rd_kafka_ConfigSource_t;</span>
<span class="s1">const char *rd_kafka_ConfigSource_name(rd_kafka_ConfigSource_t confsource);</span>
<span class="s1">typedef struct rd_kafka_ConfigEntry_s rd_kafka_ConfigEntry_t;</span>
<span class="s1">const char *rd_kafka_ConfigEntry_name(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">const char *rd_kafka_ConfigEntry_value(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">rd_kafka_ConfigSource_t rd_kafka_ConfigEntry_source(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_read_only(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_default(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_sensitive(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_synonym(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">const rd_kafka_ConfigEntry_t **rd_kafka_ConfigEntry_synonyms(const rd_kafka_ConfigEntry_t *entry, size_t *cntp);</span>
<span class="s1">typedef enum rd_kafka_ResourceType_t {</span>
<span class="s1">  RD_KAFKA_RESOURCE_UNKNOWN = 0,</span>
<span class="s1">  RD_KAFKA_RESOURCE_ANY = 1,</span>
<span class="s1">  RD_KAFKA_RESOURCE_TOPIC = 2,</span>
<span class="s1">  RD_KAFKA_RESOURCE_GROUP = 3,</span>
<span class="s1">  RD_KAFKA_RESOURCE_BROKER = 4,</span>
<span class="s1">  RD_KAFKA_RESOURCE__CNT,</span>
<span class="s1">} rd_kafka_ResourceType_t;</span>
<span class="s1">const char *rd_kafka_ResourceType_name(rd_kafka_ResourceType_t restype);</span>
<span class="s1">typedef struct rd_kafka_ConfigResource_s rd_kafka_ConfigResource_t;</span>
<span class="s1">rd_kafka_ConfigResource_t *rd_kafka_ConfigResource_new(rd_kafka_ResourceType_t restype, const char *resname);</span>
<span class="s1">void rd_kafka_ConfigResource_destroy(rd_kafka_ConfigResource_t *config);</span>
<span class="s1">void rd_kafka_ConfigResource_destroy_array(rd_kafka_ConfigResource_t **config, size_t config_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_ConfigResource_set_config(rd_kafka_ConfigResource_t *config, const char *name, const char *value);</span>
<span class="s1">const rd_kafka_ConfigEntry_t **rd_kafka_ConfigResource_configs(const rd_kafka_ConfigResource_t *config, size_t *cntp);</span>
<span class="s1">rd_kafka_ResourceType_t rd_kafka_ConfigResource_type(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">const char *rd_kafka_ConfigResource_name(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_ConfigResource_error(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">const char *rd_kafka_ConfigResource_error_string(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">void rd_kafka_AlterConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_ConfigResource_t **rd_kafka_AlterConfigs_result_resources(const rd_kafka_AlterConfigs_result_t *result, size_t *cntp);</span>
<span class="s1">void rd_kafka_DescribeConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_ConfigResource_t **rd_kafka_DescribeConfigs_result_resources(const rd_kafka_DescribeConfigs_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_DeleteRecords_s rd_kafka_DeleteRecords_t;</span>
<span class="s1">rd_kafka_DeleteRecords_t *rd_kafka_DeleteRecords_new(const rd_kafka_topic_partition_list_t *before_offsets);</span>
<span class="s1">void rd_kafka_DeleteRecords_destroy(rd_kafka_DeleteRecords_t *del_records);</span>
<span class="s1">void rd_kafka_DeleteRecords_destroy_array(rd_kafka_DeleteRecords_t **del_records, size_t del_record_cnt);</span>
<span class="s1">void rd_kafka_DeleteRecords(rd_kafka_t *rk, rd_kafka_DeleteRecords_t **del_records, size_t del_record_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_partition_list_t *rd_kafka_DeleteRecords_result_offsets(const rd_kafka_DeleteRecords_result_t *result);</span>
<span class="s1">typedef struct rd_kafka_DeleteGroup_s rd_kafka_DeleteGroup_t;</span>
<span class="s1">rd_kafka_DeleteGroup_t *rd_kafka_DeleteGroup_new(const char *group);</span>
<span class="s1">void rd_kafka_DeleteGroup_destroy(rd_kafka_DeleteGroup_t *del_group);</span>
<span class="s1">void rd_kafka_DeleteGroup_destroy_array(rd_kafka_DeleteGroup_t **del_groups, size_t del_group_cnt);</span>
<span class="s1">void rd_kafka_DeleteGroups(rd_kafka_t *rk, rd_kafka_DeleteGroup_t **del_groups, size_t del_group_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_group_result_t **rd_kafka_DeleteGroups_result_groups(const rd_kafka_DeleteGroups_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_DeleteConsumerGroupOffsets_s rd_kafka_DeleteConsumerGroupOffsets_t;</span>
<span class="s1">rd_kafka_DeleteConsumerGroupOffsets_t *rd_kafka_DeleteConsumerGroupOffsets_new(const char *group, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">void rd_kafka_DeleteConsumerGroupOffsets_destroy(rd_kafka_DeleteConsumerGroupOffsets_t *del_grpoffsets);</span>
<span class="s1">void rd_kafka_DeleteConsumerGroupOffsets_destroy_array(rd_kafka_DeleteConsumerGroupOffsets_t **del_grpoffsets, size_t del_grpoffset_cnt);</span>
<span class="s1">void rd_kafka_DeleteConsumerGroupOffsets(rd_kafka_t *rk, rd_kafka_DeleteConsumerGroupOffsets_t **del_grpoffsets, size_t del_grpoffsets_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_group_result_t **rd_kafka_DeleteConsumerGroupOffsets_result_groups(const rd_kafka_DeleteConsumerGroupOffsets_result_t *result, size_t *cntp);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token(rd_kafka_t *rk, const char *token_value, int64_t md_lifetime_ms, const char *md_principal_name, const char **extensions, size_t extension_size, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token_failure(rd_kafka_t *rk, const char *errstr);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_init_transactions(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_begin_transaction(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_send_offsets_to_transaction(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, const rd_kafka_consumer_group_metadata_t *cgmetadata, int timeout_ms);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_commit_transaction(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_abort_transaction(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">typedef struct rd_kafka_mock_cluster_s rd_kafka_mock_cluster_t;</span>
<span class="s1">rd_kafka_mock_cluster_t *rd_kafka_mock_cluster_new(rd_kafka_t *rk, int broker_cnt);</span>
<span class="s1">void rd_kafka_mock_cluster_destroy(rd_kafka_mock_cluster_t *mcluster);</span>
<span class="s1">rd_kafka_t *rd_kafka_mock_cluster_handle(const rd_kafka_mock_cluster_t *mcluster);</span>
<span class="s1">rd_kafka_mock_cluster_t *rd_kafka_handle_mock_cluster(const rd_kafka_t *rk);</span>
<span class="s1">const char *rd_kafka_mock_cluster_bootstraps(const rd_kafka_mock_cluster_t *mcluster);</span>
<span class="s1">void rd_kafka_mock_clear_request_errors(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey);</span>
<span class="s1">void rd_kafka_mock_push_request_errors(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, size_t cnt, ...);</span>
<span class="s1">void rd_kafka_mock_push_request_errors_array(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, size_t cnt, const rd_kafka_resp_err_t *errors);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_push_request_error_rtts(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int16_t ApiKey, size_t cnt, ...);</span>
<span class="s1">void rd_kafka_mock_topic_set_error(rd_kafka_mock_cluster_t *mcluster, const char *topic, rd_kafka_resp_err_t err);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_topic_create(rd_kafka_mock_cluster_t *mcluster, const char *topic, int partition_cnt, int replication_factor);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_partition_set_leader(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_partition_set_follower(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_partition_set_follower_wmarks(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int64_t lo, int64_t hi);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_set_down(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_set_up(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_set_rtt(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int rtt_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_set_rack(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, const char *rack);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_coordinator_set(rd_kafka_mock_cluster_t *mcluster, const char *key_type, const char *key, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_set_apiversion(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, int16_t MinVersion, int16_t MaxVersion);</span>
<span class="s1">&#39;</span>
</code></pre></div>
rdkafka.h, rdkafka_mock.h</p>
<h3 id="rd_kafka_version_19">RD_KAFKA_VERSION<a class="headerlink" href="#rd_kafka_version_19" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_VERSION</span> <span class="o">=</span> <span class="mi">17367295</span>
</code></pre></div>
<p>librdkafka version </p>
<p>Interpreted as hex <code>MM.mm.rr.xx</code>:</p>
<ul>
<li>MM = Major</li>
<li>mm = minor</li>
<li>rr = revision</li>
<li>xx = pre-release id (0xff is the final release)</li>
</ul>
<p>E.g.: <code>0x000801ff</code> = 0.8.1</p>
<dl class="section remark"><dt>Remarks</dt><dd>This value should only be used during compile time, for runtime checks of version use rd_kafka_version() </dd></dl>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_unsupported_compression_type_19">RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE<a class="headerlink" href="#rd_kafka_resp_err_unsupported_compression_type_19" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE</span> <span class="o">=</span> <span class="mi">76</span>
</code></pre></div>
<p>Unsupported compression type </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_end_all_19">RD_KAFKA_RESP_ERR_END_ALL<a class="headerlink" href="#rd_kafka_resp_err_end_all_19" title="Permanent link">&para;</a></h3>
<p><div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_END_ALL</span> <span class="o">=</span> <span class="mi">98</span>
</code></pre></div>
enum rd_kafka_resp_err_t</p>
<h3 id="rd_kafka_admin_op__cnt_19">RD_KAFKA_ADMIN_OP__CNT<a class="headerlink" href="#rd_kafka_admin_op__cnt_19" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_ADMIN_OP__CNT</span> <span class="o">=</span> <span class="mi">12</span>
</code></pre></div>
<p>Number of ops defined </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe </a></li>
</ul>
</div>
<h3 id="rd_kafka_resource__cnt_19">RD_KAFKA_RESOURCE__CNT<a class="headerlink" href="#rd_kafka_resource__cnt_19" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESOURCE__CNT</span> <span class="o">=</span> <span class="mi">5</span>
</code></pre></div>
<p>Number of resource types defined </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#acca83a66d7783ff7683ed2691cc907c9"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#acca83a66d7783ff7683ed2691cc907c9 </a></li>
</ul>
</div>
<h3 id="rd_kafka_cdef_19">RD_KAFKA_CDEF<a class="headerlink" href="#rd_kafka_cdef_19" title="Permanent link">&para;</a></h3>
<p><div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_CDEF</span> <span class="o">=</span> <span class="s1">&#39;typedef long int ssize_t;</span>
<span class="s1">typedef struct _IO_FILE FILE;</span>
<span class="s1">typedef long int mode_t;</span>
<span class="s1">typedef signed int int16_t;</span>
<span class="s1">typedef unsigned int uint16_t;</span>
<span class="s1">typedef signed int int32_t;</span>
<span class="s1">typedef signed long int int64_t;</span>
<span class="s1">int rd_kafka_version(void);</span>
<span class="s1">const char *rd_kafka_version_str(void);</span>
<span class="s1">typedef enum rd_kafka_type_t {</span>
<span class="s1">  RD_KAFKA_PRODUCER,</span>
<span class="s1">  RD_KAFKA_CONSUMER,</span>
<span class="s1">} rd_kafka_type_t;</span>
<span class="s1">typedef enum rd_kafka_timestamp_type_t {</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_NOT_AVAILABLE,</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_CREATE_TIME,</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_LOG_APPEND_TIME,</span>
<span class="s1">} rd_kafka_timestamp_type_t;</span>
<span class="s1">const char *rd_kafka_get_debug_contexts(void);</span>
<span class="s1">typedef struct rd_kafka_s rd_kafka_t;</span>
<span class="s1">typedef struct rd_kafka_topic_s rd_kafka_topic_t;</span>
<span class="s1">typedef struct rd_kafka_conf_s rd_kafka_conf_t;</span>
<span class="s1">typedef struct rd_kafka_topic_conf_s rd_kafka_topic_conf_t;</span>
<span class="s1">typedef struct rd_kafka_queue_s rd_kafka_queue_t;</span>
<span class="s1">typedef struct rd_kafka_op_s rd_kafka_event_t;</span>
<span class="s1">typedef struct rd_kafka_topic_result_s rd_kafka_topic_result_t;</span>
<span class="s1">typedef struct rd_kafka_consumer_group_metadata_s rd_kafka_consumer_group_metadata_t;</span>
<span class="s1">typedef struct rd_kafka_error_s {</span>
<span class="s1">  unsigned int code;</span>
<span class="s1">  char *errstr;</span>
<span class="s1">  unsigned char fatal;</span>
<span class="s1">  unsigned char retriable;</span>
<span class="s1">  unsigned char txn_requires_abort;</span>
<span class="s1">} rd_kafka_error_t;</span>
<span class="s1">typedef struct rd_kafka_headers_s rd_kafka_headers_t;</span>
<span class="s1">typedef struct rd_kafka_group_result_s rd_kafka_group_result_t;</span>
<span class="s1">typedef struct rd_kafka_acl_result_s rd_kafka_acl_result_t;</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BEGIN = (- 200),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BAD_MSG = (- 199),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BAD_COMPRESSION = (- 198),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__DESTROY = (- 197),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FAIL = (- 196),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TRANSPORT = (- 195),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__CRIT_SYS_RESOURCE = (- 194),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__RESOLVE = (- 193),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__MSG_TIMED_OUT = (- 192),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PARTITION_EOF = (- 191),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION = (- 190),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FS = (- 189),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC = (- 188),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ALL_BROKERS_DOWN = (- 187),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INVALID_ARG = (- 186),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TIMED_OUT = (- 185),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__QUEUE_FULL = (- 184),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ISR_INSUFF = (- 183),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NODE_UPDATE = (- 182),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__SSL = (- 181),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__WAIT_COORD = (- 180),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_GROUP = (- 179),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__IN_PROGRESS = (- 178),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PREV_IN_PROGRESS = (- 177),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__EXISTING_SUBSCRIPTION = (- 176),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS = (- 175),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS = (- 174),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__CONFLICT = (- 173),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__STATE = (- 172),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_PROTOCOL = (- 171),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED = (- 170),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__AUTHENTICATION = (- 169),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NO_OFFSET = (- 168),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__OUTDATED = (- 167),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TIMED_OUT_QUEUE = (- 166),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNSUPPORTED_FEATURE = (- 165),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__WAIT_CACHE = (- 164),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INTR = (- 163),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__KEY_SERIALIZATION = (- 162),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__VALUE_SERIALIZATION = (- 161),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__KEY_DESERIALIZATION = (- 160),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__VALUE_DESERIALIZATION = (- 159),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PARTIAL = (- 158),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__READ_ONLY = (- 157),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOENT = (- 156),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNDERFLOW = (- 155),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INVALID_TYPE = (- 154),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__RETRY = (- 153),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PURGE_QUEUE = (- 152),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PURGE_INFLIGHT = (- 151),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FATAL = (- 150),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INCONSISTENT = (- 149),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__GAPLESS_GUARANTEE = (- 148),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__MAX_POLL_EXCEEDED = (- 147),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_BROKER = (- 146),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOT_CONFIGURED = (- 145),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FENCED = (- 144),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__APPLICATION = (- 143),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ASSIGNMENT_LOST = (- 142),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOOP = (- 141),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__AUTO_OFFSET_RESET = (- 140),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__END = (- 100),</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN = (- 1),</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NO_ERROR = 0,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_OUT_OF_RANGE = 1,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_MSG = 2,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART = 3,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_MSG_SIZE = 4,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE = 5,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_LEADER_FOR_PARTITION = 6,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REQUEST_TIMED_OUT = 7,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_BROKER_NOT_AVAILABLE = 8,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REPLICA_NOT_AVAILABLE = 9,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE = 10,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_STALE_CTRL_EPOCH = 11,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_METADATA_TOO_LARGE = 12,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NETWORK_EXCEPTION = 13,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_COORDINATOR_LOAD_IN_PROGRESS = 14,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_COORDINATOR_NOT_AVAILABLE = 15,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_COORDINATOR = 16,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_EXCEPTION = 17,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_RECORD_LIST_TOO_LARGE = 18,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS = 19,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS_AFTER_APPEND = 20,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REQUIRED_ACKS = 21,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ILLEGAL_GENERATION = 22,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INCONSISTENT_GROUP_PROTOCOL = 23,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_GROUP_ID = 24,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_MEMBER_ID = 25,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_SESSION_TIMEOUT = 26,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REBALANCE_IN_PROGRESS = 27,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_COMMIT_OFFSET_SIZE = 28,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_AUTHORIZATION_FAILED = 29,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_AUTHORIZATION_FAILED = 30,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_CLUSTER_AUTHORIZATION_FAILED = 31,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TIMESTAMP = 32,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_SASL_MECHANISM = 33,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ILLEGAL_SASL_STATE = 34,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_VERSION = 35,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_ALREADY_EXISTS = 36,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PARTITIONS = 37,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REPLICATION_FACTOR = 38,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REPLICA_ASSIGNMENT = 39,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_CONFIG = 40,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_CONTROLLER = 41,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REQUEST = 42,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_FOR_MESSAGE_FORMAT = 43,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_POLICY_VIOLATION = 44,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OUT_OF_ORDER_SEQUENCE_NUMBER = 45,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DUPLICATE_SEQUENCE_NUMBER = 46,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_EPOCH = 47,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TXN_STATE = 48,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_ID_MAPPING = 49,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TRANSACTION_TIMEOUT = 50,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_CONCURRENT_TRANSACTIONS = 51,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TRANSACTION_COORDINATOR_FENCED = 52,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TRANSACTIONAL_ID_AUTHORIZATION_FAILED = 53,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_SECURITY_DISABLED = 54,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OPERATION_NOT_ATTEMPTED = 55,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_KAFKA_STORAGE_ERROR = 56,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LOG_DIR_NOT_FOUND = 57,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_SASL_AUTHENTICATION_FAILED = 58,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_PRODUCER_ID = 59,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REASSIGNMENT_IN_PROGRESS = 60,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTH_DISABLED = 61,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_NOT_FOUND = 62,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_OWNER_MISMATCH = 63,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_REQUEST_NOT_ALLOWED = 64,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTHORIZATION_FAILED = 65,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_EXPIRED = 66,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRINCIPAL_TYPE = 67,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NON_EMPTY_GROUP = 68,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_ID_NOT_FOUND = 69,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FETCH_SESSION_ID_NOT_FOUND = 70,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_FETCH_SESSION_EPOCH = 71,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LISTENER_NOT_FOUND = 72,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_DELETION_DISABLED = 73,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FENCED_LEADER_EPOCH = 74,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_LEADER_EPOCH = 75,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_STALE_BROKER_EPOCH = 77,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_NOT_AVAILABLE = 78,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_MEMBER_ID_REQUIRED = 79,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_PREFERRED_LEADER_NOT_AVAILABLE = 80,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_MAX_SIZE_REACHED = 81,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FENCED_INSTANCE_ID = 82,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ELIGIBLE_LEADERS_NOT_AVAILABLE = 83,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ELECTION_NOT_NEEDED = 84,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NO_REASSIGNMENT_IN_PROGRESS = 85,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_SUBSCRIBED_TO_TOPIC = 86,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_RECORD = 87,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSTABLE_OFFSET_COMMIT = 88,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_THROTTLING_QUOTA_EXCEEDED = 89,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_PRODUCER_FENCED = 90,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_RESOURCE_NOT_FOUND = 91,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DUPLICATE_RESOURCE = 92,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNACCEPTABLE_CREDENTIAL = 93,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INCONSISTENT_VOTER_SET = 94,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_UPDATE_VERSION = 95,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FEATURE_UPDATE_FAILED = 96,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_PRINCIPAL_DESERIALIZATION_FAILURE = 97,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_END_ALL,</span>
<span class="s1">} rd_kafka_resp_err_t;</span>
<span class="s1">struct rd_kafka_err_desc {</span>
<span class="s1">  rd_kafka_resp_err_t code;</span>
<span class="s1">  char *name;</span>
<span class="s1">  char *desc;</span>
<span class="s1">};</span>
<span class="s1">void rd_kafka_get_err_descs(const struct rd_kafka_err_desc **errdescs, size_t *cntp);</span>
<span class="s1">const char *rd_kafka_err2str(rd_kafka_resp_err_t err);</span>
<span class="s1">const char *rd_kafka_err2name(rd_kafka_resp_err_t err);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_last_error(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_errno2err(int errnox);</span>
<span class="s1">int rd_kafka_errno(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_fatal_error(rd_kafka_t *rk, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_test_fatal_error(rd_kafka_t *rk, rd_kafka_resp_err_t err, const char *reason);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_error_code(const rd_kafka_error_t *error);</span>
<span class="s1">const char *rd_kafka_error_name(const rd_kafka_error_t *error);</span>
<span class="s1">const char *rd_kafka_error_string(const rd_kafka_error_t *error);</span>
<span class="s1">int rd_kafka_error_is_fatal(const rd_kafka_error_t *error);</span>
<span class="s1">int rd_kafka_error_is_retriable(const rd_kafka_error_t *error);</span>
<span class="s1">int rd_kafka_error_txn_requires_abort(const rd_kafka_error_t *error);</span>
<span class="s1">void rd_kafka_error_destroy(rd_kafka_error_t *error);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_error_new(rd_kafka_resp_err_t code, const char *fmt, ...);</span>
<span class="s1">typedef struct rd_kafka_topic_partition_s {</span>
<span class="s1">  char *topic;</span>
<span class="s1">  int32_t partition;</span>
<span class="s1">  int64_t offset;</span>
<span class="s1">  void *metadata;</span>
<span class="s1">  size_t metadata_size;</span>
<span class="s1">  void *opaque;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  void *_private;</span>
<span class="s1">} rd_kafka_topic_partition_t;</span>
<span class="s1">void rd_kafka_topic_partition_destroy(rd_kafka_topic_partition_t *rktpar);</span>
<span class="s1">typedef struct rd_kafka_topic_partition_list_s {</span>
<span class="s1">  int cnt;</span>
<span class="s1">  int size;</span>
<span class="s1">  rd_kafka_topic_partition_t *elems;</span>
<span class="s1">} rd_kafka_topic_partition_list_t;</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_new(int size);</span>
<span class="s1">void rd_kafka_topic_partition_list_destroy(rd_kafka_topic_partition_list_t *rkparlist);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_add(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">void rd_kafka_topic_partition_list_add_range(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t start, int32_t stop);</span>
<span class="s1">int rd_kafka_topic_partition_list_del(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">int rd_kafka_topic_partition_list_del_by_idx(rd_kafka_topic_partition_list_t *rktparlist, int idx);</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_copy(const rd_kafka_topic_partition_list_t *src);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_topic_partition_list_set_offset(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition, int64_t offset);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_find(const rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">void rd_kafka_topic_partition_list_sort(rd_kafka_topic_partition_list_t *rktparlist, int (*cmp)(const void *a, const void *b, void *cmp_opaque), void *cmp_opaque);</span>
<span class="s1">typedef enum rd_kafka_vtype_t {</span>
<span class="s1">  RD_KAFKA_VTYPE_END,</span>
<span class="s1">  RD_KAFKA_VTYPE_TOPIC,</span>
<span class="s1">  RD_KAFKA_VTYPE_RKT,</span>
<span class="s1">  RD_KAFKA_VTYPE_PARTITION,</span>
<span class="s1">  RD_KAFKA_VTYPE_VALUE,</span>
<span class="s1">  RD_KAFKA_VTYPE_KEY,</span>
<span class="s1">  RD_KAFKA_VTYPE_OPAQUE,</span>
<span class="s1">  RD_KAFKA_VTYPE_MSGFLAGS,</span>
<span class="s1">  RD_KAFKA_VTYPE_TIMESTAMP,</span>
<span class="s1">  RD_KAFKA_VTYPE_HEADER,</span>
<span class="s1">  RD_KAFKA_VTYPE_HEADERS,</span>
<span class="s1">} rd_kafka_vtype_t;</span>
<span class="s1">typedef struct rd_kafka_vu_s {</span>
<span class="s1">  rd_kafka_vtype_t vtype;</span>
<span class="s1">  union {</span>
<span class="s1">    char *cstr;</span>
<span class="s1">    rd_kafka_topic_t *rkt;</span>
<span class="s1">    int i;</span>
<span class="s1">    int32_t i32;</span>
<span class="s1">    int64_t i64;</span>
<span class="s1">    struct {</span>
<span class="s1">      void *ptr;</span>
<span class="s1">      size_t size;</span>
<span class="s1">    } mem;</span>
<span class="s1">    struct {</span>
<span class="s1">      char *name;</span>
<span class="s1">      void *val;</span>
<span class="s1">      ssize_t size;</span>
<span class="s1">    } header;</span>
<span class="s1">    rd_kafka_headers_t *headers;</span>
<span class="s1">    void *ptr;</span>
<span class="s1">    char _pad[64];</span>
<span class="s1">  } u;</span>
<span class="s1">} rd_kafka_vu_t;</span>
<span class="s1">rd_kafka_headers_t *rd_kafka_headers_new(size_t initial_count);</span>
<span class="s1">void rd_kafka_headers_destroy(rd_kafka_headers_t *hdrs);</span>
<span class="s1">rd_kafka_headers_t *rd_kafka_headers_copy(const rd_kafka_headers_t *src);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_add(rd_kafka_headers_t *hdrs, const char *name, ssize_t name_size, const void *value, ssize_t value_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_remove(rd_kafka_headers_t *hdrs, const char *name);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get_last(const rd_kafka_headers_t *hdrs, const char *name, const void **valuep, size_t *sizep);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get(const rd_kafka_headers_t *hdrs, size_t idx, const char *name, const void **valuep, size_t *sizep);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get_all(const rd_kafka_headers_t *hdrs, size_t idx, const char **namep, const void **valuep, size_t *sizep);</span>
<span class="s1">typedef struct rd_kafka_message_s {</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  rd_kafka_topic_t *rkt;</span>
<span class="s1">  int32_t partition;</span>
<span class="s1">  void *payload;</span>
<span class="s1">  size_t len;</span>
<span class="s1">  void *key;</span>
<span class="s1">  size_t key_len;</span>
<span class="s1">  int64_t offset;</span>
<span class="s1">  void *_private;</span>
<span class="s1">} rd_kafka_message_t;</span>
<span class="s1">void rd_kafka_message_destroy(rd_kafka_message_t *rkmessage);</span>
<span class="s1">const char *rd_kafka_message_errstr(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">int64_t rd_kafka_message_timestamp(const rd_kafka_message_t *rkmessage, rd_kafka_timestamp_type_t *tstype);</span>
<span class="s1">int64_t rd_kafka_message_latency(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">int32_t rd_kafka_message_broker_id(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_message_headers(const rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_message_detach_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);</span>
<span class="s1">void rd_kafka_message_set_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t *hdrs);</span>
<span class="s1">size_t rd_kafka_header_cnt(const rd_kafka_headers_t *hdrs);</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_NOT_PERSISTED = 0,</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_POSSIBLY_PERSISTED = 1,</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_PERSISTED = 2,</span>
<span class="s1">} rd_kafka_msg_status_t;</span>
<span class="s1">rd_kafka_msg_status_t rd_kafka_message_status(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_CONF_UNKNOWN = (- 2),</span>
<span class="s1">  RD_KAFKA_CONF_INVALID = (- 1),</span>
<span class="s1">  RD_KAFKA_CONF_OK = 0,</span>
<span class="s1">} rd_kafka_conf_res_t;</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_new(void);</span>
<span class="s1">void rd_kafka_conf_destroy(rd_kafka_conf_t *conf);</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_dup(const rd_kafka_conf_t *conf);</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_dup_filter(const rd_kafka_conf_t *conf, size_t filter_cnt, const char **filter);</span>
<span class="s1">const rd_kafka_conf_t *rd_kafka_conf(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_set(rd_kafka_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_conf_set_events(rd_kafka_conf_t *conf, int events);</span>
<span class="s1">void rd_kafka_conf_set_background_event_cb(rd_kafka_conf_t *conf, void (*event_cb)(rd_kafka_t *rk, rd_kafka_event_t *rkev, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_dr_cb(rd_kafka_conf_t *conf, void (*dr_cb)(rd_kafka_t *rk, void *payload, size_t len, rd_kafka_resp_err_t err, void *opaque, void *msg_opaque));</span>
<span class="s1">void rd_kafka_conf_set_dr_msg_cb(rd_kafka_conf_t *conf, void (*dr_msg_cb)(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_consume_cb(rd_kafka_conf_t *conf, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_rebalance_cb(rd_kafka_conf_t *conf, void (*rebalance_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *partitions, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_offset_commit_cb(rd_kafka_conf_t *conf, void (*offset_commit_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_error_cb(rd_kafka_conf_t *conf, void (*error_cb)(rd_kafka_t *rk, int err, const char *reason, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_throttle_cb(rd_kafka_conf_t *conf, void (*throttle_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int throttle_time_ms, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_log_cb(rd_kafka_conf_t *conf, void (*log_cb)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));</span>
<span class="s1">void rd_kafka_conf_set_stats_cb(rd_kafka_conf_t *conf, int (*stats_cb)(rd_kafka_t *rk, char *json, size_t json_len, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_oauthbearer_token_refresh_cb(rd_kafka_conf_t *conf, void (*oauthbearer_token_refresh_cb)(rd_kafka_t *rk, const char *oauthbearer_config, void *opaque));</span>
<span class="s1">void rd_kafka_conf_enable_sasl_queue(rd_kafka_conf_t *conf, int enable);</span>
<span class="s1">void rd_kafka_conf_set_socket_cb(rd_kafka_conf_t *conf, int (*socket_cb)(int domain, int type, int protocol, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_connect_cb(rd_kafka_conf_t *conf, int (*connect_cb)(int sockfd, const struct sockaddr *addr, int addrlen, const char *id, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_closesocket_cb(rd_kafka_conf_t *conf, int (*closesocket_cb)(int sockfd, void *opaque));</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert_verify_cb(rd_kafka_conf_t *conf, int (*ssl_cert_verify_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int *x509_error, int depth, const char *buf, size_t size, char *errstr, size_t errstr_size, void *opaque));</span>
<span class="s1">typedef enum rd_kafka_cert_type_t {</span>
<span class="s1">  RD_KAFKA_CERT_PUBLIC_KEY,</span>
<span class="s1">  RD_KAFKA_CERT_PRIVATE_KEY,</span>
<span class="s1">  RD_KAFKA_CERT_CA,</span>
<span class="s1">  RD_KAFKA_CERT__CNT,</span>
<span class="s1">} rd_kafka_cert_type_t;</span>
<span class="s1">typedef enum rd_kafka_cert_enc_t {</span>
<span class="s1">  RD_KAFKA_CERT_ENC_PKCS12,</span>
<span class="s1">  RD_KAFKA_CERT_ENC_DER,</span>
<span class="s1">  RD_KAFKA_CERT_ENC_PEM,</span>
<span class="s1">  RD_KAFKA_CERT_ENC__CNT,</span>
<span class="s1">} rd_kafka_cert_enc_t;</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert(rd_kafka_conf_t *conf, rd_kafka_cert_type_t cert_type, rd_kafka_cert_enc_t cert_enc, const void *buffer, size_t size, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_conf_set_engine_callback_data(rd_kafka_conf_t *conf, void *callback_data);</span>
<span class="s1">void rd_kafka_conf_set_opaque(rd_kafka_conf_t *conf, void *opaque);</span>
<span class="s1">void *rd_kafka_opaque(const rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_conf_set_default_topic_conf(rd_kafka_conf_t *conf, rd_kafka_topic_conf_t *tconf);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_conf_get_default_topic_conf(rd_kafka_conf_t *conf);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_get(const rd_kafka_conf_t *conf, const char *name, char *dest, size_t *dest_size);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_topic_conf_get(const rd_kafka_topic_conf_t *conf, const char *name, char *dest, size_t *dest_size);</span>
<span class="s1">const char **rd_kafka_conf_dump(rd_kafka_conf_t *conf, size_t *cntp);</span>
<span class="s1">const char **rd_kafka_topic_conf_dump(rd_kafka_topic_conf_t *conf, size_t *cntp);</span>
<span class="s1">void rd_kafka_conf_dump_free(const char **arr, size_t cnt);</span>
<span class="s1">void rd_kafka_conf_properties_show(FILE *fp);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_topic_conf_new(void);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_topic_conf_dup(const rd_kafka_topic_conf_t *conf);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_default_topic_conf_dup(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_topic_conf_destroy(rd_kafka_topic_conf_t *topic_conf);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_topic_conf_set(rd_kafka_topic_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_topic_conf_set_opaque(rd_kafka_topic_conf_t *conf, void *rkt_opaque);</span>
<span class="s1">void rd_kafka_topic_conf_set_partitioner_cb(rd_kafka_topic_conf_t *topic_conf, int32_t (*partitioner)(const rd_kafka_topic_t *rkt, const void *keydata, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque));</span>
<span class="s1">void rd_kafka_topic_conf_set_msg_order_cmp(rd_kafka_topic_conf_t *topic_conf, int (*msg_order_cmp)(const rd_kafka_message_t *a, const rd_kafka_message_t *b));</span>
<span class="s1">int rd_kafka_topic_partition_available(const rd_kafka_topic_t *rkt, int32_t partition);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_consistent(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_consistent_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_murmur2(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_murmur2_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_fnv1a(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_fnv1a_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">rd_kafka_t *rd_kafka_new(rd_kafka_type_t type, rd_kafka_conf_t *conf, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_destroy(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_destroy_flags(rd_kafka_t *rk, int flags);</span>
<span class="s1">const char *rd_kafka_name(const rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_type_t rd_kafka_type(const rd_kafka_t *rk);</span>
<span class="s1">char *rd_kafka_memberid(const rd_kafka_t *rk);</span>
<span class="s1">char *rd_kafka_clusterid(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">int32_t rd_kafka_controllerid(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_topic_t *rd_kafka_topic_new(rd_kafka_t *rk, const char *topic, rd_kafka_topic_conf_t *conf);</span>
<span class="s1">void rd_kafka_topic_destroy(rd_kafka_topic_t *rkt);</span>
<span class="s1">const char *rd_kafka_topic_name(const rd_kafka_topic_t *rkt);</span>
<span class="s1">void *rd_kafka_topic_opaque(const rd_kafka_topic_t *rkt);</span>
<span class="s1">int rd_kafka_poll(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">void rd_kafka_yield(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_pause_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_resume_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_query_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_get_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offsets_for_times(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets, int timeout_ms);</span>
<span class="s1">void *rd_kafka_mem_calloc(rd_kafka_t *rk, size_t num, size_t size);</span>
<span class="s1">void *rd_kafka_mem_malloc(rd_kafka_t *rk, size_t size);</span>
<span class="s1">void rd_kafka_mem_free(rd_kafka_t *rk, void *ptr);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_new(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_queue_destroy(rd_kafka_queue_t *rkqu);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_main(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_sasl(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_sasl_background_callbacks_enable(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_consumer(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_partition(rd_kafka_t *rk, const char *topic, int32_t partition);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_background(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_queue_forward(rd_kafka_queue_t *src, rd_kafka_queue_t *dst);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_set_log_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu);</span>
<span class="s1">size_t rd_kafka_queue_length(rd_kafka_queue_t *rkqu);</span>
<span class="s1">void rd_kafka_queue_io_event_enable(rd_kafka_queue_t *rkqu, int fd, const void *payload, size_t size);</span>
<span class="s1">void rd_kafka_queue_cb_event_enable(rd_kafka_queue_t *rkqu, void (*event_cb)(rd_kafka_t *rk, void *qev_opaque), void *qev_opaque);</span>
<span class="s1">void rd_kafka_queue_yield(rd_kafka_queue_t *rkqu);</span>
<span class="s1">int rd_kafka_consume_start(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);</span>
<span class="s1">int rd_kafka_consume_start_queue(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, rd_kafka_queue_t *rkqu);</span>
<span class="s1">int rd_kafka_consume_stop(rd_kafka_topic_t *rkt, int32_t partition);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_seek(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, int timeout_ms);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_seek_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consume(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms);</span>
<span class="s1">ssize_t rd_kafka_consume_batch(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);</span>
<span class="s1">int rd_kafka_consume_callback(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consume_queue(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">ssize_t rd_kafka_consume_batch_queue(rd_kafka_queue_t *rkqu, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);</span>
<span class="s1">int rd_kafka_consume_callback_queue(rd_kafka_queue_t *rkqu, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offset_store(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offsets_store(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_subscribe(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *topics);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_unsubscribe(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_subscription(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **topics);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consumer_poll(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_consumer_close(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_consumer_close_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu);</span>
<span class="s1">int rd_kafka_consumer_closed(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_incremental_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_incremental_unassign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">const char *rd_kafka_rebalance_protocol(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_assignment(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **partitions);</span>
<span class="s1">int rd_kafka_assignment_lost(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, int async);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit_message(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, int async);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit_queue(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_queue_t *rkqu, void (*cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *commit_opaque), void *commit_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_committed(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_position(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata_new(const char *group_id);</span>
<span class="s1">rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata_new_with_genid(const char *group_id, int32_t generation_id, const char *member_id, const char *group_instance_id);</span>
<span class="s1">void rd_kafka_consumer_group_metadata_destroy(rd_kafka_consumer_group_metadata_t *);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_consumer_group_metadata_write(const rd_kafka_consumer_group_metadata_t *cgmd, void **bufferp, size_t *sizep);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_consumer_group_metadata_read(rd_kafka_consumer_group_metadata_t **cgmdp, const void *buffer, size_t size);</span>
<span class="s1">int rd_kafka_produce(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, void *payload, size_t len, const void *key, size_t keylen, void *msg_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_producev(rd_kafka_t *rk, ...);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_produceva(rd_kafka_t *rk, const rd_kafka_vu_t *vus, size_t cnt);</span>
<span class="s1">int rd_kafka_produce_batch(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, rd_kafka_message_t *rkmessages, int message_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_flush(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_purge(rd_kafka_t *rk, int purge_flags);</span>
<span class="s1">typedef struct rd_kafka_metadata_broker {</span>
<span class="s1">  int32_t id;</span>
<span class="s1">  char *host;</span>
<span class="s1">  int port;</span>
<span class="s1">} rd_kafka_metadata_broker_t;</span>
<span class="s1">typedef struct rd_kafka_metadata_partition {</span>
<span class="s1">  int32_t id;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  int32_t leader;</span>
<span class="s1">  int replica_cnt;</span>
<span class="s1">  int32_t *replicas;</span>
<span class="s1">  int isr_cnt;</span>
<span class="s1">  int32_t *isrs;</span>
<span class="s1">} rd_kafka_metadata_partition_t;</span>
<span class="s1">typedef struct rd_kafka_metadata_topic {</span>
<span class="s1">  char *topic;</span>
<span class="s1">  int partition_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_partition *partitions;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">} rd_kafka_metadata_topic_t;</span>
<span class="s1">typedef struct rd_kafka_metadata {</span>
<span class="s1">  int broker_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_broker *brokers;</span>
<span class="s1">  int topic_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_topic *topics;</span>
<span class="s1">  int32_t orig_broker_id;</span>
<span class="s1">  char *orig_broker_name;</span>
<span class="s1">} rd_kafka_metadata_t;</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_metadata(rd_kafka_t *rk, int all_topics, rd_kafka_topic_t *only_rkt, const struct rd_kafka_metadata **metadatap, int timeout_ms);</span>
<span class="s1">void rd_kafka_metadata_destroy(const struct rd_kafka_metadata *metadata);</span>
<span class="s1">struct rd_kafka_group_member_info {</span>
<span class="s1">  char *member_id;</span>
<span class="s1">  char *client_id;</span>
<span class="s1">  char *client_host;</span>
<span class="s1">  void *member_metadata;</span>
<span class="s1">  int member_metadata_size;</span>
<span class="s1">  void *member_assignment;</span>
<span class="s1">  int member_assignment_size;</span>
<span class="s1">};</span>
<span class="s1">struct rd_kafka_group_info {</span>
<span class="s1">  struct rd_kafka_metadata_broker broker;</span>
<span class="s1">  char *group;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  char *state;</span>
<span class="s1">  char *protocol_type;</span>
<span class="s1">  char *protocol;</span>
<span class="s1">  struct rd_kafka_group_member_info *members;</span>
<span class="s1">  int member_cnt;</span>
<span class="s1">};</span>
<span class="s1">struct rd_kafka_group_list {</span>
<span class="s1">  struct rd_kafka_group_info *groups;</span>
<span class="s1">  int group_cnt;</span>
<span class="s1">};</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_list_groups(rd_kafka_t *rk, const char *group, const struct rd_kafka_group_list **grplistp, int timeout_ms);</span>
<span class="s1">void rd_kafka_group_list_destroy(const struct rd_kafka_group_list *grplist);</span>
<span class="s1">int rd_kafka_brokers_add(rd_kafka_t *rk, const char *brokerlist);</span>
<span class="s1">void rd_kafka_set_logger(rd_kafka_t *rk, void (*func)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));</span>
<span class="s1">void rd_kafka_set_log_level(rd_kafka_t *rk, int level);</span>
<span class="s1">void rd_kafka_log_print(const rd_kafka_t *rk, int level, const char *fac, const char *buf);</span>
<span class="s1">void rd_kafka_log_syslog(const rd_kafka_t *rk, int level, const char *fac, const char *buf);</span>
<span class="s1">int rd_kafka_outq_len(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_dump(FILE *fp, rd_kafka_t *rk);</span>
<span class="s1">int rd_kafka_thread_cnt(void);</span>
<span class="s1">typedef enum rd_kafka_thread_type_t {</span>
<span class="s1">  RD_KAFKA_THREAD_MAIN,</span>
<span class="s1">  RD_KAFKA_THREAD_BACKGROUND,</span>
<span class="s1">  RD_KAFKA_THREAD_BROKER,</span>
<span class="s1">} rd_kafka_thread_type_t;</span>
<span class="s1">int rd_kafka_wait_destroyed(int timeout_ms);</span>
<span class="s1">int rd_kafka_unittest(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_poll_set_consumer(rd_kafka_t *rk);</span>
<span class="s1">typedef int rd_kafka_event_type_t;</span>
<span class="s1">rd_kafka_event_type_t rd_kafka_event_type(const rd_kafka_event_t *rkev);</span>
<span class="s1">const char *rd_kafka_event_name(const rd_kafka_event_t *rkev);</span>
<span class="s1">void rd_kafka_event_destroy(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_message_t *rd_kafka_event_message_next(rd_kafka_event_t *rkev);</span>
<span class="s1">size_t rd_kafka_event_message_array(rd_kafka_event_t *rkev, const rd_kafka_message_t **rkmessages, size_t size);</span>
<span class="s1">size_t rd_kafka_event_message_count(rd_kafka_event_t *rkev);</span>
<span class="s1">const char *rd_kafka_event_config_string(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_event_error(rd_kafka_event_t *rkev);</span>
<span class="s1">const char *rd_kafka_event_error_string(rd_kafka_event_t *rkev);</span>
<span class="s1">int rd_kafka_event_error_is_fatal(rd_kafka_event_t *rkev);</span>
<span class="s1">void *rd_kafka_event_opaque(rd_kafka_event_t *rkev);</span>
<span class="s1">int rd_kafka_event_log(rd_kafka_event_t *rkev, const char **fac, const char **str, int *level);</span>
<span class="s1">int rd_kafka_event_debug_contexts(rd_kafka_event_t *rkev, char *dst, size_t dstsize);</span>
<span class="s1">const char *rd_kafka_event_stats(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_event_topic_partition_list(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_event_topic_partition(rd_kafka_event_t *rkev);</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_CreateTopics_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DeleteTopics_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_CreateAcls_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DescribeAcls_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DeleteAcls_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_CreatePartitions_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_AlterConfigs_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DescribeConfigs_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DeleteRecords_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DeleteGroups_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DeleteConsumerGroupOffsets_result_t;</span>
<span class="s1">const rd_kafka_CreateTopics_result_t *rd_kafka_event_CreateTopics_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DeleteTopics_result_t *rd_kafka_event_DeleteTopics_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_CreatePartitions_result_t *rd_kafka_event_CreatePartitions_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_AlterConfigs_result_t *rd_kafka_event_AlterConfigs_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DescribeConfigs_result_t *rd_kafka_event_DescribeConfigs_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DeleteRecords_result_t *rd_kafka_event_DeleteRecords_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DeleteGroups_result_t *rd_kafka_event_DeleteGroups_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DeleteConsumerGroupOffsets_result_t *rd_kafka_event_DeleteConsumerGroupOffsets_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_CreateAcls_result_t *rd_kafka_event_CreateAcls_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DescribeAcls_result_t *rd_kafka_event_DescribeAcls_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DeleteAcls_result_t *rd_kafka_event_DeleteAcls_result(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_event_t *rd_kafka_queue_poll(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">int rd_kafka_queue_poll_callback(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_plugin_f_conf_init_t)(rd_kafka_conf_t *conf, void **plug_opaquep, char *errstr, size_t errstr_size);</span>
<span class="s1">typedef rd_kafka_conf_res_t (rd_kafka_interceptor_f_on_conf_set_t)(rd_kafka_conf_t *conf, const char *name, const char *val, char *errstr, size_t errstr_size, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_dup_t)(rd_kafka_conf_t *new_conf, const rd_kafka_conf_t *old_conf, size_t filter_cnt, const char **filter, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_destroy_t)(void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_new_t)(rd_kafka_t *rk, const rd_kafka_conf_t *conf, void *ic_opaque, char *errstr, size_t errstr_size);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_destroy_t)(rd_kafka_t *rk, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_send_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_acknowledgement_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_consume_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_commit_t)(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_resp_err_t err, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_request_sent_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_response_received_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, int64_t rtt, rd_kafka_resp_err_t err, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_start_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_exit_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_set(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_set_t *on_conf_set, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_dup(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_dup_t *on_conf_dup, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_destroy(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_destroy_t *on_conf_destroy, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_new(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_new_t *on_new, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_destroy(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_destroy_t *on_destroy, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_send(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_send_t *on_send, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_acknowledgement(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_acknowledgement_t *on_acknowledgement, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_consume(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_consume_t *on_consume, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_commit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_commit_t *on_commit, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_request_sent(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_request_sent_t *on_request_sent, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_response_received(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_response_received_t *on_response_received, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_start(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_start_t *on_thread_start, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_exit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_exit_t *on_thread_exit, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_topic_result_error(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">const char *rd_kafka_topic_result_error_string(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">const char *rd_kafka_topic_result_name(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">const rd_kafka_error_t *rd_kafka_group_result_error(const rd_kafka_group_result_t *groupres);</span>
<span class="s1">const char *rd_kafka_group_result_name(const rd_kafka_group_result_t *groupres);</span>
<span class="s1">const rd_kafka_topic_partition_list_t *rd_kafka_group_result_partitions(const rd_kafka_group_result_t *groupres);</span>
<span class="s1">typedef enum rd_kafka_admin_op_t {</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_ANY = 0,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_CREATETOPICS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DELETETOPICS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_CREATEPARTITIONS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_ALTERCONFIGS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DESCRIBECONFIGS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DELETERECORDS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DELETEGROUPS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DELETECONSUMERGROUPOFFSETS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_CREATEACLS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DESCRIBEACLS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DELETEACLS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP__CNT,</span>
<span class="s1">} rd_kafka_admin_op_t;</span>
<span class="s1">typedef struct rd_kafka_AdminOptions_s rd_kafka_AdminOptions_t;</span>
<span class="s1">rd_kafka_AdminOptions_t *rd_kafka_AdminOptions_new(rd_kafka_t *rk, rd_kafka_admin_op_t for_api);</span>
<span class="s1">void rd_kafka_AdminOptions_destroy(rd_kafka_AdminOptions_t *options);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_request_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_operation_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_validate_only(rd_kafka_AdminOptions_t *options, int true_or_false, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_broker(rd_kafka_AdminOptions_t *options, int32_t broker_id, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_AdminOptions_set_opaque(rd_kafka_AdminOptions_t *options, void *ev_opaque);</span>
<span class="s1">typedef struct rd_kafka_NewTopic_s rd_kafka_NewTopic_t;</span>
<span class="s1">rd_kafka_NewTopic_t *rd_kafka_NewTopic_new(const char *topic, int num_partitions, int replication_factor, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_NewTopic_destroy(rd_kafka_NewTopic_t *new_topic);</span>
<span class="s1">void rd_kafka_NewTopic_destroy_array(rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewTopic_set_replica_assignment(rd_kafka_NewTopic_t *new_topic, int32_t partition, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewTopic_set_config(rd_kafka_NewTopic_t *new_topic, const char *name, const char *value);</span>
<span class="s1">void rd_kafka_CreateTopics(rd_kafka_t *rk, rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_CreateTopics_result_topics(const rd_kafka_CreateTopics_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_DeleteTopic_s rd_kafka_DeleteTopic_t;</span>
<span class="s1">rd_kafka_DeleteTopic_t *rd_kafka_DeleteTopic_new(const char *topic);</span>
<span class="s1">void rd_kafka_DeleteTopic_destroy(rd_kafka_DeleteTopic_t *del_topic);</span>
<span class="s1">void rd_kafka_DeleteTopic_destroy_array(rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt);</span>
<span class="s1">void rd_kafka_DeleteTopics(rd_kafka_t *rk, rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_DeleteTopics_result_topics(const rd_kafka_DeleteTopics_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_NewPartitions_s rd_kafka_NewPartitions_t;</span>
<span class="s1">rd_kafka_NewPartitions_t *rd_kafka_NewPartitions_new(const char *topic, size_t new_total_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_NewPartitions_destroy(rd_kafka_NewPartitions_t *new_parts);</span>
<span class="s1">void rd_kafka_NewPartitions_destroy_array(rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewPartitions_set_replica_assignment(rd_kafka_NewPartitions_t *new_parts, int32_t new_partition_idx, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_CreatePartitions(rd_kafka_t *rk, rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_CreatePartitions_result_topics(const rd_kafka_CreatePartitions_result_t *result, size_t *cntp);</span>
<span class="s1">typedef enum rd_kafka_ConfigSource_t {</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_UNKNOWN_CONFIG = 0,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_TOPIC_CONFIG = 1,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_BROKER_CONFIG = 2,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_DEFAULT_BROKER_CONFIG = 3,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_STATIC_BROKER_CONFIG = 4,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DEFAULT_CONFIG = 5,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE__CNT,</span>
<span class="s1">} rd_kafka_ConfigSource_t;</span>
<span class="s1">const char *rd_kafka_ConfigSource_name(rd_kafka_ConfigSource_t confsource);</span>
<span class="s1">typedef struct rd_kafka_ConfigEntry_s rd_kafka_ConfigEntry_t;</span>
<span class="s1">const char *rd_kafka_ConfigEntry_name(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">const char *rd_kafka_ConfigEntry_value(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">rd_kafka_ConfigSource_t rd_kafka_ConfigEntry_source(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_read_only(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_default(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_sensitive(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_synonym(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">const rd_kafka_ConfigEntry_t **rd_kafka_ConfigEntry_synonyms(const rd_kafka_ConfigEntry_t *entry, size_t *cntp);</span>
<span class="s1">typedef enum rd_kafka_ResourceType_t {</span>
<span class="s1">  RD_KAFKA_RESOURCE_UNKNOWN = 0,</span>
<span class="s1">  RD_KAFKA_RESOURCE_ANY = 1,</span>
<span class="s1">  RD_KAFKA_RESOURCE_TOPIC = 2,</span>
<span class="s1">  RD_KAFKA_RESOURCE_GROUP = 3,</span>
<span class="s1">  RD_KAFKA_RESOURCE_BROKER = 4,</span>
<span class="s1">  RD_KAFKA_RESOURCE__CNT,</span>
<span class="s1">} rd_kafka_ResourceType_t;</span>
<span class="s1">typedef enum rd_kafka_ResourcePatternType_t {</span>
<span class="s1">  RD_KAFKA_RESOURCE_PATTERN_UNKNOWN = 0,</span>
<span class="s1">  RD_KAFKA_RESOURCE_PATTERN_ANY = 1,</span>
<span class="s1">  RD_KAFKA_RESOURCE_PATTERN_MATCH = 2,</span>
<span class="s1">  RD_KAFKA_RESOURCE_PATTERN_LITERAL = 3,</span>
<span class="s1">  RD_KAFKA_RESOURCE_PATTERN_PREFIXED = 4,</span>
<span class="s1">  RD_KAFKA_RESOURCE_PATTERN_TYPE__CNT,</span>
<span class="s1">} rd_kafka_ResourcePatternType_t;</span>
<span class="s1">const char *rd_kafka_ResourcePatternType_name(rd_kafka_ResourcePatternType_t resource_pattern_type);</span>
<span class="s1">const char *rd_kafka_ResourceType_name(rd_kafka_ResourceType_t restype);</span>
<span class="s1">typedef struct rd_kafka_ConfigResource_s rd_kafka_ConfigResource_t;</span>
<span class="s1">rd_kafka_ConfigResource_t *rd_kafka_ConfigResource_new(rd_kafka_ResourceType_t restype, const char *resname);</span>
<span class="s1">void rd_kafka_ConfigResource_destroy(rd_kafka_ConfigResource_t *config);</span>
<span class="s1">void rd_kafka_ConfigResource_destroy_array(rd_kafka_ConfigResource_t **config, size_t config_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_ConfigResource_set_config(rd_kafka_ConfigResource_t *config, const char *name, const char *value);</span>
<span class="s1">const rd_kafka_ConfigEntry_t **rd_kafka_ConfigResource_configs(const rd_kafka_ConfigResource_t *config, size_t *cntp);</span>
<span class="s1">rd_kafka_ResourceType_t rd_kafka_ConfigResource_type(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">const char *rd_kafka_ConfigResource_name(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_ConfigResource_error(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">const char *rd_kafka_ConfigResource_error_string(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">void rd_kafka_AlterConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_ConfigResource_t **rd_kafka_AlterConfigs_result_resources(const rd_kafka_AlterConfigs_result_t *result, size_t *cntp);</span>
<span class="s1">void rd_kafka_DescribeConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_ConfigResource_t **rd_kafka_DescribeConfigs_result_resources(const rd_kafka_DescribeConfigs_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_DeleteRecords_s rd_kafka_DeleteRecords_t;</span>
<span class="s1">rd_kafka_DeleteRecords_t *rd_kafka_DeleteRecords_new(const rd_kafka_topic_partition_list_t *before_offsets);</span>
<span class="s1">void rd_kafka_DeleteRecords_destroy(rd_kafka_DeleteRecords_t *del_records);</span>
<span class="s1">void rd_kafka_DeleteRecords_destroy_array(rd_kafka_DeleteRecords_t **del_records, size_t del_record_cnt);</span>
<span class="s1">void rd_kafka_DeleteRecords(rd_kafka_t *rk, rd_kafka_DeleteRecords_t **del_records, size_t del_record_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_partition_list_t *rd_kafka_DeleteRecords_result_offsets(const rd_kafka_DeleteRecords_result_t *result);</span>
<span class="s1">typedef struct rd_kafka_DeleteGroup_s rd_kafka_DeleteGroup_t;</span>
<span class="s1">rd_kafka_DeleteGroup_t *rd_kafka_DeleteGroup_new(const char *group);</span>
<span class="s1">void rd_kafka_DeleteGroup_destroy(rd_kafka_DeleteGroup_t *del_group);</span>
<span class="s1">void rd_kafka_DeleteGroup_destroy_array(rd_kafka_DeleteGroup_t **del_groups, size_t del_group_cnt);</span>
<span class="s1">void rd_kafka_DeleteGroups(rd_kafka_t *rk, rd_kafka_DeleteGroup_t **del_groups, size_t del_group_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_group_result_t **rd_kafka_DeleteGroups_result_groups(const rd_kafka_DeleteGroups_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_DeleteConsumerGroupOffsets_s rd_kafka_DeleteConsumerGroupOffsets_t;</span>
<span class="s1">rd_kafka_DeleteConsumerGroupOffsets_t *rd_kafka_DeleteConsumerGroupOffsets_new(const char *group, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">void rd_kafka_DeleteConsumerGroupOffsets_destroy(rd_kafka_DeleteConsumerGroupOffsets_t *del_grpoffsets);</span>
<span class="s1">void rd_kafka_DeleteConsumerGroupOffsets_destroy_array(rd_kafka_DeleteConsumerGroupOffsets_t **del_grpoffsets, size_t del_grpoffset_cnt);</span>
<span class="s1">void rd_kafka_DeleteConsumerGroupOffsets(rd_kafka_t *rk, rd_kafka_DeleteConsumerGroupOffsets_t **del_grpoffsets, size_t del_grpoffsets_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_group_result_t **rd_kafka_DeleteConsumerGroupOffsets_result_groups(const rd_kafka_DeleteConsumerGroupOffsets_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_AclBinding_s rd_kafka_AclBinding_t;</span>
<span class="s1">typedef rd_kafka_AclBinding_t rd_kafka_AclBindingFilter_t;</span>
<span class="s1">const rd_kafka_error_t *rd_kafka_acl_result_error(const rd_kafka_acl_result_t *aclres);</span>
<span class="s1">typedef enum rd_kafka_AclOperation_t {</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_UNKNOWN = 0,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_ANY = 1,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_ALL = 2,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_READ = 3,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_WRITE = 4,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_CREATE = 5,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_DELETE = 6,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_ALTER = 7,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_DESCRIBE = 8,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_CLUSTER_ACTION = 9,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_DESCRIBE_CONFIGS = 10,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_ALTER_CONFIGS = 11,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_IDEMPOTENT_WRITE = 12,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION__CNT,</span>
<span class="s1">} rd_kafka_AclOperation_t;</span>
<span class="s1">const char *rd_kafka_AclOperation_name(rd_kafka_AclOperation_t acl_operation);</span>
<span class="s1">typedef enum rd_kafka_AclPermissionType_t {</span>
<span class="s1">  RD_KAFKA_ACL_PERMISSION_TYPE_UNKNOWN = 0,</span>
<span class="s1">  RD_KAFKA_ACL_PERMISSION_TYPE_ANY = 1,</span>
<span class="s1">  RD_KAFKA_ACL_PERMISSION_TYPE_DENY = 2,</span>
<span class="s1">  RD_KAFKA_ACL_PERMISSION_TYPE_ALLOW = 3,</span>
<span class="s1">  RD_KAFKA_ACL_PERMISSION_TYPE__CNT,</span>
<span class="s1">} rd_kafka_AclPermissionType_t;</span>
<span class="s1">const char *rd_kafka_AclPermissionType_name(rd_kafka_AclPermissionType_t acl_permission_type);</span>
<span class="s1">rd_kafka_AclBinding_t *rd_kafka_AclBinding_new(rd_kafka_ResourceType_t restype, const char *name, rd_kafka_ResourcePatternType_t resource_pattern_type, const char *principal, const char *host, rd_kafka_AclOperation_t operation, rd_kafka_AclPermissionType_t permission_type, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_AclBindingFilter_t *rd_kafka_AclBindingFilter_new(rd_kafka_ResourceType_t restype, const char *name, rd_kafka_ResourcePatternType_t resource_pattern_type, const char *principal, const char *host, rd_kafka_AclOperation_t operation, rd_kafka_AclPermissionType_t permission_type, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_ResourceType_t rd_kafka_AclBinding_restype(const rd_kafka_AclBinding_t *acl);</span>
<span class="s1">const char *rd_kafka_AclBinding_name(const rd_kafka_AclBinding_t *acl);</span>
<span class="s1">const char *rd_kafka_AclBinding_principal(const rd_kafka_AclBinding_t *acl);</span>
<span class="s1">const char *rd_kafka_AclBinding_host(const rd_kafka_AclBinding_t *acl);</span>
<span class="s1">rd_kafka_AclOperation_t rd_kafka_AclBinding_operation(const rd_kafka_AclBinding_t *acl);</span>
<span class="s1">rd_kafka_AclPermissionType_t rd_kafka_AclBinding_permission_type(const rd_kafka_AclBinding_t *acl);</span>
<span class="s1">rd_kafka_ResourcePatternType_t rd_kafka_AclBinding_resource_pattern_type(const rd_kafka_AclBinding_t *acl);</span>
<span class="s1">const rd_kafka_error_t *rd_kafka_AclBinding_error(const rd_kafka_AclBinding_t *acl);</span>
<span class="s1">void rd_kafka_AclBinding_destroy(rd_kafka_AclBinding_t *acl_binding);</span>
<span class="s1">void rd_kafka_AclBinding_destroy_array(rd_kafka_AclBinding_t **acl_bindings, size_t acl_bindings_cnt);</span>
<span class="s1">const rd_kafka_acl_result_t **rd_kafka_CreateAcls_result_acls(const rd_kafka_CreateAcls_result_t *result, size_t *cntp);</span>
<span class="s1">void rd_kafka_CreateAcls(rd_kafka_t *rk, rd_kafka_AclBinding_t **new_acls, size_t new_acls_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_AclBinding_t **rd_kafka_DescribeAcls_result_acls(const rd_kafka_DescribeAcls_result_t *result, size_t *cntp);</span>
<span class="s1">void rd_kafka_DescribeAcls(rd_kafka_t *rk, rd_kafka_AclBindingFilter_t *acl_filter, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">typedef struct rd_kafka_DeleteAcls_result_response_s rd_kafka_DeleteAcls_result_response_t;</span>
<span class="s1">const rd_kafka_DeleteAcls_result_response_t **rd_kafka_DeleteAcls_result_responses(const rd_kafka_DeleteAcls_result_t *result, size_t *cntp);</span>
<span class="s1">const rd_kafka_error_t *rd_kafka_DeleteAcls_result_response_error(const rd_kafka_DeleteAcls_result_response_t *result_response);</span>
<span class="s1">const rd_kafka_AclBinding_t **rd_kafka_DeleteAcls_result_response_matching_acls(const rd_kafka_DeleteAcls_result_response_t *result_response, size_t *matching_acls_cntp);</span>
<span class="s1">void rd_kafka_DeleteAcls(rd_kafka_t *rk, rd_kafka_AclBindingFilter_t **del_acls, size_t del_acls_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token(rd_kafka_t *rk, const char *token_value, int64_t md_lifetime_ms, const char *md_principal_name, const char **extensions, size_t extension_size, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token_failure(rd_kafka_t *rk, const char *errstr);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_init_transactions(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_begin_transaction(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_send_offsets_to_transaction(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, const rd_kafka_consumer_group_metadata_t *cgmetadata, int timeout_ms);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_commit_transaction(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_abort_transaction(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">typedef struct rd_kafka_mock_cluster_s rd_kafka_mock_cluster_t;</span>
<span class="s1">rd_kafka_mock_cluster_t *rd_kafka_mock_cluster_new(rd_kafka_t *rk, int broker_cnt);</span>
<span class="s1">void rd_kafka_mock_cluster_destroy(rd_kafka_mock_cluster_t *mcluster);</span>
<span class="s1">rd_kafka_t *rd_kafka_mock_cluster_handle(const rd_kafka_mock_cluster_t *mcluster);</span>
<span class="s1">rd_kafka_mock_cluster_t *rd_kafka_handle_mock_cluster(const rd_kafka_t *rk);</span>
<span class="s1">const char *rd_kafka_mock_cluster_bootstraps(const rd_kafka_mock_cluster_t *mcluster);</span>
<span class="s1">void rd_kafka_mock_clear_request_errors(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey);</span>
<span class="s1">void rd_kafka_mock_push_request_errors(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, size_t cnt, ...);</span>
<span class="s1">void rd_kafka_mock_push_request_errors_array(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, size_t cnt, const rd_kafka_resp_err_t *errors);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_push_request_error_rtts(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int16_t ApiKey, size_t cnt, ...);</span>
<span class="s1">void rd_kafka_mock_topic_set_error(rd_kafka_mock_cluster_t *mcluster, const char *topic, rd_kafka_resp_err_t err);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_topic_create(rd_kafka_mock_cluster_t *mcluster, const char *topic, int partition_cnt, int replication_factor);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_partition_set_leader(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_partition_set_follower(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_partition_set_follower_wmarks(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int64_t lo, int64_t hi);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_set_down(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_set_up(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_set_rtt(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int rtt_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_set_rack(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, const char *rack);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_coordinator_set(rd_kafka_mock_cluster_t *mcluster, const char *key_type, const char *key, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_set_apiversion(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, int16_t MinVersion, int16_t MaxVersion);</span>
<span class="s1">&#39;</span>
</code></pre></div>
rdkafka.h, rdkafka_mock.h</p>
<h3 id="rd_kafka_version_20">RD_KAFKA_VERSION<a class="headerlink" href="#rd_kafka_version_20" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_VERSION</span> <span class="o">=</span> <span class="mi">17367551</span>
</code></pre></div>
<p>librdkafka version </p>
<p>Interpreted as hex <code>MM.mm.rr.xx</code>:</p>
<ul>
<li>MM = Major</li>
<li>mm = minor</li>
<li>rr = revision</li>
<li>xx = pre-release id (0xff is the final release)</li>
</ul>
<p>E.g.: <code>0x000801ff</code> = 0.8.1</p>
<dl class="section remark"><dt>Remarks</dt><dd>This value should only be used during compile time, for runtime checks of version use rd_kafka_version() </dd></dl>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_unsupported_compression_type_20">RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE<a class="headerlink" href="#rd_kafka_resp_err_unsupported_compression_type_20" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE</span> <span class="o">=</span> <span class="mi">76</span>
</code></pre></div>
<p>Unsupported compression type </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_end_all_20">RD_KAFKA_RESP_ERR_END_ALL<a class="headerlink" href="#rd_kafka_resp_err_end_all_20" title="Permanent link">&para;</a></h3>
<p><div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_END_ALL</span> <span class="o">=</span> <span class="mi">98</span>
</code></pre></div>
enum rd_kafka_resp_err_t</p>
<h3 id="rd_kafka_admin_op__cnt_20">RD_KAFKA_ADMIN_OP__CNT<a class="headerlink" href="#rd_kafka_admin_op__cnt_20" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_ADMIN_OP__CNT</span> <span class="o">=</span> <span class="mi">12</span>
</code></pre></div>
<p>Number of ops defined </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe </a></li>
</ul>
</div>
<h3 id="rd_kafka_resource__cnt_20">RD_KAFKA_RESOURCE__CNT<a class="headerlink" href="#rd_kafka_resource__cnt_20" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESOURCE__CNT</span> <span class="o">=</span> <span class="mi">5</span>
</code></pre></div>
<p>Number of resource types defined </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#acca83a66d7783ff7683ed2691cc907c9"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#acca83a66d7783ff7683ed2691cc907c9 </a></li>
</ul>
</div>
<h3 id="rd_kafka_cdef_20">RD_KAFKA_CDEF<a class="headerlink" href="#rd_kafka_cdef_20" title="Permanent link">&para;</a></h3>
<p><div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_CDEF</span> <span class="o">=</span> <span class="s1">&#39;typedef long int ssize_t;</span>
<span class="s1">typedef struct _IO_FILE FILE;</span>
<span class="s1">typedef long int mode_t;</span>
<span class="s1">typedef signed int int16_t;</span>
<span class="s1">typedef unsigned int uint16_t;</span>
<span class="s1">typedef signed int int32_t;</span>
<span class="s1">typedef signed long int int64_t;</span>
<span class="s1">int rd_kafka_version(void);</span>
<span class="s1">const char *rd_kafka_version_str(void);</span>
<span class="s1">typedef enum rd_kafka_type_t {</span>
<span class="s1">  RD_KAFKA_PRODUCER,</span>
<span class="s1">  RD_KAFKA_CONSUMER,</span>
<span class="s1">} rd_kafka_type_t;</span>
<span class="s1">typedef enum rd_kafka_timestamp_type_t {</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_NOT_AVAILABLE,</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_CREATE_TIME,</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_LOG_APPEND_TIME,</span>
<span class="s1">} rd_kafka_timestamp_type_t;</span>
<span class="s1">const char *rd_kafka_get_debug_contexts(void);</span>
<span class="s1">typedef struct rd_kafka_s rd_kafka_t;</span>
<span class="s1">typedef struct rd_kafka_topic_s rd_kafka_topic_t;</span>
<span class="s1">typedef struct rd_kafka_conf_s rd_kafka_conf_t;</span>
<span class="s1">typedef struct rd_kafka_topic_conf_s rd_kafka_topic_conf_t;</span>
<span class="s1">typedef struct rd_kafka_queue_s rd_kafka_queue_t;</span>
<span class="s1">typedef struct rd_kafka_op_s rd_kafka_event_t;</span>
<span class="s1">typedef struct rd_kafka_topic_result_s rd_kafka_topic_result_t;</span>
<span class="s1">typedef struct rd_kafka_consumer_group_metadata_s rd_kafka_consumer_group_metadata_t;</span>
<span class="s1">typedef struct rd_kafka_error_s {</span>
<span class="s1">  unsigned int code;</span>
<span class="s1">  char *errstr;</span>
<span class="s1">  unsigned char fatal;</span>
<span class="s1">  unsigned char retriable;</span>
<span class="s1">  unsigned char txn_requires_abort;</span>
<span class="s1">} rd_kafka_error_t;</span>
<span class="s1">typedef struct rd_kafka_headers_s rd_kafka_headers_t;</span>
<span class="s1">typedef struct rd_kafka_group_result_s rd_kafka_group_result_t;</span>
<span class="s1">typedef struct rd_kafka_acl_result_s rd_kafka_acl_result_t;</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BEGIN = (- 200),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BAD_MSG = (- 199),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BAD_COMPRESSION = (- 198),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__DESTROY = (- 197),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FAIL = (- 196),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TRANSPORT = (- 195),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__CRIT_SYS_RESOURCE = (- 194),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__RESOLVE = (- 193),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__MSG_TIMED_OUT = (- 192),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PARTITION_EOF = (- 191),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION = (- 190),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FS = (- 189),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC = (- 188),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ALL_BROKERS_DOWN = (- 187),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INVALID_ARG = (- 186),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TIMED_OUT = (- 185),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__QUEUE_FULL = (- 184),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ISR_INSUFF = (- 183),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NODE_UPDATE = (- 182),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__SSL = (- 181),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__WAIT_COORD = (- 180),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_GROUP = (- 179),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__IN_PROGRESS = (- 178),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PREV_IN_PROGRESS = (- 177),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__EXISTING_SUBSCRIPTION = (- 176),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS = (- 175),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS = (- 174),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__CONFLICT = (- 173),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__STATE = (- 172),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_PROTOCOL = (- 171),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED = (- 170),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__AUTHENTICATION = (- 169),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NO_OFFSET = (- 168),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__OUTDATED = (- 167),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TIMED_OUT_QUEUE = (- 166),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNSUPPORTED_FEATURE = (- 165),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__WAIT_CACHE = (- 164),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INTR = (- 163),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__KEY_SERIALIZATION = (- 162),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__VALUE_SERIALIZATION = (- 161),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__KEY_DESERIALIZATION = (- 160),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__VALUE_DESERIALIZATION = (- 159),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PARTIAL = (- 158),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__READ_ONLY = (- 157),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOENT = (- 156),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNDERFLOW = (- 155),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INVALID_TYPE = (- 154),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__RETRY = (- 153),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PURGE_QUEUE = (- 152),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PURGE_INFLIGHT = (- 151),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FATAL = (- 150),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INCONSISTENT = (- 149),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__GAPLESS_GUARANTEE = (- 148),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__MAX_POLL_EXCEEDED = (- 147),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_BROKER = (- 146),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOT_CONFIGURED = (- 145),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FENCED = (- 144),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__APPLICATION = (- 143),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ASSIGNMENT_LOST = (- 142),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOOP = (- 141),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__AUTO_OFFSET_RESET = (- 140),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__END = (- 100),</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN = (- 1),</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NO_ERROR = 0,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_OUT_OF_RANGE = 1,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_MSG = 2,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART = 3,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_MSG_SIZE = 4,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE = 5,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_LEADER_FOR_PARTITION = 6,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REQUEST_TIMED_OUT = 7,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_BROKER_NOT_AVAILABLE = 8,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REPLICA_NOT_AVAILABLE = 9,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE = 10,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_STALE_CTRL_EPOCH = 11,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_METADATA_TOO_LARGE = 12,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NETWORK_EXCEPTION = 13,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_COORDINATOR_LOAD_IN_PROGRESS = 14,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_COORDINATOR_NOT_AVAILABLE = 15,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_COORDINATOR = 16,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_EXCEPTION = 17,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_RECORD_LIST_TOO_LARGE = 18,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS = 19,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS_AFTER_APPEND = 20,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REQUIRED_ACKS = 21,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ILLEGAL_GENERATION = 22,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INCONSISTENT_GROUP_PROTOCOL = 23,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_GROUP_ID = 24,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_MEMBER_ID = 25,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_SESSION_TIMEOUT = 26,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REBALANCE_IN_PROGRESS = 27,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_COMMIT_OFFSET_SIZE = 28,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_AUTHORIZATION_FAILED = 29,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_AUTHORIZATION_FAILED = 30,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_CLUSTER_AUTHORIZATION_FAILED = 31,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TIMESTAMP = 32,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_SASL_MECHANISM = 33,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ILLEGAL_SASL_STATE = 34,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_VERSION = 35,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_ALREADY_EXISTS = 36,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PARTITIONS = 37,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REPLICATION_FACTOR = 38,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REPLICA_ASSIGNMENT = 39,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_CONFIG = 40,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_CONTROLLER = 41,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REQUEST = 42,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_FOR_MESSAGE_FORMAT = 43,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_POLICY_VIOLATION = 44,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OUT_OF_ORDER_SEQUENCE_NUMBER = 45,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DUPLICATE_SEQUENCE_NUMBER = 46,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_EPOCH = 47,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TXN_STATE = 48,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_ID_MAPPING = 49,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TRANSACTION_TIMEOUT = 50,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_CONCURRENT_TRANSACTIONS = 51,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TRANSACTION_COORDINATOR_FENCED = 52,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TRANSACTIONAL_ID_AUTHORIZATION_FAILED = 53,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_SECURITY_DISABLED = 54,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OPERATION_NOT_ATTEMPTED = 55,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_KAFKA_STORAGE_ERROR = 56,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LOG_DIR_NOT_FOUND = 57,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_SASL_AUTHENTICATION_FAILED = 58,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_PRODUCER_ID = 59,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REASSIGNMENT_IN_PROGRESS = 60,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTH_DISABLED = 61,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_NOT_FOUND = 62,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_OWNER_MISMATCH = 63,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_REQUEST_NOT_ALLOWED = 64,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTHORIZATION_FAILED = 65,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_EXPIRED = 66,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRINCIPAL_TYPE = 67,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NON_EMPTY_GROUP = 68,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_ID_NOT_FOUND = 69,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FETCH_SESSION_ID_NOT_FOUND = 70,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_FETCH_SESSION_EPOCH = 71,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LISTENER_NOT_FOUND = 72,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_DELETION_DISABLED = 73,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FENCED_LEADER_EPOCH = 74,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_LEADER_EPOCH = 75,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_STALE_BROKER_EPOCH = 77,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_NOT_AVAILABLE = 78,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_MEMBER_ID_REQUIRED = 79,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_PREFERRED_LEADER_NOT_AVAILABLE = 80,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_MAX_SIZE_REACHED = 81,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FENCED_INSTANCE_ID = 82,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ELIGIBLE_LEADERS_NOT_AVAILABLE = 83,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ELECTION_NOT_NEEDED = 84,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NO_REASSIGNMENT_IN_PROGRESS = 85,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_SUBSCRIBED_TO_TOPIC = 86,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_RECORD = 87,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSTABLE_OFFSET_COMMIT = 88,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_THROTTLING_QUOTA_EXCEEDED = 89,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_PRODUCER_FENCED = 90,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_RESOURCE_NOT_FOUND = 91,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DUPLICATE_RESOURCE = 92,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNACCEPTABLE_CREDENTIAL = 93,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INCONSISTENT_VOTER_SET = 94,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_UPDATE_VERSION = 95,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FEATURE_UPDATE_FAILED = 96,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_PRINCIPAL_DESERIALIZATION_FAILURE = 97,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_END_ALL,</span>
<span class="s1">} rd_kafka_resp_err_t;</span>
<span class="s1">struct rd_kafka_err_desc {</span>
<span class="s1">  rd_kafka_resp_err_t code;</span>
<span class="s1">  char *name;</span>
<span class="s1">  char *desc;</span>
<span class="s1">};</span>
<span class="s1">void rd_kafka_get_err_descs(const struct rd_kafka_err_desc **errdescs, size_t *cntp);</span>
<span class="s1">const char *rd_kafka_err2str(rd_kafka_resp_err_t err);</span>
<span class="s1">const char *rd_kafka_err2name(rd_kafka_resp_err_t err);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_last_error(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_errno2err(int errnox);</span>
<span class="s1">int rd_kafka_errno(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_fatal_error(rd_kafka_t *rk, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_test_fatal_error(rd_kafka_t *rk, rd_kafka_resp_err_t err, const char *reason);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_error_code(const rd_kafka_error_t *error);</span>
<span class="s1">const char *rd_kafka_error_name(const rd_kafka_error_t *error);</span>
<span class="s1">const char *rd_kafka_error_string(const rd_kafka_error_t *error);</span>
<span class="s1">int rd_kafka_error_is_fatal(const rd_kafka_error_t *error);</span>
<span class="s1">int rd_kafka_error_is_retriable(const rd_kafka_error_t *error);</span>
<span class="s1">int rd_kafka_error_txn_requires_abort(const rd_kafka_error_t *error);</span>
<span class="s1">void rd_kafka_error_destroy(rd_kafka_error_t *error);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_error_new(rd_kafka_resp_err_t code, const char *fmt, ...);</span>
<span class="s1">typedef struct rd_kafka_topic_partition_s {</span>
<span class="s1">  char *topic;</span>
<span class="s1">  int32_t partition;</span>
<span class="s1">  int64_t offset;</span>
<span class="s1">  void *metadata;</span>
<span class="s1">  size_t metadata_size;</span>
<span class="s1">  void *opaque;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  void *_private;</span>
<span class="s1">} rd_kafka_topic_partition_t;</span>
<span class="s1">void rd_kafka_topic_partition_destroy(rd_kafka_topic_partition_t *rktpar);</span>
<span class="s1">typedef struct rd_kafka_topic_partition_list_s {</span>
<span class="s1">  int cnt;</span>
<span class="s1">  int size;</span>
<span class="s1">  rd_kafka_topic_partition_t *elems;</span>
<span class="s1">} rd_kafka_topic_partition_list_t;</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_new(int size);</span>
<span class="s1">void rd_kafka_topic_partition_list_destroy(rd_kafka_topic_partition_list_t *rkparlist);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_add(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">void rd_kafka_topic_partition_list_add_range(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t start, int32_t stop);</span>
<span class="s1">int rd_kafka_topic_partition_list_del(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">int rd_kafka_topic_partition_list_del_by_idx(rd_kafka_topic_partition_list_t *rktparlist, int idx);</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_copy(const rd_kafka_topic_partition_list_t *src);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_topic_partition_list_set_offset(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition, int64_t offset);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_find(const rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">void rd_kafka_topic_partition_list_sort(rd_kafka_topic_partition_list_t *rktparlist, int (*cmp)(const void *a, const void *b, void *cmp_opaque), void *cmp_opaque);</span>
<span class="s1">typedef enum rd_kafka_vtype_t {</span>
<span class="s1">  RD_KAFKA_VTYPE_END,</span>
<span class="s1">  RD_KAFKA_VTYPE_TOPIC,</span>
<span class="s1">  RD_KAFKA_VTYPE_RKT,</span>
<span class="s1">  RD_KAFKA_VTYPE_PARTITION,</span>
<span class="s1">  RD_KAFKA_VTYPE_VALUE,</span>
<span class="s1">  RD_KAFKA_VTYPE_KEY,</span>
<span class="s1">  RD_KAFKA_VTYPE_OPAQUE,</span>
<span class="s1">  RD_KAFKA_VTYPE_MSGFLAGS,</span>
<span class="s1">  RD_KAFKA_VTYPE_TIMESTAMP,</span>
<span class="s1">  RD_KAFKA_VTYPE_HEADER,</span>
<span class="s1">  RD_KAFKA_VTYPE_HEADERS,</span>
<span class="s1">} rd_kafka_vtype_t;</span>
<span class="s1">typedef struct rd_kafka_vu_s {</span>
<span class="s1">  rd_kafka_vtype_t vtype;</span>
<span class="s1">  union {</span>
<span class="s1">    char *cstr;</span>
<span class="s1">    rd_kafka_topic_t *rkt;</span>
<span class="s1">    int i;</span>
<span class="s1">    int32_t i32;</span>
<span class="s1">    int64_t i64;</span>
<span class="s1">    struct {</span>
<span class="s1">      void *ptr;</span>
<span class="s1">      size_t size;</span>
<span class="s1">    } mem;</span>
<span class="s1">    struct {</span>
<span class="s1">      char *name;</span>
<span class="s1">      void *val;</span>
<span class="s1">      ssize_t size;</span>
<span class="s1">    } header;</span>
<span class="s1">    rd_kafka_headers_t *headers;</span>
<span class="s1">    void *ptr;</span>
<span class="s1">    char _pad[64];</span>
<span class="s1">  } u;</span>
<span class="s1">} rd_kafka_vu_t;</span>
<span class="s1">rd_kafka_headers_t *rd_kafka_headers_new(size_t initial_count);</span>
<span class="s1">void rd_kafka_headers_destroy(rd_kafka_headers_t *hdrs);</span>
<span class="s1">rd_kafka_headers_t *rd_kafka_headers_copy(const rd_kafka_headers_t *src);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_add(rd_kafka_headers_t *hdrs, const char *name, ssize_t name_size, const void *value, ssize_t value_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_remove(rd_kafka_headers_t *hdrs, const char *name);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get_last(const rd_kafka_headers_t *hdrs, const char *name, const void **valuep, size_t *sizep);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get(const rd_kafka_headers_t *hdrs, size_t idx, const char *name, const void **valuep, size_t *sizep);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get_all(const rd_kafka_headers_t *hdrs, size_t idx, const char **namep, const void **valuep, size_t *sizep);</span>
<span class="s1">typedef struct rd_kafka_message_s {</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  rd_kafka_topic_t *rkt;</span>
<span class="s1">  int32_t partition;</span>
<span class="s1">  void *payload;</span>
<span class="s1">  size_t len;</span>
<span class="s1">  void *key;</span>
<span class="s1">  size_t key_len;</span>
<span class="s1">  int64_t offset;</span>
<span class="s1">  void *_private;</span>
<span class="s1">} rd_kafka_message_t;</span>
<span class="s1">void rd_kafka_message_destroy(rd_kafka_message_t *rkmessage);</span>
<span class="s1">const char *rd_kafka_message_errstr(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">int64_t rd_kafka_message_timestamp(const rd_kafka_message_t *rkmessage, rd_kafka_timestamp_type_t *tstype);</span>
<span class="s1">int64_t rd_kafka_message_latency(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">int32_t rd_kafka_message_broker_id(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_message_headers(const rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_message_detach_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);</span>
<span class="s1">void rd_kafka_message_set_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t *hdrs);</span>
<span class="s1">size_t rd_kafka_header_cnt(const rd_kafka_headers_t *hdrs);</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_NOT_PERSISTED = 0,</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_POSSIBLY_PERSISTED = 1,</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_PERSISTED = 2,</span>
<span class="s1">} rd_kafka_msg_status_t;</span>
<span class="s1">rd_kafka_msg_status_t rd_kafka_message_status(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_CONF_UNKNOWN = (- 2),</span>
<span class="s1">  RD_KAFKA_CONF_INVALID = (- 1),</span>
<span class="s1">  RD_KAFKA_CONF_OK = 0,</span>
<span class="s1">} rd_kafka_conf_res_t;</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_new(void);</span>
<span class="s1">void rd_kafka_conf_destroy(rd_kafka_conf_t *conf);</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_dup(const rd_kafka_conf_t *conf);</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_dup_filter(const rd_kafka_conf_t *conf, size_t filter_cnt, const char **filter);</span>
<span class="s1">const rd_kafka_conf_t *rd_kafka_conf(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_set(rd_kafka_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_conf_set_events(rd_kafka_conf_t *conf, int events);</span>
<span class="s1">void rd_kafka_conf_set_background_event_cb(rd_kafka_conf_t *conf, void (*event_cb)(rd_kafka_t *rk, rd_kafka_event_t *rkev, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_dr_cb(rd_kafka_conf_t *conf, void (*dr_cb)(rd_kafka_t *rk, void *payload, size_t len, rd_kafka_resp_err_t err, void *opaque, void *msg_opaque));</span>
<span class="s1">void rd_kafka_conf_set_dr_msg_cb(rd_kafka_conf_t *conf, void (*dr_msg_cb)(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_consume_cb(rd_kafka_conf_t *conf, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_rebalance_cb(rd_kafka_conf_t *conf, void (*rebalance_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *partitions, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_offset_commit_cb(rd_kafka_conf_t *conf, void (*offset_commit_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_error_cb(rd_kafka_conf_t *conf, void (*error_cb)(rd_kafka_t *rk, int err, const char *reason, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_throttle_cb(rd_kafka_conf_t *conf, void (*throttle_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int throttle_time_ms, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_log_cb(rd_kafka_conf_t *conf, void (*log_cb)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));</span>
<span class="s1">void rd_kafka_conf_set_stats_cb(rd_kafka_conf_t *conf, int (*stats_cb)(rd_kafka_t *rk, char *json, size_t json_len, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_oauthbearer_token_refresh_cb(rd_kafka_conf_t *conf, void (*oauthbearer_token_refresh_cb)(rd_kafka_t *rk, const char *oauthbearer_config, void *opaque));</span>
<span class="s1">void rd_kafka_conf_enable_sasl_queue(rd_kafka_conf_t *conf, int enable);</span>
<span class="s1">void rd_kafka_conf_set_socket_cb(rd_kafka_conf_t *conf, int (*socket_cb)(int domain, int type, int protocol, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_connect_cb(rd_kafka_conf_t *conf, int (*connect_cb)(int sockfd, const struct sockaddr *addr, int addrlen, const char *id, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_closesocket_cb(rd_kafka_conf_t *conf, int (*closesocket_cb)(int sockfd, void *opaque));</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert_verify_cb(rd_kafka_conf_t *conf, int (*ssl_cert_verify_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int *x509_error, int depth, const char *buf, size_t size, char *errstr, size_t errstr_size, void *opaque));</span>
<span class="s1">typedef enum rd_kafka_cert_type_t {</span>
<span class="s1">  RD_KAFKA_CERT_PUBLIC_KEY,</span>
<span class="s1">  RD_KAFKA_CERT_PRIVATE_KEY,</span>
<span class="s1">  RD_KAFKA_CERT_CA,</span>
<span class="s1">  RD_KAFKA_CERT__CNT,</span>
<span class="s1">} rd_kafka_cert_type_t;</span>
<span class="s1">typedef enum rd_kafka_cert_enc_t {</span>
<span class="s1">  RD_KAFKA_CERT_ENC_PKCS12,</span>
<span class="s1">  RD_KAFKA_CERT_ENC_DER,</span>
<span class="s1">  RD_KAFKA_CERT_ENC_PEM,</span>
<span class="s1">  RD_KAFKA_CERT_ENC__CNT,</span>
<span class="s1">} rd_kafka_cert_enc_t;</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert(rd_kafka_conf_t *conf, rd_kafka_cert_type_t cert_type, rd_kafka_cert_enc_t cert_enc, const void *buffer, size_t size, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_conf_set_engine_callback_data(rd_kafka_conf_t *conf, void *callback_data);</span>
<span class="s1">void rd_kafka_conf_set_opaque(rd_kafka_conf_t *conf, void *opaque);</span>
<span class="s1">void *rd_kafka_opaque(const rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_conf_set_default_topic_conf(rd_kafka_conf_t *conf, rd_kafka_topic_conf_t *tconf);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_conf_get_default_topic_conf(rd_kafka_conf_t *conf);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_get(const rd_kafka_conf_t *conf, const char *name, char *dest, size_t *dest_size);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_topic_conf_get(const rd_kafka_topic_conf_t *conf, const char *name, char *dest, size_t *dest_size);</span>
<span class="s1">const char **rd_kafka_conf_dump(rd_kafka_conf_t *conf, size_t *cntp);</span>
<span class="s1">const char **rd_kafka_topic_conf_dump(rd_kafka_topic_conf_t *conf, size_t *cntp);</span>
<span class="s1">void rd_kafka_conf_dump_free(const char **arr, size_t cnt);</span>
<span class="s1">void rd_kafka_conf_properties_show(FILE *fp);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_topic_conf_new(void);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_topic_conf_dup(const rd_kafka_topic_conf_t *conf);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_default_topic_conf_dup(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_topic_conf_destroy(rd_kafka_topic_conf_t *topic_conf);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_topic_conf_set(rd_kafka_topic_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_topic_conf_set_opaque(rd_kafka_topic_conf_t *conf, void *rkt_opaque);</span>
<span class="s1">void rd_kafka_topic_conf_set_partitioner_cb(rd_kafka_topic_conf_t *topic_conf, int32_t (*partitioner)(const rd_kafka_topic_t *rkt, const void *keydata, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque));</span>
<span class="s1">void rd_kafka_topic_conf_set_msg_order_cmp(rd_kafka_topic_conf_t *topic_conf, int (*msg_order_cmp)(const rd_kafka_message_t *a, const rd_kafka_message_t *b));</span>
<span class="s1">int rd_kafka_topic_partition_available(const rd_kafka_topic_t *rkt, int32_t partition);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_consistent(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_consistent_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_murmur2(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_murmur2_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_fnv1a(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_fnv1a_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">rd_kafka_t *rd_kafka_new(rd_kafka_type_t type, rd_kafka_conf_t *conf, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_destroy(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_destroy_flags(rd_kafka_t *rk, int flags);</span>
<span class="s1">const char *rd_kafka_name(const rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_type_t rd_kafka_type(const rd_kafka_t *rk);</span>
<span class="s1">char *rd_kafka_memberid(const rd_kafka_t *rk);</span>
<span class="s1">char *rd_kafka_clusterid(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">int32_t rd_kafka_controllerid(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_topic_t *rd_kafka_topic_new(rd_kafka_t *rk, const char *topic, rd_kafka_topic_conf_t *conf);</span>
<span class="s1">void rd_kafka_topic_destroy(rd_kafka_topic_t *rkt);</span>
<span class="s1">const char *rd_kafka_topic_name(const rd_kafka_topic_t *rkt);</span>
<span class="s1">void *rd_kafka_topic_opaque(const rd_kafka_topic_t *rkt);</span>
<span class="s1">int rd_kafka_poll(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">void rd_kafka_yield(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_pause_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_resume_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_query_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_get_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offsets_for_times(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets, int timeout_ms);</span>
<span class="s1">void *rd_kafka_mem_calloc(rd_kafka_t *rk, size_t num, size_t size);</span>
<span class="s1">void *rd_kafka_mem_malloc(rd_kafka_t *rk, size_t size);</span>
<span class="s1">void rd_kafka_mem_free(rd_kafka_t *rk, void *ptr);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_new(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_queue_destroy(rd_kafka_queue_t *rkqu);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_main(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_sasl(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_sasl_background_callbacks_enable(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_consumer(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_partition(rd_kafka_t *rk, const char *topic, int32_t partition);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_background(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_queue_forward(rd_kafka_queue_t *src, rd_kafka_queue_t *dst);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_set_log_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu);</span>
<span class="s1">size_t rd_kafka_queue_length(rd_kafka_queue_t *rkqu);</span>
<span class="s1">void rd_kafka_queue_io_event_enable(rd_kafka_queue_t *rkqu, int fd, const void *payload, size_t size);</span>
<span class="s1">void rd_kafka_queue_cb_event_enable(rd_kafka_queue_t *rkqu, void (*event_cb)(rd_kafka_t *rk, void *qev_opaque), void *qev_opaque);</span>
<span class="s1">void rd_kafka_queue_yield(rd_kafka_queue_t *rkqu);</span>
<span class="s1">int rd_kafka_consume_start(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);</span>
<span class="s1">int rd_kafka_consume_start_queue(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, rd_kafka_queue_t *rkqu);</span>
<span class="s1">int rd_kafka_consume_stop(rd_kafka_topic_t *rkt, int32_t partition);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_seek(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, int timeout_ms);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_seek_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consume(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms);</span>
<span class="s1">ssize_t rd_kafka_consume_batch(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);</span>
<span class="s1">int rd_kafka_consume_callback(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consume_queue(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">ssize_t rd_kafka_consume_batch_queue(rd_kafka_queue_t *rkqu, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);</span>
<span class="s1">int rd_kafka_consume_callback_queue(rd_kafka_queue_t *rkqu, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offset_store(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offsets_store(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_subscribe(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *topics);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_unsubscribe(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_subscription(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **topics);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consumer_poll(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_consumer_close(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_consumer_close_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu);</span>
<span class="s1">int rd_kafka_consumer_closed(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_incremental_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_incremental_unassign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">const char *rd_kafka_rebalance_protocol(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_assignment(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **partitions);</span>
<span class="s1">int rd_kafka_assignment_lost(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, int async);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit_message(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, int async);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit_queue(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_queue_t *rkqu, void (*cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *commit_opaque), void *commit_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_committed(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_position(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata_new(const char *group_id);</span>
<span class="s1">rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata_new_with_genid(const char *group_id, int32_t generation_id, const char *member_id, const char *group_instance_id);</span>
<span class="s1">void rd_kafka_consumer_group_metadata_destroy(rd_kafka_consumer_group_metadata_t *);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_consumer_group_metadata_write(const rd_kafka_consumer_group_metadata_t *cgmd, void **bufferp, size_t *sizep);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_consumer_group_metadata_read(rd_kafka_consumer_group_metadata_t **cgmdp, const void *buffer, size_t size);</span>
<span class="s1">int rd_kafka_produce(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, void *payload, size_t len, const void *key, size_t keylen, void *msg_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_producev(rd_kafka_t *rk, ...);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_produceva(rd_kafka_t *rk, const rd_kafka_vu_t *vus, size_t cnt);</span>
<span class="s1">int rd_kafka_produce_batch(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, rd_kafka_message_t *rkmessages, int message_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_flush(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_purge(rd_kafka_t *rk, int purge_flags);</span>
<span class="s1">typedef struct rd_kafka_metadata_broker {</span>
<span class="s1">  int32_t id;</span>
<span class="s1">  char *host;</span>
<span class="s1">  int port;</span>
<span class="s1">} rd_kafka_metadata_broker_t;</span>
<span class="s1">typedef struct rd_kafka_metadata_partition {</span>
<span class="s1">  int32_t id;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  int32_t leader;</span>
<span class="s1">  int replica_cnt;</span>
<span class="s1">  int32_t *replicas;</span>
<span class="s1">  int isr_cnt;</span>
<span class="s1">  int32_t *isrs;</span>
<span class="s1">} rd_kafka_metadata_partition_t;</span>
<span class="s1">typedef struct rd_kafka_metadata_topic {</span>
<span class="s1">  char *topic;</span>
<span class="s1">  int partition_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_partition *partitions;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">} rd_kafka_metadata_topic_t;</span>
<span class="s1">typedef struct rd_kafka_metadata {</span>
<span class="s1">  int broker_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_broker *brokers;</span>
<span class="s1">  int topic_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_topic *topics;</span>
<span class="s1">  int32_t orig_broker_id;</span>
<span class="s1">  char *orig_broker_name;</span>
<span class="s1">} rd_kafka_metadata_t;</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_metadata(rd_kafka_t *rk, int all_topics, rd_kafka_topic_t *only_rkt, const struct rd_kafka_metadata **metadatap, int timeout_ms);</span>
<span class="s1">void rd_kafka_metadata_destroy(const struct rd_kafka_metadata *metadata);</span>
<span class="s1">struct rd_kafka_group_member_info {</span>
<span class="s1">  char *member_id;</span>
<span class="s1">  char *client_id;</span>
<span class="s1">  char *client_host;</span>
<span class="s1">  void *member_metadata;</span>
<span class="s1">  int member_metadata_size;</span>
<span class="s1">  void *member_assignment;</span>
<span class="s1">  int member_assignment_size;</span>
<span class="s1">};</span>
<span class="s1">struct rd_kafka_group_info {</span>
<span class="s1">  struct rd_kafka_metadata_broker broker;</span>
<span class="s1">  char *group;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  char *state;</span>
<span class="s1">  char *protocol_type;</span>
<span class="s1">  char *protocol;</span>
<span class="s1">  struct rd_kafka_group_member_info *members;</span>
<span class="s1">  int member_cnt;</span>
<span class="s1">};</span>
<span class="s1">struct rd_kafka_group_list {</span>
<span class="s1">  struct rd_kafka_group_info *groups;</span>
<span class="s1">  int group_cnt;</span>
<span class="s1">};</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_list_groups(rd_kafka_t *rk, const char *group, const struct rd_kafka_group_list **grplistp, int timeout_ms);</span>
<span class="s1">void rd_kafka_group_list_destroy(const struct rd_kafka_group_list *grplist);</span>
<span class="s1">int rd_kafka_brokers_add(rd_kafka_t *rk, const char *brokerlist);</span>
<span class="s1">void rd_kafka_set_logger(rd_kafka_t *rk, void (*func)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));</span>
<span class="s1">void rd_kafka_set_log_level(rd_kafka_t *rk, int level);</span>
<span class="s1">void rd_kafka_log_print(const rd_kafka_t *rk, int level, const char *fac, const char *buf);</span>
<span class="s1">void rd_kafka_log_syslog(const rd_kafka_t *rk, int level, const char *fac, const char *buf);</span>
<span class="s1">int rd_kafka_outq_len(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_dump(FILE *fp, rd_kafka_t *rk);</span>
<span class="s1">int rd_kafka_thread_cnt(void);</span>
<span class="s1">typedef enum rd_kafka_thread_type_t {</span>
<span class="s1">  RD_KAFKA_THREAD_MAIN,</span>
<span class="s1">  RD_KAFKA_THREAD_BACKGROUND,</span>
<span class="s1">  RD_KAFKA_THREAD_BROKER,</span>
<span class="s1">} rd_kafka_thread_type_t;</span>
<span class="s1">int rd_kafka_wait_destroyed(int timeout_ms);</span>
<span class="s1">int rd_kafka_unittest(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_poll_set_consumer(rd_kafka_t *rk);</span>
<span class="s1">typedef int rd_kafka_event_type_t;</span>
<span class="s1">rd_kafka_event_type_t rd_kafka_event_type(const rd_kafka_event_t *rkev);</span>
<span class="s1">const char *rd_kafka_event_name(const rd_kafka_event_t *rkev);</span>
<span class="s1">void rd_kafka_event_destroy(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_message_t *rd_kafka_event_message_next(rd_kafka_event_t *rkev);</span>
<span class="s1">size_t rd_kafka_event_message_array(rd_kafka_event_t *rkev, const rd_kafka_message_t **rkmessages, size_t size);</span>
<span class="s1">size_t rd_kafka_event_message_count(rd_kafka_event_t *rkev);</span>
<span class="s1">const char *rd_kafka_event_config_string(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_event_error(rd_kafka_event_t *rkev);</span>
<span class="s1">const char *rd_kafka_event_error_string(rd_kafka_event_t *rkev);</span>
<span class="s1">int rd_kafka_event_error_is_fatal(rd_kafka_event_t *rkev);</span>
<span class="s1">void *rd_kafka_event_opaque(rd_kafka_event_t *rkev);</span>
<span class="s1">int rd_kafka_event_log(rd_kafka_event_t *rkev, const char **fac, const char **str, int *level);</span>
<span class="s1">int rd_kafka_event_debug_contexts(rd_kafka_event_t *rkev, char *dst, size_t dstsize);</span>
<span class="s1">const char *rd_kafka_event_stats(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_event_topic_partition_list(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_event_topic_partition(rd_kafka_event_t *rkev);</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_CreateTopics_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DeleteTopics_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_CreateAcls_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DescribeAcls_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DeleteAcls_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_CreatePartitions_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_AlterConfigs_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DescribeConfigs_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DeleteRecords_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DeleteGroups_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DeleteConsumerGroupOffsets_result_t;</span>
<span class="s1">const rd_kafka_CreateTopics_result_t *rd_kafka_event_CreateTopics_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DeleteTopics_result_t *rd_kafka_event_DeleteTopics_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_CreatePartitions_result_t *rd_kafka_event_CreatePartitions_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_AlterConfigs_result_t *rd_kafka_event_AlterConfigs_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DescribeConfigs_result_t *rd_kafka_event_DescribeConfigs_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DeleteRecords_result_t *rd_kafka_event_DeleteRecords_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DeleteGroups_result_t *rd_kafka_event_DeleteGroups_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DeleteConsumerGroupOffsets_result_t *rd_kafka_event_DeleteConsumerGroupOffsets_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_CreateAcls_result_t *rd_kafka_event_CreateAcls_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DescribeAcls_result_t *rd_kafka_event_DescribeAcls_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DeleteAcls_result_t *rd_kafka_event_DeleteAcls_result(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_event_t *rd_kafka_queue_poll(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">int rd_kafka_queue_poll_callback(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_plugin_f_conf_init_t)(rd_kafka_conf_t *conf, void **plug_opaquep, char *errstr, size_t errstr_size);</span>
<span class="s1">typedef rd_kafka_conf_res_t (rd_kafka_interceptor_f_on_conf_set_t)(rd_kafka_conf_t *conf, const char *name, const char *val, char *errstr, size_t errstr_size, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_dup_t)(rd_kafka_conf_t *new_conf, const rd_kafka_conf_t *old_conf, size_t filter_cnt, const char **filter, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_destroy_t)(void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_new_t)(rd_kafka_t *rk, const rd_kafka_conf_t *conf, void *ic_opaque, char *errstr, size_t errstr_size);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_destroy_t)(rd_kafka_t *rk, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_send_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_acknowledgement_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_consume_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_commit_t)(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_resp_err_t err, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_request_sent_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_response_received_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, int64_t rtt, rd_kafka_resp_err_t err, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_start_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_exit_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_set(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_set_t *on_conf_set, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_dup(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_dup_t *on_conf_dup, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_destroy(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_destroy_t *on_conf_destroy, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_new(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_new_t *on_new, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_destroy(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_destroy_t *on_destroy, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_send(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_send_t *on_send, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_acknowledgement(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_acknowledgement_t *on_acknowledgement, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_consume(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_consume_t *on_consume, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_commit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_commit_t *on_commit, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_request_sent(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_request_sent_t *on_request_sent, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_response_received(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_response_received_t *on_response_received, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_start(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_start_t *on_thread_start, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_exit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_exit_t *on_thread_exit, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_topic_result_error(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">const char *rd_kafka_topic_result_error_string(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">const char *rd_kafka_topic_result_name(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">const rd_kafka_error_t *rd_kafka_group_result_error(const rd_kafka_group_result_t *groupres);</span>
<span class="s1">const char *rd_kafka_group_result_name(const rd_kafka_group_result_t *groupres);</span>
<span class="s1">const rd_kafka_topic_partition_list_t *rd_kafka_group_result_partitions(const rd_kafka_group_result_t *groupres);</span>
<span class="s1">typedef enum rd_kafka_admin_op_t {</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_ANY = 0,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_CREATETOPICS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DELETETOPICS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_CREATEPARTITIONS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_ALTERCONFIGS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DESCRIBECONFIGS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DELETERECORDS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DELETEGROUPS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DELETECONSUMERGROUPOFFSETS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_CREATEACLS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DESCRIBEACLS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DELETEACLS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP__CNT,</span>
<span class="s1">} rd_kafka_admin_op_t;</span>
<span class="s1">typedef struct rd_kafka_AdminOptions_s rd_kafka_AdminOptions_t;</span>
<span class="s1">rd_kafka_AdminOptions_t *rd_kafka_AdminOptions_new(rd_kafka_t *rk, rd_kafka_admin_op_t for_api);</span>
<span class="s1">void rd_kafka_AdminOptions_destroy(rd_kafka_AdminOptions_t *options);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_request_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_operation_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_validate_only(rd_kafka_AdminOptions_t *options, int true_or_false, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_broker(rd_kafka_AdminOptions_t *options, int32_t broker_id, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_AdminOptions_set_opaque(rd_kafka_AdminOptions_t *options, void *ev_opaque);</span>
<span class="s1">typedef struct rd_kafka_NewTopic_s rd_kafka_NewTopic_t;</span>
<span class="s1">rd_kafka_NewTopic_t *rd_kafka_NewTopic_new(const char *topic, int num_partitions, int replication_factor, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_NewTopic_destroy(rd_kafka_NewTopic_t *new_topic);</span>
<span class="s1">void rd_kafka_NewTopic_destroy_array(rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewTopic_set_replica_assignment(rd_kafka_NewTopic_t *new_topic, int32_t partition, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewTopic_set_config(rd_kafka_NewTopic_t *new_topic, const char *name, const char *value);</span>
<span class="s1">void rd_kafka_CreateTopics(rd_kafka_t *rk, rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_CreateTopics_result_topics(const rd_kafka_CreateTopics_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_DeleteTopic_s rd_kafka_DeleteTopic_t;</span>
<span class="s1">rd_kafka_DeleteTopic_t *rd_kafka_DeleteTopic_new(const char *topic);</span>
<span class="s1">void rd_kafka_DeleteTopic_destroy(rd_kafka_DeleteTopic_t *del_topic);</span>
<span class="s1">void rd_kafka_DeleteTopic_destroy_array(rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt);</span>
<span class="s1">void rd_kafka_DeleteTopics(rd_kafka_t *rk, rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_DeleteTopics_result_topics(const rd_kafka_DeleteTopics_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_NewPartitions_s rd_kafka_NewPartitions_t;</span>
<span class="s1">rd_kafka_NewPartitions_t *rd_kafka_NewPartitions_new(const char *topic, size_t new_total_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_NewPartitions_destroy(rd_kafka_NewPartitions_t *new_parts);</span>
<span class="s1">void rd_kafka_NewPartitions_destroy_array(rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewPartitions_set_replica_assignment(rd_kafka_NewPartitions_t *new_parts, int32_t new_partition_idx, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_CreatePartitions(rd_kafka_t *rk, rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_CreatePartitions_result_topics(const rd_kafka_CreatePartitions_result_t *result, size_t *cntp);</span>
<span class="s1">typedef enum rd_kafka_ConfigSource_t {</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_UNKNOWN_CONFIG = 0,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_TOPIC_CONFIG = 1,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_BROKER_CONFIG = 2,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_DEFAULT_BROKER_CONFIG = 3,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_STATIC_BROKER_CONFIG = 4,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DEFAULT_CONFIG = 5,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE__CNT,</span>
<span class="s1">} rd_kafka_ConfigSource_t;</span>
<span class="s1">const char *rd_kafka_ConfigSource_name(rd_kafka_ConfigSource_t confsource);</span>
<span class="s1">typedef struct rd_kafka_ConfigEntry_s rd_kafka_ConfigEntry_t;</span>
<span class="s1">const char *rd_kafka_ConfigEntry_name(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">const char *rd_kafka_ConfigEntry_value(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">rd_kafka_ConfigSource_t rd_kafka_ConfigEntry_source(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_read_only(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_default(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_sensitive(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_synonym(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">const rd_kafka_ConfigEntry_t **rd_kafka_ConfigEntry_synonyms(const rd_kafka_ConfigEntry_t *entry, size_t *cntp);</span>
<span class="s1">typedef enum rd_kafka_ResourceType_t {</span>
<span class="s1">  RD_KAFKA_RESOURCE_UNKNOWN = 0,</span>
<span class="s1">  RD_KAFKA_RESOURCE_ANY = 1,</span>
<span class="s1">  RD_KAFKA_RESOURCE_TOPIC = 2,</span>
<span class="s1">  RD_KAFKA_RESOURCE_GROUP = 3,</span>
<span class="s1">  RD_KAFKA_RESOURCE_BROKER = 4,</span>
<span class="s1">  RD_KAFKA_RESOURCE__CNT,</span>
<span class="s1">} rd_kafka_ResourceType_t;</span>
<span class="s1">typedef enum rd_kafka_ResourcePatternType_t {</span>
<span class="s1">  RD_KAFKA_RESOURCE_PATTERN_UNKNOWN = 0,</span>
<span class="s1">  RD_KAFKA_RESOURCE_PATTERN_ANY = 1,</span>
<span class="s1">  RD_KAFKA_RESOURCE_PATTERN_MATCH = 2,</span>
<span class="s1">  RD_KAFKA_RESOURCE_PATTERN_LITERAL = 3,</span>
<span class="s1">  RD_KAFKA_RESOURCE_PATTERN_PREFIXED = 4,</span>
<span class="s1">  RD_KAFKA_RESOURCE_PATTERN_TYPE__CNT,</span>
<span class="s1">} rd_kafka_ResourcePatternType_t;</span>
<span class="s1">const char *rd_kafka_ResourcePatternType_name(rd_kafka_ResourcePatternType_t resource_pattern_type);</span>
<span class="s1">const char *rd_kafka_ResourceType_name(rd_kafka_ResourceType_t restype);</span>
<span class="s1">typedef struct rd_kafka_ConfigResource_s rd_kafka_ConfigResource_t;</span>
<span class="s1">rd_kafka_ConfigResource_t *rd_kafka_ConfigResource_new(rd_kafka_ResourceType_t restype, const char *resname);</span>
<span class="s1">void rd_kafka_ConfigResource_destroy(rd_kafka_ConfigResource_t *config);</span>
<span class="s1">void rd_kafka_ConfigResource_destroy_array(rd_kafka_ConfigResource_t **config, size_t config_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_ConfigResource_set_config(rd_kafka_ConfigResource_t *config, const char *name, const char *value);</span>
<span class="s1">const rd_kafka_ConfigEntry_t **rd_kafka_ConfigResource_configs(const rd_kafka_ConfigResource_t *config, size_t *cntp);</span>
<span class="s1">rd_kafka_ResourceType_t rd_kafka_ConfigResource_type(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">const char *rd_kafka_ConfigResource_name(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_ConfigResource_error(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">const char *rd_kafka_ConfigResource_error_string(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">void rd_kafka_AlterConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_ConfigResource_t **rd_kafka_AlterConfigs_result_resources(const rd_kafka_AlterConfigs_result_t *result, size_t *cntp);</span>
<span class="s1">void rd_kafka_DescribeConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_ConfigResource_t **rd_kafka_DescribeConfigs_result_resources(const rd_kafka_DescribeConfigs_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_DeleteRecords_s rd_kafka_DeleteRecords_t;</span>
<span class="s1">rd_kafka_DeleteRecords_t *rd_kafka_DeleteRecords_new(const rd_kafka_topic_partition_list_t *before_offsets);</span>
<span class="s1">void rd_kafka_DeleteRecords_destroy(rd_kafka_DeleteRecords_t *del_records);</span>
<span class="s1">void rd_kafka_DeleteRecords_destroy_array(rd_kafka_DeleteRecords_t **del_records, size_t del_record_cnt);</span>
<span class="s1">void rd_kafka_DeleteRecords(rd_kafka_t *rk, rd_kafka_DeleteRecords_t **del_records, size_t del_record_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_partition_list_t *rd_kafka_DeleteRecords_result_offsets(const rd_kafka_DeleteRecords_result_t *result);</span>
<span class="s1">typedef struct rd_kafka_DeleteGroup_s rd_kafka_DeleteGroup_t;</span>
<span class="s1">rd_kafka_DeleteGroup_t *rd_kafka_DeleteGroup_new(const char *group);</span>
<span class="s1">void rd_kafka_DeleteGroup_destroy(rd_kafka_DeleteGroup_t *del_group);</span>
<span class="s1">void rd_kafka_DeleteGroup_destroy_array(rd_kafka_DeleteGroup_t **del_groups, size_t del_group_cnt);</span>
<span class="s1">void rd_kafka_DeleteGroups(rd_kafka_t *rk, rd_kafka_DeleteGroup_t **del_groups, size_t del_group_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_group_result_t **rd_kafka_DeleteGroups_result_groups(const rd_kafka_DeleteGroups_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_DeleteConsumerGroupOffsets_s rd_kafka_DeleteConsumerGroupOffsets_t;</span>
<span class="s1">rd_kafka_DeleteConsumerGroupOffsets_t *rd_kafka_DeleteConsumerGroupOffsets_new(const char *group, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">void rd_kafka_DeleteConsumerGroupOffsets_destroy(rd_kafka_DeleteConsumerGroupOffsets_t *del_grpoffsets);</span>
<span class="s1">void rd_kafka_DeleteConsumerGroupOffsets_destroy_array(rd_kafka_DeleteConsumerGroupOffsets_t **del_grpoffsets, size_t del_grpoffset_cnt);</span>
<span class="s1">void rd_kafka_DeleteConsumerGroupOffsets(rd_kafka_t *rk, rd_kafka_DeleteConsumerGroupOffsets_t **del_grpoffsets, size_t del_grpoffsets_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_group_result_t **rd_kafka_DeleteConsumerGroupOffsets_result_groups(const rd_kafka_DeleteConsumerGroupOffsets_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_AclBinding_s rd_kafka_AclBinding_t;</span>
<span class="s1">typedef rd_kafka_AclBinding_t rd_kafka_AclBindingFilter_t;</span>
<span class="s1">const rd_kafka_error_t *rd_kafka_acl_result_error(const rd_kafka_acl_result_t *aclres);</span>
<span class="s1">typedef enum rd_kafka_AclOperation_t {</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_UNKNOWN = 0,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_ANY = 1,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_ALL = 2,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_READ = 3,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_WRITE = 4,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_CREATE = 5,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_DELETE = 6,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_ALTER = 7,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_DESCRIBE = 8,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_CLUSTER_ACTION = 9,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_DESCRIBE_CONFIGS = 10,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_ALTER_CONFIGS = 11,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_IDEMPOTENT_WRITE = 12,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION__CNT,</span>
<span class="s1">} rd_kafka_AclOperation_t;</span>
<span class="s1">const char *rd_kafka_AclOperation_name(rd_kafka_AclOperation_t acl_operation);</span>
<span class="s1">typedef enum rd_kafka_AclPermissionType_t {</span>
<span class="s1">  RD_KAFKA_ACL_PERMISSION_TYPE_UNKNOWN = 0,</span>
<span class="s1">  RD_KAFKA_ACL_PERMISSION_TYPE_ANY = 1,</span>
<span class="s1">  RD_KAFKA_ACL_PERMISSION_TYPE_DENY = 2,</span>
<span class="s1">  RD_KAFKA_ACL_PERMISSION_TYPE_ALLOW = 3,</span>
<span class="s1">  RD_KAFKA_ACL_PERMISSION_TYPE__CNT,</span>
<span class="s1">} rd_kafka_AclPermissionType_t;</span>
<span class="s1">const char *rd_kafka_AclPermissionType_name(rd_kafka_AclPermissionType_t acl_permission_type);</span>
<span class="s1">rd_kafka_AclBinding_t *rd_kafka_AclBinding_new(rd_kafka_ResourceType_t restype, const char *name, rd_kafka_ResourcePatternType_t resource_pattern_type, const char *principal, const char *host, rd_kafka_AclOperation_t operation, rd_kafka_AclPermissionType_t permission_type, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_AclBindingFilter_t *rd_kafka_AclBindingFilter_new(rd_kafka_ResourceType_t restype, const char *name, rd_kafka_ResourcePatternType_t resource_pattern_type, const char *principal, const char *host, rd_kafka_AclOperation_t operation, rd_kafka_AclPermissionType_t permission_type, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_ResourceType_t rd_kafka_AclBinding_restype(const rd_kafka_AclBinding_t *acl);</span>
<span class="s1">const char *rd_kafka_AclBinding_name(const rd_kafka_AclBinding_t *acl);</span>
<span class="s1">const char *rd_kafka_AclBinding_principal(const rd_kafka_AclBinding_t *acl);</span>
<span class="s1">const char *rd_kafka_AclBinding_host(const rd_kafka_AclBinding_t *acl);</span>
<span class="s1">rd_kafka_AclOperation_t rd_kafka_AclBinding_operation(const rd_kafka_AclBinding_t *acl);</span>
<span class="s1">rd_kafka_AclPermissionType_t rd_kafka_AclBinding_permission_type(const rd_kafka_AclBinding_t *acl);</span>
<span class="s1">rd_kafka_ResourcePatternType_t rd_kafka_AclBinding_resource_pattern_type(const rd_kafka_AclBinding_t *acl);</span>
<span class="s1">const rd_kafka_error_t *rd_kafka_AclBinding_error(const rd_kafka_AclBinding_t *acl);</span>
<span class="s1">void rd_kafka_AclBinding_destroy(rd_kafka_AclBinding_t *acl_binding);</span>
<span class="s1">void rd_kafka_AclBinding_destroy_array(rd_kafka_AclBinding_t **acl_bindings, size_t acl_bindings_cnt);</span>
<span class="s1">const rd_kafka_acl_result_t **rd_kafka_CreateAcls_result_acls(const rd_kafka_CreateAcls_result_t *result, size_t *cntp);</span>
<span class="s1">void rd_kafka_CreateAcls(rd_kafka_t *rk, rd_kafka_AclBinding_t **new_acls, size_t new_acls_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_AclBinding_t **rd_kafka_DescribeAcls_result_acls(const rd_kafka_DescribeAcls_result_t *result, size_t *cntp);</span>
<span class="s1">void rd_kafka_DescribeAcls(rd_kafka_t *rk, rd_kafka_AclBindingFilter_t *acl_filter, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">typedef struct rd_kafka_DeleteAcls_result_response_s rd_kafka_DeleteAcls_result_response_t;</span>
<span class="s1">const rd_kafka_DeleteAcls_result_response_t **rd_kafka_DeleteAcls_result_responses(const rd_kafka_DeleteAcls_result_t *result, size_t *cntp);</span>
<span class="s1">const rd_kafka_error_t *rd_kafka_DeleteAcls_result_response_error(const rd_kafka_DeleteAcls_result_response_t *result_response);</span>
<span class="s1">const rd_kafka_AclBinding_t **rd_kafka_DeleteAcls_result_response_matching_acls(const rd_kafka_DeleteAcls_result_response_t *result_response, size_t *matching_acls_cntp);</span>
<span class="s1">void rd_kafka_DeleteAcls(rd_kafka_t *rk, rd_kafka_AclBindingFilter_t **del_acls, size_t del_acls_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token(rd_kafka_t *rk, const char *token_value, int64_t md_lifetime_ms, const char *md_principal_name, const char **extensions, size_t extension_size, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token_failure(rd_kafka_t *rk, const char *errstr);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_init_transactions(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_begin_transaction(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_send_offsets_to_transaction(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, const rd_kafka_consumer_group_metadata_t *cgmetadata, int timeout_ms);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_commit_transaction(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_abort_transaction(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">typedef struct rd_kafka_mock_cluster_s rd_kafka_mock_cluster_t;</span>
<span class="s1">rd_kafka_mock_cluster_t *rd_kafka_mock_cluster_new(rd_kafka_t *rk, int broker_cnt);</span>
<span class="s1">void rd_kafka_mock_cluster_destroy(rd_kafka_mock_cluster_t *mcluster);</span>
<span class="s1">rd_kafka_t *rd_kafka_mock_cluster_handle(const rd_kafka_mock_cluster_t *mcluster);</span>
<span class="s1">rd_kafka_mock_cluster_t *rd_kafka_handle_mock_cluster(const rd_kafka_t *rk);</span>
<span class="s1">const char *rd_kafka_mock_cluster_bootstraps(const rd_kafka_mock_cluster_t *mcluster);</span>
<span class="s1">void rd_kafka_mock_clear_request_errors(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey);</span>
<span class="s1">void rd_kafka_mock_push_request_errors(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, size_t cnt, ...);</span>
<span class="s1">void rd_kafka_mock_push_request_errors_array(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, size_t cnt, const rd_kafka_resp_err_t *errors);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_push_request_error_rtts(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int16_t ApiKey, size_t cnt, ...);</span>
<span class="s1">void rd_kafka_mock_topic_set_error(rd_kafka_mock_cluster_t *mcluster, const char *topic, rd_kafka_resp_err_t err);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_topic_create(rd_kafka_mock_cluster_t *mcluster, const char *topic, int partition_cnt, int replication_factor);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_partition_set_leader(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_partition_set_follower(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_partition_set_follower_wmarks(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int64_t lo, int64_t hi);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_set_down(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_set_up(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_set_rtt(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int rtt_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_set_rack(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, const char *rack);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_coordinator_set(rd_kafka_mock_cluster_t *mcluster, const char *key_type, const char *key, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_set_apiversion(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, int16_t MinVersion, int16_t MaxVersion);</span>
<span class="s1">&#39;</span>
</code></pre></div>
rdkafka.h, rdkafka_mock.h</p>
<h3 id="rd_kafka_version_21">RD_KAFKA_VERSION<a class="headerlink" href="#rd_kafka_version_21" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_VERSION</span> <span class="o">=</span> <span class="mi">17367807</span>
</code></pre></div>
<p>librdkafka version </p>
<p>Interpreted as hex <code>MM.mm.rr.xx</code>:</p>
<ul>
<li>MM = Major</li>
<li>mm = minor</li>
<li>rr = revision</li>
<li>xx = pre-release id (0xff is the final release)</li>
</ul>
<p>E.g.: <code>0x000801ff</code> = 0.8.1</p>
<dl class="section remark"><dt>Remarks</dt><dd>This value should only be used during compile time, for runtime checks of version use rd_kafka_version() </dd></dl>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_unsupported_compression_type_21">RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE<a class="headerlink" href="#rd_kafka_resp_err_unsupported_compression_type_21" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE</span> <span class="o">=</span> <span class="mi">76</span>
</code></pre></div>
<p>Unsupported compression type </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_end_all_21">RD_KAFKA_RESP_ERR_END_ALL<a class="headerlink" href="#rd_kafka_resp_err_end_all_21" title="Permanent link">&para;</a></h3>
<p><div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_END_ALL</span> <span class="o">=</span> <span class="mi">98</span>
</code></pre></div>
enum rd_kafka_resp_err_t</p>
<h3 id="rd_kafka_admin_op__cnt_21">RD_KAFKA_ADMIN_OP__CNT<a class="headerlink" href="#rd_kafka_admin_op__cnt_21" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_ADMIN_OP__CNT</span> <span class="o">=</span> <span class="mi">12</span>
</code></pre></div>
<p>Number of ops defined </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe </a></li>
</ul>
</div>
<h3 id="rd_kafka_resource__cnt_21">RD_KAFKA_RESOURCE__CNT<a class="headerlink" href="#rd_kafka_resource__cnt_21" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESOURCE__CNT</span> <span class="o">=</span> <span class="mi">5</span>
</code></pre></div>
<p>Number of resource types defined </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#acca83a66d7783ff7683ed2691cc907c9"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#acca83a66d7783ff7683ed2691cc907c9 </a></li>
</ul>
</div>
<h3 id="rd_kafka_cdef_21">RD_KAFKA_CDEF<a class="headerlink" href="#rd_kafka_cdef_21" title="Permanent link">&para;</a></h3>
<p><div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_CDEF</span> <span class="o">=</span> <span class="s1">&#39;typedef long int ssize_t;</span>
<span class="s1">typedef struct _IO_FILE FILE;</span>
<span class="s1">typedef long int mode_t;</span>
<span class="s1">typedef signed int int16_t;</span>
<span class="s1">typedef unsigned int uint16_t;</span>
<span class="s1">typedef signed int int32_t;</span>
<span class="s1">typedef signed long int int64_t;</span>
<span class="s1">int rd_kafka_version(void);</span>
<span class="s1">const char *rd_kafka_version_str(void);</span>
<span class="s1">typedef enum rd_kafka_type_t {</span>
<span class="s1">  RD_KAFKA_PRODUCER,</span>
<span class="s1">  RD_KAFKA_CONSUMER,</span>
<span class="s1">} rd_kafka_type_t;</span>
<span class="s1">typedef enum rd_kafka_timestamp_type_t {</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_NOT_AVAILABLE,</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_CREATE_TIME,</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_LOG_APPEND_TIME,</span>
<span class="s1">} rd_kafka_timestamp_type_t;</span>
<span class="s1">const char *rd_kafka_get_debug_contexts(void);</span>
<span class="s1">typedef struct rd_kafka_s rd_kafka_t;</span>
<span class="s1">typedef struct rd_kafka_topic_s rd_kafka_topic_t;</span>
<span class="s1">typedef struct rd_kafka_conf_s rd_kafka_conf_t;</span>
<span class="s1">typedef struct rd_kafka_topic_conf_s rd_kafka_topic_conf_t;</span>
<span class="s1">typedef struct rd_kafka_queue_s rd_kafka_queue_t;</span>
<span class="s1">typedef struct rd_kafka_op_s rd_kafka_event_t;</span>
<span class="s1">typedef struct rd_kafka_topic_result_s rd_kafka_topic_result_t;</span>
<span class="s1">typedef struct rd_kafka_consumer_group_metadata_s rd_kafka_consumer_group_metadata_t;</span>
<span class="s1">typedef struct rd_kafka_error_s {</span>
<span class="s1">  unsigned int code;</span>
<span class="s1">  char *errstr;</span>
<span class="s1">  unsigned char fatal;</span>
<span class="s1">  unsigned char retriable;</span>
<span class="s1">  unsigned char txn_requires_abort;</span>
<span class="s1">} rd_kafka_error_t;</span>
<span class="s1">typedef struct rd_kafka_headers_s rd_kafka_headers_t;</span>
<span class="s1">typedef struct rd_kafka_group_result_s rd_kafka_group_result_t;</span>
<span class="s1">typedef struct rd_kafka_acl_result_s rd_kafka_acl_result_t;</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BEGIN = (- 200),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BAD_MSG = (- 199),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BAD_COMPRESSION = (- 198),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__DESTROY = (- 197),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FAIL = (- 196),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TRANSPORT = (- 195),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__CRIT_SYS_RESOURCE = (- 194),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__RESOLVE = (- 193),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__MSG_TIMED_OUT = (- 192),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PARTITION_EOF = (- 191),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION = (- 190),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FS = (- 189),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC = (- 188),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ALL_BROKERS_DOWN = (- 187),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INVALID_ARG = (- 186),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TIMED_OUT = (- 185),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__QUEUE_FULL = (- 184),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ISR_INSUFF = (- 183),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NODE_UPDATE = (- 182),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__SSL = (- 181),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__WAIT_COORD = (- 180),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_GROUP = (- 179),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__IN_PROGRESS = (- 178),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PREV_IN_PROGRESS = (- 177),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__EXISTING_SUBSCRIPTION = (- 176),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS = (- 175),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS = (- 174),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__CONFLICT = (- 173),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__STATE = (- 172),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_PROTOCOL = (- 171),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED = (- 170),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__AUTHENTICATION = (- 169),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NO_OFFSET = (- 168),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__OUTDATED = (- 167),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TIMED_OUT_QUEUE = (- 166),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNSUPPORTED_FEATURE = (- 165),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__WAIT_CACHE = (- 164),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INTR = (- 163),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__KEY_SERIALIZATION = (- 162),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__VALUE_SERIALIZATION = (- 161),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__KEY_DESERIALIZATION = (- 160),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__VALUE_DESERIALIZATION = (- 159),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PARTIAL = (- 158),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__READ_ONLY = (- 157),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOENT = (- 156),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNDERFLOW = (- 155),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INVALID_TYPE = (- 154),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__RETRY = (- 153),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PURGE_QUEUE = (- 152),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PURGE_INFLIGHT = (- 151),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FATAL = (- 150),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INCONSISTENT = (- 149),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__GAPLESS_GUARANTEE = (- 148),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__MAX_POLL_EXCEEDED = (- 147),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_BROKER = (- 146),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOT_CONFIGURED = (- 145),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FENCED = (- 144),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__APPLICATION = (- 143),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ASSIGNMENT_LOST = (- 142),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOOP = (- 141),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__AUTO_OFFSET_RESET = (- 140),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__END = (- 100),</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN = (- 1),</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NO_ERROR = 0,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_OUT_OF_RANGE = 1,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_MSG = 2,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART = 3,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_MSG_SIZE = 4,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE = 5,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_LEADER_FOR_PARTITION = 6,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REQUEST_TIMED_OUT = 7,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_BROKER_NOT_AVAILABLE = 8,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REPLICA_NOT_AVAILABLE = 9,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE = 10,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_STALE_CTRL_EPOCH = 11,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_METADATA_TOO_LARGE = 12,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NETWORK_EXCEPTION = 13,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_COORDINATOR_LOAD_IN_PROGRESS = 14,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_COORDINATOR_NOT_AVAILABLE = 15,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_COORDINATOR = 16,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_EXCEPTION = 17,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_RECORD_LIST_TOO_LARGE = 18,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS = 19,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS_AFTER_APPEND = 20,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REQUIRED_ACKS = 21,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ILLEGAL_GENERATION = 22,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INCONSISTENT_GROUP_PROTOCOL = 23,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_GROUP_ID = 24,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_MEMBER_ID = 25,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_SESSION_TIMEOUT = 26,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REBALANCE_IN_PROGRESS = 27,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_COMMIT_OFFSET_SIZE = 28,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_AUTHORIZATION_FAILED = 29,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_AUTHORIZATION_FAILED = 30,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_CLUSTER_AUTHORIZATION_FAILED = 31,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TIMESTAMP = 32,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_SASL_MECHANISM = 33,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ILLEGAL_SASL_STATE = 34,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_VERSION = 35,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_ALREADY_EXISTS = 36,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PARTITIONS = 37,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REPLICATION_FACTOR = 38,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REPLICA_ASSIGNMENT = 39,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_CONFIG = 40,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_CONTROLLER = 41,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REQUEST = 42,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_FOR_MESSAGE_FORMAT = 43,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_POLICY_VIOLATION = 44,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OUT_OF_ORDER_SEQUENCE_NUMBER = 45,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DUPLICATE_SEQUENCE_NUMBER = 46,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_EPOCH = 47,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TXN_STATE = 48,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_ID_MAPPING = 49,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TRANSACTION_TIMEOUT = 50,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_CONCURRENT_TRANSACTIONS = 51,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TRANSACTION_COORDINATOR_FENCED = 52,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TRANSACTIONAL_ID_AUTHORIZATION_FAILED = 53,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_SECURITY_DISABLED = 54,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OPERATION_NOT_ATTEMPTED = 55,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_KAFKA_STORAGE_ERROR = 56,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LOG_DIR_NOT_FOUND = 57,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_SASL_AUTHENTICATION_FAILED = 58,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_PRODUCER_ID = 59,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REASSIGNMENT_IN_PROGRESS = 60,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTH_DISABLED = 61,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_NOT_FOUND = 62,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_OWNER_MISMATCH = 63,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_REQUEST_NOT_ALLOWED = 64,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTHORIZATION_FAILED = 65,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_EXPIRED = 66,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRINCIPAL_TYPE = 67,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NON_EMPTY_GROUP = 68,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_ID_NOT_FOUND = 69,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FETCH_SESSION_ID_NOT_FOUND = 70,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_FETCH_SESSION_EPOCH = 71,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LISTENER_NOT_FOUND = 72,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_DELETION_DISABLED = 73,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FENCED_LEADER_EPOCH = 74,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_LEADER_EPOCH = 75,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_STALE_BROKER_EPOCH = 77,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_NOT_AVAILABLE = 78,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_MEMBER_ID_REQUIRED = 79,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_PREFERRED_LEADER_NOT_AVAILABLE = 80,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_MAX_SIZE_REACHED = 81,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FENCED_INSTANCE_ID = 82,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ELIGIBLE_LEADERS_NOT_AVAILABLE = 83,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ELECTION_NOT_NEEDED = 84,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NO_REASSIGNMENT_IN_PROGRESS = 85,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_SUBSCRIBED_TO_TOPIC = 86,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_RECORD = 87,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSTABLE_OFFSET_COMMIT = 88,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_THROTTLING_QUOTA_EXCEEDED = 89,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_PRODUCER_FENCED = 90,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_RESOURCE_NOT_FOUND = 91,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DUPLICATE_RESOURCE = 92,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNACCEPTABLE_CREDENTIAL = 93,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INCONSISTENT_VOTER_SET = 94,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_UPDATE_VERSION = 95,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FEATURE_UPDATE_FAILED = 96,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_PRINCIPAL_DESERIALIZATION_FAILURE = 97,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_END_ALL,</span>
<span class="s1">} rd_kafka_resp_err_t;</span>
<span class="s1">struct rd_kafka_err_desc {</span>
<span class="s1">  rd_kafka_resp_err_t code;</span>
<span class="s1">  char *name;</span>
<span class="s1">  char *desc;</span>
<span class="s1">};</span>
<span class="s1">void rd_kafka_get_err_descs(const struct rd_kafka_err_desc **errdescs, size_t *cntp);</span>
<span class="s1">const char *rd_kafka_err2str(rd_kafka_resp_err_t err);</span>
<span class="s1">const char *rd_kafka_err2name(rd_kafka_resp_err_t err);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_last_error(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_errno2err(int errnox);</span>
<span class="s1">int rd_kafka_errno(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_fatal_error(rd_kafka_t *rk, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_test_fatal_error(rd_kafka_t *rk, rd_kafka_resp_err_t err, const char *reason);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_error_code(const rd_kafka_error_t *error);</span>
<span class="s1">const char *rd_kafka_error_name(const rd_kafka_error_t *error);</span>
<span class="s1">const char *rd_kafka_error_string(const rd_kafka_error_t *error);</span>
<span class="s1">int rd_kafka_error_is_fatal(const rd_kafka_error_t *error);</span>
<span class="s1">int rd_kafka_error_is_retriable(const rd_kafka_error_t *error);</span>
<span class="s1">int rd_kafka_error_txn_requires_abort(const rd_kafka_error_t *error);</span>
<span class="s1">void rd_kafka_error_destroy(rd_kafka_error_t *error);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_error_new(rd_kafka_resp_err_t code, const char *fmt, ...);</span>
<span class="s1">typedef struct rd_kafka_topic_partition_s {</span>
<span class="s1">  char *topic;</span>
<span class="s1">  int32_t partition;</span>
<span class="s1">  int64_t offset;</span>
<span class="s1">  void *metadata;</span>
<span class="s1">  size_t metadata_size;</span>
<span class="s1">  void *opaque;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  void *_private;</span>
<span class="s1">} rd_kafka_topic_partition_t;</span>
<span class="s1">void rd_kafka_topic_partition_destroy(rd_kafka_topic_partition_t *rktpar);</span>
<span class="s1">typedef struct rd_kafka_topic_partition_list_s {</span>
<span class="s1">  int cnt;</span>
<span class="s1">  int size;</span>
<span class="s1">  rd_kafka_topic_partition_t *elems;</span>
<span class="s1">} rd_kafka_topic_partition_list_t;</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_new(int size);</span>
<span class="s1">void rd_kafka_topic_partition_list_destroy(rd_kafka_topic_partition_list_t *rkparlist);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_add(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">void rd_kafka_topic_partition_list_add_range(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t start, int32_t stop);</span>
<span class="s1">int rd_kafka_topic_partition_list_del(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">int rd_kafka_topic_partition_list_del_by_idx(rd_kafka_topic_partition_list_t *rktparlist, int idx);</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_copy(const rd_kafka_topic_partition_list_t *src);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_topic_partition_list_set_offset(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition, int64_t offset);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_find(const rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">void rd_kafka_topic_partition_list_sort(rd_kafka_topic_partition_list_t *rktparlist, int (*cmp)(const void *a, const void *b, void *cmp_opaque), void *cmp_opaque);</span>
<span class="s1">typedef enum rd_kafka_vtype_t {</span>
<span class="s1">  RD_KAFKA_VTYPE_END,</span>
<span class="s1">  RD_KAFKA_VTYPE_TOPIC,</span>
<span class="s1">  RD_KAFKA_VTYPE_RKT,</span>
<span class="s1">  RD_KAFKA_VTYPE_PARTITION,</span>
<span class="s1">  RD_KAFKA_VTYPE_VALUE,</span>
<span class="s1">  RD_KAFKA_VTYPE_KEY,</span>
<span class="s1">  RD_KAFKA_VTYPE_OPAQUE,</span>
<span class="s1">  RD_KAFKA_VTYPE_MSGFLAGS,</span>
<span class="s1">  RD_KAFKA_VTYPE_TIMESTAMP,</span>
<span class="s1">  RD_KAFKA_VTYPE_HEADER,</span>
<span class="s1">  RD_KAFKA_VTYPE_HEADERS,</span>
<span class="s1">} rd_kafka_vtype_t;</span>
<span class="s1">typedef struct rd_kafka_vu_s {</span>
<span class="s1">  rd_kafka_vtype_t vtype;</span>
<span class="s1">  union {</span>
<span class="s1">    char *cstr;</span>
<span class="s1">    rd_kafka_topic_t *rkt;</span>
<span class="s1">    int i;</span>
<span class="s1">    int32_t i32;</span>
<span class="s1">    int64_t i64;</span>
<span class="s1">    struct {</span>
<span class="s1">      void *ptr;</span>
<span class="s1">      size_t size;</span>
<span class="s1">    } mem;</span>
<span class="s1">    struct {</span>
<span class="s1">      char *name;</span>
<span class="s1">      void *val;</span>
<span class="s1">      ssize_t size;</span>
<span class="s1">    } header;</span>
<span class="s1">    rd_kafka_headers_t *headers;</span>
<span class="s1">    void *ptr;</span>
<span class="s1">    char _pad[64];</span>
<span class="s1">  } u;</span>
<span class="s1">} rd_kafka_vu_t;</span>
<span class="s1">rd_kafka_headers_t *rd_kafka_headers_new(size_t initial_count);</span>
<span class="s1">void rd_kafka_headers_destroy(rd_kafka_headers_t *hdrs);</span>
<span class="s1">rd_kafka_headers_t *rd_kafka_headers_copy(const rd_kafka_headers_t *src);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_add(rd_kafka_headers_t *hdrs, const char *name, ssize_t name_size, const void *value, ssize_t value_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_remove(rd_kafka_headers_t *hdrs, const char *name);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get_last(const rd_kafka_headers_t *hdrs, const char *name, const void **valuep, size_t *sizep);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get(const rd_kafka_headers_t *hdrs, size_t idx, const char *name, const void **valuep, size_t *sizep);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get_all(const rd_kafka_headers_t *hdrs, size_t idx, const char **namep, const void **valuep, size_t *sizep);</span>
<span class="s1">typedef struct rd_kafka_message_s {</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  rd_kafka_topic_t *rkt;</span>
<span class="s1">  int32_t partition;</span>
<span class="s1">  void *payload;</span>
<span class="s1">  size_t len;</span>
<span class="s1">  void *key;</span>
<span class="s1">  size_t key_len;</span>
<span class="s1">  int64_t offset;</span>
<span class="s1">  void *_private;</span>
<span class="s1">} rd_kafka_message_t;</span>
<span class="s1">void rd_kafka_message_destroy(rd_kafka_message_t *rkmessage);</span>
<span class="s1">const char *rd_kafka_message_errstr(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">int64_t rd_kafka_message_timestamp(const rd_kafka_message_t *rkmessage, rd_kafka_timestamp_type_t *tstype);</span>
<span class="s1">int64_t rd_kafka_message_latency(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">int32_t rd_kafka_message_broker_id(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_message_headers(const rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_message_detach_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);</span>
<span class="s1">void rd_kafka_message_set_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t *hdrs);</span>
<span class="s1">size_t rd_kafka_header_cnt(const rd_kafka_headers_t *hdrs);</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_NOT_PERSISTED = 0,</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_POSSIBLY_PERSISTED = 1,</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_PERSISTED = 2,</span>
<span class="s1">} rd_kafka_msg_status_t;</span>
<span class="s1">rd_kafka_msg_status_t rd_kafka_message_status(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_CONF_UNKNOWN = (- 2),</span>
<span class="s1">  RD_KAFKA_CONF_INVALID = (- 1),</span>
<span class="s1">  RD_KAFKA_CONF_OK = 0,</span>
<span class="s1">} rd_kafka_conf_res_t;</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_new(void);</span>
<span class="s1">void rd_kafka_conf_destroy(rd_kafka_conf_t *conf);</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_dup(const rd_kafka_conf_t *conf);</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_dup_filter(const rd_kafka_conf_t *conf, size_t filter_cnt, const char **filter);</span>
<span class="s1">const rd_kafka_conf_t *rd_kafka_conf(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_set(rd_kafka_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_conf_set_events(rd_kafka_conf_t *conf, int events);</span>
<span class="s1">void rd_kafka_conf_set_background_event_cb(rd_kafka_conf_t *conf, void (*event_cb)(rd_kafka_t *rk, rd_kafka_event_t *rkev, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_dr_cb(rd_kafka_conf_t *conf, void (*dr_cb)(rd_kafka_t *rk, void *payload, size_t len, rd_kafka_resp_err_t err, void *opaque, void *msg_opaque));</span>
<span class="s1">void rd_kafka_conf_set_dr_msg_cb(rd_kafka_conf_t *conf, void (*dr_msg_cb)(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_consume_cb(rd_kafka_conf_t *conf, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_rebalance_cb(rd_kafka_conf_t *conf, void (*rebalance_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *partitions, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_offset_commit_cb(rd_kafka_conf_t *conf, void (*offset_commit_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_error_cb(rd_kafka_conf_t *conf, void (*error_cb)(rd_kafka_t *rk, int err, const char *reason, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_throttle_cb(rd_kafka_conf_t *conf, void (*throttle_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int throttle_time_ms, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_log_cb(rd_kafka_conf_t *conf, void (*log_cb)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));</span>
<span class="s1">void rd_kafka_conf_set_stats_cb(rd_kafka_conf_t *conf, int (*stats_cb)(rd_kafka_t *rk, char *json, size_t json_len, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_oauthbearer_token_refresh_cb(rd_kafka_conf_t *conf, void (*oauthbearer_token_refresh_cb)(rd_kafka_t *rk, const char *oauthbearer_config, void *opaque));</span>
<span class="s1">void rd_kafka_conf_enable_sasl_queue(rd_kafka_conf_t *conf, int enable);</span>
<span class="s1">void rd_kafka_conf_set_socket_cb(rd_kafka_conf_t *conf, int (*socket_cb)(int domain, int type, int protocol, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_connect_cb(rd_kafka_conf_t *conf, int (*connect_cb)(int sockfd, const struct sockaddr *addr, int addrlen, const char *id, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_closesocket_cb(rd_kafka_conf_t *conf, int (*closesocket_cb)(int sockfd, void *opaque));</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert_verify_cb(rd_kafka_conf_t *conf, int (*ssl_cert_verify_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int *x509_error, int depth, const char *buf, size_t size, char *errstr, size_t errstr_size, void *opaque));</span>
<span class="s1">typedef enum rd_kafka_cert_type_t {</span>
<span class="s1">  RD_KAFKA_CERT_PUBLIC_KEY,</span>
<span class="s1">  RD_KAFKA_CERT_PRIVATE_KEY,</span>
<span class="s1">  RD_KAFKA_CERT_CA,</span>
<span class="s1">  RD_KAFKA_CERT__CNT,</span>
<span class="s1">} rd_kafka_cert_type_t;</span>
<span class="s1">typedef enum rd_kafka_cert_enc_t {</span>
<span class="s1">  RD_KAFKA_CERT_ENC_PKCS12,</span>
<span class="s1">  RD_KAFKA_CERT_ENC_DER,</span>
<span class="s1">  RD_KAFKA_CERT_ENC_PEM,</span>
<span class="s1">  RD_KAFKA_CERT_ENC__CNT,</span>
<span class="s1">} rd_kafka_cert_enc_t;</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert(rd_kafka_conf_t *conf, rd_kafka_cert_type_t cert_type, rd_kafka_cert_enc_t cert_enc, const void *buffer, size_t size, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_conf_set_engine_callback_data(rd_kafka_conf_t *conf, void *callback_data);</span>
<span class="s1">void rd_kafka_conf_set_opaque(rd_kafka_conf_t *conf, void *opaque);</span>
<span class="s1">void *rd_kafka_opaque(const rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_conf_set_default_topic_conf(rd_kafka_conf_t *conf, rd_kafka_topic_conf_t *tconf);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_conf_get_default_topic_conf(rd_kafka_conf_t *conf);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_get(const rd_kafka_conf_t *conf, const char *name, char *dest, size_t *dest_size);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_topic_conf_get(const rd_kafka_topic_conf_t *conf, const char *name, char *dest, size_t *dest_size);</span>
<span class="s1">const char **rd_kafka_conf_dump(rd_kafka_conf_t *conf, size_t *cntp);</span>
<span class="s1">const char **rd_kafka_topic_conf_dump(rd_kafka_topic_conf_t *conf, size_t *cntp);</span>
<span class="s1">void rd_kafka_conf_dump_free(const char **arr, size_t cnt);</span>
<span class="s1">void rd_kafka_conf_properties_show(FILE *fp);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_topic_conf_new(void);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_topic_conf_dup(const rd_kafka_topic_conf_t *conf);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_default_topic_conf_dup(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_topic_conf_destroy(rd_kafka_topic_conf_t *topic_conf);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_topic_conf_set(rd_kafka_topic_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_topic_conf_set_opaque(rd_kafka_topic_conf_t *conf, void *rkt_opaque);</span>
<span class="s1">void rd_kafka_topic_conf_set_partitioner_cb(rd_kafka_topic_conf_t *topic_conf, int32_t (*partitioner)(const rd_kafka_topic_t *rkt, const void *keydata, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque));</span>
<span class="s1">void rd_kafka_topic_conf_set_msg_order_cmp(rd_kafka_topic_conf_t *topic_conf, int (*msg_order_cmp)(const rd_kafka_message_t *a, const rd_kafka_message_t *b));</span>
<span class="s1">int rd_kafka_topic_partition_available(const rd_kafka_topic_t *rkt, int32_t partition);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_consistent(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_consistent_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_murmur2(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_murmur2_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_fnv1a(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_fnv1a_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">rd_kafka_t *rd_kafka_new(rd_kafka_type_t type, rd_kafka_conf_t *conf, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_destroy(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_destroy_flags(rd_kafka_t *rk, int flags);</span>
<span class="s1">const char *rd_kafka_name(const rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_type_t rd_kafka_type(const rd_kafka_t *rk);</span>
<span class="s1">char *rd_kafka_memberid(const rd_kafka_t *rk);</span>
<span class="s1">char *rd_kafka_clusterid(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">int32_t rd_kafka_controllerid(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_topic_t *rd_kafka_topic_new(rd_kafka_t *rk, const char *topic, rd_kafka_topic_conf_t *conf);</span>
<span class="s1">void rd_kafka_topic_destroy(rd_kafka_topic_t *rkt);</span>
<span class="s1">const char *rd_kafka_topic_name(const rd_kafka_topic_t *rkt);</span>
<span class="s1">void *rd_kafka_topic_opaque(const rd_kafka_topic_t *rkt);</span>
<span class="s1">int rd_kafka_poll(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">void rd_kafka_yield(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_pause_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_resume_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_query_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_get_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offsets_for_times(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets, int timeout_ms);</span>
<span class="s1">void *rd_kafka_mem_calloc(rd_kafka_t *rk, size_t num, size_t size);</span>
<span class="s1">void *rd_kafka_mem_malloc(rd_kafka_t *rk, size_t size);</span>
<span class="s1">void rd_kafka_mem_free(rd_kafka_t *rk, void *ptr);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_new(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_queue_destroy(rd_kafka_queue_t *rkqu);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_main(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_sasl(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_sasl_background_callbacks_enable(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_consumer(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_partition(rd_kafka_t *rk, const char *topic, int32_t partition);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_background(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_queue_forward(rd_kafka_queue_t *src, rd_kafka_queue_t *dst);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_set_log_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu);</span>
<span class="s1">size_t rd_kafka_queue_length(rd_kafka_queue_t *rkqu);</span>
<span class="s1">void rd_kafka_queue_io_event_enable(rd_kafka_queue_t *rkqu, int fd, const void *payload, size_t size);</span>
<span class="s1">void rd_kafka_queue_cb_event_enable(rd_kafka_queue_t *rkqu, void (*event_cb)(rd_kafka_t *rk, void *qev_opaque), void *qev_opaque);</span>
<span class="s1">void rd_kafka_queue_yield(rd_kafka_queue_t *rkqu);</span>
<span class="s1">int rd_kafka_consume_start(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);</span>
<span class="s1">int rd_kafka_consume_start_queue(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, rd_kafka_queue_t *rkqu);</span>
<span class="s1">int rd_kafka_consume_stop(rd_kafka_topic_t *rkt, int32_t partition);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_seek(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, int timeout_ms);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_seek_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consume(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms);</span>
<span class="s1">ssize_t rd_kafka_consume_batch(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);</span>
<span class="s1">int rd_kafka_consume_callback(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consume_queue(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">ssize_t rd_kafka_consume_batch_queue(rd_kafka_queue_t *rkqu, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);</span>
<span class="s1">int rd_kafka_consume_callback_queue(rd_kafka_queue_t *rkqu, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offset_store(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offsets_store(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_subscribe(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *topics);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_unsubscribe(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_subscription(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **topics);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consumer_poll(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_consumer_close(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_consumer_close_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu);</span>
<span class="s1">int rd_kafka_consumer_closed(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_incremental_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_incremental_unassign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">const char *rd_kafka_rebalance_protocol(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_assignment(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **partitions);</span>
<span class="s1">int rd_kafka_assignment_lost(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, int async);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit_message(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, int async);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit_queue(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_queue_t *rkqu, void (*cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *commit_opaque), void *commit_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_committed(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_position(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata_new(const char *group_id);</span>
<span class="s1">rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata_new_with_genid(const char *group_id, int32_t generation_id, const char *member_id, const char *group_instance_id);</span>
<span class="s1">void rd_kafka_consumer_group_metadata_destroy(rd_kafka_consumer_group_metadata_t *);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_consumer_group_metadata_write(const rd_kafka_consumer_group_metadata_t *cgmd, void **bufferp, size_t *sizep);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_consumer_group_metadata_read(rd_kafka_consumer_group_metadata_t **cgmdp, const void *buffer, size_t size);</span>
<span class="s1">int rd_kafka_produce(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, void *payload, size_t len, const void *key, size_t keylen, void *msg_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_producev(rd_kafka_t *rk, ...);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_produceva(rd_kafka_t *rk, const rd_kafka_vu_t *vus, size_t cnt);</span>
<span class="s1">int rd_kafka_produce_batch(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, rd_kafka_message_t *rkmessages, int message_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_flush(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_purge(rd_kafka_t *rk, int purge_flags);</span>
<span class="s1">typedef struct rd_kafka_metadata_broker {</span>
<span class="s1">  int32_t id;</span>
<span class="s1">  char *host;</span>
<span class="s1">  int port;</span>
<span class="s1">} rd_kafka_metadata_broker_t;</span>
<span class="s1">typedef struct rd_kafka_metadata_partition {</span>
<span class="s1">  int32_t id;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  int32_t leader;</span>
<span class="s1">  int replica_cnt;</span>
<span class="s1">  int32_t *replicas;</span>
<span class="s1">  int isr_cnt;</span>
<span class="s1">  int32_t *isrs;</span>
<span class="s1">} rd_kafka_metadata_partition_t;</span>
<span class="s1">typedef struct rd_kafka_metadata_topic {</span>
<span class="s1">  char *topic;</span>
<span class="s1">  int partition_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_partition *partitions;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">} rd_kafka_metadata_topic_t;</span>
<span class="s1">typedef struct rd_kafka_metadata {</span>
<span class="s1">  int broker_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_broker *brokers;</span>
<span class="s1">  int topic_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_topic *topics;</span>
<span class="s1">  int32_t orig_broker_id;</span>
<span class="s1">  char *orig_broker_name;</span>
<span class="s1">} rd_kafka_metadata_t;</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_metadata(rd_kafka_t *rk, int all_topics, rd_kafka_topic_t *only_rkt, const struct rd_kafka_metadata **metadatap, int timeout_ms);</span>
<span class="s1">void rd_kafka_metadata_destroy(const struct rd_kafka_metadata *metadata);</span>
<span class="s1">struct rd_kafka_group_member_info {</span>
<span class="s1">  char *member_id;</span>
<span class="s1">  char *client_id;</span>
<span class="s1">  char *client_host;</span>
<span class="s1">  void *member_metadata;</span>
<span class="s1">  int member_metadata_size;</span>
<span class="s1">  void *member_assignment;</span>
<span class="s1">  int member_assignment_size;</span>
<span class="s1">};</span>
<span class="s1">struct rd_kafka_group_info {</span>
<span class="s1">  struct rd_kafka_metadata_broker broker;</span>
<span class="s1">  char *group;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  char *state;</span>
<span class="s1">  char *protocol_type;</span>
<span class="s1">  char *protocol;</span>
<span class="s1">  struct rd_kafka_group_member_info *members;</span>
<span class="s1">  int member_cnt;</span>
<span class="s1">};</span>
<span class="s1">struct rd_kafka_group_list {</span>
<span class="s1">  struct rd_kafka_group_info *groups;</span>
<span class="s1">  int group_cnt;</span>
<span class="s1">};</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_list_groups(rd_kafka_t *rk, const char *group, const struct rd_kafka_group_list **grplistp, int timeout_ms);</span>
<span class="s1">void rd_kafka_group_list_destroy(const struct rd_kafka_group_list *grplist);</span>
<span class="s1">int rd_kafka_brokers_add(rd_kafka_t *rk, const char *brokerlist);</span>
<span class="s1">void rd_kafka_set_logger(rd_kafka_t *rk, void (*func)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));</span>
<span class="s1">void rd_kafka_set_log_level(rd_kafka_t *rk, int level);</span>
<span class="s1">void rd_kafka_log_print(const rd_kafka_t *rk, int level, const char *fac, const char *buf);</span>
<span class="s1">void rd_kafka_log_syslog(const rd_kafka_t *rk, int level, const char *fac, const char *buf);</span>
<span class="s1">int rd_kafka_outq_len(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_dump(FILE *fp, rd_kafka_t *rk);</span>
<span class="s1">int rd_kafka_thread_cnt(void);</span>
<span class="s1">typedef enum rd_kafka_thread_type_t {</span>
<span class="s1">  RD_KAFKA_THREAD_MAIN,</span>
<span class="s1">  RD_KAFKA_THREAD_BACKGROUND,</span>
<span class="s1">  RD_KAFKA_THREAD_BROKER,</span>
<span class="s1">} rd_kafka_thread_type_t;</span>
<span class="s1">int rd_kafka_wait_destroyed(int timeout_ms);</span>
<span class="s1">int rd_kafka_unittest(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_poll_set_consumer(rd_kafka_t *rk);</span>
<span class="s1">typedef int rd_kafka_event_type_t;</span>
<span class="s1">rd_kafka_event_type_t rd_kafka_event_type(const rd_kafka_event_t *rkev);</span>
<span class="s1">const char *rd_kafka_event_name(const rd_kafka_event_t *rkev);</span>
<span class="s1">void rd_kafka_event_destroy(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_message_t *rd_kafka_event_message_next(rd_kafka_event_t *rkev);</span>
<span class="s1">size_t rd_kafka_event_message_array(rd_kafka_event_t *rkev, const rd_kafka_message_t **rkmessages, size_t size);</span>
<span class="s1">size_t rd_kafka_event_message_count(rd_kafka_event_t *rkev);</span>
<span class="s1">const char *rd_kafka_event_config_string(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_event_error(rd_kafka_event_t *rkev);</span>
<span class="s1">const char *rd_kafka_event_error_string(rd_kafka_event_t *rkev);</span>
<span class="s1">int rd_kafka_event_error_is_fatal(rd_kafka_event_t *rkev);</span>
<span class="s1">void *rd_kafka_event_opaque(rd_kafka_event_t *rkev);</span>
<span class="s1">int rd_kafka_event_log(rd_kafka_event_t *rkev, const char **fac, const char **str, int *level);</span>
<span class="s1">int rd_kafka_event_debug_contexts(rd_kafka_event_t *rkev, char *dst, size_t dstsize);</span>
<span class="s1">const char *rd_kafka_event_stats(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_event_topic_partition_list(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_event_topic_partition(rd_kafka_event_t *rkev);</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_CreateTopics_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DeleteTopics_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_CreateAcls_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DescribeAcls_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DeleteAcls_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_CreatePartitions_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_AlterConfigs_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DescribeConfigs_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DeleteRecords_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DeleteGroups_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DeleteConsumerGroupOffsets_result_t;</span>
<span class="s1">const rd_kafka_CreateTopics_result_t *rd_kafka_event_CreateTopics_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DeleteTopics_result_t *rd_kafka_event_DeleteTopics_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_CreatePartitions_result_t *rd_kafka_event_CreatePartitions_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_AlterConfigs_result_t *rd_kafka_event_AlterConfigs_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DescribeConfigs_result_t *rd_kafka_event_DescribeConfigs_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DeleteRecords_result_t *rd_kafka_event_DeleteRecords_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DeleteGroups_result_t *rd_kafka_event_DeleteGroups_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DeleteConsumerGroupOffsets_result_t *rd_kafka_event_DeleteConsumerGroupOffsets_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_CreateAcls_result_t *rd_kafka_event_CreateAcls_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DescribeAcls_result_t *rd_kafka_event_DescribeAcls_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DeleteAcls_result_t *rd_kafka_event_DeleteAcls_result(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_event_t *rd_kafka_queue_poll(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">int rd_kafka_queue_poll_callback(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_plugin_f_conf_init_t)(rd_kafka_conf_t *conf, void **plug_opaquep, char *errstr, size_t errstr_size);</span>
<span class="s1">typedef rd_kafka_conf_res_t (rd_kafka_interceptor_f_on_conf_set_t)(rd_kafka_conf_t *conf, const char *name, const char *val, char *errstr, size_t errstr_size, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_dup_t)(rd_kafka_conf_t *new_conf, const rd_kafka_conf_t *old_conf, size_t filter_cnt, const char **filter, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_destroy_t)(void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_new_t)(rd_kafka_t *rk, const rd_kafka_conf_t *conf, void *ic_opaque, char *errstr, size_t errstr_size);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_destroy_t)(rd_kafka_t *rk, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_send_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_acknowledgement_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_consume_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_commit_t)(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_resp_err_t err, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_request_sent_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_response_received_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, int64_t rtt, rd_kafka_resp_err_t err, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_start_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_exit_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_set(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_set_t *on_conf_set, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_dup(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_dup_t *on_conf_dup, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_destroy(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_destroy_t *on_conf_destroy, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_new(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_new_t *on_new, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_destroy(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_destroy_t *on_destroy, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_send(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_send_t *on_send, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_acknowledgement(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_acknowledgement_t *on_acknowledgement, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_consume(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_consume_t *on_consume, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_commit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_commit_t *on_commit, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_request_sent(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_request_sent_t *on_request_sent, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_response_received(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_response_received_t *on_response_received, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_start(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_start_t *on_thread_start, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_exit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_exit_t *on_thread_exit, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_topic_result_error(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">const char *rd_kafka_topic_result_error_string(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">const char *rd_kafka_topic_result_name(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">const rd_kafka_error_t *rd_kafka_group_result_error(const rd_kafka_group_result_t *groupres);</span>
<span class="s1">const char *rd_kafka_group_result_name(const rd_kafka_group_result_t *groupres);</span>
<span class="s1">const rd_kafka_topic_partition_list_t *rd_kafka_group_result_partitions(const rd_kafka_group_result_t *groupres);</span>
<span class="s1">typedef enum rd_kafka_admin_op_t {</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_ANY = 0,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_CREATETOPICS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DELETETOPICS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_CREATEPARTITIONS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_ALTERCONFIGS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DESCRIBECONFIGS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DELETERECORDS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DELETEGROUPS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DELETECONSUMERGROUPOFFSETS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_CREATEACLS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DESCRIBEACLS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DELETEACLS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP__CNT,</span>
<span class="s1">} rd_kafka_admin_op_t;</span>
<span class="s1">typedef struct rd_kafka_AdminOptions_s rd_kafka_AdminOptions_t;</span>
<span class="s1">rd_kafka_AdminOptions_t *rd_kafka_AdminOptions_new(rd_kafka_t *rk, rd_kafka_admin_op_t for_api);</span>
<span class="s1">void rd_kafka_AdminOptions_destroy(rd_kafka_AdminOptions_t *options);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_request_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_operation_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_validate_only(rd_kafka_AdminOptions_t *options, int true_or_false, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_broker(rd_kafka_AdminOptions_t *options, int32_t broker_id, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_AdminOptions_set_opaque(rd_kafka_AdminOptions_t *options, void *ev_opaque);</span>
<span class="s1">typedef struct rd_kafka_NewTopic_s rd_kafka_NewTopic_t;</span>
<span class="s1">rd_kafka_NewTopic_t *rd_kafka_NewTopic_new(const char *topic, int num_partitions, int replication_factor, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_NewTopic_destroy(rd_kafka_NewTopic_t *new_topic);</span>
<span class="s1">void rd_kafka_NewTopic_destroy_array(rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewTopic_set_replica_assignment(rd_kafka_NewTopic_t *new_topic, int32_t partition, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewTopic_set_config(rd_kafka_NewTopic_t *new_topic, const char *name, const char *value);</span>
<span class="s1">void rd_kafka_CreateTopics(rd_kafka_t *rk, rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_CreateTopics_result_topics(const rd_kafka_CreateTopics_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_DeleteTopic_s rd_kafka_DeleteTopic_t;</span>
<span class="s1">rd_kafka_DeleteTopic_t *rd_kafka_DeleteTopic_new(const char *topic);</span>
<span class="s1">void rd_kafka_DeleteTopic_destroy(rd_kafka_DeleteTopic_t *del_topic);</span>
<span class="s1">void rd_kafka_DeleteTopic_destroy_array(rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt);</span>
<span class="s1">void rd_kafka_DeleteTopics(rd_kafka_t *rk, rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_DeleteTopics_result_topics(const rd_kafka_DeleteTopics_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_NewPartitions_s rd_kafka_NewPartitions_t;</span>
<span class="s1">rd_kafka_NewPartitions_t *rd_kafka_NewPartitions_new(const char *topic, size_t new_total_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_NewPartitions_destroy(rd_kafka_NewPartitions_t *new_parts);</span>
<span class="s1">void rd_kafka_NewPartitions_destroy_array(rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewPartitions_set_replica_assignment(rd_kafka_NewPartitions_t *new_parts, int32_t new_partition_idx, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_CreatePartitions(rd_kafka_t *rk, rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_CreatePartitions_result_topics(const rd_kafka_CreatePartitions_result_t *result, size_t *cntp);</span>
<span class="s1">typedef enum rd_kafka_ConfigSource_t {</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_UNKNOWN_CONFIG = 0,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_TOPIC_CONFIG = 1,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_BROKER_CONFIG = 2,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_DEFAULT_BROKER_CONFIG = 3,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_STATIC_BROKER_CONFIG = 4,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DEFAULT_CONFIG = 5,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE__CNT,</span>
<span class="s1">} rd_kafka_ConfigSource_t;</span>
<span class="s1">const char *rd_kafka_ConfigSource_name(rd_kafka_ConfigSource_t confsource);</span>
<span class="s1">typedef struct rd_kafka_ConfigEntry_s rd_kafka_ConfigEntry_t;</span>
<span class="s1">const char *rd_kafka_ConfigEntry_name(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">const char *rd_kafka_ConfigEntry_value(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">rd_kafka_ConfigSource_t rd_kafka_ConfigEntry_source(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_read_only(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_default(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_sensitive(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_synonym(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">const rd_kafka_ConfigEntry_t **rd_kafka_ConfigEntry_synonyms(const rd_kafka_ConfigEntry_t *entry, size_t *cntp);</span>
<span class="s1">typedef enum rd_kafka_ResourceType_t {</span>
<span class="s1">  RD_KAFKA_RESOURCE_UNKNOWN = 0,</span>
<span class="s1">  RD_KAFKA_RESOURCE_ANY = 1,</span>
<span class="s1">  RD_KAFKA_RESOURCE_TOPIC = 2,</span>
<span class="s1">  RD_KAFKA_RESOURCE_GROUP = 3,</span>
<span class="s1">  RD_KAFKA_RESOURCE_BROKER = 4,</span>
<span class="s1">  RD_KAFKA_RESOURCE__CNT,</span>
<span class="s1">} rd_kafka_ResourceType_t;</span>
<span class="s1">typedef enum rd_kafka_ResourcePatternType_t {</span>
<span class="s1">  RD_KAFKA_RESOURCE_PATTERN_UNKNOWN = 0,</span>
<span class="s1">  RD_KAFKA_RESOURCE_PATTERN_ANY = 1,</span>
<span class="s1">  RD_KAFKA_RESOURCE_PATTERN_MATCH = 2,</span>
<span class="s1">  RD_KAFKA_RESOURCE_PATTERN_LITERAL = 3,</span>
<span class="s1">  RD_KAFKA_RESOURCE_PATTERN_PREFIXED = 4,</span>
<span class="s1">  RD_KAFKA_RESOURCE_PATTERN_TYPE__CNT,</span>
<span class="s1">} rd_kafka_ResourcePatternType_t;</span>
<span class="s1">const char *rd_kafka_ResourcePatternType_name(rd_kafka_ResourcePatternType_t resource_pattern_type);</span>
<span class="s1">const char *rd_kafka_ResourceType_name(rd_kafka_ResourceType_t restype);</span>
<span class="s1">typedef struct rd_kafka_ConfigResource_s rd_kafka_ConfigResource_t;</span>
<span class="s1">rd_kafka_ConfigResource_t *rd_kafka_ConfigResource_new(rd_kafka_ResourceType_t restype, const char *resname);</span>
<span class="s1">void rd_kafka_ConfigResource_destroy(rd_kafka_ConfigResource_t *config);</span>
<span class="s1">void rd_kafka_ConfigResource_destroy_array(rd_kafka_ConfigResource_t **config, size_t config_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_ConfigResource_set_config(rd_kafka_ConfigResource_t *config, const char *name, const char *value);</span>
<span class="s1">const rd_kafka_ConfigEntry_t **rd_kafka_ConfigResource_configs(const rd_kafka_ConfigResource_t *config, size_t *cntp);</span>
<span class="s1">rd_kafka_ResourceType_t rd_kafka_ConfigResource_type(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">const char *rd_kafka_ConfigResource_name(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_ConfigResource_error(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">const char *rd_kafka_ConfigResource_error_string(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">void rd_kafka_AlterConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_ConfigResource_t **rd_kafka_AlterConfigs_result_resources(const rd_kafka_AlterConfigs_result_t *result, size_t *cntp);</span>
<span class="s1">void rd_kafka_DescribeConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_ConfigResource_t **rd_kafka_DescribeConfigs_result_resources(const rd_kafka_DescribeConfigs_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_DeleteRecords_s rd_kafka_DeleteRecords_t;</span>
<span class="s1">rd_kafka_DeleteRecords_t *rd_kafka_DeleteRecords_new(const rd_kafka_topic_partition_list_t *before_offsets);</span>
<span class="s1">void rd_kafka_DeleteRecords_destroy(rd_kafka_DeleteRecords_t *del_records);</span>
<span class="s1">void rd_kafka_DeleteRecords_destroy_array(rd_kafka_DeleteRecords_t **del_records, size_t del_record_cnt);</span>
<span class="s1">void rd_kafka_DeleteRecords(rd_kafka_t *rk, rd_kafka_DeleteRecords_t **del_records, size_t del_record_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_partition_list_t *rd_kafka_DeleteRecords_result_offsets(const rd_kafka_DeleteRecords_result_t *result);</span>
<span class="s1">typedef struct rd_kafka_DeleteGroup_s rd_kafka_DeleteGroup_t;</span>
<span class="s1">rd_kafka_DeleteGroup_t *rd_kafka_DeleteGroup_new(const char *group);</span>
<span class="s1">void rd_kafka_DeleteGroup_destroy(rd_kafka_DeleteGroup_t *del_group);</span>
<span class="s1">void rd_kafka_DeleteGroup_destroy_array(rd_kafka_DeleteGroup_t **del_groups, size_t del_group_cnt);</span>
<span class="s1">void rd_kafka_DeleteGroups(rd_kafka_t *rk, rd_kafka_DeleteGroup_t **del_groups, size_t del_group_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_group_result_t **rd_kafka_DeleteGroups_result_groups(const rd_kafka_DeleteGroups_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_DeleteConsumerGroupOffsets_s rd_kafka_DeleteConsumerGroupOffsets_t;</span>
<span class="s1">rd_kafka_DeleteConsumerGroupOffsets_t *rd_kafka_DeleteConsumerGroupOffsets_new(const char *group, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">void rd_kafka_DeleteConsumerGroupOffsets_destroy(rd_kafka_DeleteConsumerGroupOffsets_t *del_grpoffsets);</span>
<span class="s1">void rd_kafka_DeleteConsumerGroupOffsets_destroy_array(rd_kafka_DeleteConsumerGroupOffsets_t **del_grpoffsets, size_t del_grpoffset_cnt);</span>
<span class="s1">void rd_kafka_DeleteConsumerGroupOffsets(rd_kafka_t *rk, rd_kafka_DeleteConsumerGroupOffsets_t **del_grpoffsets, size_t del_grpoffsets_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_group_result_t **rd_kafka_DeleteConsumerGroupOffsets_result_groups(const rd_kafka_DeleteConsumerGroupOffsets_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_AclBinding_s rd_kafka_AclBinding_t;</span>
<span class="s1">typedef rd_kafka_AclBinding_t rd_kafka_AclBindingFilter_t;</span>
<span class="s1">const rd_kafka_error_t *rd_kafka_acl_result_error(const rd_kafka_acl_result_t *aclres);</span>
<span class="s1">typedef enum rd_kafka_AclOperation_t {</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_UNKNOWN = 0,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_ANY = 1,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_ALL = 2,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_READ = 3,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_WRITE = 4,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_CREATE = 5,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_DELETE = 6,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_ALTER = 7,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_DESCRIBE = 8,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_CLUSTER_ACTION = 9,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_DESCRIBE_CONFIGS = 10,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_ALTER_CONFIGS = 11,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_IDEMPOTENT_WRITE = 12,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION__CNT,</span>
<span class="s1">} rd_kafka_AclOperation_t;</span>
<span class="s1">const char *rd_kafka_AclOperation_name(rd_kafka_AclOperation_t acl_operation);</span>
<span class="s1">typedef enum rd_kafka_AclPermissionType_t {</span>
<span class="s1">  RD_KAFKA_ACL_PERMISSION_TYPE_UNKNOWN = 0,</span>
<span class="s1">  RD_KAFKA_ACL_PERMISSION_TYPE_ANY = 1,</span>
<span class="s1">  RD_KAFKA_ACL_PERMISSION_TYPE_DENY = 2,</span>
<span class="s1">  RD_KAFKA_ACL_PERMISSION_TYPE_ALLOW = 3,</span>
<span class="s1">  RD_KAFKA_ACL_PERMISSION_TYPE__CNT,</span>
<span class="s1">} rd_kafka_AclPermissionType_t;</span>
<span class="s1">const char *rd_kafka_AclPermissionType_name(rd_kafka_AclPermissionType_t acl_permission_type);</span>
<span class="s1">rd_kafka_AclBinding_t *rd_kafka_AclBinding_new(rd_kafka_ResourceType_t restype, const char *name, rd_kafka_ResourcePatternType_t resource_pattern_type, const char *principal, const char *host, rd_kafka_AclOperation_t operation, rd_kafka_AclPermissionType_t permission_type, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_AclBindingFilter_t *rd_kafka_AclBindingFilter_new(rd_kafka_ResourceType_t restype, const char *name, rd_kafka_ResourcePatternType_t resource_pattern_type, const char *principal, const char *host, rd_kafka_AclOperation_t operation, rd_kafka_AclPermissionType_t permission_type, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_ResourceType_t rd_kafka_AclBinding_restype(const rd_kafka_AclBinding_t *acl);</span>
<span class="s1">const char *rd_kafka_AclBinding_name(const rd_kafka_AclBinding_t *acl);</span>
<span class="s1">const char *rd_kafka_AclBinding_principal(const rd_kafka_AclBinding_t *acl);</span>
<span class="s1">const char *rd_kafka_AclBinding_host(const rd_kafka_AclBinding_t *acl);</span>
<span class="s1">rd_kafka_AclOperation_t rd_kafka_AclBinding_operation(const rd_kafka_AclBinding_t *acl);</span>
<span class="s1">rd_kafka_AclPermissionType_t rd_kafka_AclBinding_permission_type(const rd_kafka_AclBinding_t *acl);</span>
<span class="s1">rd_kafka_ResourcePatternType_t rd_kafka_AclBinding_resource_pattern_type(const rd_kafka_AclBinding_t *acl);</span>
<span class="s1">const rd_kafka_error_t *rd_kafka_AclBinding_error(const rd_kafka_AclBinding_t *acl);</span>
<span class="s1">void rd_kafka_AclBinding_destroy(rd_kafka_AclBinding_t *acl_binding);</span>
<span class="s1">void rd_kafka_AclBinding_destroy_array(rd_kafka_AclBinding_t **acl_bindings, size_t acl_bindings_cnt);</span>
<span class="s1">const rd_kafka_acl_result_t **rd_kafka_CreateAcls_result_acls(const rd_kafka_CreateAcls_result_t *result, size_t *cntp);</span>
<span class="s1">void rd_kafka_CreateAcls(rd_kafka_t *rk, rd_kafka_AclBinding_t **new_acls, size_t new_acls_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_AclBinding_t **rd_kafka_DescribeAcls_result_acls(const rd_kafka_DescribeAcls_result_t *result, size_t *cntp);</span>
<span class="s1">void rd_kafka_DescribeAcls(rd_kafka_t *rk, rd_kafka_AclBindingFilter_t *acl_filter, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">typedef struct rd_kafka_DeleteAcls_result_response_s rd_kafka_DeleteAcls_result_response_t;</span>
<span class="s1">const rd_kafka_DeleteAcls_result_response_t **rd_kafka_DeleteAcls_result_responses(const rd_kafka_DeleteAcls_result_t *result, size_t *cntp);</span>
<span class="s1">const rd_kafka_error_t *rd_kafka_DeleteAcls_result_response_error(const rd_kafka_DeleteAcls_result_response_t *result_response);</span>
<span class="s1">const rd_kafka_AclBinding_t **rd_kafka_DeleteAcls_result_response_matching_acls(const rd_kafka_DeleteAcls_result_response_t *result_response, size_t *matching_acls_cntp);</span>
<span class="s1">void rd_kafka_DeleteAcls(rd_kafka_t *rk, rd_kafka_AclBindingFilter_t **del_acls, size_t del_acls_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token(rd_kafka_t *rk, const char *token_value, int64_t md_lifetime_ms, const char *md_principal_name, const char **extensions, size_t extension_size, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token_failure(rd_kafka_t *rk, const char *errstr);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_init_transactions(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_begin_transaction(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_send_offsets_to_transaction(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, const rd_kafka_consumer_group_metadata_t *cgmetadata, int timeout_ms);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_commit_transaction(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_abort_transaction(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">typedef struct rd_kafka_mock_cluster_s rd_kafka_mock_cluster_t;</span>
<span class="s1">rd_kafka_mock_cluster_t *rd_kafka_mock_cluster_new(rd_kafka_t *rk, int broker_cnt);</span>
<span class="s1">void rd_kafka_mock_cluster_destroy(rd_kafka_mock_cluster_t *mcluster);</span>
<span class="s1">rd_kafka_t *rd_kafka_mock_cluster_handle(const rd_kafka_mock_cluster_t *mcluster);</span>
<span class="s1">rd_kafka_mock_cluster_t *rd_kafka_handle_mock_cluster(const rd_kafka_t *rk);</span>
<span class="s1">const char *rd_kafka_mock_cluster_bootstraps(const rd_kafka_mock_cluster_t *mcluster);</span>
<span class="s1">void rd_kafka_mock_clear_request_errors(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey);</span>
<span class="s1">void rd_kafka_mock_push_request_errors(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, size_t cnt, ...);</span>
<span class="s1">void rd_kafka_mock_push_request_errors_array(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, size_t cnt, const rd_kafka_resp_err_t *errors);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_push_request_error_rtts(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int16_t ApiKey, size_t cnt, ...);</span>
<span class="s1">void rd_kafka_mock_topic_set_error(rd_kafka_mock_cluster_t *mcluster, const char *topic, rd_kafka_resp_err_t err);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_topic_create(rd_kafka_mock_cluster_t *mcluster, const char *topic, int partition_cnt, int replication_factor);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_partition_set_leader(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_partition_set_follower(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_partition_set_follower_wmarks(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int64_t lo, int64_t hi);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_set_down(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_set_up(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_set_rtt(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int rtt_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_set_rack(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, const char *rack);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_coordinator_set(rd_kafka_mock_cluster_t *mcluster, const char *key_type, const char *key, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_set_apiversion(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, int16_t MinVersion, int16_t MaxVersion);</span>
<span class="s1">&#39;</span>
</code></pre></div>
rdkafka.h, rdkafka_mock.h</p>
<h3 id="rd_kafka_version_22">RD_KAFKA_VERSION<a class="headerlink" href="#rd_kafka_version_22" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_VERSION</span> <span class="o">=</span> <span class="mi">33554687</span>
</code></pre></div>
<p>librdkafka version </p>
<p>Interpreted as hex <code>MM.mm.rr.xx</code>:</p>
<ul>
<li>MM = Major</li>
<li>mm = minor</li>
<li>rr = revision</li>
<li>xx = pre-release id (0xff is the final release)</li>
</ul>
<p>E.g.: <code>0x000801ff</code> = 0.8.1</p>
<dl class="section remark"><dt>Remarks</dt><dd>This value should only be used during compile time, for runtime checks of version use rd_kafka_version() </dd></dl>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_unsupported_compression_type_22">RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE<a class="headerlink" href="#rd_kafka_resp_err_unsupported_compression_type_22" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE</span> <span class="o">=</span> <span class="mi">76</span>
</code></pre></div>
<p>Unsupported compression type </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_end_all_22">RD_KAFKA_RESP_ERR_END_ALL<a class="headerlink" href="#rd_kafka_resp_err_end_all_22" title="Permanent link">&para;</a></h3>
<p><div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_END_ALL</span> <span class="o">=</span> <span class="mi">98</span>
</code></pre></div>
enum rd_kafka_resp_err_t</p>
<h3 id="rd_kafka_admin_op__cnt_22">RD_KAFKA_ADMIN_OP__CNT<a class="headerlink" href="#rd_kafka_admin_op__cnt_22" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_ADMIN_OP__CNT</span> <span class="o">=</span> <span class="mi">16</span>
</code></pre></div>
<p>Number of ops defined </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe </a></li>
</ul>
</div>
<h3 id="rd_kafka_resource__cnt_22">RD_KAFKA_RESOURCE__CNT<a class="headerlink" href="#rd_kafka_resource__cnt_22" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESOURCE__CNT</span> <span class="o">=</span> <span class="mi">5</span>
</code></pre></div>
<p>Number of resource types defined </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#acca83a66d7783ff7683ed2691cc907c9"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#acca83a66d7783ff7683ed2691cc907c9 </a></li>
</ul>
</div>
<h3 id="rd_kafka_cdef_22">RD_KAFKA_CDEF<a class="headerlink" href="#rd_kafka_cdef_22" title="Permanent link">&para;</a></h3>
<p><div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_CDEF</span> <span class="o">=</span> <span class="s1">&#39;typedef long int ssize_t;</span>
<span class="s1">typedef struct _IO_FILE FILE;</span>
<span class="s1">typedef long int mode_t;</span>
<span class="s1">typedef signed int int16_t;</span>
<span class="s1">typedef unsigned int uint16_t;</span>
<span class="s1">typedef signed int int32_t;</span>
<span class="s1">typedef signed long int int64_t;</span>
<span class="s1">int rd_kafka_version(void);</span>
<span class="s1">const char *rd_kafka_version_str(void);</span>
<span class="s1">typedef enum rd_kafka_type_t {</span>
<span class="s1">  RD_KAFKA_PRODUCER,</span>
<span class="s1">  RD_KAFKA_CONSUMER,</span>
<span class="s1">} rd_kafka_type_t;</span>
<span class="s1">typedef enum rd_kafka_timestamp_type_t {</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_NOT_AVAILABLE,</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_CREATE_TIME,</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_LOG_APPEND_TIME,</span>
<span class="s1">} rd_kafka_timestamp_type_t;</span>
<span class="s1">const char *rd_kafka_get_debug_contexts(void);</span>
<span class="s1">typedef struct rd_kafka_s rd_kafka_t;</span>
<span class="s1">typedef struct rd_kafka_topic_s rd_kafka_topic_t;</span>
<span class="s1">typedef struct rd_kafka_conf_s rd_kafka_conf_t;</span>
<span class="s1">typedef struct rd_kafka_topic_conf_s rd_kafka_topic_conf_t;</span>
<span class="s1">typedef struct rd_kafka_queue_s rd_kafka_queue_t;</span>
<span class="s1">typedef struct rd_kafka_op_s rd_kafka_event_t;</span>
<span class="s1">typedef struct rd_kafka_topic_result_s rd_kafka_topic_result_t;</span>
<span class="s1">typedef struct rd_kafka_consumer_group_metadata_s rd_kafka_consumer_group_metadata_t;</span>
<span class="s1">typedef struct rd_kafka_error_s {</span>
<span class="s1">  unsigned int code;</span>
<span class="s1">  char *errstr;</span>
<span class="s1">  unsigned char fatal;</span>
<span class="s1">  unsigned char retriable;</span>
<span class="s1">  unsigned char txn_requires_abort;</span>
<span class="s1">} rd_kafka_error_t;</span>
<span class="s1">typedef struct rd_kafka_headers_s rd_kafka_headers_t;</span>
<span class="s1">typedef struct rd_kafka_group_result_s rd_kafka_group_result_t;</span>
<span class="s1">typedef struct rd_kafka_acl_result_s rd_kafka_acl_result_t;</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BEGIN = (- 200),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BAD_MSG = (- 199),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BAD_COMPRESSION = (- 198),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__DESTROY = (- 197),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FAIL = (- 196),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TRANSPORT = (- 195),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__CRIT_SYS_RESOURCE = (- 194),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__RESOLVE = (- 193),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__MSG_TIMED_OUT = (- 192),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PARTITION_EOF = (- 191),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION = (- 190),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FS = (- 189),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC = (- 188),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ALL_BROKERS_DOWN = (- 187),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INVALID_ARG = (- 186),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TIMED_OUT = (- 185),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__QUEUE_FULL = (- 184),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ISR_INSUFF = (- 183),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NODE_UPDATE = (- 182),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__SSL = (- 181),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__WAIT_COORD = (- 180),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_GROUP = (- 179),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__IN_PROGRESS = (- 178),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PREV_IN_PROGRESS = (- 177),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__EXISTING_SUBSCRIPTION = (- 176),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS = (- 175),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS = (- 174),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__CONFLICT = (- 173),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__STATE = (- 172),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_PROTOCOL = (- 171),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED = (- 170),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__AUTHENTICATION = (- 169),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NO_OFFSET = (- 168),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__OUTDATED = (- 167),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TIMED_OUT_QUEUE = (- 166),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNSUPPORTED_FEATURE = (- 165),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__WAIT_CACHE = (- 164),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INTR = (- 163),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__KEY_SERIALIZATION = (- 162),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__VALUE_SERIALIZATION = (- 161),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__KEY_DESERIALIZATION = (- 160),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__VALUE_DESERIALIZATION = (- 159),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PARTIAL = (- 158),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__READ_ONLY = (- 157),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOENT = (- 156),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNDERFLOW = (- 155),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INVALID_TYPE = (- 154),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__RETRY = (- 153),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PURGE_QUEUE = (- 152),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PURGE_INFLIGHT = (- 151),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FATAL = (- 150),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INCONSISTENT = (- 149),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__GAPLESS_GUARANTEE = (- 148),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__MAX_POLL_EXCEEDED = (- 147),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_BROKER = (- 146),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOT_CONFIGURED = (- 145),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FENCED = (- 144),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__APPLICATION = (- 143),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ASSIGNMENT_LOST = (- 142),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOOP = (- 141),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__AUTO_OFFSET_RESET = (- 140),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__END = (- 100),</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN = (- 1),</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NO_ERROR = 0,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_OUT_OF_RANGE = 1,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_MSG = 2,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART = 3,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_MSG_SIZE = 4,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE = 5,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_LEADER_FOR_PARTITION = 6,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REQUEST_TIMED_OUT = 7,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_BROKER_NOT_AVAILABLE = 8,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REPLICA_NOT_AVAILABLE = 9,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE = 10,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_STALE_CTRL_EPOCH = 11,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_METADATA_TOO_LARGE = 12,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NETWORK_EXCEPTION = 13,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_COORDINATOR_LOAD_IN_PROGRESS = 14,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_COORDINATOR_NOT_AVAILABLE = 15,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_COORDINATOR = 16,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_EXCEPTION = 17,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_RECORD_LIST_TOO_LARGE = 18,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS = 19,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS_AFTER_APPEND = 20,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REQUIRED_ACKS = 21,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ILLEGAL_GENERATION = 22,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INCONSISTENT_GROUP_PROTOCOL = 23,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_GROUP_ID = 24,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_MEMBER_ID = 25,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_SESSION_TIMEOUT = 26,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REBALANCE_IN_PROGRESS = 27,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_COMMIT_OFFSET_SIZE = 28,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_AUTHORIZATION_FAILED = 29,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_AUTHORIZATION_FAILED = 30,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_CLUSTER_AUTHORIZATION_FAILED = 31,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TIMESTAMP = 32,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_SASL_MECHANISM = 33,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ILLEGAL_SASL_STATE = 34,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_VERSION = 35,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_ALREADY_EXISTS = 36,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PARTITIONS = 37,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REPLICATION_FACTOR = 38,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REPLICA_ASSIGNMENT = 39,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_CONFIG = 40,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_CONTROLLER = 41,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REQUEST = 42,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_FOR_MESSAGE_FORMAT = 43,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_POLICY_VIOLATION = 44,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OUT_OF_ORDER_SEQUENCE_NUMBER = 45,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DUPLICATE_SEQUENCE_NUMBER = 46,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_EPOCH = 47,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TXN_STATE = 48,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_ID_MAPPING = 49,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TRANSACTION_TIMEOUT = 50,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_CONCURRENT_TRANSACTIONS = 51,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TRANSACTION_COORDINATOR_FENCED = 52,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TRANSACTIONAL_ID_AUTHORIZATION_FAILED = 53,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_SECURITY_DISABLED = 54,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OPERATION_NOT_ATTEMPTED = 55,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_KAFKA_STORAGE_ERROR = 56,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LOG_DIR_NOT_FOUND = 57,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_SASL_AUTHENTICATION_FAILED = 58,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_PRODUCER_ID = 59,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REASSIGNMENT_IN_PROGRESS = 60,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTH_DISABLED = 61,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_NOT_FOUND = 62,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_OWNER_MISMATCH = 63,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_REQUEST_NOT_ALLOWED = 64,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTHORIZATION_FAILED = 65,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_EXPIRED = 66,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRINCIPAL_TYPE = 67,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NON_EMPTY_GROUP = 68,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_ID_NOT_FOUND = 69,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FETCH_SESSION_ID_NOT_FOUND = 70,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_FETCH_SESSION_EPOCH = 71,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LISTENER_NOT_FOUND = 72,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_DELETION_DISABLED = 73,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FENCED_LEADER_EPOCH = 74,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_LEADER_EPOCH = 75,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_STALE_BROKER_EPOCH = 77,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_NOT_AVAILABLE = 78,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_MEMBER_ID_REQUIRED = 79,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_PREFERRED_LEADER_NOT_AVAILABLE = 80,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_MAX_SIZE_REACHED = 81,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FENCED_INSTANCE_ID = 82,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ELIGIBLE_LEADERS_NOT_AVAILABLE = 83,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ELECTION_NOT_NEEDED = 84,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NO_REASSIGNMENT_IN_PROGRESS = 85,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_SUBSCRIBED_TO_TOPIC = 86,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_RECORD = 87,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSTABLE_OFFSET_COMMIT = 88,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_THROTTLING_QUOTA_EXCEEDED = 89,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_PRODUCER_FENCED = 90,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_RESOURCE_NOT_FOUND = 91,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DUPLICATE_RESOURCE = 92,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNACCEPTABLE_CREDENTIAL = 93,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INCONSISTENT_VOTER_SET = 94,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_UPDATE_VERSION = 95,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FEATURE_UPDATE_FAILED = 96,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_PRINCIPAL_DESERIALIZATION_FAILURE = 97,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_END_ALL,</span>
<span class="s1">} rd_kafka_resp_err_t;</span>
<span class="s1">struct rd_kafka_err_desc {</span>
<span class="s1">  rd_kafka_resp_err_t code;</span>
<span class="s1">  char *name;</span>
<span class="s1">  char *desc;</span>
<span class="s1">};</span>
<span class="s1">void rd_kafka_get_err_descs(const struct rd_kafka_err_desc **errdescs, size_t *cntp);</span>
<span class="s1">const char *rd_kafka_err2str(rd_kafka_resp_err_t err);</span>
<span class="s1">const char *rd_kafka_err2name(rd_kafka_resp_err_t err);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_last_error(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_errno2err(int errnox);</span>
<span class="s1">int rd_kafka_errno(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_fatal_error(rd_kafka_t *rk, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_test_fatal_error(rd_kafka_t *rk, rd_kafka_resp_err_t err, const char *reason);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_error_code(const rd_kafka_error_t *error);</span>
<span class="s1">const char *rd_kafka_error_name(const rd_kafka_error_t *error);</span>
<span class="s1">const char *rd_kafka_error_string(const rd_kafka_error_t *error);</span>
<span class="s1">int rd_kafka_error_is_fatal(const rd_kafka_error_t *error);</span>
<span class="s1">int rd_kafka_error_is_retriable(const rd_kafka_error_t *error);</span>
<span class="s1">int rd_kafka_error_txn_requires_abort(const rd_kafka_error_t *error);</span>
<span class="s1">void rd_kafka_error_destroy(rd_kafka_error_t *error);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_error_new(rd_kafka_resp_err_t code, const char *fmt, ...);</span>
<span class="s1">typedef struct rd_kafka_topic_partition_s {</span>
<span class="s1">  char *topic;</span>
<span class="s1">  int32_t partition;</span>
<span class="s1">  int64_t offset;</span>
<span class="s1">  void *metadata;</span>
<span class="s1">  size_t metadata_size;</span>
<span class="s1">  void *opaque;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  void *_private;</span>
<span class="s1">} rd_kafka_topic_partition_t;</span>
<span class="s1">void rd_kafka_topic_partition_destroy(rd_kafka_topic_partition_t *rktpar);</span>
<span class="s1">typedef struct rd_kafka_topic_partition_list_s {</span>
<span class="s1">  int cnt;</span>
<span class="s1">  int size;</span>
<span class="s1">  rd_kafka_topic_partition_t *elems;</span>
<span class="s1">} rd_kafka_topic_partition_list_t;</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_new(int size);</span>
<span class="s1">void rd_kafka_topic_partition_list_destroy(rd_kafka_topic_partition_list_t *rkparlist);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_add(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">void rd_kafka_topic_partition_list_add_range(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t start, int32_t stop);</span>
<span class="s1">int rd_kafka_topic_partition_list_del(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">int rd_kafka_topic_partition_list_del_by_idx(rd_kafka_topic_partition_list_t *rktparlist, int idx);</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_copy(const rd_kafka_topic_partition_list_t *src);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_topic_partition_list_set_offset(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition, int64_t offset);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_find(const rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">void rd_kafka_topic_partition_list_sort(rd_kafka_topic_partition_list_t *rktparlist, int (*cmp)(const void *a, const void *b, void *cmp_opaque), void *cmp_opaque);</span>
<span class="s1">typedef enum rd_kafka_vtype_t {</span>
<span class="s1">  RD_KAFKA_VTYPE_END,</span>
<span class="s1">  RD_KAFKA_VTYPE_TOPIC,</span>
<span class="s1">  RD_KAFKA_VTYPE_RKT,</span>
<span class="s1">  RD_KAFKA_VTYPE_PARTITION,</span>
<span class="s1">  RD_KAFKA_VTYPE_VALUE,</span>
<span class="s1">  RD_KAFKA_VTYPE_KEY,</span>
<span class="s1">  RD_KAFKA_VTYPE_OPAQUE,</span>
<span class="s1">  RD_KAFKA_VTYPE_MSGFLAGS,</span>
<span class="s1">  RD_KAFKA_VTYPE_TIMESTAMP,</span>
<span class="s1">  RD_KAFKA_VTYPE_HEADER,</span>
<span class="s1">  RD_KAFKA_VTYPE_HEADERS,</span>
<span class="s1">} rd_kafka_vtype_t;</span>
<span class="s1">typedef struct rd_kafka_vu_s {</span>
<span class="s1">  rd_kafka_vtype_t vtype;</span>
<span class="s1">  union {</span>
<span class="s1">    char *cstr;</span>
<span class="s1">    rd_kafka_topic_t *rkt;</span>
<span class="s1">    int i;</span>
<span class="s1">    int32_t i32;</span>
<span class="s1">    int64_t i64;</span>
<span class="s1">    struct {</span>
<span class="s1">      void *ptr;</span>
<span class="s1">      size_t size;</span>
<span class="s1">    } mem;</span>
<span class="s1">    struct {</span>
<span class="s1">      char *name;</span>
<span class="s1">      void *val;</span>
<span class="s1">      ssize_t size;</span>
<span class="s1">    } header;</span>
<span class="s1">    rd_kafka_headers_t *headers;</span>
<span class="s1">    void *ptr;</span>
<span class="s1">    char _pad[64];</span>
<span class="s1">  } u;</span>
<span class="s1">} rd_kafka_vu_t;</span>
<span class="s1">rd_kafka_headers_t *rd_kafka_headers_new(size_t initial_count);</span>
<span class="s1">void rd_kafka_headers_destroy(rd_kafka_headers_t *hdrs);</span>
<span class="s1">rd_kafka_headers_t *rd_kafka_headers_copy(const rd_kafka_headers_t *src);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_add(rd_kafka_headers_t *hdrs, const char *name, ssize_t name_size, const void *value, ssize_t value_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_remove(rd_kafka_headers_t *hdrs, const char *name);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get_last(const rd_kafka_headers_t *hdrs, const char *name, const void **valuep, size_t *sizep);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get(const rd_kafka_headers_t *hdrs, size_t idx, const char *name, const void **valuep, size_t *sizep);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get_all(const rd_kafka_headers_t *hdrs, size_t idx, const char **namep, const void **valuep, size_t *sizep);</span>
<span class="s1">typedef struct rd_kafka_message_s {</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  rd_kafka_topic_t *rkt;</span>
<span class="s1">  int32_t partition;</span>
<span class="s1">  void *payload;</span>
<span class="s1">  size_t len;</span>
<span class="s1">  void *key;</span>
<span class="s1">  size_t key_len;</span>
<span class="s1">  int64_t offset;</span>
<span class="s1">  void *_private;</span>
<span class="s1">} rd_kafka_message_t;</span>
<span class="s1">void rd_kafka_message_destroy(rd_kafka_message_t *rkmessage);</span>
<span class="s1">const char *rd_kafka_message_errstr(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">int64_t rd_kafka_message_timestamp(const rd_kafka_message_t *rkmessage, rd_kafka_timestamp_type_t *tstype);</span>
<span class="s1">int64_t rd_kafka_message_latency(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">int32_t rd_kafka_message_broker_id(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_message_headers(const rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_message_detach_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);</span>
<span class="s1">void rd_kafka_message_set_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t *hdrs);</span>
<span class="s1">size_t rd_kafka_header_cnt(const rd_kafka_headers_t *hdrs);</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_NOT_PERSISTED = 0,</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_POSSIBLY_PERSISTED = 1,</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_PERSISTED = 2,</span>
<span class="s1">} rd_kafka_msg_status_t;</span>
<span class="s1">rd_kafka_msg_status_t rd_kafka_message_status(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_CONF_UNKNOWN = (- 2),</span>
<span class="s1">  RD_KAFKA_CONF_INVALID = (- 1),</span>
<span class="s1">  RD_KAFKA_CONF_OK = 0,</span>
<span class="s1">} rd_kafka_conf_res_t;</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_new(void);</span>
<span class="s1">void rd_kafka_conf_destroy(rd_kafka_conf_t *conf);</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_dup(const rd_kafka_conf_t *conf);</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_dup_filter(const rd_kafka_conf_t *conf, size_t filter_cnt, const char **filter);</span>
<span class="s1">const rd_kafka_conf_t *rd_kafka_conf(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_set(rd_kafka_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_conf_set_events(rd_kafka_conf_t *conf, int events);</span>
<span class="s1">void rd_kafka_conf_set_background_event_cb(rd_kafka_conf_t *conf, void (*event_cb)(rd_kafka_t *rk, rd_kafka_event_t *rkev, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_dr_cb(rd_kafka_conf_t *conf, void (*dr_cb)(rd_kafka_t *rk, void *payload, size_t len, rd_kafka_resp_err_t err, void *opaque, void *msg_opaque));</span>
<span class="s1">void rd_kafka_conf_set_dr_msg_cb(rd_kafka_conf_t *conf, void (*dr_msg_cb)(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_consume_cb(rd_kafka_conf_t *conf, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_rebalance_cb(rd_kafka_conf_t *conf, void (*rebalance_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *partitions, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_offset_commit_cb(rd_kafka_conf_t *conf, void (*offset_commit_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_error_cb(rd_kafka_conf_t *conf, void (*error_cb)(rd_kafka_t *rk, int err, const char *reason, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_throttle_cb(rd_kafka_conf_t *conf, void (*throttle_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int throttle_time_ms, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_log_cb(rd_kafka_conf_t *conf, void (*log_cb)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));</span>
<span class="s1">void rd_kafka_conf_set_stats_cb(rd_kafka_conf_t *conf, int (*stats_cb)(rd_kafka_t *rk, char *json, size_t json_len, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_oauthbearer_token_refresh_cb(rd_kafka_conf_t *conf, void (*oauthbearer_token_refresh_cb)(rd_kafka_t *rk, const char *oauthbearer_config, void *opaque));</span>
<span class="s1">void rd_kafka_conf_enable_sasl_queue(rd_kafka_conf_t *conf, int enable);</span>
<span class="s1">void rd_kafka_conf_set_socket_cb(rd_kafka_conf_t *conf, int (*socket_cb)(int domain, int type, int protocol, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_connect_cb(rd_kafka_conf_t *conf, int (*connect_cb)(int sockfd, const struct sockaddr *addr, int addrlen, const char *id, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_closesocket_cb(rd_kafka_conf_t *conf, int (*closesocket_cb)(int sockfd, void *opaque));</span>
<span class="s1">struct addrinfo;</span>
<span class="s1">void rd_kafka_conf_set_resolve_cb(rd_kafka_conf_t *conf, int (*resolve_cb)(const char *node, const char *service, const struct addrinfo *hints, struct addrinfo **res, void *opaque));</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert_verify_cb(rd_kafka_conf_t *conf, int (*ssl_cert_verify_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int *x509_error, int depth, const char *buf, size_t size, char *errstr, size_t errstr_size, void *opaque));</span>
<span class="s1">typedef enum rd_kafka_cert_type_t {</span>
<span class="s1">  RD_KAFKA_CERT_PUBLIC_KEY,</span>
<span class="s1">  RD_KAFKA_CERT_PRIVATE_KEY,</span>
<span class="s1">  RD_KAFKA_CERT_CA,</span>
<span class="s1">  RD_KAFKA_CERT__CNT,</span>
<span class="s1">} rd_kafka_cert_type_t;</span>
<span class="s1">typedef enum rd_kafka_cert_enc_t {</span>
<span class="s1">  RD_KAFKA_CERT_ENC_PKCS12,</span>
<span class="s1">  RD_KAFKA_CERT_ENC_DER,</span>
<span class="s1">  RD_KAFKA_CERT_ENC_PEM,</span>
<span class="s1">  RD_KAFKA_CERT_ENC__CNT,</span>
<span class="s1">} rd_kafka_cert_enc_t;</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert(rd_kafka_conf_t *conf, rd_kafka_cert_type_t cert_type, rd_kafka_cert_enc_t cert_enc, const void *buffer, size_t size, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_conf_set_engine_callback_data(rd_kafka_conf_t *conf, void *callback_data);</span>
<span class="s1">void rd_kafka_conf_set_opaque(rd_kafka_conf_t *conf, void *opaque);</span>
<span class="s1">void *rd_kafka_opaque(const rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_conf_set_default_topic_conf(rd_kafka_conf_t *conf, rd_kafka_topic_conf_t *tconf);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_conf_get_default_topic_conf(rd_kafka_conf_t *conf);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_get(const rd_kafka_conf_t *conf, const char *name, char *dest, size_t *dest_size);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_topic_conf_get(const rd_kafka_topic_conf_t *conf, const char *name, char *dest, size_t *dest_size);</span>
<span class="s1">const char **rd_kafka_conf_dump(rd_kafka_conf_t *conf, size_t *cntp);</span>
<span class="s1">const char **rd_kafka_topic_conf_dump(rd_kafka_topic_conf_t *conf, size_t *cntp);</span>
<span class="s1">void rd_kafka_conf_dump_free(const char **arr, size_t cnt);</span>
<span class="s1">void rd_kafka_conf_properties_show(FILE *fp);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_topic_conf_new(void);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_topic_conf_dup(const rd_kafka_topic_conf_t *conf);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_default_topic_conf_dup(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_topic_conf_destroy(rd_kafka_topic_conf_t *topic_conf);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_topic_conf_set(rd_kafka_topic_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_topic_conf_set_opaque(rd_kafka_topic_conf_t *conf, void *rkt_opaque);</span>
<span class="s1">void rd_kafka_topic_conf_set_partitioner_cb(rd_kafka_topic_conf_t *topic_conf, int32_t (*partitioner)(const rd_kafka_topic_t *rkt, const void *keydata, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque));</span>
<span class="s1">void rd_kafka_topic_conf_set_msg_order_cmp(rd_kafka_topic_conf_t *topic_conf, int (*msg_order_cmp)(const rd_kafka_message_t *a, const rd_kafka_message_t *b));</span>
<span class="s1">int rd_kafka_topic_partition_available(const rd_kafka_topic_t *rkt, int32_t partition);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_consistent(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_consistent_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_murmur2(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_murmur2_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_fnv1a(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_fnv1a_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">rd_kafka_t *rd_kafka_new(rd_kafka_type_t type, rd_kafka_conf_t *conf, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_destroy(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_destroy_flags(rd_kafka_t *rk, int flags);</span>
<span class="s1">const char *rd_kafka_name(const rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_type_t rd_kafka_type(const rd_kafka_t *rk);</span>
<span class="s1">char *rd_kafka_memberid(const rd_kafka_t *rk);</span>
<span class="s1">char *rd_kafka_clusterid(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">int32_t rd_kafka_controllerid(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_topic_t *rd_kafka_topic_new(rd_kafka_t *rk, const char *topic, rd_kafka_topic_conf_t *conf);</span>
<span class="s1">void rd_kafka_topic_destroy(rd_kafka_topic_t *rkt);</span>
<span class="s1">const char *rd_kafka_topic_name(const rd_kafka_topic_t *rkt);</span>
<span class="s1">void *rd_kafka_topic_opaque(const rd_kafka_topic_t *rkt);</span>
<span class="s1">int rd_kafka_poll(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">void rd_kafka_yield(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_pause_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_resume_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_query_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_get_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offsets_for_times(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets, int timeout_ms);</span>
<span class="s1">void *rd_kafka_mem_calloc(rd_kafka_t *rk, size_t num, size_t size);</span>
<span class="s1">void *rd_kafka_mem_malloc(rd_kafka_t *rk, size_t size);</span>
<span class="s1">void rd_kafka_mem_free(rd_kafka_t *rk, void *ptr);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_new(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_queue_destroy(rd_kafka_queue_t *rkqu);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_main(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_sasl(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_sasl_background_callbacks_enable(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_sasl_set_credentials(rd_kafka_t *rk, const char *username, const char *password);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_consumer(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_partition(rd_kafka_t *rk, const char *topic, int32_t partition);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_background(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_queue_forward(rd_kafka_queue_t *src, rd_kafka_queue_t *dst);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_set_log_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu);</span>
<span class="s1">size_t rd_kafka_queue_length(rd_kafka_queue_t *rkqu);</span>
<span class="s1">void rd_kafka_queue_io_event_enable(rd_kafka_queue_t *rkqu, int fd, const void *payload, size_t size);</span>
<span class="s1">void rd_kafka_queue_cb_event_enable(rd_kafka_queue_t *rkqu, void (*event_cb)(rd_kafka_t *rk, void *qev_opaque), void *qev_opaque);</span>
<span class="s1">void rd_kafka_queue_yield(rd_kafka_queue_t *rkqu);</span>
<span class="s1">int rd_kafka_consume_start(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);</span>
<span class="s1">int rd_kafka_consume_start_queue(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, rd_kafka_queue_t *rkqu);</span>
<span class="s1">int rd_kafka_consume_stop(rd_kafka_topic_t *rkt, int32_t partition);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_seek(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, int timeout_ms);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_seek_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consume(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms);</span>
<span class="s1">ssize_t rd_kafka_consume_batch(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);</span>
<span class="s1">int rd_kafka_consume_callback(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consume_queue(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">ssize_t rd_kafka_consume_batch_queue(rd_kafka_queue_t *rkqu, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);</span>
<span class="s1">int rd_kafka_consume_callback_queue(rd_kafka_queue_t *rkqu, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offset_store(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offsets_store(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_subscribe(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *topics);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_unsubscribe(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_subscription(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **topics);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consumer_poll(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_consumer_close(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_consumer_close_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu);</span>
<span class="s1">int rd_kafka_consumer_closed(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_incremental_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_incremental_unassign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">const char *rd_kafka_rebalance_protocol(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_assignment(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **partitions);</span>
<span class="s1">int rd_kafka_assignment_lost(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, int async);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit_message(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, int async);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit_queue(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_queue_t *rkqu, void (*cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *commit_opaque), void *commit_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_committed(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_position(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata_new(const char *group_id);</span>
<span class="s1">rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata_new_with_genid(const char *group_id, int32_t generation_id, const char *member_id, const char *group_instance_id);</span>
<span class="s1">void rd_kafka_consumer_group_metadata_destroy(rd_kafka_consumer_group_metadata_t *);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_consumer_group_metadata_write(const rd_kafka_consumer_group_metadata_t *cgmd, void **bufferp, size_t *sizep);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_consumer_group_metadata_read(rd_kafka_consumer_group_metadata_t **cgmdp, const void *buffer, size_t size);</span>
<span class="s1">int rd_kafka_produce(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, void *payload, size_t len, const void *key, size_t keylen, void *msg_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_producev(rd_kafka_t *rk, ...);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_produceva(rd_kafka_t *rk, const rd_kafka_vu_t *vus, size_t cnt);</span>
<span class="s1">int rd_kafka_produce_batch(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, rd_kafka_message_t *rkmessages, int message_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_flush(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_purge(rd_kafka_t *rk, int purge_flags);</span>
<span class="s1">typedef struct rd_kafka_metadata_broker {</span>
<span class="s1">  int32_t id;</span>
<span class="s1">  char *host;</span>
<span class="s1">  int port;</span>
<span class="s1">} rd_kafka_metadata_broker_t;</span>
<span class="s1">typedef struct rd_kafka_metadata_partition {</span>
<span class="s1">  int32_t id;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  int32_t leader;</span>
<span class="s1">  int replica_cnt;</span>
<span class="s1">  int32_t *replicas;</span>
<span class="s1">  int isr_cnt;</span>
<span class="s1">  int32_t *isrs;</span>
<span class="s1">} rd_kafka_metadata_partition_t;</span>
<span class="s1">typedef struct rd_kafka_metadata_topic {</span>
<span class="s1">  char *topic;</span>
<span class="s1">  int partition_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_partition *partitions;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">} rd_kafka_metadata_topic_t;</span>
<span class="s1">typedef struct rd_kafka_metadata {</span>
<span class="s1">  int broker_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_broker *brokers;</span>
<span class="s1">  int topic_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_topic *topics;</span>
<span class="s1">  int32_t orig_broker_id;</span>
<span class="s1">  char *orig_broker_name;</span>
<span class="s1">} rd_kafka_metadata_t;</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_metadata(rd_kafka_t *rk, int all_topics, rd_kafka_topic_t *only_rkt, const struct rd_kafka_metadata **metadatap, int timeout_ms);</span>
<span class="s1">void rd_kafka_metadata_destroy(const struct rd_kafka_metadata *metadata);</span>
<span class="s1">typedef struct rd_kafka_Node_s rd_kafka_Node_t;</span>
<span class="s1">int rd_kafka_Node_id(const rd_kafka_Node_t *node);</span>
<span class="s1">const char *rd_kafka_Node_host(const rd_kafka_Node_t *node);</span>
<span class="s1">uint16_t rd_kafka_Node_port(const rd_kafka_Node_t *node);</span>
<span class="s1">struct rd_kafka_group_member_info {</span>
<span class="s1">  char *member_id;</span>
<span class="s1">  char *client_id;</span>
<span class="s1">  char *client_host;</span>
<span class="s1">  void *member_metadata;</span>
<span class="s1">  int member_metadata_size;</span>
<span class="s1">  void *member_assignment;</span>
<span class="s1">  int member_assignment_size;</span>
<span class="s1">};</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_CONSUMER_GROUP_STATE_UNKNOWN = 0,</span>
<span class="s1">  RD_KAFKA_CONSUMER_GROUP_STATE_PREPARING_REBALANCE = 1,</span>
<span class="s1">  RD_KAFKA_CONSUMER_GROUP_STATE_COMPLETING_REBALANCE = 2,</span>
<span class="s1">  RD_KAFKA_CONSUMER_GROUP_STATE_STABLE = 3,</span>
<span class="s1">  RD_KAFKA_CONSUMER_GROUP_STATE_DEAD = 4,</span>
<span class="s1">  RD_KAFKA_CONSUMER_GROUP_STATE_EMPTY = 5,</span>
<span class="s1">  RD_KAFKA_CONSUMER_GROUP_STATE__CNT,</span>
<span class="s1">} rd_kafka_consumer_group_state_t;</span>
<span class="s1">struct rd_kafka_group_info {</span>
<span class="s1">  struct rd_kafka_metadata_broker broker;</span>
<span class="s1">  char *group;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  char *state;</span>
<span class="s1">  char *protocol_type;</span>
<span class="s1">  char *protocol;</span>
<span class="s1">  struct rd_kafka_group_member_info *members;</span>
<span class="s1">  int member_cnt;</span>
<span class="s1">};</span>
<span class="s1">struct rd_kafka_group_list {</span>
<span class="s1">  struct rd_kafka_group_info *groups;</span>
<span class="s1">  int group_cnt;</span>
<span class="s1">};</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_list_groups(rd_kafka_t *rk, const char *group, const struct rd_kafka_group_list **grplistp, int timeout_ms);</span>
<span class="s1">const char *rd_kafka_consumer_group_state_name(rd_kafka_consumer_group_state_t state);</span>
<span class="s1">rd_kafka_consumer_group_state_t rd_kafka_consumer_group_state_code(const char *name);</span>
<span class="s1">void rd_kafka_group_list_destroy(const struct rd_kafka_group_list *grplist);</span>
<span class="s1">int rd_kafka_brokers_add(rd_kafka_t *rk, const char *brokerlist);</span>
<span class="s1">void rd_kafka_set_logger(rd_kafka_t *rk, void (*func)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));</span>
<span class="s1">void rd_kafka_set_log_level(rd_kafka_t *rk, int level);</span>
<span class="s1">void rd_kafka_log_print(const rd_kafka_t *rk, int level, const char *fac, const char *buf);</span>
<span class="s1">void rd_kafka_log_syslog(const rd_kafka_t *rk, int level, const char *fac, const char *buf);</span>
<span class="s1">int rd_kafka_outq_len(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_dump(FILE *fp, rd_kafka_t *rk);</span>
<span class="s1">int rd_kafka_thread_cnt(void);</span>
<span class="s1">typedef enum rd_kafka_thread_type_t {</span>
<span class="s1">  RD_KAFKA_THREAD_MAIN,</span>
<span class="s1">  RD_KAFKA_THREAD_BACKGROUND,</span>
<span class="s1">  RD_KAFKA_THREAD_BROKER,</span>
<span class="s1">} rd_kafka_thread_type_t;</span>
<span class="s1">int rd_kafka_wait_destroyed(int timeout_ms);</span>
<span class="s1">int rd_kafka_unittest(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_poll_set_consumer(rd_kafka_t *rk);</span>
<span class="s1">typedef int rd_kafka_event_type_t;</span>
<span class="s1">rd_kafka_event_type_t rd_kafka_event_type(const rd_kafka_event_t *rkev);</span>
<span class="s1">const char *rd_kafka_event_name(const rd_kafka_event_t *rkev);</span>
<span class="s1">void rd_kafka_event_destroy(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_message_t *rd_kafka_event_message_next(rd_kafka_event_t *rkev);</span>
<span class="s1">size_t rd_kafka_event_message_array(rd_kafka_event_t *rkev, const rd_kafka_message_t **rkmessages, size_t size);</span>
<span class="s1">size_t rd_kafka_event_message_count(rd_kafka_event_t *rkev);</span>
<span class="s1">const char *rd_kafka_event_config_string(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_event_error(rd_kafka_event_t *rkev);</span>
<span class="s1">const char *rd_kafka_event_error_string(rd_kafka_event_t *rkev);</span>
<span class="s1">int rd_kafka_event_error_is_fatal(rd_kafka_event_t *rkev);</span>
<span class="s1">void *rd_kafka_event_opaque(rd_kafka_event_t *rkev);</span>
<span class="s1">int rd_kafka_event_log(rd_kafka_event_t *rkev, const char **fac, const char **str, int *level);</span>
<span class="s1">int rd_kafka_event_debug_contexts(rd_kafka_event_t *rkev, char *dst, size_t dstsize);</span>
<span class="s1">const char *rd_kafka_event_stats(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_event_topic_partition_list(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_event_topic_partition(rd_kafka_event_t *rkev);</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_CreateTopics_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DeleteTopics_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_CreateAcls_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DescribeAcls_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DeleteAcls_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_CreatePartitions_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_AlterConfigs_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DescribeConfigs_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DeleteRecords_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_ListConsumerGroups_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DescribeConsumerGroups_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DeleteGroups_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DeleteConsumerGroupOffsets_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_AlterConsumerGroupOffsets_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_ListConsumerGroupOffsets_result_t;</span>
<span class="s1">const rd_kafka_CreateTopics_result_t *rd_kafka_event_CreateTopics_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DeleteTopics_result_t *rd_kafka_event_DeleteTopics_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_CreatePartitions_result_t *rd_kafka_event_CreatePartitions_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_AlterConfigs_result_t *rd_kafka_event_AlterConfigs_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DescribeConfigs_result_t *rd_kafka_event_DescribeConfigs_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DeleteRecords_result_t *rd_kafka_event_DeleteRecords_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_ListConsumerGroups_result_t *rd_kafka_event_ListConsumerGroups_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DescribeConsumerGroups_result_t *rd_kafka_event_DescribeConsumerGroups_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DeleteGroups_result_t *rd_kafka_event_DeleteGroups_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DeleteConsumerGroupOffsets_result_t *rd_kafka_event_DeleteConsumerGroupOffsets_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_CreateAcls_result_t *rd_kafka_event_CreateAcls_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DescribeAcls_result_t *rd_kafka_event_DescribeAcls_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DeleteAcls_result_t *rd_kafka_event_DeleteAcls_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_AlterConsumerGroupOffsets_result_t *rd_kafka_event_AlterConsumerGroupOffsets_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_ListConsumerGroupOffsets_result_t *rd_kafka_event_ListConsumerGroupOffsets_result(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_event_t *rd_kafka_queue_poll(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">int rd_kafka_queue_poll_callback(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_plugin_f_conf_init_t)(rd_kafka_conf_t *conf, void **plug_opaquep, char *errstr, size_t errstr_size);</span>
<span class="s1">typedef rd_kafka_conf_res_t (rd_kafka_interceptor_f_on_conf_set_t)(rd_kafka_conf_t *conf, const char *name, const char *val, char *errstr, size_t errstr_size, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_dup_t)(rd_kafka_conf_t *new_conf, const rd_kafka_conf_t *old_conf, size_t filter_cnt, const char **filter, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_destroy_t)(void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_new_t)(rd_kafka_t *rk, const rd_kafka_conf_t *conf, void *ic_opaque, char *errstr, size_t errstr_size);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_destroy_t)(rd_kafka_t *rk, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_send_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_acknowledgement_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_consume_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_commit_t)(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_resp_err_t err, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_request_sent_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_response_received_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, int64_t rtt, rd_kafka_resp_err_t err, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_start_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_exit_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_broker_state_change_t)(rd_kafka_t *rk, int32_t broker_id, const char *secproto, const char *name, int port, const char *state, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_set(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_set_t *on_conf_set, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_dup(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_dup_t *on_conf_dup, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_destroy(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_destroy_t *on_conf_destroy, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_new(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_new_t *on_new, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_destroy(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_destroy_t *on_destroy, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_send(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_send_t *on_send, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_acknowledgement(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_acknowledgement_t *on_acknowledgement, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_consume(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_consume_t *on_consume, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_commit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_commit_t *on_commit, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_request_sent(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_request_sent_t *on_request_sent, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_response_received(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_response_received_t *on_response_received, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_start(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_start_t *on_thread_start, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_exit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_exit_t *on_thread_exit, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_broker_state_change(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_broker_state_change_t *on_broker_state_change, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_topic_result_error(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">const char *rd_kafka_topic_result_error_string(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">const char *rd_kafka_topic_result_name(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">const rd_kafka_error_t *rd_kafka_group_result_error(const rd_kafka_group_result_t *groupres);</span>
<span class="s1">const char *rd_kafka_group_result_name(const rd_kafka_group_result_t *groupres);</span>
<span class="s1">const rd_kafka_topic_partition_list_t *rd_kafka_group_result_partitions(const rd_kafka_group_result_t *groupres);</span>
<span class="s1">typedef enum rd_kafka_admin_op_t {</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_ANY = 0,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_CREATETOPICS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DELETETOPICS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_CREATEPARTITIONS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_ALTERCONFIGS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DESCRIBECONFIGS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DELETERECORDS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DELETEGROUPS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DELETECONSUMERGROUPOFFSETS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_CREATEACLS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DESCRIBEACLS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DELETEACLS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_LISTCONSUMERGROUPS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DESCRIBECONSUMERGROUPS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_LISTCONSUMERGROUPOFFSETS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_ALTERCONSUMERGROUPOFFSETS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP__CNT,</span>
<span class="s1">} rd_kafka_admin_op_t;</span>
<span class="s1">typedef struct rd_kafka_AdminOptions_s rd_kafka_AdminOptions_t;</span>
<span class="s1">rd_kafka_AdminOptions_t *rd_kafka_AdminOptions_new(rd_kafka_t *rk, rd_kafka_admin_op_t for_api);</span>
<span class="s1">void rd_kafka_AdminOptions_destroy(rd_kafka_AdminOptions_t *options);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_request_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_operation_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_validate_only(rd_kafka_AdminOptions_t *options, int true_or_false, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_broker(rd_kafka_AdminOptions_t *options, int32_t broker_id, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_AdminOptions_set_require_stable_offsets(rd_kafka_AdminOptions_t *options, int true_or_false);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_AdminOptions_set_match_consumer_group_states(rd_kafka_AdminOptions_t *options, const rd_kafka_consumer_group_state_t *consumer_group_states, size_t consumer_group_states_cnt);</span>
<span class="s1">void rd_kafka_AdminOptions_set_opaque(rd_kafka_AdminOptions_t *options, void *ev_opaque);</span>
<span class="s1">typedef struct rd_kafka_NewTopic_s rd_kafka_NewTopic_t;</span>
<span class="s1">rd_kafka_NewTopic_t *rd_kafka_NewTopic_new(const char *topic, int num_partitions, int replication_factor, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_NewTopic_destroy(rd_kafka_NewTopic_t *new_topic);</span>
<span class="s1">void rd_kafka_NewTopic_destroy_array(rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewTopic_set_replica_assignment(rd_kafka_NewTopic_t *new_topic, int32_t partition, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewTopic_set_config(rd_kafka_NewTopic_t *new_topic, const char *name, const char *value);</span>
<span class="s1">void rd_kafka_CreateTopics(rd_kafka_t *rk, rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_CreateTopics_result_topics(const rd_kafka_CreateTopics_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_DeleteTopic_s rd_kafka_DeleteTopic_t;</span>
<span class="s1">rd_kafka_DeleteTopic_t *rd_kafka_DeleteTopic_new(const char *topic);</span>
<span class="s1">void rd_kafka_DeleteTopic_destroy(rd_kafka_DeleteTopic_t *del_topic);</span>
<span class="s1">void rd_kafka_DeleteTopic_destroy_array(rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt);</span>
<span class="s1">void rd_kafka_DeleteTopics(rd_kafka_t *rk, rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_DeleteTopics_result_topics(const rd_kafka_DeleteTopics_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_NewPartitions_s rd_kafka_NewPartitions_t;</span>
<span class="s1">rd_kafka_NewPartitions_t *rd_kafka_NewPartitions_new(const char *topic, size_t new_total_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_NewPartitions_destroy(rd_kafka_NewPartitions_t *new_parts);</span>
<span class="s1">void rd_kafka_NewPartitions_destroy_array(rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewPartitions_set_replica_assignment(rd_kafka_NewPartitions_t *new_parts, int32_t new_partition_idx, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_CreatePartitions(rd_kafka_t *rk, rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_CreatePartitions_result_topics(const rd_kafka_CreatePartitions_result_t *result, size_t *cntp);</span>
<span class="s1">typedef enum rd_kafka_ConfigSource_t {</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_UNKNOWN_CONFIG = 0,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_TOPIC_CONFIG = 1,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_BROKER_CONFIG = 2,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_DEFAULT_BROKER_CONFIG = 3,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_STATIC_BROKER_CONFIG = 4,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DEFAULT_CONFIG = 5,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE__CNT,</span>
<span class="s1">} rd_kafka_ConfigSource_t;</span>
<span class="s1">const char *rd_kafka_ConfigSource_name(rd_kafka_ConfigSource_t confsource);</span>
<span class="s1">typedef struct rd_kafka_ConfigEntry_s rd_kafka_ConfigEntry_t;</span>
<span class="s1">const char *rd_kafka_ConfigEntry_name(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">const char *rd_kafka_ConfigEntry_value(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">rd_kafka_ConfigSource_t rd_kafka_ConfigEntry_source(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_read_only(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_default(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_sensitive(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_synonym(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">const rd_kafka_ConfigEntry_t **rd_kafka_ConfigEntry_synonyms(const rd_kafka_ConfigEntry_t *entry, size_t *cntp);</span>
<span class="s1">typedef enum rd_kafka_ResourceType_t {</span>
<span class="s1">  RD_KAFKA_RESOURCE_UNKNOWN = 0,</span>
<span class="s1">  RD_KAFKA_RESOURCE_ANY = 1,</span>
<span class="s1">  RD_KAFKA_RESOURCE_TOPIC = 2,</span>
<span class="s1">  RD_KAFKA_RESOURCE_GROUP = 3,</span>
<span class="s1">  RD_KAFKA_RESOURCE_BROKER = 4,</span>
<span class="s1">  RD_KAFKA_RESOURCE__CNT,</span>
<span class="s1">} rd_kafka_ResourceType_t;</span>
<span class="s1">typedef enum rd_kafka_ResourcePatternType_t {</span>
<span class="s1">  RD_KAFKA_RESOURCE_PATTERN_UNKNOWN = 0,</span>
<span class="s1">  RD_KAFKA_RESOURCE_PATTERN_ANY = 1,</span>
<span class="s1">  RD_KAFKA_RESOURCE_PATTERN_MATCH = 2,</span>
<span class="s1">  RD_KAFKA_RESOURCE_PATTERN_LITERAL = 3,</span>
<span class="s1">  RD_KAFKA_RESOURCE_PATTERN_PREFIXED = 4,</span>
<span class="s1">  RD_KAFKA_RESOURCE_PATTERN_TYPE__CNT,</span>
<span class="s1">} rd_kafka_ResourcePatternType_t;</span>
<span class="s1">const char *rd_kafka_ResourcePatternType_name(rd_kafka_ResourcePatternType_t resource_pattern_type);</span>
<span class="s1">const char *rd_kafka_ResourceType_name(rd_kafka_ResourceType_t restype);</span>
<span class="s1">typedef struct rd_kafka_ConfigResource_s rd_kafka_ConfigResource_t;</span>
<span class="s1">rd_kafka_ConfigResource_t *rd_kafka_ConfigResource_new(rd_kafka_ResourceType_t restype, const char *resname);</span>
<span class="s1">void rd_kafka_ConfigResource_destroy(rd_kafka_ConfigResource_t *config);</span>
<span class="s1">void rd_kafka_ConfigResource_destroy_array(rd_kafka_ConfigResource_t **config, size_t config_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_ConfigResource_set_config(rd_kafka_ConfigResource_t *config, const char *name, const char *value);</span>
<span class="s1">const rd_kafka_ConfigEntry_t **rd_kafka_ConfigResource_configs(const rd_kafka_ConfigResource_t *config, size_t *cntp);</span>
<span class="s1">rd_kafka_ResourceType_t rd_kafka_ConfigResource_type(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">const char *rd_kafka_ConfigResource_name(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_ConfigResource_error(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">const char *rd_kafka_ConfigResource_error_string(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">void rd_kafka_AlterConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_ConfigResource_t **rd_kafka_AlterConfigs_result_resources(const rd_kafka_AlterConfigs_result_t *result, size_t *cntp);</span>
<span class="s1">void rd_kafka_DescribeConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_ConfigResource_t **rd_kafka_DescribeConfigs_result_resources(const rd_kafka_DescribeConfigs_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_DeleteRecords_s rd_kafka_DeleteRecords_t;</span>
<span class="s1">rd_kafka_DeleteRecords_t *rd_kafka_DeleteRecords_new(const rd_kafka_topic_partition_list_t *before_offsets);</span>
<span class="s1">void rd_kafka_DeleteRecords_destroy(rd_kafka_DeleteRecords_t *del_records);</span>
<span class="s1">void rd_kafka_DeleteRecords_destroy_array(rd_kafka_DeleteRecords_t **del_records, size_t del_record_cnt);</span>
<span class="s1">void rd_kafka_DeleteRecords(rd_kafka_t *rk, rd_kafka_DeleteRecords_t **del_records, size_t del_record_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_partition_list_t *rd_kafka_DeleteRecords_result_offsets(const rd_kafka_DeleteRecords_result_t *result);</span>
<span class="s1">typedef struct rd_kafka_ConsumerGroupListing_s rd_kafka_ConsumerGroupListing_t;</span>
<span class="s1">typedef struct rd_kafka_ListConsumerGroupsResult_s rd_kafka_ListConsumerGroupsResult_t;</span>
<span class="s1">void rd_kafka_ListConsumerGroups(rd_kafka_t *rk, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const char *rd_kafka_ConsumerGroupListing_group_id(const rd_kafka_ConsumerGroupListing_t *grplist);</span>
<span class="s1">int rd_kafka_ConsumerGroupListing_is_simple_consumer_group(const rd_kafka_ConsumerGroupListing_t *grplist);</span>
<span class="s1">rd_kafka_consumer_group_state_t rd_kafka_ConsumerGroupListing_state(const rd_kafka_ConsumerGroupListing_t *grplist);</span>
<span class="s1">const rd_kafka_ConsumerGroupListing_t **rd_kafka_ListConsumerGroups_result_valid(const rd_kafka_ListConsumerGroups_result_t *result, size_t *cntp);</span>
<span class="s1">const rd_kafka_error_t **rd_kafka_ListConsumerGroups_result_errors(const rd_kafka_ListConsumerGroups_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_ConsumerGroupDescription_s rd_kafka_ConsumerGroupDescription_t;</span>
<span class="s1">typedef struct rd_kafka_MemberDescription_s rd_kafka_MemberDescription_t;</span>
<span class="s1">typedef struct rd_kafka_MemberAssignment_s rd_kafka_MemberAssignment_t;</span>
<span class="s1">void rd_kafka_DescribeConsumerGroups(rd_kafka_t *rk, const char **groups, size_t groups_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_ConsumerGroupDescription_t **rd_kafka_DescribeConsumerGroups_result_groups(const rd_kafka_DescribeConsumerGroups_result_t *result, size_t *cntp);</span>
<span class="s1">const char *rd_kafka_ConsumerGroupDescription_group_id(const rd_kafka_ConsumerGroupDescription_t *grpdesc);</span>
<span class="s1">const rd_kafka_error_t *rd_kafka_ConsumerGroupDescription_error(const rd_kafka_ConsumerGroupDescription_t *grpdesc);</span>
<span class="s1">int rd_kafka_ConsumerGroupDescription_is_simple_consumer_group(const rd_kafka_ConsumerGroupDescription_t *grpdesc);</span>
<span class="s1">const char *rd_kafka_ConsumerGroupDescription_partition_assignor(const rd_kafka_ConsumerGroupDescription_t *grpdesc);</span>
<span class="s1">rd_kafka_consumer_group_state_t rd_kafka_ConsumerGroupDescription_state(const rd_kafka_ConsumerGroupDescription_t *grpdesc);</span>
<span class="s1">const rd_kafka_Node_t *rd_kafka_ConsumerGroupDescription_coordinator(const rd_kafka_ConsumerGroupDescription_t *grpdesc);</span>
<span class="s1">size_t rd_kafka_ConsumerGroupDescription_member_count(const rd_kafka_ConsumerGroupDescription_t *grpdesc);</span>
<span class="s1">const rd_kafka_MemberDescription_t *rd_kafka_ConsumerGroupDescription_member(const rd_kafka_ConsumerGroupDescription_t *grpdesc, size_t idx);</span>
<span class="s1">const char *rd_kafka_MemberDescription_client_id(const rd_kafka_MemberDescription_t *member);</span>
<span class="s1">const char *rd_kafka_MemberDescription_group_instance_id(const rd_kafka_MemberDescription_t *member);</span>
<span class="s1">const char *rd_kafka_MemberDescription_consumer_id(const rd_kafka_MemberDescription_t *member);</span>
<span class="s1">const char *rd_kafka_MemberDescription_host(const rd_kafka_MemberDescription_t *member);</span>
<span class="s1">const rd_kafka_MemberAssignment_t *rd_kafka_MemberDescription_assignment(const rd_kafka_MemberDescription_t *member);</span>
<span class="s1">const rd_kafka_topic_partition_list_t *rd_kafka_MemberAssignment_partitions(const rd_kafka_MemberAssignment_t *assignment);</span>
<span class="s1">typedef struct rd_kafka_DeleteGroup_s rd_kafka_DeleteGroup_t;</span>
<span class="s1">rd_kafka_DeleteGroup_t *rd_kafka_DeleteGroup_new(const char *group);</span>
<span class="s1">void rd_kafka_DeleteGroup_destroy(rd_kafka_DeleteGroup_t *del_group);</span>
<span class="s1">void rd_kafka_DeleteGroup_destroy_array(rd_kafka_DeleteGroup_t **del_groups, size_t del_group_cnt);</span>
<span class="s1">void rd_kafka_DeleteGroups(rd_kafka_t *rk, rd_kafka_DeleteGroup_t **del_groups, size_t del_group_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_group_result_t **rd_kafka_DeleteGroups_result_groups(const rd_kafka_DeleteGroups_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_ListConsumerGroupOffsets_s rd_kafka_ListConsumerGroupOffsets_t;</span>
<span class="s1">rd_kafka_ListConsumerGroupOffsets_t *rd_kafka_ListConsumerGroupOffsets_new(const char *group_id, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">void rd_kafka_ListConsumerGroupOffsets_destroy(rd_kafka_ListConsumerGroupOffsets_t *list_grpoffsets);</span>
<span class="s1">void rd_kafka_ListConsumerGroupOffsets_destroy_array(rd_kafka_ListConsumerGroupOffsets_t **list_grpoffsets, size_t list_grpoffset_cnt);</span>
<span class="s1">void rd_kafka_ListConsumerGroupOffsets(rd_kafka_t *rk, rd_kafka_ListConsumerGroupOffsets_t **list_grpoffsets, size_t list_grpoffsets_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_group_result_t **rd_kafka_ListConsumerGroupOffsets_result_groups(const rd_kafka_ListConsumerGroupOffsets_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_AlterConsumerGroupOffsets_s rd_kafka_AlterConsumerGroupOffsets_t;</span>
<span class="s1">rd_kafka_AlterConsumerGroupOffsets_t *rd_kafka_AlterConsumerGroupOffsets_new(const char *group_id, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">void rd_kafka_AlterConsumerGroupOffsets_destroy(rd_kafka_AlterConsumerGroupOffsets_t *alter_grpoffsets);</span>
<span class="s1">void rd_kafka_AlterConsumerGroupOffsets_destroy_array(rd_kafka_AlterConsumerGroupOffsets_t **alter_grpoffsets, size_t alter_grpoffset_cnt);</span>
<span class="s1">void rd_kafka_AlterConsumerGroupOffsets(rd_kafka_t *rk, rd_kafka_AlterConsumerGroupOffsets_t **alter_grpoffsets, size_t alter_grpoffsets_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_group_result_t **rd_kafka_AlterConsumerGroupOffsets_result_groups(const rd_kafka_AlterConsumerGroupOffsets_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_DeleteConsumerGroupOffsets_s rd_kafka_DeleteConsumerGroupOffsets_t;</span>
<span class="s1">rd_kafka_DeleteConsumerGroupOffsets_t *rd_kafka_DeleteConsumerGroupOffsets_new(const char *group, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">void rd_kafka_DeleteConsumerGroupOffsets_destroy(rd_kafka_DeleteConsumerGroupOffsets_t *del_grpoffsets);</span>
<span class="s1">void rd_kafka_DeleteConsumerGroupOffsets_destroy_array(rd_kafka_DeleteConsumerGroupOffsets_t **del_grpoffsets, size_t del_grpoffset_cnt);</span>
<span class="s1">void rd_kafka_DeleteConsumerGroupOffsets(rd_kafka_t *rk, rd_kafka_DeleteConsumerGroupOffsets_t **del_grpoffsets, size_t del_grpoffsets_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_group_result_t **rd_kafka_DeleteConsumerGroupOffsets_result_groups(const rd_kafka_DeleteConsumerGroupOffsets_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_AclBinding_s rd_kafka_AclBinding_t;</span>
<span class="s1">typedef rd_kafka_AclBinding_t rd_kafka_AclBindingFilter_t;</span>
<span class="s1">const rd_kafka_error_t *rd_kafka_acl_result_error(const rd_kafka_acl_result_t *aclres);</span>
<span class="s1">typedef enum rd_kafka_AclOperation_t {</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_UNKNOWN = 0,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_ANY = 1,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_ALL = 2,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_READ = 3,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_WRITE = 4,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_CREATE = 5,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_DELETE = 6,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_ALTER = 7,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_DESCRIBE = 8,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_CLUSTER_ACTION = 9,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_DESCRIBE_CONFIGS = 10,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_ALTER_CONFIGS = 11,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_IDEMPOTENT_WRITE = 12,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION__CNT,</span>
<span class="s1">} rd_kafka_AclOperation_t;</span>
<span class="s1">const char *rd_kafka_AclOperation_name(rd_kafka_AclOperation_t acl_operation);</span>
<span class="s1">typedef enum rd_kafka_AclPermissionType_t {</span>
<span class="s1">  RD_KAFKA_ACL_PERMISSION_TYPE_UNKNOWN = 0,</span>
<span class="s1">  RD_KAFKA_ACL_PERMISSION_TYPE_ANY = 1,</span>
<span class="s1">  RD_KAFKA_ACL_PERMISSION_TYPE_DENY = 2,</span>
<span class="s1">  RD_KAFKA_ACL_PERMISSION_TYPE_ALLOW = 3,</span>
<span class="s1">  RD_KAFKA_ACL_PERMISSION_TYPE__CNT,</span>
<span class="s1">} rd_kafka_AclPermissionType_t;</span>
<span class="s1">const char *rd_kafka_AclPermissionType_name(rd_kafka_AclPermissionType_t acl_permission_type);</span>
<span class="s1">rd_kafka_AclBinding_t *rd_kafka_AclBinding_new(rd_kafka_ResourceType_t restype, const char *name, rd_kafka_ResourcePatternType_t resource_pattern_type, const char *principal, const char *host, rd_kafka_AclOperation_t operation, rd_kafka_AclPermissionType_t permission_type, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_AclBindingFilter_t *rd_kafka_AclBindingFilter_new(rd_kafka_ResourceType_t restype, const char *name, rd_kafka_ResourcePatternType_t resource_pattern_type, const char *principal, const char *host, rd_kafka_AclOperation_t operation, rd_kafka_AclPermissionType_t permission_type, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_ResourceType_t rd_kafka_AclBinding_restype(const rd_kafka_AclBinding_t *acl);</span>
<span class="s1">const char *rd_kafka_AclBinding_name(const rd_kafka_AclBinding_t *acl);</span>
<span class="s1">const char *rd_kafka_AclBinding_principal(const rd_kafka_AclBinding_t *acl);</span>
<span class="s1">const char *rd_kafka_AclBinding_host(const rd_kafka_AclBinding_t *acl);</span>
<span class="s1">rd_kafka_AclOperation_t rd_kafka_AclBinding_operation(const rd_kafka_AclBinding_t *acl);</span>
<span class="s1">rd_kafka_AclPermissionType_t rd_kafka_AclBinding_permission_type(const rd_kafka_AclBinding_t *acl);</span>
<span class="s1">rd_kafka_ResourcePatternType_t rd_kafka_AclBinding_resource_pattern_type(const rd_kafka_AclBinding_t *acl);</span>
<span class="s1">const rd_kafka_error_t *rd_kafka_AclBinding_error(const rd_kafka_AclBinding_t *acl);</span>
<span class="s1">void rd_kafka_AclBinding_destroy(rd_kafka_AclBinding_t *acl_binding);</span>
<span class="s1">void rd_kafka_AclBinding_destroy_array(rd_kafka_AclBinding_t **acl_bindings, size_t acl_bindings_cnt);</span>
<span class="s1">const rd_kafka_acl_result_t **rd_kafka_CreateAcls_result_acls(const rd_kafka_CreateAcls_result_t *result, size_t *cntp);</span>
<span class="s1">void rd_kafka_CreateAcls(rd_kafka_t *rk, rd_kafka_AclBinding_t **new_acls, size_t new_acls_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_AclBinding_t **rd_kafka_DescribeAcls_result_acls(const rd_kafka_DescribeAcls_result_t *result, size_t *cntp);</span>
<span class="s1">void rd_kafka_DescribeAcls(rd_kafka_t *rk, rd_kafka_AclBindingFilter_t *acl_filter, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">typedef struct rd_kafka_DeleteAcls_result_response_s rd_kafka_DeleteAcls_result_response_t;</span>
<span class="s1">const rd_kafka_DeleteAcls_result_response_t **rd_kafka_DeleteAcls_result_responses(const rd_kafka_DeleteAcls_result_t *result, size_t *cntp);</span>
<span class="s1">const rd_kafka_error_t *rd_kafka_DeleteAcls_result_response_error(const rd_kafka_DeleteAcls_result_response_t *result_response);</span>
<span class="s1">const rd_kafka_AclBinding_t **rd_kafka_DeleteAcls_result_response_matching_acls(const rd_kafka_DeleteAcls_result_response_t *result_response, size_t *matching_acls_cntp);</span>
<span class="s1">void rd_kafka_DeleteAcls(rd_kafka_t *rk, rd_kafka_AclBindingFilter_t **del_acls, size_t del_acls_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token(rd_kafka_t *rk, const char *token_value, int64_t md_lifetime_ms, const char *md_principal_name, const char **extensions, size_t extension_size, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token_failure(rd_kafka_t *rk, const char *errstr);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_init_transactions(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_begin_transaction(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_send_offsets_to_transaction(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, const rd_kafka_consumer_group_metadata_t *cgmetadata, int timeout_ms);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_commit_transaction(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_abort_transaction(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">typedef struct rd_kafka_mock_cluster_s rd_kafka_mock_cluster_t;</span>
<span class="s1">rd_kafka_mock_cluster_t *rd_kafka_mock_cluster_new(rd_kafka_t *rk, int broker_cnt);</span>
<span class="s1">void rd_kafka_mock_cluster_destroy(rd_kafka_mock_cluster_t *mcluster);</span>
<span class="s1">rd_kafka_t *rd_kafka_mock_cluster_handle(const rd_kafka_mock_cluster_t *mcluster);</span>
<span class="s1">rd_kafka_mock_cluster_t *rd_kafka_handle_mock_cluster(const rd_kafka_t *rk);</span>
<span class="s1">const char *rd_kafka_mock_cluster_bootstraps(const rd_kafka_mock_cluster_t *mcluster);</span>
<span class="s1">void rd_kafka_mock_clear_request_errors(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey);</span>
<span class="s1">void rd_kafka_mock_push_request_errors(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, size_t cnt, ...);</span>
<span class="s1">void rd_kafka_mock_push_request_errors_array(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, size_t cnt, const rd_kafka_resp_err_t *errors);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_push_request_error_rtts(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int16_t ApiKey, size_t cnt, ...);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_error_stack_cnt(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int16_t ApiKey, size_t *cntp);</span>
<span class="s1">void rd_kafka_mock_topic_set_error(rd_kafka_mock_cluster_t *mcluster, const char *topic, rd_kafka_resp_err_t err);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_topic_create(rd_kafka_mock_cluster_t *mcluster, const char *topic, int partition_cnt, int replication_factor);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_partition_set_leader(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_partition_set_follower(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_partition_set_follower_wmarks(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int64_t lo, int64_t hi);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_set_down(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_set_up(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_set_rtt(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int rtt_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_set_rack(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, const char *rack);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_coordinator_set(rd_kafka_mock_cluster_t *mcluster, const char *key_type, const char *key, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_set_apiversion(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, int16_t MinVersion, int16_t MaxVersion);</span>
<span class="s1">&#39;</span>
</code></pre></div>
rdkafka.h, rdkafka_mock.h</p>
<h3 id="rd_kafka_version_23">RD_KAFKA_VERSION<a class="headerlink" href="#rd_kafka_version_23" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_VERSION</span> <span class="o">=</span> <span class="mi">33554687</span>
</code></pre></div>
<p>librdkafka version </p>
<p>Interpreted as hex <code>MM.mm.rr.xx</code>:</p>
<ul>
<li>MM = Major</li>
<li>mm = minor</li>
<li>rr = revision</li>
<li>xx = pre-release id (0xff is the final release)</li>
</ul>
<p>E.g.: <code>0x000801ff</code> = 0.8.1</p>
<dl class="section remark"><dt>Remarks</dt><dd>This value should only be used during compile time, for runtime checks of version use rd_kafka_version() </dd></dl>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_unsupported_compression_type_23">RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE<a class="headerlink" href="#rd_kafka_resp_err_unsupported_compression_type_23" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE</span> <span class="o">=</span> <span class="mi">76</span>
</code></pre></div>
<p>Unsupported compression type </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_end_all_23">RD_KAFKA_RESP_ERR_END_ALL<a class="headerlink" href="#rd_kafka_resp_err_end_all_23" title="Permanent link">&para;</a></h3>
<p><div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_END_ALL</span> <span class="o">=</span> <span class="mi">98</span>
</code></pre></div>
enum rd_kafka_resp_err_t</p>
<h3 id="rd_kafka_admin_op__cnt_23">RD_KAFKA_ADMIN_OP__CNT<a class="headerlink" href="#rd_kafka_admin_op__cnt_23" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_ADMIN_OP__CNT</span> <span class="o">=</span> <span class="mi">16</span>
</code></pre></div>
<p>Number of ops defined </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe </a></li>
</ul>
</div>
<h3 id="rd_kafka_resource__cnt_23">RD_KAFKA_RESOURCE__CNT<a class="headerlink" href="#rd_kafka_resource__cnt_23" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESOURCE__CNT</span> <span class="o">=</span> <span class="mi">5</span>
</code></pre></div>
<p>Number of resource types defined </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#acca83a66d7783ff7683ed2691cc907c9"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#acca83a66d7783ff7683ed2691cc907c9 </a></li>
</ul>
</div>
<h3 id="rd_kafka_cdef_23">RD_KAFKA_CDEF<a class="headerlink" href="#rd_kafka_cdef_23" title="Permanent link">&para;</a></h3>
<p><div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_CDEF</span> <span class="o">=</span> <span class="s1">&#39;typedef long int ssize_t;</span>
<span class="s1">typedef struct _IO_FILE FILE;</span>
<span class="s1">typedef long int mode_t;</span>
<span class="s1">typedef signed int int16_t;</span>
<span class="s1">typedef unsigned int uint16_t;</span>
<span class="s1">typedef signed int int32_t;</span>
<span class="s1">typedef signed long int int64_t;</span>
<span class="s1">int rd_kafka_version(void);</span>
<span class="s1">const char *rd_kafka_version_str(void);</span>
<span class="s1">typedef enum rd_kafka_type_t {</span>
<span class="s1">  RD_KAFKA_PRODUCER,</span>
<span class="s1">  RD_KAFKA_CONSUMER,</span>
<span class="s1">} rd_kafka_type_t;</span>
<span class="s1">typedef enum rd_kafka_timestamp_type_t {</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_NOT_AVAILABLE,</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_CREATE_TIME,</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_LOG_APPEND_TIME,</span>
<span class="s1">} rd_kafka_timestamp_type_t;</span>
<span class="s1">const char *rd_kafka_get_debug_contexts(void);</span>
<span class="s1">typedef struct rd_kafka_s rd_kafka_t;</span>
<span class="s1">typedef struct rd_kafka_topic_s rd_kafka_topic_t;</span>
<span class="s1">typedef struct rd_kafka_conf_s rd_kafka_conf_t;</span>
<span class="s1">typedef struct rd_kafka_topic_conf_s rd_kafka_topic_conf_t;</span>
<span class="s1">typedef struct rd_kafka_queue_s rd_kafka_queue_t;</span>
<span class="s1">typedef struct rd_kafka_op_s rd_kafka_event_t;</span>
<span class="s1">typedef struct rd_kafka_topic_result_s rd_kafka_topic_result_t;</span>
<span class="s1">typedef struct rd_kafka_consumer_group_metadata_s rd_kafka_consumer_group_metadata_t;</span>
<span class="s1">typedef struct rd_kafka_error_s {</span>
<span class="s1">  unsigned int code;</span>
<span class="s1">  char *errstr;</span>
<span class="s1">  unsigned char fatal;</span>
<span class="s1">  unsigned char retriable;</span>
<span class="s1">  unsigned char txn_requires_abort;</span>
<span class="s1">} rd_kafka_error_t;</span>
<span class="s1">typedef struct rd_kafka_headers_s rd_kafka_headers_t;</span>
<span class="s1">typedef struct rd_kafka_group_result_s rd_kafka_group_result_t;</span>
<span class="s1">typedef struct rd_kafka_acl_result_s rd_kafka_acl_result_t;</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BEGIN = (- 200),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BAD_MSG = (- 199),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BAD_COMPRESSION = (- 198),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__DESTROY = (- 197),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FAIL = (- 196),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TRANSPORT = (- 195),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__CRIT_SYS_RESOURCE = (- 194),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__RESOLVE = (- 193),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__MSG_TIMED_OUT = (- 192),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PARTITION_EOF = (- 191),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION = (- 190),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FS = (- 189),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC = (- 188),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ALL_BROKERS_DOWN = (- 187),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INVALID_ARG = (- 186),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TIMED_OUT = (- 185),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__QUEUE_FULL = (- 184),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ISR_INSUFF = (- 183),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NODE_UPDATE = (- 182),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__SSL = (- 181),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__WAIT_COORD = (- 180),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_GROUP = (- 179),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__IN_PROGRESS = (- 178),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PREV_IN_PROGRESS = (- 177),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__EXISTING_SUBSCRIPTION = (- 176),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS = (- 175),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS = (- 174),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__CONFLICT = (- 173),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__STATE = (- 172),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_PROTOCOL = (- 171),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED = (- 170),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__AUTHENTICATION = (- 169),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NO_OFFSET = (- 168),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__OUTDATED = (- 167),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TIMED_OUT_QUEUE = (- 166),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNSUPPORTED_FEATURE = (- 165),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__WAIT_CACHE = (- 164),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INTR = (- 163),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__KEY_SERIALIZATION = (- 162),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__VALUE_SERIALIZATION = (- 161),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__KEY_DESERIALIZATION = (- 160),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__VALUE_DESERIALIZATION = (- 159),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PARTIAL = (- 158),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__READ_ONLY = (- 157),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOENT = (- 156),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNDERFLOW = (- 155),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INVALID_TYPE = (- 154),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__RETRY = (- 153),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PURGE_QUEUE = (- 152),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PURGE_INFLIGHT = (- 151),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FATAL = (- 150),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INCONSISTENT = (- 149),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__GAPLESS_GUARANTEE = (- 148),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__MAX_POLL_EXCEEDED = (- 147),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_BROKER = (- 146),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOT_CONFIGURED = (- 145),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FENCED = (- 144),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__APPLICATION = (- 143),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ASSIGNMENT_LOST = (- 142),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOOP = (- 141),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__AUTO_OFFSET_RESET = (- 140),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__END = (- 100),</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN = (- 1),</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NO_ERROR = 0,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_OUT_OF_RANGE = 1,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_MSG = 2,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART = 3,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_MSG_SIZE = 4,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE = 5,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_LEADER_FOR_PARTITION = 6,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REQUEST_TIMED_OUT = 7,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_BROKER_NOT_AVAILABLE = 8,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REPLICA_NOT_AVAILABLE = 9,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE = 10,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_STALE_CTRL_EPOCH = 11,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_METADATA_TOO_LARGE = 12,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NETWORK_EXCEPTION = 13,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_COORDINATOR_LOAD_IN_PROGRESS = 14,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_COORDINATOR_NOT_AVAILABLE = 15,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_COORDINATOR = 16,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_EXCEPTION = 17,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_RECORD_LIST_TOO_LARGE = 18,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS = 19,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS_AFTER_APPEND = 20,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REQUIRED_ACKS = 21,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ILLEGAL_GENERATION = 22,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INCONSISTENT_GROUP_PROTOCOL = 23,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_GROUP_ID = 24,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_MEMBER_ID = 25,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_SESSION_TIMEOUT = 26,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REBALANCE_IN_PROGRESS = 27,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_COMMIT_OFFSET_SIZE = 28,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_AUTHORIZATION_FAILED = 29,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_AUTHORIZATION_FAILED = 30,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_CLUSTER_AUTHORIZATION_FAILED = 31,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TIMESTAMP = 32,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_SASL_MECHANISM = 33,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ILLEGAL_SASL_STATE = 34,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_VERSION = 35,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_ALREADY_EXISTS = 36,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PARTITIONS = 37,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REPLICATION_FACTOR = 38,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REPLICA_ASSIGNMENT = 39,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_CONFIG = 40,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_CONTROLLER = 41,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REQUEST = 42,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_FOR_MESSAGE_FORMAT = 43,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_POLICY_VIOLATION = 44,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OUT_OF_ORDER_SEQUENCE_NUMBER = 45,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DUPLICATE_SEQUENCE_NUMBER = 46,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_EPOCH = 47,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TXN_STATE = 48,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_ID_MAPPING = 49,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TRANSACTION_TIMEOUT = 50,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_CONCURRENT_TRANSACTIONS = 51,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TRANSACTION_COORDINATOR_FENCED = 52,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TRANSACTIONAL_ID_AUTHORIZATION_FAILED = 53,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_SECURITY_DISABLED = 54,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OPERATION_NOT_ATTEMPTED = 55,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_KAFKA_STORAGE_ERROR = 56,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LOG_DIR_NOT_FOUND = 57,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_SASL_AUTHENTICATION_FAILED = 58,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_PRODUCER_ID = 59,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REASSIGNMENT_IN_PROGRESS = 60,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTH_DISABLED = 61,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_NOT_FOUND = 62,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_OWNER_MISMATCH = 63,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_REQUEST_NOT_ALLOWED = 64,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTHORIZATION_FAILED = 65,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_EXPIRED = 66,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRINCIPAL_TYPE = 67,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NON_EMPTY_GROUP = 68,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_ID_NOT_FOUND = 69,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FETCH_SESSION_ID_NOT_FOUND = 70,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_FETCH_SESSION_EPOCH = 71,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LISTENER_NOT_FOUND = 72,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_DELETION_DISABLED = 73,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FENCED_LEADER_EPOCH = 74,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_LEADER_EPOCH = 75,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_STALE_BROKER_EPOCH = 77,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_NOT_AVAILABLE = 78,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_MEMBER_ID_REQUIRED = 79,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_PREFERRED_LEADER_NOT_AVAILABLE = 80,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_MAX_SIZE_REACHED = 81,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FENCED_INSTANCE_ID = 82,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ELIGIBLE_LEADERS_NOT_AVAILABLE = 83,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ELECTION_NOT_NEEDED = 84,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NO_REASSIGNMENT_IN_PROGRESS = 85,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_SUBSCRIBED_TO_TOPIC = 86,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_RECORD = 87,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSTABLE_OFFSET_COMMIT = 88,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_THROTTLING_QUOTA_EXCEEDED = 89,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_PRODUCER_FENCED = 90,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_RESOURCE_NOT_FOUND = 91,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DUPLICATE_RESOURCE = 92,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNACCEPTABLE_CREDENTIAL = 93,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INCONSISTENT_VOTER_SET = 94,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_UPDATE_VERSION = 95,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FEATURE_UPDATE_FAILED = 96,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_PRINCIPAL_DESERIALIZATION_FAILURE = 97,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_END_ALL,</span>
<span class="s1">} rd_kafka_resp_err_t;</span>
<span class="s1">struct rd_kafka_err_desc {</span>
<span class="s1">  rd_kafka_resp_err_t code;</span>
<span class="s1">  char *name;</span>
<span class="s1">  char *desc;</span>
<span class="s1">};</span>
<span class="s1">void rd_kafka_get_err_descs(const struct rd_kafka_err_desc **errdescs, size_t *cntp);</span>
<span class="s1">const char *rd_kafka_err2str(rd_kafka_resp_err_t err);</span>
<span class="s1">const char *rd_kafka_err2name(rd_kafka_resp_err_t err);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_last_error(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_errno2err(int errnox);</span>
<span class="s1">int rd_kafka_errno(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_fatal_error(rd_kafka_t *rk, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_test_fatal_error(rd_kafka_t *rk, rd_kafka_resp_err_t err, const char *reason);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_error_code(const rd_kafka_error_t *error);</span>
<span class="s1">const char *rd_kafka_error_name(const rd_kafka_error_t *error);</span>
<span class="s1">const char *rd_kafka_error_string(const rd_kafka_error_t *error);</span>
<span class="s1">int rd_kafka_error_is_fatal(const rd_kafka_error_t *error);</span>
<span class="s1">int rd_kafka_error_is_retriable(const rd_kafka_error_t *error);</span>
<span class="s1">int rd_kafka_error_txn_requires_abort(const rd_kafka_error_t *error);</span>
<span class="s1">void rd_kafka_error_destroy(rd_kafka_error_t *error);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_error_new(rd_kafka_resp_err_t code, const char *fmt, ...);</span>
<span class="s1">typedef struct rd_kafka_topic_partition_s {</span>
<span class="s1">  char *topic;</span>
<span class="s1">  int32_t partition;</span>
<span class="s1">  int64_t offset;</span>
<span class="s1">  void *metadata;</span>
<span class="s1">  size_t metadata_size;</span>
<span class="s1">  void *opaque;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  void *_private;</span>
<span class="s1">} rd_kafka_topic_partition_t;</span>
<span class="s1">void rd_kafka_topic_partition_destroy(rd_kafka_topic_partition_t *rktpar);</span>
<span class="s1">typedef struct rd_kafka_topic_partition_list_s {</span>
<span class="s1">  int cnt;</span>
<span class="s1">  int size;</span>
<span class="s1">  rd_kafka_topic_partition_t *elems;</span>
<span class="s1">} rd_kafka_topic_partition_list_t;</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_new(int size);</span>
<span class="s1">void rd_kafka_topic_partition_list_destroy(rd_kafka_topic_partition_list_t *rkparlist);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_add(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">void rd_kafka_topic_partition_list_add_range(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t start, int32_t stop);</span>
<span class="s1">int rd_kafka_topic_partition_list_del(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">int rd_kafka_topic_partition_list_del_by_idx(rd_kafka_topic_partition_list_t *rktparlist, int idx);</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_copy(const rd_kafka_topic_partition_list_t *src);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_topic_partition_list_set_offset(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition, int64_t offset);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_find(const rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">void rd_kafka_topic_partition_list_sort(rd_kafka_topic_partition_list_t *rktparlist, int (*cmp)(const void *a, const void *b, void *cmp_opaque), void *cmp_opaque);</span>
<span class="s1">typedef enum rd_kafka_vtype_t {</span>
<span class="s1">  RD_KAFKA_VTYPE_END,</span>
<span class="s1">  RD_KAFKA_VTYPE_TOPIC,</span>
<span class="s1">  RD_KAFKA_VTYPE_RKT,</span>
<span class="s1">  RD_KAFKA_VTYPE_PARTITION,</span>
<span class="s1">  RD_KAFKA_VTYPE_VALUE,</span>
<span class="s1">  RD_KAFKA_VTYPE_KEY,</span>
<span class="s1">  RD_KAFKA_VTYPE_OPAQUE,</span>
<span class="s1">  RD_KAFKA_VTYPE_MSGFLAGS,</span>
<span class="s1">  RD_KAFKA_VTYPE_TIMESTAMP,</span>
<span class="s1">  RD_KAFKA_VTYPE_HEADER,</span>
<span class="s1">  RD_KAFKA_VTYPE_HEADERS,</span>
<span class="s1">} rd_kafka_vtype_t;</span>
<span class="s1">typedef struct rd_kafka_vu_s {</span>
<span class="s1">  rd_kafka_vtype_t vtype;</span>
<span class="s1">  union {</span>
<span class="s1">    char *cstr;</span>
<span class="s1">    rd_kafka_topic_t *rkt;</span>
<span class="s1">    int i;</span>
<span class="s1">    int32_t i32;</span>
<span class="s1">    int64_t i64;</span>
<span class="s1">    struct {</span>
<span class="s1">      void *ptr;</span>
<span class="s1">      size_t size;</span>
<span class="s1">    } mem;</span>
<span class="s1">    struct {</span>
<span class="s1">      char *name;</span>
<span class="s1">      void *val;</span>
<span class="s1">      ssize_t size;</span>
<span class="s1">    } header;</span>
<span class="s1">    rd_kafka_headers_t *headers;</span>
<span class="s1">    void *ptr;</span>
<span class="s1">    char _pad[64];</span>
<span class="s1">  } u;</span>
<span class="s1">} rd_kafka_vu_t;</span>
<span class="s1">rd_kafka_headers_t *rd_kafka_headers_new(size_t initial_count);</span>
<span class="s1">void rd_kafka_headers_destroy(rd_kafka_headers_t *hdrs);</span>
<span class="s1">rd_kafka_headers_t *rd_kafka_headers_copy(const rd_kafka_headers_t *src);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_add(rd_kafka_headers_t *hdrs, const char *name, ssize_t name_size, const void *value, ssize_t value_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_remove(rd_kafka_headers_t *hdrs, const char *name);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get_last(const rd_kafka_headers_t *hdrs, const char *name, const void **valuep, size_t *sizep);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get(const rd_kafka_headers_t *hdrs, size_t idx, const char *name, const void **valuep, size_t *sizep);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get_all(const rd_kafka_headers_t *hdrs, size_t idx, const char **namep, const void **valuep, size_t *sizep);</span>
<span class="s1">typedef struct rd_kafka_message_s {</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  rd_kafka_topic_t *rkt;</span>
<span class="s1">  int32_t partition;</span>
<span class="s1">  void *payload;</span>
<span class="s1">  size_t len;</span>
<span class="s1">  void *key;</span>
<span class="s1">  size_t key_len;</span>
<span class="s1">  int64_t offset;</span>
<span class="s1">  void *_private;</span>
<span class="s1">} rd_kafka_message_t;</span>
<span class="s1">void rd_kafka_message_destroy(rd_kafka_message_t *rkmessage);</span>
<span class="s1">const char *rd_kafka_message_errstr(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">int64_t rd_kafka_message_timestamp(const rd_kafka_message_t *rkmessage, rd_kafka_timestamp_type_t *tstype);</span>
<span class="s1">int64_t rd_kafka_message_latency(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">int32_t rd_kafka_message_broker_id(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_message_headers(const rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_message_detach_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);</span>
<span class="s1">void rd_kafka_message_set_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t *hdrs);</span>
<span class="s1">size_t rd_kafka_header_cnt(const rd_kafka_headers_t *hdrs);</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_NOT_PERSISTED = 0,</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_POSSIBLY_PERSISTED = 1,</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_PERSISTED = 2,</span>
<span class="s1">} rd_kafka_msg_status_t;</span>
<span class="s1">rd_kafka_msg_status_t rd_kafka_message_status(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_CONF_UNKNOWN = (- 2),</span>
<span class="s1">  RD_KAFKA_CONF_INVALID = (- 1),</span>
<span class="s1">  RD_KAFKA_CONF_OK = 0,</span>
<span class="s1">} rd_kafka_conf_res_t;</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_new(void);</span>
<span class="s1">void rd_kafka_conf_destroy(rd_kafka_conf_t *conf);</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_dup(const rd_kafka_conf_t *conf);</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_dup_filter(const rd_kafka_conf_t *conf, size_t filter_cnt, const char **filter);</span>
<span class="s1">const rd_kafka_conf_t *rd_kafka_conf(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_set(rd_kafka_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_conf_set_events(rd_kafka_conf_t *conf, int events);</span>
<span class="s1">void rd_kafka_conf_set_background_event_cb(rd_kafka_conf_t *conf, void (*event_cb)(rd_kafka_t *rk, rd_kafka_event_t *rkev, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_dr_cb(rd_kafka_conf_t *conf, void (*dr_cb)(rd_kafka_t *rk, void *payload, size_t len, rd_kafka_resp_err_t err, void *opaque, void *msg_opaque));</span>
<span class="s1">void rd_kafka_conf_set_dr_msg_cb(rd_kafka_conf_t *conf, void (*dr_msg_cb)(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_consume_cb(rd_kafka_conf_t *conf, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_rebalance_cb(rd_kafka_conf_t *conf, void (*rebalance_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *partitions, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_offset_commit_cb(rd_kafka_conf_t *conf, void (*offset_commit_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_error_cb(rd_kafka_conf_t *conf, void (*error_cb)(rd_kafka_t *rk, int err, const char *reason, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_throttle_cb(rd_kafka_conf_t *conf, void (*throttle_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int throttle_time_ms, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_log_cb(rd_kafka_conf_t *conf, void (*log_cb)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));</span>
<span class="s1">void rd_kafka_conf_set_stats_cb(rd_kafka_conf_t *conf, int (*stats_cb)(rd_kafka_t *rk, char *json, size_t json_len, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_oauthbearer_token_refresh_cb(rd_kafka_conf_t *conf, void (*oauthbearer_token_refresh_cb)(rd_kafka_t *rk, const char *oauthbearer_config, void *opaque));</span>
<span class="s1">void rd_kafka_conf_enable_sasl_queue(rd_kafka_conf_t *conf, int enable);</span>
<span class="s1">void rd_kafka_conf_set_socket_cb(rd_kafka_conf_t *conf, int (*socket_cb)(int domain, int type, int protocol, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_connect_cb(rd_kafka_conf_t *conf, int (*connect_cb)(int sockfd, const struct sockaddr *addr, int addrlen, const char *id, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_closesocket_cb(rd_kafka_conf_t *conf, int (*closesocket_cb)(int sockfd, void *opaque));</span>
<span class="s1">struct addrinfo;</span>
<span class="s1">void rd_kafka_conf_set_resolve_cb(rd_kafka_conf_t *conf, int (*resolve_cb)(const char *node, const char *service, const struct addrinfo *hints, struct addrinfo **res, void *opaque));</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert_verify_cb(rd_kafka_conf_t *conf, int (*ssl_cert_verify_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int *x509_error, int depth, const char *buf, size_t size, char *errstr, size_t errstr_size, void *opaque));</span>
<span class="s1">typedef enum rd_kafka_cert_type_t {</span>
<span class="s1">  RD_KAFKA_CERT_PUBLIC_KEY,</span>
<span class="s1">  RD_KAFKA_CERT_PRIVATE_KEY,</span>
<span class="s1">  RD_KAFKA_CERT_CA,</span>
<span class="s1">  RD_KAFKA_CERT__CNT,</span>
<span class="s1">} rd_kafka_cert_type_t;</span>
<span class="s1">typedef enum rd_kafka_cert_enc_t {</span>
<span class="s1">  RD_KAFKA_CERT_ENC_PKCS12,</span>
<span class="s1">  RD_KAFKA_CERT_ENC_DER,</span>
<span class="s1">  RD_KAFKA_CERT_ENC_PEM,</span>
<span class="s1">  RD_KAFKA_CERT_ENC__CNT,</span>
<span class="s1">} rd_kafka_cert_enc_t;</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert(rd_kafka_conf_t *conf, rd_kafka_cert_type_t cert_type, rd_kafka_cert_enc_t cert_enc, const void *buffer, size_t size, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_conf_set_engine_callback_data(rd_kafka_conf_t *conf, void *callback_data);</span>
<span class="s1">void rd_kafka_conf_set_opaque(rd_kafka_conf_t *conf, void *opaque);</span>
<span class="s1">void *rd_kafka_opaque(const rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_conf_set_default_topic_conf(rd_kafka_conf_t *conf, rd_kafka_topic_conf_t *tconf);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_conf_get_default_topic_conf(rd_kafka_conf_t *conf);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_get(const rd_kafka_conf_t *conf, const char *name, char *dest, size_t *dest_size);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_topic_conf_get(const rd_kafka_topic_conf_t *conf, const char *name, char *dest, size_t *dest_size);</span>
<span class="s1">const char **rd_kafka_conf_dump(rd_kafka_conf_t *conf, size_t *cntp);</span>
<span class="s1">const char **rd_kafka_topic_conf_dump(rd_kafka_topic_conf_t *conf, size_t *cntp);</span>
<span class="s1">void rd_kafka_conf_dump_free(const char **arr, size_t cnt);</span>
<span class="s1">void rd_kafka_conf_properties_show(FILE *fp);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_topic_conf_new(void);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_topic_conf_dup(const rd_kafka_topic_conf_t *conf);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_default_topic_conf_dup(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_topic_conf_destroy(rd_kafka_topic_conf_t *topic_conf);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_topic_conf_set(rd_kafka_topic_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_topic_conf_set_opaque(rd_kafka_topic_conf_t *conf, void *rkt_opaque);</span>
<span class="s1">void rd_kafka_topic_conf_set_partitioner_cb(rd_kafka_topic_conf_t *topic_conf, int32_t (*partitioner)(const rd_kafka_topic_t *rkt, const void *keydata, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque));</span>
<span class="s1">void rd_kafka_topic_conf_set_msg_order_cmp(rd_kafka_topic_conf_t *topic_conf, int (*msg_order_cmp)(const rd_kafka_message_t *a, const rd_kafka_message_t *b));</span>
<span class="s1">int rd_kafka_topic_partition_available(const rd_kafka_topic_t *rkt, int32_t partition);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_consistent(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_consistent_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_murmur2(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_murmur2_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_fnv1a(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_fnv1a_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">rd_kafka_t *rd_kafka_new(rd_kafka_type_t type, rd_kafka_conf_t *conf, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_destroy(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_destroy_flags(rd_kafka_t *rk, int flags);</span>
<span class="s1">const char *rd_kafka_name(const rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_type_t rd_kafka_type(const rd_kafka_t *rk);</span>
<span class="s1">char *rd_kafka_memberid(const rd_kafka_t *rk);</span>
<span class="s1">char *rd_kafka_clusterid(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">int32_t rd_kafka_controllerid(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_topic_t *rd_kafka_topic_new(rd_kafka_t *rk, const char *topic, rd_kafka_topic_conf_t *conf);</span>
<span class="s1">void rd_kafka_topic_destroy(rd_kafka_topic_t *rkt);</span>
<span class="s1">const char *rd_kafka_topic_name(const rd_kafka_topic_t *rkt);</span>
<span class="s1">void *rd_kafka_topic_opaque(const rd_kafka_topic_t *rkt);</span>
<span class="s1">int rd_kafka_poll(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">void rd_kafka_yield(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_pause_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_resume_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_query_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_get_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offsets_for_times(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets, int timeout_ms);</span>
<span class="s1">void *rd_kafka_mem_calloc(rd_kafka_t *rk, size_t num, size_t size);</span>
<span class="s1">void *rd_kafka_mem_malloc(rd_kafka_t *rk, size_t size);</span>
<span class="s1">void rd_kafka_mem_free(rd_kafka_t *rk, void *ptr);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_new(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_queue_destroy(rd_kafka_queue_t *rkqu);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_main(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_sasl(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_sasl_background_callbacks_enable(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_sasl_set_credentials(rd_kafka_t *rk, const char *username, const char *password);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_consumer(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_partition(rd_kafka_t *rk, const char *topic, int32_t partition);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_background(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_queue_forward(rd_kafka_queue_t *src, rd_kafka_queue_t *dst);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_set_log_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu);</span>
<span class="s1">size_t rd_kafka_queue_length(rd_kafka_queue_t *rkqu);</span>
<span class="s1">void rd_kafka_queue_io_event_enable(rd_kafka_queue_t *rkqu, int fd, const void *payload, size_t size);</span>
<span class="s1">void rd_kafka_queue_cb_event_enable(rd_kafka_queue_t *rkqu, void (*event_cb)(rd_kafka_t *rk, void *qev_opaque), void *qev_opaque);</span>
<span class="s1">void rd_kafka_queue_yield(rd_kafka_queue_t *rkqu);</span>
<span class="s1">int rd_kafka_consume_start(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);</span>
<span class="s1">int rd_kafka_consume_start_queue(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, rd_kafka_queue_t *rkqu);</span>
<span class="s1">int rd_kafka_consume_stop(rd_kafka_topic_t *rkt, int32_t partition);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_seek(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, int timeout_ms);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_seek_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consume(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms);</span>
<span class="s1">ssize_t rd_kafka_consume_batch(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);</span>
<span class="s1">int rd_kafka_consume_callback(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consume_queue(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">ssize_t rd_kafka_consume_batch_queue(rd_kafka_queue_t *rkqu, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);</span>
<span class="s1">int rd_kafka_consume_callback_queue(rd_kafka_queue_t *rkqu, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offset_store(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offsets_store(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_subscribe(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *topics);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_unsubscribe(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_subscription(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **topics);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consumer_poll(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_consumer_close(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_consumer_close_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu);</span>
<span class="s1">int rd_kafka_consumer_closed(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_incremental_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_incremental_unassign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">const char *rd_kafka_rebalance_protocol(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_assignment(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **partitions);</span>
<span class="s1">int rd_kafka_assignment_lost(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, int async);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit_message(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, int async);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit_queue(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_queue_t *rkqu, void (*cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *commit_opaque), void *commit_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_committed(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_position(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata_new(const char *group_id);</span>
<span class="s1">rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata_new_with_genid(const char *group_id, int32_t generation_id, const char *member_id, const char *group_instance_id);</span>
<span class="s1">void rd_kafka_consumer_group_metadata_destroy(rd_kafka_consumer_group_metadata_t *);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_consumer_group_metadata_write(const rd_kafka_consumer_group_metadata_t *cgmd, void **bufferp, size_t *sizep);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_consumer_group_metadata_read(rd_kafka_consumer_group_metadata_t **cgmdp, const void *buffer, size_t size);</span>
<span class="s1">int rd_kafka_produce(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, void *payload, size_t len, const void *key, size_t keylen, void *msg_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_producev(rd_kafka_t *rk, ...);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_produceva(rd_kafka_t *rk, const rd_kafka_vu_t *vus, size_t cnt);</span>
<span class="s1">int rd_kafka_produce_batch(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, rd_kafka_message_t *rkmessages, int message_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_flush(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_purge(rd_kafka_t *rk, int purge_flags);</span>
<span class="s1">typedef struct rd_kafka_metadata_broker {</span>
<span class="s1">  int32_t id;</span>
<span class="s1">  char *host;</span>
<span class="s1">  int port;</span>
<span class="s1">} rd_kafka_metadata_broker_t;</span>
<span class="s1">typedef struct rd_kafka_metadata_partition {</span>
<span class="s1">  int32_t id;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  int32_t leader;</span>
<span class="s1">  int replica_cnt;</span>
<span class="s1">  int32_t *replicas;</span>
<span class="s1">  int isr_cnt;</span>
<span class="s1">  int32_t *isrs;</span>
<span class="s1">} rd_kafka_metadata_partition_t;</span>
<span class="s1">typedef struct rd_kafka_metadata_topic {</span>
<span class="s1">  char *topic;</span>
<span class="s1">  int partition_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_partition *partitions;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">} rd_kafka_metadata_topic_t;</span>
<span class="s1">typedef struct rd_kafka_metadata {</span>
<span class="s1">  int broker_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_broker *brokers;</span>
<span class="s1">  int topic_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_topic *topics;</span>
<span class="s1">  int32_t orig_broker_id;</span>
<span class="s1">  char *orig_broker_name;</span>
<span class="s1">} rd_kafka_metadata_t;</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_metadata(rd_kafka_t *rk, int all_topics, rd_kafka_topic_t *only_rkt, const struct rd_kafka_metadata **metadatap, int timeout_ms);</span>
<span class="s1">void rd_kafka_metadata_destroy(const struct rd_kafka_metadata *metadata);</span>
<span class="s1">typedef struct rd_kafka_Node_s rd_kafka_Node_t;</span>
<span class="s1">int rd_kafka_Node_id(const rd_kafka_Node_t *node);</span>
<span class="s1">const char *rd_kafka_Node_host(const rd_kafka_Node_t *node);</span>
<span class="s1">uint16_t rd_kafka_Node_port(const rd_kafka_Node_t *node);</span>
<span class="s1">struct rd_kafka_group_member_info {</span>
<span class="s1">  char *member_id;</span>
<span class="s1">  char *client_id;</span>
<span class="s1">  char *client_host;</span>
<span class="s1">  void *member_metadata;</span>
<span class="s1">  int member_metadata_size;</span>
<span class="s1">  void *member_assignment;</span>
<span class="s1">  int member_assignment_size;</span>
<span class="s1">};</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_CONSUMER_GROUP_STATE_UNKNOWN = 0,</span>
<span class="s1">  RD_KAFKA_CONSUMER_GROUP_STATE_PREPARING_REBALANCE = 1,</span>
<span class="s1">  RD_KAFKA_CONSUMER_GROUP_STATE_COMPLETING_REBALANCE = 2,</span>
<span class="s1">  RD_KAFKA_CONSUMER_GROUP_STATE_STABLE = 3,</span>
<span class="s1">  RD_KAFKA_CONSUMER_GROUP_STATE_DEAD = 4,</span>
<span class="s1">  RD_KAFKA_CONSUMER_GROUP_STATE_EMPTY = 5,</span>
<span class="s1">  RD_KAFKA_CONSUMER_GROUP_STATE__CNT,</span>
<span class="s1">} rd_kafka_consumer_group_state_t;</span>
<span class="s1">struct rd_kafka_group_info {</span>
<span class="s1">  struct rd_kafka_metadata_broker broker;</span>
<span class="s1">  char *group;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  char *state;</span>
<span class="s1">  char *protocol_type;</span>
<span class="s1">  char *protocol;</span>
<span class="s1">  struct rd_kafka_group_member_info *members;</span>
<span class="s1">  int member_cnt;</span>
<span class="s1">};</span>
<span class="s1">struct rd_kafka_group_list {</span>
<span class="s1">  struct rd_kafka_group_info *groups;</span>
<span class="s1">  int group_cnt;</span>
<span class="s1">};</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_list_groups(rd_kafka_t *rk, const char *group, const struct rd_kafka_group_list **grplistp, int timeout_ms);</span>
<span class="s1">const char *rd_kafka_consumer_group_state_name(rd_kafka_consumer_group_state_t state);</span>
<span class="s1">rd_kafka_consumer_group_state_t rd_kafka_consumer_group_state_code(const char *name);</span>
<span class="s1">void rd_kafka_group_list_destroy(const struct rd_kafka_group_list *grplist);</span>
<span class="s1">int rd_kafka_brokers_add(rd_kafka_t *rk, const char *brokerlist);</span>
<span class="s1">void rd_kafka_set_logger(rd_kafka_t *rk, void (*func)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));</span>
<span class="s1">void rd_kafka_set_log_level(rd_kafka_t *rk, int level);</span>
<span class="s1">void rd_kafka_log_print(const rd_kafka_t *rk, int level, const char *fac, const char *buf);</span>
<span class="s1">void rd_kafka_log_syslog(const rd_kafka_t *rk, int level, const char *fac, const char *buf);</span>
<span class="s1">int rd_kafka_outq_len(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_dump(FILE *fp, rd_kafka_t *rk);</span>
<span class="s1">int rd_kafka_thread_cnt(void);</span>
<span class="s1">typedef enum rd_kafka_thread_type_t {</span>
<span class="s1">  RD_KAFKA_THREAD_MAIN,</span>
<span class="s1">  RD_KAFKA_THREAD_BACKGROUND,</span>
<span class="s1">  RD_KAFKA_THREAD_BROKER,</span>
<span class="s1">} rd_kafka_thread_type_t;</span>
<span class="s1">int rd_kafka_wait_destroyed(int timeout_ms);</span>
<span class="s1">int rd_kafka_unittest(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_poll_set_consumer(rd_kafka_t *rk);</span>
<span class="s1">typedef int rd_kafka_event_type_t;</span>
<span class="s1">rd_kafka_event_type_t rd_kafka_event_type(const rd_kafka_event_t *rkev);</span>
<span class="s1">const char *rd_kafka_event_name(const rd_kafka_event_t *rkev);</span>
<span class="s1">void rd_kafka_event_destroy(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_message_t *rd_kafka_event_message_next(rd_kafka_event_t *rkev);</span>
<span class="s1">size_t rd_kafka_event_message_array(rd_kafka_event_t *rkev, const rd_kafka_message_t **rkmessages, size_t size);</span>
<span class="s1">size_t rd_kafka_event_message_count(rd_kafka_event_t *rkev);</span>
<span class="s1">const char *rd_kafka_event_config_string(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_event_error(rd_kafka_event_t *rkev);</span>
<span class="s1">const char *rd_kafka_event_error_string(rd_kafka_event_t *rkev);</span>
<span class="s1">int rd_kafka_event_error_is_fatal(rd_kafka_event_t *rkev);</span>
<span class="s1">void *rd_kafka_event_opaque(rd_kafka_event_t *rkev);</span>
<span class="s1">int rd_kafka_event_log(rd_kafka_event_t *rkev, const char **fac, const char **str, int *level);</span>
<span class="s1">int rd_kafka_event_debug_contexts(rd_kafka_event_t *rkev, char *dst, size_t dstsize);</span>
<span class="s1">const char *rd_kafka_event_stats(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_event_topic_partition_list(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_event_topic_partition(rd_kafka_event_t *rkev);</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_CreateTopics_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DeleteTopics_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_CreateAcls_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DescribeAcls_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DeleteAcls_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_CreatePartitions_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_AlterConfigs_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DescribeConfigs_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DeleteRecords_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_ListConsumerGroups_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DescribeConsumerGroups_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DeleteGroups_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DeleteConsumerGroupOffsets_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_AlterConsumerGroupOffsets_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_ListConsumerGroupOffsets_result_t;</span>
<span class="s1">const rd_kafka_CreateTopics_result_t *rd_kafka_event_CreateTopics_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DeleteTopics_result_t *rd_kafka_event_DeleteTopics_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_CreatePartitions_result_t *rd_kafka_event_CreatePartitions_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_AlterConfigs_result_t *rd_kafka_event_AlterConfigs_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DescribeConfigs_result_t *rd_kafka_event_DescribeConfigs_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DeleteRecords_result_t *rd_kafka_event_DeleteRecords_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_ListConsumerGroups_result_t *rd_kafka_event_ListConsumerGroups_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DescribeConsumerGroups_result_t *rd_kafka_event_DescribeConsumerGroups_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DeleteGroups_result_t *rd_kafka_event_DeleteGroups_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DeleteConsumerGroupOffsets_result_t *rd_kafka_event_DeleteConsumerGroupOffsets_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_CreateAcls_result_t *rd_kafka_event_CreateAcls_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DescribeAcls_result_t *rd_kafka_event_DescribeAcls_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DeleteAcls_result_t *rd_kafka_event_DeleteAcls_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_AlterConsumerGroupOffsets_result_t *rd_kafka_event_AlterConsumerGroupOffsets_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_ListConsumerGroupOffsets_result_t *rd_kafka_event_ListConsumerGroupOffsets_result(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_event_t *rd_kafka_queue_poll(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">int rd_kafka_queue_poll_callback(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_plugin_f_conf_init_t)(rd_kafka_conf_t *conf, void **plug_opaquep, char *errstr, size_t errstr_size);</span>
<span class="s1">typedef rd_kafka_conf_res_t (rd_kafka_interceptor_f_on_conf_set_t)(rd_kafka_conf_t *conf, const char *name, const char *val, char *errstr, size_t errstr_size, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_dup_t)(rd_kafka_conf_t *new_conf, const rd_kafka_conf_t *old_conf, size_t filter_cnt, const char **filter, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_destroy_t)(void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_new_t)(rd_kafka_t *rk, const rd_kafka_conf_t *conf, void *ic_opaque, char *errstr, size_t errstr_size);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_destroy_t)(rd_kafka_t *rk, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_send_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_acknowledgement_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_consume_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_commit_t)(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_resp_err_t err, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_request_sent_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_response_received_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, int64_t rtt, rd_kafka_resp_err_t err, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_start_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_exit_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_broker_state_change_t)(rd_kafka_t *rk, int32_t broker_id, const char *secproto, const char *name, int port, const char *state, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_set(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_set_t *on_conf_set, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_dup(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_dup_t *on_conf_dup, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_destroy(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_destroy_t *on_conf_destroy, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_new(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_new_t *on_new, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_destroy(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_destroy_t *on_destroy, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_send(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_send_t *on_send, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_acknowledgement(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_acknowledgement_t *on_acknowledgement, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_consume(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_consume_t *on_consume, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_commit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_commit_t *on_commit, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_request_sent(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_request_sent_t *on_request_sent, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_response_received(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_response_received_t *on_response_received, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_start(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_start_t *on_thread_start, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_exit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_exit_t *on_thread_exit, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_broker_state_change(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_broker_state_change_t *on_broker_state_change, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_topic_result_error(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">const char *rd_kafka_topic_result_error_string(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">const char *rd_kafka_topic_result_name(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">const rd_kafka_error_t *rd_kafka_group_result_error(const rd_kafka_group_result_t *groupres);</span>
<span class="s1">const char *rd_kafka_group_result_name(const rd_kafka_group_result_t *groupres);</span>
<span class="s1">const rd_kafka_topic_partition_list_t *rd_kafka_group_result_partitions(const rd_kafka_group_result_t *groupres);</span>
<span class="s1">typedef enum rd_kafka_admin_op_t {</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_ANY = 0,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_CREATETOPICS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DELETETOPICS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_CREATEPARTITIONS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_ALTERCONFIGS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DESCRIBECONFIGS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DELETERECORDS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DELETEGROUPS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DELETECONSUMERGROUPOFFSETS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_CREATEACLS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DESCRIBEACLS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DELETEACLS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_LISTCONSUMERGROUPS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DESCRIBECONSUMERGROUPS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_LISTCONSUMERGROUPOFFSETS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_ALTERCONSUMERGROUPOFFSETS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP__CNT,</span>
<span class="s1">} rd_kafka_admin_op_t;</span>
<span class="s1">typedef struct rd_kafka_AdminOptions_s rd_kafka_AdminOptions_t;</span>
<span class="s1">rd_kafka_AdminOptions_t *rd_kafka_AdminOptions_new(rd_kafka_t *rk, rd_kafka_admin_op_t for_api);</span>
<span class="s1">void rd_kafka_AdminOptions_destroy(rd_kafka_AdminOptions_t *options);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_request_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_operation_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_validate_only(rd_kafka_AdminOptions_t *options, int true_or_false, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_broker(rd_kafka_AdminOptions_t *options, int32_t broker_id, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_AdminOptions_set_require_stable_offsets(rd_kafka_AdminOptions_t *options, int true_or_false);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_AdminOptions_set_match_consumer_group_states(rd_kafka_AdminOptions_t *options, const rd_kafka_consumer_group_state_t *consumer_group_states, size_t consumer_group_states_cnt);</span>
<span class="s1">void rd_kafka_AdminOptions_set_opaque(rd_kafka_AdminOptions_t *options, void *ev_opaque);</span>
<span class="s1">typedef struct rd_kafka_NewTopic_s rd_kafka_NewTopic_t;</span>
<span class="s1">rd_kafka_NewTopic_t *rd_kafka_NewTopic_new(const char *topic, int num_partitions, int replication_factor, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_NewTopic_destroy(rd_kafka_NewTopic_t *new_topic);</span>
<span class="s1">void rd_kafka_NewTopic_destroy_array(rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewTopic_set_replica_assignment(rd_kafka_NewTopic_t *new_topic, int32_t partition, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewTopic_set_config(rd_kafka_NewTopic_t *new_topic, const char *name, const char *value);</span>
<span class="s1">void rd_kafka_CreateTopics(rd_kafka_t *rk, rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_CreateTopics_result_topics(const rd_kafka_CreateTopics_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_DeleteTopic_s rd_kafka_DeleteTopic_t;</span>
<span class="s1">rd_kafka_DeleteTopic_t *rd_kafka_DeleteTopic_new(const char *topic);</span>
<span class="s1">void rd_kafka_DeleteTopic_destroy(rd_kafka_DeleteTopic_t *del_topic);</span>
<span class="s1">void rd_kafka_DeleteTopic_destroy_array(rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt);</span>
<span class="s1">void rd_kafka_DeleteTopics(rd_kafka_t *rk, rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_DeleteTopics_result_topics(const rd_kafka_DeleteTopics_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_NewPartitions_s rd_kafka_NewPartitions_t;</span>
<span class="s1">rd_kafka_NewPartitions_t *rd_kafka_NewPartitions_new(const char *topic, size_t new_total_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_NewPartitions_destroy(rd_kafka_NewPartitions_t *new_parts);</span>
<span class="s1">void rd_kafka_NewPartitions_destroy_array(rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewPartitions_set_replica_assignment(rd_kafka_NewPartitions_t *new_parts, int32_t new_partition_idx, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_CreatePartitions(rd_kafka_t *rk, rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_CreatePartitions_result_topics(const rd_kafka_CreatePartitions_result_t *result, size_t *cntp);</span>
<span class="s1">typedef enum rd_kafka_ConfigSource_t {</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_UNKNOWN_CONFIG = 0,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_TOPIC_CONFIG = 1,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_BROKER_CONFIG = 2,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_DEFAULT_BROKER_CONFIG = 3,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_STATIC_BROKER_CONFIG = 4,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DEFAULT_CONFIG = 5,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE__CNT,</span>
<span class="s1">} rd_kafka_ConfigSource_t;</span>
<span class="s1">const char *rd_kafka_ConfigSource_name(rd_kafka_ConfigSource_t confsource);</span>
<span class="s1">typedef struct rd_kafka_ConfigEntry_s rd_kafka_ConfigEntry_t;</span>
<span class="s1">const char *rd_kafka_ConfigEntry_name(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">const char *rd_kafka_ConfigEntry_value(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">rd_kafka_ConfigSource_t rd_kafka_ConfigEntry_source(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_read_only(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_default(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_sensitive(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_synonym(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">const rd_kafka_ConfigEntry_t **rd_kafka_ConfigEntry_synonyms(const rd_kafka_ConfigEntry_t *entry, size_t *cntp);</span>
<span class="s1">typedef enum rd_kafka_ResourceType_t {</span>
<span class="s1">  RD_KAFKA_RESOURCE_UNKNOWN = 0,</span>
<span class="s1">  RD_KAFKA_RESOURCE_ANY = 1,</span>
<span class="s1">  RD_KAFKA_RESOURCE_TOPIC = 2,</span>
<span class="s1">  RD_KAFKA_RESOURCE_GROUP = 3,</span>
<span class="s1">  RD_KAFKA_RESOURCE_BROKER = 4,</span>
<span class="s1">  RD_KAFKA_RESOURCE__CNT,</span>
<span class="s1">} rd_kafka_ResourceType_t;</span>
<span class="s1">typedef enum rd_kafka_ResourcePatternType_t {</span>
<span class="s1">  RD_KAFKA_RESOURCE_PATTERN_UNKNOWN = 0,</span>
<span class="s1">  RD_KAFKA_RESOURCE_PATTERN_ANY = 1,</span>
<span class="s1">  RD_KAFKA_RESOURCE_PATTERN_MATCH = 2,</span>
<span class="s1">  RD_KAFKA_RESOURCE_PATTERN_LITERAL = 3,</span>
<span class="s1">  RD_KAFKA_RESOURCE_PATTERN_PREFIXED = 4,</span>
<span class="s1">  RD_KAFKA_RESOURCE_PATTERN_TYPE__CNT,</span>
<span class="s1">} rd_kafka_ResourcePatternType_t;</span>
<span class="s1">const char *rd_kafka_ResourcePatternType_name(rd_kafka_ResourcePatternType_t resource_pattern_type);</span>
<span class="s1">const char *rd_kafka_ResourceType_name(rd_kafka_ResourceType_t restype);</span>
<span class="s1">typedef struct rd_kafka_ConfigResource_s rd_kafka_ConfigResource_t;</span>
<span class="s1">rd_kafka_ConfigResource_t *rd_kafka_ConfigResource_new(rd_kafka_ResourceType_t restype, const char *resname);</span>
<span class="s1">void rd_kafka_ConfigResource_destroy(rd_kafka_ConfigResource_t *config);</span>
<span class="s1">void rd_kafka_ConfigResource_destroy_array(rd_kafka_ConfigResource_t **config, size_t config_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_ConfigResource_set_config(rd_kafka_ConfigResource_t *config, const char *name, const char *value);</span>
<span class="s1">const rd_kafka_ConfigEntry_t **rd_kafka_ConfigResource_configs(const rd_kafka_ConfigResource_t *config, size_t *cntp);</span>
<span class="s1">rd_kafka_ResourceType_t rd_kafka_ConfigResource_type(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">const char *rd_kafka_ConfigResource_name(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_ConfigResource_error(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">const char *rd_kafka_ConfigResource_error_string(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">void rd_kafka_AlterConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_ConfigResource_t **rd_kafka_AlterConfigs_result_resources(const rd_kafka_AlterConfigs_result_t *result, size_t *cntp);</span>
<span class="s1">void rd_kafka_DescribeConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_ConfigResource_t **rd_kafka_DescribeConfigs_result_resources(const rd_kafka_DescribeConfigs_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_DeleteRecords_s rd_kafka_DeleteRecords_t;</span>
<span class="s1">rd_kafka_DeleteRecords_t *rd_kafka_DeleteRecords_new(const rd_kafka_topic_partition_list_t *before_offsets);</span>
<span class="s1">void rd_kafka_DeleteRecords_destroy(rd_kafka_DeleteRecords_t *del_records);</span>
<span class="s1">void rd_kafka_DeleteRecords_destroy_array(rd_kafka_DeleteRecords_t **del_records, size_t del_record_cnt);</span>
<span class="s1">void rd_kafka_DeleteRecords(rd_kafka_t *rk, rd_kafka_DeleteRecords_t **del_records, size_t del_record_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_partition_list_t *rd_kafka_DeleteRecords_result_offsets(const rd_kafka_DeleteRecords_result_t *result);</span>
<span class="s1">typedef struct rd_kafka_ConsumerGroupListing_s rd_kafka_ConsumerGroupListing_t;</span>
<span class="s1">typedef struct rd_kafka_ListConsumerGroupsResult_s rd_kafka_ListConsumerGroupsResult_t;</span>
<span class="s1">void rd_kafka_ListConsumerGroups(rd_kafka_t *rk, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const char *rd_kafka_ConsumerGroupListing_group_id(const rd_kafka_ConsumerGroupListing_t *grplist);</span>
<span class="s1">int rd_kafka_ConsumerGroupListing_is_simple_consumer_group(const rd_kafka_ConsumerGroupListing_t *grplist);</span>
<span class="s1">rd_kafka_consumer_group_state_t rd_kafka_ConsumerGroupListing_state(const rd_kafka_ConsumerGroupListing_t *grplist);</span>
<span class="s1">const rd_kafka_ConsumerGroupListing_t **rd_kafka_ListConsumerGroups_result_valid(const rd_kafka_ListConsumerGroups_result_t *result, size_t *cntp);</span>
<span class="s1">const rd_kafka_error_t **rd_kafka_ListConsumerGroups_result_errors(const rd_kafka_ListConsumerGroups_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_ConsumerGroupDescription_s rd_kafka_ConsumerGroupDescription_t;</span>
<span class="s1">typedef struct rd_kafka_MemberDescription_s rd_kafka_MemberDescription_t;</span>
<span class="s1">typedef struct rd_kafka_MemberAssignment_s rd_kafka_MemberAssignment_t;</span>
<span class="s1">void rd_kafka_DescribeConsumerGroups(rd_kafka_t *rk, const char **groups, size_t groups_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_ConsumerGroupDescription_t **rd_kafka_DescribeConsumerGroups_result_groups(const rd_kafka_DescribeConsumerGroups_result_t *result, size_t *cntp);</span>
<span class="s1">const char *rd_kafka_ConsumerGroupDescription_group_id(const rd_kafka_ConsumerGroupDescription_t *grpdesc);</span>
<span class="s1">const rd_kafka_error_t *rd_kafka_ConsumerGroupDescription_error(const rd_kafka_ConsumerGroupDescription_t *grpdesc);</span>
<span class="s1">int rd_kafka_ConsumerGroupDescription_is_simple_consumer_group(const rd_kafka_ConsumerGroupDescription_t *grpdesc);</span>
<span class="s1">const char *rd_kafka_ConsumerGroupDescription_partition_assignor(const rd_kafka_ConsumerGroupDescription_t *grpdesc);</span>
<span class="s1">rd_kafka_consumer_group_state_t rd_kafka_ConsumerGroupDescription_state(const rd_kafka_ConsumerGroupDescription_t *grpdesc);</span>
<span class="s1">const rd_kafka_Node_t *rd_kafka_ConsumerGroupDescription_coordinator(const rd_kafka_ConsumerGroupDescription_t *grpdesc);</span>
<span class="s1">size_t rd_kafka_ConsumerGroupDescription_member_count(const rd_kafka_ConsumerGroupDescription_t *grpdesc);</span>
<span class="s1">const rd_kafka_MemberDescription_t *rd_kafka_ConsumerGroupDescription_member(const rd_kafka_ConsumerGroupDescription_t *grpdesc, size_t idx);</span>
<span class="s1">const char *rd_kafka_MemberDescription_client_id(const rd_kafka_MemberDescription_t *member);</span>
<span class="s1">const char *rd_kafka_MemberDescription_group_instance_id(const rd_kafka_MemberDescription_t *member);</span>
<span class="s1">const char *rd_kafka_MemberDescription_consumer_id(const rd_kafka_MemberDescription_t *member);</span>
<span class="s1">const char *rd_kafka_MemberDescription_host(const rd_kafka_MemberDescription_t *member);</span>
<span class="s1">const rd_kafka_MemberAssignment_t *rd_kafka_MemberDescription_assignment(const rd_kafka_MemberDescription_t *member);</span>
<span class="s1">const rd_kafka_topic_partition_list_t *rd_kafka_MemberAssignment_partitions(const rd_kafka_MemberAssignment_t *assignment);</span>
<span class="s1">typedef struct rd_kafka_DeleteGroup_s rd_kafka_DeleteGroup_t;</span>
<span class="s1">rd_kafka_DeleteGroup_t *rd_kafka_DeleteGroup_new(const char *group);</span>
<span class="s1">void rd_kafka_DeleteGroup_destroy(rd_kafka_DeleteGroup_t *del_group);</span>
<span class="s1">void rd_kafka_DeleteGroup_destroy_array(rd_kafka_DeleteGroup_t **del_groups, size_t del_group_cnt);</span>
<span class="s1">void rd_kafka_DeleteGroups(rd_kafka_t *rk, rd_kafka_DeleteGroup_t **del_groups, size_t del_group_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_group_result_t **rd_kafka_DeleteGroups_result_groups(const rd_kafka_DeleteGroups_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_ListConsumerGroupOffsets_s rd_kafka_ListConsumerGroupOffsets_t;</span>
<span class="s1">rd_kafka_ListConsumerGroupOffsets_t *rd_kafka_ListConsumerGroupOffsets_new(const char *group_id, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">void rd_kafka_ListConsumerGroupOffsets_destroy(rd_kafka_ListConsumerGroupOffsets_t *list_grpoffsets);</span>
<span class="s1">void rd_kafka_ListConsumerGroupOffsets_destroy_array(rd_kafka_ListConsumerGroupOffsets_t **list_grpoffsets, size_t list_grpoffset_cnt);</span>
<span class="s1">void rd_kafka_ListConsumerGroupOffsets(rd_kafka_t *rk, rd_kafka_ListConsumerGroupOffsets_t **list_grpoffsets, size_t list_grpoffsets_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_group_result_t **rd_kafka_ListConsumerGroupOffsets_result_groups(const rd_kafka_ListConsumerGroupOffsets_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_AlterConsumerGroupOffsets_s rd_kafka_AlterConsumerGroupOffsets_t;</span>
<span class="s1">rd_kafka_AlterConsumerGroupOffsets_t *rd_kafka_AlterConsumerGroupOffsets_new(const char *group_id, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">void rd_kafka_AlterConsumerGroupOffsets_destroy(rd_kafka_AlterConsumerGroupOffsets_t *alter_grpoffsets);</span>
<span class="s1">void rd_kafka_AlterConsumerGroupOffsets_destroy_array(rd_kafka_AlterConsumerGroupOffsets_t **alter_grpoffsets, size_t alter_grpoffset_cnt);</span>
<span class="s1">void rd_kafka_AlterConsumerGroupOffsets(rd_kafka_t *rk, rd_kafka_AlterConsumerGroupOffsets_t **alter_grpoffsets, size_t alter_grpoffsets_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_group_result_t **rd_kafka_AlterConsumerGroupOffsets_result_groups(const rd_kafka_AlterConsumerGroupOffsets_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_DeleteConsumerGroupOffsets_s rd_kafka_DeleteConsumerGroupOffsets_t;</span>
<span class="s1">rd_kafka_DeleteConsumerGroupOffsets_t *rd_kafka_DeleteConsumerGroupOffsets_new(const char *group, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">void rd_kafka_DeleteConsumerGroupOffsets_destroy(rd_kafka_DeleteConsumerGroupOffsets_t *del_grpoffsets);</span>
<span class="s1">void rd_kafka_DeleteConsumerGroupOffsets_destroy_array(rd_kafka_DeleteConsumerGroupOffsets_t **del_grpoffsets, size_t del_grpoffset_cnt);</span>
<span class="s1">void rd_kafka_DeleteConsumerGroupOffsets(rd_kafka_t *rk, rd_kafka_DeleteConsumerGroupOffsets_t **del_grpoffsets, size_t del_grpoffsets_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_group_result_t **rd_kafka_DeleteConsumerGroupOffsets_result_groups(const rd_kafka_DeleteConsumerGroupOffsets_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_AclBinding_s rd_kafka_AclBinding_t;</span>
<span class="s1">typedef rd_kafka_AclBinding_t rd_kafka_AclBindingFilter_t;</span>
<span class="s1">const rd_kafka_error_t *rd_kafka_acl_result_error(const rd_kafka_acl_result_t *aclres);</span>
<span class="s1">typedef enum rd_kafka_AclOperation_t {</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_UNKNOWN = 0,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_ANY = 1,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_ALL = 2,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_READ = 3,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_WRITE = 4,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_CREATE = 5,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_DELETE = 6,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_ALTER = 7,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_DESCRIBE = 8,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_CLUSTER_ACTION = 9,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_DESCRIBE_CONFIGS = 10,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_ALTER_CONFIGS = 11,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_IDEMPOTENT_WRITE = 12,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION__CNT,</span>
<span class="s1">} rd_kafka_AclOperation_t;</span>
<span class="s1">const char *rd_kafka_AclOperation_name(rd_kafka_AclOperation_t acl_operation);</span>
<span class="s1">typedef enum rd_kafka_AclPermissionType_t {</span>
<span class="s1">  RD_KAFKA_ACL_PERMISSION_TYPE_UNKNOWN = 0,</span>
<span class="s1">  RD_KAFKA_ACL_PERMISSION_TYPE_ANY = 1,</span>
<span class="s1">  RD_KAFKA_ACL_PERMISSION_TYPE_DENY = 2,</span>
<span class="s1">  RD_KAFKA_ACL_PERMISSION_TYPE_ALLOW = 3,</span>
<span class="s1">  RD_KAFKA_ACL_PERMISSION_TYPE__CNT,</span>
<span class="s1">} rd_kafka_AclPermissionType_t;</span>
<span class="s1">const char *rd_kafka_AclPermissionType_name(rd_kafka_AclPermissionType_t acl_permission_type);</span>
<span class="s1">rd_kafka_AclBinding_t *rd_kafka_AclBinding_new(rd_kafka_ResourceType_t restype, const char *name, rd_kafka_ResourcePatternType_t resource_pattern_type, const char *principal, const char *host, rd_kafka_AclOperation_t operation, rd_kafka_AclPermissionType_t permission_type, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_AclBindingFilter_t *rd_kafka_AclBindingFilter_new(rd_kafka_ResourceType_t restype, const char *name, rd_kafka_ResourcePatternType_t resource_pattern_type, const char *principal, const char *host, rd_kafka_AclOperation_t operation, rd_kafka_AclPermissionType_t permission_type, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_ResourceType_t rd_kafka_AclBinding_restype(const rd_kafka_AclBinding_t *acl);</span>
<span class="s1">const char *rd_kafka_AclBinding_name(const rd_kafka_AclBinding_t *acl);</span>
<span class="s1">const char *rd_kafka_AclBinding_principal(const rd_kafka_AclBinding_t *acl);</span>
<span class="s1">const char *rd_kafka_AclBinding_host(const rd_kafka_AclBinding_t *acl);</span>
<span class="s1">rd_kafka_AclOperation_t rd_kafka_AclBinding_operation(const rd_kafka_AclBinding_t *acl);</span>
<span class="s1">rd_kafka_AclPermissionType_t rd_kafka_AclBinding_permission_type(const rd_kafka_AclBinding_t *acl);</span>
<span class="s1">rd_kafka_ResourcePatternType_t rd_kafka_AclBinding_resource_pattern_type(const rd_kafka_AclBinding_t *acl);</span>
<span class="s1">const rd_kafka_error_t *rd_kafka_AclBinding_error(const rd_kafka_AclBinding_t *acl);</span>
<span class="s1">void rd_kafka_AclBinding_destroy(rd_kafka_AclBinding_t *acl_binding);</span>
<span class="s1">void rd_kafka_AclBinding_destroy_array(rd_kafka_AclBinding_t **acl_bindings, size_t acl_bindings_cnt);</span>
<span class="s1">const rd_kafka_acl_result_t **rd_kafka_CreateAcls_result_acls(const rd_kafka_CreateAcls_result_t *result, size_t *cntp);</span>
<span class="s1">void rd_kafka_CreateAcls(rd_kafka_t *rk, rd_kafka_AclBinding_t **new_acls, size_t new_acls_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_AclBinding_t **rd_kafka_DescribeAcls_result_acls(const rd_kafka_DescribeAcls_result_t *result, size_t *cntp);</span>
<span class="s1">void rd_kafka_DescribeAcls(rd_kafka_t *rk, rd_kafka_AclBindingFilter_t *acl_filter, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">typedef struct rd_kafka_DeleteAcls_result_response_s rd_kafka_DeleteAcls_result_response_t;</span>
<span class="s1">const rd_kafka_DeleteAcls_result_response_t **rd_kafka_DeleteAcls_result_responses(const rd_kafka_DeleteAcls_result_t *result, size_t *cntp);</span>
<span class="s1">const rd_kafka_error_t *rd_kafka_DeleteAcls_result_response_error(const rd_kafka_DeleteAcls_result_response_t *result_response);</span>
<span class="s1">const rd_kafka_AclBinding_t **rd_kafka_DeleteAcls_result_response_matching_acls(const rd_kafka_DeleteAcls_result_response_t *result_response, size_t *matching_acls_cntp);</span>
<span class="s1">void rd_kafka_DeleteAcls(rd_kafka_t *rk, rd_kafka_AclBindingFilter_t **del_acls, size_t del_acls_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token(rd_kafka_t *rk, const char *token_value, int64_t md_lifetime_ms, const char *md_principal_name, const char **extensions, size_t extension_size, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token_failure(rd_kafka_t *rk, const char *errstr);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_init_transactions(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_begin_transaction(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_send_offsets_to_transaction(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, const rd_kafka_consumer_group_metadata_t *cgmetadata, int timeout_ms);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_commit_transaction(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_abort_transaction(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">typedef struct rd_kafka_mock_cluster_s rd_kafka_mock_cluster_t;</span>
<span class="s1">rd_kafka_mock_cluster_t *rd_kafka_mock_cluster_new(rd_kafka_t *rk, int broker_cnt);</span>
<span class="s1">void rd_kafka_mock_cluster_destroy(rd_kafka_mock_cluster_t *mcluster);</span>
<span class="s1">rd_kafka_t *rd_kafka_mock_cluster_handle(const rd_kafka_mock_cluster_t *mcluster);</span>
<span class="s1">rd_kafka_mock_cluster_t *rd_kafka_handle_mock_cluster(const rd_kafka_t *rk);</span>
<span class="s1">const char *rd_kafka_mock_cluster_bootstraps(const rd_kafka_mock_cluster_t *mcluster);</span>
<span class="s1">void rd_kafka_mock_clear_request_errors(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey);</span>
<span class="s1">void rd_kafka_mock_push_request_errors(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, size_t cnt, ...);</span>
<span class="s1">void rd_kafka_mock_push_request_errors_array(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, size_t cnt, const rd_kafka_resp_err_t *errors);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_push_request_error_rtts(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int16_t ApiKey, size_t cnt, ...);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_error_stack_cnt(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int16_t ApiKey, size_t *cntp);</span>
<span class="s1">void rd_kafka_mock_topic_set_error(rd_kafka_mock_cluster_t *mcluster, const char *topic, rd_kafka_resp_err_t err);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_topic_create(rd_kafka_mock_cluster_t *mcluster, const char *topic, int partition_cnt, int replication_factor);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_partition_set_leader(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_partition_set_follower(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_partition_set_follower_wmarks(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int64_t lo, int64_t hi);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_set_down(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_set_up(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_set_rtt(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int rtt_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_set_rack(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, const char *rack);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_coordinator_set(rd_kafka_mock_cluster_t *mcluster, const char *key_type, const char *key, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_set_apiversion(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, int16_t MinVersion, int16_t MaxVersion);</span>
<span class="s1">&#39;</span>
</code></pre></div>
rdkafka.h, rdkafka_mock.h</p>
<h3 id="rd_kafka_version_24">RD_KAFKA_VERSION<a class="headerlink" href="#rd_kafka_version_24" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_VERSION</span> <span class="o">=</span> <span class="mi">33555199</span>
</code></pre></div>
<p>librdkafka version </p>
<p>Interpreted as hex <code>MM.mm.rr.xx</code>:</p>
<ul>
<li>MM = Major</li>
<li>mm = minor</li>
<li>rr = revision</li>
<li>xx = pre-release id (0xff is the final release)</li>
</ul>
<p>E.g.: <code>0x000801ff</code> = 0.8.1</p>
<dl class="section remark"><dt>Remarks</dt><dd>This value should only be used during compile time, for runtime checks of version use rd_kafka_version() </dd></dl>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_unsupported_compression_type_24">RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE<a class="headerlink" href="#rd_kafka_resp_err_unsupported_compression_type_24" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE</span> <span class="o">=</span> <span class="mi">76</span>
</code></pre></div>
<p>Unsupported compression type </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_end_all_24">RD_KAFKA_RESP_ERR_END_ALL<a class="headerlink" href="#rd_kafka_resp_err_end_all_24" title="Permanent link">&para;</a></h3>
<p><div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_END_ALL</span> <span class="o">=</span> <span class="mi">98</span>
</code></pre></div>
enum rd_kafka_resp_err_t</p>
<h3 id="rd_kafka_admin_op__cnt_24">RD_KAFKA_ADMIN_OP__CNT<a class="headerlink" href="#rd_kafka_admin_op__cnt_24" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_ADMIN_OP__CNT</span> <span class="o">=</span> <span class="mi">16</span>
</code></pre></div>
<p>Number of ops defined </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe </a></li>
</ul>
</div>
<h3 id="rd_kafka_resource__cnt_24">RD_KAFKA_RESOURCE__CNT<a class="headerlink" href="#rd_kafka_resource__cnt_24" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESOURCE__CNT</span> <span class="o">=</span> <span class="mi">5</span>
</code></pre></div>
<p>Number of resource types defined </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#acca83a66d7783ff7683ed2691cc907c9"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#acca83a66d7783ff7683ed2691cc907c9 </a></li>
</ul>
</div>
<h3 id="rd_kafka_cdef_24">RD_KAFKA_CDEF<a class="headerlink" href="#rd_kafka_cdef_24" title="Permanent link">&para;</a></h3>
<p><div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_CDEF</span> <span class="o">=</span> <span class="s1">&#39;typedef long int ssize_t;</span>
<span class="s1">typedef struct _IO_FILE FILE;</span>
<span class="s1">typedef long int mode_t;</span>
<span class="s1">typedef signed int int16_t;</span>
<span class="s1">typedef unsigned int uint16_t;</span>
<span class="s1">typedef signed int int32_t;</span>
<span class="s1">typedef signed long int int64_t;</span>
<span class="s1">int rd_kafka_version(void);</span>
<span class="s1">const char *rd_kafka_version_str(void);</span>
<span class="s1">typedef enum rd_kafka_type_t {</span>
<span class="s1">  RD_KAFKA_PRODUCER,</span>
<span class="s1">  RD_KAFKA_CONSUMER,</span>
<span class="s1">} rd_kafka_type_t;</span>
<span class="s1">typedef enum rd_kafka_timestamp_type_t {</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_NOT_AVAILABLE,</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_CREATE_TIME,</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_LOG_APPEND_TIME,</span>
<span class="s1">} rd_kafka_timestamp_type_t;</span>
<span class="s1">const char *rd_kafka_get_debug_contexts(void);</span>
<span class="s1">typedef struct rd_kafka_s rd_kafka_t;</span>
<span class="s1">typedef struct rd_kafka_topic_s rd_kafka_topic_t;</span>
<span class="s1">typedef struct rd_kafka_conf_s rd_kafka_conf_t;</span>
<span class="s1">typedef struct rd_kafka_topic_conf_s rd_kafka_topic_conf_t;</span>
<span class="s1">typedef struct rd_kafka_queue_s rd_kafka_queue_t;</span>
<span class="s1">typedef struct rd_kafka_op_s rd_kafka_event_t;</span>
<span class="s1">typedef struct rd_kafka_topic_result_s rd_kafka_topic_result_t;</span>
<span class="s1">typedef struct rd_kafka_consumer_group_metadata_s rd_kafka_consumer_group_metadata_t;</span>
<span class="s1">typedef struct rd_kafka_error_s {</span>
<span class="s1">  unsigned int code;</span>
<span class="s1">  char *errstr;</span>
<span class="s1">  unsigned char fatal;</span>
<span class="s1">  unsigned char retriable;</span>
<span class="s1">  unsigned char txn_requires_abort;</span>
<span class="s1">} rd_kafka_error_t;</span>
<span class="s1">typedef struct rd_kafka_headers_s rd_kafka_headers_t;</span>
<span class="s1">typedef struct rd_kafka_group_result_s rd_kafka_group_result_t;</span>
<span class="s1">typedef struct rd_kafka_acl_result_s rd_kafka_acl_result_t;</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BEGIN = (- 200),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BAD_MSG = (- 199),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BAD_COMPRESSION = (- 198),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__DESTROY = (- 197),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FAIL = (- 196),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TRANSPORT = (- 195),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__CRIT_SYS_RESOURCE = (- 194),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__RESOLVE = (- 193),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__MSG_TIMED_OUT = (- 192),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PARTITION_EOF = (- 191),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION = (- 190),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FS = (- 189),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC = (- 188),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ALL_BROKERS_DOWN = (- 187),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INVALID_ARG = (- 186),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TIMED_OUT = (- 185),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__QUEUE_FULL = (- 184),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ISR_INSUFF = (- 183),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NODE_UPDATE = (- 182),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__SSL = (- 181),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__WAIT_COORD = (- 180),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_GROUP = (- 179),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__IN_PROGRESS = (- 178),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PREV_IN_PROGRESS = (- 177),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__EXISTING_SUBSCRIPTION = (- 176),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS = (- 175),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS = (- 174),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__CONFLICT = (- 173),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__STATE = (- 172),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_PROTOCOL = (- 171),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED = (- 170),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__AUTHENTICATION = (- 169),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NO_OFFSET = (- 168),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__OUTDATED = (- 167),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TIMED_OUT_QUEUE = (- 166),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNSUPPORTED_FEATURE = (- 165),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__WAIT_CACHE = (- 164),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INTR = (- 163),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__KEY_SERIALIZATION = (- 162),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__VALUE_SERIALIZATION = (- 161),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__KEY_DESERIALIZATION = (- 160),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__VALUE_DESERIALIZATION = (- 159),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PARTIAL = (- 158),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__READ_ONLY = (- 157),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOENT = (- 156),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNDERFLOW = (- 155),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INVALID_TYPE = (- 154),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__RETRY = (- 153),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PURGE_QUEUE = (- 152),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PURGE_INFLIGHT = (- 151),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FATAL = (- 150),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INCONSISTENT = (- 149),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__GAPLESS_GUARANTEE = (- 148),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__MAX_POLL_EXCEEDED = (- 147),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_BROKER = (- 146),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOT_CONFIGURED = (- 145),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FENCED = (- 144),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__APPLICATION = (- 143),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ASSIGNMENT_LOST = (- 142),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOOP = (- 141),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__AUTO_OFFSET_RESET = (- 140),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__END = (- 100),</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN = (- 1),</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NO_ERROR = 0,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_OUT_OF_RANGE = 1,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_MSG = 2,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART = 3,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_MSG_SIZE = 4,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE = 5,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_LEADER_FOR_PARTITION = 6,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REQUEST_TIMED_OUT = 7,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_BROKER_NOT_AVAILABLE = 8,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REPLICA_NOT_AVAILABLE = 9,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE = 10,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_STALE_CTRL_EPOCH = 11,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_METADATA_TOO_LARGE = 12,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NETWORK_EXCEPTION = 13,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_COORDINATOR_LOAD_IN_PROGRESS = 14,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_COORDINATOR_NOT_AVAILABLE = 15,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_COORDINATOR = 16,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_EXCEPTION = 17,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_RECORD_LIST_TOO_LARGE = 18,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS = 19,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS_AFTER_APPEND = 20,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REQUIRED_ACKS = 21,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ILLEGAL_GENERATION = 22,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INCONSISTENT_GROUP_PROTOCOL = 23,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_GROUP_ID = 24,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_MEMBER_ID = 25,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_SESSION_TIMEOUT = 26,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REBALANCE_IN_PROGRESS = 27,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_COMMIT_OFFSET_SIZE = 28,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_AUTHORIZATION_FAILED = 29,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_AUTHORIZATION_FAILED = 30,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_CLUSTER_AUTHORIZATION_FAILED = 31,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TIMESTAMP = 32,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_SASL_MECHANISM = 33,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ILLEGAL_SASL_STATE = 34,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_VERSION = 35,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_ALREADY_EXISTS = 36,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PARTITIONS = 37,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REPLICATION_FACTOR = 38,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REPLICA_ASSIGNMENT = 39,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_CONFIG = 40,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_CONTROLLER = 41,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REQUEST = 42,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_FOR_MESSAGE_FORMAT = 43,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_POLICY_VIOLATION = 44,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OUT_OF_ORDER_SEQUENCE_NUMBER = 45,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DUPLICATE_SEQUENCE_NUMBER = 46,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_EPOCH = 47,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TXN_STATE = 48,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_ID_MAPPING = 49,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TRANSACTION_TIMEOUT = 50,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_CONCURRENT_TRANSACTIONS = 51,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TRANSACTION_COORDINATOR_FENCED = 52,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TRANSACTIONAL_ID_AUTHORIZATION_FAILED = 53,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_SECURITY_DISABLED = 54,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OPERATION_NOT_ATTEMPTED = 55,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_KAFKA_STORAGE_ERROR = 56,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LOG_DIR_NOT_FOUND = 57,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_SASL_AUTHENTICATION_FAILED = 58,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_PRODUCER_ID = 59,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REASSIGNMENT_IN_PROGRESS = 60,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTH_DISABLED = 61,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_NOT_FOUND = 62,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_OWNER_MISMATCH = 63,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_REQUEST_NOT_ALLOWED = 64,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTHORIZATION_FAILED = 65,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_EXPIRED = 66,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRINCIPAL_TYPE = 67,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NON_EMPTY_GROUP = 68,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_ID_NOT_FOUND = 69,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FETCH_SESSION_ID_NOT_FOUND = 70,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_FETCH_SESSION_EPOCH = 71,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LISTENER_NOT_FOUND = 72,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_DELETION_DISABLED = 73,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FENCED_LEADER_EPOCH = 74,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_LEADER_EPOCH = 75,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_STALE_BROKER_EPOCH = 77,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_NOT_AVAILABLE = 78,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_MEMBER_ID_REQUIRED = 79,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_PREFERRED_LEADER_NOT_AVAILABLE = 80,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_MAX_SIZE_REACHED = 81,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FENCED_INSTANCE_ID = 82,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ELIGIBLE_LEADERS_NOT_AVAILABLE = 83,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ELECTION_NOT_NEEDED = 84,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NO_REASSIGNMENT_IN_PROGRESS = 85,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_SUBSCRIBED_TO_TOPIC = 86,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_RECORD = 87,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSTABLE_OFFSET_COMMIT = 88,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_THROTTLING_QUOTA_EXCEEDED = 89,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_PRODUCER_FENCED = 90,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_RESOURCE_NOT_FOUND = 91,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DUPLICATE_RESOURCE = 92,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNACCEPTABLE_CREDENTIAL = 93,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INCONSISTENT_VOTER_SET = 94,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_UPDATE_VERSION = 95,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FEATURE_UPDATE_FAILED = 96,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_PRINCIPAL_DESERIALIZATION_FAILURE = 97,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_END_ALL,</span>
<span class="s1">} rd_kafka_resp_err_t;</span>
<span class="s1">struct rd_kafka_err_desc {</span>
<span class="s1">  rd_kafka_resp_err_t code;</span>
<span class="s1">  char *name;</span>
<span class="s1">  char *desc;</span>
<span class="s1">};</span>
<span class="s1">void rd_kafka_get_err_descs(const struct rd_kafka_err_desc **errdescs, size_t *cntp);</span>
<span class="s1">const char *rd_kafka_err2str(rd_kafka_resp_err_t err);</span>
<span class="s1">const char *rd_kafka_err2name(rd_kafka_resp_err_t err);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_last_error(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_errno2err(int errnox);</span>
<span class="s1">int rd_kafka_errno(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_fatal_error(rd_kafka_t *rk, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_test_fatal_error(rd_kafka_t *rk, rd_kafka_resp_err_t err, const char *reason);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_error_code(const rd_kafka_error_t *error);</span>
<span class="s1">const char *rd_kafka_error_name(const rd_kafka_error_t *error);</span>
<span class="s1">const char *rd_kafka_error_string(const rd_kafka_error_t *error);</span>
<span class="s1">int rd_kafka_error_is_fatal(const rd_kafka_error_t *error);</span>
<span class="s1">int rd_kafka_error_is_retriable(const rd_kafka_error_t *error);</span>
<span class="s1">int rd_kafka_error_txn_requires_abort(const rd_kafka_error_t *error);</span>
<span class="s1">void rd_kafka_error_destroy(rd_kafka_error_t *error);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_error_new(rd_kafka_resp_err_t code, const char *fmt, ...);</span>
<span class="s1">typedef struct rd_kafka_topic_partition_s {</span>
<span class="s1">  char *topic;</span>
<span class="s1">  int32_t partition;</span>
<span class="s1">  int64_t offset;</span>
<span class="s1">  void *metadata;</span>
<span class="s1">  size_t metadata_size;</span>
<span class="s1">  void *opaque;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  void *_private;</span>
<span class="s1">} rd_kafka_topic_partition_t;</span>
<span class="s1">void rd_kafka_topic_partition_destroy(rd_kafka_topic_partition_t *rktpar);</span>
<span class="s1">typedef struct rd_kafka_topic_partition_list_s {</span>
<span class="s1">  int cnt;</span>
<span class="s1">  int size;</span>
<span class="s1">  rd_kafka_topic_partition_t *elems;</span>
<span class="s1">} rd_kafka_topic_partition_list_t;</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_new(int size);</span>
<span class="s1">void rd_kafka_topic_partition_list_destroy(rd_kafka_topic_partition_list_t *rkparlist);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_add(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">void rd_kafka_topic_partition_list_add_range(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t start, int32_t stop);</span>
<span class="s1">int rd_kafka_topic_partition_list_del(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">int rd_kafka_topic_partition_list_del_by_idx(rd_kafka_topic_partition_list_t *rktparlist, int idx);</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_copy(const rd_kafka_topic_partition_list_t *src);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_topic_partition_list_set_offset(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition, int64_t offset);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_find(const rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">void rd_kafka_topic_partition_list_sort(rd_kafka_topic_partition_list_t *rktparlist, int (*cmp)(const void *a, const void *b, void *cmp_opaque), void *cmp_opaque);</span>
<span class="s1">typedef enum rd_kafka_vtype_t {</span>
<span class="s1">  RD_KAFKA_VTYPE_END,</span>
<span class="s1">  RD_KAFKA_VTYPE_TOPIC,</span>
<span class="s1">  RD_KAFKA_VTYPE_RKT,</span>
<span class="s1">  RD_KAFKA_VTYPE_PARTITION,</span>
<span class="s1">  RD_KAFKA_VTYPE_VALUE,</span>
<span class="s1">  RD_KAFKA_VTYPE_KEY,</span>
<span class="s1">  RD_KAFKA_VTYPE_OPAQUE,</span>
<span class="s1">  RD_KAFKA_VTYPE_MSGFLAGS,</span>
<span class="s1">  RD_KAFKA_VTYPE_TIMESTAMP,</span>
<span class="s1">  RD_KAFKA_VTYPE_HEADER,</span>
<span class="s1">  RD_KAFKA_VTYPE_HEADERS,</span>
<span class="s1">} rd_kafka_vtype_t;</span>
<span class="s1">typedef struct rd_kafka_vu_s {</span>
<span class="s1">  rd_kafka_vtype_t vtype;</span>
<span class="s1">  union {</span>
<span class="s1">    char *cstr;</span>
<span class="s1">    rd_kafka_topic_t *rkt;</span>
<span class="s1">    int i;</span>
<span class="s1">    int32_t i32;</span>
<span class="s1">    int64_t i64;</span>
<span class="s1">    struct {</span>
<span class="s1">      void *ptr;</span>
<span class="s1">      size_t size;</span>
<span class="s1">    } mem;</span>
<span class="s1">    struct {</span>
<span class="s1">      char *name;</span>
<span class="s1">      void *val;</span>
<span class="s1">      ssize_t size;</span>
<span class="s1">    } header;</span>
<span class="s1">    rd_kafka_headers_t *headers;</span>
<span class="s1">    void *ptr;</span>
<span class="s1">    char _pad[64];</span>
<span class="s1">  } u;</span>
<span class="s1">} rd_kafka_vu_t;</span>
<span class="s1">rd_kafka_headers_t *rd_kafka_headers_new(size_t initial_count);</span>
<span class="s1">void rd_kafka_headers_destroy(rd_kafka_headers_t *hdrs);</span>
<span class="s1">rd_kafka_headers_t *rd_kafka_headers_copy(const rd_kafka_headers_t *src);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_add(rd_kafka_headers_t *hdrs, const char *name, ssize_t name_size, const void *value, ssize_t value_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_remove(rd_kafka_headers_t *hdrs, const char *name);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get_last(const rd_kafka_headers_t *hdrs, const char *name, const void **valuep, size_t *sizep);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get(const rd_kafka_headers_t *hdrs, size_t idx, const char *name, const void **valuep, size_t *sizep);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get_all(const rd_kafka_headers_t *hdrs, size_t idx, const char **namep, const void **valuep, size_t *sizep);</span>
<span class="s1">typedef struct rd_kafka_message_s {</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  rd_kafka_topic_t *rkt;</span>
<span class="s1">  int32_t partition;</span>
<span class="s1">  void *payload;</span>
<span class="s1">  size_t len;</span>
<span class="s1">  void *key;</span>
<span class="s1">  size_t key_len;</span>
<span class="s1">  int64_t offset;</span>
<span class="s1">  void *_private;</span>
<span class="s1">} rd_kafka_message_t;</span>
<span class="s1">void rd_kafka_message_destroy(rd_kafka_message_t *rkmessage);</span>
<span class="s1">const char *rd_kafka_message_errstr(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">int64_t rd_kafka_message_timestamp(const rd_kafka_message_t *rkmessage, rd_kafka_timestamp_type_t *tstype);</span>
<span class="s1">int64_t rd_kafka_message_latency(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">int32_t rd_kafka_message_broker_id(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_message_headers(const rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_message_detach_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);</span>
<span class="s1">void rd_kafka_message_set_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t *hdrs);</span>
<span class="s1">size_t rd_kafka_header_cnt(const rd_kafka_headers_t *hdrs);</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_NOT_PERSISTED = 0,</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_POSSIBLY_PERSISTED = 1,</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_PERSISTED = 2,</span>
<span class="s1">} rd_kafka_msg_status_t;</span>
<span class="s1">rd_kafka_msg_status_t rd_kafka_message_status(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_CONF_UNKNOWN = (- 2),</span>
<span class="s1">  RD_KAFKA_CONF_INVALID = (- 1),</span>
<span class="s1">  RD_KAFKA_CONF_OK = 0,</span>
<span class="s1">} rd_kafka_conf_res_t;</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_new(void);</span>
<span class="s1">void rd_kafka_conf_destroy(rd_kafka_conf_t *conf);</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_dup(const rd_kafka_conf_t *conf);</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_dup_filter(const rd_kafka_conf_t *conf, size_t filter_cnt, const char **filter);</span>
<span class="s1">const rd_kafka_conf_t *rd_kafka_conf(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_set(rd_kafka_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_conf_set_events(rd_kafka_conf_t *conf, int events);</span>
<span class="s1">void rd_kafka_conf_set_background_event_cb(rd_kafka_conf_t *conf, void (*event_cb)(rd_kafka_t *rk, rd_kafka_event_t *rkev, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_dr_cb(rd_kafka_conf_t *conf, void (*dr_cb)(rd_kafka_t *rk, void *payload, size_t len, rd_kafka_resp_err_t err, void *opaque, void *msg_opaque));</span>
<span class="s1">void rd_kafka_conf_set_dr_msg_cb(rd_kafka_conf_t *conf, void (*dr_msg_cb)(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_consume_cb(rd_kafka_conf_t *conf, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_rebalance_cb(rd_kafka_conf_t *conf, void (*rebalance_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *partitions, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_offset_commit_cb(rd_kafka_conf_t *conf, void (*offset_commit_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_error_cb(rd_kafka_conf_t *conf, void (*error_cb)(rd_kafka_t *rk, int err, const char *reason, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_throttle_cb(rd_kafka_conf_t *conf, void (*throttle_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int throttle_time_ms, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_log_cb(rd_kafka_conf_t *conf, void (*log_cb)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));</span>
<span class="s1">void rd_kafka_conf_set_stats_cb(rd_kafka_conf_t *conf, int (*stats_cb)(rd_kafka_t *rk, char *json, size_t json_len, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_oauthbearer_token_refresh_cb(rd_kafka_conf_t *conf, void (*oauthbearer_token_refresh_cb)(rd_kafka_t *rk, const char *oauthbearer_config, void *opaque));</span>
<span class="s1">void rd_kafka_conf_enable_sasl_queue(rd_kafka_conf_t *conf, int enable);</span>
<span class="s1">void rd_kafka_conf_set_socket_cb(rd_kafka_conf_t *conf, int (*socket_cb)(int domain, int type, int protocol, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_connect_cb(rd_kafka_conf_t *conf, int (*connect_cb)(int sockfd, const struct sockaddr *addr, int addrlen, const char *id, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_closesocket_cb(rd_kafka_conf_t *conf, int (*closesocket_cb)(int sockfd, void *opaque));</span>
<span class="s1">struct addrinfo;</span>
<span class="s1">void rd_kafka_conf_set_resolve_cb(rd_kafka_conf_t *conf, int (*resolve_cb)(const char *node, const char *service, const struct addrinfo *hints, struct addrinfo **res, void *opaque));</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert_verify_cb(rd_kafka_conf_t *conf, int (*ssl_cert_verify_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int *x509_error, int depth, const char *buf, size_t size, char *errstr, size_t errstr_size, void *opaque));</span>
<span class="s1">typedef enum rd_kafka_cert_type_t {</span>
<span class="s1">  RD_KAFKA_CERT_PUBLIC_KEY,</span>
<span class="s1">  RD_KAFKA_CERT_PRIVATE_KEY,</span>
<span class="s1">  RD_KAFKA_CERT_CA,</span>
<span class="s1">  RD_KAFKA_CERT__CNT,</span>
<span class="s1">} rd_kafka_cert_type_t;</span>
<span class="s1">typedef enum rd_kafka_cert_enc_t {</span>
<span class="s1">  RD_KAFKA_CERT_ENC_PKCS12,</span>
<span class="s1">  RD_KAFKA_CERT_ENC_DER,</span>
<span class="s1">  RD_KAFKA_CERT_ENC_PEM,</span>
<span class="s1">  RD_KAFKA_CERT_ENC__CNT,</span>
<span class="s1">} rd_kafka_cert_enc_t;</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert(rd_kafka_conf_t *conf, rd_kafka_cert_type_t cert_type, rd_kafka_cert_enc_t cert_enc, const void *buffer, size_t size, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_conf_set_engine_callback_data(rd_kafka_conf_t *conf, void *callback_data);</span>
<span class="s1">void rd_kafka_conf_set_opaque(rd_kafka_conf_t *conf, void *opaque);</span>
<span class="s1">void *rd_kafka_opaque(const rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_conf_set_default_topic_conf(rd_kafka_conf_t *conf, rd_kafka_topic_conf_t *tconf);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_conf_get_default_topic_conf(rd_kafka_conf_t *conf);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_get(const rd_kafka_conf_t *conf, const char *name, char *dest, size_t *dest_size);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_topic_conf_get(const rd_kafka_topic_conf_t *conf, const char *name, char *dest, size_t *dest_size);</span>
<span class="s1">const char **rd_kafka_conf_dump(rd_kafka_conf_t *conf, size_t *cntp);</span>
<span class="s1">const char **rd_kafka_topic_conf_dump(rd_kafka_topic_conf_t *conf, size_t *cntp);</span>
<span class="s1">void rd_kafka_conf_dump_free(const char **arr, size_t cnt);</span>
<span class="s1">void rd_kafka_conf_properties_show(FILE *fp);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_topic_conf_new(void);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_topic_conf_dup(const rd_kafka_topic_conf_t *conf);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_default_topic_conf_dup(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_topic_conf_destroy(rd_kafka_topic_conf_t *topic_conf);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_topic_conf_set(rd_kafka_topic_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_topic_conf_set_opaque(rd_kafka_topic_conf_t *conf, void *rkt_opaque);</span>
<span class="s1">void rd_kafka_topic_conf_set_partitioner_cb(rd_kafka_topic_conf_t *topic_conf, int32_t (*partitioner)(const rd_kafka_topic_t *rkt, const void *keydata, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque));</span>
<span class="s1">void rd_kafka_topic_conf_set_msg_order_cmp(rd_kafka_topic_conf_t *topic_conf, int (*msg_order_cmp)(const rd_kafka_message_t *a, const rd_kafka_message_t *b));</span>
<span class="s1">int rd_kafka_topic_partition_available(const rd_kafka_topic_t *rkt, int32_t partition);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_consistent(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_consistent_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_murmur2(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_murmur2_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_fnv1a(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_fnv1a_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">rd_kafka_t *rd_kafka_new(rd_kafka_type_t type, rd_kafka_conf_t *conf, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_destroy(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_destroy_flags(rd_kafka_t *rk, int flags);</span>
<span class="s1">const char *rd_kafka_name(const rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_type_t rd_kafka_type(const rd_kafka_t *rk);</span>
<span class="s1">char *rd_kafka_memberid(const rd_kafka_t *rk);</span>
<span class="s1">char *rd_kafka_clusterid(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">int32_t rd_kafka_controllerid(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_topic_t *rd_kafka_topic_new(rd_kafka_t *rk, const char *topic, rd_kafka_topic_conf_t *conf);</span>
<span class="s1">void rd_kafka_topic_destroy(rd_kafka_topic_t *rkt);</span>
<span class="s1">const char *rd_kafka_topic_name(const rd_kafka_topic_t *rkt);</span>
<span class="s1">void *rd_kafka_topic_opaque(const rd_kafka_topic_t *rkt);</span>
<span class="s1">int rd_kafka_poll(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">void rd_kafka_yield(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_pause_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_resume_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_query_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_get_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offsets_for_times(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets, int timeout_ms);</span>
<span class="s1">void *rd_kafka_mem_calloc(rd_kafka_t *rk, size_t num, size_t size);</span>
<span class="s1">void *rd_kafka_mem_malloc(rd_kafka_t *rk, size_t size);</span>
<span class="s1">void rd_kafka_mem_free(rd_kafka_t *rk, void *ptr);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_new(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_queue_destroy(rd_kafka_queue_t *rkqu);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_main(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_sasl(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_sasl_background_callbacks_enable(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_sasl_set_credentials(rd_kafka_t *rk, const char *username, const char *password);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_consumer(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_partition(rd_kafka_t *rk, const char *topic, int32_t partition);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_background(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_queue_forward(rd_kafka_queue_t *src, rd_kafka_queue_t *dst);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_set_log_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu);</span>
<span class="s1">size_t rd_kafka_queue_length(rd_kafka_queue_t *rkqu);</span>
<span class="s1">void rd_kafka_queue_io_event_enable(rd_kafka_queue_t *rkqu, int fd, const void *payload, size_t size);</span>
<span class="s1">void rd_kafka_queue_cb_event_enable(rd_kafka_queue_t *rkqu, void (*event_cb)(rd_kafka_t *rk, void *qev_opaque), void *qev_opaque);</span>
<span class="s1">void rd_kafka_queue_yield(rd_kafka_queue_t *rkqu);</span>
<span class="s1">int rd_kafka_consume_start(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);</span>
<span class="s1">int rd_kafka_consume_start_queue(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, rd_kafka_queue_t *rkqu);</span>
<span class="s1">int rd_kafka_consume_stop(rd_kafka_topic_t *rkt, int32_t partition);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_seek(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, int timeout_ms);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_seek_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consume(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms);</span>
<span class="s1">ssize_t rd_kafka_consume_batch(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);</span>
<span class="s1">int rd_kafka_consume_callback(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consume_queue(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">ssize_t rd_kafka_consume_batch_queue(rd_kafka_queue_t *rkqu, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);</span>
<span class="s1">int rd_kafka_consume_callback_queue(rd_kafka_queue_t *rkqu, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offset_store(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offsets_store(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_subscribe(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *topics);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_unsubscribe(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_subscription(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **topics);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consumer_poll(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_consumer_close(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_consumer_close_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu);</span>
<span class="s1">int rd_kafka_consumer_closed(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_incremental_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_incremental_unassign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">const char *rd_kafka_rebalance_protocol(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_assignment(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **partitions);</span>
<span class="s1">int rd_kafka_assignment_lost(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, int async);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit_message(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, int async);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit_queue(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_queue_t *rkqu, void (*cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *commit_opaque), void *commit_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_committed(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_position(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata_new(const char *group_id);</span>
<span class="s1">rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata_new_with_genid(const char *group_id, int32_t generation_id, const char *member_id, const char *group_instance_id);</span>
<span class="s1">void rd_kafka_consumer_group_metadata_destroy(rd_kafka_consumer_group_metadata_t *);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_consumer_group_metadata_write(const rd_kafka_consumer_group_metadata_t *cgmd, void **bufferp, size_t *sizep);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_consumer_group_metadata_read(rd_kafka_consumer_group_metadata_t **cgmdp, const void *buffer, size_t size);</span>
<span class="s1">int rd_kafka_produce(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, void *payload, size_t len, const void *key, size_t keylen, void *msg_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_producev(rd_kafka_t *rk, ...);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_produceva(rd_kafka_t *rk, const rd_kafka_vu_t *vus, size_t cnt);</span>
<span class="s1">int rd_kafka_produce_batch(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, rd_kafka_message_t *rkmessages, int message_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_flush(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_purge(rd_kafka_t *rk, int purge_flags);</span>
<span class="s1">typedef struct rd_kafka_metadata_broker {</span>
<span class="s1">  int32_t id;</span>
<span class="s1">  char *host;</span>
<span class="s1">  int port;</span>
<span class="s1">} rd_kafka_metadata_broker_t;</span>
<span class="s1">typedef struct rd_kafka_metadata_partition {</span>
<span class="s1">  int32_t id;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  int32_t leader;</span>
<span class="s1">  int replica_cnt;</span>
<span class="s1">  int32_t *replicas;</span>
<span class="s1">  int isr_cnt;</span>
<span class="s1">  int32_t *isrs;</span>
<span class="s1">} rd_kafka_metadata_partition_t;</span>
<span class="s1">typedef struct rd_kafka_metadata_topic {</span>
<span class="s1">  char *topic;</span>
<span class="s1">  int partition_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_partition *partitions;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">} rd_kafka_metadata_topic_t;</span>
<span class="s1">typedef struct rd_kafka_metadata {</span>
<span class="s1">  int broker_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_broker *brokers;</span>
<span class="s1">  int topic_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_topic *topics;</span>
<span class="s1">  int32_t orig_broker_id;</span>
<span class="s1">  char *orig_broker_name;</span>
<span class="s1">} rd_kafka_metadata_t;</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_metadata(rd_kafka_t *rk, int all_topics, rd_kafka_topic_t *only_rkt, const struct rd_kafka_metadata **metadatap, int timeout_ms);</span>
<span class="s1">void rd_kafka_metadata_destroy(const struct rd_kafka_metadata *metadata);</span>
<span class="s1">typedef struct rd_kafka_Node_s rd_kafka_Node_t;</span>
<span class="s1">int rd_kafka_Node_id(const rd_kafka_Node_t *node);</span>
<span class="s1">const char *rd_kafka_Node_host(const rd_kafka_Node_t *node);</span>
<span class="s1">uint16_t rd_kafka_Node_port(const rd_kafka_Node_t *node);</span>
<span class="s1">struct rd_kafka_group_member_info {</span>
<span class="s1">  char *member_id;</span>
<span class="s1">  char *client_id;</span>
<span class="s1">  char *client_host;</span>
<span class="s1">  void *member_metadata;</span>
<span class="s1">  int member_metadata_size;</span>
<span class="s1">  void *member_assignment;</span>
<span class="s1">  int member_assignment_size;</span>
<span class="s1">};</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_CONSUMER_GROUP_STATE_UNKNOWN = 0,</span>
<span class="s1">  RD_KAFKA_CONSUMER_GROUP_STATE_PREPARING_REBALANCE = 1,</span>
<span class="s1">  RD_KAFKA_CONSUMER_GROUP_STATE_COMPLETING_REBALANCE = 2,</span>
<span class="s1">  RD_KAFKA_CONSUMER_GROUP_STATE_STABLE = 3,</span>
<span class="s1">  RD_KAFKA_CONSUMER_GROUP_STATE_DEAD = 4,</span>
<span class="s1">  RD_KAFKA_CONSUMER_GROUP_STATE_EMPTY = 5,</span>
<span class="s1">  RD_KAFKA_CONSUMER_GROUP_STATE__CNT,</span>
<span class="s1">} rd_kafka_consumer_group_state_t;</span>
<span class="s1">struct rd_kafka_group_info {</span>
<span class="s1">  struct rd_kafka_metadata_broker broker;</span>
<span class="s1">  char *group;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  char *state;</span>
<span class="s1">  char *protocol_type;</span>
<span class="s1">  char *protocol;</span>
<span class="s1">  struct rd_kafka_group_member_info *members;</span>
<span class="s1">  int member_cnt;</span>
<span class="s1">};</span>
<span class="s1">struct rd_kafka_group_list {</span>
<span class="s1">  struct rd_kafka_group_info *groups;</span>
<span class="s1">  int group_cnt;</span>
<span class="s1">};</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_list_groups(rd_kafka_t *rk, const char *group, const struct rd_kafka_group_list **grplistp, int timeout_ms);</span>
<span class="s1">const char *rd_kafka_consumer_group_state_name(rd_kafka_consumer_group_state_t state);</span>
<span class="s1">rd_kafka_consumer_group_state_t rd_kafka_consumer_group_state_code(const char *name);</span>
<span class="s1">void rd_kafka_group_list_destroy(const struct rd_kafka_group_list *grplist);</span>
<span class="s1">int rd_kafka_brokers_add(rd_kafka_t *rk, const char *brokerlist);</span>
<span class="s1">void rd_kafka_set_logger(rd_kafka_t *rk, void (*func)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));</span>
<span class="s1">void rd_kafka_set_log_level(rd_kafka_t *rk, int level);</span>
<span class="s1">void rd_kafka_log_print(const rd_kafka_t *rk, int level, const char *fac, const char *buf);</span>
<span class="s1">void rd_kafka_log_syslog(const rd_kafka_t *rk, int level, const char *fac, const char *buf);</span>
<span class="s1">int rd_kafka_outq_len(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_dump(FILE *fp, rd_kafka_t *rk);</span>
<span class="s1">int rd_kafka_thread_cnt(void);</span>
<span class="s1">typedef enum rd_kafka_thread_type_t {</span>
<span class="s1">  RD_KAFKA_THREAD_MAIN,</span>
<span class="s1">  RD_KAFKA_THREAD_BACKGROUND,</span>
<span class="s1">  RD_KAFKA_THREAD_BROKER,</span>
<span class="s1">} rd_kafka_thread_type_t;</span>
<span class="s1">int rd_kafka_wait_destroyed(int timeout_ms);</span>
<span class="s1">int rd_kafka_unittest(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_poll_set_consumer(rd_kafka_t *rk);</span>
<span class="s1">typedef int rd_kafka_event_type_t;</span>
<span class="s1">rd_kafka_event_type_t rd_kafka_event_type(const rd_kafka_event_t *rkev);</span>
<span class="s1">const char *rd_kafka_event_name(const rd_kafka_event_t *rkev);</span>
<span class="s1">void rd_kafka_event_destroy(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_message_t *rd_kafka_event_message_next(rd_kafka_event_t *rkev);</span>
<span class="s1">size_t rd_kafka_event_message_array(rd_kafka_event_t *rkev, const rd_kafka_message_t **rkmessages, size_t size);</span>
<span class="s1">size_t rd_kafka_event_message_count(rd_kafka_event_t *rkev);</span>
<span class="s1">const char *rd_kafka_event_config_string(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_event_error(rd_kafka_event_t *rkev);</span>
<span class="s1">const char *rd_kafka_event_error_string(rd_kafka_event_t *rkev);</span>
<span class="s1">int rd_kafka_event_error_is_fatal(rd_kafka_event_t *rkev);</span>
<span class="s1">void *rd_kafka_event_opaque(rd_kafka_event_t *rkev);</span>
<span class="s1">int rd_kafka_event_log(rd_kafka_event_t *rkev, const char **fac, const char **str, int *level);</span>
<span class="s1">int rd_kafka_event_debug_contexts(rd_kafka_event_t *rkev, char *dst, size_t dstsize);</span>
<span class="s1">const char *rd_kafka_event_stats(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_event_topic_partition_list(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_event_topic_partition(rd_kafka_event_t *rkev);</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_CreateTopics_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DeleteTopics_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_CreateAcls_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DescribeAcls_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DeleteAcls_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_CreatePartitions_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_AlterConfigs_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DescribeConfigs_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DeleteRecords_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_ListConsumerGroups_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DescribeConsumerGroups_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DeleteGroups_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DeleteConsumerGroupOffsets_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_AlterConsumerGroupOffsets_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_ListConsumerGroupOffsets_result_t;</span>
<span class="s1">const rd_kafka_CreateTopics_result_t *rd_kafka_event_CreateTopics_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DeleteTopics_result_t *rd_kafka_event_DeleteTopics_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_CreatePartitions_result_t *rd_kafka_event_CreatePartitions_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_AlterConfigs_result_t *rd_kafka_event_AlterConfigs_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DescribeConfigs_result_t *rd_kafka_event_DescribeConfigs_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DeleteRecords_result_t *rd_kafka_event_DeleteRecords_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_ListConsumerGroups_result_t *rd_kafka_event_ListConsumerGroups_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DescribeConsumerGroups_result_t *rd_kafka_event_DescribeConsumerGroups_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DeleteGroups_result_t *rd_kafka_event_DeleteGroups_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DeleteConsumerGroupOffsets_result_t *rd_kafka_event_DeleteConsumerGroupOffsets_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_CreateAcls_result_t *rd_kafka_event_CreateAcls_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DescribeAcls_result_t *rd_kafka_event_DescribeAcls_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DeleteAcls_result_t *rd_kafka_event_DeleteAcls_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_AlterConsumerGroupOffsets_result_t *rd_kafka_event_AlterConsumerGroupOffsets_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_ListConsumerGroupOffsets_result_t *rd_kafka_event_ListConsumerGroupOffsets_result(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_event_t *rd_kafka_queue_poll(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">int rd_kafka_queue_poll_callback(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_plugin_f_conf_init_t)(rd_kafka_conf_t *conf, void **plug_opaquep, char *errstr, size_t errstr_size);</span>
<span class="s1">typedef rd_kafka_conf_res_t (rd_kafka_interceptor_f_on_conf_set_t)(rd_kafka_conf_t *conf, const char *name, const char *val, char *errstr, size_t errstr_size, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_dup_t)(rd_kafka_conf_t *new_conf, const rd_kafka_conf_t *old_conf, size_t filter_cnt, const char **filter, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_destroy_t)(void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_new_t)(rd_kafka_t *rk, const rd_kafka_conf_t *conf, void *ic_opaque, char *errstr, size_t errstr_size);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_destroy_t)(rd_kafka_t *rk, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_send_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_acknowledgement_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_consume_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_commit_t)(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_resp_err_t err, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_request_sent_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_response_received_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, int64_t rtt, rd_kafka_resp_err_t err, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_start_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_exit_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_broker_state_change_t)(rd_kafka_t *rk, int32_t broker_id, const char *secproto, const char *name, int port, const char *state, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_set(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_set_t *on_conf_set, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_dup(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_dup_t *on_conf_dup, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_destroy(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_destroy_t *on_conf_destroy, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_new(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_new_t *on_new, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_destroy(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_destroy_t *on_destroy, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_send(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_send_t *on_send, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_acknowledgement(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_acknowledgement_t *on_acknowledgement, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_consume(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_consume_t *on_consume, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_commit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_commit_t *on_commit, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_request_sent(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_request_sent_t *on_request_sent, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_response_received(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_response_received_t *on_response_received, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_start(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_start_t *on_thread_start, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_exit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_exit_t *on_thread_exit, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_broker_state_change(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_broker_state_change_t *on_broker_state_change, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_topic_result_error(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">const char *rd_kafka_topic_result_error_string(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">const char *rd_kafka_topic_result_name(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">const rd_kafka_error_t *rd_kafka_group_result_error(const rd_kafka_group_result_t *groupres);</span>
<span class="s1">const char *rd_kafka_group_result_name(const rd_kafka_group_result_t *groupres);</span>
<span class="s1">const rd_kafka_topic_partition_list_t *rd_kafka_group_result_partitions(const rd_kafka_group_result_t *groupres);</span>
<span class="s1">typedef enum rd_kafka_admin_op_t {</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_ANY = 0,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_CREATETOPICS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DELETETOPICS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_CREATEPARTITIONS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_ALTERCONFIGS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DESCRIBECONFIGS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DELETERECORDS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DELETEGROUPS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DELETECONSUMERGROUPOFFSETS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_CREATEACLS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DESCRIBEACLS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DELETEACLS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_LISTCONSUMERGROUPS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DESCRIBECONSUMERGROUPS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_LISTCONSUMERGROUPOFFSETS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_ALTERCONSUMERGROUPOFFSETS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP__CNT,</span>
<span class="s1">} rd_kafka_admin_op_t;</span>
<span class="s1">typedef struct rd_kafka_AdminOptions_s rd_kafka_AdminOptions_t;</span>
<span class="s1">rd_kafka_AdminOptions_t *rd_kafka_AdminOptions_new(rd_kafka_t *rk, rd_kafka_admin_op_t for_api);</span>
<span class="s1">void rd_kafka_AdminOptions_destroy(rd_kafka_AdminOptions_t *options);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_request_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_operation_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_validate_only(rd_kafka_AdminOptions_t *options, int true_or_false, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_broker(rd_kafka_AdminOptions_t *options, int32_t broker_id, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_AdminOptions_set_require_stable_offsets(rd_kafka_AdminOptions_t *options, int true_or_false);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_AdminOptions_set_match_consumer_group_states(rd_kafka_AdminOptions_t *options, const rd_kafka_consumer_group_state_t *consumer_group_states, size_t consumer_group_states_cnt);</span>
<span class="s1">void rd_kafka_AdminOptions_set_opaque(rd_kafka_AdminOptions_t *options, void *ev_opaque);</span>
<span class="s1">typedef struct rd_kafka_NewTopic_s rd_kafka_NewTopic_t;</span>
<span class="s1">rd_kafka_NewTopic_t *rd_kafka_NewTopic_new(const char *topic, int num_partitions, int replication_factor, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_NewTopic_destroy(rd_kafka_NewTopic_t *new_topic);</span>
<span class="s1">void rd_kafka_NewTopic_destroy_array(rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewTopic_set_replica_assignment(rd_kafka_NewTopic_t *new_topic, int32_t partition, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewTopic_set_config(rd_kafka_NewTopic_t *new_topic, const char *name, const char *value);</span>
<span class="s1">void rd_kafka_CreateTopics(rd_kafka_t *rk, rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_CreateTopics_result_topics(const rd_kafka_CreateTopics_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_DeleteTopic_s rd_kafka_DeleteTopic_t;</span>
<span class="s1">rd_kafka_DeleteTopic_t *rd_kafka_DeleteTopic_new(const char *topic);</span>
<span class="s1">void rd_kafka_DeleteTopic_destroy(rd_kafka_DeleteTopic_t *del_topic);</span>
<span class="s1">void rd_kafka_DeleteTopic_destroy_array(rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt);</span>
<span class="s1">void rd_kafka_DeleteTopics(rd_kafka_t *rk, rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_DeleteTopics_result_topics(const rd_kafka_DeleteTopics_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_NewPartitions_s rd_kafka_NewPartitions_t;</span>
<span class="s1">rd_kafka_NewPartitions_t *rd_kafka_NewPartitions_new(const char *topic, size_t new_total_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_NewPartitions_destroy(rd_kafka_NewPartitions_t *new_parts);</span>
<span class="s1">void rd_kafka_NewPartitions_destroy_array(rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewPartitions_set_replica_assignment(rd_kafka_NewPartitions_t *new_parts, int32_t new_partition_idx, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_CreatePartitions(rd_kafka_t *rk, rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_CreatePartitions_result_topics(const rd_kafka_CreatePartitions_result_t *result, size_t *cntp);</span>
<span class="s1">typedef enum rd_kafka_ConfigSource_t {</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_UNKNOWN_CONFIG = 0,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_TOPIC_CONFIG = 1,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_BROKER_CONFIG = 2,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_DEFAULT_BROKER_CONFIG = 3,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_STATIC_BROKER_CONFIG = 4,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DEFAULT_CONFIG = 5,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE__CNT,</span>
<span class="s1">} rd_kafka_ConfigSource_t;</span>
<span class="s1">const char *rd_kafka_ConfigSource_name(rd_kafka_ConfigSource_t confsource);</span>
<span class="s1">typedef struct rd_kafka_ConfigEntry_s rd_kafka_ConfigEntry_t;</span>
<span class="s1">const char *rd_kafka_ConfigEntry_name(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">const char *rd_kafka_ConfigEntry_value(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">rd_kafka_ConfigSource_t rd_kafka_ConfigEntry_source(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_read_only(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_default(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_sensitive(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_synonym(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">const rd_kafka_ConfigEntry_t **rd_kafka_ConfigEntry_synonyms(const rd_kafka_ConfigEntry_t *entry, size_t *cntp);</span>
<span class="s1">typedef enum rd_kafka_ResourceType_t {</span>
<span class="s1">  RD_KAFKA_RESOURCE_UNKNOWN = 0,</span>
<span class="s1">  RD_KAFKA_RESOURCE_ANY = 1,</span>
<span class="s1">  RD_KAFKA_RESOURCE_TOPIC = 2,</span>
<span class="s1">  RD_KAFKA_RESOURCE_GROUP = 3,</span>
<span class="s1">  RD_KAFKA_RESOURCE_BROKER = 4,</span>
<span class="s1">  RD_KAFKA_RESOURCE__CNT,</span>
<span class="s1">} rd_kafka_ResourceType_t;</span>
<span class="s1">typedef enum rd_kafka_ResourcePatternType_t {</span>
<span class="s1">  RD_KAFKA_RESOURCE_PATTERN_UNKNOWN = 0,</span>
<span class="s1">  RD_KAFKA_RESOURCE_PATTERN_ANY = 1,</span>
<span class="s1">  RD_KAFKA_RESOURCE_PATTERN_MATCH = 2,</span>
<span class="s1">  RD_KAFKA_RESOURCE_PATTERN_LITERAL = 3,</span>
<span class="s1">  RD_KAFKA_RESOURCE_PATTERN_PREFIXED = 4,</span>
<span class="s1">  RD_KAFKA_RESOURCE_PATTERN_TYPE__CNT,</span>
<span class="s1">} rd_kafka_ResourcePatternType_t;</span>
<span class="s1">const char *rd_kafka_ResourcePatternType_name(rd_kafka_ResourcePatternType_t resource_pattern_type);</span>
<span class="s1">const char *rd_kafka_ResourceType_name(rd_kafka_ResourceType_t restype);</span>
<span class="s1">typedef struct rd_kafka_ConfigResource_s rd_kafka_ConfigResource_t;</span>
<span class="s1">rd_kafka_ConfigResource_t *rd_kafka_ConfigResource_new(rd_kafka_ResourceType_t restype, const char *resname);</span>
<span class="s1">void rd_kafka_ConfigResource_destroy(rd_kafka_ConfigResource_t *config);</span>
<span class="s1">void rd_kafka_ConfigResource_destroy_array(rd_kafka_ConfigResource_t **config, size_t config_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_ConfigResource_set_config(rd_kafka_ConfigResource_t *config, const char *name, const char *value);</span>
<span class="s1">const rd_kafka_ConfigEntry_t **rd_kafka_ConfigResource_configs(const rd_kafka_ConfigResource_t *config, size_t *cntp);</span>
<span class="s1">rd_kafka_ResourceType_t rd_kafka_ConfigResource_type(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">const char *rd_kafka_ConfigResource_name(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_ConfigResource_error(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">const char *rd_kafka_ConfigResource_error_string(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">void rd_kafka_AlterConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_ConfigResource_t **rd_kafka_AlterConfigs_result_resources(const rd_kafka_AlterConfigs_result_t *result, size_t *cntp);</span>
<span class="s1">void rd_kafka_DescribeConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_ConfigResource_t **rd_kafka_DescribeConfigs_result_resources(const rd_kafka_DescribeConfigs_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_DeleteRecords_s rd_kafka_DeleteRecords_t;</span>
<span class="s1">rd_kafka_DeleteRecords_t *rd_kafka_DeleteRecords_new(const rd_kafka_topic_partition_list_t *before_offsets);</span>
<span class="s1">void rd_kafka_DeleteRecords_destroy(rd_kafka_DeleteRecords_t *del_records);</span>
<span class="s1">void rd_kafka_DeleteRecords_destroy_array(rd_kafka_DeleteRecords_t **del_records, size_t del_record_cnt);</span>
<span class="s1">void rd_kafka_DeleteRecords(rd_kafka_t *rk, rd_kafka_DeleteRecords_t **del_records, size_t del_record_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_partition_list_t *rd_kafka_DeleteRecords_result_offsets(const rd_kafka_DeleteRecords_result_t *result);</span>
<span class="s1">typedef struct rd_kafka_ConsumerGroupListing_s rd_kafka_ConsumerGroupListing_t;</span>
<span class="s1">typedef struct rd_kafka_ListConsumerGroupsResult_s rd_kafka_ListConsumerGroupsResult_t;</span>
<span class="s1">void rd_kafka_ListConsumerGroups(rd_kafka_t *rk, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const char *rd_kafka_ConsumerGroupListing_group_id(const rd_kafka_ConsumerGroupListing_t *grplist);</span>
<span class="s1">int rd_kafka_ConsumerGroupListing_is_simple_consumer_group(const rd_kafka_ConsumerGroupListing_t *grplist);</span>
<span class="s1">rd_kafka_consumer_group_state_t rd_kafka_ConsumerGroupListing_state(const rd_kafka_ConsumerGroupListing_t *grplist);</span>
<span class="s1">const rd_kafka_ConsumerGroupListing_t **rd_kafka_ListConsumerGroups_result_valid(const rd_kafka_ListConsumerGroups_result_t *result, size_t *cntp);</span>
<span class="s1">const rd_kafka_error_t **rd_kafka_ListConsumerGroups_result_errors(const rd_kafka_ListConsumerGroups_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_ConsumerGroupDescription_s rd_kafka_ConsumerGroupDescription_t;</span>
<span class="s1">typedef struct rd_kafka_MemberDescription_s rd_kafka_MemberDescription_t;</span>
<span class="s1">typedef struct rd_kafka_MemberAssignment_s rd_kafka_MemberAssignment_t;</span>
<span class="s1">void rd_kafka_DescribeConsumerGroups(rd_kafka_t *rk, const char **groups, size_t groups_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_ConsumerGroupDescription_t **rd_kafka_DescribeConsumerGroups_result_groups(const rd_kafka_DescribeConsumerGroups_result_t *result, size_t *cntp);</span>
<span class="s1">const char *rd_kafka_ConsumerGroupDescription_group_id(const rd_kafka_ConsumerGroupDescription_t *grpdesc);</span>
<span class="s1">const rd_kafka_error_t *rd_kafka_ConsumerGroupDescription_error(const rd_kafka_ConsumerGroupDescription_t *grpdesc);</span>
<span class="s1">int rd_kafka_ConsumerGroupDescription_is_simple_consumer_group(const rd_kafka_ConsumerGroupDescription_t *grpdesc);</span>
<span class="s1">const char *rd_kafka_ConsumerGroupDescription_partition_assignor(const rd_kafka_ConsumerGroupDescription_t *grpdesc);</span>
<span class="s1">rd_kafka_consumer_group_state_t rd_kafka_ConsumerGroupDescription_state(const rd_kafka_ConsumerGroupDescription_t *grpdesc);</span>
<span class="s1">const rd_kafka_Node_t *rd_kafka_ConsumerGroupDescription_coordinator(const rd_kafka_ConsumerGroupDescription_t *grpdesc);</span>
<span class="s1">size_t rd_kafka_ConsumerGroupDescription_member_count(const rd_kafka_ConsumerGroupDescription_t *grpdesc);</span>
<span class="s1">const rd_kafka_MemberDescription_t *rd_kafka_ConsumerGroupDescription_member(const rd_kafka_ConsumerGroupDescription_t *grpdesc, size_t idx);</span>
<span class="s1">const char *rd_kafka_MemberDescription_client_id(const rd_kafka_MemberDescription_t *member);</span>
<span class="s1">const char *rd_kafka_MemberDescription_group_instance_id(const rd_kafka_MemberDescription_t *member);</span>
<span class="s1">const char *rd_kafka_MemberDescription_consumer_id(const rd_kafka_MemberDescription_t *member);</span>
<span class="s1">const char *rd_kafka_MemberDescription_host(const rd_kafka_MemberDescription_t *member);</span>
<span class="s1">const rd_kafka_MemberAssignment_t *rd_kafka_MemberDescription_assignment(const rd_kafka_MemberDescription_t *member);</span>
<span class="s1">const rd_kafka_topic_partition_list_t *rd_kafka_MemberAssignment_partitions(const rd_kafka_MemberAssignment_t *assignment);</span>
<span class="s1">typedef struct rd_kafka_DeleteGroup_s rd_kafka_DeleteGroup_t;</span>
<span class="s1">rd_kafka_DeleteGroup_t *rd_kafka_DeleteGroup_new(const char *group);</span>
<span class="s1">void rd_kafka_DeleteGroup_destroy(rd_kafka_DeleteGroup_t *del_group);</span>
<span class="s1">void rd_kafka_DeleteGroup_destroy_array(rd_kafka_DeleteGroup_t **del_groups, size_t del_group_cnt);</span>
<span class="s1">void rd_kafka_DeleteGroups(rd_kafka_t *rk, rd_kafka_DeleteGroup_t **del_groups, size_t del_group_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_group_result_t **rd_kafka_DeleteGroups_result_groups(const rd_kafka_DeleteGroups_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_ListConsumerGroupOffsets_s rd_kafka_ListConsumerGroupOffsets_t;</span>
<span class="s1">rd_kafka_ListConsumerGroupOffsets_t *rd_kafka_ListConsumerGroupOffsets_new(const char *group_id, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">void rd_kafka_ListConsumerGroupOffsets_destroy(rd_kafka_ListConsumerGroupOffsets_t *list_grpoffsets);</span>
<span class="s1">void rd_kafka_ListConsumerGroupOffsets_destroy_array(rd_kafka_ListConsumerGroupOffsets_t **list_grpoffsets, size_t list_grpoffset_cnt);</span>
<span class="s1">void rd_kafka_ListConsumerGroupOffsets(rd_kafka_t *rk, rd_kafka_ListConsumerGroupOffsets_t **list_grpoffsets, size_t list_grpoffsets_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_group_result_t **rd_kafka_ListConsumerGroupOffsets_result_groups(const rd_kafka_ListConsumerGroupOffsets_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_AlterConsumerGroupOffsets_s rd_kafka_AlterConsumerGroupOffsets_t;</span>
<span class="s1">rd_kafka_AlterConsumerGroupOffsets_t *rd_kafka_AlterConsumerGroupOffsets_new(const char *group_id, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">void rd_kafka_AlterConsumerGroupOffsets_destroy(rd_kafka_AlterConsumerGroupOffsets_t *alter_grpoffsets);</span>
<span class="s1">void rd_kafka_AlterConsumerGroupOffsets_destroy_array(rd_kafka_AlterConsumerGroupOffsets_t **alter_grpoffsets, size_t alter_grpoffset_cnt);</span>
<span class="s1">void rd_kafka_AlterConsumerGroupOffsets(rd_kafka_t *rk, rd_kafka_AlterConsumerGroupOffsets_t **alter_grpoffsets, size_t alter_grpoffsets_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_group_result_t **rd_kafka_AlterConsumerGroupOffsets_result_groups(const rd_kafka_AlterConsumerGroupOffsets_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_DeleteConsumerGroupOffsets_s rd_kafka_DeleteConsumerGroupOffsets_t;</span>
<span class="s1">rd_kafka_DeleteConsumerGroupOffsets_t *rd_kafka_DeleteConsumerGroupOffsets_new(const char *group, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">void rd_kafka_DeleteConsumerGroupOffsets_destroy(rd_kafka_DeleteConsumerGroupOffsets_t *del_grpoffsets);</span>
<span class="s1">void rd_kafka_DeleteConsumerGroupOffsets_destroy_array(rd_kafka_DeleteConsumerGroupOffsets_t **del_grpoffsets, size_t del_grpoffset_cnt);</span>
<span class="s1">void rd_kafka_DeleteConsumerGroupOffsets(rd_kafka_t *rk, rd_kafka_DeleteConsumerGroupOffsets_t **del_grpoffsets, size_t del_grpoffsets_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_group_result_t **rd_kafka_DeleteConsumerGroupOffsets_result_groups(const rd_kafka_DeleteConsumerGroupOffsets_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_AclBinding_s rd_kafka_AclBinding_t;</span>
<span class="s1">typedef rd_kafka_AclBinding_t rd_kafka_AclBindingFilter_t;</span>
<span class="s1">const rd_kafka_error_t *rd_kafka_acl_result_error(const rd_kafka_acl_result_t *aclres);</span>
<span class="s1">typedef enum rd_kafka_AclOperation_t {</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_UNKNOWN = 0,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_ANY = 1,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_ALL = 2,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_READ = 3,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_WRITE = 4,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_CREATE = 5,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_DELETE = 6,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_ALTER = 7,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_DESCRIBE = 8,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_CLUSTER_ACTION = 9,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_DESCRIBE_CONFIGS = 10,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_ALTER_CONFIGS = 11,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_IDEMPOTENT_WRITE = 12,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION__CNT,</span>
<span class="s1">} rd_kafka_AclOperation_t;</span>
<span class="s1">const char *rd_kafka_AclOperation_name(rd_kafka_AclOperation_t acl_operation);</span>
<span class="s1">typedef enum rd_kafka_AclPermissionType_t {</span>
<span class="s1">  RD_KAFKA_ACL_PERMISSION_TYPE_UNKNOWN = 0,</span>
<span class="s1">  RD_KAFKA_ACL_PERMISSION_TYPE_ANY = 1,</span>
<span class="s1">  RD_KAFKA_ACL_PERMISSION_TYPE_DENY = 2,</span>
<span class="s1">  RD_KAFKA_ACL_PERMISSION_TYPE_ALLOW = 3,</span>
<span class="s1">  RD_KAFKA_ACL_PERMISSION_TYPE__CNT,</span>
<span class="s1">} rd_kafka_AclPermissionType_t;</span>
<span class="s1">const char *rd_kafka_AclPermissionType_name(rd_kafka_AclPermissionType_t acl_permission_type);</span>
<span class="s1">rd_kafka_AclBinding_t *rd_kafka_AclBinding_new(rd_kafka_ResourceType_t restype, const char *name, rd_kafka_ResourcePatternType_t resource_pattern_type, const char *principal, const char *host, rd_kafka_AclOperation_t operation, rd_kafka_AclPermissionType_t permission_type, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_AclBindingFilter_t *rd_kafka_AclBindingFilter_new(rd_kafka_ResourceType_t restype, const char *name, rd_kafka_ResourcePatternType_t resource_pattern_type, const char *principal, const char *host, rd_kafka_AclOperation_t operation, rd_kafka_AclPermissionType_t permission_type, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_ResourceType_t rd_kafka_AclBinding_restype(const rd_kafka_AclBinding_t *acl);</span>
<span class="s1">const char *rd_kafka_AclBinding_name(const rd_kafka_AclBinding_t *acl);</span>
<span class="s1">const char *rd_kafka_AclBinding_principal(const rd_kafka_AclBinding_t *acl);</span>
<span class="s1">const char *rd_kafka_AclBinding_host(const rd_kafka_AclBinding_t *acl);</span>
<span class="s1">rd_kafka_AclOperation_t rd_kafka_AclBinding_operation(const rd_kafka_AclBinding_t *acl);</span>
<span class="s1">rd_kafka_AclPermissionType_t rd_kafka_AclBinding_permission_type(const rd_kafka_AclBinding_t *acl);</span>
<span class="s1">rd_kafka_ResourcePatternType_t rd_kafka_AclBinding_resource_pattern_type(const rd_kafka_AclBinding_t *acl);</span>
<span class="s1">const rd_kafka_error_t *rd_kafka_AclBinding_error(const rd_kafka_AclBinding_t *acl);</span>
<span class="s1">void rd_kafka_AclBinding_destroy(rd_kafka_AclBinding_t *acl_binding);</span>
<span class="s1">void rd_kafka_AclBinding_destroy_array(rd_kafka_AclBinding_t **acl_bindings, size_t acl_bindings_cnt);</span>
<span class="s1">const rd_kafka_acl_result_t **rd_kafka_CreateAcls_result_acls(const rd_kafka_CreateAcls_result_t *result, size_t *cntp);</span>
<span class="s1">void rd_kafka_CreateAcls(rd_kafka_t *rk, rd_kafka_AclBinding_t **new_acls, size_t new_acls_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_AclBinding_t **rd_kafka_DescribeAcls_result_acls(const rd_kafka_DescribeAcls_result_t *result, size_t *cntp);</span>
<span class="s1">void rd_kafka_DescribeAcls(rd_kafka_t *rk, rd_kafka_AclBindingFilter_t *acl_filter, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">typedef struct rd_kafka_DeleteAcls_result_response_s rd_kafka_DeleteAcls_result_response_t;</span>
<span class="s1">const rd_kafka_DeleteAcls_result_response_t **rd_kafka_DeleteAcls_result_responses(const rd_kafka_DeleteAcls_result_t *result, size_t *cntp);</span>
<span class="s1">const rd_kafka_error_t *rd_kafka_DeleteAcls_result_response_error(const rd_kafka_DeleteAcls_result_response_t *result_response);</span>
<span class="s1">const rd_kafka_AclBinding_t **rd_kafka_DeleteAcls_result_response_matching_acls(const rd_kafka_DeleteAcls_result_response_t *result_response, size_t *matching_acls_cntp);</span>
<span class="s1">void rd_kafka_DeleteAcls(rd_kafka_t *rk, rd_kafka_AclBindingFilter_t **del_acls, size_t del_acls_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token(rd_kafka_t *rk, const char *token_value, int64_t md_lifetime_ms, const char *md_principal_name, const char **extensions, size_t extension_size, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token_failure(rd_kafka_t *rk, const char *errstr);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_init_transactions(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_begin_transaction(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_send_offsets_to_transaction(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, const rd_kafka_consumer_group_metadata_t *cgmetadata, int timeout_ms);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_commit_transaction(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_abort_transaction(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">typedef struct rd_kafka_mock_cluster_s rd_kafka_mock_cluster_t;</span>
<span class="s1">rd_kafka_mock_cluster_t *rd_kafka_mock_cluster_new(rd_kafka_t *rk, int broker_cnt);</span>
<span class="s1">void rd_kafka_mock_cluster_destroy(rd_kafka_mock_cluster_t *mcluster);</span>
<span class="s1">rd_kafka_t *rd_kafka_mock_cluster_handle(const rd_kafka_mock_cluster_t *mcluster);</span>
<span class="s1">rd_kafka_mock_cluster_t *rd_kafka_handle_mock_cluster(const rd_kafka_t *rk);</span>
<span class="s1">const char *rd_kafka_mock_cluster_bootstraps(const rd_kafka_mock_cluster_t *mcluster);</span>
<span class="s1">void rd_kafka_mock_clear_request_errors(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey);</span>
<span class="s1">void rd_kafka_mock_push_request_errors(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, size_t cnt, ...);</span>
<span class="s1">void rd_kafka_mock_push_request_errors_array(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, size_t cnt, const rd_kafka_resp_err_t *errors);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_push_request_error_rtts(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int16_t ApiKey, size_t cnt, ...);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_error_stack_cnt(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int16_t ApiKey, size_t *cntp);</span>
<span class="s1">void rd_kafka_mock_topic_set_error(rd_kafka_mock_cluster_t *mcluster, const char *topic, rd_kafka_resp_err_t err);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_topic_create(rd_kafka_mock_cluster_t *mcluster, const char *topic, int partition_cnt, int replication_factor);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_partition_set_leader(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_partition_set_follower(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_partition_set_follower_wmarks(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int64_t lo, int64_t hi);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_set_down(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_set_up(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_set_rtt(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int rtt_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_set_rack(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, const char *rack);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_coordinator_set(rd_kafka_mock_cluster_t *mcluster, const char *key_type, const char *key, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_set_apiversion(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, int16_t MinVersion, int16_t MaxVersion);</span>
<span class="s1">&#39;</span>
</code></pre></div>
rdkafka.h, rdkafka_mock.h</p>
<h3 id="rd_kafka_version_25">RD_KAFKA_VERSION<a class="headerlink" href="#rd_kafka_version_25" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_VERSION</span> <span class="o">=</span> <span class="mi">33620223</span>
</code></pre></div>
<p>librdkafka version </p>
<p>Interpreted as hex <code>MM.mm.rr.xx</code>:</p>
<ul>
<li>MM = Major</li>
<li>mm = minor</li>
<li>rr = revision</li>
<li>xx = pre-release id (0xff is the final release)</li>
</ul>
<p>E.g.: <code>0x000801ff</code> = 0.8.1</p>
<dl class="section remark"><dt>Remarks</dt><dd>This value should only be used during compile time, for runtime checks of version use rd_kafka_version() </dd></dl>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_unsupported_compression_type_25">RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE<a class="headerlink" href="#rd_kafka_resp_err_unsupported_compression_type_25" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE</span> <span class="o">=</span> <span class="mi">76</span>
</code></pre></div>
<p>Unsupported compression type </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_end_all_25">RD_KAFKA_RESP_ERR_END_ALL<a class="headerlink" href="#rd_kafka_resp_err_end_all_25" title="Permanent link">&para;</a></h3>
<p><div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_END_ALL</span> <span class="o">=</span> <span class="mi">98</span>
</code></pre></div>
enum rd_kafka_resp_err_t</p>
<h3 id="rd_kafka_admin_op__cnt_25">RD_KAFKA_ADMIN_OP__CNT<a class="headerlink" href="#rd_kafka_admin_op__cnt_25" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_ADMIN_OP__CNT</span> <span class="o">=</span> <span class="mi">16</span>
</code></pre></div>
<p>Number of ops defined </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe </a></li>
</ul>
</div>
<h3 id="rd_kafka_resource__cnt_25">RD_KAFKA_RESOURCE__CNT<a class="headerlink" href="#rd_kafka_resource__cnt_25" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESOURCE__CNT</span> <span class="o">=</span> <span class="mi">5</span>
</code></pre></div>
<p>Number of resource types defined </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#acca83a66d7783ff7683ed2691cc907c9"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#acca83a66d7783ff7683ed2691cc907c9 </a></li>
</ul>
</div>
<h3 id="rd_kafka_cdef_25">RD_KAFKA_CDEF<a class="headerlink" href="#rd_kafka_cdef_25" title="Permanent link">&para;</a></h3>
<p><div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_CDEF</span> <span class="o">=</span> <span class="s1">&#39;typedef long int ssize_t;</span>
<span class="s1">typedef struct _IO_FILE FILE;</span>
<span class="s1">typedef long int mode_t;</span>
<span class="s1">typedef signed int int16_t;</span>
<span class="s1">typedef unsigned int uint16_t;</span>
<span class="s1">typedef signed int int32_t;</span>
<span class="s1">typedef signed long int int64_t;</span>
<span class="s1">int rd_kafka_version(void);</span>
<span class="s1">const char *rd_kafka_version_str(void);</span>
<span class="s1">typedef enum rd_kafka_type_t {</span>
<span class="s1">  RD_KAFKA_PRODUCER,</span>
<span class="s1">  RD_KAFKA_CONSUMER,</span>
<span class="s1">} rd_kafka_type_t;</span>
<span class="s1">typedef enum rd_kafka_timestamp_type_t {</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_NOT_AVAILABLE,</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_CREATE_TIME,</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_LOG_APPEND_TIME,</span>
<span class="s1">} rd_kafka_timestamp_type_t;</span>
<span class="s1">const char *rd_kafka_get_debug_contexts(void);</span>
<span class="s1">typedef struct rd_kafka_s rd_kafka_t;</span>
<span class="s1">typedef struct rd_kafka_topic_s rd_kafka_topic_t;</span>
<span class="s1">typedef struct rd_kafka_conf_s rd_kafka_conf_t;</span>
<span class="s1">typedef struct rd_kafka_topic_conf_s rd_kafka_topic_conf_t;</span>
<span class="s1">typedef struct rd_kafka_queue_s rd_kafka_queue_t;</span>
<span class="s1">typedef struct rd_kafka_op_s rd_kafka_event_t;</span>
<span class="s1">typedef struct rd_kafka_topic_result_s rd_kafka_topic_result_t;</span>
<span class="s1">typedef struct rd_kafka_consumer_group_metadata_s rd_kafka_consumer_group_metadata_t;</span>
<span class="s1">typedef struct rd_kafka_error_s {</span>
<span class="s1">  unsigned int code;</span>
<span class="s1">  char *errstr;</span>
<span class="s1">  unsigned char fatal;</span>
<span class="s1">  unsigned char retriable;</span>
<span class="s1">  unsigned char txn_requires_abort;</span>
<span class="s1">} rd_kafka_error_t;</span>
<span class="s1">typedef struct rd_kafka_headers_s rd_kafka_headers_t;</span>
<span class="s1">typedef struct rd_kafka_group_result_s rd_kafka_group_result_t;</span>
<span class="s1">typedef struct rd_kafka_acl_result_s rd_kafka_acl_result_t;</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BEGIN = (- 200),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BAD_MSG = (- 199),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BAD_COMPRESSION = (- 198),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__DESTROY = (- 197),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FAIL = (- 196),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TRANSPORT = (- 195),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__CRIT_SYS_RESOURCE = (- 194),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__RESOLVE = (- 193),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__MSG_TIMED_OUT = (- 192),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PARTITION_EOF = (- 191),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION = (- 190),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FS = (- 189),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC = (- 188),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ALL_BROKERS_DOWN = (- 187),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INVALID_ARG = (- 186),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TIMED_OUT = (- 185),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__QUEUE_FULL = (- 184),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ISR_INSUFF = (- 183),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NODE_UPDATE = (- 182),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__SSL = (- 181),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__WAIT_COORD = (- 180),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_GROUP = (- 179),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__IN_PROGRESS = (- 178),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PREV_IN_PROGRESS = (- 177),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__EXISTING_SUBSCRIPTION = (- 176),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS = (- 175),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS = (- 174),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__CONFLICT = (- 173),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__STATE = (- 172),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_PROTOCOL = (- 171),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED = (- 170),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__AUTHENTICATION = (- 169),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NO_OFFSET = (- 168),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__OUTDATED = (- 167),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TIMED_OUT_QUEUE = (- 166),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNSUPPORTED_FEATURE = (- 165),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__WAIT_CACHE = (- 164),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INTR = (- 163),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__KEY_SERIALIZATION = (- 162),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__VALUE_SERIALIZATION = (- 161),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__KEY_DESERIALIZATION = (- 160),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__VALUE_DESERIALIZATION = (- 159),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PARTIAL = (- 158),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__READ_ONLY = (- 157),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOENT = (- 156),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNDERFLOW = (- 155),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INVALID_TYPE = (- 154),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__RETRY = (- 153),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PURGE_QUEUE = (- 152),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PURGE_INFLIGHT = (- 151),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FATAL = (- 150),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INCONSISTENT = (- 149),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__GAPLESS_GUARANTEE = (- 148),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__MAX_POLL_EXCEEDED = (- 147),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_BROKER = (- 146),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOT_CONFIGURED = (- 145),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FENCED = (- 144),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__APPLICATION = (- 143),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ASSIGNMENT_LOST = (- 142),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOOP = (- 141),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__AUTO_OFFSET_RESET = (- 140),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__LOG_TRUNCATION = (- 139),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__END = (- 100),</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN = (- 1),</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NO_ERROR = 0,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_OUT_OF_RANGE = 1,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_MSG = 2,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART = 3,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_MSG_SIZE = 4,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE = 5,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_LEADER_FOR_PARTITION = 6,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REQUEST_TIMED_OUT = 7,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_BROKER_NOT_AVAILABLE = 8,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REPLICA_NOT_AVAILABLE = 9,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE = 10,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_STALE_CTRL_EPOCH = 11,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_METADATA_TOO_LARGE = 12,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NETWORK_EXCEPTION = 13,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_COORDINATOR_LOAD_IN_PROGRESS = 14,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_COORDINATOR_NOT_AVAILABLE = 15,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_COORDINATOR = 16,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_EXCEPTION = 17,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_RECORD_LIST_TOO_LARGE = 18,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS = 19,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS_AFTER_APPEND = 20,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REQUIRED_ACKS = 21,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ILLEGAL_GENERATION = 22,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INCONSISTENT_GROUP_PROTOCOL = 23,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_GROUP_ID = 24,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_MEMBER_ID = 25,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_SESSION_TIMEOUT = 26,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REBALANCE_IN_PROGRESS = 27,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_COMMIT_OFFSET_SIZE = 28,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_AUTHORIZATION_FAILED = 29,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_AUTHORIZATION_FAILED = 30,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_CLUSTER_AUTHORIZATION_FAILED = 31,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TIMESTAMP = 32,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_SASL_MECHANISM = 33,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ILLEGAL_SASL_STATE = 34,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_VERSION = 35,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_ALREADY_EXISTS = 36,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PARTITIONS = 37,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REPLICATION_FACTOR = 38,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REPLICA_ASSIGNMENT = 39,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_CONFIG = 40,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_CONTROLLER = 41,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REQUEST = 42,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_FOR_MESSAGE_FORMAT = 43,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_POLICY_VIOLATION = 44,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OUT_OF_ORDER_SEQUENCE_NUMBER = 45,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DUPLICATE_SEQUENCE_NUMBER = 46,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_EPOCH = 47,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TXN_STATE = 48,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_ID_MAPPING = 49,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TRANSACTION_TIMEOUT = 50,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_CONCURRENT_TRANSACTIONS = 51,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TRANSACTION_COORDINATOR_FENCED = 52,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TRANSACTIONAL_ID_AUTHORIZATION_FAILED = 53,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_SECURITY_DISABLED = 54,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OPERATION_NOT_ATTEMPTED = 55,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_KAFKA_STORAGE_ERROR = 56,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LOG_DIR_NOT_FOUND = 57,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_SASL_AUTHENTICATION_FAILED = 58,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_PRODUCER_ID = 59,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REASSIGNMENT_IN_PROGRESS = 60,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTH_DISABLED = 61,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_NOT_FOUND = 62,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_OWNER_MISMATCH = 63,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_REQUEST_NOT_ALLOWED = 64,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTHORIZATION_FAILED = 65,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_EXPIRED = 66,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRINCIPAL_TYPE = 67,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NON_EMPTY_GROUP = 68,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_ID_NOT_FOUND = 69,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FETCH_SESSION_ID_NOT_FOUND = 70,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_FETCH_SESSION_EPOCH = 71,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LISTENER_NOT_FOUND = 72,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_DELETION_DISABLED = 73,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FENCED_LEADER_EPOCH = 74,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_LEADER_EPOCH = 75,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_STALE_BROKER_EPOCH = 77,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_NOT_AVAILABLE = 78,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_MEMBER_ID_REQUIRED = 79,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_PREFERRED_LEADER_NOT_AVAILABLE = 80,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_MAX_SIZE_REACHED = 81,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FENCED_INSTANCE_ID = 82,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ELIGIBLE_LEADERS_NOT_AVAILABLE = 83,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ELECTION_NOT_NEEDED = 84,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NO_REASSIGNMENT_IN_PROGRESS = 85,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_SUBSCRIBED_TO_TOPIC = 86,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_RECORD = 87,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSTABLE_OFFSET_COMMIT = 88,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_THROTTLING_QUOTA_EXCEEDED = 89,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_PRODUCER_FENCED = 90,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_RESOURCE_NOT_FOUND = 91,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DUPLICATE_RESOURCE = 92,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNACCEPTABLE_CREDENTIAL = 93,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INCONSISTENT_VOTER_SET = 94,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_UPDATE_VERSION = 95,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FEATURE_UPDATE_FAILED = 96,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_PRINCIPAL_DESERIALIZATION_FAILURE = 97,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_END_ALL,</span>
<span class="s1">} rd_kafka_resp_err_t;</span>
<span class="s1">struct rd_kafka_err_desc {</span>
<span class="s1">  rd_kafka_resp_err_t code;</span>
<span class="s1">  char *name;</span>
<span class="s1">  char *desc;</span>
<span class="s1">};</span>
<span class="s1">void rd_kafka_get_err_descs(const struct rd_kafka_err_desc **errdescs, size_t *cntp);</span>
<span class="s1">const char *rd_kafka_err2str(rd_kafka_resp_err_t err);</span>
<span class="s1">const char *rd_kafka_err2name(rd_kafka_resp_err_t err);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_last_error(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_errno2err(int errnox);</span>
<span class="s1">int rd_kafka_errno(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_fatal_error(rd_kafka_t *rk, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_test_fatal_error(rd_kafka_t *rk, rd_kafka_resp_err_t err, const char *reason);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_error_code(const rd_kafka_error_t *error);</span>
<span class="s1">const char *rd_kafka_error_name(const rd_kafka_error_t *error);</span>
<span class="s1">const char *rd_kafka_error_string(const rd_kafka_error_t *error);</span>
<span class="s1">int rd_kafka_error_is_fatal(const rd_kafka_error_t *error);</span>
<span class="s1">int rd_kafka_error_is_retriable(const rd_kafka_error_t *error);</span>
<span class="s1">int rd_kafka_error_txn_requires_abort(const rd_kafka_error_t *error);</span>
<span class="s1">void rd_kafka_error_destroy(rd_kafka_error_t *error);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_error_new(rd_kafka_resp_err_t code, const char *fmt, ...);</span>
<span class="s1">typedef struct rd_kafka_topic_partition_s {</span>
<span class="s1">  char *topic;</span>
<span class="s1">  int32_t partition;</span>
<span class="s1">  int64_t offset;</span>
<span class="s1">  void *metadata;</span>
<span class="s1">  size_t metadata_size;</span>
<span class="s1">  void *opaque;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  void *_private;</span>
<span class="s1">} rd_kafka_topic_partition_t;</span>
<span class="s1">void rd_kafka_topic_partition_destroy(rd_kafka_topic_partition_t *rktpar);</span>
<span class="s1">void rd_kafka_topic_partition_set_leader_epoch(rd_kafka_topic_partition_t *rktpar, int32_t leader_epoch);</span>
<span class="s1">int32_t rd_kafka_topic_partition_get_leader_epoch(const rd_kafka_topic_partition_t *rktpar);</span>
<span class="s1">typedef struct rd_kafka_topic_partition_list_s {</span>
<span class="s1">  int cnt;</span>
<span class="s1">  int size;</span>
<span class="s1">  rd_kafka_topic_partition_t *elems;</span>
<span class="s1">} rd_kafka_topic_partition_list_t;</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_new(int size);</span>
<span class="s1">void rd_kafka_topic_partition_list_destroy(rd_kafka_topic_partition_list_t *rkparlist);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_add(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">void rd_kafka_topic_partition_list_add_range(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t start, int32_t stop);</span>
<span class="s1">int rd_kafka_topic_partition_list_del(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">int rd_kafka_topic_partition_list_del_by_idx(rd_kafka_topic_partition_list_t *rktparlist, int idx);</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_copy(const rd_kafka_topic_partition_list_t *src);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_topic_partition_list_set_offset(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition, int64_t offset);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_find(const rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">void rd_kafka_topic_partition_list_sort(rd_kafka_topic_partition_list_t *rktparlist, int (*cmp)(const void *a, const void *b, void *cmp_opaque), void *cmp_opaque);</span>
<span class="s1">typedef enum rd_kafka_vtype_t {</span>
<span class="s1">  RD_KAFKA_VTYPE_END,</span>
<span class="s1">  RD_KAFKA_VTYPE_TOPIC,</span>
<span class="s1">  RD_KAFKA_VTYPE_RKT,</span>
<span class="s1">  RD_KAFKA_VTYPE_PARTITION,</span>
<span class="s1">  RD_KAFKA_VTYPE_VALUE,</span>
<span class="s1">  RD_KAFKA_VTYPE_KEY,</span>
<span class="s1">  RD_KAFKA_VTYPE_OPAQUE,</span>
<span class="s1">  RD_KAFKA_VTYPE_MSGFLAGS,</span>
<span class="s1">  RD_KAFKA_VTYPE_TIMESTAMP,</span>
<span class="s1">  RD_KAFKA_VTYPE_HEADER,</span>
<span class="s1">  RD_KAFKA_VTYPE_HEADERS,</span>
<span class="s1">} rd_kafka_vtype_t;</span>
<span class="s1">typedef struct rd_kafka_vu_s {</span>
<span class="s1">  rd_kafka_vtype_t vtype;</span>
<span class="s1">  union {</span>
<span class="s1">    char *cstr;</span>
<span class="s1">    rd_kafka_topic_t *rkt;</span>
<span class="s1">    int i;</span>
<span class="s1">    int32_t i32;</span>
<span class="s1">    int64_t i64;</span>
<span class="s1">    struct {</span>
<span class="s1">      void *ptr;</span>
<span class="s1">      size_t size;</span>
<span class="s1">    } mem;</span>
<span class="s1">    struct {</span>
<span class="s1">      char *name;</span>
<span class="s1">      void *val;</span>
<span class="s1">      ssize_t size;</span>
<span class="s1">    } header;</span>
<span class="s1">    rd_kafka_headers_t *headers;</span>
<span class="s1">    void *ptr;</span>
<span class="s1">    char _pad[64];</span>
<span class="s1">  } u;</span>
<span class="s1">} rd_kafka_vu_t;</span>
<span class="s1">rd_kafka_headers_t *rd_kafka_headers_new(size_t initial_count);</span>
<span class="s1">void rd_kafka_headers_destroy(rd_kafka_headers_t *hdrs);</span>
<span class="s1">rd_kafka_headers_t *rd_kafka_headers_copy(const rd_kafka_headers_t *src);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_add(rd_kafka_headers_t *hdrs, const char *name, ssize_t name_size, const void *value, ssize_t value_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_remove(rd_kafka_headers_t *hdrs, const char *name);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get_last(const rd_kafka_headers_t *hdrs, const char *name, const void **valuep, size_t *sizep);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get(const rd_kafka_headers_t *hdrs, size_t idx, const char *name, const void **valuep, size_t *sizep);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get_all(const rd_kafka_headers_t *hdrs, size_t idx, const char **namep, const void **valuep, size_t *sizep);</span>
<span class="s1">typedef struct rd_kafka_message_s {</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  rd_kafka_topic_t *rkt;</span>
<span class="s1">  int32_t partition;</span>
<span class="s1">  void *payload;</span>
<span class="s1">  size_t len;</span>
<span class="s1">  void *key;</span>
<span class="s1">  size_t key_len;</span>
<span class="s1">  int64_t offset;</span>
<span class="s1">  void *_private;</span>
<span class="s1">} rd_kafka_message_t;</span>
<span class="s1">void rd_kafka_message_destroy(rd_kafka_message_t *rkmessage);</span>
<span class="s1">const char *rd_kafka_message_errstr(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">int64_t rd_kafka_message_timestamp(const rd_kafka_message_t *rkmessage, rd_kafka_timestamp_type_t *tstype);</span>
<span class="s1">int64_t rd_kafka_message_latency(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">int32_t rd_kafka_message_broker_id(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_message_headers(const rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_message_detach_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);</span>
<span class="s1">void rd_kafka_message_set_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t *hdrs);</span>
<span class="s1">size_t rd_kafka_header_cnt(const rd_kafka_headers_t *hdrs);</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_NOT_PERSISTED = 0,</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_POSSIBLY_PERSISTED = 1,</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_PERSISTED = 2,</span>
<span class="s1">} rd_kafka_msg_status_t;</span>
<span class="s1">rd_kafka_msg_status_t rd_kafka_message_status(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">int32_t rd_kafka_message_leader_epoch(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_CONF_UNKNOWN = (- 2),</span>
<span class="s1">  RD_KAFKA_CONF_INVALID = (- 1),</span>
<span class="s1">  RD_KAFKA_CONF_OK = 0,</span>
<span class="s1">} rd_kafka_conf_res_t;</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_new(void);</span>
<span class="s1">void rd_kafka_conf_destroy(rd_kafka_conf_t *conf);</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_dup(const rd_kafka_conf_t *conf);</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_dup_filter(const rd_kafka_conf_t *conf, size_t filter_cnt, const char **filter);</span>
<span class="s1">const rd_kafka_conf_t *rd_kafka_conf(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_set(rd_kafka_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_conf_set_events(rd_kafka_conf_t *conf, int events);</span>
<span class="s1">void rd_kafka_conf_set_background_event_cb(rd_kafka_conf_t *conf, void (*event_cb)(rd_kafka_t *rk, rd_kafka_event_t *rkev, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_dr_cb(rd_kafka_conf_t *conf, void (*dr_cb)(rd_kafka_t *rk, void *payload, size_t len, rd_kafka_resp_err_t err, void *opaque, void *msg_opaque));</span>
<span class="s1">void rd_kafka_conf_set_dr_msg_cb(rd_kafka_conf_t *conf, void (*dr_msg_cb)(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_consume_cb(rd_kafka_conf_t *conf, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_rebalance_cb(rd_kafka_conf_t *conf, void (*rebalance_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *partitions, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_offset_commit_cb(rd_kafka_conf_t *conf, void (*offset_commit_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_error_cb(rd_kafka_conf_t *conf, void (*error_cb)(rd_kafka_t *rk, int err, const char *reason, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_throttle_cb(rd_kafka_conf_t *conf, void (*throttle_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int throttle_time_ms, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_log_cb(rd_kafka_conf_t *conf, void (*log_cb)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));</span>
<span class="s1">void rd_kafka_conf_set_stats_cb(rd_kafka_conf_t *conf, int (*stats_cb)(rd_kafka_t *rk, char *json, size_t json_len, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_oauthbearer_token_refresh_cb(rd_kafka_conf_t *conf, void (*oauthbearer_token_refresh_cb)(rd_kafka_t *rk, const char *oauthbearer_config, void *opaque));</span>
<span class="s1">void rd_kafka_conf_enable_sasl_queue(rd_kafka_conf_t *conf, int enable);</span>
<span class="s1">void rd_kafka_conf_set_socket_cb(rd_kafka_conf_t *conf, int (*socket_cb)(int domain, int type, int protocol, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_connect_cb(rd_kafka_conf_t *conf, int (*connect_cb)(int sockfd, const struct sockaddr *addr, int addrlen, const char *id, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_closesocket_cb(rd_kafka_conf_t *conf, int (*closesocket_cb)(int sockfd, void *opaque));</span>
<span class="s1">struct addrinfo;</span>
<span class="s1">void rd_kafka_conf_set_resolve_cb(rd_kafka_conf_t *conf, int (*resolve_cb)(const char *node, const char *service, const struct addrinfo *hints, struct addrinfo **res, void *opaque));</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert_verify_cb(rd_kafka_conf_t *conf, int (*ssl_cert_verify_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int *x509_error, int depth, const char *buf, size_t size, char *errstr, size_t errstr_size, void *opaque));</span>
<span class="s1">typedef enum rd_kafka_cert_type_t {</span>
<span class="s1">  RD_KAFKA_CERT_PUBLIC_KEY,</span>
<span class="s1">  RD_KAFKA_CERT_PRIVATE_KEY,</span>
<span class="s1">  RD_KAFKA_CERT_CA,</span>
<span class="s1">  RD_KAFKA_CERT__CNT,</span>
<span class="s1">} rd_kafka_cert_type_t;</span>
<span class="s1">typedef enum rd_kafka_cert_enc_t {</span>
<span class="s1">  RD_KAFKA_CERT_ENC_PKCS12,</span>
<span class="s1">  RD_KAFKA_CERT_ENC_DER,</span>
<span class="s1">  RD_KAFKA_CERT_ENC_PEM,</span>
<span class="s1">  RD_KAFKA_CERT_ENC__CNT,</span>
<span class="s1">} rd_kafka_cert_enc_t;</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert(rd_kafka_conf_t *conf, rd_kafka_cert_type_t cert_type, rd_kafka_cert_enc_t cert_enc, const void *buffer, size_t size, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_conf_set_engine_callback_data(rd_kafka_conf_t *conf, void *callback_data);</span>
<span class="s1">void rd_kafka_conf_set_opaque(rd_kafka_conf_t *conf, void *opaque);</span>
<span class="s1">void *rd_kafka_opaque(const rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_conf_set_default_topic_conf(rd_kafka_conf_t *conf, rd_kafka_topic_conf_t *tconf);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_conf_get_default_topic_conf(rd_kafka_conf_t *conf);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_get(const rd_kafka_conf_t *conf, const char *name, char *dest, size_t *dest_size);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_topic_conf_get(const rd_kafka_topic_conf_t *conf, const char *name, char *dest, size_t *dest_size);</span>
<span class="s1">const char **rd_kafka_conf_dump(rd_kafka_conf_t *conf, size_t *cntp);</span>
<span class="s1">const char **rd_kafka_topic_conf_dump(rd_kafka_topic_conf_t *conf, size_t *cntp);</span>
<span class="s1">void rd_kafka_conf_dump_free(const char **arr, size_t cnt);</span>
<span class="s1">void rd_kafka_conf_properties_show(FILE *fp);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_topic_conf_new(void);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_topic_conf_dup(const rd_kafka_topic_conf_t *conf);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_default_topic_conf_dup(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_topic_conf_destroy(rd_kafka_topic_conf_t *topic_conf);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_topic_conf_set(rd_kafka_topic_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_topic_conf_set_opaque(rd_kafka_topic_conf_t *conf, void *rkt_opaque);</span>
<span class="s1">void rd_kafka_topic_conf_set_partitioner_cb(rd_kafka_topic_conf_t *topic_conf, int32_t (*partitioner)(const rd_kafka_topic_t *rkt, const void *keydata, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque));</span>
<span class="s1">void rd_kafka_topic_conf_set_msg_order_cmp(rd_kafka_topic_conf_t *topic_conf, int (*msg_order_cmp)(const rd_kafka_message_t *a, const rd_kafka_message_t *b));</span>
<span class="s1">int rd_kafka_topic_partition_available(const rd_kafka_topic_t *rkt, int32_t partition);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_consistent(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_consistent_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_murmur2(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_murmur2_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_fnv1a(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_fnv1a_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">rd_kafka_t *rd_kafka_new(rd_kafka_type_t type, rd_kafka_conf_t *conf, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_destroy(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_destroy_flags(rd_kafka_t *rk, int flags);</span>
<span class="s1">const char *rd_kafka_name(const rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_type_t rd_kafka_type(const rd_kafka_t *rk);</span>
<span class="s1">char *rd_kafka_memberid(const rd_kafka_t *rk);</span>
<span class="s1">char *rd_kafka_clusterid(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">int32_t rd_kafka_controllerid(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_topic_t *rd_kafka_topic_new(rd_kafka_t *rk, const char *topic, rd_kafka_topic_conf_t *conf);</span>
<span class="s1">void rd_kafka_topic_destroy(rd_kafka_topic_t *rkt);</span>
<span class="s1">const char *rd_kafka_topic_name(const rd_kafka_topic_t *rkt);</span>
<span class="s1">void *rd_kafka_topic_opaque(const rd_kafka_topic_t *rkt);</span>
<span class="s1">int rd_kafka_poll(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">void rd_kafka_yield(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_pause_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_resume_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_query_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_get_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offsets_for_times(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets, int timeout_ms);</span>
<span class="s1">void *rd_kafka_mem_calloc(rd_kafka_t *rk, size_t num, size_t size);</span>
<span class="s1">void *rd_kafka_mem_malloc(rd_kafka_t *rk, size_t size);</span>
<span class="s1">void rd_kafka_mem_free(rd_kafka_t *rk, void *ptr);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_new(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_queue_destroy(rd_kafka_queue_t *rkqu);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_main(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_sasl(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_sasl_background_callbacks_enable(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_sasl_set_credentials(rd_kafka_t *rk, const char *username, const char *password);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_consumer(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_partition(rd_kafka_t *rk, const char *topic, int32_t partition);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_background(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_queue_forward(rd_kafka_queue_t *src, rd_kafka_queue_t *dst);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_set_log_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu);</span>
<span class="s1">size_t rd_kafka_queue_length(rd_kafka_queue_t *rkqu);</span>
<span class="s1">void rd_kafka_queue_io_event_enable(rd_kafka_queue_t *rkqu, int fd, const void *payload, size_t size);</span>
<span class="s1">void rd_kafka_queue_cb_event_enable(rd_kafka_queue_t *rkqu, void (*event_cb)(rd_kafka_t *rk, void *qev_opaque), void *qev_opaque);</span>
<span class="s1">void rd_kafka_queue_yield(rd_kafka_queue_t *rkqu);</span>
<span class="s1">int rd_kafka_consume_start(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);</span>
<span class="s1">int rd_kafka_consume_start_queue(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, rd_kafka_queue_t *rkqu);</span>
<span class="s1">int rd_kafka_consume_stop(rd_kafka_topic_t *rkt, int32_t partition);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_seek(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, int timeout_ms);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_seek_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consume(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms);</span>
<span class="s1">ssize_t rd_kafka_consume_batch(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);</span>
<span class="s1">int rd_kafka_consume_callback(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consume_queue(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">ssize_t rd_kafka_consume_batch_queue(rd_kafka_queue_t *rkqu, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);</span>
<span class="s1">int rd_kafka_consume_callback_queue(rd_kafka_queue_t *rkqu, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offset_store(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offsets_store(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_offset_store_message(rd_kafka_message_t *rkmessage);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_subscribe(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *topics);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_unsubscribe(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_subscription(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **topics);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consumer_poll(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_consumer_close(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_consumer_close_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu);</span>
<span class="s1">int rd_kafka_consumer_closed(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_incremental_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_incremental_unassign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">const char *rd_kafka_rebalance_protocol(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_assignment(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **partitions);</span>
<span class="s1">int rd_kafka_assignment_lost(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, int async);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit_message(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, int async);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit_queue(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_queue_t *rkqu, void (*cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *commit_opaque), void *commit_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_committed(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_position(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata_new(const char *group_id);</span>
<span class="s1">rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata_new_with_genid(const char *group_id, int32_t generation_id, const char *member_id, const char *group_instance_id);</span>
<span class="s1">void rd_kafka_consumer_group_metadata_destroy(rd_kafka_consumer_group_metadata_t *);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_consumer_group_metadata_write(const rd_kafka_consumer_group_metadata_t *cgmd, void **bufferp, size_t *sizep);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_consumer_group_metadata_read(rd_kafka_consumer_group_metadata_t **cgmdp, const void *buffer, size_t size);</span>
<span class="s1">int rd_kafka_produce(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, void *payload, size_t len, const void *key, size_t keylen, void *msg_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_producev(rd_kafka_t *rk, ...);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_produceva(rd_kafka_t *rk, const rd_kafka_vu_t *vus, size_t cnt);</span>
<span class="s1">int rd_kafka_produce_batch(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, rd_kafka_message_t *rkmessages, int message_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_flush(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_purge(rd_kafka_t *rk, int purge_flags);</span>
<span class="s1">typedef struct rd_kafka_metadata_broker {</span>
<span class="s1">  int32_t id;</span>
<span class="s1">  char *host;</span>
<span class="s1">  int port;</span>
<span class="s1">} rd_kafka_metadata_broker_t;</span>
<span class="s1">typedef struct rd_kafka_metadata_partition {</span>
<span class="s1">  int32_t id;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  int32_t leader;</span>
<span class="s1">  int replica_cnt;</span>
<span class="s1">  int32_t *replicas;</span>
<span class="s1">  int isr_cnt;</span>
<span class="s1">  int32_t *isrs;</span>
<span class="s1">} rd_kafka_metadata_partition_t;</span>
<span class="s1">typedef struct rd_kafka_metadata_topic {</span>
<span class="s1">  char *topic;</span>
<span class="s1">  int partition_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_partition *partitions;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">} rd_kafka_metadata_topic_t;</span>
<span class="s1">typedef struct rd_kafka_metadata {</span>
<span class="s1">  int broker_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_broker *brokers;</span>
<span class="s1">  int topic_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_topic *topics;</span>
<span class="s1">  int32_t orig_broker_id;</span>
<span class="s1">  char *orig_broker_name;</span>
<span class="s1">} rd_kafka_metadata_t;</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_metadata(rd_kafka_t *rk, int all_topics, rd_kafka_topic_t *only_rkt, const struct rd_kafka_metadata **metadatap, int timeout_ms);</span>
<span class="s1">void rd_kafka_metadata_destroy(const struct rd_kafka_metadata *metadata);</span>
<span class="s1">typedef struct rd_kafka_Node_s rd_kafka_Node_t;</span>
<span class="s1">int rd_kafka_Node_id(const rd_kafka_Node_t *node);</span>
<span class="s1">const char *rd_kafka_Node_host(const rd_kafka_Node_t *node);</span>
<span class="s1">uint16_t rd_kafka_Node_port(const rd_kafka_Node_t *node);</span>
<span class="s1">struct rd_kafka_group_member_info {</span>
<span class="s1">  char *member_id;</span>
<span class="s1">  char *client_id;</span>
<span class="s1">  char *client_host;</span>
<span class="s1">  void *member_metadata;</span>
<span class="s1">  int member_metadata_size;</span>
<span class="s1">  void *member_assignment;</span>
<span class="s1">  int member_assignment_size;</span>
<span class="s1">};</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_CONSUMER_GROUP_STATE_UNKNOWN = 0,</span>
<span class="s1">  RD_KAFKA_CONSUMER_GROUP_STATE_PREPARING_REBALANCE = 1,</span>
<span class="s1">  RD_KAFKA_CONSUMER_GROUP_STATE_COMPLETING_REBALANCE = 2,</span>
<span class="s1">  RD_KAFKA_CONSUMER_GROUP_STATE_STABLE = 3,</span>
<span class="s1">  RD_KAFKA_CONSUMER_GROUP_STATE_DEAD = 4,</span>
<span class="s1">  RD_KAFKA_CONSUMER_GROUP_STATE_EMPTY = 5,</span>
<span class="s1">  RD_KAFKA_CONSUMER_GROUP_STATE__CNT,</span>
<span class="s1">} rd_kafka_consumer_group_state_t;</span>
<span class="s1">struct rd_kafka_group_info {</span>
<span class="s1">  struct rd_kafka_metadata_broker broker;</span>
<span class="s1">  char *group;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  char *state;</span>
<span class="s1">  char *protocol_type;</span>
<span class="s1">  char *protocol;</span>
<span class="s1">  struct rd_kafka_group_member_info *members;</span>
<span class="s1">  int member_cnt;</span>
<span class="s1">};</span>
<span class="s1">struct rd_kafka_group_list {</span>
<span class="s1">  struct rd_kafka_group_info *groups;</span>
<span class="s1">  int group_cnt;</span>
<span class="s1">};</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_list_groups(rd_kafka_t *rk, const char *group, const struct rd_kafka_group_list **grplistp, int timeout_ms);</span>
<span class="s1">const char *rd_kafka_consumer_group_state_name(rd_kafka_consumer_group_state_t state);</span>
<span class="s1">rd_kafka_consumer_group_state_t rd_kafka_consumer_group_state_code(const char *name);</span>
<span class="s1">void rd_kafka_group_list_destroy(const struct rd_kafka_group_list *grplist);</span>
<span class="s1">int rd_kafka_brokers_add(rd_kafka_t *rk, const char *brokerlist);</span>
<span class="s1">void rd_kafka_set_logger(rd_kafka_t *rk, void (*func)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));</span>
<span class="s1">void rd_kafka_set_log_level(rd_kafka_t *rk, int level);</span>
<span class="s1">void rd_kafka_log_print(const rd_kafka_t *rk, int level, const char *fac, const char *buf);</span>
<span class="s1">void rd_kafka_log_syslog(const rd_kafka_t *rk, int level, const char *fac, const char *buf);</span>
<span class="s1">int rd_kafka_outq_len(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_dump(FILE *fp, rd_kafka_t *rk);</span>
<span class="s1">int rd_kafka_thread_cnt(void);</span>
<span class="s1">typedef enum rd_kafka_thread_type_t {</span>
<span class="s1">  RD_KAFKA_THREAD_MAIN,</span>
<span class="s1">  RD_KAFKA_THREAD_BACKGROUND,</span>
<span class="s1">  RD_KAFKA_THREAD_BROKER,</span>
<span class="s1">} rd_kafka_thread_type_t;</span>
<span class="s1">int rd_kafka_wait_destroyed(int timeout_ms);</span>
<span class="s1">int rd_kafka_unittest(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_poll_set_consumer(rd_kafka_t *rk);</span>
<span class="s1">typedef int rd_kafka_event_type_t;</span>
<span class="s1">rd_kafka_event_type_t rd_kafka_event_type(const rd_kafka_event_t *rkev);</span>
<span class="s1">const char *rd_kafka_event_name(const rd_kafka_event_t *rkev);</span>
<span class="s1">void rd_kafka_event_destroy(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_message_t *rd_kafka_event_message_next(rd_kafka_event_t *rkev);</span>
<span class="s1">size_t rd_kafka_event_message_array(rd_kafka_event_t *rkev, const rd_kafka_message_t **rkmessages, size_t size);</span>
<span class="s1">size_t rd_kafka_event_message_count(rd_kafka_event_t *rkev);</span>
<span class="s1">const char *rd_kafka_event_config_string(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_event_error(rd_kafka_event_t *rkev);</span>
<span class="s1">const char *rd_kafka_event_error_string(rd_kafka_event_t *rkev);</span>
<span class="s1">int rd_kafka_event_error_is_fatal(rd_kafka_event_t *rkev);</span>
<span class="s1">void *rd_kafka_event_opaque(rd_kafka_event_t *rkev);</span>
<span class="s1">int rd_kafka_event_log(rd_kafka_event_t *rkev, const char **fac, const char **str, int *level);</span>
<span class="s1">int rd_kafka_event_debug_contexts(rd_kafka_event_t *rkev, char *dst, size_t dstsize);</span>
<span class="s1">const char *rd_kafka_event_stats(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_event_topic_partition_list(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_event_topic_partition(rd_kafka_event_t *rkev);</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_CreateTopics_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DeleteTopics_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_CreateAcls_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DescribeAcls_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DeleteAcls_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_CreatePartitions_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_AlterConfigs_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DescribeConfigs_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DeleteRecords_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_ListConsumerGroups_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DescribeConsumerGroups_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DeleteGroups_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DeleteConsumerGroupOffsets_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_AlterConsumerGroupOffsets_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_ListConsumerGroupOffsets_result_t;</span>
<span class="s1">const rd_kafka_CreateTopics_result_t *rd_kafka_event_CreateTopics_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DeleteTopics_result_t *rd_kafka_event_DeleteTopics_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_CreatePartitions_result_t *rd_kafka_event_CreatePartitions_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_AlterConfigs_result_t *rd_kafka_event_AlterConfigs_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DescribeConfigs_result_t *rd_kafka_event_DescribeConfigs_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DeleteRecords_result_t *rd_kafka_event_DeleteRecords_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_ListConsumerGroups_result_t *rd_kafka_event_ListConsumerGroups_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DescribeConsumerGroups_result_t *rd_kafka_event_DescribeConsumerGroups_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DeleteGroups_result_t *rd_kafka_event_DeleteGroups_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DeleteConsumerGroupOffsets_result_t *rd_kafka_event_DeleteConsumerGroupOffsets_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_CreateAcls_result_t *rd_kafka_event_CreateAcls_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DescribeAcls_result_t *rd_kafka_event_DescribeAcls_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DeleteAcls_result_t *rd_kafka_event_DeleteAcls_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_AlterConsumerGroupOffsets_result_t *rd_kafka_event_AlterConsumerGroupOffsets_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_ListConsumerGroupOffsets_result_t *rd_kafka_event_ListConsumerGroupOffsets_result(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_event_t *rd_kafka_queue_poll(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">int rd_kafka_queue_poll_callback(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_plugin_f_conf_init_t)(rd_kafka_conf_t *conf, void **plug_opaquep, char *errstr, size_t errstr_size);</span>
<span class="s1">typedef rd_kafka_conf_res_t (rd_kafka_interceptor_f_on_conf_set_t)(rd_kafka_conf_t *conf, const char *name, const char *val, char *errstr, size_t errstr_size, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_dup_t)(rd_kafka_conf_t *new_conf, const rd_kafka_conf_t *old_conf, size_t filter_cnt, const char **filter, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_destroy_t)(void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_new_t)(rd_kafka_t *rk, const rd_kafka_conf_t *conf, void *ic_opaque, char *errstr, size_t errstr_size);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_destroy_t)(rd_kafka_t *rk, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_send_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_acknowledgement_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_consume_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_commit_t)(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_resp_err_t err, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_request_sent_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_response_received_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, int64_t rtt, rd_kafka_resp_err_t err, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_start_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_exit_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_broker_state_change_t)(rd_kafka_t *rk, int32_t broker_id, const char *secproto, const char *name, int port, const char *state, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_set(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_set_t *on_conf_set, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_dup(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_dup_t *on_conf_dup, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_destroy(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_destroy_t *on_conf_destroy, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_new(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_new_t *on_new, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_destroy(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_destroy_t *on_destroy, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_send(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_send_t *on_send, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_acknowledgement(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_acknowledgement_t *on_acknowledgement, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_consume(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_consume_t *on_consume, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_commit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_commit_t *on_commit, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_request_sent(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_request_sent_t *on_request_sent, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_response_received(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_response_received_t *on_response_received, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_start(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_start_t *on_thread_start, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_exit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_exit_t *on_thread_exit, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_broker_state_change(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_broker_state_change_t *on_broker_state_change, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_topic_result_error(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">const char *rd_kafka_topic_result_error_string(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">const char *rd_kafka_topic_result_name(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">const rd_kafka_error_t *rd_kafka_group_result_error(const rd_kafka_group_result_t *groupres);</span>
<span class="s1">const char *rd_kafka_group_result_name(const rd_kafka_group_result_t *groupres);</span>
<span class="s1">const rd_kafka_topic_partition_list_t *rd_kafka_group_result_partitions(const rd_kafka_group_result_t *groupres);</span>
<span class="s1">typedef enum rd_kafka_admin_op_t {</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_ANY = 0,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_CREATETOPICS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DELETETOPICS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_CREATEPARTITIONS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_ALTERCONFIGS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DESCRIBECONFIGS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DELETERECORDS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DELETEGROUPS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DELETECONSUMERGROUPOFFSETS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_CREATEACLS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DESCRIBEACLS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DELETEACLS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_LISTCONSUMERGROUPS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DESCRIBECONSUMERGROUPS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_LISTCONSUMERGROUPOFFSETS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_ALTERCONSUMERGROUPOFFSETS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP__CNT,</span>
<span class="s1">} rd_kafka_admin_op_t;</span>
<span class="s1">typedef struct rd_kafka_AdminOptions_s rd_kafka_AdminOptions_t;</span>
<span class="s1">rd_kafka_AdminOptions_t *rd_kafka_AdminOptions_new(rd_kafka_t *rk, rd_kafka_admin_op_t for_api);</span>
<span class="s1">void rd_kafka_AdminOptions_destroy(rd_kafka_AdminOptions_t *options);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_request_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_operation_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_validate_only(rd_kafka_AdminOptions_t *options, int true_or_false, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_broker(rd_kafka_AdminOptions_t *options, int32_t broker_id, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_AdminOptions_set_require_stable_offsets(rd_kafka_AdminOptions_t *options, int true_or_false);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_AdminOptions_set_match_consumer_group_states(rd_kafka_AdminOptions_t *options, const rd_kafka_consumer_group_state_t *consumer_group_states, size_t consumer_group_states_cnt);</span>
<span class="s1">void rd_kafka_AdminOptions_set_opaque(rd_kafka_AdminOptions_t *options, void *ev_opaque);</span>
<span class="s1">typedef struct rd_kafka_NewTopic_s rd_kafka_NewTopic_t;</span>
<span class="s1">rd_kafka_NewTopic_t *rd_kafka_NewTopic_new(const char *topic, int num_partitions, int replication_factor, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_NewTopic_destroy(rd_kafka_NewTopic_t *new_topic);</span>
<span class="s1">void rd_kafka_NewTopic_destroy_array(rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewTopic_set_replica_assignment(rd_kafka_NewTopic_t *new_topic, int32_t partition, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewTopic_set_config(rd_kafka_NewTopic_t *new_topic, const char *name, const char *value);</span>
<span class="s1">void rd_kafka_CreateTopics(rd_kafka_t *rk, rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_CreateTopics_result_topics(const rd_kafka_CreateTopics_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_DeleteTopic_s rd_kafka_DeleteTopic_t;</span>
<span class="s1">rd_kafka_DeleteTopic_t *rd_kafka_DeleteTopic_new(const char *topic);</span>
<span class="s1">void rd_kafka_DeleteTopic_destroy(rd_kafka_DeleteTopic_t *del_topic);</span>
<span class="s1">void rd_kafka_DeleteTopic_destroy_array(rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt);</span>
<span class="s1">void rd_kafka_DeleteTopics(rd_kafka_t *rk, rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_DeleteTopics_result_topics(const rd_kafka_DeleteTopics_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_NewPartitions_s rd_kafka_NewPartitions_t;</span>
<span class="s1">rd_kafka_NewPartitions_t *rd_kafka_NewPartitions_new(const char *topic, size_t new_total_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_NewPartitions_destroy(rd_kafka_NewPartitions_t *new_parts);</span>
<span class="s1">void rd_kafka_NewPartitions_destroy_array(rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewPartitions_set_replica_assignment(rd_kafka_NewPartitions_t *new_parts, int32_t new_partition_idx, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_CreatePartitions(rd_kafka_t *rk, rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_CreatePartitions_result_topics(const rd_kafka_CreatePartitions_result_t *result, size_t *cntp);</span>
<span class="s1">typedef enum rd_kafka_ConfigSource_t {</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_UNKNOWN_CONFIG = 0,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_TOPIC_CONFIG = 1,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_BROKER_CONFIG = 2,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_DEFAULT_BROKER_CONFIG = 3,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_STATIC_BROKER_CONFIG = 4,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DEFAULT_CONFIG = 5,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE__CNT,</span>
<span class="s1">} rd_kafka_ConfigSource_t;</span>
<span class="s1">const char *rd_kafka_ConfigSource_name(rd_kafka_ConfigSource_t confsource);</span>
<span class="s1">typedef struct rd_kafka_ConfigEntry_s rd_kafka_ConfigEntry_t;</span>
<span class="s1">const char *rd_kafka_ConfigEntry_name(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">const char *rd_kafka_ConfigEntry_value(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">rd_kafka_ConfigSource_t rd_kafka_ConfigEntry_source(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_read_only(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_default(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_sensitive(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_synonym(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">const rd_kafka_ConfigEntry_t **rd_kafka_ConfigEntry_synonyms(const rd_kafka_ConfigEntry_t *entry, size_t *cntp);</span>
<span class="s1">typedef enum rd_kafka_ResourceType_t {</span>
<span class="s1">  RD_KAFKA_RESOURCE_UNKNOWN = 0,</span>
<span class="s1">  RD_KAFKA_RESOURCE_ANY = 1,</span>
<span class="s1">  RD_KAFKA_RESOURCE_TOPIC = 2,</span>
<span class="s1">  RD_KAFKA_RESOURCE_GROUP = 3,</span>
<span class="s1">  RD_KAFKA_RESOURCE_BROKER = 4,</span>
<span class="s1">  RD_KAFKA_RESOURCE__CNT,</span>
<span class="s1">} rd_kafka_ResourceType_t;</span>
<span class="s1">typedef enum rd_kafka_ResourcePatternType_t {</span>
<span class="s1">  RD_KAFKA_RESOURCE_PATTERN_UNKNOWN = 0,</span>
<span class="s1">  RD_KAFKA_RESOURCE_PATTERN_ANY = 1,</span>
<span class="s1">  RD_KAFKA_RESOURCE_PATTERN_MATCH = 2,</span>
<span class="s1">  RD_KAFKA_RESOURCE_PATTERN_LITERAL = 3,</span>
<span class="s1">  RD_KAFKA_RESOURCE_PATTERN_PREFIXED = 4,</span>
<span class="s1">  RD_KAFKA_RESOURCE_PATTERN_TYPE__CNT,</span>
<span class="s1">} rd_kafka_ResourcePatternType_t;</span>
<span class="s1">const char *rd_kafka_ResourcePatternType_name(rd_kafka_ResourcePatternType_t resource_pattern_type);</span>
<span class="s1">const char *rd_kafka_ResourceType_name(rd_kafka_ResourceType_t restype);</span>
<span class="s1">typedef struct rd_kafka_ConfigResource_s rd_kafka_ConfigResource_t;</span>
<span class="s1">rd_kafka_ConfigResource_t *rd_kafka_ConfigResource_new(rd_kafka_ResourceType_t restype, const char *resname);</span>
<span class="s1">void rd_kafka_ConfigResource_destroy(rd_kafka_ConfigResource_t *config);</span>
<span class="s1">void rd_kafka_ConfigResource_destroy_array(rd_kafka_ConfigResource_t **config, size_t config_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_ConfigResource_set_config(rd_kafka_ConfigResource_t *config, const char *name, const char *value);</span>
<span class="s1">const rd_kafka_ConfigEntry_t **rd_kafka_ConfigResource_configs(const rd_kafka_ConfigResource_t *config, size_t *cntp);</span>
<span class="s1">rd_kafka_ResourceType_t rd_kafka_ConfigResource_type(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">const char *rd_kafka_ConfigResource_name(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_ConfigResource_error(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">const char *rd_kafka_ConfigResource_error_string(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">void rd_kafka_AlterConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_ConfigResource_t **rd_kafka_AlterConfigs_result_resources(const rd_kafka_AlterConfigs_result_t *result, size_t *cntp);</span>
<span class="s1">void rd_kafka_DescribeConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_ConfigResource_t **rd_kafka_DescribeConfigs_result_resources(const rd_kafka_DescribeConfigs_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_DeleteRecords_s rd_kafka_DeleteRecords_t;</span>
<span class="s1">rd_kafka_DeleteRecords_t *rd_kafka_DeleteRecords_new(const rd_kafka_topic_partition_list_t *before_offsets);</span>
<span class="s1">void rd_kafka_DeleteRecords_destroy(rd_kafka_DeleteRecords_t *del_records);</span>
<span class="s1">void rd_kafka_DeleteRecords_destroy_array(rd_kafka_DeleteRecords_t **del_records, size_t del_record_cnt);</span>
<span class="s1">void rd_kafka_DeleteRecords(rd_kafka_t *rk, rd_kafka_DeleteRecords_t **del_records, size_t del_record_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_partition_list_t *rd_kafka_DeleteRecords_result_offsets(const rd_kafka_DeleteRecords_result_t *result);</span>
<span class="s1">typedef struct rd_kafka_ConsumerGroupListing_s rd_kafka_ConsumerGroupListing_t;</span>
<span class="s1">typedef struct rd_kafka_ListConsumerGroupsResult_s rd_kafka_ListConsumerGroupsResult_t;</span>
<span class="s1">void rd_kafka_ListConsumerGroups(rd_kafka_t *rk, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const char *rd_kafka_ConsumerGroupListing_group_id(const rd_kafka_ConsumerGroupListing_t *grplist);</span>
<span class="s1">int rd_kafka_ConsumerGroupListing_is_simple_consumer_group(const rd_kafka_ConsumerGroupListing_t *grplist);</span>
<span class="s1">rd_kafka_consumer_group_state_t rd_kafka_ConsumerGroupListing_state(const rd_kafka_ConsumerGroupListing_t *grplist);</span>
<span class="s1">const rd_kafka_ConsumerGroupListing_t **rd_kafka_ListConsumerGroups_result_valid(const rd_kafka_ListConsumerGroups_result_t *result, size_t *cntp);</span>
<span class="s1">const rd_kafka_error_t **rd_kafka_ListConsumerGroups_result_errors(const rd_kafka_ListConsumerGroups_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_ConsumerGroupDescription_s rd_kafka_ConsumerGroupDescription_t;</span>
<span class="s1">typedef struct rd_kafka_MemberDescription_s rd_kafka_MemberDescription_t;</span>
<span class="s1">typedef struct rd_kafka_MemberAssignment_s rd_kafka_MemberAssignment_t;</span>
<span class="s1">void rd_kafka_DescribeConsumerGroups(rd_kafka_t *rk, const char **groups, size_t groups_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_ConsumerGroupDescription_t **rd_kafka_DescribeConsumerGroups_result_groups(const rd_kafka_DescribeConsumerGroups_result_t *result, size_t *cntp);</span>
<span class="s1">const char *rd_kafka_ConsumerGroupDescription_group_id(const rd_kafka_ConsumerGroupDescription_t *grpdesc);</span>
<span class="s1">const rd_kafka_error_t *rd_kafka_ConsumerGroupDescription_error(const rd_kafka_ConsumerGroupDescription_t *grpdesc);</span>
<span class="s1">int rd_kafka_ConsumerGroupDescription_is_simple_consumer_group(const rd_kafka_ConsumerGroupDescription_t *grpdesc);</span>
<span class="s1">const char *rd_kafka_ConsumerGroupDescription_partition_assignor(const rd_kafka_ConsumerGroupDescription_t *grpdesc);</span>
<span class="s1">rd_kafka_consumer_group_state_t rd_kafka_ConsumerGroupDescription_state(const rd_kafka_ConsumerGroupDescription_t *grpdesc);</span>
<span class="s1">const rd_kafka_Node_t *rd_kafka_ConsumerGroupDescription_coordinator(const rd_kafka_ConsumerGroupDescription_t *grpdesc);</span>
<span class="s1">size_t rd_kafka_ConsumerGroupDescription_member_count(const rd_kafka_ConsumerGroupDescription_t *grpdesc);</span>
<span class="s1">const rd_kafka_MemberDescription_t *rd_kafka_ConsumerGroupDescription_member(const rd_kafka_ConsumerGroupDescription_t *grpdesc, size_t idx);</span>
<span class="s1">const char *rd_kafka_MemberDescription_client_id(const rd_kafka_MemberDescription_t *member);</span>
<span class="s1">const char *rd_kafka_MemberDescription_group_instance_id(const rd_kafka_MemberDescription_t *member);</span>
<span class="s1">const char *rd_kafka_MemberDescription_consumer_id(const rd_kafka_MemberDescription_t *member);</span>
<span class="s1">const char *rd_kafka_MemberDescription_host(const rd_kafka_MemberDescription_t *member);</span>
<span class="s1">const rd_kafka_MemberAssignment_t *rd_kafka_MemberDescription_assignment(const rd_kafka_MemberDescription_t *member);</span>
<span class="s1">const rd_kafka_topic_partition_list_t *rd_kafka_MemberAssignment_partitions(const rd_kafka_MemberAssignment_t *assignment);</span>
<span class="s1">typedef struct rd_kafka_DeleteGroup_s rd_kafka_DeleteGroup_t;</span>
<span class="s1">rd_kafka_DeleteGroup_t *rd_kafka_DeleteGroup_new(const char *group);</span>
<span class="s1">void rd_kafka_DeleteGroup_destroy(rd_kafka_DeleteGroup_t *del_group);</span>
<span class="s1">void rd_kafka_DeleteGroup_destroy_array(rd_kafka_DeleteGroup_t **del_groups, size_t del_group_cnt);</span>
<span class="s1">void rd_kafka_DeleteGroups(rd_kafka_t *rk, rd_kafka_DeleteGroup_t **del_groups, size_t del_group_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_group_result_t **rd_kafka_DeleteGroups_result_groups(const rd_kafka_DeleteGroups_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_ListConsumerGroupOffsets_s rd_kafka_ListConsumerGroupOffsets_t;</span>
<span class="s1">rd_kafka_ListConsumerGroupOffsets_t *rd_kafka_ListConsumerGroupOffsets_new(const char *group_id, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">void rd_kafka_ListConsumerGroupOffsets_destroy(rd_kafka_ListConsumerGroupOffsets_t *list_grpoffsets);</span>
<span class="s1">void rd_kafka_ListConsumerGroupOffsets_destroy_array(rd_kafka_ListConsumerGroupOffsets_t **list_grpoffsets, size_t list_grpoffset_cnt);</span>
<span class="s1">void rd_kafka_ListConsumerGroupOffsets(rd_kafka_t *rk, rd_kafka_ListConsumerGroupOffsets_t **list_grpoffsets, size_t list_grpoffsets_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_group_result_t **rd_kafka_ListConsumerGroupOffsets_result_groups(const rd_kafka_ListConsumerGroupOffsets_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_AlterConsumerGroupOffsets_s rd_kafka_AlterConsumerGroupOffsets_t;</span>
<span class="s1">rd_kafka_AlterConsumerGroupOffsets_t *rd_kafka_AlterConsumerGroupOffsets_new(const char *group_id, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">void rd_kafka_AlterConsumerGroupOffsets_destroy(rd_kafka_AlterConsumerGroupOffsets_t *alter_grpoffsets);</span>
<span class="s1">void rd_kafka_AlterConsumerGroupOffsets_destroy_array(rd_kafka_AlterConsumerGroupOffsets_t **alter_grpoffsets, size_t alter_grpoffset_cnt);</span>
<span class="s1">void rd_kafka_AlterConsumerGroupOffsets(rd_kafka_t *rk, rd_kafka_AlterConsumerGroupOffsets_t **alter_grpoffsets, size_t alter_grpoffsets_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_group_result_t **rd_kafka_AlterConsumerGroupOffsets_result_groups(const rd_kafka_AlterConsumerGroupOffsets_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_DeleteConsumerGroupOffsets_s rd_kafka_DeleteConsumerGroupOffsets_t;</span>
<span class="s1">rd_kafka_DeleteConsumerGroupOffsets_t *rd_kafka_DeleteConsumerGroupOffsets_new(const char *group, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">void rd_kafka_DeleteConsumerGroupOffsets_destroy(rd_kafka_DeleteConsumerGroupOffsets_t *del_grpoffsets);</span>
<span class="s1">void rd_kafka_DeleteConsumerGroupOffsets_destroy_array(rd_kafka_DeleteConsumerGroupOffsets_t **del_grpoffsets, size_t del_grpoffset_cnt);</span>
<span class="s1">void rd_kafka_DeleteConsumerGroupOffsets(rd_kafka_t *rk, rd_kafka_DeleteConsumerGroupOffsets_t **del_grpoffsets, size_t del_grpoffsets_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_group_result_t **rd_kafka_DeleteConsumerGroupOffsets_result_groups(const rd_kafka_DeleteConsumerGroupOffsets_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_AclBinding_s rd_kafka_AclBinding_t;</span>
<span class="s1">typedef rd_kafka_AclBinding_t rd_kafka_AclBindingFilter_t;</span>
<span class="s1">const rd_kafka_error_t *rd_kafka_acl_result_error(const rd_kafka_acl_result_t *aclres);</span>
<span class="s1">typedef enum rd_kafka_AclOperation_t {</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_UNKNOWN = 0,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_ANY = 1,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_ALL = 2,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_READ = 3,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_WRITE = 4,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_CREATE = 5,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_DELETE = 6,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_ALTER = 7,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_DESCRIBE = 8,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_CLUSTER_ACTION = 9,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_DESCRIBE_CONFIGS = 10,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_ALTER_CONFIGS = 11,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_IDEMPOTENT_WRITE = 12,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION__CNT,</span>
<span class="s1">} rd_kafka_AclOperation_t;</span>
<span class="s1">const char *rd_kafka_AclOperation_name(rd_kafka_AclOperation_t acl_operation);</span>
<span class="s1">typedef enum rd_kafka_AclPermissionType_t {</span>
<span class="s1">  RD_KAFKA_ACL_PERMISSION_TYPE_UNKNOWN = 0,</span>
<span class="s1">  RD_KAFKA_ACL_PERMISSION_TYPE_ANY = 1,</span>
<span class="s1">  RD_KAFKA_ACL_PERMISSION_TYPE_DENY = 2,</span>
<span class="s1">  RD_KAFKA_ACL_PERMISSION_TYPE_ALLOW = 3,</span>
<span class="s1">  RD_KAFKA_ACL_PERMISSION_TYPE__CNT,</span>
<span class="s1">} rd_kafka_AclPermissionType_t;</span>
<span class="s1">const char *rd_kafka_AclPermissionType_name(rd_kafka_AclPermissionType_t acl_permission_type);</span>
<span class="s1">rd_kafka_AclBinding_t *rd_kafka_AclBinding_new(rd_kafka_ResourceType_t restype, const char *name, rd_kafka_ResourcePatternType_t resource_pattern_type, const char *principal, const char *host, rd_kafka_AclOperation_t operation, rd_kafka_AclPermissionType_t permission_type, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_AclBindingFilter_t *rd_kafka_AclBindingFilter_new(rd_kafka_ResourceType_t restype, const char *name, rd_kafka_ResourcePatternType_t resource_pattern_type, const char *principal, const char *host, rd_kafka_AclOperation_t operation, rd_kafka_AclPermissionType_t permission_type, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_ResourceType_t rd_kafka_AclBinding_restype(const rd_kafka_AclBinding_t *acl);</span>
<span class="s1">const char *rd_kafka_AclBinding_name(const rd_kafka_AclBinding_t *acl);</span>
<span class="s1">const char *rd_kafka_AclBinding_principal(const rd_kafka_AclBinding_t *acl);</span>
<span class="s1">const char *rd_kafka_AclBinding_host(const rd_kafka_AclBinding_t *acl);</span>
<span class="s1">rd_kafka_AclOperation_t rd_kafka_AclBinding_operation(const rd_kafka_AclBinding_t *acl);</span>
<span class="s1">rd_kafka_AclPermissionType_t rd_kafka_AclBinding_permission_type(const rd_kafka_AclBinding_t *acl);</span>
<span class="s1">rd_kafka_ResourcePatternType_t rd_kafka_AclBinding_resource_pattern_type(const rd_kafka_AclBinding_t *acl);</span>
<span class="s1">const rd_kafka_error_t *rd_kafka_AclBinding_error(const rd_kafka_AclBinding_t *acl);</span>
<span class="s1">void rd_kafka_AclBinding_destroy(rd_kafka_AclBinding_t *acl_binding);</span>
<span class="s1">void rd_kafka_AclBinding_destroy_array(rd_kafka_AclBinding_t **acl_bindings, size_t acl_bindings_cnt);</span>
<span class="s1">const rd_kafka_acl_result_t **rd_kafka_CreateAcls_result_acls(const rd_kafka_CreateAcls_result_t *result, size_t *cntp);</span>
<span class="s1">void rd_kafka_CreateAcls(rd_kafka_t *rk, rd_kafka_AclBinding_t **new_acls, size_t new_acls_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_AclBinding_t **rd_kafka_DescribeAcls_result_acls(const rd_kafka_DescribeAcls_result_t *result, size_t *cntp);</span>
<span class="s1">void rd_kafka_DescribeAcls(rd_kafka_t *rk, rd_kafka_AclBindingFilter_t *acl_filter, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">typedef struct rd_kafka_DeleteAcls_result_response_s rd_kafka_DeleteAcls_result_response_t;</span>
<span class="s1">const rd_kafka_DeleteAcls_result_response_t **rd_kafka_DeleteAcls_result_responses(const rd_kafka_DeleteAcls_result_t *result, size_t *cntp);</span>
<span class="s1">const rd_kafka_error_t *rd_kafka_DeleteAcls_result_response_error(const rd_kafka_DeleteAcls_result_response_t *result_response);</span>
<span class="s1">const rd_kafka_AclBinding_t **rd_kafka_DeleteAcls_result_response_matching_acls(const rd_kafka_DeleteAcls_result_response_t *result_response, size_t *matching_acls_cntp);</span>
<span class="s1">void rd_kafka_DeleteAcls(rd_kafka_t *rk, rd_kafka_AclBindingFilter_t **del_acls, size_t del_acls_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token(rd_kafka_t *rk, const char *token_value, int64_t md_lifetime_ms, const char *md_principal_name, const char **extensions, size_t extension_size, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token_failure(rd_kafka_t *rk, const char *errstr);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_init_transactions(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_begin_transaction(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_send_offsets_to_transaction(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, const rd_kafka_consumer_group_metadata_t *cgmetadata, int timeout_ms);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_commit_transaction(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_abort_transaction(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">typedef struct rd_kafka_mock_cluster_s rd_kafka_mock_cluster_t;</span>
<span class="s1">rd_kafka_mock_cluster_t *rd_kafka_mock_cluster_new(rd_kafka_t *rk, int broker_cnt);</span>
<span class="s1">void rd_kafka_mock_cluster_destroy(rd_kafka_mock_cluster_t *mcluster);</span>
<span class="s1">rd_kafka_t *rd_kafka_mock_cluster_handle(const rd_kafka_mock_cluster_t *mcluster);</span>
<span class="s1">rd_kafka_mock_cluster_t *rd_kafka_handle_mock_cluster(const rd_kafka_t *rk);</span>
<span class="s1">const char *rd_kafka_mock_cluster_bootstraps(const rd_kafka_mock_cluster_t *mcluster);</span>
<span class="s1">void rd_kafka_mock_clear_request_errors(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey);</span>
<span class="s1">void rd_kafka_mock_push_request_errors(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, size_t cnt, ...);</span>
<span class="s1">void rd_kafka_mock_push_request_errors_array(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, size_t cnt, const rd_kafka_resp_err_t *errors);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_push_request_error_rtts(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int16_t ApiKey, size_t cnt, ...);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_error_stack_cnt(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int16_t ApiKey, size_t *cntp);</span>
<span class="s1">void rd_kafka_mock_topic_set_error(rd_kafka_mock_cluster_t *mcluster, const char *topic, rd_kafka_resp_err_t err);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_topic_create(rd_kafka_mock_cluster_t *mcluster, const char *topic, int partition_cnt, int replication_factor);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_partition_set_leader(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_partition_set_follower(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_partition_set_follower_wmarks(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int64_t lo, int64_t hi);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_set_down(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_set_up(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_set_rtt(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int rtt_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_set_rack(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, const char *rack);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_coordinator_set(rd_kafka_mock_cluster_t *mcluster, const char *key_type, const char *key, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_set_apiversion(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, int16_t MinVersion, int16_t MaxVersion);</span>
<span class="s1">&#39;</span>
</code></pre></div>
rdkafka.h, rdkafka_mock.h</p>
<h3 id="rd_kafka_version_26">RD_KAFKA_VERSION<a class="headerlink" href="#rd_kafka_version_26" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_VERSION</span> <span class="o">=</span> <span class="mi">33620479</span>
</code></pre></div>
<p>librdkafka version </p>
<p>Interpreted as hex <code>MM.mm.rr.xx</code>:</p>
<ul>
<li>MM = Major</li>
<li>mm = minor</li>
<li>rr = revision</li>
<li>xx = pre-release id (0xff is the final release)</li>
</ul>
<p>E.g.: <code>0x000801ff</code> = 0.8.1</p>
<dl class="section remark"><dt>Remarks</dt><dd>This value should only be used during compile time, for runtime checks of version use rd_kafka_version() </dd></dl>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_unsupported_compression_type_26">RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE<a class="headerlink" href="#rd_kafka_resp_err_unsupported_compression_type_26" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE</span> <span class="o">=</span> <span class="mi">76</span>
</code></pre></div>
<p>Unsupported compression type </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_end_all_26">RD_KAFKA_RESP_ERR_END_ALL<a class="headerlink" href="#rd_kafka_resp_err_end_all_26" title="Permanent link">&para;</a></h3>
<p><div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_END_ALL</span> <span class="o">=</span> <span class="mi">98</span>
</code></pre></div>
enum rd_kafka_resp_err_t</p>
<h3 id="rd_kafka_admin_op__cnt_26">RD_KAFKA_ADMIN_OP__CNT<a class="headerlink" href="#rd_kafka_admin_op__cnt_26" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_ADMIN_OP__CNT</span> <span class="o">=</span> <span class="mi">16</span>
</code></pre></div>
<p>Number of ops defined </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe </a></li>
</ul>
</div>
<h3 id="rd_kafka_resource__cnt_26">RD_KAFKA_RESOURCE__CNT<a class="headerlink" href="#rd_kafka_resource__cnt_26" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESOURCE__CNT</span> <span class="o">=</span> <span class="mi">5</span>
</code></pre></div>
<p>Number of resource types defined </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#acca83a66d7783ff7683ed2691cc907c9"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#acca83a66d7783ff7683ed2691cc907c9 </a></li>
</ul>
</div>
<h3 id="rd_kafka_cdef_26">RD_KAFKA_CDEF<a class="headerlink" href="#rd_kafka_cdef_26" title="Permanent link">&para;</a></h3>
<p><div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_CDEF</span> <span class="o">=</span> <span class="s1">&#39;typedef long int ssize_t;</span>
<span class="s1">typedef struct _IO_FILE FILE;</span>
<span class="s1">typedef long int mode_t;</span>
<span class="s1">typedef signed int int16_t;</span>
<span class="s1">typedef unsigned int uint16_t;</span>
<span class="s1">typedef signed int int32_t;</span>
<span class="s1">typedef signed long int int64_t;</span>
<span class="s1">int rd_kafka_version(void);</span>
<span class="s1">const char *rd_kafka_version_str(void);</span>
<span class="s1">typedef enum rd_kafka_type_t {</span>
<span class="s1">  RD_KAFKA_PRODUCER,</span>
<span class="s1">  RD_KAFKA_CONSUMER,</span>
<span class="s1">} rd_kafka_type_t;</span>
<span class="s1">typedef enum rd_kafka_timestamp_type_t {</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_NOT_AVAILABLE,</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_CREATE_TIME,</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_LOG_APPEND_TIME,</span>
<span class="s1">} rd_kafka_timestamp_type_t;</span>
<span class="s1">const char *rd_kafka_get_debug_contexts(void);</span>
<span class="s1">typedef struct rd_kafka_s rd_kafka_t;</span>
<span class="s1">typedef struct rd_kafka_topic_s rd_kafka_topic_t;</span>
<span class="s1">typedef struct rd_kafka_conf_s rd_kafka_conf_t;</span>
<span class="s1">typedef struct rd_kafka_topic_conf_s rd_kafka_topic_conf_t;</span>
<span class="s1">typedef struct rd_kafka_queue_s rd_kafka_queue_t;</span>
<span class="s1">typedef struct rd_kafka_op_s rd_kafka_event_t;</span>
<span class="s1">typedef struct rd_kafka_topic_result_s rd_kafka_topic_result_t;</span>
<span class="s1">typedef struct rd_kafka_consumer_group_metadata_s rd_kafka_consumer_group_metadata_t;</span>
<span class="s1">typedef struct rd_kafka_error_s {</span>
<span class="s1">  unsigned int code;</span>
<span class="s1">  char *errstr;</span>
<span class="s1">  unsigned char fatal;</span>
<span class="s1">  unsigned char retriable;</span>
<span class="s1">  unsigned char txn_requires_abort;</span>
<span class="s1">} rd_kafka_error_t;</span>
<span class="s1">typedef struct rd_kafka_headers_s rd_kafka_headers_t;</span>
<span class="s1">typedef struct rd_kafka_group_result_s rd_kafka_group_result_t;</span>
<span class="s1">typedef struct rd_kafka_acl_result_s rd_kafka_acl_result_t;</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BEGIN = (- 200),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BAD_MSG = (- 199),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BAD_COMPRESSION = (- 198),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__DESTROY = (- 197),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FAIL = (- 196),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TRANSPORT = (- 195),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__CRIT_SYS_RESOURCE = (- 194),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__RESOLVE = (- 193),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__MSG_TIMED_OUT = (- 192),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PARTITION_EOF = (- 191),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION = (- 190),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FS = (- 189),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC = (- 188),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ALL_BROKERS_DOWN = (- 187),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INVALID_ARG = (- 186),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TIMED_OUT = (- 185),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__QUEUE_FULL = (- 184),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ISR_INSUFF = (- 183),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NODE_UPDATE = (- 182),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__SSL = (- 181),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__WAIT_COORD = (- 180),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_GROUP = (- 179),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__IN_PROGRESS = (- 178),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PREV_IN_PROGRESS = (- 177),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__EXISTING_SUBSCRIPTION = (- 176),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS = (- 175),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS = (- 174),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__CONFLICT = (- 173),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__STATE = (- 172),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_PROTOCOL = (- 171),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED = (- 170),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__AUTHENTICATION = (- 169),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NO_OFFSET = (- 168),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__OUTDATED = (- 167),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TIMED_OUT_QUEUE = (- 166),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNSUPPORTED_FEATURE = (- 165),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__WAIT_CACHE = (- 164),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INTR = (- 163),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__KEY_SERIALIZATION = (- 162),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__VALUE_SERIALIZATION = (- 161),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__KEY_DESERIALIZATION = (- 160),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__VALUE_DESERIALIZATION = (- 159),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PARTIAL = (- 158),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__READ_ONLY = (- 157),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOENT = (- 156),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNDERFLOW = (- 155),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INVALID_TYPE = (- 154),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__RETRY = (- 153),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PURGE_QUEUE = (- 152),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PURGE_INFLIGHT = (- 151),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FATAL = (- 150),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INCONSISTENT = (- 149),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__GAPLESS_GUARANTEE = (- 148),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__MAX_POLL_EXCEEDED = (- 147),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_BROKER = (- 146),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOT_CONFIGURED = (- 145),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FENCED = (- 144),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__APPLICATION = (- 143),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ASSIGNMENT_LOST = (- 142),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOOP = (- 141),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__AUTO_OFFSET_RESET = (- 140),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__LOG_TRUNCATION = (- 139),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__END = (- 100),</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN = (- 1),</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NO_ERROR = 0,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_OUT_OF_RANGE = 1,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_MSG = 2,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART = 3,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_MSG_SIZE = 4,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE = 5,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_LEADER_FOR_PARTITION = 6,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REQUEST_TIMED_OUT = 7,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_BROKER_NOT_AVAILABLE = 8,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REPLICA_NOT_AVAILABLE = 9,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE = 10,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_STALE_CTRL_EPOCH = 11,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_METADATA_TOO_LARGE = 12,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NETWORK_EXCEPTION = 13,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_COORDINATOR_LOAD_IN_PROGRESS = 14,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_COORDINATOR_NOT_AVAILABLE = 15,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_COORDINATOR = 16,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_EXCEPTION = 17,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_RECORD_LIST_TOO_LARGE = 18,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS = 19,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS_AFTER_APPEND = 20,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REQUIRED_ACKS = 21,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ILLEGAL_GENERATION = 22,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INCONSISTENT_GROUP_PROTOCOL = 23,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_GROUP_ID = 24,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_MEMBER_ID = 25,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_SESSION_TIMEOUT = 26,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REBALANCE_IN_PROGRESS = 27,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_COMMIT_OFFSET_SIZE = 28,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_AUTHORIZATION_FAILED = 29,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_AUTHORIZATION_FAILED = 30,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_CLUSTER_AUTHORIZATION_FAILED = 31,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TIMESTAMP = 32,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_SASL_MECHANISM = 33,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ILLEGAL_SASL_STATE = 34,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_VERSION = 35,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_ALREADY_EXISTS = 36,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PARTITIONS = 37,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REPLICATION_FACTOR = 38,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REPLICA_ASSIGNMENT = 39,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_CONFIG = 40,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_CONTROLLER = 41,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REQUEST = 42,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_FOR_MESSAGE_FORMAT = 43,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_POLICY_VIOLATION = 44,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OUT_OF_ORDER_SEQUENCE_NUMBER = 45,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DUPLICATE_SEQUENCE_NUMBER = 46,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_EPOCH = 47,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TXN_STATE = 48,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_ID_MAPPING = 49,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TRANSACTION_TIMEOUT = 50,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_CONCURRENT_TRANSACTIONS = 51,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TRANSACTION_COORDINATOR_FENCED = 52,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TRANSACTIONAL_ID_AUTHORIZATION_FAILED = 53,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_SECURITY_DISABLED = 54,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OPERATION_NOT_ATTEMPTED = 55,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_KAFKA_STORAGE_ERROR = 56,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LOG_DIR_NOT_FOUND = 57,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_SASL_AUTHENTICATION_FAILED = 58,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_PRODUCER_ID = 59,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REASSIGNMENT_IN_PROGRESS = 60,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTH_DISABLED = 61,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_NOT_FOUND = 62,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_OWNER_MISMATCH = 63,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_REQUEST_NOT_ALLOWED = 64,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTHORIZATION_FAILED = 65,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_EXPIRED = 66,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRINCIPAL_TYPE = 67,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NON_EMPTY_GROUP = 68,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_ID_NOT_FOUND = 69,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FETCH_SESSION_ID_NOT_FOUND = 70,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_FETCH_SESSION_EPOCH = 71,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LISTENER_NOT_FOUND = 72,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_DELETION_DISABLED = 73,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FENCED_LEADER_EPOCH = 74,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_LEADER_EPOCH = 75,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_STALE_BROKER_EPOCH = 77,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_NOT_AVAILABLE = 78,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_MEMBER_ID_REQUIRED = 79,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_PREFERRED_LEADER_NOT_AVAILABLE = 80,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_MAX_SIZE_REACHED = 81,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FENCED_INSTANCE_ID = 82,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ELIGIBLE_LEADERS_NOT_AVAILABLE = 83,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ELECTION_NOT_NEEDED = 84,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NO_REASSIGNMENT_IN_PROGRESS = 85,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_SUBSCRIBED_TO_TOPIC = 86,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_RECORD = 87,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSTABLE_OFFSET_COMMIT = 88,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_THROTTLING_QUOTA_EXCEEDED = 89,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_PRODUCER_FENCED = 90,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_RESOURCE_NOT_FOUND = 91,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DUPLICATE_RESOURCE = 92,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNACCEPTABLE_CREDENTIAL = 93,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INCONSISTENT_VOTER_SET = 94,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_UPDATE_VERSION = 95,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FEATURE_UPDATE_FAILED = 96,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_PRINCIPAL_DESERIALIZATION_FAILURE = 97,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_END_ALL,</span>
<span class="s1">} rd_kafka_resp_err_t;</span>
<span class="s1">struct rd_kafka_err_desc {</span>
<span class="s1">  rd_kafka_resp_err_t code;</span>
<span class="s1">  char *name;</span>
<span class="s1">  char *desc;</span>
<span class="s1">};</span>
<span class="s1">void rd_kafka_get_err_descs(const struct rd_kafka_err_desc **errdescs, size_t *cntp);</span>
<span class="s1">const char *rd_kafka_err2str(rd_kafka_resp_err_t err);</span>
<span class="s1">const char *rd_kafka_err2name(rd_kafka_resp_err_t err);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_last_error(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_errno2err(int errnox);</span>
<span class="s1">int rd_kafka_errno(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_fatal_error(rd_kafka_t *rk, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_test_fatal_error(rd_kafka_t *rk, rd_kafka_resp_err_t err, const char *reason);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_error_code(const rd_kafka_error_t *error);</span>
<span class="s1">const char *rd_kafka_error_name(const rd_kafka_error_t *error);</span>
<span class="s1">const char *rd_kafka_error_string(const rd_kafka_error_t *error);</span>
<span class="s1">int rd_kafka_error_is_fatal(const rd_kafka_error_t *error);</span>
<span class="s1">int rd_kafka_error_is_retriable(const rd_kafka_error_t *error);</span>
<span class="s1">int rd_kafka_error_txn_requires_abort(const rd_kafka_error_t *error);</span>
<span class="s1">void rd_kafka_error_destroy(rd_kafka_error_t *error);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_error_new(rd_kafka_resp_err_t code, const char *fmt, ...);</span>
<span class="s1">typedef struct rd_kafka_topic_partition_s {</span>
<span class="s1">  char *topic;</span>
<span class="s1">  int32_t partition;</span>
<span class="s1">  int64_t offset;</span>
<span class="s1">  void *metadata;</span>
<span class="s1">  size_t metadata_size;</span>
<span class="s1">  void *opaque;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  void *_private;</span>
<span class="s1">} rd_kafka_topic_partition_t;</span>
<span class="s1">void rd_kafka_topic_partition_destroy(rd_kafka_topic_partition_t *rktpar);</span>
<span class="s1">void rd_kafka_topic_partition_set_leader_epoch(rd_kafka_topic_partition_t *rktpar, int32_t leader_epoch);</span>
<span class="s1">int32_t rd_kafka_topic_partition_get_leader_epoch(const rd_kafka_topic_partition_t *rktpar);</span>
<span class="s1">typedef struct rd_kafka_topic_partition_list_s {</span>
<span class="s1">  int cnt;</span>
<span class="s1">  int size;</span>
<span class="s1">  rd_kafka_topic_partition_t *elems;</span>
<span class="s1">} rd_kafka_topic_partition_list_t;</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_new(int size);</span>
<span class="s1">void rd_kafka_topic_partition_list_destroy(rd_kafka_topic_partition_list_t *rkparlist);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_add(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">void rd_kafka_topic_partition_list_add_range(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t start, int32_t stop);</span>
<span class="s1">int rd_kafka_topic_partition_list_del(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">int rd_kafka_topic_partition_list_del_by_idx(rd_kafka_topic_partition_list_t *rktparlist, int idx);</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_copy(const rd_kafka_topic_partition_list_t *src);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_topic_partition_list_set_offset(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition, int64_t offset);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_find(const rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">void rd_kafka_topic_partition_list_sort(rd_kafka_topic_partition_list_t *rktparlist, int (*cmp)(const void *a, const void *b, void *cmp_opaque), void *cmp_opaque);</span>
<span class="s1">typedef enum rd_kafka_vtype_t {</span>
<span class="s1">  RD_KAFKA_VTYPE_END,</span>
<span class="s1">  RD_KAFKA_VTYPE_TOPIC,</span>
<span class="s1">  RD_KAFKA_VTYPE_RKT,</span>
<span class="s1">  RD_KAFKA_VTYPE_PARTITION,</span>
<span class="s1">  RD_KAFKA_VTYPE_VALUE,</span>
<span class="s1">  RD_KAFKA_VTYPE_KEY,</span>
<span class="s1">  RD_KAFKA_VTYPE_OPAQUE,</span>
<span class="s1">  RD_KAFKA_VTYPE_MSGFLAGS,</span>
<span class="s1">  RD_KAFKA_VTYPE_TIMESTAMP,</span>
<span class="s1">  RD_KAFKA_VTYPE_HEADER,</span>
<span class="s1">  RD_KAFKA_VTYPE_HEADERS,</span>
<span class="s1">} rd_kafka_vtype_t;</span>
<span class="s1">typedef struct rd_kafka_vu_s {</span>
<span class="s1">  rd_kafka_vtype_t vtype;</span>
<span class="s1">  union {</span>
<span class="s1">    char *cstr;</span>
<span class="s1">    rd_kafka_topic_t *rkt;</span>
<span class="s1">    int i;</span>
<span class="s1">    int32_t i32;</span>
<span class="s1">    int64_t i64;</span>
<span class="s1">    struct {</span>
<span class="s1">      void *ptr;</span>
<span class="s1">      size_t size;</span>
<span class="s1">    } mem;</span>
<span class="s1">    struct {</span>
<span class="s1">      char *name;</span>
<span class="s1">      void *val;</span>
<span class="s1">      ssize_t size;</span>
<span class="s1">    } header;</span>
<span class="s1">    rd_kafka_headers_t *headers;</span>
<span class="s1">    void *ptr;</span>
<span class="s1">    char _pad[64];</span>
<span class="s1">  } u;</span>
<span class="s1">} rd_kafka_vu_t;</span>
<span class="s1">rd_kafka_headers_t *rd_kafka_headers_new(size_t initial_count);</span>
<span class="s1">void rd_kafka_headers_destroy(rd_kafka_headers_t *hdrs);</span>
<span class="s1">rd_kafka_headers_t *rd_kafka_headers_copy(const rd_kafka_headers_t *src);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_add(rd_kafka_headers_t *hdrs, const char *name, ssize_t name_size, const void *value, ssize_t value_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_remove(rd_kafka_headers_t *hdrs, const char *name);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get_last(const rd_kafka_headers_t *hdrs, const char *name, const void **valuep, size_t *sizep);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get(const rd_kafka_headers_t *hdrs, size_t idx, const char *name, const void **valuep, size_t *sizep);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get_all(const rd_kafka_headers_t *hdrs, size_t idx, const char **namep, const void **valuep, size_t *sizep);</span>
<span class="s1">typedef struct rd_kafka_message_s {</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  rd_kafka_topic_t *rkt;</span>
<span class="s1">  int32_t partition;</span>
<span class="s1">  void *payload;</span>
<span class="s1">  size_t len;</span>
<span class="s1">  void *key;</span>
<span class="s1">  size_t key_len;</span>
<span class="s1">  int64_t offset;</span>
<span class="s1">  void *_private;</span>
<span class="s1">} rd_kafka_message_t;</span>
<span class="s1">void rd_kafka_message_destroy(rd_kafka_message_t *rkmessage);</span>
<span class="s1">const char *rd_kafka_message_errstr(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">int64_t rd_kafka_message_timestamp(const rd_kafka_message_t *rkmessage, rd_kafka_timestamp_type_t *tstype);</span>
<span class="s1">int64_t rd_kafka_message_latency(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">int32_t rd_kafka_message_broker_id(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_message_headers(const rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_message_detach_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);</span>
<span class="s1">void rd_kafka_message_set_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t *hdrs);</span>
<span class="s1">size_t rd_kafka_header_cnt(const rd_kafka_headers_t *hdrs);</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_NOT_PERSISTED = 0,</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_POSSIBLY_PERSISTED = 1,</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_PERSISTED = 2,</span>
<span class="s1">} rd_kafka_msg_status_t;</span>
<span class="s1">rd_kafka_msg_status_t rd_kafka_message_status(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">int32_t rd_kafka_message_leader_epoch(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_CONF_UNKNOWN = (- 2),</span>
<span class="s1">  RD_KAFKA_CONF_INVALID = (- 1),</span>
<span class="s1">  RD_KAFKA_CONF_OK = 0,</span>
<span class="s1">} rd_kafka_conf_res_t;</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_new(void);</span>
<span class="s1">void rd_kafka_conf_destroy(rd_kafka_conf_t *conf);</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_dup(const rd_kafka_conf_t *conf);</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_dup_filter(const rd_kafka_conf_t *conf, size_t filter_cnt, const char **filter);</span>
<span class="s1">const rd_kafka_conf_t *rd_kafka_conf(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_set(rd_kafka_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_conf_set_events(rd_kafka_conf_t *conf, int events);</span>
<span class="s1">void rd_kafka_conf_set_background_event_cb(rd_kafka_conf_t *conf, void (*event_cb)(rd_kafka_t *rk, rd_kafka_event_t *rkev, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_dr_cb(rd_kafka_conf_t *conf, void (*dr_cb)(rd_kafka_t *rk, void *payload, size_t len, rd_kafka_resp_err_t err, void *opaque, void *msg_opaque));</span>
<span class="s1">void rd_kafka_conf_set_dr_msg_cb(rd_kafka_conf_t *conf, void (*dr_msg_cb)(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_consume_cb(rd_kafka_conf_t *conf, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_rebalance_cb(rd_kafka_conf_t *conf, void (*rebalance_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *partitions, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_offset_commit_cb(rd_kafka_conf_t *conf, void (*offset_commit_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_error_cb(rd_kafka_conf_t *conf, void (*error_cb)(rd_kafka_t *rk, int err, const char *reason, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_throttle_cb(rd_kafka_conf_t *conf, void (*throttle_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int throttle_time_ms, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_log_cb(rd_kafka_conf_t *conf, void (*log_cb)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));</span>
<span class="s1">void rd_kafka_conf_set_stats_cb(rd_kafka_conf_t *conf, int (*stats_cb)(rd_kafka_t *rk, char *json, size_t json_len, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_oauthbearer_token_refresh_cb(rd_kafka_conf_t *conf, void (*oauthbearer_token_refresh_cb)(rd_kafka_t *rk, const char *oauthbearer_config, void *opaque));</span>
<span class="s1">void rd_kafka_conf_enable_sasl_queue(rd_kafka_conf_t *conf, int enable);</span>
<span class="s1">void rd_kafka_conf_set_socket_cb(rd_kafka_conf_t *conf, int (*socket_cb)(int domain, int type, int protocol, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_connect_cb(rd_kafka_conf_t *conf, int (*connect_cb)(int sockfd, const struct sockaddr *addr, int addrlen, const char *id, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_closesocket_cb(rd_kafka_conf_t *conf, int (*closesocket_cb)(int sockfd, void *opaque));</span>
<span class="s1">struct addrinfo;</span>
<span class="s1">void rd_kafka_conf_set_resolve_cb(rd_kafka_conf_t *conf, int (*resolve_cb)(const char *node, const char *service, const struct addrinfo *hints, struct addrinfo **res, void *opaque));</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert_verify_cb(rd_kafka_conf_t *conf, int (*ssl_cert_verify_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int *x509_error, int depth, const char *buf, size_t size, char *errstr, size_t errstr_size, void *opaque));</span>
<span class="s1">typedef enum rd_kafka_cert_type_t {</span>
<span class="s1">  RD_KAFKA_CERT_PUBLIC_KEY,</span>
<span class="s1">  RD_KAFKA_CERT_PRIVATE_KEY,</span>
<span class="s1">  RD_KAFKA_CERT_CA,</span>
<span class="s1">  RD_KAFKA_CERT__CNT,</span>
<span class="s1">} rd_kafka_cert_type_t;</span>
<span class="s1">typedef enum rd_kafka_cert_enc_t {</span>
<span class="s1">  RD_KAFKA_CERT_ENC_PKCS12,</span>
<span class="s1">  RD_KAFKA_CERT_ENC_DER,</span>
<span class="s1">  RD_KAFKA_CERT_ENC_PEM,</span>
<span class="s1">  RD_KAFKA_CERT_ENC__CNT,</span>
<span class="s1">} rd_kafka_cert_enc_t;</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert(rd_kafka_conf_t *conf, rd_kafka_cert_type_t cert_type, rd_kafka_cert_enc_t cert_enc, const void *buffer, size_t size, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_conf_set_engine_callback_data(rd_kafka_conf_t *conf, void *callback_data);</span>
<span class="s1">void rd_kafka_conf_set_opaque(rd_kafka_conf_t *conf, void *opaque);</span>
<span class="s1">void *rd_kafka_opaque(const rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_conf_set_default_topic_conf(rd_kafka_conf_t *conf, rd_kafka_topic_conf_t *tconf);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_conf_get_default_topic_conf(rd_kafka_conf_t *conf);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_get(const rd_kafka_conf_t *conf, const char *name, char *dest, size_t *dest_size);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_topic_conf_get(const rd_kafka_topic_conf_t *conf, const char *name, char *dest, size_t *dest_size);</span>
<span class="s1">const char **rd_kafka_conf_dump(rd_kafka_conf_t *conf, size_t *cntp);</span>
<span class="s1">const char **rd_kafka_topic_conf_dump(rd_kafka_topic_conf_t *conf, size_t *cntp);</span>
<span class="s1">void rd_kafka_conf_dump_free(const char **arr, size_t cnt);</span>
<span class="s1">void rd_kafka_conf_properties_show(FILE *fp);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_topic_conf_new(void);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_topic_conf_dup(const rd_kafka_topic_conf_t *conf);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_default_topic_conf_dup(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_topic_conf_destroy(rd_kafka_topic_conf_t *topic_conf);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_topic_conf_set(rd_kafka_topic_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_topic_conf_set_opaque(rd_kafka_topic_conf_t *conf, void *rkt_opaque);</span>
<span class="s1">void rd_kafka_topic_conf_set_partitioner_cb(rd_kafka_topic_conf_t *topic_conf, int32_t (*partitioner)(const rd_kafka_topic_t *rkt, const void *keydata, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque));</span>
<span class="s1">void rd_kafka_topic_conf_set_msg_order_cmp(rd_kafka_topic_conf_t *topic_conf, int (*msg_order_cmp)(const rd_kafka_message_t *a, const rd_kafka_message_t *b));</span>
<span class="s1">int rd_kafka_topic_partition_available(const rd_kafka_topic_t *rkt, int32_t partition);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_consistent(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_consistent_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_murmur2(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_murmur2_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_fnv1a(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_fnv1a_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">rd_kafka_t *rd_kafka_new(rd_kafka_type_t type, rd_kafka_conf_t *conf, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_destroy(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_destroy_flags(rd_kafka_t *rk, int flags);</span>
<span class="s1">const char *rd_kafka_name(const rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_type_t rd_kafka_type(const rd_kafka_t *rk);</span>
<span class="s1">char *rd_kafka_memberid(const rd_kafka_t *rk);</span>
<span class="s1">char *rd_kafka_clusterid(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">int32_t rd_kafka_controllerid(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_topic_t *rd_kafka_topic_new(rd_kafka_t *rk, const char *topic, rd_kafka_topic_conf_t *conf);</span>
<span class="s1">void rd_kafka_topic_destroy(rd_kafka_topic_t *rkt);</span>
<span class="s1">const char *rd_kafka_topic_name(const rd_kafka_topic_t *rkt);</span>
<span class="s1">void *rd_kafka_topic_opaque(const rd_kafka_topic_t *rkt);</span>
<span class="s1">int rd_kafka_poll(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">void rd_kafka_yield(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_pause_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_resume_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_query_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_get_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offsets_for_times(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets, int timeout_ms);</span>
<span class="s1">void *rd_kafka_mem_calloc(rd_kafka_t *rk, size_t num, size_t size);</span>
<span class="s1">void *rd_kafka_mem_malloc(rd_kafka_t *rk, size_t size);</span>
<span class="s1">void rd_kafka_mem_free(rd_kafka_t *rk, void *ptr);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_new(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_queue_destroy(rd_kafka_queue_t *rkqu);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_main(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_sasl(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_sasl_background_callbacks_enable(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_sasl_set_credentials(rd_kafka_t *rk, const char *username, const char *password);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_consumer(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_partition(rd_kafka_t *rk, const char *topic, int32_t partition);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_background(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_queue_forward(rd_kafka_queue_t *src, rd_kafka_queue_t *dst);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_set_log_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu);</span>
<span class="s1">size_t rd_kafka_queue_length(rd_kafka_queue_t *rkqu);</span>
<span class="s1">void rd_kafka_queue_io_event_enable(rd_kafka_queue_t *rkqu, int fd, const void *payload, size_t size);</span>
<span class="s1">void rd_kafka_queue_cb_event_enable(rd_kafka_queue_t *rkqu, void (*event_cb)(rd_kafka_t *rk, void *qev_opaque), void *qev_opaque);</span>
<span class="s1">void rd_kafka_queue_yield(rd_kafka_queue_t *rkqu);</span>
<span class="s1">int rd_kafka_consume_start(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);</span>
<span class="s1">int rd_kafka_consume_start_queue(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, rd_kafka_queue_t *rkqu);</span>
<span class="s1">int rd_kafka_consume_stop(rd_kafka_topic_t *rkt, int32_t partition);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_seek(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, int timeout_ms);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_seek_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consume(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms);</span>
<span class="s1">ssize_t rd_kafka_consume_batch(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);</span>
<span class="s1">int rd_kafka_consume_callback(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consume_queue(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">ssize_t rd_kafka_consume_batch_queue(rd_kafka_queue_t *rkqu, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);</span>
<span class="s1">int rd_kafka_consume_callback_queue(rd_kafka_queue_t *rkqu, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offset_store(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offsets_store(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_offset_store_message(rd_kafka_message_t *rkmessage);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_subscribe(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *topics);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_unsubscribe(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_subscription(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **topics);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consumer_poll(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_consumer_close(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_consumer_close_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu);</span>
<span class="s1">int rd_kafka_consumer_closed(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_incremental_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_incremental_unassign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">const char *rd_kafka_rebalance_protocol(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_assignment(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **partitions);</span>
<span class="s1">int rd_kafka_assignment_lost(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, int async);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit_message(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, int async);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit_queue(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_queue_t *rkqu, void (*cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *commit_opaque), void *commit_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_committed(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_position(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata_new(const char *group_id);</span>
<span class="s1">rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata_new_with_genid(const char *group_id, int32_t generation_id, const char *member_id, const char *group_instance_id);</span>
<span class="s1">void rd_kafka_consumer_group_metadata_destroy(rd_kafka_consumer_group_metadata_t *);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_consumer_group_metadata_write(const rd_kafka_consumer_group_metadata_t *cgmd, void **bufferp, size_t *sizep);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_consumer_group_metadata_read(rd_kafka_consumer_group_metadata_t **cgmdp, const void *buffer, size_t size);</span>
<span class="s1">int rd_kafka_produce(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, void *payload, size_t len, const void *key, size_t keylen, void *msg_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_producev(rd_kafka_t *rk, ...);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_produceva(rd_kafka_t *rk, const rd_kafka_vu_t *vus, size_t cnt);</span>
<span class="s1">int rd_kafka_produce_batch(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, rd_kafka_message_t *rkmessages, int message_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_flush(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_purge(rd_kafka_t *rk, int purge_flags);</span>
<span class="s1">typedef struct rd_kafka_metadata_broker {</span>
<span class="s1">  int32_t id;</span>
<span class="s1">  char *host;</span>
<span class="s1">  int port;</span>
<span class="s1">} rd_kafka_metadata_broker_t;</span>
<span class="s1">typedef struct rd_kafka_metadata_partition {</span>
<span class="s1">  int32_t id;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  int32_t leader;</span>
<span class="s1">  int replica_cnt;</span>
<span class="s1">  int32_t *replicas;</span>
<span class="s1">  int isr_cnt;</span>
<span class="s1">  int32_t *isrs;</span>
<span class="s1">} rd_kafka_metadata_partition_t;</span>
<span class="s1">typedef struct rd_kafka_metadata_topic {</span>
<span class="s1">  char *topic;</span>
<span class="s1">  int partition_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_partition *partitions;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">} rd_kafka_metadata_topic_t;</span>
<span class="s1">typedef struct rd_kafka_metadata {</span>
<span class="s1">  int broker_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_broker *brokers;</span>
<span class="s1">  int topic_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_topic *topics;</span>
<span class="s1">  int32_t orig_broker_id;</span>
<span class="s1">  char *orig_broker_name;</span>
<span class="s1">} rd_kafka_metadata_t;</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_metadata(rd_kafka_t *rk, int all_topics, rd_kafka_topic_t *only_rkt, const struct rd_kafka_metadata **metadatap, int timeout_ms);</span>
<span class="s1">void rd_kafka_metadata_destroy(const struct rd_kafka_metadata *metadata);</span>
<span class="s1">typedef struct rd_kafka_Node_s rd_kafka_Node_t;</span>
<span class="s1">int rd_kafka_Node_id(const rd_kafka_Node_t *node);</span>
<span class="s1">const char *rd_kafka_Node_host(const rd_kafka_Node_t *node);</span>
<span class="s1">uint16_t rd_kafka_Node_port(const rd_kafka_Node_t *node);</span>
<span class="s1">struct rd_kafka_group_member_info {</span>
<span class="s1">  char *member_id;</span>
<span class="s1">  char *client_id;</span>
<span class="s1">  char *client_host;</span>
<span class="s1">  void *member_metadata;</span>
<span class="s1">  int member_metadata_size;</span>
<span class="s1">  void *member_assignment;</span>
<span class="s1">  int member_assignment_size;</span>
<span class="s1">};</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_CONSUMER_GROUP_STATE_UNKNOWN = 0,</span>
<span class="s1">  RD_KAFKA_CONSUMER_GROUP_STATE_PREPARING_REBALANCE = 1,</span>
<span class="s1">  RD_KAFKA_CONSUMER_GROUP_STATE_COMPLETING_REBALANCE = 2,</span>
<span class="s1">  RD_KAFKA_CONSUMER_GROUP_STATE_STABLE = 3,</span>
<span class="s1">  RD_KAFKA_CONSUMER_GROUP_STATE_DEAD = 4,</span>
<span class="s1">  RD_KAFKA_CONSUMER_GROUP_STATE_EMPTY = 5,</span>
<span class="s1">  RD_KAFKA_CONSUMER_GROUP_STATE__CNT,</span>
<span class="s1">} rd_kafka_consumer_group_state_t;</span>
<span class="s1">struct rd_kafka_group_info {</span>
<span class="s1">  struct rd_kafka_metadata_broker broker;</span>
<span class="s1">  char *group;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  char *state;</span>
<span class="s1">  char *protocol_type;</span>
<span class="s1">  char *protocol;</span>
<span class="s1">  struct rd_kafka_group_member_info *members;</span>
<span class="s1">  int member_cnt;</span>
<span class="s1">};</span>
<span class="s1">struct rd_kafka_group_list {</span>
<span class="s1">  struct rd_kafka_group_info *groups;</span>
<span class="s1">  int group_cnt;</span>
<span class="s1">};</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_list_groups(rd_kafka_t *rk, const char *group, const struct rd_kafka_group_list **grplistp, int timeout_ms);</span>
<span class="s1">const char *rd_kafka_consumer_group_state_name(rd_kafka_consumer_group_state_t state);</span>
<span class="s1">rd_kafka_consumer_group_state_t rd_kafka_consumer_group_state_code(const char *name);</span>
<span class="s1">void rd_kafka_group_list_destroy(const struct rd_kafka_group_list *grplist);</span>
<span class="s1">int rd_kafka_brokers_add(rd_kafka_t *rk, const char *brokerlist);</span>
<span class="s1">void rd_kafka_set_logger(rd_kafka_t *rk, void (*func)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));</span>
<span class="s1">void rd_kafka_set_log_level(rd_kafka_t *rk, int level);</span>
<span class="s1">void rd_kafka_log_print(const rd_kafka_t *rk, int level, const char *fac, const char *buf);</span>
<span class="s1">void rd_kafka_log_syslog(const rd_kafka_t *rk, int level, const char *fac, const char *buf);</span>
<span class="s1">int rd_kafka_outq_len(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_dump(FILE *fp, rd_kafka_t *rk);</span>
<span class="s1">int rd_kafka_thread_cnt(void);</span>
<span class="s1">typedef enum rd_kafka_thread_type_t {</span>
<span class="s1">  RD_KAFKA_THREAD_MAIN,</span>
<span class="s1">  RD_KAFKA_THREAD_BACKGROUND,</span>
<span class="s1">  RD_KAFKA_THREAD_BROKER,</span>
<span class="s1">} rd_kafka_thread_type_t;</span>
<span class="s1">int rd_kafka_wait_destroyed(int timeout_ms);</span>
<span class="s1">int rd_kafka_unittest(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_poll_set_consumer(rd_kafka_t *rk);</span>
<span class="s1">typedef int rd_kafka_event_type_t;</span>
<span class="s1">rd_kafka_event_type_t rd_kafka_event_type(const rd_kafka_event_t *rkev);</span>
<span class="s1">const char *rd_kafka_event_name(const rd_kafka_event_t *rkev);</span>
<span class="s1">void rd_kafka_event_destroy(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_message_t *rd_kafka_event_message_next(rd_kafka_event_t *rkev);</span>
<span class="s1">size_t rd_kafka_event_message_array(rd_kafka_event_t *rkev, const rd_kafka_message_t **rkmessages, size_t size);</span>
<span class="s1">size_t rd_kafka_event_message_count(rd_kafka_event_t *rkev);</span>
<span class="s1">const char *rd_kafka_event_config_string(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_event_error(rd_kafka_event_t *rkev);</span>
<span class="s1">const char *rd_kafka_event_error_string(rd_kafka_event_t *rkev);</span>
<span class="s1">int rd_kafka_event_error_is_fatal(rd_kafka_event_t *rkev);</span>
<span class="s1">void *rd_kafka_event_opaque(rd_kafka_event_t *rkev);</span>
<span class="s1">int rd_kafka_event_log(rd_kafka_event_t *rkev, const char **fac, const char **str, int *level);</span>
<span class="s1">int rd_kafka_event_debug_contexts(rd_kafka_event_t *rkev, char *dst, size_t dstsize);</span>
<span class="s1">const char *rd_kafka_event_stats(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_event_topic_partition_list(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_event_topic_partition(rd_kafka_event_t *rkev);</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_CreateTopics_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DeleteTopics_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_CreateAcls_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DescribeAcls_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DeleteAcls_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_CreatePartitions_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_AlterConfigs_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DescribeConfigs_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DeleteRecords_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_ListConsumerGroups_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DescribeConsumerGroups_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DeleteGroups_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DeleteConsumerGroupOffsets_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_AlterConsumerGroupOffsets_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_ListConsumerGroupOffsets_result_t;</span>
<span class="s1">const rd_kafka_CreateTopics_result_t *rd_kafka_event_CreateTopics_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DeleteTopics_result_t *rd_kafka_event_DeleteTopics_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_CreatePartitions_result_t *rd_kafka_event_CreatePartitions_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_AlterConfigs_result_t *rd_kafka_event_AlterConfigs_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DescribeConfigs_result_t *rd_kafka_event_DescribeConfigs_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DeleteRecords_result_t *rd_kafka_event_DeleteRecords_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_ListConsumerGroups_result_t *rd_kafka_event_ListConsumerGroups_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DescribeConsumerGroups_result_t *rd_kafka_event_DescribeConsumerGroups_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DeleteGroups_result_t *rd_kafka_event_DeleteGroups_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DeleteConsumerGroupOffsets_result_t *rd_kafka_event_DeleteConsumerGroupOffsets_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_CreateAcls_result_t *rd_kafka_event_CreateAcls_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DescribeAcls_result_t *rd_kafka_event_DescribeAcls_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DeleteAcls_result_t *rd_kafka_event_DeleteAcls_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_AlterConsumerGroupOffsets_result_t *rd_kafka_event_AlterConsumerGroupOffsets_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_ListConsumerGroupOffsets_result_t *rd_kafka_event_ListConsumerGroupOffsets_result(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_event_t *rd_kafka_queue_poll(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">int rd_kafka_queue_poll_callback(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_plugin_f_conf_init_t)(rd_kafka_conf_t *conf, void **plug_opaquep, char *errstr, size_t errstr_size);</span>
<span class="s1">typedef rd_kafka_conf_res_t (rd_kafka_interceptor_f_on_conf_set_t)(rd_kafka_conf_t *conf, const char *name, const char *val, char *errstr, size_t errstr_size, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_dup_t)(rd_kafka_conf_t *new_conf, const rd_kafka_conf_t *old_conf, size_t filter_cnt, const char **filter, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_destroy_t)(void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_new_t)(rd_kafka_t *rk, const rd_kafka_conf_t *conf, void *ic_opaque, char *errstr, size_t errstr_size);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_destroy_t)(rd_kafka_t *rk, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_send_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_acknowledgement_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_consume_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_commit_t)(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_resp_err_t err, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_request_sent_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_response_received_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, int64_t rtt, rd_kafka_resp_err_t err, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_start_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_exit_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_broker_state_change_t)(rd_kafka_t *rk, int32_t broker_id, const char *secproto, const char *name, int port, const char *state, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_set(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_set_t *on_conf_set, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_dup(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_dup_t *on_conf_dup, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_destroy(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_destroy_t *on_conf_destroy, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_new(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_new_t *on_new, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_destroy(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_destroy_t *on_destroy, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_send(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_send_t *on_send, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_acknowledgement(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_acknowledgement_t *on_acknowledgement, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_consume(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_consume_t *on_consume, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_commit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_commit_t *on_commit, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_request_sent(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_request_sent_t *on_request_sent, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_response_received(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_response_received_t *on_response_received, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_start(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_start_t *on_thread_start, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_exit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_exit_t *on_thread_exit, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_broker_state_change(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_broker_state_change_t *on_broker_state_change, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_topic_result_error(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">const char *rd_kafka_topic_result_error_string(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">const char *rd_kafka_topic_result_name(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">const rd_kafka_error_t *rd_kafka_group_result_error(const rd_kafka_group_result_t *groupres);</span>
<span class="s1">const char *rd_kafka_group_result_name(const rd_kafka_group_result_t *groupres);</span>
<span class="s1">const rd_kafka_topic_partition_list_t *rd_kafka_group_result_partitions(const rd_kafka_group_result_t *groupres);</span>
<span class="s1">typedef enum rd_kafka_admin_op_t {</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_ANY = 0,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_CREATETOPICS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DELETETOPICS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_CREATEPARTITIONS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_ALTERCONFIGS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DESCRIBECONFIGS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DELETERECORDS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DELETEGROUPS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DELETECONSUMERGROUPOFFSETS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_CREATEACLS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DESCRIBEACLS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DELETEACLS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_LISTCONSUMERGROUPS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DESCRIBECONSUMERGROUPS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_LISTCONSUMERGROUPOFFSETS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_ALTERCONSUMERGROUPOFFSETS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP__CNT,</span>
<span class="s1">} rd_kafka_admin_op_t;</span>
<span class="s1">typedef struct rd_kafka_AdminOptions_s rd_kafka_AdminOptions_t;</span>
<span class="s1">rd_kafka_AdminOptions_t *rd_kafka_AdminOptions_new(rd_kafka_t *rk, rd_kafka_admin_op_t for_api);</span>
<span class="s1">void rd_kafka_AdminOptions_destroy(rd_kafka_AdminOptions_t *options);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_request_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_operation_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_validate_only(rd_kafka_AdminOptions_t *options, int true_or_false, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_broker(rd_kafka_AdminOptions_t *options, int32_t broker_id, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_AdminOptions_set_require_stable_offsets(rd_kafka_AdminOptions_t *options, int true_or_false);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_AdminOptions_set_match_consumer_group_states(rd_kafka_AdminOptions_t *options, const rd_kafka_consumer_group_state_t *consumer_group_states, size_t consumer_group_states_cnt);</span>
<span class="s1">void rd_kafka_AdminOptions_set_opaque(rd_kafka_AdminOptions_t *options, void *ev_opaque);</span>
<span class="s1">typedef struct rd_kafka_NewTopic_s rd_kafka_NewTopic_t;</span>
<span class="s1">rd_kafka_NewTopic_t *rd_kafka_NewTopic_new(const char *topic, int num_partitions, int replication_factor, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_NewTopic_destroy(rd_kafka_NewTopic_t *new_topic);</span>
<span class="s1">void rd_kafka_NewTopic_destroy_array(rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewTopic_set_replica_assignment(rd_kafka_NewTopic_t *new_topic, int32_t partition, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewTopic_set_config(rd_kafka_NewTopic_t *new_topic, const char *name, const char *value);</span>
<span class="s1">void rd_kafka_CreateTopics(rd_kafka_t *rk, rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_CreateTopics_result_topics(const rd_kafka_CreateTopics_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_DeleteTopic_s rd_kafka_DeleteTopic_t;</span>
<span class="s1">rd_kafka_DeleteTopic_t *rd_kafka_DeleteTopic_new(const char *topic);</span>
<span class="s1">void rd_kafka_DeleteTopic_destroy(rd_kafka_DeleteTopic_t *del_topic);</span>
<span class="s1">void rd_kafka_DeleteTopic_destroy_array(rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt);</span>
<span class="s1">void rd_kafka_DeleteTopics(rd_kafka_t *rk, rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_DeleteTopics_result_topics(const rd_kafka_DeleteTopics_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_NewPartitions_s rd_kafka_NewPartitions_t;</span>
<span class="s1">rd_kafka_NewPartitions_t *rd_kafka_NewPartitions_new(const char *topic, size_t new_total_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_NewPartitions_destroy(rd_kafka_NewPartitions_t *new_parts);</span>
<span class="s1">void rd_kafka_NewPartitions_destroy_array(rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewPartitions_set_replica_assignment(rd_kafka_NewPartitions_t *new_parts, int32_t new_partition_idx, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_CreatePartitions(rd_kafka_t *rk, rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_CreatePartitions_result_topics(const rd_kafka_CreatePartitions_result_t *result, size_t *cntp);</span>
<span class="s1">typedef enum rd_kafka_ConfigSource_t {</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_UNKNOWN_CONFIG = 0,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_TOPIC_CONFIG = 1,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_BROKER_CONFIG = 2,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_DEFAULT_BROKER_CONFIG = 3,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_STATIC_BROKER_CONFIG = 4,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DEFAULT_CONFIG = 5,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE__CNT,</span>
<span class="s1">} rd_kafka_ConfigSource_t;</span>
<span class="s1">const char *rd_kafka_ConfigSource_name(rd_kafka_ConfigSource_t confsource);</span>
<span class="s1">typedef struct rd_kafka_ConfigEntry_s rd_kafka_ConfigEntry_t;</span>
<span class="s1">const char *rd_kafka_ConfigEntry_name(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">const char *rd_kafka_ConfigEntry_value(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">rd_kafka_ConfigSource_t rd_kafka_ConfigEntry_source(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_read_only(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_default(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_sensitive(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_synonym(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">const rd_kafka_ConfigEntry_t **rd_kafka_ConfigEntry_synonyms(const rd_kafka_ConfigEntry_t *entry, size_t *cntp);</span>
<span class="s1">typedef enum rd_kafka_ResourceType_t {</span>
<span class="s1">  RD_KAFKA_RESOURCE_UNKNOWN = 0,</span>
<span class="s1">  RD_KAFKA_RESOURCE_ANY = 1,</span>
<span class="s1">  RD_KAFKA_RESOURCE_TOPIC = 2,</span>
<span class="s1">  RD_KAFKA_RESOURCE_GROUP = 3,</span>
<span class="s1">  RD_KAFKA_RESOURCE_BROKER = 4,</span>
<span class="s1">  RD_KAFKA_RESOURCE__CNT,</span>
<span class="s1">} rd_kafka_ResourceType_t;</span>
<span class="s1">typedef enum rd_kafka_ResourcePatternType_t {</span>
<span class="s1">  RD_KAFKA_RESOURCE_PATTERN_UNKNOWN = 0,</span>
<span class="s1">  RD_KAFKA_RESOURCE_PATTERN_ANY = 1,</span>
<span class="s1">  RD_KAFKA_RESOURCE_PATTERN_MATCH = 2,</span>
<span class="s1">  RD_KAFKA_RESOURCE_PATTERN_LITERAL = 3,</span>
<span class="s1">  RD_KAFKA_RESOURCE_PATTERN_PREFIXED = 4,</span>
<span class="s1">  RD_KAFKA_RESOURCE_PATTERN_TYPE__CNT,</span>
<span class="s1">} rd_kafka_ResourcePatternType_t;</span>
<span class="s1">const char *rd_kafka_ResourcePatternType_name(rd_kafka_ResourcePatternType_t resource_pattern_type);</span>
<span class="s1">const char *rd_kafka_ResourceType_name(rd_kafka_ResourceType_t restype);</span>
<span class="s1">typedef struct rd_kafka_ConfigResource_s rd_kafka_ConfigResource_t;</span>
<span class="s1">rd_kafka_ConfigResource_t *rd_kafka_ConfigResource_new(rd_kafka_ResourceType_t restype, const char *resname);</span>
<span class="s1">void rd_kafka_ConfigResource_destroy(rd_kafka_ConfigResource_t *config);</span>
<span class="s1">void rd_kafka_ConfigResource_destroy_array(rd_kafka_ConfigResource_t **config, size_t config_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_ConfigResource_set_config(rd_kafka_ConfigResource_t *config, const char *name, const char *value);</span>
<span class="s1">const rd_kafka_ConfigEntry_t **rd_kafka_ConfigResource_configs(const rd_kafka_ConfigResource_t *config, size_t *cntp);</span>
<span class="s1">rd_kafka_ResourceType_t rd_kafka_ConfigResource_type(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">const char *rd_kafka_ConfigResource_name(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_ConfigResource_error(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">const char *rd_kafka_ConfigResource_error_string(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">void rd_kafka_AlterConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_ConfigResource_t **rd_kafka_AlterConfigs_result_resources(const rd_kafka_AlterConfigs_result_t *result, size_t *cntp);</span>
<span class="s1">void rd_kafka_DescribeConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_ConfigResource_t **rd_kafka_DescribeConfigs_result_resources(const rd_kafka_DescribeConfigs_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_DeleteRecords_s rd_kafka_DeleteRecords_t;</span>
<span class="s1">rd_kafka_DeleteRecords_t *rd_kafka_DeleteRecords_new(const rd_kafka_topic_partition_list_t *before_offsets);</span>
<span class="s1">void rd_kafka_DeleteRecords_destroy(rd_kafka_DeleteRecords_t *del_records);</span>
<span class="s1">void rd_kafka_DeleteRecords_destroy_array(rd_kafka_DeleteRecords_t **del_records, size_t del_record_cnt);</span>
<span class="s1">void rd_kafka_DeleteRecords(rd_kafka_t *rk, rd_kafka_DeleteRecords_t **del_records, size_t del_record_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_partition_list_t *rd_kafka_DeleteRecords_result_offsets(const rd_kafka_DeleteRecords_result_t *result);</span>
<span class="s1">typedef struct rd_kafka_ConsumerGroupListing_s rd_kafka_ConsumerGroupListing_t;</span>
<span class="s1">typedef struct rd_kafka_ListConsumerGroupsResult_s rd_kafka_ListConsumerGroupsResult_t;</span>
<span class="s1">void rd_kafka_ListConsumerGroups(rd_kafka_t *rk, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const char *rd_kafka_ConsumerGroupListing_group_id(const rd_kafka_ConsumerGroupListing_t *grplist);</span>
<span class="s1">int rd_kafka_ConsumerGroupListing_is_simple_consumer_group(const rd_kafka_ConsumerGroupListing_t *grplist);</span>
<span class="s1">rd_kafka_consumer_group_state_t rd_kafka_ConsumerGroupListing_state(const rd_kafka_ConsumerGroupListing_t *grplist);</span>
<span class="s1">const rd_kafka_ConsumerGroupListing_t **rd_kafka_ListConsumerGroups_result_valid(const rd_kafka_ListConsumerGroups_result_t *result, size_t *cntp);</span>
<span class="s1">const rd_kafka_error_t **rd_kafka_ListConsumerGroups_result_errors(const rd_kafka_ListConsumerGroups_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_ConsumerGroupDescription_s rd_kafka_ConsumerGroupDescription_t;</span>
<span class="s1">typedef struct rd_kafka_MemberDescription_s rd_kafka_MemberDescription_t;</span>
<span class="s1">typedef struct rd_kafka_MemberAssignment_s rd_kafka_MemberAssignment_t;</span>
<span class="s1">void rd_kafka_DescribeConsumerGroups(rd_kafka_t *rk, const char **groups, size_t groups_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_ConsumerGroupDescription_t **rd_kafka_DescribeConsumerGroups_result_groups(const rd_kafka_DescribeConsumerGroups_result_t *result, size_t *cntp);</span>
<span class="s1">const char *rd_kafka_ConsumerGroupDescription_group_id(const rd_kafka_ConsumerGroupDescription_t *grpdesc);</span>
<span class="s1">const rd_kafka_error_t *rd_kafka_ConsumerGroupDescription_error(const rd_kafka_ConsumerGroupDescription_t *grpdesc);</span>
<span class="s1">int rd_kafka_ConsumerGroupDescription_is_simple_consumer_group(const rd_kafka_ConsumerGroupDescription_t *grpdesc);</span>
<span class="s1">const char *rd_kafka_ConsumerGroupDescription_partition_assignor(const rd_kafka_ConsumerGroupDescription_t *grpdesc);</span>
<span class="s1">rd_kafka_consumer_group_state_t rd_kafka_ConsumerGroupDescription_state(const rd_kafka_ConsumerGroupDescription_t *grpdesc);</span>
<span class="s1">const rd_kafka_Node_t *rd_kafka_ConsumerGroupDescription_coordinator(const rd_kafka_ConsumerGroupDescription_t *grpdesc);</span>
<span class="s1">size_t rd_kafka_ConsumerGroupDescription_member_count(const rd_kafka_ConsumerGroupDescription_t *grpdesc);</span>
<span class="s1">const rd_kafka_MemberDescription_t *rd_kafka_ConsumerGroupDescription_member(const rd_kafka_ConsumerGroupDescription_t *grpdesc, size_t idx);</span>
<span class="s1">const char *rd_kafka_MemberDescription_client_id(const rd_kafka_MemberDescription_t *member);</span>
<span class="s1">const char *rd_kafka_MemberDescription_group_instance_id(const rd_kafka_MemberDescription_t *member);</span>
<span class="s1">const char *rd_kafka_MemberDescription_consumer_id(const rd_kafka_MemberDescription_t *member);</span>
<span class="s1">const char *rd_kafka_MemberDescription_host(const rd_kafka_MemberDescription_t *member);</span>
<span class="s1">const rd_kafka_MemberAssignment_t *rd_kafka_MemberDescription_assignment(const rd_kafka_MemberDescription_t *member);</span>
<span class="s1">const rd_kafka_topic_partition_list_t *rd_kafka_MemberAssignment_partitions(const rd_kafka_MemberAssignment_t *assignment);</span>
<span class="s1">typedef struct rd_kafka_DeleteGroup_s rd_kafka_DeleteGroup_t;</span>
<span class="s1">rd_kafka_DeleteGroup_t *rd_kafka_DeleteGroup_new(const char *group);</span>
<span class="s1">void rd_kafka_DeleteGroup_destroy(rd_kafka_DeleteGroup_t *del_group);</span>
<span class="s1">void rd_kafka_DeleteGroup_destroy_array(rd_kafka_DeleteGroup_t **del_groups, size_t del_group_cnt);</span>
<span class="s1">void rd_kafka_DeleteGroups(rd_kafka_t *rk, rd_kafka_DeleteGroup_t **del_groups, size_t del_group_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_group_result_t **rd_kafka_DeleteGroups_result_groups(const rd_kafka_DeleteGroups_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_ListConsumerGroupOffsets_s rd_kafka_ListConsumerGroupOffsets_t;</span>
<span class="s1">rd_kafka_ListConsumerGroupOffsets_t *rd_kafka_ListConsumerGroupOffsets_new(const char *group_id, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">void rd_kafka_ListConsumerGroupOffsets_destroy(rd_kafka_ListConsumerGroupOffsets_t *list_grpoffsets);</span>
<span class="s1">void rd_kafka_ListConsumerGroupOffsets_destroy_array(rd_kafka_ListConsumerGroupOffsets_t **list_grpoffsets, size_t list_grpoffset_cnt);</span>
<span class="s1">void rd_kafka_ListConsumerGroupOffsets(rd_kafka_t *rk, rd_kafka_ListConsumerGroupOffsets_t **list_grpoffsets, size_t list_grpoffsets_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_group_result_t **rd_kafka_ListConsumerGroupOffsets_result_groups(const rd_kafka_ListConsumerGroupOffsets_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_AlterConsumerGroupOffsets_s rd_kafka_AlterConsumerGroupOffsets_t;</span>
<span class="s1">rd_kafka_AlterConsumerGroupOffsets_t *rd_kafka_AlterConsumerGroupOffsets_new(const char *group_id, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">void rd_kafka_AlterConsumerGroupOffsets_destroy(rd_kafka_AlterConsumerGroupOffsets_t *alter_grpoffsets);</span>
<span class="s1">void rd_kafka_AlterConsumerGroupOffsets_destroy_array(rd_kafka_AlterConsumerGroupOffsets_t **alter_grpoffsets, size_t alter_grpoffset_cnt);</span>
<span class="s1">void rd_kafka_AlterConsumerGroupOffsets(rd_kafka_t *rk, rd_kafka_AlterConsumerGroupOffsets_t **alter_grpoffsets, size_t alter_grpoffsets_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_group_result_t **rd_kafka_AlterConsumerGroupOffsets_result_groups(const rd_kafka_AlterConsumerGroupOffsets_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_DeleteConsumerGroupOffsets_s rd_kafka_DeleteConsumerGroupOffsets_t;</span>
<span class="s1">rd_kafka_DeleteConsumerGroupOffsets_t *rd_kafka_DeleteConsumerGroupOffsets_new(const char *group, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">void rd_kafka_DeleteConsumerGroupOffsets_destroy(rd_kafka_DeleteConsumerGroupOffsets_t *del_grpoffsets);</span>
<span class="s1">void rd_kafka_DeleteConsumerGroupOffsets_destroy_array(rd_kafka_DeleteConsumerGroupOffsets_t **del_grpoffsets, size_t del_grpoffset_cnt);</span>
<span class="s1">void rd_kafka_DeleteConsumerGroupOffsets(rd_kafka_t *rk, rd_kafka_DeleteConsumerGroupOffsets_t **del_grpoffsets, size_t del_grpoffsets_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_group_result_t **rd_kafka_DeleteConsumerGroupOffsets_result_groups(const rd_kafka_DeleteConsumerGroupOffsets_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_AclBinding_s rd_kafka_AclBinding_t;</span>
<span class="s1">typedef rd_kafka_AclBinding_t rd_kafka_AclBindingFilter_t;</span>
<span class="s1">const rd_kafka_error_t *rd_kafka_acl_result_error(const rd_kafka_acl_result_t *aclres);</span>
<span class="s1">typedef enum rd_kafka_AclOperation_t {</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_UNKNOWN = 0,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_ANY = 1,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_ALL = 2,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_READ = 3,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_WRITE = 4,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_CREATE = 5,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_DELETE = 6,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_ALTER = 7,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_DESCRIBE = 8,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_CLUSTER_ACTION = 9,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_DESCRIBE_CONFIGS = 10,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_ALTER_CONFIGS = 11,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_IDEMPOTENT_WRITE = 12,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION__CNT,</span>
<span class="s1">} rd_kafka_AclOperation_t;</span>
<span class="s1">const char *rd_kafka_AclOperation_name(rd_kafka_AclOperation_t acl_operation);</span>
<span class="s1">typedef enum rd_kafka_AclPermissionType_t {</span>
<span class="s1">  RD_KAFKA_ACL_PERMISSION_TYPE_UNKNOWN = 0,</span>
<span class="s1">  RD_KAFKA_ACL_PERMISSION_TYPE_ANY = 1,</span>
<span class="s1">  RD_KAFKA_ACL_PERMISSION_TYPE_DENY = 2,</span>
<span class="s1">  RD_KAFKA_ACL_PERMISSION_TYPE_ALLOW = 3,</span>
<span class="s1">  RD_KAFKA_ACL_PERMISSION_TYPE__CNT,</span>
<span class="s1">} rd_kafka_AclPermissionType_t;</span>
<span class="s1">const char *rd_kafka_AclPermissionType_name(rd_kafka_AclPermissionType_t acl_permission_type);</span>
<span class="s1">rd_kafka_AclBinding_t *rd_kafka_AclBinding_new(rd_kafka_ResourceType_t restype, const char *name, rd_kafka_ResourcePatternType_t resource_pattern_type, const char *principal, const char *host, rd_kafka_AclOperation_t operation, rd_kafka_AclPermissionType_t permission_type, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_AclBindingFilter_t *rd_kafka_AclBindingFilter_new(rd_kafka_ResourceType_t restype, const char *name, rd_kafka_ResourcePatternType_t resource_pattern_type, const char *principal, const char *host, rd_kafka_AclOperation_t operation, rd_kafka_AclPermissionType_t permission_type, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_ResourceType_t rd_kafka_AclBinding_restype(const rd_kafka_AclBinding_t *acl);</span>
<span class="s1">const char *rd_kafka_AclBinding_name(const rd_kafka_AclBinding_t *acl);</span>
<span class="s1">const char *rd_kafka_AclBinding_principal(const rd_kafka_AclBinding_t *acl);</span>
<span class="s1">const char *rd_kafka_AclBinding_host(const rd_kafka_AclBinding_t *acl);</span>
<span class="s1">rd_kafka_AclOperation_t rd_kafka_AclBinding_operation(const rd_kafka_AclBinding_t *acl);</span>
<span class="s1">rd_kafka_AclPermissionType_t rd_kafka_AclBinding_permission_type(const rd_kafka_AclBinding_t *acl);</span>
<span class="s1">rd_kafka_ResourcePatternType_t rd_kafka_AclBinding_resource_pattern_type(const rd_kafka_AclBinding_t *acl);</span>
<span class="s1">const rd_kafka_error_t *rd_kafka_AclBinding_error(const rd_kafka_AclBinding_t *acl);</span>
<span class="s1">void rd_kafka_AclBinding_destroy(rd_kafka_AclBinding_t *acl_binding);</span>
<span class="s1">void rd_kafka_AclBinding_destroy_array(rd_kafka_AclBinding_t **acl_bindings, size_t acl_bindings_cnt);</span>
<span class="s1">const rd_kafka_acl_result_t **rd_kafka_CreateAcls_result_acls(const rd_kafka_CreateAcls_result_t *result, size_t *cntp);</span>
<span class="s1">void rd_kafka_CreateAcls(rd_kafka_t *rk, rd_kafka_AclBinding_t **new_acls, size_t new_acls_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_AclBinding_t **rd_kafka_DescribeAcls_result_acls(const rd_kafka_DescribeAcls_result_t *result, size_t *cntp);</span>
<span class="s1">void rd_kafka_DescribeAcls(rd_kafka_t *rk, rd_kafka_AclBindingFilter_t *acl_filter, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">typedef struct rd_kafka_DeleteAcls_result_response_s rd_kafka_DeleteAcls_result_response_t;</span>
<span class="s1">const rd_kafka_DeleteAcls_result_response_t **rd_kafka_DeleteAcls_result_responses(const rd_kafka_DeleteAcls_result_t *result, size_t *cntp);</span>
<span class="s1">const rd_kafka_error_t *rd_kafka_DeleteAcls_result_response_error(const rd_kafka_DeleteAcls_result_response_t *result_response);</span>
<span class="s1">const rd_kafka_AclBinding_t **rd_kafka_DeleteAcls_result_response_matching_acls(const rd_kafka_DeleteAcls_result_response_t *result_response, size_t *matching_acls_cntp);</span>
<span class="s1">void rd_kafka_DeleteAcls(rd_kafka_t *rk, rd_kafka_AclBindingFilter_t **del_acls, size_t del_acls_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token(rd_kafka_t *rk, const char *token_value, int64_t md_lifetime_ms, const char *md_principal_name, const char **extensions, size_t extension_size, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token_failure(rd_kafka_t *rk, const char *errstr);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_init_transactions(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_begin_transaction(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_send_offsets_to_transaction(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, const rd_kafka_consumer_group_metadata_t *cgmetadata, int timeout_ms);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_commit_transaction(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_abort_transaction(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">typedef struct rd_kafka_mock_cluster_s rd_kafka_mock_cluster_t;</span>
<span class="s1">rd_kafka_mock_cluster_t *rd_kafka_mock_cluster_new(rd_kafka_t *rk, int broker_cnt);</span>
<span class="s1">void rd_kafka_mock_cluster_destroy(rd_kafka_mock_cluster_t *mcluster);</span>
<span class="s1">rd_kafka_t *rd_kafka_mock_cluster_handle(const rd_kafka_mock_cluster_t *mcluster);</span>
<span class="s1">rd_kafka_mock_cluster_t *rd_kafka_handle_mock_cluster(const rd_kafka_t *rk);</span>
<span class="s1">const char *rd_kafka_mock_cluster_bootstraps(const rd_kafka_mock_cluster_t *mcluster);</span>
<span class="s1">void rd_kafka_mock_clear_request_errors(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey);</span>
<span class="s1">void rd_kafka_mock_push_request_errors(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, size_t cnt, ...);</span>
<span class="s1">void rd_kafka_mock_push_request_errors_array(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, size_t cnt, const rd_kafka_resp_err_t *errors);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_push_request_error_rtts(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int16_t ApiKey, size_t cnt, ...);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_error_stack_cnt(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int16_t ApiKey, size_t *cntp);</span>
<span class="s1">void rd_kafka_mock_topic_set_error(rd_kafka_mock_cluster_t *mcluster, const char *topic, rd_kafka_resp_err_t err);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_topic_create(rd_kafka_mock_cluster_t *mcluster, const char *topic, int partition_cnt, int replication_factor);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_partition_set_leader(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_partition_set_follower(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_partition_set_follower_wmarks(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int64_t lo, int64_t hi);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_set_down(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_set_up(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_set_rtt(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int rtt_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_set_rack(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, const char *rack);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_coordinator_set(rd_kafka_mock_cluster_t *mcluster, const char *key_type, const char *key, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_set_apiversion(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, int16_t MinVersion, int16_t MaxVersion);</span>
<span class="s1">&#39;</span>
</code></pre></div>
rdkafka.h, rdkafka_mock.h</p>
<h3 id="rd_kafka_version_27">RD_KAFKA_VERSION<a class="headerlink" href="#rd_kafka_version_27" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_VERSION</span> <span class="o">=</span> <span class="mi">33685759</span>
</code></pre></div>
<p>librdkafka version </p>
<p>Interpreted as hex <code>MM.mm.rr.xx</code>:</p>
<ul>
<li>MM = Major</li>
<li>mm = minor</li>
<li>rr = revision</li>
<li>xx = pre-release id (0xff is the final release)</li>
</ul>
<p>E.g.: <code>0x000801ff</code> = 0.8.1</p>
<dl class="section remark"><dt>Remarks</dt><dd>This value should only be used during compile time, for runtime checks of version use rd_kafka_version() </dd></dl>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_unsupported_compression_type_27">RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE<a class="headerlink" href="#rd_kafka_resp_err_unsupported_compression_type_27" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE</span> <span class="o">=</span> <span class="mi">76</span>
</code></pre></div>
<p>Unsupported compression type </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_end_all_27">RD_KAFKA_RESP_ERR_END_ALL<a class="headerlink" href="#rd_kafka_resp_err_end_all_27" title="Permanent link">&para;</a></h3>
<p><div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_END_ALL</span> <span class="o">=</span> <span class="mi">98</span>
</code></pre></div>
enum rd_kafka_resp_err_t</p>
<h3 id="rd_kafka_admin_op__cnt_27">RD_KAFKA_ADMIN_OP__CNT<a class="headerlink" href="#rd_kafka_admin_op__cnt_27" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_ADMIN_OP__CNT</span> <span class="o">=</span> <span class="mi">19</span>
</code></pre></div>
<p>Number of ops defined </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe </a></li>
</ul>
</div>
<h3 id="rd_kafka_resource__cnt_27">RD_KAFKA_RESOURCE__CNT<a class="headerlink" href="#rd_kafka_resource__cnt_27" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESOURCE__CNT</span> <span class="o">=</span> <span class="mi">5</span>
</code></pre></div>
<p>Number of resource types defined </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#acca83a66d7783ff7683ed2691cc907c9"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#acca83a66d7783ff7683ed2691cc907c9 </a></li>
</ul>
</div>
<h3 id="rd_kafka_cdef_27">RD_KAFKA_CDEF<a class="headerlink" href="#rd_kafka_cdef_27" title="Permanent link">&para;</a></h3>
<p><div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_CDEF</span> <span class="o">=</span> <span class="s1">&#39;typedef long int ssize_t;</span>
<span class="s1">typedef struct _IO_FILE FILE;</span>
<span class="s1">typedef long int mode_t;</span>
<span class="s1">typedef signed int int16_t;</span>
<span class="s1">typedef unsigned int uint16_t;</span>
<span class="s1">typedef signed int int32_t;</span>
<span class="s1">typedef signed long int int64_t;</span>
<span class="s1">int rd_kafka_version(void);</span>
<span class="s1">const char *rd_kafka_version_str(void);</span>
<span class="s1">typedef enum rd_kafka_type_t {</span>
<span class="s1">  RD_KAFKA_PRODUCER,</span>
<span class="s1">  RD_KAFKA_CONSUMER,</span>
<span class="s1">} rd_kafka_type_t;</span>
<span class="s1">typedef enum rd_kafka_timestamp_type_t {</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_NOT_AVAILABLE,</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_CREATE_TIME,</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_LOG_APPEND_TIME,</span>
<span class="s1">} rd_kafka_timestamp_type_t;</span>
<span class="s1">const char *rd_kafka_get_debug_contexts(void);</span>
<span class="s1">typedef struct rd_kafka_s rd_kafka_t;</span>
<span class="s1">typedef struct rd_kafka_topic_s rd_kafka_topic_t;</span>
<span class="s1">typedef struct rd_kafka_conf_s rd_kafka_conf_t;</span>
<span class="s1">typedef struct rd_kafka_topic_conf_s rd_kafka_topic_conf_t;</span>
<span class="s1">typedef struct rd_kafka_queue_s rd_kafka_queue_t;</span>
<span class="s1">typedef struct rd_kafka_op_s rd_kafka_event_t;</span>
<span class="s1">typedef struct rd_kafka_topic_result_s rd_kafka_topic_result_t;</span>
<span class="s1">typedef struct rd_kafka_consumer_group_metadata_s rd_kafka_consumer_group_metadata_t;</span>
<span class="s1">typedef struct rd_kafka_error_s {</span>
<span class="s1">  unsigned int code;</span>
<span class="s1">  char *errstr;</span>
<span class="s1">  unsigned char fatal;</span>
<span class="s1">  unsigned char retriable;</span>
<span class="s1">  unsigned char txn_requires_abort;</span>
<span class="s1">} rd_kafka_error_t;</span>
<span class="s1">typedef struct rd_kafka_headers_s rd_kafka_headers_t;</span>
<span class="s1">typedef struct rd_kafka_group_result_s rd_kafka_group_result_t;</span>
<span class="s1">typedef struct rd_kafka_acl_result_s rd_kafka_acl_result_t;</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BEGIN = (- 200),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BAD_MSG = (- 199),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BAD_COMPRESSION = (- 198),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__DESTROY = (- 197),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FAIL = (- 196),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TRANSPORT = (- 195),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__CRIT_SYS_RESOURCE = (- 194),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__RESOLVE = (- 193),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__MSG_TIMED_OUT = (- 192),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PARTITION_EOF = (- 191),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION = (- 190),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FS = (- 189),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC = (- 188),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ALL_BROKERS_DOWN = (- 187),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INVALID_ARG = (- 186),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TIMED_OUT = (- 185),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__QUEUE_FULL = (- 184),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ISR_INSUFF = (- 183),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NODE_UPDATE = (- 182),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__SSL = (- 181),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__WAIT_COORD = (- 180),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_GROUP = (- 179),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__IN_PROGRESS = (- 178),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PREV_IN_PROGRESS = (- 177),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__EXISTING_SUBSCRIPTION = (- 176),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS = (- 175),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS = (- 174),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__CONFLICT = (- 173),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__STATE = (- 172),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_PROTOCOL = (- 171),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED = (- 170),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__AUTHENTICATION = (- 169),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NO_OFFSET = (- 168),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__OUTDATED = (- 167),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TIMED_OUT_QUEUE = (- 166),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNSUPPORTED_FEATURE = (- 165),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__WAIT_CACHE = (- 164),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INTR = (- 163),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__KEY_SERIALIZATION = (- 162),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__VALUE_SERIALIZATION = (- 161),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__KEY_DESERIALIZATION = (- 160),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__VALUE_DESERIALIZATION = (- 159),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PARTIAL = (- 158),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__READ_ONLY = (- 157),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOENT = (- 156),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNDERFLOW = (- 155),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INVALID_TYPE = (- 154),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__RETRY = (- 153),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PURGE_QUEUE = (- 152),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PURGE_INFLIGHT = (- 151),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FATAL = (- 150),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INCONSISTENT = (- 149),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__GAPLESS_GUARANTEE = (- 148),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__MAX_POLL_EXCEEDED = (- 147),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_BROKER = (- 146),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOT_CONFIGURED = (- 145),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FENCED = (- 144),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__APPLICATION = (- 143),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ASSIGNMENT_LOST = (- 142),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOOP = (- 141),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__AUTO_OFFSET_RESET = (- 140),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__LOG_TRUNCATION = (- 139),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__END = (- 100),</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN = (- 1),</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NO_ERROR = 0,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_OUT_OF_RANGE = 1,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_MSG = 2,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART = 3,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_MSG_SIZE = 4,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE = 5,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_LEADER_FOR_PARTITION = 6,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REQUEST_TIMED_OUT = 7,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_BROKER_NOT_AVAILABLE = 8,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REPLICA_NOT_AVAILABLE = 9,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE = 10,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_STALE_CTRL_EPOCH = 11,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_METADATA_TOO_LARGE = 12,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NETWORK_EXCEPTION = 13,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_COORDINATOR_LOAD_IN_PROGRESS = 14,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_COORDINATOR_NOT_AVAILABLE = 15,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_COORDINATOR = 16,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_EXCEPTION = 17,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_RECORD_LIST_TOO_LARGE = 18,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS = 19,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS_AFTER_APPEND = 20,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REQUIRED_ACKS = 21,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ILLEGAL_GENERATION = 22,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INCONSISTENT_GROUP_PROTOCOL = 23,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_GROUP_ID = 24,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_MEMBER_ID = 25,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_SESSION_TIMEOUT = 26,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REBALANCE_IN_PROGRESS = 27,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_COMMIT_OFFSET_SIZE = 28,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_AUTHORIZATION_FAILED = 29,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_AUTHORIZATION_FAILED = 30,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_CLUSTER_AUTHORIZATION_FAILED = 31,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TIMESTAMP = 32,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_SASL_MECHANISM = 33,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ILLEGAL_SASL_STATE = 34,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_VERSION = 35,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_ALREADY_EXISTS = 36,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PARTITIONS = 37,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REPLICATION_FACTOR = 38,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REPLICA_ASSIGNMENT = 39,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_CONFIG = 40,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_CONTROLLER = 41,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REQUEST = 42,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_FOR_MESSAGE_FORMAT = 43,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_POLICY_VIOLATION = 44,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OUT_OF_ORDER_SEQUENCE_NUMBER = 45,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DUPLICATE_SEQUENCE_NUMBER = 46,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_EPOCH = 47,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TXN_STATE = 48,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_ID_MAPPING = 49,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TRANSACTION_TIMEOUT = 50,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_CONCURRENT_TRANSACTIONS = 51,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TRANSACTION_COORDINATOR_FENCED = 52,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TRANSACTIONAL_ID_AUTHORIZATION_FAILED = 53,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_SECURITY_DISABLED = 54,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OPERATION_NOT_ATTEMPTED = 55,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_KAFKA_STORAGE_ERROR = 56,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LOG_DIR_NOT_FOUND = 57,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_SASL_AUTHENTICATION_FAILED = 58,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_PRODUCER_ID = 59,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REASSIGNMENT_IN_PROGRESS = 60,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTH_DISABLED = 61,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_NOT_FOUND = 62,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_OWNER_MISMATCH = 63,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_REQUEST_NOT_ALLOWED = 64,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTHORIZATION_FAILED = 65,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_EXPIRED = 66,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRINCIPAL_TYPE = 67,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NON_EMPTY_GROUP = 68,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_ID_NOT_FOUND = 69,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FETCH_SESSION_ID_NOT_FOUND = 70,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_FETCH_SESSION_EPOCH = 71,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LISTENER_NOT_FOUND = 72,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_DELETION_DISABLED = 73,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FENCED_LEADER_EPOCH = 74,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_LEADER_EPOCH = 75,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_STALE_BROKER_EPOCH = 77,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_NOT_AVAILABLE = 78,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_MEMBER_ID_REQUIRED = 79,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_PREFERRED_LEADER_NOT_AVAILABLE = 80,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_MAX_SIZE_REACHED = 81,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FENCED_INSTANCE_ID = 82,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ELIGIBLE_LEADERS_NOT_AVAILABLE = 83,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ELECTION_NOT_NEEDED = 84,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NO_REASSIGNMENT_IN_PROGRESS = 85,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_SUBSCRIBED_TO_TOPIC = 86,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_RECORD = 87,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSTABLE_OFFSET_COMMIT = 88,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_THROTTLING_QUOTA_EXCEEDED = 89,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_PRODUCER_FENCED = 90,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_RESOURCE_NOT_FOUND = 91,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DUPLICATE_RESOURCE = 92,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNACCEPTABLE_CREDENTIAL = 93,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INCONSISTENT_VOTER_SET = 94,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_UPDATE_VERSION = 95,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FEATURE_UPDATE_FAILED = 96,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_PRINCIPAL_DESERIALIZATION_FAILURE = 97,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_END_ALL,</span>
<span class="s1">} rd_kafka_resp_err_t;</span>
<span class="s1">struct rd_kafka_err_desc {</span>
<span class="s1">  rd_kafka_resp_err_t code;</span>
<span class="s1">  char *name;</span>
<span class="s1">  char *desc;</span>
<span class="s1">};</span>
<span class="s1">void rd_kafka_get_err_descs(const struct rd_kafka_err_desc **errdescs, size_t *cntp);</span>
<span class="s1">const char *rd_kafka_err2str(rd_kafka_resp_err_t err);</span>
<span class="s1">const char *rd_kafka_err2name(rd_kafka_resp_err_t err);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_last_error(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_errno2err(int errnox);</span>
<span class="s1">int rd_kafka_errno(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_fatal_error(rd_kafka_t *rk, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_test_fatal_error(rd_kafka_t *rk, rd_kafka_resp_err_t err, const char *reason);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_error_code(const rd_kafka_error_t *error);</span>
<span class="s1">const char *rd_kafka_error_name(const rd_kafka_error_t *error);</span>
<span class="s1">const char *rd_kafka_error_string(const rd_kafka_error_t *error);</span>
<span class="s1">int rd_kafka_error_is_fatal(const rd_kafka_error_t *error);</span>
<span class="s1">int rd_kafka_error_is_retriable(const rd_kafka_error_t *error);</span>
<span class="s1">int rd_kafka_error_txn_requires_abort(const rd_kafka_error_t *error);</span>
<span class="s1">void rd_kafka_error_destroy(rd_kafka_error_t *error);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_error_new(rd_kafka_resp_err_t code, const char *fmt, ...);</span>
<span class="s1">typedef struct rd_kafka_topic_partition_s {</span>
<span class="s1">  char *topic;</span>
<span class="s1">  int32_t partition;</span>
<span class="s1">  int64_t offset;</span>
<span class="s1">  void *metadata;</span>
<span class="s1">  size_t metadata_size;</span>
<span class="s1">  void *opaque;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  void *_private;</span>
<span class="s1">} rd_kafka_topic_partition_t;</span>
<span class="s1">void rd_kafka_topic_partition_destroy(rd_kafka_topic_partition_t *rktpar);</span>
<span class="s1">void rd_kafka_topic_partition_set_leader_epoch(rd_kafka_topic_partition_t *rktpar, int32_t leader_epoch);</span>
<span class="s1">int32_t rd_kafka_topic_partition_get_leader_epoch(const rd_kafka_topic_partition_t *rktpar);</span>
<span class="s1">typedef struct rd_kafka_topic_partition_list_s {</span>
<span class="s1">  int cnt;</span>
<span class="s1">  int size;</span>
<span class="s1">  rd_kafka_topic_partition_t *elems;</span>
<span class="s1">} rd_kafka_topic_partition_list_t;</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_new(int size);</span>
<span class="s1">void rd_kafka_topic_partition_list_destroy(rd_kafka_topic_partition_list_t *rkparlist);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_add(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">void rd_kafka_topic_partition_list_add_range(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t start, int32_t stop);</span>
<span class="s1">int rd_kafka_topic_partition_list_del(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">int rd_kafka_topic_partition_list_del_by_idx(rd_kafka_topic_partition_list_t *rktparlist, int idx);</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_copy(const rd_kafka_topic_partition_list_t *src);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_topic_partition_list_set_offset(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition, int64_t offset);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_find(const rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">void rd_kafka_topic_partition_list_sort(rd_kafka_topic_partition_list_t *rktparlist, int (*cmp)(const void *a, const void *b, void *cmp_opaque), void *cmp_opaque);</span>
<span class="s1">typedef enum rd_kafka_vtype_t {</span>
<span class="s1">  RD_KAFKA_VTYPE_END,</span>
<span class="s1">  RD_KAFKA_VTYPE_TOPIC,</span>
<span class="s1">  RD_KAFKA_VTYPE_RKT,</span>
<span class="s1">  RD_KAFKA_VTYPE_PARTITION,</span>
<span class="s1">  RD_KAFKA_VTYPE_VALUE,</span>
<span class="s1">  RD_KAFKA_VTYPE_KEY,</span>
<span class="s1">  RD_KAFKA_VTYPE_OPAQUE,</span>
<span class="s1">  RD_KAFKA_VTYPE_MSGFLAGS,</span>
<span class="s1">  RD_KAFKA_VTYPE_TIMESTAMP,</span>
<span class="s1">  RD_KAFKA_VTYPE_HEADER,</span>
<span class="s1">  RD_KAFKA_VTYPE_HEADERS,</span>
<span class="s1">} rd_kafka_vtype_t;</span>
<span class="s1">typedef struct rd_kafka_vu_s {</span>
<span class="s1">  rd_kafka_vtype_t vtype;</span>
<span class="s1">  union {</span>
<span class="s1">    char *cstr;</span>
<span class="s1">    rd_kafka_topic_t *rkt;</span>
<span class="s1">    int i;</span>
<span class="s1">    int32_t i32;</span>
<span class="s1">    int64_t i64;</span>
<span class="s1">    struct {</span>
<span class="s1">      void *ptr;</span>
<span class="s1">      size_t size;</span>
<span class="s1">    } mem;</span>
<span class="s1">    struct {</span>
<span class="s1">      char *name;</span>
<span class="s1">      void *val;</span>
<span class="s1">      ssize_t size;</span>
<span class="s1">    } header;</span>
<span class="s1">    rd_kafka_headers_t *headers;</span>
<span class="s1">    void *ptr;</span>
<span class="s1">    char _pad[64];</span>
<span class="s1">  } u;</span>
<span class="s1">} rd_kafka_vu_t;</span>
<span class="s1">rd_kafka_headers_t *rd_kafka_headers_new(size_t initial_count);</span>
<span class="s1">void rd_kafka_headers_destroy(rd_kafka_headers_t *hdrs);</span>
<span class="s1">rd_kafka_headers_t *rd_kafka_headers_copy(const rd_kafka_headers_t *src);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_add(rd_kafka_headers_t *hdrs, const char *name, ssize_t name_size, const void *value, ssize_t value_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_remove(rd_kafka_headers_t *hdrs, const char *name);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get_last(const rd_kafka_headers_t *hdrs, const char *name, const void **valuep, size_t *sizep);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get(const rd_kafka_headers_t *hdrs, size_t idx, const char *name, const void **valuep, size_t *sizep);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get_all(const rd_kafka_headers_t *hdrs, size_t idx, const char **namep, const void **valuep, size_t *sizep);</span>
<span class="s1">typedef struct rd_kafka_message_s {</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  rd_kafka_topic_t *rkt;</span>
<span class="s1">  int32_t partition;</span>
<span class="s1">  void *payload;</span>
<span class="s1">  size_t len;</span>
<span class="s1">  void *key;</span>
<span class="s1">  size_t key_len;</span>
<span class="s1">  int64_t offset;</span>
<span class="s1">  void *_private;</span>
<span class="s1">} rd_kafka_message_t;</span>
<span class="s1">void rd_kafka_message_destroy(rd_kafka_message_t *rkmessage);</span>
<span class="s1">const char *rd_kafka_message_errstr(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">int64_t rd_kafka_message_timestamp(const rd_kafka_message_t *rkmessage, rd_kafka_timestamp_type_t *tstype);</span>
<span class="s1">int64_t rd_kafka_message_latency(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">int32_t rd_kafka_message_broker_id(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_message_headers(const rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_message_detach_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);</span>
<span class="s1">void rd_kafka_message_set_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t *hdrs);</span>
<span class="s1">size_t rd_kafka_header_cnt(const rd_kafka_headers_t *hdrs);</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_NOT_PERSISTED = 0,</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_POSSIBLY_PERSISTED = 1,</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_PERSISTED = 2,</span>
<span class="s1">} rd_kafka_msg_status_t;</span>
<span class="s1">rd_kafka_msg_status_t rd_kafka_message_status(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">int32_t rd_kafka_message_leader_epoch(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_CONF_UNKNOWN = (- 2),</span>
<span class="s1">  RD_KAFKA_CONF_INVALID = (- 1),</span>
<span class="s1">  RD_KAFKA_CONF_OK = 0,</span>
<span class="s1">} rd_kafka_conf_res_t;</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_new(void);</span>
<span class="s1">void rd_kafka_conf_destroy(rd_kafka_conf_t *conf);</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_dup(const rd_kafka_conf_t *conf);</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_dup_filter(const rd_kafka_conf_t *conf, size_t filter_cnt, const char **filter);</span>
<span class="s1">const rd_kafka_conf_t *rd_kafka_conf(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_set(rd_kafka_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_conf_set_events(rd_kafka_conf_t *conf, int events);</span>
<span class="s1">void rd_kafka_conf_set_background_event_cb(rd_kafka_conf_t *conf, void (*event_cb)(rd_kafka_t *rk, rd_kafka_event_t *rkev, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_dr_cb(rd_kafka_conf_t *conf, void (*dr_cb)(rd_kafka_t *rk, void *payload, size_t len, rd_kafka_resp_err_t err, void *opaque, void *msg_opaque));</span>
<span class="s1">void rd_kafka_conf_set_dr_msg_cb(rd_kafka_conf_t *conf, void (*dr_msg_cb)(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_consume_cb(rd_kafka_conf_t *conf, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_rebalance_cb(rd_kafka_conf_t *conf, void (*rebalance_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *partitions, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_offset_commit_cb(rd_kafka_conf_t *conf, void (*offset_commit_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_error_cb(rd_kafka_conf_t *conf, void (*error_cb)(rd_kafka_t *rk, int err, const char *reason, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_throttle_cb(rd_kafka_conf_t *conf, void (*throttle_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int throttle_time_ms, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_log_cb(rd_kafka_conf_t *conf, void (*log_cb)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));</span>
<span class="s1">void rd_kafka_conf_set_stats_cb(rd_kafka_conf_t *conf, int (*stats_cb)(rd_kafka_t *rk, char *json, size_t json_len, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_oauthbearer_token_refresh_cb(rd_kafka_conf_t *conf, void (*oauthbearer_token_refresh_cb)(rd_kafka_t *rk, const char *oauthbearer_config, void *opaque));</span>
<span class="s1">void rd_kafka_conf_enable_sasl_queue(rd_kafka_conf_t *conf, int enable);</span>
<span class="s1">void rd_kafka_conf_set_socket_cb(rd_kafka_conf_t *conf, int (*socket_cb)(int domain, int type, int protocol, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_connect_cb(rd_kafka_conf_t *conf, int (*connect_cb)(int sockfd, const struct sockaddr *addr, int addrlen, const char *id, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_closesocket_cb(rd_kafka_conf_t *conf, int (*closesocket_cb)(int sockfd, void *opaque));</span>
<span class="s1">struct addrinfo;</span>
<span class="s1">void rd_kafka_conf_set_resolve_cb(rd_kafka_conf_t *conf, int (*resolve_cb)(const char *node, const char *service, const struct addrinfo *hints, struct addrinfo **res, void *opaque));</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert_verify_cb(rd_kafka_conf_t *conf, int (*ssl_cert_verify_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int *x509_error, int depth, const char *buf, size_t size, char *errstr, size_t errstr_size, void *opaque));</span>
<span class="s1">typedef enum rd_kafka_cert_type_t {</span>
<span class="s1">  RD_KAFKA_CERT_PUBLIC_KEY,</span>
<span class="s1">  RD_KAFKA_CERT_PRIVATE_KEY,</span>
<span class="s1">  RD_KAFKA_CERT_CA,</span>
<span class="s1">  RD_KAFKA_CERT__CNT,</span>
<span class="s1">} rd_kafka_cert_type_t;</span>
<span class="s1">typedef enum rd_kafka_cert_enc_t {</span>
<span class="s1">  RD_KAFKA_CERT_ENC_PKCS12,</span>
<span class="s1">  RD_KAFKA_CERT_ENC_DER,</span>
<span class="s1">  RD_KAFKA_CERT_ENC_PEM,</span>
<span class="s1">  RD_KAFKA_CERT_ENC__CNT,</span>
<span class="s1">} rd_kafka_cert_enc_t;</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert(rd_kafka_conf_t *conf, rd_kafka_cert_type_t cert_type, rd_kafka_cert_enc_t cert_enc, const void *buffer, size_t size, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_conf_set_engine_callback_data(rd_kafka_conf_t *conf, void *callback_data);</span>
<span class="s1">void rd_kafka_conf_set_opaque(rd_kafka_conf_t *conf, void *opaque);</span>
<span class="s1">void *rd_kafka_opaque(const rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_conf_set_default_topic_conf(rd_kafka_conf_t *conf, rd_kafka_topic_conf_t *tconf);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_conf_get_default_topic_conf(rd_kafka_conf_t *conf);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_get(const rd_kafka_conf_t *conf, const char *name, char *dest, size_t *dest_size);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_topic_conf_get(const rd_kafka_topic_conf_t *conf, const char *name, char *dest, size_t *dest_size);</span>
<span class="s1">const char **rd_kafka_conf_dump(rd_kafka_conf_t *conf, size_t *cntp);</span>
<span class="s1">const char **rd_kafka_topic_conf_dump(rd_kafka_topic_conf_t *conf, size_t *cntp);</span>
<span class="s1">void rd_kafka_conf_dump_free(const char **arr, size_t cnt);</span>
<span class="s1">void rd_kafka_conf_properties_show(FILE *fp);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_topic_conf_new(void);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_topic_conf_dup(const rd_kafka_topic_conf_t *conf);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_default_topic_conf_dup(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_topic_conf_destroy(rd_kafka_topic_conf_t *topic_conf);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_topic_conf_set(rd_kafka_topic_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_topic_conf_set_opaque(rd_kafka_topic_conf_t *conf, void *rkt_opaque);</span>
<span class="s1">void rd_kafka_topic_conf_set_partitioner_cb(rd_kafka_topic_conf_t *topic_conf, int32_t (*partitioner)(const rd_kafka_topic_t *rkt, const void *keydata, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque));</span>
<span class="s1">void rd_kafka_topic_conf_set_msg_order_cmp(rd_kafka_topic_conf_t *topic_conf, int (*msg_order_cmp)(const rd_kafka_message_t *a, const rd_kafka_message_t *b));</span>
<span class="s1">int rd_kafka_topic_partition_available(const rd_kafka_topic_t *rkt, int32_t partition);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_consistent(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_consistent_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_murmur2(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_murmur2_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_fnv1a(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_fnv1a_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">rd_kafka_t *rd_kafka_new(rd_kafka_type_t type, rd_kafka_conf_t *conf, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_destroy(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_destroy_flags(rd_kafka_t *rk, int flags);</span>
<span class="s1">const char *rd_kafka_name(const rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_type_t rd_kafka_type(const rd_kafka_t *rk);</span>
<span class="s1">char *rd_kafka_memberid(const rd_kafka_t *rk);</span>
<span class="s1">char *rd_kafka_clusterid(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">int32_t rd_kafka_controllerid(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_topic_t *rd_kafka_topic_new(rd_kafka_t *rk, const char *topic, rd_kafka_topic_conf_t *conf);</span>
<span class="s1">void rd_kafka_topic_destroy(rd_kafka_topic_t *rkt);</span>
<span class="s1">const char *rd_kafka_topic_name(const rd_kafka_topic_t *rkt);</span>
<span class="s1">void *rd_kafka_topic_opaque(const rd_kafka_topic_t *rkt);</span>
<span class="s1">int rd_kafka_poll(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">void rd_kafka_yield(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_pause_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_resume_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_query_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_get_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offsets_for_times(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets, int timeout_ms);</span>
<span class="s1">void *rd_kafka_mem_calloc(rd_kafka_t *rk, size_t num, size_t size);</span>
<span class="s1">void *rd_kafka_mem_malloc(rd_kafka_t *rk, size_t size);</span>
<span class="s1">void rd_kafka_mem_free(rd_kafka_t *rk, void *ptr);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_new(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_queue_destroy(rd_kafka_queue_t *rkqu);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_main(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_sasl(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_sasl_background_callbacks_enable(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_sasl_set_credentials(rd_kafka_t *rk, const char *username, const char *password);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_consumer(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_partition(rd_kafka_t *rk, const char *topic, int32_t partition);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_background(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_queue_forward(rd_kafka_queue_t *src, rd_kafka_queue_t *dst);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_set_log_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu);</span>
<span class="s1">size_t rd_kafka_queue_length(rd_kafka_queue_t *rkqu);</span>
<span class="s1">void rd_kafka_queue_io_event_enable(rd_kafka_queue_t *rkqu, int fd, const void *payload, size_t size);</span>
<span class="s1">void rd_kafka_queue_cb_event_enable(rd_kafka_queue_t *rkqu, void (*event_cb)(rd_kafka_t *rk, void *qev_opaque), void *qev_opaque);</span>
<span class="s1">void rd_kafka_queue_yield(rd_kafka_queue_t *rkqu);</span>
<span class="s1">int rd_kafka_consume_start(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);</span>
<span class="s1">int rd_kafka_consume_start_queue(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, rd_kafka_queue_t *rkqu);</span>
<span class="s1">int rd_kafka_consume_stop(rd_kafka_topic_t *rkt, int32_t partition);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_seek(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, int timeout_ms);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_seek_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consume(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms);</span>
<span class="s1">ssize_t rd_kafka_consume_batch(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);</span>
<span class="s1">int rd_kafka_consume_callback(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consume_queue(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">ssize_t rd_kafka_consume_batch_queue(rd_kafka_queue_t *rkqu, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);</span>
<span class="s1">int rd_kafka_consume_callback_queue(rd_kafka_queue_t *rkqu, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offset_store(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offsets_store(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_offset_store_message(rd_kafka_message_t *rkmessage);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_subscribe(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *topics);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_unsubscribe(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_subscription(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **topics);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consumer_poll(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_consumer_close(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_consumer_close_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu);</span>
<span class="s1">int rd_kafka_consumer_closed(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_incremental_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_incremental_unassign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">const char *rd_kafka_rebalance_protocol(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_assignment(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **partitions);</span>
<span class="s1">int rd_kafka_assignment_lost(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, int async);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit_message(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, int async);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit_queue(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_queue_t *rkqu, void (*cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *commit_opaque), void *commit_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_committed(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_position(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata_new(const char *group_id);</span>
<span class="s1">rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata_new_with_genid(const char *group_id, int32_t generation_id, const char *member_id, const char *group_instance_id);</span>
<span class="s1">void rd_kafka_consumer_group_metadata_destroy(rd_kafka_consumer_group_metadata_t *);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_consumer_group_metadata_write(const rd_kafka_consumer_group_metadata_t *cgmd, void **bufferp, size_t *sizep);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_consumer_group_metadata_read(rd_kafka_consumer_group_metadata_t **cgmdp, const void *buffer, size_t size);</span>
<span class="s1">int rd_kafka_produce(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, void *payload, size_t len, const void *key, size_t keylen, void *msg_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_producev(rd_kafka_t *rk, ...);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_produceva(rd_kafka_t *rk, const rd_kafka_vu_t *vus, size_t cnt);</span>
<span class="s1">int rd_kafka_produce_batch(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, rd_kafka_message_t *rkmessages, int message_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_flush(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_purge(rd_kafka_t *rk, int purge_flags);</span>
<span class="s1">typedef struct rd_kafka_metadata_broker {</span>
<span class="s1">  int32_t id;</span>
<span class="s1">  char *host;</span>
<span class="s1">  int port;</span>
<span class="s1">} rd_kafka_metadata_broker_t;</span>
<span class="s1">typedef struct rd_kafka_metadata_partition {</span>
<span class="s1">  int32_t id;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  int32_t leader;</span>
<span class="s1">  int replica_cnt;</span>
<span class="s1">  int32_t *replicas;</span>
<span class="s1">  int isr_cnt;</span>
<span class="s1">  int32_t *isrs;</span>
<span class="s1">} rd_kafka_metadata_partition_t;</span>
<span class="s1">typedef struct rd_kafka_metadata_topic {</span>
<span class="s1">  char *topic;</span>
<span class="s1">  int partition_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_partition *partitions;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">} rd_kafka_metadata_topic_t;</span>
<span class="s1">typedef struct rd_kafka_metadata {</span>
<span class="s1">  int broker_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_broker *brokers;</span>
<span class="s1">  int topic_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_topic *topics;</span>
<span class="s1">  int32_t orig_broker_id;</span>
<span class="s1">  char *orig_broker_name;</span>
<span class="s1">} rd_kafka_metadata_t;</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_metadata(rd_kafka_t *rk, int all_topics, rd_kafka_topic_t *only_rkt, const struct rd_kafka_metadata **metadatap, int timeout_ms);</span>
<span class="s1">void rd_kafka_metadata_destroy(const struct rd_kafka_metadata *metadata);</span>
<span class="s1">typedef struct rd_kafka_Node_s rd_kafka_Node_t;</span>
<span class="s1">int rd_kafka_Node_id(const rd_kafka_Node_t *node);</span>
<span class="s1">const char *rd_kafka_Node_host(const rd_kafka_Node_t *node);</span>
<span class="s1">uint16_t rd_kafka_Node_port(const rd_kafka_Node_t *node);</span>
<span class="s1">struct rd_kafka_group_member_info {</span>
<span class="s1">  char *member_id;</span>
<span class="s1">  char *client_id;</span>
<span class="s1">  char *client_host;</span>
<span class="s1">  void *member_metadata;</span>
<span class="s1">  int member_metadata_size;</span>
<span class="s1">  void *member_assignment;</span>
<span class="s1">  int member_assignment_size;</span>
<span class="s1">};</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_CONSUMER_GROUP_STATE_UNKNOWN = 0,</span>
<span class="s1">  RD_KAFKA_CONSUMER_GROUP_STATE_PREPARING_REBALANCE = 1,</span>
<span class="s1">  RD_KAFKA_CONSUMER_GROUP_STATE_COMPLETING_REBALANCE = 2,</span>
<span class="s1">  RD_KAFKA_CONSUMER_GROUP_STATE_STABLE = 3,</span>
<span class="s1">  RD_KAFKA_CONSUMER_GROUP_STATE_DEAD = 4,</span>
<span class="s1">  RD_KAFKA_CONSUMER_GROUP_STATE_EMPTY = 5,</span>
<span class="s1">  RD_KAFKA_CONSUMER_GROUP_STATE__CNT,</span>
<span class="s1">} rd_kafka_consumer_group_state_t;</span>
<span class="s1">struct rd_kafka_group_info {</span>
<span class="s1">  struct rd_kafka_metadata_broker broker;</span>
<span class="s1">  char *group;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  char *state;</span>
<span class="s1">  char *protocol_type;</span>
<span class="s1">  char *protocol;</span>
<span class="s1">  struct rd_kafka_group_member_info *members;</span>
<span class="s1">  int member_cnt;</span>
<span class="s1">};</span>
<span class="s1">struct rd_kafka_group_list {</span>
<span class="s1">  struct rd_kafka_group_info *groups;</span>
<span class="s1">  int group_cnt;</span>
<span class="s1">};</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_list_groups(rd_kafka_t *rk, const char *group, const struct rd_kafka_group_list **grplistp, int timeout_ms);</span>
<span class="s1">const char *rd_kafka_consumer_group_state_name(rd_kafka_consumer_group_state_t state);</span>
<span class="s1">rd_kafka_consumer_group_state_t rd_kafka_consumer_group_state_code(const char *name);</span>
<span class="s1">void rd_kafka_group_list_destroy(const struct rd_kafka_group_list *grplist);</span>
<span class="s1">int rd_kafka_brokers_add(rd_kafka_t *rk, const char *brokerlist);</span>
<span class="s1">void rd_kafka_set_logger(rd_kafka_t *rk, void (*func)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));</span>
<span class="s1">void rd_kafka_set_log_level(rd_kafka_t *rk, int level);</span>
<span class="s1">void rd_kafka_log_print(const rd_kafka_t *rk, int level, const char *fac, const char *buf);</span>
<span class="s1">void rd_kafka_log_syslog(const rd_kafka_t *rk, int level, const char *fac, const char *buf);</span>
<span class="s1">int rd_kafka_outq_len(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_dump(FILE *fp, rd_kafka_t *rk);</span>
<span class="s1">int rd_kafka_thread_cnt(void);</span>
<span class="s1">typedef enum rd_kafka_thread_type_t {</span>
<span class="s1">  RD_KAFKA_THREAD_MAIN,</span>
<span class="s1">  RD_KAFKA_THREAD_BACKGROUND,</span>
<span class="s1">  RD_KAFKA_THREAD_BROKER,</span>
<span class="s1">} rd_kafka_thread_type_t;</span>
<span class="s1">int rd_kafka_wait_destroyed(int timeout_ms);</span>
<span class="s1">int rd_kafka_unittest(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_poll_set_consumer(rd_kafka_t *rk);</span>
<span class="s1">typedef int rd_kafka_event_type_t;</span>
<span class="s1">rd_kafka_event_type_t rd_kafka_event_type(const rd_kafka_event_t *rkev);</span>
<span class="s1">const char *rd_kafka_event_name(const rd_kafka_event_t *rkev);</span>
<span class="s1">void rd_kafka_event_destroy(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_message_t *rd_kafka_event_message_next(rd_kafka_event_t *rkev);</span>
<span class="s1">size_t rd_kafka_event_message_array(rd_kafka_event_t *rkev, const rd_kafka_message_t **rkmessages, size_t size);</span>
<span class="s1">size_t rd_kafka_event_message_count(rd_kafka_event_t *rkev);</span>
<span class="s1">const char *rd_kafka_event_config_string(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_event_error(rd_kafka_event_t *rkev);</span>
<span class="s1">const char *rd_kafka_event_error_string(rd_kafka_event_t *rkev);</span>
<span class="s1">int rd_kafka_event_error_is_fatal(rd_kafka_event_t *rkev);</span>
<span class="s1">void *rd_kafka_event_opaque(rd_kafka_event_t *rkev);</span>
<span class="s1">int rd_kafka_event_log(rd_kafka_event_t *rkev, const char **fac, const char **str, int *level);</span>
<span class="s1">int rd_kafka_event_debug_contexts(rd_kafka_event_t *rkev, char *dst, size_t dstsize);</span>
<span class="s1">const char *rd_kafka_event_stats(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_event_topic_partition_list(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_event_topic_partition(rd_kafka_event_t *rkev);</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_CreateTopics_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DeleteTopics_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_CreateAcls_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DescribeAcls_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DeleteAcls_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_CreatePartitions_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_AlterConfigs_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_IncrementalAlterConfigs_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DescribeConfigs_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DeleteRecords_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_ListConsumerGroups_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DescribeConsumerGroups_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DeleteGroups_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DeleteConsumerGroupOffsets_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_AlterConsumerGroupOffsets_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_ListConsumerGroupOffsets_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DescribeUserScramCredentials_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_AlterUserScramCredentials_result_t;</span>
<span class="s1">const rd_kafka_CreateTopics_result_t *rd_kafka_event_CreateTopics_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DeleteTopics_result_t *rd_kafka_event_DeleteTopics_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_CreatePartitions_result_t *rd_kafka_event_CreatePartitions_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_AlterConfigs_result_t *rd_kafka_event_AlterConfigs_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_IncrementalAlterConfigs_result_t *rd_kafka_event_IncrementalAlterConfigs_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DescribeConfigs_result_t *rd_kafka_event_DescribeConfigs_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DeleteRecords_result_t *rd_kafka_event_DeleteRecords_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_ListConsumerGroups_result_t *rd_kafka_event_ListConsumerGroups_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DescribeConsumerGroups_result_t *rd_kafka_event_DescribeConsumerGroups_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DeleteGroups_result_t *rd_kafka_event_DeleteGroups_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DeleteConsumerGroupOffsets_result_t *rd_kafka_event_DeleteConsumerGroupOffsets_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_CreateAcls_result_t *rd_kafka_event_CreateAcls_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DescribeAcls_result_t *rd_kafka_event_DescribeAcls_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DeleteAcls_result_t *rd_kafka_event_DeleteAcls_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_ListConsumerGroupOffsets_result_t *rd_kafka_event_ListConsumerGroupOffsets_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_AlterConsumerGroupOffsets_result_t *rd_kafka_event_AlterConsumerGroupOffsets_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DescribeUserScramCredentials_result_t *rd_kafka_event_DescribeUserScramCredentials_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_AlterUserScramCredentials_result_t *rd_kafka_event_AlterUserScramCredentials_result(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_event_t *rd_kafka_queue_poll(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">int rd_kafka_queue_poll_callback(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_plugin_f_conf_init_t)(rd_kafka_conf_t *conf, void **plug_opaquep, char *errstr, size_t errstr_size);</span>
<span class="s1">typedef rd_kafka_conf_res_t (rd_kafka_interceptor_f_on_conf_set_t)(rd_kafka_conf_t *conf, const char *name, const char *val, char *errstr, size_t errstr_size, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_dup_t)(rd_kafka_conf_t *new_conf, const rd_kafka_conf_t *old_conf, size_t filter_cnt, const char **filter, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_destroy_t)(void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_new_t)(rd_kafka_t *rk, const rd_kafka_conf_t *conf, void *ic_opaque, char *errstr, size_t errstr_size);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_destroy_t)(rd_kafka_t *rk, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_send_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_acknowledgement_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_consume_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_commit_t)(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_resp_err_t err, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_request_sent_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_response_received_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, int64_t rtt, rd_kafka_resp_err_t err, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_start_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_exit_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_broker_state_change_t)(rd_kafka_t *rk, int32_t broker_id, const char *secproto, const char *name, int port, const char *state, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_set(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_set_t *on_conf_set, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_dup(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_dup_t *on_conf_dup, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_destroy(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_destroy_t *on_conf_destroy, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_new(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_new_t *on_new, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_destroy(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_destroy_t *on_destroy, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_send(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_send_t *on_send, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_acknowledgement(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_acknowledgement_t *on_acknowledgement, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_consume(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_consume_t *on_consume, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_commit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_commit_t *on_commit, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_request_sent(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_request_sent_t *on_request_sent, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_response_received(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_response_received_t *on_response_received, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_start(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_start_t *on_thread_start, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_exit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_exit_t *on_thread_exit, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_broker_state_change(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_broker_state_change_t *on_broker_state_change, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_topic_result_error(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">const char *rd_kafka_topic_result_error_string(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">const char *rd_kafka_topic_result_name(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">const rd_kafka_error_t *rd_kafka_group_result_error(const rd_kafka_group_result_t *groupres);</span>
<span class="s1">const char *rd_kafka_group_result_name(const rd_kafka_group_result_t *groupres);</span>
<span class="s1">const rd_kafka_topic_partition_list_t *rd_kafka_group_result_partitions(const rd_kafka_group_result_t *groupres);</span>
<span class="s1">typedef enum rd_kafka_admin_op_t {</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_ANY = 0,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_CREATETOPICS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DELETETOPICS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_CREATEPARTITIONS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_ALTERCONFIGS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DESCRIBECONFIGS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DELETERECORDS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DELETEGROUPS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DELETECONSUMERGROUPOFFSETS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_CREATEACLS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DESCRIBEACLS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DELETEACLS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_LISTCONSUMERGROUPS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DESCRIBECONSUMERGROUPS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_LISTCONSUMERGROUPOFFSETS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_ALTERCONSUMERGROUPOFFSETS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_INCREMENTALALTERCONFIGS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DESCRIBEUSERSCRAMCREDENTIALS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_ALTERUSERSCRAMCREDENTIALS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP__CNT,</span>
<span class="s1">} rd_kafka_admin_op_t;</span>
<span class="s1">typedef struct rd_kafka_AdminOptions_s rd_kafka_AdminOptions_t;</span>
<span class="s1">rd_kafka_AdminOptions_t *rd_kafka_AdminOptions_new(rd_kafka_t *rk, rd_kafka_admin_op_t for_api);</span>
<span class="s1">void rd_kafka_AdminOptions_destroy(rd_kafka_AdminOptions_t *options);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_request_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_operation_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_validate_only(rd_kafka_AdminOptions_t *options, int true_or_false, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_broker(rd_kafka_AdminOptions_t *options, int32_t broker_id, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_AdminOptions_set_require_stable_offsets(rd_kafka_AdminOptions_t *options, int true_or_false);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_AdminOptions_set_match_consumer_group_states(rd_kafka_AdminOptions_t *options, const rd_kafka_consumer_group_state_t *consumer_group_states, size_t consumer_group_states_cnt);</span>
<span class="s1">void rd_kafka_AdminOptions_set_opaque(rd_kafka_AdminOptions_t *options, void *ev_opaque);</span>
<span class="s1">typedef struct rd_kafka_NewTopic_s rd_kafka_NewTopic_t;</span>
<span class="s1">rd_kafka_NewTopic_t *rd_kafka_NewTopic_new(const char *topic, int num_partitions, int replication_factor, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_NewTopic_destroy(rd_kafka_NewTopic_t *new_topic);</span>
<span class="s1">void rd_kafka_NewTopic_destroy_array(rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewTopic_set_replica_assignment(rd_kafka_NewTopic_t *new_topic, int32_t partition, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewTopic_set_config(rd_kafka_NewTopic_t *new_topic, const char *name, const char *value);</span>
<span class="s1">void rd_kafka_CreateTopics(rd_kafka_t *rk, rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_CreateTopics_result_topics(const rd_kafka_CreateTopics_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_DeleteTopic_s rd_kafka_DeleteTopic_t;</span>
<span class="s1">rd_kafka_DeleteTopic_t *rd_kafka_DeleteTopic_new(const char *topic);</span>
<span class="s1">void rd_kafka_DeleteTopic_destroy(rd_kafka_DeleteTopic_t *del_topic);</span>
<span class="s1">void rd_kafka_DeleteTopic_destroy_array(rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt);</span>
<span class="s1">void rd_kafka_DeleteTopics(rd_kafka_t *rk, rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_DeleteTopics_result_topics(const rd_kafka_DeleteTopics_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_NewPartitions_s rd_kafka_NewPartitions_t;</span>
<span class="s1">rd_kafka_NewPartitions_t *rd_kafka_NewPartitions_new(const char *topic, size_t new_total_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_NewPartitions_destroy(rd_kafka_NewPartitions_t *new_parts);</span>
<span class="s1">void rd_kafka_NewPartitions_destroy_array(rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewPartitions_set_replica_assignment(rd_kafka_NewPartitions_t *new_parts, int32_t new_partition_idx, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_CreatePartitions(rd_kafka_t *rk, rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_CreatePartitions_result_topics(const rd_kafka_CreatePartitions_result_t *result, size_t *cntp);</span>
<span class="s1">typedef enum rd_kafka_ConfigSource_t {</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_UNKNOWN_CONFIG = 0,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_TOPIC_CONFIG = 1,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_BROKER_CONFIG = 2,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_DEFAULT_BROKER_CONFIG = 3,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_STATIC_BROKER_CONFIG = 4,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DEFAULT_CONFIG = 5,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE__CNT,</span>
<span class="s1">} rd_kafka_ConfigSource_t;</span>
<span class="s1">const char *rd_kafka_ConfigSource_name(rd_kafka_ConfigSource_t confsource);</span>
<span class="s1">typedef struct rd_kafka_ConfigEntry_s rd_kafka_ConfigEntry_t;</span>
<span class="s1">const char *rd_kafka_ConfigEntry_name(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">const char *rd_kafka_ConfigEntry_value(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">rd_kafka_ConfigSource_t rd_kafka_ConfigEntry_source(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_read_only(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_default(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_sensitive(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_synonym(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">const rd_kafka_ConfigEntry_t **rd_kafka_ConfigEntry_synonyms(const rd_kafka_ConfigEntry_t *entry, size_t *cntp);</span>
<span class="s1">typedef enum rd_kafka_ResourceType_t {</span>
<span class="s1">  RD_KAFKA_RESOURCE_UNKNOWN = 0,</span>
<span class="s1">  RD_KAFKA_RESOURCE_ANY = 1,</span>
<span class="s1">  RD_KAFKA_RESOURCE_TOPIC = 2,</span>
<span class="s1">  RD_KAFKA_RESOURCE_GROUP = 3,</span>
<span class="s1">  RD_KAFKA_RESOURCE_BROKER = 4,</span>
<span class="s1">  RD_KAFKA_RESOURCE__CNT,</span>
<span class="s1">} rd_kafka_ResourceType_t;</span>
<span class="s1">typedef enum rd_kafka_ResourcePatternType_t {</span>
<span class="s1">  RD_KAFKA_RESOURCE_PATTERN_UNKNOWN = 0,</span>
<span class="s1">  RD_KAFKA_RESOURCE_PATTERN_ANY = 1,</span>
<span class="s1">  RD_KAFKA_RESOURCE_PATTERN_MATCH = 2,</span>
<span class="s1">  RD_KAFKA_RESOURCE_PATTERN_LITERAL = 3,</span>
<span class="s1">  RD_KAFKA_RESOURCE_PATTERN_PREFIXED = 4,</span>
<span class="s1">  RD_KAFKA_RESOURCE_PATTERN_TYPE__CNT,</span>
<span class="s1">} rd_kafka_ResourcePatternType_t;</span>
<span class="s1">typedef enum rd_kafka_AlterConfigOpType_t {</span>
<span class="s1">  RD_KAFKA_ALTER_CONFIG_OP_TYPE_SET = 0,</span>
<span class="s1">  RD_KAFKA_ALTER_CONFIG_OP_TYPE_DELETE = 1,</span>
<span class="s1">  RD_KAFKA_ALTER_CONFIG_OP_TYPE_APPEND = 2,</span>
<span class="s1">  RD_KAFKA_ALTER_CONFIG_OP_TYPE_SUBTRACT = 3,</span>
<span class="s1">  RD_KAFKA_ALTER_CONFIG_OP_TYPE__CNT,</span>
<span class="s1">} rd_kafka_AlterConfigOpType_t;</span>
<span class="s1">const char *rd_kafka_ResourcePatternType_name(rd_kafka_ResourcePatternType_t resource_pattern_type);</span>
<span class="s1">const char *rd_kafka_ResourceType_name(rd_kafka_ResourceType_t restype);</span>
<span class="s1">typedef struct rd_kafka_ConfigResource_s rd_kafka_ConfigResource_t;</span>
<span class="s1">rd_kafka_ConfigResource_t *rd_kafka_ConfigResource_new(rd_kafka_ResourceType_t restype, const char *resname);</span>
<span class="s1">void rd_kafka_ConfigResource_destroy(rd_kafka_ConfigResource_t *config);</span>
<span class="s1">void rd_kafka_ConfigResource_destroy_array(rd_kafka_ConfigResource_t **config, size_t config_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_ConfigResource_set_config(rd_kafka_ConfigResource_t *config, const char *name, const char *value);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_ConfigResource_add_incremental_config(rd_kafka_ConfigResource_t *config, const char *name, rd_kafka_AlterConfigOpType_t op_type, const char *value);</span>
<span class="s1">const rd_kafka_ConfigEntry_t **rd_kafka_ConfigResource_configs(const rd_kafka_ConfigResource_t *config, size_t *cntp);</span>
<span class="s1">rd_kafka_ResourceType_t rd_kafka_ConfigResource_type(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">const char *rd_kafka_ConfigResource_name(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_ConfigResource_error(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">const char *rd_kafka_ConfigResource_error_string(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">void rd_kafka_AlterConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_ConfigResource_t **rd_kafka_AlterConfigs_result_resources(const rd_kafka_AlterConfigs_result_t *result, size_t *cntp);</span>
<span class="s1">void rd_kafka_IncrementalAlterConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_ConfigResource_t **rd_kafka_IncrementalAlterConfigs_result_resources(const rd_kafka_IncrementalAlterConfigs_result_t *result, size_t *cntp);</span>
<span class="s1">void rd_kafka_DescribeConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_ConfigResource_t **rd_kafka_DescribeConfigs_result_resources(const rd_kafka_DescribeConfigs_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_DeleteRecords_s rd_kafka_DeleteRecords_t;</span>
<span class="s1">rd_kafka_DeleteRecords_t *rd_kafka_DeleteRecords_new(const rd_kafka_topic_partition_list_t *before_offsets);</span>
<span class="s1">void rd_kafka_DeleteRecords_destroy(rd_kafka_DeleteRecords_t *del_records);</span>
<span class="s1">void rd_kafka_DeleteRecords_destroy_array(rd_kafka_DeleteRecords_t **del_records, size_t del_record_cnt);</span>
<span class="s1">void rd_kafka_DeleteRecords(rd_kafka_t *rk, rd_kafka_DeleteRecords_t **del_records, size_t del_record_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_partition_list_t *rd_kafka_DeleteRecords_result_offsets(const rd_kafka_DeleteRecords_result_t *result);</span>
<span class="s1">typedef struct rd_kafka_ConsumerGroupListing_s rd_kafka_ConsumerGroupListing_t;</span>
<span class="s1">typedef struct rd_kafka_ListConsumerGroupsResult_s rd_kafka_ListConsumerGroupsResult_t;</span>
<span class="s1">void rd_kafka_ListConsumerGroups(rd_kafka_t *rk, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const char *rd_kafka_ConsumerGroupListing_group_id(const rd_kafka_ConsumerGroupListing_t *grplist);</span>
<span class="s1">int rd_kafka_ConsumerGroupListing_is_simple_consumer_group(const rd_kafka_ConsumerGroupListing_t *grplist);</span>
<span class="s1">rd_kafka_consumer_group_state_t rd_kafka_ConsumerGroupListing_state(const rd_kafka_ConsumerGroupListing_t *grplist);</span>
<span class="s1">const rd_kafka_ConsumerGroupListing_t **rd_kafka_ListConsumerGroups_result_valid(const rd_kafka_ListConsumerGroups_result_t *result, size_t *cntp);</span>
<span class="s1">const rd_kafka_error_t **rd_kafka_ListConsumerGroups_result_errors(const rd_kafka_ListConsumerGroups_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_ConsumerGroupDescription_s rd_kafka_ConsumerGroupDescription_t;</span>
<span class="s1">typedef struct rd_kafka_MemberDescription_s rd_kafka_MemberDescription_t;</span>
<span class="s1">typedef struct rd_kafka_MemberAssignment_s rd_kafka_MemberAssignment_t;</span>
<span class="s1">void rd_kafka_DescribeConsumerGroups(rd_kafka_t *rk, const char **groups, size_t groups_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_ConsumerGroupDescription_t **rd_kafka_DescribeConsumerGroups_result_groups(const rd_kafka_DescribeConsumerGroups_result_t *result, size_t *cntp);</span>
<span class="s1">const char *rd_kafka_ConsumerGroupDescription_group_id(const rd_kafka_ConsumerGroupDescription_t *grpdesc);</span>
<span class="s1">const rd_kafka_error_t *rd_kafka_ConsumerGroupDescription_error(const rd_kafka_ConsumerGroupDescription_t *grpdesc);</span>
<span class="s1">int rd_kafka_ConsumerGroupDescription_is_simple_consumer_group(const rd_kafka_ConsumerGroupDescription_t *grpdesc);</span>
<span class="s1">const char *rd_kafka_ConsumerGroupDescription_partition_assignor(const rd_kafka_ConsumerGroupDescription_t *grpdesc);</span>
<span class="s1">rd_kafka_consumer_group_state_t rd_kafka_ConsumerGroupDescription_state(const rd_kafka_ConsumerGroupDescription_t *grpdesc);</span>
<span class="s1">const rd_kafka_Node_t *rd_kafka_ConsumerGroupDescription_coordinator(const rd_kafka_ConsumerGroupDescription_t *grpdesc);</span>
<span class="s1">size_t rd_kafka_ConsumerGroupDescription_member_count(const rd_kafka_ConsumerGroupDescription_t *grpdesc);</span>
<span class="s1">const rd_kafka_MemberDescription_t *rd_kafka_ConsumerGroupDescription_member(const rd_kafka_ConsumerGroupDescription_t *grpdesc, size_t idx);</span>
<span class="s1">const char *rd_kafka_MemberDescription_client_id(const rd_kafka_MemberDescription_t *member);</span>
<span class="s1">const char *rd_kafka_MemberDescription_group_instance_id(const rd_kafka_MemberDescription_t *member);</span>
<span class="s1">const char *rd_kafka_MemberDescription_consumer_id(const rd_kafka_MemberDescription_t *member);</span>
<span class="s1">const char *rd_kafka_MemberDescription_host(const rd_kafka_MemberDescription_t *member);</span>
<span class="s1">const rd_kafka_MemberAssignment_t *rd_kafka_MemberDescription_assignment(const rd_kafka_MemberDescription_t *member);</span>
<span class="s1">const rd_kafka_topic_partition_list_t *rd_kafka_MemberAssignment_partitions(const rd_kafka_MemberAssignment_t *assignment);</span>
<span class="s1">typedef struct rd_kafka_DeleteGroup_s rd_kafka_DeleteGroup_t;</span>
<span class="s1">rd_kafka_DeleteGroup_t *rd_kafka_DeleteGroup_new(const char *group);</span>
<span class="s1">void rd_kafka_DeleteGroup_destroy(rd_kafka_DeleteGroup_t *del_group);</span>
<span class="s1">void rd_kafka_DeleteGroup_destroy_array(rd_kafka_DeleteGroup_t **del_groups, size_t del_group_cnt);</span>
<span class="s1">void rd_kafka_DeleteGroups(rd_kafka_t *rk, rd_kafka_DeleteGroup_t **del_groups, size_t del_group_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_group_result_t **rd_kafka_DeleteGroups_result_groups(const rd_kafka_DeleteGroups_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_ListConsumerGroupOffsets_s rd_kafka_ListConsumerGroupOffsets_t;</span>
<span class="s1">rd_kafka_ListConsumerGroupOffsets_t *rd_kafka_ListConsumerGroupOffsets_new(const char *group_id, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">void rd_kafka_ListConsumerGroupOffsets_destroy(rd_kafka_ListConsumerGroupOffsets_t *list_grpoffsets);</span>
<span class="s1">void rd_kafka_ListConsumerGroupOffsets_destroy_array(rd_kafka_ListConsumerGroupOffsets_t **list_grpoffsets, size_t list_grpoffset_cnt);</span>
<span class="s1">void rd_kafka_ListConsumerGroupOffsets(rd_kafka_t *rk, rd_kafka_ListConsumerGroupOffsets_t **list_grpoffsets, size_t list_grpoffsets_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_group_result_t **rd_kafka_ListConsumerGroupOffsets_result_groups(const rd_kafka_ListConsumerGroupOffsets_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_AlterConsumerGroupOffsets_s rd_kafka_AlterConsumerGroupOffsets_t;</span>
<span class="s1">rd_kafka_AlterConsumerGroupOffsets_t *rd_kafka_AlterConsumerGroupOffsets_new(const char *group_id, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">void rd_kafka_AlterConsumerGroupOffsets_destroy(rd_kafka_AlterConsumerGroupOffsets_t *alter_grpoffsets);</span>
<span class="s1">void rd_kafka_AlterConsumerGroupOffsets_destroy_array(rd_kafka_AlterConsumerGroupOffsets_t **alter_grpoffsets, size_t alter_grpoffset_cnt);</span>
<span class="s1">void rd_kafka_AlterConsumerGroupOffsets(rd_kafka_t *rk, rd_kafka_AlterConsumerGroupOffsets_t **alter_grpoffsets, size_t alter_grpoffsets_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_group_result_t **rd_kafka_AlterConsumerGroupOffsets_result_groups(const rd_kafka_AlterConsumerGroupOffsets_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_DeleteConsumerGroupOffsets_s rd_kafka_DeleteConsumerGroupOffsets_t;</span>
<span class="s1">rd_kafka_DeleteConsumerGroupOffsets_t *rd_kafka_DeleteConsumerGroupOffsets_new(const char *group, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">void rd_kafka_DeleteConsumerGroupOffsets_destroy(rd_kafka_DeleteConsumerGroupOffsets_t *del_grpoffsets);</span>
<span class="s1">void rd_kafka_DeleteConsumerGroupOffsets_destroy_array(rd_kafka_DeleteConsumerGroupOffsets_t **del_grpoffsets, size_t del_grpoffset_cnt);</span>
<span class="s1">void rd_kafka_DeleteConsumerGroupOffsets(rd_kafka_t *rk, rd_kafka_DeleteConsumerGroupOffsets_t **del_grpoffsets, size_t del_grpoffsets_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_group_result_t **rd_kafka_DeleteConsumerGroupOffsets_result_groups(const rd_kafka_DeleteConsumerGroupOffsets_result_t *result, size_t *cntp);</span>
<span class="s1">typedef enum rd_kafka_ScramMechanism_t {</span>
<span class="s1">  RD_KAFKA_SCRAM_MECHANISM_UNKNOWN = 0,</span>
<span class="s1">  RD_KAFKA_SCRAM_MECHANISM_SHA_256 = 1,</span>
<span class="s1">  RD_KAFKA_SCRAM_MECHANISM_SHA_512 = 2,</span>
<span class="s1">  RD_KAFKA_SCRAM_MECHANISM__CNT,</span>
<span class="s1">} rd_kafka_ScramMechanism_t;</span>
<span class="s1">typedef struct rd_kafka_ScramCredentialInfo_s rd_kafka_ScramCredentialInfo_t;</span>
<span class="s1">rd_kafka_ScramMechanism_t rd_kafka_ScramCredentialInfo_mechanism(const rd_kafka_ScramCredentialInfo_t *scram_credential_info);</span>
<span class="s1">int32_t rd_kafka_ScramCredentialInfo_iterations(const rd_kafka_ScramCredentialInfo_t *scram_credential_info);</span>
<span class="s1">typedef struct rd_kafka_UserScramCredentialsDescription_s rd_kafka_UserScramCredentialsDescription_t;</span>
<span class="s1">const char *rd_kafka_UserScramCredentialsDescription_user(const rd_kafka_UserScramCredentialsDescription_t *description);</span>
<span class="s1">const rd_kafka_error_t *rd_kafka_UserScramCredentialsDescription_error(const rd_kafka_UserScramCredentialsDescription_t *description);</span>
<span class="s1">size_t rd_kafka_UserScramCredentialsDescription_scramcredentialinfo_count(const rd_kafka_UserScramCredentialsDescription_t *description);</span>
<span class="s1">const rd_kafka_ScramCredentialInfo_t *rd_kafka_UserScramCredentialsDescription_scramcredentialinfo(const rd_kafka_UserScramCredentialsDescription_t *description, size_t idx);</span>
<span class="s1">const rd_kafka_UserScramCredentialsDescription_t **rd_kafka_DescribeUserScramCredentials_result_descriptions(const rd_kafka_DescribeUserScramCredentials_result_t *result, size_t *cntp);</span>
<span class="s1">void rd_kafka_DescribeUserScramCredentials(rd_kafka_t *rk, const char **users, size_t user_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">typedef struct rd_kafka_UserScramCredentialAlteration_s rd_kafka_UserScramCredentialAlteration_t;</span>
<span class="s1">rd_kafka_UserScramCredentialAlteration_t *rd_kafka_UserScramCredentialUpsertion_new(const char *username, rd_kafka_ScramMechanism_t mechanism, int32_t iterations, const unsigned char *password, size_t password_size, const unsigned char *salt, size_t salt_size);</span>
<span class="s1">rd_kafka_UserScramCredentialAlteration_t *rd_kafka_UserScramCredentialDeletion_new(const char *username, rd_kafka_ScramMechanism_t mechanism);</span>
<span class="s1">void rd_kafka_UserScramCredentialAlteration_destroy(rd_kafka_UserScramCredentialAlteration_t *alteration);</span>
<span class="s1">void rd_kafka_UserScramCredentialAlteration_destroy_array(rd_kafka_UserScramCredentialAlteration_t **alterations, size_t alteration_cnt);</span>
<span class="s1">typedef struct rd_kafka_AlterUserScramCredentials_result_response_s rd_kafka_AlterUserScramCredentials_result_response_t;</span>
<span class="s1">const char *rd_kafka_AlterUserScramCredentials_result_response_user(const rd_kafka_AlterUserScramCredentials_result_response_t *response);</span>
<span class="s1">const rd_kafka_error_t *rd_kafka_AlterUserScramCredentials_result_response_error(const rd_kafka_AlterUserScramCredentials_result_response_t *response);</span>
<span class="s1">const rd_kafka_AlterUserScramCredentials_result_response_t **rd_kafka_AlterUserScramCredentials_result_responses(const rd_kafka_AlterUserScramCredentials_result_t *result, size_t *cntp);</span>
<span class="s1">void rd_kafka_AlterUserScramCredentials(rd_kafka_t *rk, rd_kafka_UserScramCredentialAlteration_t **alterations, size_t alteration_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">typedef struct rd_kafka_AclBinding_s rd_kafka_AclBinding_t;</span>
<span class="s1">typedef rd_kafka_AclBinding_t rd_kafka_AclBindingFilter_t;</span>
<span class="s1">const rd_kafka_error_t *rd_kafka_acl_result_error(const rd_kafka_acl_result_t *aclres);</span>
<span class="s1">typedef enum rd_kafka_AclOperation_t {</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_UNKNOWN = 0,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_ANY = 1,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_ALL = 2,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_READ = 3,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_WRITE = 4,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_CREATE = 5,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_DELETE = 6,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_ALTER = 7,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_DESCRIBE = 8,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_CLUSTER_ACTION = 9,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_DESCRIBE_CONFIGS = 10,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_ALTER_CONFIGS = 11,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_IDEMPOTENT_WRITE = 12,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION__CNT,</span>
<span class="s1">} rd_kafka_AclOperation_t;</span>
<span class="s1">const char *rd_kafka_AclOperation_name(rd_kafka_AclOperation_t acl_operation);</span>
<span class="s1">typedef enum rd_kafka_AclPermissionType_t {</span>
<span class="s1">  RD_KAFKA_ACL_PERMISSION_TYPE_UNKNOWN = 0,</span>
<span class="s1">  RD_KAFKA_ACL_PERMISSION_TYPE_ANY = 1,</span>
<span class="s1">  RD_KAFKA_ACL_PERMISSION_TYPE_DENY = 2,</span>
<span class="s1">  RD_KAFKA_ACL_PERMISSION_TYPE_ALLOW = 3,</span>
<span class="s1">  RD_KAFKA_ACL_PERMISSION_TYPE__CNT,</span>
<span class="s1">} rd_kafka_AclPermissionType_t;</span>
<span class="s1">const char *rd_kafka_AclPermissionType_name(rd_kafka_AclPermissionType_t acl_permission_type);</span>
<span class="s1">rd_kafka_AclBinding_t *rd_kafka_AclBinding_new(rd_kafka_ResourceType_t restype, const char *name, rd_kafka_ResourcePatternType_t resource_pattern_type, const char *principal, const char *host, rd_kafka_AclOperation_t operation, rd_kafka_AclPermissionType_t permission_type, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_AclBindingFilter_t *rd_kafka_AclBindingFilter_new(rd_kafka_ResourceType_t restype, const char *name, rd_kafka_ResourcePatternType_t resource_pattern_type, const char *principal, const char *host, rd_kafka_AclOperation_t operation, rd_kafka_AclPermissionType_t permission_type, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_ResourceType_t rd_kafka_AclBinding_restype(const rd_kafka_AclBinding_t *acl);</span>
<span class="s1">const char *rd_kafka_AclBinding_name(const rd_kafka_AclBinding_t *acl);</span>
<span class="s1">const char *rd_kafka_AclBinding_principal(const rd_kafka_AclBinding_t *acl);</span>
<span class="s1">const char *rd_kafka_AclBinding_host(const rd_kafka_AclBinding_t *acl);</span>
<span class="s1">rd_kafka_AclOperation_t rd_kafka_AclBinding_operation(const rd_kafka_AclBinding_t *acl);</span>
<span class="s1">rd_kafka_AclPermissionType_t rd_kafka_AclBinding_permission_type(const rd_kafka_AclBinding_t *acl);</span>
<span class="s1">rd_kafka_ResourcePatternType_t rd_kafka_AclBinding_resource_pattern_type(const rd_kafka_AclBinding_t *acl);</span>
<span class="s1">const rd_kafka_error_t *rd_kafka_AclBinding_error(const rd_kafka_AclBinding_t *acl);</span>
<span class="s1">void rd_kafka_AclBinding_destroy(rd_kafka_AclBinding_t *acl_binding);</span>
<span class="s1">void rd_kafka_AclBinding_destroy_array(rd_kafka_AclBinding_t **acl_bindings, size_t acl_bindings_cnt);</span>
<span class="s1">const rd_kafka_acl_result_t **rd_kafka_CreateAcls_result_acls(const rd_kafka_CreateAcls_result_t *result, size_t *cntp);</span>
<span class="s1">void rd_kafka_CreateAcls(rd_kafka_t *rk, rd_kafka_AclBinding_t **new_acls, size_t new_acls_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_AclBinding_t **rd_kafka_DescribeAcls_result_acls(const rd_kafka_DescribeAcls_result_t *result, size_t *cntp);</span>
<span class="s1">void rd_kafka_DescribeAcls(rd_kafka_t *rk, rd_kafka_AclBindingFilter_t *acl_filter, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">typedef struct rd_kafka_DeleteAcls_result_response_s rd_kafka_DeleteAcls_result_response_t;</span>
<span class="s1">const rd_kafka_DeleteAcls_result_response_t **rd_kafka_DeleteAcls_result_responses(const rd_kafka_DeleteAcls_result_t *result, size_t *cntp);</span>
<span class="s1">const rd_kafka_error_t *rd_kafka_DeleteAcls_result_response_error(const rd_kafka_DeleteAcls_result_response_t *result_response);</span>
<span class="s1">const rd_kafka_AclBinding_t **rd_kafka_DeleteAcls_result_response_matching_acls(const rd_kafka_DeleteAcls_result_response_t *result_response, size_t *matching_acls_cntp);</span>
<span class="s1">void rd_kafka_DeleteAcls(rd_kafka_t *rk, rd_kafka_AclBindingFilter_t **del_acls, size_t del_acls_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token(rd_kafka_t *rk, const char *token_value, int64_t md_lifetime_ms, const char *md_principal_name, const char **extensions, size_t extension_size, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token_failure(rd_kafka_t *rk, const char *errstr);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_init_transactions(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_begin_transaction(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_send_offsets_to_transaction(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, const rd_kafka_consumer_group_metadata_t *cgmetadata, int timeout_ms);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_commit_transaction(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_abort_transaction(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">typedef struct rd_kafka_mock_cluster_s rd_kafka_mock_cluster_t;</span>
<span class="s1">rd_kafka_mock_cluster_t *rd_kafka_mock_cluster_new(rd_kafka_t *rk, int broker_cnt);</span>
<span class="s1">void rd_kafka_mock_cluster_destroy(rd_kafka_mock_cluster_t *mcluster);</span>
<span class="s1">rd_kafka_t *rd_kafka_mock_cluster_handle(const rd_kafka_mock_cluster_t *mcluster);</span>
<span class="s1">rd_kafka_mock_cluster_t *rd_kafka_handle_mock_cluster(const rd_kafka_t *rk);</span>
<span class="s1">const char *rd_kafka_mock_cluster_bootstraps(const rd_kafka_mock_cluster_t *mcluster);</span>
<span class="s1">void rd_kafka_mock_clear_request_errors(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey);</span>
<span class="s1">void rd_kafka_mock_push_request_errors(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, size_t cnt, ...);</span>
<span class="s1">void rd_kafka_mock_push_request_errors_array(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, size_t cnt, const rd_kafka_resp_err_t *errors);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_push_request_error_rtts(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int16_t ApiKey, size_t cnt, ...);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_error_stack_cnt(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int16_t ApiKey, size_t *cntp);</span>
<span class="s1">void rd_kafka_mock_topic_set_error(rd_kafka_mock_cluster_t *mcluster, const char *topic, rd_kafka_resp_err_t err);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_topic_create(rd_kafka_mock_cluster_t *mcluster, const char *topic, int partition_cnt, int replication_factor);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_partition_set_leader(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_partition_set_follower(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_partition_set_follower_wmarks(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int64_t lo, int64_t hi);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_set_down(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_set_up(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_set_rtt(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int rtt_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_set_rack(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, const char *rack);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_coordinator_set(rd_kafka_mock_cluster_t *mcluster, const char *key_type, const char *key, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_set_apiversion(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, int16_t MinVersion, int16_t MaxVersion);</span>
<span class="s1">&#39;</span>
</code></pre></div>
rdkafka.h, rdkafka_mock.h</p>
<h3 id="rd_kafka_version_28">RD_KAFKA_VERSION<a class="headerlink" href="#rd_kafka_version_28" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_VERSION</span> <span class="o">=</span> <span class="mi">33686015</span>
</code></pre></div>
<p>librdkafka version </p>
<p>Interpreted as hex <code>MM.mm.rr.xx</code>:</p>
<ul>
<li>MM = Major</li>
<li>mm = minor</li>
<li>rr = revision</li>
<li>xx = pre-release id (0xff is the final release)</li>
</ul>
<p>E.g.: <code>0x000801ff</code> = 0.8.1</p>
<dl class="section remark"><dt>Remarks</dt><dd>This value should only be used during compile time, for runtime checks of version use rd_kafka_version() </dd></dl>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_unsupported_compression_type_28">RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE<a class="headerlink" href="#rd_kafka_resp_err_unsupported_compression_type_28" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE</span> <span class="o">=</span> <span class="mi">76</span>
</code></pre></div>
<p>Unsupported compression type </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_end_all_28">RD_KAFKA_RESP_ERR_END_ALL<a class="headerlink" href="#rd_kafka_resp_err_end_all_28" title="Permanent link">&para;</a></h3>
<p><div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_END_ALL</span> <span class="o">=</span> <span class="mi">98</span>
</code></pre></div>
enum rd_kafka_resp_err_t</p>
<h3 id="rd_kafka_admin_op__cnt_28">RD_KAFKA_ADMIN_OP__CNT<a class="headerlink" href="#rd_kafka_admin_op__cnt_28" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_ADMIN_OP__CNT</span> <span class="o">=</span> <span class="mi">19</span>
</code></pre></div>
<p>Number of ops defined </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe </a></li>
</ul>
</div>
<h3 id="rd_kafka_resource__cnt_28">RD_KAFKA_RESOURCE__CNT<a class="headerlink" href="#rd_kafka_resource__cnt_28" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESOURCE__CNT</span> <span class="o">=</span> <span class="mi">5</span>
</code></pre></div>
<p>Number of resource types defined </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#acca83a66d7783ff7683ed2691cc907c9"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#acca83a66d7783ff7683ed2691cc907c9 </a></li>
</ul>
</div>
<h3 id="rd_kafka_cdef_28">RD_KAFKA_CDEF<a class="headerlink" href="#rd_kafka_cdef_28" title="Permanent link">&para;</a></h3>
<p><div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_CDEF</span> <span class="o">=</span> <span class="s1">&#39;typedef long int ssize_t;</span>
<span class="s1">typedef struct _IO_FILE FILE;</span>
<span class="s1">typedef long int mode_t;</span>
<span class="s1">typedef signed int int16_t;</span>
<span class="s1">typedef unsigned int uint16_t;</span>
<span class="s1">typedef signed int int32_t;</span>
<span class="s1">typedef signed long int int64_t;</span>
<span class="s1">int rd_kafka_version(void);</span>
<span class="s1">const char *rd_kafka_version_str(void);</span>
<span class="s1">typedef enum rd_kafka_type_t {</span>
<span class="s1">  RD_KAFKA_PRODUCER,</span>
<span class="s1">  RD_KAFKA_CONSUMER,</span>
<span class="s1">} rd_kafka_type_t;</span>
<span class="s1">typedef enum rd_kafka_timestamp_type_t {</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_NOT_AVAILABLE,</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_CREATE_TIME,</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_LOG_APPEND_TIME,</span>
<span class="s1">} rd_kafka_timestamp_type_t;</span>
<span class="s1">const char *rd_kafka_get_debug_contexts(void);</span>
<span class="s1">typedef struct rd_kafka_s rd_kafka_t;</span>
<span class="s1">typedef struct rd_kafka_topic_s rd_kafka_topic_t;</span>
<span class="s1">typedef struct rd_kafka_conf_s rd_kafka_conf_t;</span>
<span class="s1">typedef struct rd_kafka_topic_conf_s rd_kafka_topic_conf_t;</span>
<span class="s1">typedef struct rd_kafka_queue_s rd_kafka_queue_t;</span>
<span class="s1">typedef struct rd_kafka_op_s rd_kafka_event_t;</span>
<span class="s1">typedef struct rd_kafka_topic_result_s rd_kafka_topic_result_t;</span>
<span class="s1">typedef struct rd_kafka_consumer_group_metadata_s rd_kafka_consumer_group_metadata_t;</span>
<span class="s1">typedef struct rd_kafka_error_s {</span>
<span class="s1">  unsigned int code;</span>
<span class="s1">  char *errstr;</span>
<span class="s1">  unsigned char fatal;</span>
<span class="s1">  unsigned char retriable;</span>
<span class="s1">  unsigned char txn_requires_abort;</span>
<span class="s1">} rd_kafka_error_t;</span>
<span class="s1">typedef struct rd_kafka_headers_s rd_kafka_headers_t;</span>
<span class="s1">typedef struct rd_kafka_group_result_s rd_kafka_group_result_t;</span>
<span class="s1">typedef struct rd_kafka_acl_result_s rd_kafka_acl_result_t;</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BEGIN = (- 200),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BAD_MSG = (- 199),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BAD_COMPRESSION = (- 198),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__DESTROY = (- 197),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FAIL = (- 196),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TRANSPORT = (- 195),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__CRIT_SYS_RESOURCE = (- 194),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__RESOLVE = (- 193),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__MSG_TIMED_OUT = (- 192),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PARTITION_EOF = (- 191),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION = (- 190),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FS = (- 189),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC = (- 188),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ALL_BROKERS_DOWN = (- 187),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INVALID_ARG = (- 186),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TIMED_OUT = (- 185),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__QUEUE_FULL = (- 184),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ISR_INSUFF = (- 183),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NODE_UPDATE = (- 182),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__SSL = (- 181),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__WAIT_COORD = (- 180),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_GROUP = (- 179),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__IN_PROGRESS = (- 178),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PREV_IN_PROGRESS = (- 177),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__EXISTING_SUBSCRIPTION = (- 176),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS = (- 175),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS = (- 174),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__CONFLICT = (- 173),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__STATE = (- 172),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_PROTOCOL = (- 171),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED = (- 170),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__AUTHENTICATION = (- 169),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NO_OFFSET = (- 168),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__OUTDATED = (- 167),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TIMED_OUT_QUEUE = (- 166),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNSUPPORTED_FEATURE = (- 165),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__WAIT_CACHE = (- 164),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INTR = (- 163),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__KEY_SERIALIZATION = (- 162),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__VALUE_SERIALIZATION = (- 161),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__KEY_DESERIALIZATION = (- 160),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__VALUE_DESERIALIZATION = (- 159),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PARTIAL = (- 158),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__READ_ONLY = (- 157),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOENT = (- 156),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNDERFLOW = (- 155),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INVALID_TYPE = (- 154),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__RETRY = (- 153),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PURGE_QUEUE = (- 152),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PURGE_INFLIGHT = (- 151),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FATAL = (- 150),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INCONSISTENT = (- 149),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__GAPLESS_GUARANTEE = (- 148),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__MAX_POLL_EXCEEDED = (- 147),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_BROKER = (- 146),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOT_CONFIGURED = (- 145),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FENCED = (- 144),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__APPLICATION = (- 143),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ASSIGNMENT_LOST = (- 142),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOOP = (- 141),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__AUTO_OFFSET_RESET = (- 140),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__LOG_TRUNCATION = (- 139),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__END = (- 100),</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN = (- 1),</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NO_ERROR = 0,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_OUT_OF_RANGE = 1,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_MSG = 2,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART = 3,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_MSG_SIZE = 4,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE = 5,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_LEADER_FOR_PARTITION = 6,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REQUEST_TIMED_OUT = 7,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_BROKER_NOT_AVAILABLE = 8,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REPLICA_NOT_AVAILABLE = 9,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE = 10,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_STALE_CTRL_EPOCH = 11,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_METADATA_TOO_LARGE = 12,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NETWORK_EXCEPTION = 13,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_COORDINATOR_LOAD_IN_PROGRESS = 14,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_COORDINATOR_NOT_AVAILABLE = 15,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_COORDINATOR = 16,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_EXCEPTION = 17,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_RECORD_LIST_TOO_LARGE = 18,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS = 19,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS_AFTER_APPEND = 20,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REQUIRED_ACKS = 21,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ILLEGAL_GENERATION = 22,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INCONSISTENT_GROUP_PROTOCOL = 23,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_GROUP_ID = 24,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_MEMBER_ID = 25,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_SESSION_TIMEOUT = 26,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REBALANCE_IN_PROGRESS = 27,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_COMMIT_OFFSET_SIZE = 28,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_AUTHORIZATION_FAILED = 29,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_AUTHORIZATION_FAILED = 30,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_CLUSTER_AUTHORIZATION_FAILED = 31,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TIMESTAMP = 32,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_SASL_MECHANISM = 33,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ILLEGAL_SASL_STATE = 34,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_VERSION = 35,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_ALREADY_EXISTS = 36,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PARTITIONS = 37,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REPLICATION_FACTOR = 38,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REPLICA_ASSIGNMENT = 39,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_CONFIG = 40,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_CONTROLLER = 41,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REQUEST = 42,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_FOR_MESSAGE_FORMAT = 43,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_POLICY_VIOLATION = 44,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OUT_OF_ORDER_SEQUENCE_NUMBER = 45,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DUPLICATE_SEQUENCE_NUMBER = 46,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_EPOCH = 47,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TXN_STATE = 48,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_ID_MAPPING = 49,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TRANSACTION_TIMEOUT = 50,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_CONCURRENT_TRANSACTIONS = 51,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TRANSACTION_COORDINATOR_FENCED = 52,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TRANSACTIONAL_ID_AUTHORIZATION_FAILED = 53,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_SECURITY_DISABLED = 54,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OPERATION_NOT_ATTEMPTED = 55,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_KAFKA_STORAGE_ERROR = 56,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LOG_DIR_NOT_FOUND = 57,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_SASL_AUTHENTICATION_FAILED = 58,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_PRODUCER_ID = 59,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REASSIGNMENT_IN_PROGRESS = 60,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTH_DISABLED = 61,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_NOT_FOUND = 62,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_OWNER_MISMATCH = 63,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_REQUEST_NOT_ALLOWED = 64,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTHORIZATION_FAILED = 65,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_EXPIRED = 66,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRINCIPAL_TYPE = 67,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NON_EMPTY_GROUP = 68,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_ID_NOT_FOUND = 69,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FETCH_SESSION_ID_NOT_FOUND = 70,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_FETCH_SESSION_EPOCH = 71,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LISTENER_NOT_FOUND = 72,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_DELETION_DISABLED = 73,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FENCED_LEADER_EPOCH = 74,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_LEADER_EPOCH = 75,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_STALE_BROKER_EPOCH = 77,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_NOT_AVAILABLE = 78,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_MEMBER_ID_REQUIRED = 79,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_PREFERRED_LEADER_NOT_AVAILABLE = 80,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_MAX_SIZE_REACHED = 81,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FENCED_INSTANCE_ID = 82,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ELIGIBLE_LEADERS_NOT_AVAILABLE = 83,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ELECTION_NOT_NEEDED = 84,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NO_REASSIGNMENT_IN_PROGRESS = 85,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_SUBSCRIBED_TO_TOPIC = 86,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_RECORD = 87,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSTABLE_OFFSET_COMMIT = 88,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_THROTTLING_QUOTA_EXCEEDED = 89,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_PRODUCER_FENCED = 90,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_RESOURCE_NOT_FOUND = 91,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DUPLICATE_RESOURCE = 92,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNACCEPTABLE_CREDENTIAL = 93,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INCONSISTENT_VOTER_SET = 94,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_UPDATE_VERSION = 95,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FEATURE_UPDATE_FAILED = 96,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_PRINCIPAL_DESERIALIZATION_FAILURE = 97,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_END_ALL,</span>
<span class="s1">} rd_kafka_resp_err_t;</span>
<span class="s1">struct rd_kafka_err_desc {</span>
<span class="s1">  rd_kafka_resp_err_t code;</span>
<span class="s1">  char *name;</span>
<span class="s1">  char *desc;</span>
<span class="s1">};</span>
<span class="s1">void rd_kafka_get_err_descs(const struct rd_kafka_err_desc **errdescs, size_t *cntp);</span>
<span class="s1">const char *rd_kafka_err2str(rd_kafka_resp_err_t err);</span>
<span class="s1">const char *rd_kafka_err2name(rd_kafka_resp_err_t err);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_last_error(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_errno2err(int errnox);</span>
<span class="s1">int rd_kafka_errno(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_fatal_error(rd_kafka_t *rk, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_test_fatal_error(rd_kafka_t *rk, rd_kafka_resp_err_t err, const char *reason);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_error_code(const rd_kafka_error_t *error);</span>
<span class="s1">const char *rd_kafka_error_name(const rd_kafka_error_t *error);</span>
<span class="s1">const char *rd_kafka_error_string(const rd_kafka_error_t *error);</span>
<span class="s1">int rd_kafka_error_is_fatal(const rd_kafka_error_t *error);</span>
<span class="s1">int rd_kafka_error_is_retriable(const rd_kafka_error_t *error);</span>
<span class="s1">int rd_kafka_error_txn_requires_abort(const rd_kafka_error_t *error);</span>
<span class="s1">void rd_kafka_error_destroy(rd_kafka_error_t *error);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_error_new(rd_kafka_resp_err_t code, const char *fmt, ...);</span>
<span class="s1">typedef struct rd_kafka_topic_partition_s {</span>
<span class="s1">  char *topic;</span>
<span class="s1">  int32_t partition;</span>
<span class="s1">  int64_t offset;</span>
<span class="s1">  void *metadata;</span>
<span class="s1">  size_t metadata_size;</span>
<span class="s1">  void *opaque;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  void *_private;</span>
<span class="s1">} rd_kafka_topic_partition_t;</span>
<span class="s1">void rd_kafka_topic_partition_destroy(rd_kafka_topic_partition_t *rktpar);</span>
<span class="s1">void rd_kafka_topic_partition_set_leader_epoch(rd_kafka_topic_partition_t *rktpar, int32_t leader_epoch);</span>
<span class="s1">int32_t rd_kafka_topic_partition_get_leader_epoch(const rd_kafka_topic_partition_t *rktpar);</span>
<span class="s1">typedef struct rd_kafka_topic_partition_list_s {</span>
<span class="s1">  int cnt;</span>
<span class="s1">  int size;</span>
<span class="s1">  rd_kafka_topic_partition_t *elems;</span>
<span class="s1">} rd_kafka_topic_partition_list_t;</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_new(int size);</span>
<span class="s1">void rd_kafka_topic_partition_list_destroy(rd_kafka_topic_partition_list_t *rkparlist);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_add(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">void rd_kafka_topic_partition_list_add_range(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t start, int32_t stop);</span>
<span class="s1">int rd_kafka_topic_partition_list_del(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">int rd_kafka_topic_partition_list_del_by_idx(rd_kafka_topic_partition_list_t *rktparlist, int idx);</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_copy(const rd_kafka_topic_partition_list_t *src);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_topic_partition_list_set_offset(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition, int64_t offset);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_find(const rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">void rd_kafka_topic_partition_list_sort(rd_kafka_topic_partition_list_t *rktparlist, int (*cmp)(const void *a, const void *b, void *cmp_opaque), void *cmp_opaque);</span>
<span class="s1">typedef enum rd_kafka_vtype_t {</span>
<span class="s1">  RD_KAFKA_VTYPE_END,</span>
<span class="s1">  RD_KAFKA_VTYPE_TOPIC,</span>
<span class="s1">  RD_KAFKA_VTYPE_RKT,</span>
<span class="s1">  RD_KAFKA_VTYPE_PARTITION,</span>
<span class="s1">  RD_KAFKA_VTYPE_VALUE,</span>
<span class="s1">  RD_KAFKA_VTYPE_KEY,</span>
<span class="s1">  RD_KAFKA_VTYPE_OPAQUE,</span>
<span class="s1">  RD_KAFKA_VTYPE_MSGFLAGS,</span>
<span class="s1">  RD_KAFKA_VTYPE_TIMESTAMP,</span>
<span class="s1">  RD_KAFKA_VTYPE_HEADER,</span>
<span class="s1">  RD_KAFKA_VTYPE_HEADERS,</span>
<span class="s1">} rd_kafka_vtype_t;</span>
<span class="s1">typedef struct rd_kafka_vu_s {</span>
<span class="s1">  rd_kafka_vtype_t vtype;</span>
<span class="s1">  union {</span>
<span class="s1">    char *cstr;</span>
<span class="s1">    rd_kafka_topic_t *rkt;</span>
<span class="s1">    int i;</span>
<span class="s1">    int32_t i32;</span>
<span class="s1">    int64_t i64;</span>
<span class="s1">    struct {</span>
<span class="s1">      void *ptr;</span>
<span class="s1">      size_t size;</span>
<span class="s1">    } mem;</span>
<span class="s1">    struct {</span>
<span class="s1">      char *name;</span>
<span class="s1">      void *val;</span>
<span class="s1">      ssize_t size;</span>
<span class="s1">    } header;</span>
<span class="s1">    rd_kafka_headers_t *headers;</span>
<span class="s1">    void *ptr;</span>
<span class="s1">    char _pad[64];</span>
<span class="s1">  } u;</span>
<span class="s1">} rd_kafka_vu_t;</span>
<span class="s1">rd_kafka_headers_t *rd_kafka_headers_new(size_t initial_count);</span>
<span class="s1">void rd_kafka_headers_destroy(rd_kafka_headers_t *hdrs);</span>
<span class="s1">rd_kafka_headers_t *rd_kafka_headers_copy(const rd_kafka_headers_t *src);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_add(rd_kafka_headers_t *hdrs, const char *name, ssize_t name_size, const void *value, ssize_t value_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_remove(rd_kafka_headers_t *hdrs, const char *name);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get_last(const rd_kafka_headers_t *hdrs, const char *name, const void **valuep, size_t *sizep);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get(const rd_kafka_headers_t *hdrs, size_t idx, const char *name, const void **valuep, size_t *sizep);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get_all(const rd_kafka_headers_t *hdrs, size_t idx, const char **namep, const void **valuep, size_t *sizep);</span>
<span class="s1">typedef struct rd_kafka_message_s {</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  rd_kafka_topic_t *rkt;</span>
<span class="s1">  int32_t partition;</span>
<span class="s1">  void *payload;</span>
<span class="s1">  size_t len;</span>
<span class="s1">  void *key;</span>
<span class="s1">  size_t key_len;</span>
<span class="s1">  int64_t offset;</span>
<span class="s1">  void *_private;</span>
<span class="s1">} rd_kafka_message_t;</span>
<span class="s1">void rd_kafka_message_destroy(rd_kafka_message_t *rkmessage);</span>
<span class="s1">const char *rd_kafka_message_errstr(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">int64_t rd_kafka_message_timestamp(const rd_kafka_message_t *rkmessage, rd_kafka_timestamp_type_t *tstype);</span>
<span class="s1">int64_t rd_kafka_message_latency(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">int32_t rd_kafka_message_broker_id(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_message_headers(const rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_message_detach_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);</span>
<span class="s1">void rd_kafka_message_set_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t *hdrs);</span>
<span class="s1">size_t rd_kafka_header_cnt(const rd_kafka_headers_t *hdrs);</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_NOT_PERSISTED = 0,</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_POSSIBLY_PERSISTED = 1,</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_PERSISTED = 2,</span>
<span class="s1">} rd_kafka_msg_status_t;</span>
<span class="s1">rd_kafka_msg_status_t rd_kafka_message_status(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">int32_t rd_kafka_message_leader_epoch(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_CONF_UNKNOWN = (- 2),</span>
<span class="s1">  RD_KAFKA_CONF_INVALID = (- 1),</span>
<span class="s1">  RD_KAFKA_CONF_OK = 0,</span>
<span class="s1">} rd_kafka_conf_res_t;</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_new(void);</span>
<span class="s1">void rd_kafka_conf_destroy(rd_kafka_conf_t *conf);</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_dup(const rd_kafka_conf_t *conf);</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_dup_filter(const rd_kafka_conf_t *conf, size_t filter_cnt, const char **filter);</span>
<span class="s1">const rd_kafka_conf_t *rd_kafka_conf(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_set(rd_kafka_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_conf_set_events(rd_kafka_conf_t *conf, int events);</span>
<span class="s1">void rd_kafka_conf_set_background_event_cb(rd_kafka_conf_t *conf, void (*event_cb)(rd_kafka_t *rk, rd_kafka_event_t *rkev, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_dr_cb(rd_kafka_conf_t *conf, void (*dr_cb)(rd_kafka_t *rk, void *payload, size_t len, rd_kafka_resp_err_t err, void *opaque, void *msg_opaque));</span>
<span class="s1">void rd_kafka_conf_set_dr_msg_cb(rd_kafka_conf_t *conf, void (*dr_msg_cb)(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_consume_cb(rd_kafka_conf_t *conf, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_rebalance_cb(rd_kafka_conf_t *conf, void (*rebalance_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *partitions, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_offset_commit_cb(rd_kafka_conf_t *conf, void (*offset_commit_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_error_cb(rd_kafka_conf_t *conf, void (*error_cb)(rd_kafka_t *rk, int err, const char *reason, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_throttle_cb(rd_kafka_conf_t *conf, void (*throttle_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int throttle_time_ms, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_log_cb(rd_kafka_conf_t *conf, void (*log_cb)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));</span>
<span class="s1">void rd_kafka_conf_set_stats_cb(rd_kafka_conf_t *conf, int (*stats_cb)(rd_kafka_t *rk, char *json, size_t json_len, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_oauthbearer_token_refresh_cb(rd_kafka_conf_t *conf, void (*oauthbearer_token_refresh_cb)(rd_kafka_t *rk, const char *oauthbearer_config, void *opaque));</span>
<span class="s1">void rd_kafka_conf_enable_sasl_queue(rd_kafka_conf_t *conf, int enable);</span>
<span class="s1">void rd_kafka_conf_set_socket_cb(rd_kafka_conf_t *conf, int (*socket_cb)(int domain, int type, int protocol, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_connect_cb(rd_kafka_conf_t *conf, int (*connect_cb)(int sockfd, const struct sockaddr *addr, int addrlen, const char *id, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_closesocket_cb(rd_kafka_conf_t *conf, int (*closesocket_cb)(int sockfd, void *opaque));</span>
<span class="s1">struct addrinfo;</span>
<span class="s1">void rd_kafka_conf_set_resolve_cb(rd_kafka_conf_t *conf, int (*resolve_cb)(const char *node, const char *service, const struct addrinfo *hints, struct addrinfo **res, void *opaque));</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert_verify_cb(rd_kafka_conf_t *conf, int (*ssl_cert_verify_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int *x509_error, int depth, const char *buf, size_t size, char *errstr, size_t errstr_size, void *opaque));</span>
<span class="s1">typedef enum rd_kafka_cert_type_t {</span>
<span class="s1">  RD_KAFKA_CERT_PUBLIC_KEY,</span>
<span class="s1">  RD_KAFKA_CERT_PRIVATE_KEY,</span>
<span class="s1">  RD_KAFKA_CERT_CA,</span>
<span class="s1">  RD_KAFKA_CERT__CNT,</span>
<span class="s1">} rd_kafka_cert_type_t;</span>
<span class="s1">typedef enum rd_kafka_cert_enc_t {</span>
<span class="s1">  RD_KAFKA_CERT_ENC_PKCS12,</span>
<span class="s1">  RD_KAFKA_CERT_ENC_DER,</span>
<span class="s1">  RD_KAFKA_CERT_ENC_PEM,</span>
<span class="s1">  RD_KAFKA_CERT_ENC__CNT,</span>
<span class="s1">} rd_kafka_cert_enc_t;</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert(rd_kafka_conf_t *conf, rd_kafka_cert_type_t cert_type, rd_kafka_cert_enc_t cert_enc, const void *buffer, size_t size, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_conf_set_engine_callback_data(rd_kafka_conf_t *conf, void *callback_data);</span>
<span class="s1">void rd_kafka_conf_set_opaque(rd_kafka_conf_t *conf, void *opaque);</span>
<span class="s1">void *rd_kafka_opaque(const rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_conf_set_default_topic_conf(rd_kafka_conf_t *conf, rd_kafka_topic_conf_t *tconf);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_conf_get_default_topic_conf(rd_kafka_conf_t *conf);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_get(const rd_kafka_conf_t *conf, const char *name, char *dest, size_t *dest_size);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_topic_conf_get(const rd_kafka_topic_conf_t *conf, const char *name, char *dest, size_t *dest_size);</span>
<span class="s1">const char **rd_kafka_conf_dump(rd_kafka_conf_t *conf, size_t *cntp);</span>
<span class="s1">const char **rd_kafka_topic_conf_dump(rd_kafka_topic_conf_t *conf, size_t *cntp);</span>
<span class="s1">void rd_kafka_conf_dump_free(const char **arr, size_t cnt);</span>
<span class="s1">void rd_kafka_conf_properties_show(FILE *fp);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_topic_conf_new(void);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_topic_conf_dup(const rd_kafka_topic_conf_t *conf);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_default_topic_conf_dup(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_topic_conf_destroy(rd_kafka_topic_conf_t *topic_conf);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_topic_conf_set(rd_kafka_topic_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_topic_conf_set_opaque(rd_kafka_topic_conf_t *conf, void *rkt_opaque);</span>
<span class="s1">void rd_kafka_topic_conf_set_partitioner_cb(rd_kafka_topic_conf_t *topic_conf, int32_t (*partitioner)(const rd_kafka_topic_t *rkt, const void *keydata, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque));</span>
<span class="s1">void rd_kafka_topic_conf_set_msg_order_cmp(rd_kafka_topic_conf_t *topic_conf, int (*msg_order_cmp)(const rd_kafka_message_t *a, const rd_kafka_message_t *b));</span>
<span class="s1">int rd_kafka_topic_partition_available(const rd_kafka_topic_t *rkt, int32_t partition);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_consistent(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_consistent_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_murmur2(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_murmur2_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_fnv1a(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_fnv1a_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">rd_kafka_t *rd_kafka_new(rd_kafka_type_t type, rd_kafka_conf_t *conf, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_destroy(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_destroy_flags(rd_kafka_t *rk, int flags);</span>
<span class="s1">const char *rd_kafka_name(const rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_type_t rd_kafka_type(const rd_kafka_t *rk);</span>
<span class="s1">char *rd_kafka_memberid(const rd_kafka_t *rk);</span>
<span class="s1">char *rd_kafka_clusterid(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">int32_t rd_kafka_controllerid(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_topic_t *rd_kafka_topic_new(rd_kafka_t *rk, const char *topic, rd_kafka_topic_conf_t *conf);</span>
<span class="s1">void rd_kafka_topic_destroy(rd_kafka_topic_t *rkt);</span>
<span class="s1">const char *rd_kafka_topic_name(const rd_kafka_topic_t *rkt);</span>
<span class="s1">void *rd_kafka_topic_opaque(const rd_kafka_topic_t *rkt);</span>
<span class="s1">int rd_kafka_poll(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">void rd_kafka_yield(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_pause_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_resume_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_query_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_get_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offsets_for_times(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets, int timeout_ms);</span>
<span class="s1">void *rd_kafka_mem_calloc(rd_kafka_t *rk, size_t num, size_t size);</span>
<span class="s1">void *rd_kafka_mem_malloc(rd_kafka_t *rk, size_t size);</span>
<span class="s1">void rd_kafka_mem_free(rd_kafka_t *rk, void *ptr);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_new(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_queue_destroy(rd_kafka_queue_t *rkqu);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_main(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_sasl(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_sasl_background_callbacks_enable(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_sasl_set_credentials(rd_kafka_t *rk, const char *username, const char *password);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_consumer(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_partition(rd_kafka_t *rk, const char *topic, int32_t partition);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_background(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_queue_forward(rd_kafka_queue_t *src, rd_kafka_queue_t *dst);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_set_log_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu);</span>
<span class="s1">size_t rd_kafka_queue_length(rd_kafka_queue_t *rkqu);</span>
<span class="s1">void rd_kafka_queue_io_event_enable(rd_kafka_queue_t *rkqu, int fd, const void *payload, size_t size);</span>
<span class="s1">void rd_kafka_queue_cb_event_enable(rd_kafka_queue_t *rkqu, void (*event_cb)(rd_kafka_t *rk, void *qev_opaque), void *qev_opaque);</span>
<span class="s1">void rd_kafka_queue_yield(rd_kafka_queue_t *rkqu);</span>
<span class="s1">int rd_kafka_consume_start(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);</span>
<span class="s1">int rd_kafka_consume_start_queue(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, rd_kafka_queue_t *rkqu);</span>
<span class="s1">int rd_kafka_consume_stop(rd_kafka_topic_t *rkt, int32_t partition);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_seek(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, int timeout_ms);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_seek_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consume(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms);</span>
<span class="s1">ssize_t rd_kafka_consume_batch(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);</span>
<span class="s1">int rd_kafka_consume_callback(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consume_queue(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">ssize_t rd_kafka_consume_batch_queue(rd_kafka_queue_t *rkqu, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);</span>
<span class="s1">int rd_kafka_consume_callback_queue(rd_kafka_queue_t *rkqu, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offset_store(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offsets_store(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_offset_store_message(rd_kafka_message_t *rkmessage);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_subscribe(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *topics);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_unsubscribe(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_subscription(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **topics);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consumer_poll(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_consumer_close(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_consumer_close_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu);</span>
<span class="s1">int rd_kafka_consumer_closed(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_incremental_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_incremental_unassign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">const char *rd_kafka_rebalance_protocol(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_assignment(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **partitions);</span>
<span class="s1">int rd_kafka_assignment_lost(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, int async);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit_message(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, int async);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit_queue(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_queue_t *rkqu, void (*cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *commit_opaque), void *commit_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_committed(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_position(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata_new(const char *group_id);</span>
<span class="s1">rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata_new_with_genid(const char *group_id, int32_t generation_id, const char *member_id, const char *group_instance_id);</span>
<span class="s1">void rd_kafka_consumer_group_metadata_destroy(rd_kafka_consumer_group_metadata_t *);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_consumer_group_metadata_write(const rd_kafka_consumer_group_metadata_t *cgmd, void **bufferp, size_t *sizep);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_consumer_group_metadata_read(rd_kafka_consumer_group_metadata_t **cgmdp, const void *buffer, size_t size);</span>
<span class="s1">int rd_kafka_produce(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, void *payload, size_t len, const void *key, size_t keylen, void *msg_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_producev(rd_kafka_t *rk, ...);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_produceva(rd_kafka_t *rk, const rd_kafka_vu_t *vus, size_t cnt);</span>
<span class="s1">int rd_kafka_produce_batch(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, rd_kafka_message_t *rkmessages, int message_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_flush(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_purge(rd_kafka_t *rk, int purge_flags);</span>
<span class="s1">typedef struct rd_kafka_metadata_broker {</span>
<span class="s1">  int32_t id;</span>
<span class="s1">  char *host;</span>
<span class="s1">  int port;</span>
<span class="s1">} rd_kafka_metadata_broker_t;</span>
<span class="s1">typedef struct rd_kafka_metadata_partition {</span>
<span class="s1">  int32_t id;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  int32_t leader;</span>
<span class="s1">  int replica_cnt;</span>
<span class="s1">  int32_t *replicas;</span>
<span class="s1">  int isr_cnt;</span>
<span class="s1">  int32_t *isrs;</span>
<span class="s1">} rd_kafka_metadata_partition_t;</span>
<span class="s1">typedef struct rd_kafka_metadata_topic {</span>
<span class="s1">  char *topic;</span>
<span class="s1">  int partition_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_partition *partitions;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">} rd_kafka_metadata_topic_t;</span>
<span class="s1">typedef struct rd_kafka_metadata {</span>
<span class="s1">  int broker_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_broker *brokers;</span>
<span class="s1">  int topic_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_topic *topics;</span>
<span class="s1">  int32_t orig_broker_id;</span>
<span class="s1">  char *orig_broker_name;</span>
<span class="s1">} rd_kafka_metadata_t;</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_metadata(rd_kafka_t *rk, int all_topics, rd_kafka_topic_t *only_rkt, const struct rd_kafka_metadata **metadatap, int timeout_ms);</span>
<span class="s1">void rd_kafka_metadata_destroy(const struct rd_kafka_metadata *metadata);</span>
<span class="s1">typedef struct rd_kafka_Node_s rd_kafka_Node_t;</span>
<span class="s1">int rd_kafka_Node_id(const rd_kafka_Node_t *node);</span>
<span class="s1">const char *rd_kafka_Node_host(const rd_kafka_Node_t *node);</span>
<span class="s1">uint16_t rd_kafka_Node_port(const rd_kafka_Node_t *node);</span>
<span class="s1">struct rd_kafka_group_member_info {</span>
<span class="s1">  char *member_id;</span>
<span class="s1">  char *client_id;</span>
<span class="s1">  char *client_host;</span>
<span class="s1">  void *member_metadata;</span>
<span class="s1">  int member_metadata_size;</span>
<span class="s1">  void *member_assignment;</span>
<span class="s1">  int member_assignment_size;</span>
<span class="s1">};</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_CONSUMER_GROUP_STATE_UNKNOWN = 0,</span>
<span class="s1">  RD_KAFKA_CONSUMER_GROUP_STATE_PREPARING_REBALANCE = 1,</span>
<span class="s1">  RD_KAFKA_CONSUMER_GROUP_STATE_COMPLETING_REBALANCE = 2,</span>
<span class="s1">  RD_KAFKA_CONSUMER_GROUP_STATE_STABLE = 3,</span>
<span class="s1">  RD_KAFKA_CONSUMER_GROUP_STATE_DEAD = 4,</span>
<span class="s1">  RD_KAFKA_CONSUMER_GROUP_STATE_EMPTY = 5,</span>
<span class="s1">  RD_KAFKA_CONSUMER_GROUP_STATE__CNT,</span>
<span class="s1">} rd_kafka_consumer_group_state_t;</span>
<span class="s1">struct rd_kafka_group_info {</span>
<span class="s1">  struct rd_kafka_metadata_broker broker;</span>
<span class="s1">  char *group;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  char *state;</span>
<span class="s1">  char *protocol_type;</span>
<span class="s1">  char *protocol;</span>
<span class="s1">  struct rd_kafka_group_member_info *members;</span>
<span class="s1">  int member_cnt;</span>
<span class="s1">};</span>
<span class="s1">struct rd_kafka_group_list {</span>
<span class="s1">  struct rd_kafka_group_info *groups;</span>
<span class="s1">  int group_cnt;</span>
<span class="s1">};</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_list_groups(rd_kafka_t *rk, const char *group, const struct rd_kafka_group_list **grplistp, int timeout_ms);</span>
<span class="s1">const char *rd_kafka_consumer_group_state_name(rd_kafka_consumer_group_state_t state);</span>
<span class="s1">rd_kafka_consumer_group_state_t rd_kafka_consumer_group_state_code(const char *name);</span>
<span class="s1">void rd_kafka_group_list_destroy(const struct rd_kafka_group_list *grplist);</span>
<span class="s1">int rd_kafka_brokers_add(rd_kafka_t *rk, const char *brokerlist);</span>
<span class="s1">void rd_kafka_set_logger(rd_kafka_t *rk, void (*func)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));</span>
<span class="s1">void rd_kafka_set_log_level(rd_kafka_t *rk, int level);</span>
<span class="s1">void rd_kafka_log_print(const rd_kafka_t *rk, int level, const char *fac, const char *buf);</span>
<span class="s1">void rd_kafka_log_syslog(const rd_kafka_t *rk, int level, const char *fac, const char *buf);</span>
<span class="s1">int rd_kafka_outq_len(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_dump(FILE *fp, rd_kafka_t *rk);</span>
<span class="s1">int rd_kafka_thread_cnt(void);</span>
<span class="s1">typedef enum rd_kafka_thread_type_t {</span>
<span class="s1">  RD_KAFKA_THREAD_MAIN,</span>
<span class="s1">  RD_KAFKA_THREAD_BACKGROUND,</span>
<span class="s1">  RD_KAFKA_THREAD_BROKER,</span>
<span class="s1">} rd_kafka_thread_type_t;</span>
<span class="s1">int rd_kafka_wait_destroyed(int timeout_ms);</span>
<span class="s1">int rd_kafka_unittest(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_poll_set_consumer(rd_kafka_t *rk);</span>
<span class="s1">typedef int rd_kafka_event_type_t;</span>
<span class="s1">rd_kafka_event_type_t rd_kafka_event_type(const rd_kafka_event_t *rkev);</span>
<span class="s1">const char *rd_kafka_event_name(const rd_kafka_event_t *rkev);</span>
<span class="s1">void rd_kafka_event_destroy(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_message_t *rd_kafka_event_message_next(rd_kafka_event_t *rkev);</span>
<span class="s1">size_t rd_kafka_event_message_array(rd_kafka_event_t *rkev, const rd_kafka_message_t **rkmessages, size_t size);</span>
<span class="s1">size_t rd_kafka_event_message_count(rd_kafka_event_t *rkev);</span>
<span class="s1">const char *rd_kafka_event_config_string(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_event_error(rd_kafka_event_t *rkev);</span>
<span class="s1">const char *rd_kafka_event_error_string(rd_kafka_event_t *rkev);</span>
<span class="s1">int rd_kafka_event_error_is_fatal(rd_kafka_event_t *rkev);</span>
<span class="s1">void *rd_kafka_event_opaque(rd_kafka_event_t *rkev);</span>
<span class="s1">int rd_kafka_event_log(rd_kafka_event_t *rkev, const char **fac, const char **str, int *level);</span>
<span class="s1">int rd_kafka_event_debug_contexts(rd_kafka_event_t *rkev, char *dst, size_t dstsize);</span>
<span class="s1">const char *rd_kafka_event_stats(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_event_topic_partition_list(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_event_topic_partition(rd_kafka_event_t *rkev);</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_CreateTopics_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DeleteTopics_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_CreateAcls_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DescribeAcls_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DeleteAcls_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_CreatePartitions_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_AlterConfigs_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_IncrementalAlterConfigs_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DescribeConfigs_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DeleteRecords_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_ListConsumerGroups_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DescribeConsumerGroups_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DeleteGroups_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DeleteConsumerGroupOffsets_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_AlterConsumerGroupOffsets_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_ListConsumerGroupOffsets_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DescribeUserScramCredentials_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_AlterUserScramCredentials_result_t;</span>
<span class="s1">const rd_kafka_CreateTopics_result_t *rd_kafka_event_CreateTopics_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DeleteTopics_result_t *rd_kafka_event_DeleteTopics_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_CreatePartitions_result_t *rd_kafka_event_CreatePartitions_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_AlterConfigs_result_t *rd_kafka_event_AlterConfigs_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_IncrementalAlterConfigs_result_t *rd_kafka_event_IncrementalAlterConfigs_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DescribeConfigs_result_t *rd_kafka_event_DescribeConfigs_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DeleteRecords_result_t *rd_kafka_event_DeleteRecords_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_ListConsumerGroups_result_t *rd_kafka_event_ListConsumerGroups_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DescribeConsumerGroups_result_t *rd_kafka_event_DescribeConsumerGroups_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DeleteGroups_result_t *rd_kafka_event_DeleteGroups_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DeleteConsumerGroupOffsets_result_t *rd_kafka_event_DeleteConsumerGroupOffsets_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_CreateAcls_result_t *rd_kafka_event_CreateAcls_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DescribeAcls_result_t *rd_kafka_event_DescribeAcls_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DeleteAcls_result_t *rd_kafka_event_DeleteAcls_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_ListConsumerGroupOffsets_result_t *rd_kafka_event_ListConsumerGroupOffsets_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_AlterConsumerGroupOffsets_result_t *rd_kafka_event_AlterConsumerGroupOffsets_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DescribeUserScramCredentials_result_t *rd_kafka_event_DescribeUserScramCredentials_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_AlterUserScramCredentials_result_t *rd_kafka_event_AlterUserScramCredentials_result(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_event_t *rd_kafka_queue_poll(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">int rd_kafka_queue_poll_callback(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_plugin_f_conf_init_t)(rd_kafka_conf_t *conf, void **plug_opaquep, char *errstr, size_t errstr_size);</span>
<span class="s1">typedef rd_kafka_conf_res_t (rd_kafka_interceptor_f_on_conf_set_t)(rd_kafka_conf_t *conf, const char *name, const char *val, char *errstr, size_t errstr_size, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_dup_t)(rd_kafka_conf_t *new_conf, const rd_kafka_conf_t *old_conf, size_t filter_cnt, const char **filter, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_destroy_t)(void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_new_t)(rd_kafka_t *rk, const rd_kafka_conf_t *conf, void *ic_opaque, char *errstr, size_t errstr_size);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_destroy_t)(rd_kafka_t *rk, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_send_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_acknowledgement_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_consume_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_commit_t)(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_resp_err_t err, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_request_sent_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_response_received_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, int64_t rtt, rd_kafka_resp_err_t err, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_start_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_exit_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_broker_state_change_t)(rd_kafka_t *rk, int32_t broker_id, const char *secproto, const char *name, int port, const char *state, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_set(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_set_t *on_conf_set, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_dup(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_dup_t *on_conf_dup, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_destroy(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_destroy_t *on_conf_destroy, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_new(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_new_t *on_new, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_destroy(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_destroy_t *on_destroy, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_send(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_send_t *on_send, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_acknowledgement(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_acknowledgement_t *on_acknowledgement, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_consume(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_consume_t *on_consume, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_commit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_commit_t *on_commit, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_request_sent(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_request_sent_t *on_request_sent, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_response_received(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_response_received_t *on_response_received, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_start(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_start_t *on_thread_start, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_exit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_exit_t *on_thread_exit, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_broker_state_change(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_broker_state_change_t *on_broker_state_change, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_topic_result_error(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">const char *rd_kafka_topic_result_error_string(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">const char *rd_kafka_topic_result_name(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">const rd_kafka_error_t *rd_kafka_group_result_error(const rd_kafka_group_result_t *groupres);</span>
<span class="s1">const char *rd_kafka_group_result_name(const rd_kafka_group_result_t *groupres);</span>
<span class="s1">const rd_kafka_topic_partition_list_t *rd_kafka_group_result_partitions(const rd_kafka_group_result_t *groupres);</span>
<span class="s1">typedef enum rd_kafka_admin_op_t {</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_ANY = 0,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_CREATETOPICS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DELETETOPICS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_CREATEPARTITIONS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_ALTERCONFIGS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DESCRIBECONFIGS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DELETERECORDS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DELETEGROUPS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DELETECONSUMERGROUPOFFSETS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_CREATEACLS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DESCRIBEACLS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DELETEACLS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_LISTCONSUMERGROUPS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DESCRIBECONSUMERGROUPS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_LISTCONSUMERGROUPOFFSETS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_ALTERCONSUMERGROUPOFFSETS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_INCREMENTALALTERCONFIGS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DESCRIBEUSERSCRAMCREDENTIALS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_ALTERUSERSCRAMCREDENTIALS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP__CNT,</span>
<span class="s1">} rd_kafka_admin_op_t;</span>
<span class="s1">typedef struct rd_kafka_AdminOptions_s rd_kafka_AdminOptions_t;</span>
<span class="s1">rd_kafka_AdminOptions_t *rd_kafka_AdminOptions_new(rd_kafka_t *rk, rd_kafka_admin_op_t for_api);</span>
<span class="s1">void rd_kafka_AdminOptions_destroy(rd_kafka_AdminOptions_t *options);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_request_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_operation_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_validate_only(rd_kafka_AdminOptions_t *options, int true_or_false, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_broker(rd_kafka_AdminOptions_t *options, int32_t broker_id, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_AdminOptions_set_require_stable_offsets(rd_kafka_AdminOptions_t *options, int true_or_false);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_AdminOptions_set_match_consumer_group_states(rd_kafka_AdminOptions_t *options, const rd_kafka_consumer_group_state_t *consumer_group_states, size_t consumer_group_states_cnt);</span>
<span class="s1">void rd_kafka_AdminOptions_set_opaque(rd_kafka_AdminOptions_t *options, void *ev_opaque);</span>
<span class="s1">typedef struct rd_kafka_NewTopic_s rd_kafka_NewTopic_t;</span>
<span class="s1">rd_kafka_NewTopic_t *rd_kafka_NewTopic_new(const char *topic, int num_partitions, int replication_factor, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_NewTopic_destroy(rd_kafka_NewTopic_t *new_topic);</span>
<span class="s1">void rd_kafka_NewTopic_destroy_array(rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewTopic_set_replica_assignment(rd_kafka_NewTopic_t *new_topic, int32_t partition, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewTopic_set_config(rd_kafka_NewTopic_t *new_topic, const char *name, const char *value);</span>
<span class="s1">void rd_kafka_CreateTopics(rd_kafka_t *rk, rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_CreateTopics_result_topics(const rd_kafka_CreateTopics_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_DeleteTopic_s rd_kafka_DeleteTopic_t;</span>
<span class="s1">rd_kafka_DeleteTopic_t *rd_kafka_DeleteTopic_new(const char *topic);</span>
<span class="s1">void rd_kafka_DeleteTopic_destroy(rd_kafka_DeleteTopic_t *del_topic);</span>
<span class="s1">void rd_kafka_DeleteTopic_destroy_array(rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt);</span>
<span class="s1">void rd_kafka_DeleteTopics(rd_kafka_t *rk, rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_DeleteTopics_result_topics(const rd_kafka_DeleteTopics_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_NewPartitions_s rd_kafka_NewPartitions_t;</span>
<span class="s1">rd_kafka_NewPartitions_t *rd_kafka_NewPartitions_new(const char *topic, size_t new_total_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_NewPartitions_destroy(rd_kafka_NewPartitions_t *new_parts);</span>
<span class="s1">void rd_kafka_NewPartitions_destroy_array(rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewPartitions_set_replica_assignment(rd_kafka_NewPartitions_t *new_parts, int32_t new_partition_idx, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_CreatePartitions(rd_kafka_t *rk, rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_CreatePartitions_result_topics(const rd_kafka_CreatePartitions_result_t *result, size_t *cntp);</span>
<span class="s1">typedef enum rd_kafka_ConfigSource_t {</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_UNKNOWN_CONFIG = 0,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_TOPIC_CONFIG = 1,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_BROKER_CONFIG = 2,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_DEFAULT_BROKER_CONFIG = 3,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_STATIC_BROKER_CONFIG = 4,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DEFAULT_CONFIG = 5,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE__CNT,</span>
<span class="s1">} rd_kafka_ConfigSource_t;</span>
<span class="s1">const char *rd_kafka_ConfigSource_name(rd_kafka_ConfigSource_t confsource);</span>
<span class="s1">typedef struct rd_kafka_ConfigEntry_s rd_kafka_ConfigEntry_t;</span>
<span class="s1">const char *rd_kafka_ConfigEntry_name(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">const char *rd_kafka_ConfigEntry_value(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">rd_kafka_ConfigSource_t rd_kafka_ConfigEntry_source(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_read_only(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_default(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_sensitive(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_synonym(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">const rd_kafka_ConfigEntry_t **rd_kafka_ConfigEntry_synonyms(const rd_kafka_ConfigEntry_t *entry, size_t *cntp);</span>
<span class="s1">typedef enum rd_kafka_ResourceType_t {</span>
<span class="s1">  RD_KAFKA_RESOURCE_UNKNOWN = 0,</span>
<span class="s1">  RD_KAFKA_RESOURCE_ANY = 1,</span>
<span class="s1">  RD_KAFKA_RESOURCE_TOPIC = 2,</span>
<span class="s1">  RD_KAFKA_RESOURCE_GROUP = 3,</span>
<span class="s1">  RD_KAFKA_RESOURCE_BROKER = 4,</span>
<span class="s1">  RD_KAFKA_RESOURCE__CNT,</span>
<span class="s1">} rd_kafka_ResourceType_t;</span>
<span class="s1">typedef enum rd_kafka_ResourcePatternType_t {</span>
<span class="s1">  RD_KAFKA_RESOURCE_PATTERN_UNKNOWN = 0,</span>
<span class="s1">  RD_KAFKA_RESOURCE_PATTERN_ANY = 1,</span>
<span class="s1">  RD_KAFKA_RESOURCE_PATTERN_MATCH = 2,</span>
<span class="s1">  RD_KAFKA_RESOURCE_PATTERN_LITERAL = 3,</span>
<span class="s1">  RD_KAFKA_RESOURCE_PATTERN_PREFIXED = 4,</span>
<span class="s1">  RD_KAFKA_RESOURCE_PATTERN_TYPE__CNT,</span>
<span class="s1">} rd_kafka_ResourcePatternType_t;</span>
<span class="s1">typedef enum rd_kafka_AlterConfigOpType_t {</span>
<span class="s1">  RD_KAFKA_ALTER_CONFIG_OP_TYPE_SET = 0,</span>
<span class="s1">  RD_KAFKA_ALTER_CONFIG_OP_TYPE_DELETE = 1,</span>
<span class="s1">  RD_KAFKA_ALTER_CONFIG_OP_TYPE_APPEND = 2,</span>
<span class="s1">  RD_KAFKA_ALTER_CONFIG_OP_TYPE_SUBTRACT = 3,</span>
<span class="s1">  RD_KAFKA_ALTER_CONFIG_OP_TYPE__CNT,</span>
<span class="s1">} rd_kafka_AlterConfigOpType_t;</span>
<span class="s1">const char *rd_kafka_ResourcePatternType_name(rd_kafka_ResourcePatternType_t resource_pattern_type);</span>
<span class="s1">const char *rd_kafka_ResourceType_name(rd_kafka_ResourceType_t restype);</span>
<span class="s1">typedef struct rd_kafka_ConfigResource_s rd_kafka_ConfigResource_t;</span>
<span class="s1">rd_kafka_ConfigResource_t *rd_kafka_ConfigResource_new(rd_kafka_ResourceType_t restype, const char *resname);</span>
<span class="s1">void rd_kafka_ConfigResource_destroy(rd_kafka_ConfigResource_t *config);</span>
<span class="s1">void rd_kafka_ConfigResource_destroy_array(rd_kafka_ConfigResource_t **config, size_t config_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_ConfigResource_set_config(rd_kafka_ConfigResource_t *config, const char *name, const char *value);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_ConfigResource_add_incremental_config(rd_kafka_ConfigResource_t *config, const char *name, rd_kafka_AlterConfigOpType_t op_type, const char *value);</span>
<span class="s1">const rd_kafka_ConfigEntry_t **rd_kafka_ConfigResource_configs(const rd_kafka_ConfigResource_t *config, size_t *cntp);</span>
<span class="s1">rd_kafka_ResourceType_t rd_kafka_ConfigResource_type(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">const char *rd_kafka_ConfigResource_name(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_ConfigResource_error(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">const char *rd_kafka_ConfigResource_error_string(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">void rd_kafka_AlterConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_ConfigResource_t **rd_kafka_AlterConfigs_result_resources(const rd_kafka_AlterConfigs_result_t *result, size_t *cntp);</span>
<span class="s1">void rd_kafka_IncrementalAlterConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_ConfigResource_t **rd_kafka_IncrementalAlterConfigs_result_resources(const rd_kafka_IncrementalAlterConfigs_result_t *result, size_t *cntp);</span>
<span class="s1">void rd_kafka_DescribeConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_ConfigResource_t **rd_kafka_DescribeConfigs_result_resources(const rd_kafka_DescribeConfigs_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_DeleteRecords_s rd_kafka_DeleteRecords_t;</span>
<span class="s1">rd_kafka_DeleteRecords_t *rd_kafka_DeleteRecords_new(const rd_kafka_topic_partition_list_t *before_offsets);</span>
<span class="s1">void rd_kafka_DeleteRecords_destroy(rd_kafka_DeleteRecords_t *del_records);</span>
<span class="s1">void rd_kafka_DeleteRecords_destroy_array(rd_kafka_DeleteRecords_t **del_records, size_t del_record_cnt);</span>
<span class="s1">void rd_kafka_DeleteRecords(rd_kafka_t *rk, rd_kafka_DeleteRecords_t **del_records, size_t del_record_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_partition_list_t *rd_kafka_DeleteRecords_result_offsets(const rd_kafka_DeleteRecords_result_t *result);</span>
<span class="s1">typedef struct rd_kafka_ConsumerGroupListing_s rd_kafka_ConsumerGroupListing_t;</span>
<span class="s1">typedef struct rd_kafka_ListConsumerGroupsResult_s rd_kafka_ListConsumerGroupsResult_t;</span>
<span class="s1">void rd_kafka_ListConsumerGroups(rd_kafka_t *rk, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const char *rd_kafka_ConsumerGroupListing_group_id(const rd_kafka_ConsumerGroupListing_t *grplist);</span>
<span class="s1">int rd_kafka_ConsumerGroupListing_is_simple_consumer_group(const rd_kafka_ConsumerGroupListing_t *grplist);</span>
<span class="s1">rd_kafka_consumer_group_state_t rd_kafka_ConsumerGroupListing_state(const rd_kafka_ConsumerGroupListing_t *grplist);</span>
<span class="s1">const rd_kafka_ConsumerGroupListing_t **rd_kafka_ListConsumerGroups_result_valid(const rd_kafka_ListConsumerGroups_result_t *result, size_t *cntp);</span>
<span class="s1">const rd_kafka_error_t **rd_kafka_ListConsumerGroups_result_errors(const rd_kafka_ListConsumerGroups_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_ConsumerGroupDescription_s rd_kafka_ConsumerGroupDescription_t;</span>
<span class="s1">typedef struct rd_kafka_MemberDescription_s rd_kafka_MemberDescription_t;</span>
<span class="s1">typedef struct rd_kafka_MemberAssignment_s rd_kafka_MemberAssignment_t;</span>
<span class="s1">void rd_kafka_DescribeConsumerGroups(rd_kafka_t *rk, const char **groups, size_t groups_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_ConsumerGroupDescription_t **rd_kafka_DescribeConsumerGroups_result_groups(const rd_kafka_DescribeConsumerGroups_result_t *result, size_t *cntp);</span>
<span class="s1">const char *rd_kafka_ConsumerGroupDescription_group_id(const rd_kafka_ConsumerGroupDescription_t *grpdesc);</span>
<span class="s1">const rd_kafka_error_t *rd_kafka_ConsumerGroupDescription_error(const rd_kafka_ConsumerGroupDescription_t *grpdesc);</span>
<span class="s1">int rd_kafka_ConsumerGroupDescription_is_simple_consumer_group(const rd_kafka_ConsumerGroupDescription_t *grpdesc);</span>
<span class="s1">const char *rd_kafka_ConsumerGroupDescription_partition_assignor(const rd_kafka_ConsumerGroupDescription_t *grpdesc);</span>
<span class="s1">rd_kafka_consumer_group_state_t rd_kafka_ConsumerGroupDescription_state(const rd_kafka_ConsumerGroupDescription_t *grpdesc);</span>
<span class="s1">const rd_kafka_Node_t *rd_kafka_ConsumerGroupDescription_coordinator(const rd_kafka_ConsumerGroupDescription_t *grpdesc);</span>
<span class="s1">size_t rd_kafka_ConsumerGroupDescription_member_count(const rd_kafka_ConsumerGroupDescription_t *grpdesc);</span>
<span class="s1">const rd_kafka_MemberDescription_t *rd_kafka_ConsumerGroupDescription_member(const rd_kafka_ConsumerGroupDescription_t *grpdesc, size_t idx);</span>
<span class="s1">const char *rd_kafka_MemberDescription_client_id(const rd_kafka_MemberDescription_t *member);</span>
<span class="s1">const char *rd_kafka_MemberDescription_group_instance_id(const rd_kafka_MemberDescription_t *member);</span>
<span class="s1">const char *rd_kafka_MemberDescription_consumer_id(const rd_kafka_MemberDescription_t *member);</span>
<span class="s1">const char *rd_kafka_MemberDescription_host(const rd_kafka_MemberDescription_t *member);</span>
<span class="s1">const rd_kafka_MemberAssignment_t *rd_kafka_MemberDescription_assignment(const rd_kafka_MemberDescription_t *member);</span>
<span class="s1">const rd_kafka_topic_partition_list_t *rd_kafka_MemberAssignment_partitions(const rd_kafka_MemberAssignment_t *assignment);</span>
<span class="s1">typedef struct rd_kafka_DeleteGroup_s rd_kafka_DeleteGroup_t;</span>
<span class="s1">rd_kafka_DeleteGroup_t *rd_kafka_DeleteGroup_new(const char *group);</span>
<span class="s1">void rd_kafka_DeleteGroup_destroy(rd_kafka_DeleteGroup_t *del_group);</span>
<span class="s1">void rd_kafka_DeleteGroup_destroy_array(rd_kafka_DeleteGroup_t **del_groups, size_t del_group_cnt);</span>
<span class="s1">void rd_kafka_DeleteGroups(rd_kafka_t *rk, rd_kafka_DeleteGroup_t **del_groups, size_t del_group_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_group_result_t **rd_kafka_DeleteGroups_result_groups(const rd_kafka_DeleteGroups_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_ListConsumerGroupOffsets_s rd_kafka_ListConsumerGroupOffsets_t;</span>
<span class="s1">rd_kafka_ListConsumerGroupOffsets_t *rd_kafka_ListConsumerGroupOffsets_new(const char *group_id, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">void rd_kafka_ListConsumerGroupOffsets_destroy(rd_kafka_ListConsumerGroupOffsets_t *list_grpoffsets);</span>
<span class="s1">void rd_kafka_ListConsumerGroupOffsets_destroy_array(rd_kafka_ListConsumerGroupOffsets_t **list_grpoffsets, size_t list_grpoffset_cnt);</span>
<span class="s1">void rd_kafka_ListConsumerGroupOffsets(rd_kafka_t *rk, rd_kafka_ListConsumerGroupOffsets_t **list_grpoffsets, size_t list_grpoffsets_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_group_result_t **rd_kafka_ListConsumerGroupOffsets_result_groups(const rd_kafka_ListConsumerGroupOffsets_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_AlterConsumerGroupOffsets_s rd_kafka_AlterConsumerGroupOffsets_t;</span>
<span class="s1">rd_kafka_AlterConsumerGroupOffsets_t *rd_kafka_AlterConsumerGroupOffsets_new(const char *group_id, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">void rd_kafka_AlterConsumerGroupOffsets_destroy(rd_kafka_AlterConsumerGroupOffsets_t *alter_grpoffsets);</span>
<span class="s1">void rd_kafka_AlterConsumerGroupOffsets_destroy_array(rd_kafka_AlterConsumerGroupOffsets_t **alter_grpoffsets, size_t alter_grpoffset_cnt);</span>
<span class="s1">void rd_kafka_AlterConsumerGroupOffsets(rd_kafka_t *rk, rd_kafka_AlterConsumerGroupOffsets_t **alter_grpoffsets, size_t alter_grpoffsets_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_group_result_t **rd_kafka_AlterConsumerGroupOffsets_result_groups(const rd_kafka_AlterConsumerGroupOffsets_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_DeleteConsumerGroupOffsets_s rd_kafka_DeleteConsumerGroupOffsets_t;</span>
<span class="s1">rd_kafka_DeleteConsumerGroupOffsets_t *rd_kafka_DeleteConsumerGroupOffsets_new(const char *group, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">void rd_kafka_DeleteConsumerGroupOffsets_destroy(rd_kafka_DeleteConsumerGroupOffsets_t *del_grpoffsets);</span>
<span class="s1">void rd_kafka_DeleteConsumerGroupOffsets_destroy_array(rd_kafka_DeleteConsumerGroupOffsets_t **del_grpoffsets, size_t del_grpoffset_cnt);</span>
<span class="s1">void rd_kafka_DeleteConsumerGroupOffsets(rd_kafka_t *rk, rd_kafka_DeleteConsumerGroupOffsets_t **del_grpoffsets, size_t del_grpoffsets_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_group_result_t **rd_kafka_DeleteConsumerGroupOffsets_result_groups(const rd_kafka_DeleteConsumerGroupOffsets_result_t *result, size_t *cntp);</span>
<span class="s1">typedef enum rd_kafka_ScramMechanism_t {</span>
<span class="s1">  RD_KAFKA_SCRAM_MECHANISM_UNKNOWN = 0,</span>
<span class="s1">  RD_KAFKA_SCRAM_MECHANISM_SHA_256 = 1,</span>
<span class="s1">  RD_KAFKA_SCRAM_MECHANISM_SHA_512 = 2,</span>
<span class="s1">  RD_KAFKA_SCRAM_MECHANISM__CNT,</span>
<span class="s1">} rd_kafka_ScramMechanism_t;</span>
<span class="s1">typedef struct rd_kafka_ScramCredentialInfo_s rd_kafka_ScramCredentialInfo_t;</span>
<span class="s1">rd_kafka_ScramMechanism_t rd_kafka_ScramCredentialInfo_mechanism(const rd_kafka_ScramCredentialInfo_t *scram_credential_info);</span>
<span class="s1">int32_t rd_kafka_ScramCredentialInfo_iterations(const rd_kafka_ScramCredentialInfo_t *scram_credential_info);</span>
<span class="s1">typedef struct rd_kafka_UserScramCredentialsDescription_s rd_kafka_UserScramCredentialsDescription_t;</span>
<span class="s1">const char *rd_kafka_UserScramCredentialsDescription_user(const rd_kafka_UserScramCredentialsDescription_t *description);</span>
<span class="s1">const rd_kafka_error_t *rd_kafka_UserScramCredentialsDescription_error(const rd_kafka_UserScramCredentialsDescription_t *description);</span>
<span class="s1">size_t rd_kafka_UserScramCredentialsDescription_scramcredentialinfo_count(const rd_kafka_UserScramCredentialsDescription_t *description);</span>
<span class="s1">const rd_kafka_ScramCredentialInfo_t *rd_kafka_UserScramCredentialsDescription_scramcredentialinfo(const rd_kafka_UserScramCredentialsDescription_t *description, size_t idx);</span>
<span class="s1">const rd_kafka_UserScramCredentialsDescription_t **rd_kafka_DescribeUserScramCredentials_result_descriptions(const rd_kafka_DescribeUserScramCredentials_result_t *result, size_t *cntp);</span>
<span class="s1">void rd_kafka_DescribeUserScramCredentials(rd_kafka_t *rk, const char **users, size_t user_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">typedef struct rd_kafka_UserScramCredentialAlteration_s rd_kafka_UserScramCredentialAlteration_t;</span>
<span class="s1">rd_kafka_UserScramCredentialAlteration_t *rd_kafka_UserScramCredentialUpsertion_new(const char *username, rd_kafka_ScramMechanism_t mechanism, int32_t iterations, const unsigned char *password, size_t password_size, const unsigned char *salt, size_t salt_size);</span>
<span class="s1">rd_kafka_UserScramCredentialAlteration_t *rd_kafka_UserScramCredentialDeletion_new(const char *username, rd_kafka_ScramMechanism_t mechanism);</span>
<span class="s1">void rd_kafka_UserScramCredentialAlteration_destroy(rd_kafka_UserScramCredentialAlteration_t *alteration);</span>
<span class="s1">void rd_kafka_UserScramCredentialAlteration_destroy_array(rd_kafka_UserScramCredentialAlteration_t **alterations, size_t alteration_cnt);</span>
<span class="s1">typedef struct rd_kafka_AlterUserScramCredentials_result_response_s rd_kafka_AlterUserScramCredentials_result_response_t;</span>
<span class="s1">const char *rd_kafka_AlterUserScramCredentials_result_response_user(const rd_kafka_AlterUserScramCredentials_result_response_t *response);</span>
<span class="s1">const rd_kafka_error_t *rd_kafka_AlterUserScramCredentials_result_response_error(const rd_kafka_AlterUserScramCredentials_result_response_t *response);</span>
<span class="s1">const rd_kafka_AlterUserScramCredentials_result_response_t **rd_kafka_AlterUserScramCredentials_result_responses(const rd_kafka_AlterUserScramCredentials_result_t *result, size_t *cntp);</span>
<span class="s1">void rd_kafka_AlterUserScramCredentials(rd_kafka_t *rk, rd_kafka_UserScramCredentialAlteration_t **alterations, size_t alteration_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">typedef struct rd_kafka_AclBinding_s rd_kafka_AclBinding_t;</span>
<span class="s1">typedef rd_kafka_AclBinding_t rd_kafka_AclBindingFilter_t;</span>
<span class="s1">const rd_kafka_error_t *rd_kafka_acl_result_error(const rd_kafka_acl_result_t *aclres);</span>
<span class="s1">typedef enum rd_kafka_AclOperation_t {</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_UNKNOWN = 0,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_ANY = 1,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_ALL = 2,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_READ = 3,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_WRITE = 4,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_CREATE = 5,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_DELETE = 6,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_ALTER = 7,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_DESCRIBE = 8,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_CLUSTER_ACTION = 9,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_DESCRIBE_CONFIGS = 10,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_ALTER_CONFIGS = 11,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_IDEMPOTENT_WRITE = 12,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION__CNT,</span>
<span class="s1">} rd_kafka_AclOperation_t;</span>
<span class="s1">const char *rd_kafka_AclOperation_name(rd_kafka_AclOperation_t acl_operation);</span>
<span class="s1">typedef enum rd_kafka_AclPermissionType_t {</span>
<span class="s1">  RD_KAFKA_ACL_PERMISSION_TYPE_UNKNOWN = 0,</span>
<span class="s1">  RD_KAFKA_ACL_PERMISSION_TYPE_ANY = 1,</span>
<span class="s1">  RD_KAFKA_ACL_PERMISSION_TYPE_DENY = 2,</span>
<span class="s1">  RD_KAFKA_ACL_PERMISSION_TYPE_ALLOW = 3,</span>
<span class="s1">  RD_KAFKA_ACL_PERMISSION_TYPE__CNT,</span>
<span class="s1">} rd_kafka_AclPermissionType_t;</span>
<span class="s1">const char *rd_kafka_AclPermissionType_name(rd_kafka_AclPermissionType_t acl_permission_type);</span>
<span class="s1">rd_kafka_AclBinding_t *rd_kafka_AclBinding_new(rd_kafka_ResourceType_t restype, const char *name, rd_kafka_ResourcePatternType_t resource_pattern_type, const char *principal, const char *host, rd_kafka_AclOperation_t operation, rd_kafka_AclPermissionType_t permission_type, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_AclBindingFilter_t *rd_kafka_AclBindingFilter_new(rd_kafka_ResourceType_t restype, const char *name, rd_kafka_ResourcePatternType_t resource_pattern_type, const char *principal, const char *host, rd_kafka_AclOperation_t operation, rd_kafka_AclPermissionType_t permission_type, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_ResourceType_t rd_kafka_AclBinding_restype(const rd_kafka_AclBinding_t *acl);</span>
<span class="s1">const char *rd_kafka_AclBinding_name(const rd_kafka_AclBinding_t *acl);</span>
<span class="s1">const char *rd_kafka_AclBinding_principal(const rd_kafka_AclBinding_t *acl);</span>
<span class="s1">const char *rd_kafka_AclBinding_host(const rd_kafka_AclBinding_t *acl);</span>
<span class="s1">rd_kafka_AclOperation_t rd_kafka_AclBinding_operation(const rd_kafka_AclBinding_t *acl);</span>
<span class="s1">rd_kafka_AclPermissionType_t rd_kafka_AclBinding_permission_type(const rd_kafka_AclBinding_t *acl);</span>
<span class="s1">rd_kafka_ResourcePatternType_t rd_kafka_AclBinding_resource_pattern_type(const rd_kafka_AclBinding_t *acl);</span>
<span class="s1">const rd_kafka_error_t *rd_kafka_AclBinding_error(const rd_kafka_AclBinding_t *acl);</span>
<span class="s1">void rd_kafka_AclBinding_destroy(rd_kafka_AclBinding_t *acl_binding);</span>
<span class="s1">void rd_kafka_AclBinding_destroy_array(rd_kafka_AclBinding_t **acl_bindings, size_t acl_bindings_cnt);</span>
<span class="s1">const rd_kafka_acl_result_t **rd_kafka_CreateAcls_result_acls(const rd_kafka_CreateAcls_result_t *result, size_t *cntp);</span>
<span class="s1">void rd_kafka_CreateAcls(rd_kafka_t *rk, rd_kafka_AclBinding_t **new_acls, size_t new_acls_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_AclBinding_t **rd_kafka_DescribeAcls_result_acls(const rd_kafka_DescribeAcls_result_t *result, size_t *cntp);</span>
<span class="s1">void rd_kafka_DescribeAcls(rd_kafka_t *rk, rd_kafka_AclBindingFilter_t *acl_filter, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">typedef struct rd_kafka_DeleteAcls_result_response_s rd_kafka_DeleteAcls_result_response_t;</span>
<span class="s1">const rd_kafka_DeleteAcls_result_response_t **rd_kafka_DeleteAcls_result_responses(const rd_kafka_DeleteAcls_result_t *result, size_t *cntp);</span>
<span class="s1">const rd_kafka_error_t *rd_kafka_DeleteAcls_result_response_error(const rd_kafka_DeleteAcls_result_response_t *result_response);</span>
<span class="s1">const rd_kafka_AclBinding_t **rd_kafka_DeleteAcls_result_response_matching_acls(const rd_kafka_DeleteAcls_result_response_t *result_response, size_t *matching_acls_cntp);</span>
<span class="s1">void rd_kafka_DeleteAcls(rd_kafka_t *rk, rd_kafka_AclBindingFilter_t **del_acls, size_t del_acls_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token(rd_kafka_t *rk, const char *token_value, int64_t md_lifetime_ms, const char *md_principal_name, const char **extensions, size_t extension_size, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token_failure(rd_kafka_t *rk, const char *errstr);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_init_transactions(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_begin_transaction(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_send_offsets_to_transaction(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, const rd_kafka_consumer_group_metadata_t *cgmetadata, int timeout_ms);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_commit_transaction(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_abort_transaction(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">typedef struct rd_kafka_mock_cluster_s rd_kafka_mock_cluster_t;</span>
<span class="s1">rd_kafka_mock_cluster_t *rd_kafka_mock_cluster_new(rd_kafka_t *rk, int broker_cnt);</span>
<span class="s1">void rd_kafka_mock_cluster_destroy(rd_kafka_mock_cluster_t *mcluster);</span>
<span class="s1">rd_kafka_t *rd_kafka_mock_cluster_handle(const rd_kafka_mock_cluster_t *mcluster);</span>
<span class="s1">rd_kafka_mock_cluster_t *rd_kafka_handle_mock_cluster(const rd_kafka_t *rk);</span>
<span class="s1">const char *rd_kafka_mock_cluster_bootstraps(const rd_kafka_mock_cluster_t *mcluster);</span>
<span class="s1">void rd_kafka_mock_clear_request_errors(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey);</span>
<span class="s1">void rd_kafka_mock_push_request_errors(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, size_t cnt, ...);</span>
<span class="s1">void rd_kafka_mock_push_request_errors_array(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, size_t cnt, const rd_kafka_resp_err_t *errors);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_push_request_error_rtts(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int16_t ApiKey, size_t cnt, ...);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_error_stack_cnt(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int16_t ApiKey, size_t *cntp);</span>
<span class="s1">void rd_kafka_mock_topic_set_error(rd_kafka_mock_cluster_t *mcluster, const char *topic, rd_kafka_resp_err_t err);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_topic_create(rd_kafka_mock_cluster_t *mcluster, const char *topic, int partition_cnt, int replication_factor);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_partition_set_leader(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_partition_set_follower(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_partition_set_follower_wmarks(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int64_t lo, int64_t hi);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_set_down(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_set_up(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_set_rtt(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int rtt_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_set_rack(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, const char *rack);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_coordinator_set(rd_kafka_mock_cluster_t *mcluster, const char *key_type, const char *key, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_set_apiversion(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, int16_t MinVersion, int16_t MaxVersion);</span>
<span class="s1">&#39;</span>
</code></pre></div>
rdkafka.h, rdkafka_mock.h</p>
<h3 id="rd_kafka_version_29">RD_KAFKA_VERSION<a class="headerlink" href="#rd_kafka_version_29" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_VERSION</span> <span class="o">=</span> <span class="mi">33751295</span>
</code></pre></div>
<p>librdkafka version </p>
<p>Interpreted as hex <code>MM.mm.rr.xx</code>:</p>
<ul>
<li>MM = Major</li>
<li>mm = minor</li>
<li>rr = revision</li>
<li>xx = pre-release id (0xff is the final release)</li>
</ul>
<p>E.g.: <code>0x000801ff</code> = 0.8.1</p>
<dl class="section remark"><dt>Remarks</dt><dd>This value should only be used during compile time, for runtime checks of version use rd_kafka_version() </dd></dl>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_unsupported_compression_type_29">RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE<a class="headerlink" href="#rd_kafka_resp_err_unsupported_compression_type_29" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE</span> <span class="o">=</span> <span class="mi">76</span>
</code></pre></div>
<p>Unsupported compression type </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_end_all_29">RD_KAFKA_RESP_ERR_END_ALL<a class="headerlink" href="#rd_kafka_resp_err_end_all_29" title="Permanent link">&para;</a></h3>
<p><div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_END_ALL</span> <span class="o">=</span> <span class="mi">98</span>
</code></pre></div>
enum rd_kafka_resp_err_t</p>
<h3 id="rd_kafka_admin_op__cnt_29">RD_KAFKA_ADMIN_OP__CNT<a class="headerlink" href="#rd_kafka_admin_op__cnt_29" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_ADMIN_OP__CNT</span> <span class="o">=</span> <span class="mi">22</span>
</code></pre></div>
<p>Number of ops defined </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe </a></li>
</ul>
</div>
<h3 id="rd_kafka_resource__cnt_29">RD_KAFKA_RESOURCE__CNT<a class="headerlink" href="#rd_kafka_resource__cnt_29" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESOURCE__CNT</span> <span class="o">=</span> <span class="mi">5</span>
</code></pre></div>
<p>Number of resource types defined </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#acca83a66d7783ff7683ed2691cc907c9"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#acca83a66d7783ff7683ed2691cc907c9 </a></li>
</ul>
</div>
<h3 id="rd_kafka_cdef_29">RD_KAFKA_CDEF<a class="headerlink" href="#rd_kafka_cdef_29" title="Permanent link">&para;</a></h3>
<p><div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_CDEF</span> <span class="o">=</span> <span class="s1">&#39;typedef long int ssize_t;</span>
<span class="s1">typedef struct _IO_FILE FILE;</span>
<span class="s1">typedef long int mode_t;</span>
<span class="s1">typedef signed int int16_t;</span>
<span class="s1">typedef unsigned int uint16_t;</span>
<span class="s1">typedef signed int int32_t;</span>
<span class="s1">typedef signed long int int64_t;</span>
<span class="s1">int rd_kafka_version(void);</span>
<span class="s1">const char *rd_kafka_version_str(void);</span>
<span class="s1">typedef enum rd_kafka_type_t {</span>
<span class="s1">  RD_KAFKA_PRODUCER,</span>
<span class="s1">  RD_KAFKA_CONSUMER,</span>
<span class="s1">} rd_kafka_type_t;</span>
<span class="s1">typedef enum rd_kafka_timestamp_type_t {</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_NOT_AVAILABLE,</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_CREATE_TIME,</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_LOG_APPEND_TIME,</span>
<span class="s1">} rd_kafka_timestamp_type_t;</span>
<span class="s1">const char *rd_kafka_get_debug_contexts(void);</span>
<span class="s1">typedef struct rd_kafka_s rd_kafka_t;</span>
<span class="s1">typedef struct rd_kafka_topic_s rd_kafka_topic_t;</span>
<span class="s1">typedef struct rd_kafka_conf_s rd_kafka_conf_t;</span>
<span class="s1">typedef struct rd_kafka_topic_conf_s rd_kafka_topic_conf_t;</span>
<span class="s1">typedef struct rd_kafka_queue_s rd_kafka_queue_t;</span>
<span class="s1">typedef struct rd_kafka_op_s rd_kafka_event_t;</span>
<span class="s1">typedef struct rd_kafka_topic_result_s rd_kafka_topic_result_t;</span>
<span class="s1">typedef struct rd_kafka_consumer_group_metadata_s rd_kafka_consumer_group_metadata_t;</span>
<span class="s1">typedef struct rd_kafka_error_s {</span>
<span class="s1">  unsigned int code;</span>
<span class="s1">  char *errstr;</span>
<span class="s1">  unsigned char fatal;</span>
<span class="s1">  unsigned char retriable;</span>
<span class="s1">  unsigned char txn_requires_abort;</span>
<span class="s1">} rd_kafka_error_t;</span>
<span class="s1">typedef struct rd_kafka_headers_s rd_kafka_headers_t;</span>
<span class="s1">typedef struct rd_kafka_group_result_s rd_kafka_group_result_t;</span>
<span class="s1">typedef struct rd_kafka_acl_result_s rd_kafka_acl_result_t;</span>
<span class="s1">typedef struct rd_kafka_Uuid_s rd_kafka_Uuid_t;</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BEGIN = (- 200),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BAD_MSG = (- 199),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BAD_COMPRESSION = (- 198),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__DESTROY = (- 197),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FAIL = (- 196),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TRANSPORT = (- 195),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__CRIT_SYS_RESOURCE = (- 194),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__RESOLVE = (- 193),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__MSG_TIMED_OUT = (- 192),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PARTITION_EOF = (- 191),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION = (- 190),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FS = (- 189),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC = (- 188),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ALL_BROKERS_DOWN = (- 187),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INVALID_ARG = (- 186),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TIMED_OUT = (- 185),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__QUEUE_FULL = (- 184),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ISR_INSUFF = (- 183),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NODE_UPDATE = (- 182),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__SSL = (- 181),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__WAIT_COORD = (- 180),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_GROUP = (- 179),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__IN_PROGRESS = (- 178),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PREV_IN_PROGRESS = (- 177),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__EXISTING_SUBSCRIPTION = (- 176),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS = (- 175),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS = (- 174),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__CONFLICT = (- 173),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__STATE = (- 172),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_PROTOCOL = (- 171),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED = (- 170),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__AUTHENTICATION = (- 169),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NO_OFFSET = (- 168),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__OUTDATED = (- 167),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TIMED_OUT_QUEUE = (- 166),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNSUPPORTED_FEATURE = (- 165),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__WAIT_CACHE = (- 164),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INTR = (- 163),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__KEY_SERIALIZATION = (- 162),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__VALUE_SERIALIZATION = (- 161),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__KEY_DESERIALIZATION = (- 160),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__VALUE_DESERIALIZATION = (- 159),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PARTIAL = (- 158),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__READ_ONLY = (- 157),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOENT = (- 156),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNDERFLOW = (- 155),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INVALID_TYPE = (- 154),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__RETRY = (- 153),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PURGE_QUEUE = (- 152),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PURGE_INFLIGHT = (- 151),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FATAL = (- 150),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INCONSISTENT = (- 149),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__GAPLESS_GUARANTEE = (- 148),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__MAX_POLL_EXCEEDED = (- 147),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_BROKER = (- 146),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOT_CONFIGURED = (- 145),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FENCED = (- 144),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__APPLICATION = (- 143),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ASSIGNMENT_LOST = (- 142),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOOP = (- 141),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__AUTO_OFFSET_RESET = (- 140),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__LOG_TRUNCATION = (- 139),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__END = (- 100),</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN = (- 1),</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NO_ERROR = 0,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_OUT_OF_RANGE = 1,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_MSG = 2,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART = 3,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_MSG_SIZE = 4,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE = 5,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_LEADER_FOR_PARTITION = 6,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REQUEST_TIMED_OUT = 7,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_BROKER_NOT_AVAILABLE = 8,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REPLICA_NOT_AVAILABLE = 9,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE = 10,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_STALE_CTRL_EPOCH = 11,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_METADATA_TOO_LARGE = 12,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NETWORK_EXCEPTION = 13,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_COORDINATOR_LOAD_IN_PROGRESS = 14,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_COORDINATOR_NOT_AVAILABLE = 15,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_COORDINATOR = 16,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_EXCEPTION = 17,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_RECORD_LIST_TOO_LARGE = 18,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS = 19,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS_AFTER_APPEND = 20,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REQUIRED_ACKS = 21,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ILLEGAL_GENERATION = 22,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INCONSISTENT_GROUP_PROTOCOL = 23,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_GROUP_ID = 24,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_MEMBER_ID = 25,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_SESSION_TIMEOUT = 26,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REBALANCE_IN_PROGRESS = 27,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_COMMIT_OFFSET_SIZE = 28,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_AUTHORIZATION_FAILED = 29,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_AUTHORIZATION_FAILED = 30,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_CLUSTER_AUTHORIZATION_FAILED = 31,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TIMESTAMP = 32,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_SASL_MECHANISM = 33,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ILLEGAL_SASL_STATE = 34,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_VERSION = 35,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_ALREADY_EXISTS = 36,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PARTITIONS = 37,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REPLICATION_FACTOR = 38,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REPLICA_ASSIGNMENT = 39,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_CONFIG = 40,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_CONTROLLER = 41,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REQUEST = 42,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_FOR_MESSAGE_FORMAT = 43,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_POLICY_VIOLATION = 44,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OUT_OF_ORDER_SEQUENCE_NUMBER = 45,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DUPLICATE_SEQUENCE_NUMBER = 46,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_EPOCH = 47,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TXN_STATE = 48,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_ID_MAPPING = 49,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TRANSACTION_TIMEOUT = 50,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_CONCURRENT_TRANSACTIONS = 51,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TRANSACTION_COORDINATOR_FENCED = 52,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TRANSACTIONAL_ID_AUTHORIZATION_FAILED = 53,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_SECURITY_DISABLED = 54,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OPERATION_NOT_ATTEMPTED = 55,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_KAFKA_STORAGE_ERROR = 56,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LOG_DIR_NOT_FOUND = 57,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_SASL_AUTHENTICATION_FAILED = 58,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_PRODUCER_ID = 59,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REASSIGNMENT_IN_PROGRESS = 60,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTH_DISABLED = 61,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_NOT_FOUND = 62,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_OWNER_MISMATCH = 63,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_REQUEST_NOT_ALLOWED = 64,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTHORIZATION_FAILED = 65,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_EXPIRED = 66,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRINCIPAL_TYPE = 67,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NON_EMPTY_GROUP = 68,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_ID_NOT_FOUND = 69,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FETCH_SESSION_ID_NOT_FOUND = 70,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_FETCH_SESSION_EPOCH = 71,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LISTENER_NOT_FOUND = 72,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_DELETION_DISABLED = 73,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FENCED_LEADER_EPOCH = 74,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_LEADER_EPOCH = 75,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_STALE_BROKER_EPOCH = 77,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_NOT_AVAILABLE = 78,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_MEMBER_ID_REQUIRED = 79,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_PREFERRED_LEADER_NOT_AVAILABLE = 80,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_MAX_SIZE_REACHED = 81,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FENCED_INSTANCE_ID = 82,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ELIGIBLE_LEADERS_NOT_AVAILABLE = 83,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ELECTION_NOT_NEEDED = 84,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NO_REASSIGNMENT_IN_PROGRESS = 85,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_SUBSCRIBED_TO_TOPIC = 86,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_RECORD = 87,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSTABLE_OFFSET_COMMIT = 88,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_THROTTLING_QUOTA_EXCEEDED = 89,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_PRODUCER_FENCED = 90,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_RESOURCE_NOT_FOUND = 91,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DUPLICATE_RESOURCE = 92,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNACCEPTABLE_CREDENTIAL = 93,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INCONSISTENT_VOTER_SET = 94,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_UPDATE_VERSION = 95,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FEATURE_UPDATE_FAILED = 96,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_PRINCIPAL_DESERIALIZATION_FAILURE = 97,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_END_ALL,</span>
<span class="s1">} rd_kafka_resp_err_t;</span>
<span class="s1">struct rd_kafka_err_desc {</span>
<span class="s1">  rd_kafka_resp_err_t code;</span>
<span class="s1">  char *name;</span>
<span class="s1">  char *desc;</span>
<span class="s1">};</span>
<span class="s1">void rd_kafka_get_err_descs(const struct rd_kafka_err_desc **errdescs, size_t *cntp);</span>
<span class="s1">const char *rd_kafka_err2str(rd_kafka_resp_err_t err);</span>
<span class="s1">const char *rd_kafka_err2name(rd_kafka_resp_err_t err);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_last_error(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_errno2err(int errnox);</span>
<span class="s1">int rd_kafka_errno(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_fatal_error(rd_kafka_t *rk, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_test_fatal_error(rd_kafka_t *rk, rd_kafka_resp_err_t err, const char *reason);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_error_code(const rd_kafka_error_t *error);</span>
<span class="s1">const char *rd_kafka_error_name(const rd_kafka_error_t *error);</span>
<span class="s1">const char *rd_kafka_error_string(const rd_kafka_error_t *error);</span>
<span class="s1">int rd_kafka_error_is_fatal(const rd_kafka_error_t *error);</span>
<span class="s1">int rd_kafka_error_is_retriable(const rd_kafka_error_t *error);</span>
<span class="s1">int rd_kafka_error_txn_requires_abort(const rd_kafka_error_t *error);</span>
<span class="s1">void rd_kafka_error_destroy(rd_kafka_error_t *error);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_error_new(rd_kafka_resp_err_t code, const char *fmt, ...);</span>
<span class="s1">typedef struct rd_kafka_topic_partition_s {</span>
<span class="s1">  char *topic;</span>
<span class="s1">  int32_t partition;</span>
<span class="s1">  int64_t offset;</span>
<span class="s1">  void *metadata;</span>
<span class="s1">  size_t metadata_size;</span>
<span class="s1">  void *opaque;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  void *_private;</span>
<span class="s1">} rd_kafka_topic_partition_t;</span>
<span class="s1">void rd_kafka_topic_partition_destroy(rd_kafka_topic_partition_t *rktpar);</span>
<span class="s1">void rd_kafka_topic_partition_set_leader_epoch(rd_kafka_topic_partition_t *rktpar, int32_t leader_epoch);</span>
<span class="s1">int32_t rd_kafka_topic_partition_get_leader_epoch(const rd_kafka_topic_partition_t *rktpar);</span>
<span class="s1">typedef struct rd_kafka_topic_partition_list_s {</span>
<span class="s1">  int cnt;</span>
<span class="s1">  int size;</span>
<span class="s1">  rd_kafka_topic_partition_t *elems;</span>
<span class="s1">} rd_kafka_topic_partition_list_t;</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_new(int size);</span>
<span class="s1">void rd_kafka_topic_partition_list_destroy(rd_kafka_topic_partition_list_t *rkparlist);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_add(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">void rd_kafka_topic_partition_list_add_range(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t start, int32_t stop);</span>
<span class="s1">int rd_kafka_topic_partition_list_del(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">int rd_kafka_topic_partition_list_del_by_idx(rd_kafka_topic_partition_list_t *rktparlist, int idx);</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_copy(const rd_kafka_topic_partition_list_t *src);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_topic_partition_list_set_offset(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition, int64_t offset);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_find(const rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">void rd_kafka_topic_partition_list_sort(rd_kafka_topic_partition_list_t *rktparlist, int (*cmp)(const void *a, const void *b, void *cmp_opaque), void *cmp_opaque);</span>
<span class="s1">typedef enum rd_kafka_vtype_t {</span>
<span class="s1">  RD_KAFKA_VTYPE_END,</span>
<span class="s1">  RD_KAFKA_VTYPE_TOPIC,</span>
<span class="s1">  RD_KAFKA_VTYPE_RKT,</span>
<span class="s1">  RD_KAFKA_VTYPE_PARTITION,</span>
<span class="s1">  RD_KAFKA_VTYPE_VALUE,</span>
<span class="s1">  RD_KAFKA_VTYPE_KEY,</span>
<span class="s1">  RD_KAFKA_VTYPE_OPAQUE,</span>
<span class="s1">  RD_KAFKA_VTYPE_MSGFLAGS,</span>
<span class="s1">  RD_KAFKA_VTYPE_TIMESTAMP,</span>
<span class="s1">  RD_KAFKA_VTYPE_HEADER,</span>
<span class="s1">  RD_KAFKA_VTYPE_HEADERS,</span>
<span class="s1">} rd_kafka_vtype_t;</span>
<span class="s1">typedef struct rd_kafka_vu_s {</span>
<span class="s1">  rd_kafka_vtype_t vtype;</span>
<span class="s1">  union {</span>
<span class="s1">    char *cstr;</span>
<span class="s1">    rd_kafka_topic_t *rkt;</span>
<span class="s1">    int i;</span>
<span class="s1">    int32_t i32;</span>
<span class="s1">    int64_t i64;</span>
<span class="s1">    struct {</span>
<span class="s1">      void *ptr;</span>
<span class="s1">      size_t size;</span>
<span class="s1">    } mem;</span>
<span class="s1">    struct {</span>
<span class="s1">      char *name;</span>
<span class="s1">      void *val;</span>
<span class="s1">      ssize_t size;</span>
<span class="s1">    } header;</span>
<span class="s1">    rd_kafka_headers_t *headers;</span>
<span class="s1">    void *ptr;</span>
<span class="s1">    char _pad[64];</span>
<span class="s1">  } u;</span>
<span class="s1">} rd_kafka_vu_t;</span>
<span class="s1">rd_kafka_headers_t *rd_kafka_headers_new(size_t initial_count);</span>
<span class="s1">void rd_kafka_headers_destroy(rd_kafka_headers_t *hdrs);</span>
<span class="s1">rd_kafka_headers_t *rd_kafka_headers_copy(const rd_kafka_headers_t *src);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_add(rd_kafka_headers_t *hdrs, const char *name, ssize_t name_size, const void *value, ssize_t value_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_remove(rd_kafka_headers_t *hdrs, const char *name);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get_last(const rd_kafka_headers_t *hdrs, const char *name, const void **valuep, size_t *sizep);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get(const rd_kafka_headers_t *hdrs, size_t idx, const char *name, const void **valuep, size_t *sizep);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get_all(const rd_kafka_headers_t *hdrs, size_t idx, const char **namep, const void **valuep, size_t *sizep);</span>
<span class="s1">typedef struct rd_kafka_message_s {</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  rd_kafka_topic_t *rkt;</span>
<span class="s1">  int32_t partition;</span>
<span class="s1">  void *payload;</span>
<span class="s1">  size_t len;</span>
<span class="s1">  void *key;</span>
<span class="s1">  size_t key_len;</span>
<span class="s1">  int64_t offset;</span>
<span class="s1">  void *_private;</span>
<span class="s1">} rd_kafka_message_t;</span>
<span class="s1">void rd_kafka_message_destroy(rd_kafka_message_t *rkmessage);</span>
<span class="s1">const char *rd_kafka_message_errstr(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">int64_t rd_kafka_message_timestamp(const rd_kafka_message_t *rkmessage, rd_kafka_timestamp_type_t *tstype);</span>
<span class="s1">int64_t rd_kafka_message_latency(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">int32_t rd_kafka_message_broker_id(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_message_headers(const rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_message_detach_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);</span>
<span class="s1">void rd_kafka_message_set_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t *hdrs);</span>
<span class="s1">size_t rd_kafka_header_cnt(const rd_kafka_headers_t *hdrs);</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_NOT_PERSISTED = 0,</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_POSSIBLY_PERSISTED = 1,</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_PERSISTED = 2,</span>
<span class="s1">} rd_kafka_msg_status_t;</span>
<span class="s1">rd_kafka_msg_status_t rd_kafka_message_status(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">int32_t rd_kafka_message_leader_epoch(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">const char *rd_kafka_Uuid_base64str(const rd_kafka_Uuid_t *uuid);</span>
<span class="s1">int64_t rd_kafka_Uuid_least_significant_bits(const rd_kafka_Uuid_t *uuid);</span>
<span class="s1">int64_t rd_kafka_Uuid_most_significant_bits(const rd_kafka_Uuid_t *uuid);</span>
<span class="s1">rd_kafka_Uuid_t *rd_kafka_Uuid_new(int64_t most_significant_bits, int64_t least_significant_bits);</span>
<span class="s1">rd_kafka_Uuid_t *rd_kafka_Uuid_copy(const rd_kafka_Uuid_t *uuid);</span>
<span class="s1">void rd_kafka_Uuid_destroy(rd_kafka_Uuid_t *uuid);</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_CONF_UNKNOWN = (- 2),</span>
<span class="s1">  RD_KAFKA_CONF_INVALID = (- 1),</span>
<span class="s1">  RD_KAFKA_CONF_OK = 0,</span>
<span class="s1">} rd_kafka_conf_res_t;</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_new(void);</span>
<span class="s1">void rd_kafka_conf_destroy(rd_kafka_conf_t *conf);</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_dup(const rd_kafka_conf_t *conf);</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_dup_filter(const rd_kafka_conf_t *conf, size_t filter_cnt, const char **filter);</span>
<span class="s1">const rd_kafka_conf_t *rd_kafka_conf(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_set(rd_kafka_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_conf_set_events(rd_kafka_conf_t *conf, int events);</span>
<span class="s1">void rd_kafka_conf_set_background_event_cb(rd_kafka_conf_t *conf, void (*event_cb)(rd_kafka_t *rk, rd_kafka_event_t *rkev, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_dr_cb(rd_kafka_conf_t *conf, void (*dr_cb)(rd_kafka_t *rk, void *payload, size_t len, rd_kafka_resp_err_t err, void *opaque, void *msg_opaque));</span>
<span class="s1">void rd_kafka_conf_set_dr_msg_cb(rd_kafka_conf_t *conf, void (*dr_msg_cb)(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_consume_cb(rd_kafka_conf_t *conf, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_rebalance_cb(rd_kafka_conf_t *conf, void (*rebalance_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *partitions, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_offset_commit_cb(rd_kafka_conf_t *conf, void (*offset_commit_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_error_cb(rd_kafka_conf_t *conf, void (*error_cb)(rd_kafka_t *rk, int err, const char *reason, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_throttle_cb(rd_kafka_conf_t *conf, void (*throttle_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int throttle_time_ms, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_log_cb(rd_kafka_conf_t *conf, void (*log_cb)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));</span>
<span class="s1">void rd_kafka_conf_set_stats_cb(rd_kafka_conf_t *conf, int (*stats_cb)(rd_kafka_t *rk, char *json, size_t json_len, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_oauthbearer_token_refresh_cb(rd_kafka_conf_t *conf, void (*oauthbearer_token_refresh_cb)(rd_kafka_t *rk, const char *oauthbearer_config, void *opaque));</span>
<span class="s1">void rd_kafka_conf_enable_sasl_queue(rd_kafka_conf_t *conf, int enable);</span>
<span class="s1">void rd_kafka_conf_set_socket_cb(rd_kafka_conf_t *conf, int (*socket_cb)(int domain, int type, int protocol, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_connect_cb(rd_kafka_conf_t *conf, int (*connect_cb)(int sockfd, const struct sockaddr *addr, int addrlen, const char *id, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_closesocket_cb(rd_kafka_conf_t *conf, int (*closesocket_cb)(int sockfd, void *opaque));</span>
<span class="s1">struct addrinfo;</span>
<span class="s1">void rd_kafka_conf_set_resolve_cb(rd_kafka_conf_t *conf, int (*resolve_cb)(const char *node, const char *service, const struct addrinfo *hints, struct addrinfo **res, void *opaque));</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert_verify_cb(rd_kafka_conf_t *conf, int (*ssl_cert_verify_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int *x509_error, int depth, const char *buf, size_t size, char *errstr, size_t errstr_size, void *opaque));</span>
<span class="s1">typedef enum rd_kafka_cert_type_t {</span>
<span class="s1">  RD_KAFKA_CERT_PUBLIC_KEY,</span>
<span class="s1">  RD_KAFKA_CERT_PRIVATE_KEY,</span>
<span class="s1">  RD_KAFKA_CERT_CA,</span>
<span class="s1">  RD_KAFKA_CERT__CNT,</span>
<span class="s1">} rd_kafka_cert_type_t;</span>
<span class="s1">typedef enum rd_kafka_cert_enc_t {</span>
<span class="s1">  RD_KAFKA_CERT_ENC_PKCS12,</span>
<span class="s1">  RD_KAFKA_CERT_ENC_DER,</span>
<span class="s1">  RD_KAFKA_CERT_ENC_PEM,</span>
<span class="s1">  RD_KAFKA_CERT_ENC__CNT,</span>
<span class="s1">} rd_kafka_cert_enc_t;</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert(rd_kafka_conf_t *conf, rd_kafka_cert_type_t cert_type, rd_kafka_cert_enc_t cert_enc, const void *buffer, size_t size, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_conf_set_engine_callback_data(rd_kafka_conf_t *conf, void *callback_data);</span>
<span class="s1">void rd_kafka_conf_set_opaque(rd_kafka_conf_t *conf, void *opaque);</span>
<span class="s1">void *rd_kafka_opaque(const rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_conf_set_default_topic_conf(rd_kafka_conf_t *conf, rd_kafka_topic_conf_t *tconf);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_conf_get_default_topic_conf(rd_kafka_conf_t *conf);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_get(const rd_kafka_conf_t *conf, const char *name, char *dest, size_t *dest_size);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_topic_conf_get(const rd_kafka_topic_conf_t *conf, const char *name, char *dest, size_t *dest_size);</span>
<span class="s1">const char **rd_kafka_conf_dump(rd_kafka_conf_t *conf, size_t *cntp);</span>
<span class="s1">const char **rd_kafka_topic_conf_dump(rd_kafka_topic_conf_t *conf, size_t *cntp);</span>
<span class="s1">void rd_kafka_conf_dump_free(const char **arr, size_t cnt);</span>
<span class="s1">void rd_kafka_conf_properties_show(FILE *fp);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_topic_conf_new(void);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_topic_conf_dup(const rd_kafka_topic_conf_t *conf);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_default_topic_conf_dup(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_topic_conf_destroy(rd_kafka_topic_conf_t *topic_conf);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_topic_conf_set(rd_kafka_topic_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_topic_conf_set_opaque(rd_kafka_topic_conf_t *conf, void *rkt_opaque);</span>
<span class="s1">void rd_kafka_topic_conf_set_partitioner_cb(rd_kafka_topic_conf_t *topic_conf, int32_t (*partitioner)(const rd_kafka_topic_t *rkt, const void *keydata, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque));</span>
<span class="s1">void rd_kafka_topic_conf_set_msg_order_cmp(rd_kafka_topic_conf_t *topic_conf, int (*msg_order_cmp)(const rd_kafka_message_t *a, const rd_kafka_message_t *b));</span>
<span class="s1">int rd_kafka_topic_partition_available(const rd_kafka_topic_t *rkt, int32_t partition);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_consistent(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_consistent_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_murmur2(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_murmur2_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_fnv1a(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_fnv1a_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">rd_kafka_t *rd_kafka_new(rd_kafka_type_t type, rd_kafka_conf_t *conf, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_destroy(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_destroy_flags(rd_kafka_t *rk, int flags);</span>
<span class="s1">const char *rd_kafka_name(const rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_type_t rd_kafka_type(const rd_kafka_t *rk);</span>
<span class="s1">char *rd_kafka_memberid(const rd_kafka_t *rk);</span>
<span class="s1">char *rd_kafka_clusterid(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">int32_t rd_kafka_controllerid(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_topic_t *rd_kafka_topic_new(rd_kafka_t *rk, const char *topic, rd_kafka_topic_conf_t *conf);</span>
<span class="s1">void rd_kafka_topic_destroy(rd_kafka_topic_t *rkt);</span>
<span class="s1">const char *rd_kafka_topic_name(const rd_kafka_topic_t *rkt);</span>
<span class="s1">void *rd_kafka_topic_opaque(const rd_kafka_topic_t *rkt);</span>
<span class="s1">int rd_kafka_poll(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">void rd_kafka_yield(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_pause_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_resume_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_query_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_get_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offsets_for_times(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets, int timeout_ms);</span>
<span class="s1">void *rd_kafka_mem_calloc(rd_kafka_t *rk, size_t num, size_t size);</span>
<span class="s1">void *rd_kafka_mem_malloc(rd_kafka_t *rk, size_t size);</span>
<span class="s1">void rd_kafka_mem_free(rd_kafka_t *rk, void *ptr);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_new(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_queue_destroy(rd_kafka_queue_t *rkqu);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_main(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_sasl(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_sasl_background_callbacks_enable(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_sasl_set_credentials(rd_kafka_t *rk, const char *username, const char *password);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_consumer(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_partition(rd_kafka_t *rk, const char *topic, int32_t partition);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_background(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_queue_forward(rd_kafka_queue_t *src, rd_kafka_queue_t *dst);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_set_log_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu);</span>
<span class="s1">size_t rd_kafka_queue_length(rd_kafka_queue_t *rkqu);</span>
<span class="s1">void rd_kafka_queue_io_event_enable(rd_kafka_queue_t *rkqu, int fd, const void *payload, size_t size);</span>
<span class="s1">void rd_kafka_queue_cb_event_enable(rd_kafka_queue_t *rkqu, void (*event_cb)(rd_kafka_t *rk, void *qev_opaque), void *qev_opaque);</span>
<span class="s1">void rd_kafka_queue_yield(rd_kafka_queue_t *rkqu);</span>
<span class="s1">int rd_kafka_consume_start(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);</span>
<span class="s1">int rd_kafka_consume_start_queue(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, rd_kafka_queue_t *rkqu);</span>
<span class="s1">int rd_kafka_consume_stop(rd_kafka_topic_t *rkt, int32_t partition);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_seek(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, int timeout_ms);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_seek_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consume(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms);</span>
<span class="s1">ssize_t rd_kafka_consume_batch(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);</span>
<span class="s1">int rd_kafka_consume_callback(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consume_queue(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">ssize_t rd_kafka_consume_batch_queue(rd_kafka_queue_t *rkqu, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);</span>
<span class="s1">int rd_kafka_consume_callback_queue(rd_kafka_queue_t *rkqu, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offset_store(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offsets_store(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_offset_store_message(rd_kafka_message_t *rkmessage);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_subscribe(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *topics);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_unsubscribe(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_subscription(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **topics);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consumer_poll(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_consumer_close(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_consumer_close_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu);</span>
<span class="s1">int rd_kafka_consumer_closed(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_incremental_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_incremental_unassign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">const char *rd_kafka_rebalance_protocol(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_assignment(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **partitions);</span>
<span class="s1">int rd_kafka_assignment_lost(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, int async);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit_message(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, int async);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit_queue(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_queue_t *rkqu, void (*cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *commit_opaque), void *commit_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_committed(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_position(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata_new(const char *group_id);</span>
<span class="s1">rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata_new_with_genid(const char *group_id, int32_t generation_id, const char *member_id, const char *group_instance_id);</span>
<span class="s1">void rd_kafka_consumer_group_metadata_destroy(rd_kafka_consumer_group_metadata_t *);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_consumer_group_metadata_write(const rd_kafka_consumer_group_metadata_t *cgmd, void **bufferp, size_t *sizep);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_consumer_group_metadata_read(rd_kafka_consumer_group_metadata_t **cgmdp, const void *buffer, size_t size);</span>
<span class="s1">int rd_kafka_produce(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, void *payload, size_t len, const void *key, size_t keylen, void *msg_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_producev(rd_kafka_t *rk, ...);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_produceva(rd_kafka_t *rk, const rd_kafka_vu_t *vus, size_t cnt);</span>
<span class="s1">int rd_kafka_produce_batch(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, rd_kafka_message_t *rkmessages, int message_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_flush(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_purge(rd_kafka_t *rk, int purge_flags);</span>
<span class="s1">typedef struct rd_kafka_metadata_broker {</span>
<span class="s1">  int32_t id;</span>
<span class="s1">  char *host;</span>
<span class="s1">  int port;</span>
<span class="s1">} rd_kafka_metadata_broker_t;</span>
<span class="s1">typedef struct rd_kafka_metadata_partition {</span>
<span class="s1">  int32_t id;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  int32_t leader;</span>
<span class="s1">  int replica_cnt;</span>
<span class="s1">  int32_t *replicas;</span>
<span class="s1">  int isr_cnt;</span>
<span class="s1">  int32_t *isrs;</span>
<span class="s1">} rd_kafka_metadata_partition_t;</span>
<span class="s1">typedef struct rd_kafka_metadata_topic {</span>
<span class="s1">  char *topic;</span>
<span class="s1">  int partition_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_partition *partitions;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">} rd_kafka_metadata_topic_t;</span>
<span class="s1">typedef struct rd_kafka_metadata {</span>
<span class="s1">  int broker_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_broker *brokers;</span>
<span class="s1">  int topic_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_topic *topics;</span>
<span class="s1">  int32_t orig_broker_id;</span>
<span class="s1">  char *orig_broker_name;</span>
<span class="s1">} rd_kafka_metadata_t;</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_metadata(rd_kafka_t *rk, int all_topics, rd_kafka_topic_t *only_rkt, const struct rd_kafka_metadata **metadatap, int timeout_ms);</span>
<span class="s1">void rd_kafka_metadata_destroy(const struct rd_kafka_metadata *metadata);</span>
<span class="s1">typedef struct rd_kafka_Node_s rd_kafka_Node_t;</span>
<span class="s1">int rd_kafka_Node_id(const rd_kafka_Node_t *node);</span>
<span class="s1">const char *rd_kafka_Node_host(const rd_kafka_Node_t *node);</span>
<span class="s1">uint16_t rd_kafka_Node_port(const rd_kafka_Node_t *node);</span>
<span class="s1">const char *rd_kafka_Node_rack(const rd_kafka_Node_t *node);</span>
<span class="s1">struct rd_kafka_group_member_info {</span>
<span class="s1">  char *member_id;</span>
<span class="s1">  char *client_id;</span>
<span class="s1">  char *client_host;</span>
<span class="s1">  void *member_metadata;</span>
<span class="s1">  int member_metadata_size;</span>
<span class="s1">  void *member_assignment;</span>
<span class="s1">  int member_assignment_size;</span>
<span class="s1">};</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_CONSUMER_GROUP_STATE_UNKNOWN = 0,</span>
<span class="s1">  RD_KAFKA_CONSUMER_GROUP_STATE_PREPARING_REBALANCE = 1,</span>
<span class="s1">  RD_KAFKA_CONSUMER_GROUP_STATE_COMPLETING_REBALANCE = 2,</span>
<span class="s1">  RD_KAFKA_CONSUMER_GROUP_STATE_STABLE = 3,</span>
<span class="s1">  RD_KAFKA_CONSUMER_GROUP_STATE_DEAD = 4,</span>
<span class="s1">  RD_KAFKA_CONSUMER_GROUP_STATE_EMPTY = 5,</span>
<span class="s1">  RD_KAFKA_CONSUMER_GROUP_STATE__CNT,</span>
<span class="s1">} rd_kafka_consumer_group_state_t;</span>
<span class="s1">struct rd_kafka_group_info {</span>
<span class="s1">  struct rd_kafka_metadata_broker broker;</span>
<span class="s1">  char *group;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  char *state;</span>
<span class="s1">  char *protocol_type;</span>
<span class="s1">  char *protocol;</span>
<span class="s1">  struct rd_kafka_group_member_info *members;</span>
<span class="s1">  int member_cnt;</span>
<span class="s1">};</span>
<span class="s1">struct rd_kafka_group_list {</span>
<span class="s1">  struct rd_kafka_group_info *groups;</span>
<span class="s1">  int group_cnt;</span>
<span class="s1">};</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_list_groups(rd_kafka_t *rk, const char *group, const struct rd_kafka_group_list **grplistp, int timeout_ms);</span>
<span class="s1">const char *rd_kafka_consumer_group_state_name(rd_kafka_consumer_group_state_t state);</span>
<span class="s1">rd_kafka_consumer_group_state_t rd_kafka_consumer_group_state_code(const char *name);</span>
<span class="s1">void rd_kafka_group_list_destroy(const struct rd_kafka_group_list *grplist);</span>
<span class="s1">int rd_kafka_brokers_add(rd_kafka_t *rk, const char *brokerlist);</span>
<span class="s1">void rd_kafka_set_logger(rd_kafka_t *rk, void (*func)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));</span>
<span class="s1">void rd_kafka_set_log_level(rd_kafka_t *rk, int level);</span>
<span class="s1">void rd_kafka_log_print(const rd_kafka_t *rk, int level, const char *fac, const char *buf);</span>
<span class="s1">void rd_kafka_log_syslog(const rd_kafka_t *rk, int level, const char *fac, const char *buf);</span>
<span class="s1">int rd_kafka_outq_len(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_dump(FILE *fp, rd_kafka_t *rk);</span>
<span class="s1">int rd_kafka_thread_cnt(void);</span>
<span class="s1">typedef enum rd_kafka_thread_type_t {</span>
<span class="s1">  RD_KAFKA_THREAD_MAIN,</span>
<span class="s1">  RD_KAFKA_THREAD_BACKGROUND,</span>
<span class="s1">  RD_KAFKA_THREAD_BROKER,</span>
<span class="s1">} rd_kafka_thread_type_t;</span>
<span class="s1">int rd_kafka_wait_destroyed(int timeout_ms);</span>
<span class="s1">int rd_kafka_unittest(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_poll_set_consumer(rd_kafka_t *rk);</span>
<span class="s1">typedef int rd_kafka_event_type_t;</span>
<span class="s1">rd_kafka_event_type_t rd_kafka_event_type(const rd_kafka_event_t *rkev);</span>
<span class="s1">const char *rd_kafka_event_name(const rd_kafka_event_t *rkev);</span>
<span class="s1">void rd_kafka_event_destroy(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_message_t *rd_kafka_event_message_next(rd_kafka_event_t *rkev);</span>
<span class="s1">size_t rd_kafka_event_message_array(rd_kafka_event_t *rkev, const rd_kafka_message_t **rkmessages, size_t size);</span>
<span class="s1">size_t rd_kafka_event_message_count(rd_kafka_event_t *rkev);</span>
<span class="s1">const char *rd_kafka_event_config_string(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_event_error(rd_kafka_event_t *rkev);</span>
<span class="s1">const char *rd_kafka_event_error_string(rd_kafka_event_t *rkev);</span>
<span class="s1">int rd_kafka_event_error_is_fatal(rd_kafka_event_t *rkev);</span>
<span class="s1">void *rd_kafka_event_opaque(rd_kafka_event_t *rkev);</span>
<span class="s1">int rd_kafka_event_log(rd_kafka_event_t *rkev, const char **fac, const char **str, int *level);</span>
<span class="s1">int rd_kafka_event_debug_contexts(rd_kafka_event_t *rkev, char *dst, size_t dstsize);</span>
<span class="s1">const char *rd_kafka_event_stats(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_event_topic_partition_list(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_event_topic_partition(rd_kafka_event_t *rkev);</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_CreateTopics_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DeleteTopics_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_CreateAcls_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DescribeAcls_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DeleteAcls_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_CreatePartitions_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_AlterConfigs_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_IncrementalAlterConfigs_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DescribeConfigs_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DeleteRecords_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_ListConsumerGroups_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DescribeConsumerGroups_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DeleteGroups_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DeleteConsumerGroupOffsets_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_AlterConsumerGroupOffsets_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_ListConsumerGroupOffsets_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DescribeTopics_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DescribeCluster_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DescribeUserScramCredentials_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_AlterUserScramCredentials_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_ListOffsets_result_t;</span>
<span class="s1">const rd_kafka_CreateTopics_result_t *rd_kafka_event_CreateTopics_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DeleteTopics_result_t *rd_kafka_event_DeleteTopics_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_CreatePartitions_result_t *rd_kafka_event_CreatePartitions_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_AlterConfigs_result_t *rd_kafka_event_AlterConfigs_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_IncrementalAlterConfigs_result_t *rd_kafka_event_IncrementalAlterConfigs_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DescribeConfigs_result_t *rd_kafka_event_DescribeConfigs_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DeleteRecords_result_t *rd_kafka_event_DeleteRecords_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_ListConsumerGroups_result_t *rd_kafka_event_ListConsumerGroups_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DescribeConsumerGroups_result_t *rd_kafka_event_DescribeConsumerGroups_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DescribeTopics_result_t *rd_kafka_event_DescribeTopics_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DescribeCluster_result_t *rd_kafka_event_DescribeCluster_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DeleteGroups_result_t *rd_kafka_event_DeleteGroups_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DeleteConsumerGroupOffsets_result_t *rd_kafka_event_DeleteConsumerGroupOffsets_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_CreateAcls_result_t *rd_kafka_event_CreateAcls_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DescribeAcls_result_t *rd_kafka_event_DescribeAcls_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DeleteAcls_result_t *rd_kafka_event_DeleteAcls_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_ListConsumerGroupOffsets_result_t *rd_kafka_event_ListConsumerGroupOffsets_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_AlterConsumerGroupOffsets_result_t *rd_kafka_event_AlterConsumerGroupOffsets_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_ListOffsets_result_t *rd_kafka_event_ListOffsets_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DescribeUserScramCredentials_result_t *rd_kafka_event_DescribeUserScramCredentials_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_AlterUserScramCredentials_result_t *rd_kafka_event_AlterUserScramCredentials_result(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_event_t *rd_kafka_queue_poll(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">int rd_kafka_queue_poll_callback(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_plugin_f_conf_init_t)(rd_kafka_conf_t *conf, void **plug_opaquep, char *errstr, size_t errstr_size);</span>
<span class="s1">typedef rd_kafka_conf_res_t (rd_kafka_interceptor_f_on_conf_set_t)(rd_kafka_conf_t *conf, const char *name, const char *val, char *errstr, size_t errstr_size, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_dup_t)(rd_kafka_conf_t *new_conf, const rd_kafka_conf_t *old_conf, size_t filter_cnt, const char **filter, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_destroy_t)(void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_new_t)(rd_kafka_t *rk, const rd_kafka_conf_t *conf, void *ic_opaque, char *errstr, size_t errstr_size);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_destroy_t)(rd_kafka_t *rk, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_send_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_acknowledgement_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_consume_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_commit_t)(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_resp_err_t err, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_request_sent_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_response_received_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, int64_t rtt, rd_kafka_resp_err_t err, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_start_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_exit_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_broker_state_change_t)(rd_kafka_t *rk, int32_t broker_id, const char *secproto, const char *name, int port, const char *state, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_set(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_set_t *on_conf_set, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_dup(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_dup_t *on_conf_dup, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_destroy(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_destroy_t *on_conf_destroy, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_new(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_new_t *on_new, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_destroy(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_destroy_t *on_destroy, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_send(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_send_t *on_send, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_acknowledgement(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_acknowledgement_t *on_acknowledgement, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_consume(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_consume_t *on_consume, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_commit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_commit_t *on_commit, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_request_sent(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_request_sent_t *on_request_sent, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_response_received(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_response_received_t *on_response_received, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_start(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_start_t *on_thread_start, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_exit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_exit_t *on_thread_exit, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_broker_state_change(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_broker_state_change_t *on_broker_state_change, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_topic_result_error(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">const char *rd_kafka_topic_result_error_string(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">const char *rd_kafka_topic_result_name(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">const rd_kafka_error_t *rd_kafka_group_result_error(const rd_kafka_group_result_t *groupres);</span>
<span class="s1">const char *rd_kafka_group_result_name(const rd_kafka_group_result_t *groupres);</span>
<span class="s1">const rd_kafka_topic_partition_list_t *rd_kafka_group_result_partitions(const rd_kafka_group_result_t *groupres);</span>
<span class="s1">typedef enum rd_kafka_admin_op_t {</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_ANY = 0,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_CREATETOPICS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DELETETOPICS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_CREATEPARTITIONS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_ALTERCONFIGS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DESCRIBECONFIGS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DELETERECORDS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DELETEGROUPS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DELETECONSUMERGROUPOFFSETS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_CREATEACLS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DESCRIBEACLS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DELETEACLS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_LISTCONSUMERGROUPS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DESCRIBECONSUMERGROUPS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_LISTCONSUMERGROUPOFFSETS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_ALTERCONSUMERGROUPOFFSETS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_INCREMENTALALTERCONFIGS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DESCRIBEUSERSCRAMCREDENTIALS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_ALTERUSERSCRAMCREDENTIALS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DESCRIBETOPICS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DESCRIBECLUSTER,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_LISTOFFSETS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP__CNT,</span>
<span class="s1">} rd_kafka_admin_op_t;</span>
<span class="s1">typedef struct rd_kafka_AdminOptions_s rd_kafka_AdminOptions_t;</span>
<span class="s1">typedef enum rd_kafka_IsolationLevel_t {</span>
<span class="s1">  RD_KAFKA_ISOLATION_LEVEL_READ_UNCOMMITTED = 0,</span>
<span class="s1">  RD_KAFKA_ISOLATION_LEVEL_READ_COMMITTED = 1,</span>
<span class="s1">} rd_kafka_IsolationLevel_t;</span>
<span class="s1">rd_kafka_AdminOptions_t *rd_kafka_AdminOptions_new(rd_kafka_t *rk, rd_kafka_admin_op_t for_api);</span>
<span class="s1">void rd_kafka_AdminOptions_destroy(rd_kafka_AdminOptions_t *options);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_request_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_operation_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_validate_only(rd_kafka_AdminOptions_t *options, int true_or_false, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_broker(rd_kafka_AdminOptions_t *options, int32_t broker_id, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_AdminOptions_set_require_stable_offsets(rd_kafka_AdminOptions_t *options, int true_or_false);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_AdminOptions_set_include_authorized_operations(rd_kafka_AdminOptions_t *options, int true_or_false);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_AdminOptions_set_match_consumer_group_states(rd_kafka_AdminOptions_t *options, const rd_kafka_consumer_group_state_t *consumer_group_states, size_t consumer_group_states_cnt);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_AdminOptions_set_isolation_level(rd_kafka_AdminOptions_t *options, rd_kafka_IsolationLevel_t value);</span>
<span class="s1">void rd_kafka_AdminOptions_set_opaque(rd_kafka_AdminOptions_t *options, void *ev_opaque);</span>
<span class="s1">typedef enum rd_kafka_AclOperation_t {</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_UNKNOWN = 0,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_ANY = 1,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_ALL = 2,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_READ = 3,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_WRITE = 4,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_CREATE = 5,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_DELETE = 6,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_ALTER = 7,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_DESCRIBE = 8,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_CLUSTER_ACTION = 9,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_DESCRIBE_CONFIGS = 10,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_ALTER_CONFIGS = 11,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_IDEMPOTENT_WRITE = 12,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION__CNT,</span>
<span class="s1">} rd_kafka_AclOperation_t;</span>
<span class="s1">typedef struct rd_kafka_NewTopic_s rd_kafka_NewTopic_t;</span>
<span class="s1">rd_kafka_NewTopic_t *rd_kafka_NewTopic_new(const char *topic, int num_partitions, int replication_factor, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_NewTopic_destroy(rd_kafka_NewTopic_t *new_topic);</span>
<span class="s1">void rd_kafka_NewTopic_destroy_array(rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewTopic_set_replica_assignment(rd_kafka_NewTopic_t *new_topic, int32_t partition, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewTopic_set_config(rd_kafka_NewTopic_t *new_topic, const char *name, const char *value);</span>
<span class="s1">void rd_kafka_CreateTopics(rd_kafka_t *rk, rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_CreateTopics_result_topics(const rd_kafka_CreateTopics_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_DeleteTopic_s rd_kafka_DeleteTopic_t;</span>
<span class="s1">rd_kafka_DeleteTopic_t *rd_kafka_DeleteTopic_new(const char *topic);</span>
<span class="s1">void rd_kafka_DeleteTopic_destroy(rd_kafka_DeleteTopic_t *del_topic);</span>
<span class="s1">void rd_kafka_DeleteTopic_destroy_array(rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt);</span>
<span class="s1">void rd_kafka_DeleteTopics(rd_kafka_t *rk, rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_DeleteTopics_result_topics(const rd_kafka_DeleteTopics_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_NewPartitions_s rd_kafka_NewPartitions_t;</span>
<span class="s1">rd_kafka_NewPartitions_t *rd_kafka_NewPartitions_new(const char *topic, size_t new_total_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_NewPartitions_destroy(rd_kafka_NewPartitions_t *new_parts);</span>
<span class="s1">void rd_kafka_NewPartitions_destroy_array(rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewPartitions_set_replica_assignment(rd_kafka_NewPartitions_t *new_parts, int32_t new_partition_idx, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_CreatePartitions(rd_kafka_t *rk, rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_CreatePartitions_result_topics(const rd_kafka_CreatePartitions_result_t *result, size_t *cntp);</span>
<span class="s1">typedef enum rd_kafka_ConfigSource_t {</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_UNKNOWN_CONFIG = 0,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_TOPIC_CONFIG = 1,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_BROKER_CONFIG = 2,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_DEFAULT_BROKER_CONFIG = 3,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_STATIC_BROKER_CONFIG = 4,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DEFAULT_CONFIG = 5,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE__CNT,</span>
<span class="s1">} rd_kafka_ConfigSource_t;</span>
<span class="s1">const char *rd_kafka_ConfigSource_name(rd_kafka_ConfigSource_t confsource);</span>
<span class="s1">typedef struct rd_kafka_ConfigEntry_s rd_kafka_ConfigEntry_t;</span>
<span class="s1">const char *rd_kafka_ConfigEntry_name(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">const char *rd_kafka_ConfigEntry_value(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">rd_kafka_ConfigSource_t rd_kafka_ConfigEntry_source(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_read_only(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_default(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_sensitive(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_synonym(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">const rd_kafka_ConfigEntry_t **rd_kafka_ConfigEntry_synonyms(const rd_kafka_ConfigEntry_t *entry, size_t *cntp);</span>
<span class="s1">typedef enum rd_kafka_ResourceType_t {</span>
<span class="s1">  RD_KAFKA_RESOURCE_UNKNOWN = 0,</span>
<span class="s1">  RD_KAFKA_RESOURCE_ANY = 1,</span>
<span class="s1">  RD_KAFKA_RESOURCE_TOPIC = 2,</span>
<span class="s1">  RD_KAFKA_RESOURCE_GROUP = 3,</span>
<span class="s1">  RD_KAFKA_RESOURCE_BROKER = 4,</span>
<span class="s1">  RD_KAFKA_RESOURCE__CNT,</span>
<span class="s1">} rd_kafka_ResourceType_t;</span>
<span class="s1">typedef enum rd_kafka_ResourcePatternType_t {</span>
<span class="s1">  RD_KAFKA_RESOURCE_PATTERN_UNKNOWN = 0,</span>
<span class="s1">  RD_KAFKA_RESOURCE_PATTERN_ANY = 1,</span>
<span class="s1">  RD_KAFKA_RESOURCE_PATTERN_MATCH = 2,</span>
<span class="s1">  RD_KAFKA_RESOURCE_PATTERN_LITERAL = 3,</span>
<span class="s1">  RD_KAFKA_RESOURCE_PATTERN_PREFIXED = 4,</span>
<span class="s1">  RD_KAFKA_RESOURCE_PATTERN_TYPE__CNT,</span>
<span class="s1">} rd_kafka_ResourcePatternType_t;</span>
<span class="s1">typedef enum rd_kafka_AlterConfigOpType_t {</span>
<span class="s1">  RD_KAFKA_ALTER_CONFIG_OP_TYPE_SET = 0,</span>
<span class="s1">  RD_KAFKA_ALTER_CONFIG_OP_TYPE_DELETE = 1,</span>
<span class="s1">  RD_KAFKA_ALTER_CONFIG_OP_TYPE_APPEND = 2,</span>
<span class="s1">  RD_KAFKA_ALTER_CONFIG_OP_TYPE_SUBTRACT = 3,</span>
<span class="s1">  RD_KAFKA_ALTER_CONFIG_OP_TYPE__CNT,</span>
<span class="s1">} rd_kafka_AlterConfigOpType_t;</span>
<span class="s1">const char *rd_kafka_ResourcePatternType_name(rd_kafka_ResourcePatternType_t resource_pattern_type);</span>
<span class="s1">const char *rd_kafka_ResourceType_name(rd_kafka_ResourceType_t restype);</span>
<span class="s1">typedef struct rd_kafka_ConfigResource_s rd_kafka_ConfigResource_t;</span>
<span class="s1">rd_kafka_ConfigResource_t *rd_kafka_ConfigResource_new(rd_kafka_ResourceType_t restype, const char *resname);</span>
<span class="s1">void rd_kafka_ConfigResource_destroy(rd_kafka_ConfigResource_t *config);</span>
<span class="s1">void rd_kafka_ConfigResource_destroy_array(rd_kafka_ConfigResource_t **config, size_t config_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_ConfigResource_set_config(rd_kafka_ConfigResource_t *config, const char *name, const char *value);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_ConfigResource_add_incremental_config(rd_kafka_ConfigResource_t *config, const char *name, rd_kafka_AlterConfigOpType_t op_type, const char *value);</span>
<span class="s1">const rd_kafka_ConfigEntry_t **rd_kafka_ConfigResource_configs(const rd_kafka_ConfigResource_t *config, size_t *cntp);</span>
<span class="s1">rd_kafka_ResourceType_t rd_kafka_ConfigResource_type(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">const char *rd_kafka_ConfigResource_name(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_ConfigResource_error(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">const char *rd_kafka_ConfigResource_error_string(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">void rd_kafka_AlterConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_ConfigResource_t **rd_kafka_AlterConfigs_result_resources(const rd_kafka_AlterConfigs_result_t *result, size_t *cntp);</span>
<span class="s1">void rd_kafka_IncrementalAlterConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_ConfigResource_t **rd_kafka_IncrementalAlterConfigs_result_resources(const rd_kafka_IncrementalAlterConfigs_result_t *result, size_t *cntp);</span>
<span class="s1">void rd_kafka_DescribeConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_ConfigResource_t **rd_kafka_DescribeConfigs_result_resources(const rd_kafka_DescribeConfigs_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_DeleteRecords_s rd_kafka_DeleteRecords_t;</span>
<span class="s1">rd_kafka_DeleteRecords_t *rd_kafka_DeleteRecords_new(const rd_kafka_topic_partition_list_t *before_offsets);</span>
<span class="s1">void rd_kafka_DeleteRecords_destroy(rd_kafka_DeleteRecords_t *del_records);</span>
<span class="s1">void rd_kafka_DeleteRecords_destroy_array(rd_kafka_DeleteRecords_t **del_records, size_t del_record_cnt);</span>
<span class="s1">void rd_kafka_DeleteRecords(rd_kafka_t *rk, rd_kafka_DeleteRecords_t **del_records, size_t del_record_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_partition_list_t *rd_kafka_DeleteRecords_result_offsets(const rd_kafka_DeleteRecords_result_t *result);</span>
<span class="s1">typedef struct rd_kafka_TopicCollection_s rd_kafka_TopicCollection_t;</span>
<span class="s1">typedef struct rd_kafka_TopicPartitionInfo_s rd_kafka_TopicPartitionInfo_t;</span>
<span class="s1">typedef struct rd_kafka_TopicDescription_s rd_kafka_TopicDescription_t;</span>
<span class="s1">rd_kafka_TopicCollection_t *rd_kafka_TopicCollection_of_topic_names(const char **topics, size_t topics_cnt);</span>
<span class="s1">void rd_kafka_TopicCollection_destroy(rd_kafka_TopicCollection_t *topics);</span>
<span class="s1">void rd_kafka_DescribeTopics(rd_kafka_t *rk, const rd_kafka_TopicCollection_t *topics, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_TopicDescription_t **rd_kafka_DescribeTopics_result_topics(const rd_kafka_DescribeTopics_result_t *result, size_t *cntp);</span>
<span class="s1">const rd_kafka_TopicPartitionInfo_t **rd_kafka_TopicDescription_partitions(const rd_kafka_TopicDescription_t *topicdesc, size_t *cntp);</span>
<span class="s1">const int rd_kafka_TopicPartitionInfo_partition(const rd_kafka_TopicPartitionInfo_t *partition);</span>
<span class="s1">const rd_kafka_Node_t *rd_kafka_TopicPartitionInfo_leader(const rd_kafka_TopicPartitionInfo_t *partition);</span>
<span class="s1">const rd_kafka_Node_t **rd_kafka_TopicPartitionInfo_isr(const rd_kafka_TopicPartitionInfo_t *partition, size_t *cntp);</span>
<span class="s1">const rd_kafka_Node_t **rd_kafka_TopicPartitionInfo_replicas(const rd_kafka_TopicPartitionInfo_t *partition, size_t *cntp);</span>
<span class="s1">const rd_kafka_AclOperation_t *rd_kafka_TopicDescription_authorized_operations(const rd_kafka_TopicDescription_t *topicdesc, size_t *cntp);</span>
<span class="s1">const char *rd_kafka_TopicDescription_name(const rd_kafka_TopicDescription_t *topicdesc);</span>
<span class="s1">const rd_kafka_Uuid_t *rd_kafka_TopicDescription_topic_id(const rd_kafka_TopicDescription_t *topicdesc);</span>
<span class="s1">int rd_kafka_TopicDescription_is_internal(const rd_kafka_TopicDescription_t *topicdesc);</span>
<span class="s1">const rd_kafka_error_t *rd_kafka_TopicDescription_error(const rd_kafka_TopicDescription_t *topicdesc);</span>
<span class="s1">void rd_kafka_DescribeCluster(rd_kafka_t *rk, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_Node_t **rd_kafka_DescribeCluster_result_nodes(const rd_kafka_DescribeCluster_result_t *result, size_t *cntp);</span>
<span class="s1">const rd_kafka_AclOperation_t *rd_kafka_DescribeCluster_result_authorized_operations(const rd_kafka_DescribeCluster_result_t *result, size_t *cntp);</span>
<span class="s1">const rd_kafka_Node_t *rd_kafka_DescribeCluster_result_controller(const rd_kafka_DescribeCluster_result_t *result);</span>
<span class="s1">const char *rd_kafka_DescribeCluster_result_cluster_id(const rd_kafka_DescribeCluster_result_t *result);</span>
<span class="s1">typedef struct rd_kafka_ConsumerGroupListing_s rd_kafka_ConsumerGroupListing_t;</span>
<span class="s1">typedef struct rd_kafka_ListConsumerGroupsResult_s rd_kafka_ListConsumerGroupsResult_t;</span>
<span class="s1">void rd_kafka_ListConsumerGroups(rd_kafka_t *rk, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const char *rd_kafka_ConsumerGroupListing_group_id(const rd_kafka_ConsumerGroupListing_t *grplist);</span>
<span class="s1">int rd_kafka_ConsumerGroupListing_is_simple_consumer_group(const rd_kafka_ConsumerGroupListing_t *grplist);</span>
<span class="s1">rd_kafka_consumer_group_state_t rd_kafka_ConsumerGroupListing_state(const rd_kafka_ConsumerGroupListing_t *grplist);</span>
<span class="s1">const rd_kafka_ConsumerGroupListing_t **rd_kafka_ListConsumerGroups_result_valid(const rd_kafka_ListConsumerGroups_result_t *result, size_t *cntp);</span>
<span class="s1">const rd_kafka_error_t **rd_kafka_ListConsumerGroups_result_errors(const rd_kafka_ListConsumerGroups_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_ConsumerGroupDescription_s rd_kafka_ConsumerGroupDescription_t;</span>
<span class="s1">typedef struct rd_kafka_MemberDescription_s rd_kafka_MemberDescription_t;</span>
<span class="s1">typedef struct rd_kafka_MemberAssignment_s rd_kafka_MemberAssignment_t;</span>
<span class="s1">void rd_kafka_DescribeConsumerGroups(rd_kafka_t *rk, const char **groups, size_t groups_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_ConsumerGroupDescription_t **rd_kafka_DescribeConsumerGroups_result_groups(const rd_kafka_DescribeConsumerGroups_result_t *result, size_t *cntp);</span>
<span class="s1">const char *rd_kafka_ConsumerGroupDescription_group_id(const rd_kafka_ConsumerGroupDescription_t *grpdesc);</span>
<span class="s1">const rd_kafka_error_t *rd_kafka_ConsumerGroupDescription_error(const rd_kafka_ConsumerGroupDescription_t *grpdesc);</span>
<span class="s1">int rd_kafka_ConsumerGroupDescription_is_simple_consumer_group(const rd_kafka_ConsumerGroupDescription_t *grpdesc);</span>
<span class="s1">const char *rd_kafka_ConsumerGroupDescription_partition_assignor(const rd_kafka_ConsumerGroupDescription_t *grpdesc);</span>
<span class="s1">const rd_kafka_AclOperation_t *rd_kafka_ConsumerGroupDescription_authorized_operations(const rd_kafka_ConsumerGroupDescription_t *grpdesc, size_t *cntp);</span>
<span class="s1">rd_kafka_consumer_group_state_t rd_kafka_ConsumerGroupDescription_state(const rd_kafka_ConsumerGroupDescription_t *grpdesc);</span>
<span class="s1">const rd_kafka_Node_t *rd_kafka_ConsumerGroupDescription_coordinator(const rd_kafka_ConsumerGroupDescription_t *grpdesc);</span>
<span class="s1">size_t rd_kafka_ConsumerGroupDescription_member_count(const rd_kafka_ConsumerGroupDescription_t *grpdesc);</span>
<span class="s1">const rd_kafka_MemberDescription_t *rd_kafka_ConsumerGroupDescription_member(const rd_kafka_ConsumerGroupDescription_t *grpdesc, size_t idx);</span>
<span class="s1">const char *rd_kafka_MemberDescription_client_id(const rd_kafka_MemberDescription_t *member);</span>
<span class="s1">const char *rd_kafka_MemberDescription_group_instance_id(const rd_kafka_MemberDescription_t *member);</span>
<span class="s1">const char *rd_kafka_MemberDescription_consumer_id(const rd_kafka_MemberDescription_t *member);</span>
<span class="s1">const char *rd_kafka_MemberDescription_host(const rd_kafka_MemberDescription_t *member);</span>
<span class="s1">const rd_kafka_MemberAssignment_t *rd_kafka_MemberDescription_assignment(const rd_kafka_MemberDescription_t *member);</span>
<span class="s1">const rd_kafka_topic_partition_list_t *rd_kafka_MemberAssignment_partitions(const rd_kafka_MemberAssignment_t *assignment);</span>
<span class="s1">typedef struct rd_kafka_DeleteGroup_s rd_kafka_DeleteGroup_t;</span>
<span class="s1">rd_kafka_DeleteGroup_t *rd_kafka_DeleteGroup_new(const char *group);</span>
<span class="s1">void rd_kafka_DeleteGroup_destroy(rd_kafka_DeleteGroup_t *del_group);</span>
<span class="s1">void rd_kafka_DeleteGroup_destroy_array(rd_kafka_DeleteGroup_t **del_groups, size_t del_group_cnt);</span>
<span class="s1">void rd_kafka_DeleteGroups(rd_kafka_t *rk, rd_kafka_DeleteGroup_t **del_groups, size_t del_group_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_group_result_t **rd_kafka_DeleteGroups_result_groups(const rd_kafka_DeleteGroups_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_ListConsumerGroupOffsets_s rd_kafka_ListConsumerGroupOffsets_t;</span>
<span class="s1">rd_kafka_ListConsumerGroupOffsets_t *rd_kafka_ListConsumerGroupOffsets_new(const char *group_id, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">void rd_kafka_ListConsumerGroupOffsets_destroy(rd_kafka_ListConsumerGroupOffsets_t *list_grpoffsets);</span>
<span class="s1">void rd_kafka_ListConsumerGroupOffsets_destroy_array(rd_kafka_ListConsumerGroupOffsets_t **list_grpoffsets, size_t list_grpoffset_cnt);</span>
<span class="s1">void rd_kafka_ListConsumerGroupOffsets(rd_kafka_t *rk, rd_kafka_ListConsumerGroupOffsets_t **list_grpoffsets, size_t list_grpoffsets_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_group_result_t **rd_kafka_ListConsumerGroupOffsets_result_groups(const rd_kafka_ListConsumerGroupOffsets_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_AlterConsumerGroupOffsets_s rd_kafka_AlterConsumerGroupOffsets_t;</span>
<span class="s1">rd_kafka_AlterConsumerGroupOffsets_t *rd_kafka_AlterConsumerGroupOffsets_new(const char *group_id, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">void rd_kafka_AlterConsumerGroupOffsets_destroy(rd_kafka_AlterConsumerGroupOffsets_t *alter_grpoffsets);</span>
<span class="s1">void rd_kafka_AlterConsumerGroupOffsets_destroy_array(rd_kafka_AlterConsumerGroupOffsets_t **alter_grpoffsets, size_t alter_grpoffset_cnt);</span>
<span class="s1">void rd_kafka_AlterConsumerGroupOffsets(rd_kafka_t *rk, rd_kafka_AlterConsumerGroupOffsets_t **alter_grpoffsets, size_t alter_grpoffsets_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_group_result_t **rd_kafka_AlterConsumerGroupOffsets_result_groups(const rd_kafka_AlterConsumerGroupOffsets_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_DeleteConsumerGroupOffsets_s rd_kafka_DeleteConsumerGroupOffsets_t;</span>
<span class="s1">rd_kafka_DeleteConsumerGroupOffsets_t *rd_kafka_DeleteConsumerGroupOffsets_new(const char *group, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">void rd_kafka_DeleteConsumerGroupOffsets_destroy(rd_kafka_DeleteConsumerGroupOffsets_t *del_grpoffsets);</span>
<span class="s1">void rd_kafka_DeleteConsumerGroupOffsets_destroy_array(rd_kafka_DeleteConsumerGroupOffsets_t **del_grpoffsets, size_t del_grpoffset_cnt);</span>
<span class="s1">void rd_kafka_DeleteConsumerGroupOffsets(rd_kafka_t *rk, rd_kafka_DeleteConsumerGroupOffsets_t **del_grpoffsets, size_t del_grpoffsets_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_group_result_t **rd_kafka_DeleteConsumerGroupOffsets_result_groups(const rd_kafka_DeleteConsumerGroupOffsets_result_t *result, size_t *cntp);</span>
<span class="s1">typedef enum rd_kafka_OffsetSpec_t {</span>
<span class="s1">  RD_KAFKA_OFFSET_SPEC_MAX_TIMESTAMP = (- 3),</span>
<span class="s1">  RD_KAFKA_OFFSET_SPEC_EARLIEST = (- 2),</span>
<span class="s1">  RD_KAFKA_OFFSET_SPEC_LATEST = (- 1),</span>
<span class="s1">} rd_kafka_OffsetSpec_t;</span>
<span class="s1">typedef struct rd_kafka_ListOffsetsResultInfo_s rd_kafka_ListOffsetsResultInfo_t;</span>
<span class="s1">const rd_kafka_topic_partition_t *rd_kafka_ListOffsetsResultInfo_topic_partition(const rd_kafka_ListOffsetsResultInfo_t *result_info);</span>
<span class="s1">int64_t rd_kafka_ListOffsetsResultInfo_timestamp(const rd_kafka_ListOffsetsResultInfo_t *result_info);</span>
<span class="s1">const rd_kafka_ListOffsetsResultInfo_t **rd_kafka_ListOffsets_result_infos(const rd_kafka_ListOffsets_result_t *result, size_t *cntp);</span>
<span class="s1">void rd_kafka_ListOffsets(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *topic_partitions, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">typedef enum rd_kafka_ScramMechanism_t {</span>
<span class="s1">  RD_KAFKA_SCRAM_MECHANISM_UNKNOWN = 0,</span>
<span class="s1">  RD_KAFKA_SCRAM_MECHANISM_SHA_256 = 1,</span>
<span class="s1">  RD_KAFKA_SCRAM_MECHANISM_SHA_512 = 2,</span>
<span class="s1">  RD_KAFKA_SCRAM_MECHANISM__CNT,</span>
<span class="s1">} rd_kafka_ScramMechanism_t;</span>
<span class="s1">typedef struct rd_kafka_ScramCredentialInfo_s rd_kafka_ScramCredentialInfo_t;</span>
<span class="s1">rd_kafka_ScramMechanism_t rd_kafka_ScramCredentialInfo_mechanism(const rd_kafka_ScramCredentialInfo_t *scram_credential_info);</span>
<span class="s1">int32_t rd_kafka_ScramCredentialInfo_iterations(const rd_kafka_ScramCredentialInfo_t *scram_credential_info);</span>
<span class="s1">typedef struct rd_kafka_UserScramCredentialsDescription_s rd_kafka_UserScramCredentialsDescription_t;</span>
<span class="s1">const char *rd_kafka_UserScramCredentialsDescription_user(const rd_kafka_UserScramCredentialsDescription_t *description);</span>
<span class="s1">const rd_kafka_error_t *rd_kafka_UserScramCredentialsDescription_error(const rd_kafka_UserScramCredentialsDescription_t *description);</span>
<span class="s1">size_t rd_kafka_UserScramCredentialsDescription_scramcredentialinfo_count(const rd_kafka_UserScramCredentialsDescription_t *description);</span>
<span class="s1">const rd_kafka_ScramCredentialInfo_t *rd_kafka_UserScramCredentialsDescription_scramcredentialinfo(const rd_kafka_UserScramCredentialsDescription_t *description, size_t idx);</span>
<span class="s1">const rd_kafka_UserScramCredentialsDescription_t **rd_kafka_DescribeUserScramCredentials_result_descriptions(const rd_kafka_DescribeUserScramCredentials_result_t *result, size_t *cntp);</span>
<span class="s1">void rd_kafka_DescribeUserScramCredentials(rd_kafka_t *rk, const char **users, size_t user_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">typedef struct rd_kafka_UserScramCredentialAlteration_s rd_kafka_UserScramCredentialAlteration_t;</span>
<span class="s1">rd_kafka_UserScramCredentialAlteration_t *rd_kafka_UserScramCredentialUpsertion_new(const char *username, rd_kafka_ScramMechanism_t mechanism, int32_t iterations, const unsigned char *password, size_t password_size, const unsigned char *salt, size_t salt_size);</span>
<span class="s1">rd_kafka_UserScramCredentialAlteration_t *rd_kafka_UserScramCredentialDeletion_new(const char *username, rd_kafka_ScramMechanism_t mechanism);</span>
<span class="s1">void rd_kafka_UserScramCredentialAlteration_destroy(rd_kafka_UserScramCredentialAlteration_t *alteration);</span>
<span class="s1">void rd_kafka_UserScramCredentialAlteration_destroy_array(rd_kafka_UserScramCredentialAlteration_t **alterations, size_t alteration_cnt);</span>
<span class="s1">typedef struct rd_kafka_AlterUserScramCredentials_result_response_s rd_kafka_AlterUserScramCredentials_result_response_t;</span>
<span class="s1">const char *rd_kafka_AlterUserScramCredentials_result_response_user(const rd_kafka_AlterUserScramCredentials_result_response_t *response);</span>
<span class="s1">const rd_kafka_error_t *rd_kafka_AlterUserScramCredentials_result_response_error(const rd_kafka_AlterUserScramCredentials_result_response_t *response);</span>
<span class="s1">const rd_kafka_AlterUserScramCredentials_result_response_t **rd_kafka_AlterUserScramCredentials_result_responses(const rd_kafka_AlterUserScramCredentials_result_t *result, size_t *cntp);</span>
<span class="s1">void rd_kafka_AlterUserScramCredentials(rd_kafka_t *rk, rd_kafka_UserScramCredentialAlteration_t **alterations, size_t alteration_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">typedef struct rd_kafka_AclBinding_s rd_kafka_AclBinding_t;</span>
<span class="s1">typedef rd_kafka_AclBinding_t rd_kafka_AclBindingFilter_t;</span>
<span class="s1">const rd_kafka_error_t *rd_kafka_acl_result_error(const rd_kafka_acl_result_t *aclres);</span>
<span class="s1">const char *rd_kafka_AclOperation_name(rd_kafka_AclOperation_t acl_operation);</span>
<span class="s1">typedef enum rd_kafka_AclPermissionType_t {</span>
<span class="s1">  RD_KAFKA_ACL_PERMISSION_TYPE_UNKNOWN = 0,</span>
<span class="s1">  RD_KAFKA_ACL_PERMISSION_TYPE_ANY = 1,</span>
<span class="s1">  RD_KAFKA_ACL_PERMISSION_TYPE_DENY = 2,</span>
<span class="s1">  RD_KAFKA_ACL_PERMISSION_TYPE_ALLOW = 3,</span>
<span class="s1">  RD_KAFKA_ACL_PERMISSION_TYPE__CNT,</span>
<span class="s1">} rd_kafka_AclPermissionType_t;</span>
<span class="s1">const char *rd_kafka_AclPermissionType_name(rd_kafka_AclPermissionType_t acl_permission_type);</span>
<span class="s1">rd_kafka_AclBinding_t *rd_kafka_AclBinding_new(rd_kafka_ResourceType_t restype, const char *name, rd_kafka_ResourcePatternType_t resource_pattern_type, const char *principal, const char *host, rd_kafka_AclOperation_t operation, rd_kafka_AclPermissionType_t permission_type, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_AclBindingFilter_t *rd_kafka_AclBindingFilter_new(rd_kafka_ResourceType_t restype, const char *name, rd_kafka_ResourcePatternType_t resource_pattern_type, const char *principal, const char *host, rd_kafka_AclOperation_t operation, rd_kafka_AclPermissionType_t permission_type, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_ResourceType_t rd_kafka_AclBinding_restype(const rd_kafka_AclBinding_t *acl);</span>
<span class="s1">const char *rd_kafka_AclBinding_name(const rd_kafka_AclBinding_t *acl);</span>
<span class="s1">const char *rd_kafka_AclBinding_principal(const rd_kafka_AclBinding_t *acl);</span>
<span class="s1">const char *rd_kafka_AclBinding_host(const rd_kafka_AclBinding_t *acl);</span>
<span class="s1">rd_kafka_AclOperation_t rd_kafka_AclBinding_operation(const rd_kafka_AclBinding_t *acl);</span>
<span class="s1">rd_kafka_AclPermissionType_t rd_kafka_AclBinding_permission_type(const rd_kafka_AclBinding_t *acl);</span>
<span class="s1">rd_kafka_ResourcePatternType_t rd_kafka_AclBinding_resource_pattern_type(const rd_kafka_AclBinding_t *acl);</span>
<span class="s1">const rd_kafka_error_t *rd_kafka_AclBinding_error(const rd_kafka_AclBinding_t *acl);</span>
<span class="s1">void rd_kafka_AclBinding_destroy(rd_kafka_AclBinding_t *acl_binding);</span>
<span class="s1">void rd_kafka_AclBinding_destroy_array(rd_kafka_AclBinding_t **acl_bindings, size_t acl_bindings_cnt);</span>
<span class="s1">const rd_kafka_acl_result_t **rd_kafka_CreateAcls_result_acls(const rd_kafka_CreateAcls_result_t *result, size_t *cntp);</span>
<span class="s1">void rd_kafka_CreateAcls(rd_kafka_t *rk, rd_kafka_AclBinding_t **new_acls, size_t new_acls_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_AclBinding_t **rd_kafka_DescribeAcls_result_acls(const rd_kafka_DescribeAcls_result_t *result, size_t *cntp);</span>
<span class="s1">void rd_kafka_DescribeAcls(rd_kafka_t *rk, rd_kafka_AclBindingFilter_t *acl_filter, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">typedef struct rd_kafka_DeleteAcls_result_response_s rd_kafka_DeleteAcls_result_response_t;</span>
<span class="s1">const rd_kafka_DeleteAcls_result_response_t **rd_kafka_DeleteAcls_result_responses(const rd_kafka_DeleteAcls_result_t *result, size_t *cntp);</span>
<span class="s1">const rd_kafka_error_t *rd_kafka_DeleteAcls_result_response_error(const rd_kafka_DeleteAcls_result_response_t *result_response);</span>
<span class="s1">const rd_kafka_AclBinding_t **rd_kafka_DeleteAcls_result_response_matching_acls(const rd_kafka_DeleteAcls_result_response_t *result_response, size_t *matching_acls_cntp);</span>
<span class="s1">void rd_kafka_DeleteAcls(rd_kafka_t *rk, rd_kafka_AclBindingFilter_t **del_acls, size_t del_acls_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token(rd_kafka_t *rk, const char *token_value, int64_t md_lifetime_ms, const char *md_principal_name, const char **extensions, size_t extension_size, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token_failure(rd_kafka_t *rk, const char *errstr);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_init_transactions(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_begin_transaction(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_send_offsets_to_transaction(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, const rd_kafka_consumer_group_metadata_t *cgmetadata, int timeout_ms);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_commit_transaction(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_abort_transaction(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">typedef struct rd_kafka_mock_cluster_s rd_kafka_mock_cluster_t;</span>
<span class="s1">rd_kafka_mock_cluster_t *rd_kafka_mock_cluster_new(rd_kafka_t *rk, int broker_cnt);</span>
<span class="s1">void rd_kafka_mock_cluster_destroy(rd_kafka_mock_cluster_t *mcluster);</span>
<span class="s1">rd_kafka_t *rd_kafka_mock_cluster_handle(const rd_kafka_mock_cluster_t *mcluster);</span>
<span class="s1">rd_kafka_mock_cluster_t *rd_kafka_handle_mock_cluster(const rd_kafka_t *rk);</span>
<span class="s1">const char *rd_kafka_mock_cluster_bootstraps(const rd_kafka_mock_cluster_t *mcluster);</span>
<span class="s1">void rd_kafka_mock_clear_request_errors(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey);</span>
<span class="s1">void rd_kafka_mock_push_request_errors(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, size_t cnt, ...);</span>
<span class="s1">void rd_kafka_mock_push_request_errors_array(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, size_t cnt, const rd_kafka_resp_err_t *errors);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_push_request_error_rtts(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int16_t ApiKey, size_t cnt, ...);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_error_stack_cnt(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int16_t ApiKey, size_t *cntp);</span>
<span class="s1">void rd_kafka_mock_topic_set_error(rd_kafka_mock_cluster_t *mcluster, const char *topic, rd_kafka_resp_err_t err);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_topic_create(rd_kafka_mock_cluster_t *mcluster, const char *topic, int partition_cnt, int replication_factor);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_partition_set_leader(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_partition_set_follower(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_partition_set_follower_wmarks(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int64_t lo, int64_t hi);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_set_down(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_set_up(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_set_rtt(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int rtt_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_set_rack(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, const char *rack);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_coordinator_set(rd_kafka_mock_cluster_t *mcluster, const char *key_type, const char *key, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_set_apiversion(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, int16_t MinVersion, int16_t MaxVersion);</span>
<span class="s1">void rd_kafka_mock_start_request_tracking(rd_kafka_mock_cluster_t *mcluster);</span>
<span class="s1">void rd_kafka_mock_stop_request_tracking(rd_kafka_mock_cluster_t *mcluster);</span>
<span class="s1">typedef struct rd_kafka_mock_request_s rd_kafka_mock_request_t;</span>
<span class="s1">void rd_kafka_mock_request_destroy(rd_kafka_mock_request_t *mreq);</span>
<span class="s1">int32_t rd_kafka_mock_request_id(rd_kafka_mock_request_t *mreq);</span>
<span class="s1">int16_t rd_kafka_mock_request_api_key(rd_kafka_mock_request_t *mreq);</span>
<span class="s1">int64_t rd_kafka_mock_request_timestamp(rd_kafka_mock_request_t *mreq);</span>
<span class="s1">rd_kafka_mock_request_t **rd_kafka_mock_get_requests(rd_kafka_mock_cluster_t *mcluster, size_t *cntp);</span>
<span class="s1">void rd_kafka_mock_clear_requests(rd_kafka_mock_cluster_t *mcluster);</span>
<span class="s1">&#39;</span>
</code></pre></div>
rdkafka.h, rdkafka_mock.h</p>
<h3 id="rd_kafka_version_30">RD_KAFKA_VERSION<a class="headerlink" href="#rd_kafka_version_30" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_VERSION</span> <span class="o">=</span> <span class="mi">33816831</span>
</code></pre></div>
<p>librdkafka version </p>
<p>Interpreted as hex <code>MM.mm.rr.xx</code>:</p>
<ul>
<li>MM = Major</li>
<li>mm = minor</li>
<li>rr = revision</li>
<li>xx = pre-release id (0xff is the final release)</li>
</ul>
<p>E.g.: <code>0x000801ff</code> = 0.8.1</p>
<dl class="section remark"><dt>Remarks</dt><dd>This value should only be used during compile time, for runtime checks of version use rd_kafka_version() </dd></dl>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_unsupported_compression_type_30">RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE<a class="headerlink" href="#rd_kafka_resp_err_unsupported_compression_type_30" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE</span> <span class="o">=</span> <span class="mi">76</span>
</code></pre></div>
<p>Unsupported compression type </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_end_all_30">RD_KAFKA_RESP_ERR_END_ALL<a class="headerlink" href="#rd_kafka_resp_err_end_all_30" title="Permanent link">&para;</a></h3>
<p><div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_END_ALL</span> <span class="o">=</span> <span class="mi">114</span>
</code></pre></div>
enum rd_kafka_resp_err_t</p>
<h3 id="rd_kafka_admin_op__cnt_30">RD_KAFKA_ADMIN_OP__CNT<a class="headerlink" href="#rd_kafka_admin_op__cnt_30" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_ADMIN_OP__CNT</span> <span class="o">=</span> <span class="mi">22</span>
</code></pre></div>
<p>Number of ops defined </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe </a></li>
</ul>
</div>
<h3 id="rd_kafka_resource__cnt_30">RD_KAFKA_RESOURCE__CNT<a class="headerlink" href="#rd_kafka_resource__cnt_30" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESOURCE__CNT</span> <span class="o">=</span> <span class="mi">5</span>
</code></pre></div>
<p>Number of resource types defined </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#acca83a66d7783ff7683ed2691cc907c9"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#acca83a66d7783ff7683ed2691cc907c9 </a></li>
</ul>
</div>
<h3 id="rd_kafka_cdef_30">RD_KAFKA_CDEF<a class="headerlink" href="#rd_kafka_cdef_30" title="Permanent link">&para;</a></h3>
<p><div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_CDEF</span> <span class="o">=</span> <span class="s1">&#39;typedef long int ssize_t;</span>
<span class="s1">typedef struct _IO_FILE FILE;</span>
<span class="s1">typedef long int mode_t;</span>
<span class="s1">typedef signed int int16_t;</span>
<span class="s1">typedef unsigned int uint16_t;</span>
<span class="s1">typedef signed int int32_t;</span>
<span class="s1">typedef signed long int int64_t;</span>
<span class="s1">int rd_kafka_version(void);</span>
<span class="s1">const char *rd_kafka_version_str(void);</span>
<span class="s1">typedef enum rd_kafka_type_t {</span>
<span class="s1">  RD_KAFKA_PRODUCER,</span>
<span class="s1">  RD_KAFKA_CONSUMER,</span>
<span class="s1">} rd_kafka_type_t;</span>
<span class="s1">typedef enum rd_kafka_timestamp_type_t {</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_NOT_AVAILABLE,</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_CREATE_TIME,</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_LOG_APPEND_TIME,</span>
<span class="s1">} rd_kafka_timestamp_type_t;</span>
<span class="s1">const char *rd_kafka_get_debug_contexts(void);</span>
<span class="s1">typedef struct rd_kafka_s rd_kafka_t;</span>
<span class="s1">typedef struct rd_kafka_topic_s rd_kafka_topic_t;</span>
<span class="s1">typedef struct rd_kafka_conf_s rd_kafka_conf_t;</span>
<span class="s1">typedef struct rd_kafka_topic_conf_s rd_kafka_topic_conf_t;</span>
<span class="s1">typedef struct rd_kafka_queue_s rd_kafka_queue_t;</span>
<span class="s1">typedef struct rd_kafka_op_s rd_kafka_event_t;</span>
<span class="s1">typedef struct rd_kafka_topic_result_s rd_kafka_topic_result_t;</span>
<span class="s1">typedef struct rd_kafka_consumer_group_metadata_s rd_kafka_consumer_group_metadata_t;</span>
<span class="s1">typedef struct rd_kafka_error_s {</span>
<span class="s1">  unsigned int code;</span>
<span class="s1">  char *errstr;</span>
<span class="s1">  unsigned char fatal;</span>
<span class="s1">  unsigned char retriable;</span>
<span class="s1">  unsigned char txn_requires_abort;</span>
<span class="s1">} rd_kafka_error_t;</span>
<span class="s1">typedef struct rd_kafka_headers_s rd_kafka_headers_t;</span>
<span class="s1">typedef struct rd_kafka_group_result_s rd_kafka_group_result_t;</span>
<span class="s1">typedef struct rd_kafka_acl_result_s rd_kafka_acl_result_t;</span>
<span class="s1">typedef struct rd_kafka_Uuid_s rd_kafka_Uuid_t;</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BEGIN = (- 200),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BAD_MSG = (- 199),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BAD_COMPRESSION = (- 198),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__DESTROY = (- 197),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FAIL = (- 196),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TRANSPORT = (- 195),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__CRIT_SYS_RESOURCE = (- 194),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__RESOLVE = (- 193),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__MSG_TIMED_OUT = (- 192),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PARTITION_EOF = (- 191),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION = (- 190),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FS = (- 189),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC = (- 188),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ALL_BROKERS_DOWN = (- 187),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INVALID_ARG = (- 186),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TIMED_OUT = (- 185),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__QUEUE_FULL = (- 184),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ISR_INSUFF = (- 183),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NODE_UPDATE = (- 182),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__SSL = (- 181),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__WAIT_COORD = (- 180),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_GROUP = (- 179),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__IN_PROGRESS = (- 178),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PREV_IN_PROGRESS = (- 177),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__EXISTING_SUBSCRIPTION = (- 176),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS = (- 175),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS = (- 174),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__CONFLICT = (- 173),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__STATE = (- 172),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_PROTOCOL = (- 171),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED = (- 170),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__AUTHENTICATION = (- 169),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NO_OFFSET = (- 168),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__OUTDATED = (- 167),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TIMED_OUT_QUEUE = (- 166),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNSUPPORTED_FEATURE = (- 165),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__WAIT_CACHE = (- 164),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INTR = (- 163),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__KEY_SERIALIZATION = (- 162),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__VALUE_SERIALIZATION = (- 161),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__KEY_DESERIALIZATION = (- 160),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__VALUE_DESERIALIZATION = (- 159),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PARTIAL = (- 158),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__READ_ONLY = (- 157),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOENT = (- 156),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNDERFLOW = (- 155),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INVALID_TYPE = (- 154),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__RETRY = (- 153),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PURGE_QUEUE = (- 152),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PURGE_INFLIGHT = (- 151),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FATAL = (- 150),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INCONSISTENT = (- 149),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__GAPLESS_GUARANTEE = (- 148),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__MAX_POLL_EXCEEDED = (- 147),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_BROKER = (- 146),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOT_CONFIGURED = (- 145),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FENCED = (- 144),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__APPLICATION = (- 143),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ASSIGNMENT_LOST = (- 142),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOOP = (- 141),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__AUTO_OFFSET_RESET = (- 140),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__LOG_TRUNCATION = (- 139),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INVALID_DIFFERENT_RECORD = (- 138),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__END = (- 100),</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN = (- 1),</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NO_ERROR = 0,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_OUT_OF_RANGE = 1,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_MSG = 2,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART = 3,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_MSG_SIZE = 4,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE = 5,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_LEADER_FOR_PARTITION = 6,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REQUEST_TIMED_OUT = 7,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_BROKER_NOT_AVAILABLE = 8,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REPLICA_NOT_AVAILABLE = 9,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE = 10,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_STALE_CTRL_EPOCH = 11,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_METADATA_TOO_LARGE = 12,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NETWORK_EXCEPTION = 13,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_COORDINATOR_LOAD_IN_PROGRESS = 14,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_COORDINATOR_NOT_AVAILABLE = 15,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_COORDINATOR = 16,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_EXCEPTION = 17,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_RECORD_LIST_TOO_LARGE = 18,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS = 19,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS_AFTER_APPEND = 20,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REQUIRED_ACKS = 21,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ILLEGAL_GENERATION = 22,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INCONSISTENT_GROUP_PROTOCOL = 23,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_GROUP_ID = 24,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_MEMBER_ID = 25,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_SESSION_TIMEOUT = 26,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REBALANCE_IN_PROGRESS = 27,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_COMMIT_OFFSET_SIZE = 28,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_AUTHORIZATION_FAILED = 29,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_AUTHORIZATION_FAILED = 30,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_CLUSTER_AUTHORIZATION_FAILED = 31,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TIMESTAMP = 32,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_SASL_MECHANISM = 33,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ILLEGAL_SASL_STATE = 34,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_VERSION = 35,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_ALREADY_EXISTS = 36,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PARTITIONS = 37,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REPLICATION_FACTOR = 38,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REPLICA_ASSIGNMENT = 39,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_CONFIG = 40,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_CONTROLLER = 41,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REQUEST = 42,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_FOR_MESSAGE_FORMAT = 43,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_POLICY_VIOLATION = 44,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OUT_OF_ORDER_SEQUENCE_NUMBER = 45,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DUPLICATE_SEQUENCE_NUMBER = 46,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_EPOCH = 47,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TXN_STATE = 48,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_ID_MAPPING = 49,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TRANSACTION_TIMEOUT = 50,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_CONCURRENT_TRANSACTIONS = 51,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TRANSACTION_COORDINATOR_FENCED = 52,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TRANSACTIONAL_ID_AUTHORIZATION_FAILED = 53,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_SECURITY_DISABLED = 54,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OPERATION_NOT_ATTEMPTED = 55,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_KAFKA_STORAGE_ERROR = 56,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LOG_DIR_NOT_FOUND = 57,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_SASL_AUTHENTICATION_FAILED = 58,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_PRODUCER_ID = 59,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REASSIGNMENT_IN_PROGRESS = 60,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTH_DISABLED = 61,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_NOT_FOUND = 62,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_OWNER_MISMATCH = 63,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_REQUEST_NOT_ALLOWED = 64,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTHORIZATION_FAILED = 65,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_EXPIRED = 66,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRINCIPAL_TYPE = 67,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NON_EMPTY_GROUP = 68,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_ID_NOT_FOUND = 69,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FETCH_SESSION_ID_NOT_FOUND = 70,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_FETCH_SESSION_EPOCH = 71,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LISTENER_NOT_FOUND = 72,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_DELETION_DISABLED = 73,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FENCED_LEADER_EPOCH = 74,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_LEADER_EPOCH = 75,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_STALE_BROKER_EPOCH = 77,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_NOT_AVAILABLE = 78,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_MEMBER_ID_REQUIRED = 79,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_PREFERRED_LEADER_NOT_AVAILABLE = 80,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_MAX_SIZE_REACHED = 81,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FENCED_INSTANCE_ID = 82,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ELIGIBLE_LEADERS_NOT_AVAILABLE = 83,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ELECTION_NOT_NEEDED = 84,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NO_REASSIGNMENT_IN_PROGRESS = 85,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_SUBSCRIBED_TO_TOPIC = 86,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_RECORD = 87,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSTABLE_OFFSET_COMMIT = 88,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_THROTTLING_QUOTA_EXCEEDED = 89,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_PRODUCER_FENCED = 90,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_RESOURCE_NOT_FOUND = 91,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DUPLICATE_RESOURCE = 92,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNACCEPTABLE_CREDENTIAL = 93,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INCONSISTENT_VOTER_SET = 94,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_UPDATE_VERSION = 95,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FEATURE_UPDATE_FAILED = 96,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_PRINCIPAL_DESERIALIZATION_FAILURE = 97,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_ID = 100,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FENCED_MEMBER_EPOCH = 110,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNRELEASED_INSTANCE_ID = 111,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_ASSIGNOR = 112,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_STALE_MEMBER_EPOCH = 113,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_END_ALL,</span>
<span class="s1">} rd_kafka_resp_err_t;</span>
<span class="s1">struct rd_kafka_err_desc {</span>
<span class="s1">  rd_kafka_resp_err_t code;</span>
<span class="s1">  char *name;</span>
<span class="s1">  char *desc;</span>
<span class="s1">};</span>
<span class="s1">void rd_kafka_get_err_descs(const struct rd_kafka_err_desc **errdescs, size_t *cntp);</span>
<span class="s1">const char *rd_kafka_err2str(rd_kafka_resp_err_t err);</span>
<span class="s1">const char *rd_kafka_err2name(rd_kafka_resp_err_t err);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_last_error(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_errno2err(int errnox);</span>
<span class="s1">int rd_kafka_errno(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_fatal_error(rd_kafka_t *rk, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_test_fatal_error(rd_kafka_t *rk, rd_kafka_resp_err_t err, const char *reason);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_error_code(const rd_kafka_error_t *error);</span>
<span class="s1">const char *rd_kafka_error_name(const rd_kafka_error_t *error);</span>
<span class="s1">const char *rd_kafka_error_string(const rd_kafka_error_t *error);</span>
<span class="s1">int rd_kafka_error_is_fatal(const rd_kafka_error_t *error);</span>
<span class="s1">int rd_kafka_error_is_retriable(const rd_kafka_error_t *error);</span>
<span class="s1">int rd_kafka_error_txn_requires_abort(const rd_kafka_error_t *error);</span>
<span class="s1">void rd_kafka_error_destroy(rd_kafka_error_t *error);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_error_new(rd_kafka_resp_err_t code, const char *fmt, ...);</span>
<span class="s1">typedef struct rd_kafka_topic_partition_s {</span>
<span class="s1">  char *topic;</span>
<span class="s1">  int32_t partition;</span>
<span class="s1">  int64_t offset;</span>
<span class="s1">  void *metadata;</span>
<span class="s1">  size_t metadata_size;</span>
<span class="s1">  void *opaque;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  void *_private;</span>
<span class="s1">} rd_kafka_topic_partition_t;</span>
<span class="s1">void rd_kafka_topic_partition_destroy(rd_kafka_topic_partition_t *rktpar);</span>
<span class="s1">void rd_kafka_topic_partition_set_leader_epoch(rd_kafka_topic_partition_t *rktpar, int32_t leader_epoch);</span>
<span class="s1">int32_t rd_kafka_topic_partition_get_leader_epoch(const rd_kafka_topic_partition_t *rktpar);</span>
<span class="s1">typedef struct rd_kafka_topic_partition_list_s {</span>
<span class="s1">  int cnt;</span>
<span class="s1">  int size;</span>
<span class="s1">  rd_kafka_topic_partition_t *elems;</span>
<span class="s1">} rd_kafka_topic_partition_list_t;</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_new(int size);</span>
<span class="s1">void rd_kafka_topic_partition_list_destroy(rd_kafka_topic_partition_list_t *rkparlist);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_add(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">void rd_kafka_topic_partition_list_add_range(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t start, int32_t stop);</span>
<span class="s1">int rd_kafka_topic_partition_list_del(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">int rd_kafka_topic_partition_list_del_by_idx(rd_kafka_topic_partition_list_t *rktparlist, int idx);</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_copy(const rd_kafka_topic_partition_list_t *src);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_topic_partition_list_set_offset(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition, int64_t offset);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_find(const rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">void rd_kafka_topic_partition_list_sort(rd_kafka_topic_partition_list_t *rktparlist, int (*cmp)(const void *a, const void *b, void *cmp_opaque), void *cmp_opaque);</span>
<span class="s1">typedef enum rd_kafka_vtype_t {</span>
<span class="s1">  RD_KAFKA_VTYPE_END,</span>
<span class="s1">  RD_KAFKA_VTYPE_TOPIC,</span>
<span class="s1">  RD_KAFKA_VTYPE_RKT,</span>
<span class="s1">  RD_KAFKA_VTYPE_PARTITION,</span>
<span class="s1">  RD_KAFKA_VTYPE_VALUE,</span>
<span class="s1">  RD_KAFKA_VTYPE_KEY,</span>
<span class="s1">  RD_KAFKA_VTYPE_OPAQUE,</span>
<span class="s1">  RD_KAFKA_VTYPE_MSGFLAGS,</span>
<span class="s1">  RD_KAFKA_VTYPE_TIMESTAMP,</span>
<span class="s1">  RD_KAFKA_VTYPE_HEADER,</span>
<span class="s1">  RD_KAFKA_VTYPE_HEADERS,</span>
<span class="s1">} rd_kafka_vtype_t;</span>
<span class="s1">typedef struct rd_kafka_vu_s {</span>
<span class="s1">  rd_kafka_vtype_t vtype;</span>
<span class="s1">  union {</span>
<span class="s1">    char *cstr;</span>
<span class="s1">    rd_kafka_topic_t *rkt;</span>
<span class="s1">    int i;</span>
<span class="s1">    int32_t i32;</span>
<span class="s1">    int64_t i64;</span>
<span class="s1">    struct {</span>
<span class="s1">      void *ptr;</span>
<span class="s1">      size_t size;</span>
<span class="s1">    } mem;</span>
<span class="s1">    struct {</span>
<span class="s1">      char *name;</span>
<span class="s1">      void *val;</span>
<span class="s1">      ssize_t size;</span>
<span class="s1">    } header;</span>
<span class="s1">    rd_kafka_headers_t *headers;</span>
<span class="s1">    void *ptr;</span>
<span class="s1">    char _pad[64];</span>
<span class="s1">  } u;</span>
<span class="s1">} rd_kafka_vu_t;</span>
<span class="s1">rd_kafka_headers_t *rd_kafka_headers_new(size_t initial_count);</span>
<span class="s1">void rd_kafka_headers_destroy(rd_kafka_headers_t *hdrs);</span>
<span class="s1">rd_kafka_headers_t *rd_kafka_headers_copy(const rd_kafka_headers_t *src);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_add(rd_kafka_headers_t *hdrs, const char *name, ssize_t name_size, const void *value, ssize_t value_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_remove(rd_kafka_headers_t *hdrs, const char *name);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get_last(const rd_kafka_headers_t *hdrs, const char *name, const void **valuep, size_t *sizep);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get(const rd_kafka_headers_t *hdrs, size_t idx, const char *name, const void **valuep, size_t *sizep);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get_all(const rd_kafka_headers_t *hdrs, size_t idx, const char **namep, const void **valuep, size_t *sizep);</span>
<span class="s1">typedef struct rd_kafka_message_s {</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  rd_kafka_topic_t *rkt;</span>
<span class="s1">  int32_t partition;</span>
<span class="s1">  void *payload;</span>
<span class="s1">  size_t len;</span>
<span class="s1">  void *key;</span>
<span class="s1">  size_t key_len;</span>
<span class="s1">  int64_t offset;</span>
<span class="s1">  void *_private;</span>
<span class="s1">} rd_kafka_message_t;</span>
<span class="s1">void rd_kafka_message_destroy(rd_kafka_message_t *rkmessage);</span>
<span class="s1">const char *rd_kafka_message_errstr(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">const char *rd_kafka_message_produce_errstr(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">int64_t rd_kafka_message_timestamp(const rd_kafka_message_t *rkmessage, rd_kafka_timestamp_type_t *tstype);</span>
<span class="s1">int64_t rd_kafka_message_latency(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">int32_t rd_kafka_message_broker_id(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_message_headers(const rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_message_detach_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);</span>
<span class="s1">void rd_kafka_message_set_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t *hdrs);</span>
<span class="s1">size_t rd_kafka_header_cnt(const rd_kafka_headers_t *hdrs);</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_NOT_PERSISTED = 0,</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_POSSIBLY_PERSISTED = 1,</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_PERSISTED = 2,</span>
<span class="s1">} rd_kafka_msg_status_t;</span>
<span class="s1">rd_kafka_msg_status_t rd_kafka_message_status(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">int32_t rd_kafka_message_leader_epoch(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">const char *rd_kafka_Uuid_base64str(const rd_kafka_Uuid_t *uuid);</span>
<span class="s1">int64_t rd_kafka_Uuid_least_significant_bits(const rd_kafka_Uuid_t *uuid);</span>
<span class="s1">int64_t rd_kafka_Uuid_most_significant_bits(const rd_kafka_Uuid_t *uuid);</span>
<span class="s1">rd_kafka_Uuid_t *rd_kafka_Uuid_new(int64_t most_significant_bits, int64_t least_significant_bits);</span>
<span class="s1">rd_kafka_Uuid_t *rd_kafka_Uuid_copy(const rd_kafka_Uuid_t *uuid);</span>
<span class="s1">void rd_kafka_Uuid_destroy(rd_kafka_Uuid_t *uuid);</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_CONF_UNKNOWN = (- 2),</span>
<span class="s1">  RD_KAFKA_CONF_INVALID = (- 1),</span>
<span class="s1">  RD_KAFKA_CONF_OK = 0,</span>
<span class="s1">} rd_kafka_conf_res_t;</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_new(void);</span>
<span class="s1">void rd_kafka_conf_destroy(rd_kafka_conf_t *conf);</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_dup(const rd_kafka_conf_t *conf);</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_dup_filter(const rd_kafka_conf_t *conf, size_t filter_cnt, const char **filter);</span>
<span class="s1">const rd_kafka_conf_t *rd_kafka_conf(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_set(rd_kafka_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_conf_set_events(rd_kafka_conf_t *conf, int events);</span>
<span class="s1">void rd_kafka_conf_set_background_event_cb(rd_kafka_conf_t *conf, void (*event_cb)(rd_kafka_t *rk, rd_kafka_event_t *rkev, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_dr_cb(rd_kafka_conf_t *conf, void (*dr_cb)(rd_kafka_t *rk, void *payload, size_t len, rd_kafka_resp_err_t err, void *opaque, void *msg_opaque));</span>
<span class="s1">void rd_kafka_conf_set_dr_msg_cb(rd_kafka_conf_t *conf, void (*dr_msg_cb)(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_consume_cb(rd_kafka_conf_t *conf, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_rebalance_cb(rd_kafka_conf_t *conf, void (*rebalance_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *partitions, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_offset_commit_cb(rd_kafka_conf_t *conf, void (*offset_commit_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_error_cb(rd_kafka_conf_t *conf, void (*error_cb)(rd_kafka_t *rk, int err, const char *reason, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_throttle_cb(rd_kafka_conf_t *conf, void (*throttle_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int throttle_time_ms, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_log_cb(rd_kafka_conf_t *conf, void (*log_cb)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));</span>
<span class="s1">void rd_kafka_conf_set_stats_cb(rd_kafka_conf_t *conf, int (*stats_cb)(rd_kafka_t *rk, char *json, size_t json_len, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_oauthbearer_token_refresh_cb(rd_kafka_conf_t *conf, void (*oauthbearer_token_refresh_cb)(rd_kafka_t *rk, const char *oauthbearer_config, void *opaque));</span>
<span class="s1">void rd_kafka_conf_enable_sasl_queue(rd_kafka_conf_t *conf, int enable);</span>
<span class="s1">void rd_kafka_conf_set_socket_cb(rd_kafka_conf_t *conf, int (*socket_cb)(int domain, int type, int protocol, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_connect_cb(rd_kafka_conf_t *conf, int (*connect_cb)(int sockfd, const struct sockaddr *addr, int addrlen, const char *id, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_closesocket_cb(rd_kafka_conf_t *conf, int (*closesocket_cb)(int sockfd, void *opaque));</span>
<span class="s1">struct addrinfo;</span>
<span class="s1">void rd_kafka_conf_set_resolve_cb(rd_kafka_conf_t *conf, int (*resolve_cb)(const char *node, const char *service, const struct addrinfo *hints, struct addrinfo **res, void *opaque));</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert_verify_cb(rd_kafka_conf_t *conf, int (*ssl_cert_verify_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int *x509_error, int depth, const char *buf, size_t size, char *errstr, size_t errstr_size, void *opaque));</span>
<span class="s1">typedef enum rd_kafka_cert_type_t {</span>
<span class="s1">  RD_KAFKA_CERT_PUBLIC_KEY,</span>
<span class="s1">  RD_KAFKA_CERT_PRIVATE_KEY,</span>
<span class="s1">  RD_KAFKA_CERT_CA,</span>
<span class="s1">  RD_KAFKA_CERT__CNT,</span>
<span class="s1">} rd_kafka_cert_type_t;</span>
<span class="s1">typedef enum rd_kafka_cert_enc_t {</span>
<span class="s1">  RD_KAFKA_CERT_ENC_PKCS12,</span>
<span class="s1">  RD_KAFKA_CERT_ENC_DER,</span>
<span class="s1">  RD_KAFKA_CERT_ENC_PEM,</span>
<span class="s1">  RD_KAFKA_CERT_ENC__CNT,</span>
<span class="s1">} rd_kafka_cert_enc_t;</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert(rd_kafka_conf_t *conf, rd_kafka_cert_type_t cert_type, rd_kafka_cert_enc_t cert_enc, const void *buffer, size_t size, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_conf_set_engine_callback_data(rd_kafka_conf_t *conf, void *callback_data);</span>
<span class="s1">void rd_kafka_conf_set_opaque(rd_kafka_conf_t *conf, void *opaque);</span>
<span class="s1">void *rd_kafka_opaque(const rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_conf_set_default_topic_conf(rd_kafka_conf_t *conf, rd_kafka_topic_conf_t *tconf);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_conf_get_default_topic_conf(rd_kafka_conf_t *conf);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_get(const rd_kafka_conf_t *conf, const char *name, char *dest, size_t *dest_size);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_topic_conf_get(const rd_kafka_topic_conf_t *conf, const char *name, char *dest, size_t *dest_size);</span>
<span class="s1">const char **rd_kafka_conf_dump(rd_kafka_conf_t *conf, size_t *cntp);</span>
<span class="s1">const char **rd_kafka_topic_conf_dump(rd_kafka_topic_conf_t *conf, size_t *cntp);</span>
<span class="s1">void rd_kafka_conf_dump_free(const char **arr, size_t cnt);</span>
<span class="s1">void rd_kafka_conf_properties_show(FILE *fp);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_topic_conf_new(void);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_topic_conf_dup(const rd_kafka_topic_conf_t *conf);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_default_topic_conf_dup(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_topic_conf_destroy(rd_kafka_topic_conf_t *topic_conf);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_topic_conf_set(rd_kafka_topic_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_topic_conf_set_opaque(rd_kafka_topic_conf_t *conf, void *rkt_opaque);</span>
<span class="s1">void rd_kafka_topic_conf_set_partitioner_cb(rd_kafka_topic_conf_t *topic_conf, int32_t (*partitioner)(const rd_kafka_topic_t *rkt, const void *keydata, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque));</span>
<span class="s1">void rd_kafka_topic_conf_set_msg_order_cmp(rd_kafka_topic_conf_t *topic_conf, int (*msg_order_cmp)(const rd_kafka_message_t *a, const rd_kafka_message_t *b));</span>
<span class="s1">int rd_kafka_topic_partition_available(const rd_kafka_topic_t *rkt, int32_t partition);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_consistent(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_consistent_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_murmur2(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_murmur2_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_fnv1a(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_fnv1a_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">rd_kafka_t *rd_kafka_new(rd_kafka_type_t type, rd_kafka_conf_t *conf, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_destroy(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_destroy_flags(rd_kafka_t *rk, int flags);</span>
<span class="s1">const char *rd_kafka_name(const rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_type_t rd_kafka_type(const rd_kafka_t *rk);</span>
<span class="s1">char *rd_kafka_memberid(const rd_kafka_t *rk);</span>
<span class="s1">char *rd_kafka_clusterid(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">int32_t rd_kafka_controllerid(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_topic_t *rd_kafka_topic_new(rd_kafka_t *rk, const char *topic, rd_kafka_topic_conf_t *conf);</span>
<span class="s1">void rd_kafka_topic_destroy(rd_kafka_topic_t *rkt);</span>
<span class="s1">const char *rd_kafka_topic_name(const rd_kafka_topic_t *rkt);</span>
<span class="s1">void *rd_kafka_topic_opaque(const rd_kafka_topic_t *rkt);</span>
<span class="s1">int rd_kafka_poll(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">void rd_kafka_yield(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_pause_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_resume_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_query_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_get_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offsets_for_times(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets, int timeout_ms);</span>
<span class="s1">void *rd_kafka_mem_calloc(rd_kafka_t *rk, size_t num, size_t size);</span>
<span class="s1">void *rd_kafka_mem_malloc(rd_kafka_t *rk, size_t size);</span>
<span class="s1">void rd_kafka_mem_free(rd_kafka_t *rk, void *ptr);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_new(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_queue_destroy(rd_kafka_queue_t *rkqu);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_main(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_sasl(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_sasl_background_callbacks_enable(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_sasl_set_credentials(rd_kafka_t *rk, const char *username, const char *password);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_consumer(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_partition(rd_kafka_t *rk, const char *topic, int32_t partition);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_background(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_queue_forward(rd_kafka_queue_t *src, rd_kafka_queue_t *dst);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_set_log_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu);</span>
<span class="s1">size_t rd_kafka_queue_length(rd_kafka_queue_t *rkqu);</span>
<span class="s1">void rd_kafka_queue_io_event_enable(rd_kafka_queue_t *rkqu, int fd, const void *payload, size_t size);</span>
<span class="s1">void rd_kafka_queue_cb_event_enable(rd_kafka_queue_t *rkqu, void (*event_cb)(rd_kafka_t *rk, void *qev_opaque), void *qev_opaque);</span>
<span class="s1">void rd_kafka_queue_yield(rd_kafka_queue_t *rkqu);</span>
<span class="s1">int rd_kafka_consume_start(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);</span>
<span class="s1">int rd_kafka_consume_start_queue(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, rd_kafka_queue_t *rkqu);</span>
<span class="s1">int rd_kafka_consume_stop(rd_kafka_topic_t *rkt, int32_t partition);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_seek(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, int timeout_ms);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_seek_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consume(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms);</span>
<span class="s1">ssize_t rd_kafka_consume_batch(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);</span>
<span class="s1">int rd_kafka_consume_callback(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consume_queue(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">ssize_t rd_kafka_consume_batch_queue(rd_kafka_queue_t *rkqu, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);</span>
<span class="s1">int rd_kafka_consume_callback_queue(rd_kafka_queue_t *rkqu, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offset_store(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offsets_store(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_offset_store_message(rd_kafka_message_t *rkmessage);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_subscribe(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *topics);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_unsubscribe(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_subscription(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **topics);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consumer_poll(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_consumer_close(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_consumer_close_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu);</span>
<span class="s1">int rd_kafka_consumer_closed(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_incremental_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_incremental_unassign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">const char *rd_kafka_rebalance_protocol(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_assignment(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **partitions);</span>
<span class="s1">int rd_kafka_assignment_lost(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, int async);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit_message(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, int async);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit_queue(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_queue_t *rkqu, void (*cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *commit_opaque), void *commit_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_committed(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_position(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata_new(const char *group_id);</span>
<span class="s1">rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata_new_with_genid(const char *group_id, int32_t generation_id, const char *member_id, const char *group_instance_id);</span>
<span class="s1">const char *rd_kafka_consumer_group_metadata_member_id(const rd_kafka_consumer_group_metadata_t *group_metadata);</span>
<span class="s1">void rd_kafka_consumer_group_metadata_destroy(rd_kafka_consumer_group_metadata_t *);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_consumer_group_metadata_write(const rd_kafka_consumer_group_metadata_t *cgmd, void **bufferp, size_t *sizep);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_consumer_group_metadata_read(rd_kafka_consumer_group_metadata_t **cgmdp, const void *buffer, size_t size);</span>
<span class="s1">int rd_kafka_produce(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, void *payload, size_t len, const void *key, size_t keylen, void *msg_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_producev(rd_kafka_t *rk, ...);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_produceva(rd_kafka_t *rk, const rd_kafka_vu_t *vus, size_t cnt);</span>
<span class="s1">int rd_kafka_produce_batch(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, rd_kafka_message_t *rkmessages, int message_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_flush(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_purge(rd_kafka_t *rk, int purge_flags);</span>
<span class="s1">typedef struct rd_kafka_metadata_broker {</span>
<span class="s1">  int32_t id;</span>
<span class="s1">  char *host;</span>
<span class="s1">  int port;</span>
<span class="s1">} rd_kafka_metadata_broker_t;</span>
<span class="s1">typedef struct rd_kafka_metadata_partition {</span>
<span class="s1">  int32_t id;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  int32_t leader;</span>
<span class="s1">  int replica_cnt;</span>
<span class="s1">  int32_t *replicas;</span>
<span class="s1">  int isr_cnt;</span>
<span class="s1">  int32_t *isrs;</span>
<span class="s1">} rd_kafka_metadata_partition_t;</span>
<span class="s1">typedef struct rd_kafka_metadata_topic {</span>
<span class="s1">  char *topic;</span>
<span class="s1">  int partition_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_partition *partitions;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">} rd_kafka_metadata_topic_t;</span>
<span class="s1">typedef struct rd_kafka_metadata {</span>
<span class="s1">  int broker_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_broker *brokers;</span>
<span class="s1">  int topic_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_topic *topics;</span>
<span class="s1">  int32_t orig_broker_id;</span>
<span class="s1">  char *orig_broker_name;</span>
<span class="s1">} rd_kafka_metadata_t;</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_metadata(rd_kafka_t *rk, int all_topics, rd_kafka_topic_t *only_rkt, const struct rd_kafka_metadata **metadatap, int timeout_ms);</span>
<span class="s1">void rd_kafka_metadata_destroy(const struct rd_kafka_metadata *metadata);</span>
<span class="s1">typedef struct rd_kafka_Node_s rd_kafka_Node_t;</span>
<span class="s1">int rd_kafka_Node_id(const rd_kafka_Node_t *node);</span>
<span class="s1">const char *rd_kafka_Node_host(const rd_kafka_Node_t *node);</span>
<span class="s1">uint16_t rd_kafka_Node_port(const rd_kafka_Node_t *node);</span>
<span class="s1">const char *rd_kafka_Node_rack(const rd_kafka_Node_t *node);</span>
<span class="s1">struct rd_kafka_group_member_info {</span>
<span class="s1">  char *member_id;</span>
<span class="s1">  char *client_id;</span>
<span class="s1">  char *client_host;</span>
<span class="s1">  void *member_metadata;</span>
<span class="s1">  int member_metadata_size;</span>
<span class="s1">  void *member_assignment;</span>
<span class="s1">  int member_assignment_size;</span>
<span class="s1">};</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_CONSUMER_GROUP_STATE_UNKNOWN = 0,</span>
<span class="s1">  RD_KAFKA_CONSUMER_GROUP_STATE_PREPARING_REBALANCE = 1,</span>
<span class="s1">  RD_KAFKA_CONSUMER_GROUP_STATE_COMPLETING_REBALANCE = 2,</span>
<span class="s1">  RD_KAFKA_CONSUMER_GROUP_STATE_STABLE = 3,</span>
<span class="s1">  RD_KAFKA_CONSUMER_GROUP_STATE_DEAD = 4,</span>
<span class="s1">  RD_KAFKA_CONSUMER_GROUP_STATE_EMPTY = 5,</span>
<span class="s1">  RD_KAFKA_CONSUMER_GROUP_STATE__CNT,</span>
<span class="s1">} rd_kafka_consumer_group_state_t;</span>
<span class="s1">struct rd_kafka_group_info {</span>
<span class="s1">  struct rd_kafka_metadata_broker broker;</span>
<span class="s1">  char *group;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  char *state;</span>
<span class="s1">  char *protocol_type;</span>
<span class="s1">  char *protocol;</span>
<span class="s1">  struct rd_kafka_group_member_info *members;</span>
<span class="s1">  int member_cnt;</span>
<span class="s1">};</span>
<span class="s1">struct rd_kafka_group_list {</span>
<span class="s1">  struct rd_kafka_group_info *groups;</span>
<span class="s1">  int group_cnt;</span>
<span class="s1">};</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_list_groups(rd_kafka_t *rk, const char *group, const struct rd_kafka_group_list **grplistp, int timeout_ms);</span>
<span class="s1">const char *rd_kafka_consumer_group_state_name(rd_kafka_consumer_group_state_t state);</span>
<span class="s1">rd_kafka_consumer_group_state_t rd_kafka_consumer_group_state_code(const char *name);</span>
<span class="s1">void rd_kafka_group_list_destroy(const struct rd_kafka_group_list *grplist);</span>
<span class="s1">int rd_kafka_brokers_add(rd_kafka_t *rk, const char *brokerlist);</span>
<span class="s1">void rd_kafka_set_logger(rd_kafka_t *rk, void (*func)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));</span>
<span class="s1">void rd_kafka_set_log_level(rd_kafka_t *rk, int level);</span>
<span class="s1">void rd_kafka_log_print(const rd_kafka_t *rk, int level, const char *fac, const char *buf);</span>
<span class="s1">void rd_kafka_log_syslog(const rd_kafka_t *rk, int level, const char *fac, const char *buf);</span>
<span class="s1">int rd_kafka_outq_len(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_dump(FILE *fp, rd_kafka_t *rk);</span>
<span class="s1">int rd_kafka_thread_cnt(void);</span>
<span class="s1">typedef enum rd_kafka_thread_type_t {</span>
<span class="s1">  RD_KAFKA_THREAD_MAIN,</span>
<span class="s1">  RD_KAFKA_THREAD_BACKGROUND,</span>
<span class="s1">  RD_KAFKA_THREAD_BROKER,</span>
<span class="s1">} rd_kafka_thread_type_t;</span>
<span class="s1">int rd_kafka_wait_destroyed(int timeout_ms);</span>
<span class="s1">int rd_kafka_unittest(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_poll_set_consumer(rd_kafka_t *rk);</span>
<span class="s1">typedef int rd_kafka_event_type_t;</span>
<span class="s1">rd_kafka_event_type_t rd_kafka_event_type(const rd_kafka_event_t *rkev);</span>
<span class="s1">const char *rd_kafka_event_name(const rd_kafka_event_t *rkev);</span>
<span class="s1">void rd_kafka_event_destroy(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_message_t *rd_kafka_event_message_next(rd_kafka_event_t *rkev);</span>
<span class="s1">size_t rd_kafka_event_message_array(rd_kafka_event_t *rkev, const rd_kafka_message_t **rkmessages, size_t size);</span>
<span class="s1">size_t rd_kafka_event_message_count(rd_kafka_event_t *rkev);</span>
<span class="s1">const char *rd_kafka_event_config_string(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_event_error(rd_kafka_event_t *rkev);</span>
<span class="s1">const char *rd_kafka_event_error_string(rd_kafka_event_t *rkev);</span>
<span class="s1">int rd_kafka_event_error_is_fatal(rd_kafka_event_t *rkev);</span>
<span class="s1">void *rd_kafka_event_opaque(rd_kafka_event_t *rkev);</span>
<span class="s1">int rd_kafka_event_log(rd_kafka_event_t *rkev, const char **fac, const char **str, int *level);</span>
<span class="s1">int rd_kafka_event_debug_contexts(rd_kafka_event_t *rkev, char *dst, size_t dstsize);</span>
<span class="s1">const char *rd_kafka_event_stats(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_event_topic_partition_list(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_event_topic_partition(rd_kafka_event_t *rkev);</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_CreateTopics_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DeleteTopics_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_CreateAcls_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DescribeAcls_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DeleteAcls_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_CreatePartitions_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_AlterConfigs_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_IncrementalAlterConfigs_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DescribeConfigs_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DeleteRecords_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_ListConsumerGroups_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DescribeConsumerGroups_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DeleteGroups_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DeleteConsumerGroupOffsets_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_AlterConsumerGroupOffsets_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_ListConsumerGroupOffsets_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DescribeTopics_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DescribeCluster_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DescribeUserScramCredentials_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_AlterUserScramCredentials_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_ListOffsets_result_t;</span>
<span class="s1">const rd_kafka_CreateTopics_result_t *rd_kafka_event_CreateTopics_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DeleteTopics_result_t *rd_kafka_event_DeleteTopics_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_CreatePartitions_result_t *rd_kafka_event_CreatePartitions_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_AlterConfigs_result_t *rd_kafka_event_AlterConfigs_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_IncrementalAlterConfigs_result_t *rd_kafka_event_IncrementalAlterConfigs_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DescribeConfigs_result_t *rd_kafka_event_DescribeConfigs_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DeleteRecords_result_t *rd_kafka_event_DeleteRecords_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_ListConsumerGroups_result_t *rd_kafka_event_ListConsumerGroups_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DescribeConsumerGroups_result_t *rd_kafka_event_DescribeConsumerGroups_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DescribeTopics_result_t *rd_kafka_event_DescribeTopics_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DescribeCluster_result_t *rd_kafka_event_DescribeCluster_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DeleteGroups_result_t *rd_kafka_event_DeleteGroups_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DeleteConsumerGroupOffsets_result_t *rd_kafka_event_DeleteConsumerGroupOffsets_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_CreateAcls_result_t *rd_kafka_event_CreateAcls_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DescribeAcls_result_t *rd_kafka_event_DescribeAcls_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DeleteAcls_result_t *rd_kafka_event_DeleteAcls_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_ListConsumerGroupOffsets_result_t *rd_kafka_event_ListConsumerGroupOffsets_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_AlterConsumerGroupOffsets_result_t *rd_kafka_event_AlterConsumerGroupOffsets_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_ListOffsets_result_t *rd_kafka_event_ListOffsets_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DescribeUserScramCredentials_result_t *rd_kafka_event_DescribeUserScramCredentials_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_AlterUserScramCredentials_result_t *rd_kafka_event_AlterUserScramCredentials_result(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_event_t *rd_kafka_queue_poll(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">int rd_kafka_queue_poll_callback(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_plugin_f_conf_init_t)(rd_kafka_conf_t *conf, void **plug_opaquep, char *errstr, size_t errstr_size);</span>
<span class="s1">typedef rd_kafka_conf_res_t (rd_kafka_interceptor_f_on_conf_set_t)(rd_kafka_conf_t *conf, const char *name, const char *val, char *errstr, size_t errstr_size, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_dup_t)(rd_kafka_conf_t *new_conf, const rd_kafka_conf_t *old_conf, size_t filter_cnt, const char **filter, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_destroy_t)(void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_new_t)(rd_kafka_t *rk, const rd_kafka_conf_t *conf, void *ic_opaque, char *errstr, size_t errstr_size);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_destroy_t)(rd_kafka_t *rk, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_send_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_acknowledgement_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_consume_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_commit_t)(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_resp_err_t err, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_request_sent_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_response_received_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, int64_t rtt, rd_kafka_resp_err_t err, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_start_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_exit_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_broker_state_change_t)(rd_kafka_t *rk, int32_t broker_id, const char *secproto, const char *name, int port, const char *state, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_set(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_set_t *on_conf_set, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_dup(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_dup_t *on_conf_dup, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_destroy(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_destroy_t *on_conf_destroy, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_new(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_new_t *on_new, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_destroy(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_destroy_t *on_destroy, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_send(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_send_t *on_send, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_acknowledgement(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_acknowledgement_t *on_acknowledgement, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_consume(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_consume_t *on_consume, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_commit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_commit_t *on_commit, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_request_sent(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_request_sent_t *on_request_sent, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_response_received(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_response_received_t *on_response_received, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_start(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_start_t *on_thread_start, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_exit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_exit_t *on_thread_exit, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_broker_state_change(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_broker_state_change_t *on_broker_state_change, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_topic_result_error(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">const char *rd_kafka_topic_result_error_string(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">const char *rd_kafka_topic_result_name(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">const rd_kafka_error_t *rd_kafka_group_result_error(const rd_kafka_group_result_t *groupres);</span>
<span class="s1">const char *rd_kafka_group_result_name(const rd_kafka_group_result_t *groupres);</span>
<span class="s1">const rd_kafka_topic_partition_list_t *rd_kafka_group_result_partitions(const rd_kafka_group_result_t *groupres);</span>
<span class="s1">typedef enum rd_kafka_admin_op_t {</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_ANY = 0,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_CREATETOPICS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DELETETOPICS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_CREATEPARTITIONS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_ALTERCONFIGS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DESCRIBECONFIGS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DELETERECORDS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DELETEGROUPS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DELETECONSUMERGROUPOFFSETS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_CREATEACLS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DESCRIBEACLS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DELETEACLS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_LISTCONSUMERGROUPS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DESCRIBECONSUMERGROUPS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_LISTCONSUMERGROUPOFFSETS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_ALTERCONSUMERGROUPOFFSETS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_INCREMENTALALTERCONFIGS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DESCRIBEUSERSCRAMCREDENTIALS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_ALTERUSERSCRAMCREDENTIALS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DESCRIBETOPICS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DESCRIBECLUSTER,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_LISTOFFSETS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP__CNT,</span>
<span class="s1">} rd_kafka_admin_op_t;</span>
<span class="s1">typedef struct rd_kafka_AdminOptions_s rd_kafka_AdminOptions_t;</span>
<span class="s1">typedef enum rd_kafka_IsolationLevel_t {</span>
<span class="s1">  RD_KAFKA_ISOLATION_LEVEL_READ_UNCOMMITTED = 0,</span>
<span class="s1">  RD_KAFKA_ISOLATION_LEVEL_READ_COMMITTED = 1,</span>
<span class="s1">} rd_kafka_IsolationLevel_t;</span>
<span class="s1">rd_kafka_AdminOptions_t *rd_kafka_AdminOptions_new(rd_kafka_t *rk, rd_kafka_admin_op_t for_api);</span>
<span class="s1">void rd_kafka_AdminOptions_destroy(rd_kafka_AdminOptions_t *options);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_request_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_operation_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_validate_only(rd_kafka_AdminOptions_t *options, int true_or_false, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_broker(rd_kafka_AdminOptions_t *options, int32_t broker_id, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_AdminOptions_set_require_stable_offsets(rd_kafka_AdminOptions_t *options, int true_or_false);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_AdminOptions_set_include_authorized_operations(rd_kafka_AdminOptions_t *options, int true_or_false);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_AdminOptions_set_match_consumer_group_states(rd_kafka_AdminOptions_t *options, const rd_kafka_consumer_group_state_t *consumer_group_states, size_t consumer_group_states_cnt);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_AdminOptions_set_isolation_level(rd_kafka_AdminOptions_t *options, rd_kafka_IsolationLevel_t value);</span>
<span class="s1">void rd_kafka_AdminOptions_set_opaque(rd_kafka_AdminOptions_t *options, void *ev_opaque);</span>
<span class="s1">typedef enum rd_kafka_AclOperation_t {</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_UNKNOWN = 0,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_ANY = 1,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_ALL = 2,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_READ = 3,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_WRITE = 4,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_CREATE = 5,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_DELETE = 6,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_ALTER = 7,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_DESCRIBE = 8,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_CLUSTER_ACTION = 9,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_DESCRIBE_CONFIGS = 10,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_ALTER_CONFIGS = 11,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_IDEMPOTENT_WRITE = 12,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION__CNT,</span>
<span class="s1">} rd_kafka_AclOperation_t;</span>
<span class="s1">typedef struct rd_kafka_NewTopic_s rd_kafka_NewTopic_t;</span>
<span class="s1">rd_kafka_NewTopic_t *rd_kafka_NewTopic_new(const char *topic, int num_partitions, int replication_factor, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_NewTopic_destroy(rd_kafka_NewTopic_t *new_topic);</span>
<span class="s1">void rd_kafka_NewTopic_destroy_array(rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewTopic_set_replica_assignment(rd_kafka_NewTopic_t *new_topic, int32_t partition, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewTopic_set_config(rd_kafka_NewTopic_t *new_topic, const char *name, const char *value);</span>
<span class="s1">void rd_kafka_CreateTopics(rd_kafka_t *rk, rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_CreateTopics_result_topics(const rd_kafka_CreateTopics_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_DeleteTopic_s rd_kafka_DeleteTopic_t;</span>
<span class="s1">rd_kafka_DeleteTopic_t *rd_kafka_DeleteTopic_new(const char *topic);</span>
<span class="s1">void rd_kafka_DeleteTopic_destroy(rd_kafka_DeleteTopic_t *del_topic);</span>
<span class="s1">void rd_kafka_DeleteTopic_destroy_array(rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt);</span>
<span class="s1">void rd_kafka_DeleteTopics(rd_kafka_t *rk, rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_DeleteTopics_result_topics(const rd_kafka_DeleteTopics_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_NewPartitions_s rd_kafka_NewPartitions_t;</span>
<span class="s1">rd_kafka_NewPartitions_t *rd_kafka_NewPartitions_new(const char *topic, size_t new_total_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_NewPartitions_destroy(rd_kafka_NewPartitions_t *new_parts);</span>
<span class="s1">void rd_kafka_NewPartitions_destroy_array(rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewPartitions_set_replica_assignment(rd_kafka_NewPartitions_t *new_parts, int32_t new_partition_idx, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_CreatePartitions(rd_kafka_t *rk, rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_CreatePartitions_result_topics(const rd_kafka_CreatePartitions_result_t *result, size_t *cntp);</span>
<span class="s1">typedef enum rd_kafka_ConfigSource_t {</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_UNKNOWN_CONFIG = 0,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_TOPIC_CONFIG = 1,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_BROKER_CONFIG = 2,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_DEFAULT_BROKER_CONFIG = 3,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_STATIC_BROKER_CONFIG = 4,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DEFAULT_CONFIG = 5,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE__CNT,</span>
<span class="s1">} rd_kafka_ConfigSource_t;</span>
<span class="s1">const char *rd_kafka_ConfigSource_name(rd_kafka_ConfigSource_t confsource);</span>
<span class="s1">typedef struct rd_kafka_ConfigEntry_s rd_kafka_ConfigEntry_t;</span>
<span class="s1">const char *rd_kafka_ConfigEntry_name(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">const char *rd_kafka_ConfigEntry_value(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">rd_kafka_ConfigSource_t rd_kafka_ConfigEntry_source(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_read_only(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_default(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_sensitive(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_synonym(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">const rd_kafka_ConfigEntry_t **rd_kafka_ConfigEntry_synonyms(const rd_kafka_ConfigEntry_t *entry, size_t *cntp);</span>
<span class="s1">typedef enum rd_kafka_ResourceType_t {</span>
<span class="s1">  RD_KAFKA_RESOURCE_UNKNOWN = 0,</span>
<span class="s1">  RD_KAFKA_RESOURCE_ANY = 1,</span>
<span class="s1">  RD_KAFKA_RESOURCE_TOPIC = 2,</span>
<span class="s1">  RD_KAFKA_RESOURCE_GROUP = 3,</span>
<span class="s1">  RD_KAFKA_RESOURCE_BROKER = 4,</span>
<span class="s1">  RD_KAFKA_RESOURCE__CNT,</span>
<span class="s1">} rd_kafka_ResourceType_t;</span>
<span class="s1">typedef enum rd_kafka_ResourcePatternType_t {</span>
<span class="s1">  RD_KAFKA_RESOURCE_PATTERN_UNKNOWN = 0,</span>
<span class="s1">  RD_KAFKA_RESOURCE_PATTERN_ANY = 1,</span>
<span class="s1">  RD_KAFKA_RESOURCE_PATTERN_MATCH = 2,</span>
<span class="s1">  RD_KAFKA_RESOURCE_PATTERN_LITERAL = 3,</span>
<span class="s1">  RD_KAFKA_RESOURCE_PATTERN_PREFIXED = 4,</span>
<span class="s1">  RD_KAFKA_RESOURCE_PATTERN_TYPE__CNT,</span>
<span class="s1">} rd_kafka_ResourcePatternType_t;</span>
<span class="s1">typedef enum rd_kafka_AlterConfigOpType_t {</span>
<span class="s1">  RD_KAFKA_ALTER_CONFIG_OP_TYPE_SET = 0,</span>
<span class="s1">  RD_KAFKA_ALTER_CONFIG_OP_TYPE_DELETE = 1,</span>
<span class="s1">  RD_KAFKA_ALTER_CONFIG_OP_TYPE_APPEND = 2,</span>
<span class="s1">  RD_KAFKA_ALTER_CONFIG_OP_TYPE_SUBTRACT = 3,</span>
<span class="s1">  RD_KAFKA_ALTER_CONFIG_OP_TYPE__CNT,</span>
<span class="s1">} rd_kafka_AlterConfigOpType_t;</span>
<span class="s1">const char *rd_kafka_ResourcePatternType_name(rd_kafka_ResourcePatternType_t resource_pattern_type);</span>
<span class="s1">const char *rd_kafka_ResourceType_name(rd_kafka_ResourceType_t restype);</span>
<span class="s1">typedef struct rd_kafka_ConfigResource_s rd_kafka_ConfigResource_t;</span>
<span class="s1">rd_kafka_ConfigResource_t *rd_kafka_ConfigResource_new(rd_kafka_ResourceType_t restype, const char *resname);</span>
<span class="s1">void rd_kafka_ConfigResource_destroy(rd_kafka_ConfigResource_t *config);</span>
<span class="s1">void rd_kafka_ConfigResource_destroy_array(rd_kafka_ConfigResource_t **config, size_t config_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_ConfigResource_set_config(rd_kafka_ConfigResource_t *config, const char *name, const char *value);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_ConfigResource_add_incremental_config(rd_kafka_ConfigResource_t *config, const char *name, rd_kafka_AlterConfigOpType_t op_type, const char *value);</span>
<span class="s1">const rd_kafka_ConfigEntry_t **rd_kafka_ConfigResource_configs(const rd_kafka_ConfigResource_t *config, size_t *cntp);</span>
<span class="s1">rd_kafka_ResourceType_t rd_kafka_ConfigResource_type(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">const char *rd_kafka_ConfigResource_name(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_ConfigResource_error(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">const char *rd_kafka_ConfigResource_error_string(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">void rd_kafka_AlterConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_ConfigResource_t **rd_kafka_AlterConfigs_result_resources(const rd_kafka_AlterConfigs_result_t *result, size_t *cntp);</span>
<span class="s1">void rd_kafka_IncrementalAlterConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_ConfigResource_t **rd_kafka_IncrementalAlterConfigs_result_resources(const rd_kafka_IncrementalAlterConfigs_result_t *result, size_t *cntp);</span>
<span class="s1">void rd_kafka_DescribeConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_ConfigResource_t **rd_kafka_DescribeConfigs_result_resources(const rd_kafka_DescribeConfigs_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_DeleteRecords_s rd_kafka_DeleteRecords_t;</span>
<span class="s1">rd_kafka_DeleteRecords_t *rd_kafka_DeleteRecords_new(const rd_kafka_topic_partition_list_t *before_offsets);</span>
<span class="s1">void rd_kafka_DeleteRecords_destroy(rd_kafka_DeleteRecords_t *del_records);</span>
<span class="s1">void rd_kafka_DeleteRecords_destroy_array(rd_kafka_DeleteRecords_t **del_records, size_t del_record_cnt);</span>
<span class="s1">void rd_kafka_DeleteRecords(rd_kafka_t *rk, rd_kafka_DeleteRecords_t **del_records, size_t del_record_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_partition_list_t *rd_kafka_DeleteRecords_result_offsets(const rd_kafka_DeleteRecords_result_t *result);</span>
<span class="s1">typedef struct rd_kafka_TopicCollection_s rd_kafka_TopicCollection_t;</span>
<span class="s1">typedef struct rd_kafka_TopicPartitionInfo_s rd_kafka_TopicPartitionInfo_t;</span>
<span class="s1">typedef struct rd_kafka_TopicDescription_s rd_kafka_TopicDescription_t;</span>
<span class="s1">rd_kafka_TopicCollection_t *rd_kafka_TopicCollection_of_topic_names(const char **topics, size_t topics_cnt);</span>
<span class="s1">void rd_kafka_TopicCollection_destroy(rd_kafka_TopicCollection_t *topics);</span>
<span class="s1">void rd_kafka_DescribeTopics(rd_kafka_t *rk, const rd_kafka_TopicCollection_t *topics, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_TopicDescription_t **rd_kafka_DescribeTopics_result_topics(const rd_kafka_DescribeTopics_result_t *result, size_t *cntp);</span>
<span class="s1">const rd_kafka_TopicPartitionInfo_t **rd_kafka_TopicDescription_partitions(const rd_kafka_TopicDescription_t *topicdesc, size_t *cntp);</span>
<span class="s1">const int rd_kafka_TopicPartitionInfo_partition(const rd_kafka_TopicPartitionInfo_t *partition);</span>
<span class="s1">const rd_kafka_Node_t *rd_kafka_TopicPartitionInfo_leader(const rd_kafka_TopicPartitionInfo_t *partition);</span>
<span class="s1">const rd_kafka_Node_t **rd_kafka_TopicPartitionInfo_isr(const rd_kafka_TopicPartitionInfo_t *partition, size_t *cntp);</span>
<span class="s1">const rd_kafka_Node_t **rd_kafka_TopicPartitionInfo_replicas(const rd_kafka_TopicPartitionInfo_t *partition, size_t *cntp);</span>
<span class="s1">const rd_kafka_AclOperation_t *rd_kafka_TopicDescription_authorized_operations(const rd_kafka_TopicDescription_t *topicdesc, size_t *cntp);</span>
<span class="s1">const char *rd_kafka_TopicDescription_name(const rd_kafka_TopicDescription_t *topicdesc);</span>
<span class="s1">const rd_kafka_Uuid_t *rd_kafka_TopicDescription_topic_id(const rd_kafka_TopicDescription_t *topicdesc);</span>
<span class="s1">int rd_kafka_TopicDescription_is_internal(const rd_kafka_TopicDescription_t *topicdesc);</span>
<span class="s1">const rd_kafka_error_t *rd_kafka_TopicDescription_error(const rd_kafka_TopicDescription_t *topicdesc);</span>
<span class="s1">void rd_kafka_DescribeCluster(rd_kafka_t *rk, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_Node_t **rd_kafka_DescribeCluster_result_nodes(const rd_kafka_DescribeCluster_result_t *result, size_t *cntp);</span>
<span class="s1">const rd_kafka_AclOperation_t *rd_kafka_DescribeCluster_result_authorized_operations(const rd_kafka_DescribeCluster_result_t *result, size_t *cntp);</span>
<span class="s1">const rd_kafka_Node_t *rd_kafka_DescribeCluster_result_controller(const rd_kafka_DescribeCluster_result_t *result);</span>
<span class="s1">const char *rd_kafka_DescribeCluster_result_cluster_id(const rd_kafka_DescribeCluster_result_t *result);</span>
<span class="s1">typedef struct rd_kafka_ConsumerGroupListing_s rd_kafka_ConsumerGroupListing_t;</span>
<span class="s1">typedef struct rd_kafka_ListConsumerGroupsResult_s rd_kafka_ListConsumerGroupsResult_t;</span>
<span class="s1">void rd_kafka_ListConsumerGroups(rd_kafka_t *rk, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const char *rd_kafka_ConsumerGroupListing_group_id(const rd_kafka_ConsumerGroupListing_t *grplist);</span>
<span class="s1">int rd_kafka_ConsumerGroupListing_is_simple_consumer_group(const rd_kafka_ConsumerGroupListing_t *grplist);</span>
<span class="s1">rd_kafka_consumer_group_state_t rd_kafka_ConsumerGroupListing_state(const rd_kafka_ConsumerGroupListing_t *grplist);</span>
<span class="s1">const rd_kafka_ConsumerGroupListing_t **rd_kafka_ListConsumerGroups_result_valid(const rd_kafka_ListConsumerGroups_result_t *result, size_t *cntp);</span>
<span class="s1">const rd_kafka_error_t **rd_kafka_ListConsumerGroups_result_errors(const rd_kafka_ListConsumerGroups_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_ConsumerGroupDescription_s rd_kafka_ConsumerGroupDescription_t;</span>
<span class="s1">typedef struct rd_kafka_MemberDescription_s rd_kafka_MemberDescription_t;</span>
<span class="s1">typedef struct rd_kafka_MemberAssignment_s rd_kafka_MemberAssignment_t;</span>
<span class="s1">void rd_kafka_DescribeConsumerGroups(rd_kafka_t *rk, const char **groups, size_t groups_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_ConsumerGroupDescription_t **rd_kafka_DescribeConsumerGroups_result_groups(const rd_kafka_DescribeConsumerGroups_result_t *result, size_t *cntp);</span>
<span class="s1">const char *rd_kafka_ConsumerGroupDescription_group_id(const rd_kafka_ConsumerGroupDescription_t *grpdesc);</span>
<span class="s1">const rd_kafka_error_t *rd_kafka_ConsumerGroupDescription_error(const rd_kafka_ConsumerGroupDescription_t *grpdesc);</span>
<span class="s1">int rd_kafka_ConsumerGroupDescription_is_simple_consumer_group(const rd_kafka_ConsumerGroupDescription_t *grpdesc);</span>
<span class="s1">const char *rd_kafka_ConsumerGroupDescription_partition_assignor(const rd_kafka_ConsumerGroupDescription_t *grpdesc);</span>
<span class="s1">const rd_kafka_AclOperation_t *rd_kafka_ConsumerGroupDescription_authorized_operations(const rd_kafka_ConsumerGroupDescription_t *grpdesc, size_t *cntp);</span>
<span class="s1">rd_kafka_consumer_group_state_t rd_kafka_ConsumerGroupDescription_state(const rd_kafka_ConsumerGroupDescription_t *grpdesc);</span>
<span class="s1">const rd_kafka_Node_t *rd_kafka_ConsumerGroupDescription_coordinator(const rd_kafka_ConsumerGroupDescription_t *grpdesc);</span>
<span class="s1">size_t rd_kafka_ConsumerGroupDescription_member_count(const rd_kafka_ConsumerGroupDescription_t *grpdesc);</span>
<span class="s1">const rd_kafka_MemberDescription_t *rd_kafka_ConsumerGroupDescription_member(const rd_kafka_ConsumerGroupDescription_t *grpdesc, size_t idx);</span>
<span class="s1">const char *rd_kafka_MemberDescription_client_id(const rd_kafka_MemberDescription_t *member);</span>
<span class="s1">const char *rd_kafka_MemberDescription_group_instance_id(const rd_kafka_MemberDescription_t *member);</span>
<span class="s1">const char *rd_kafka_MemberDescription_consumer_id(const rd_kafka_MemberDescription_t *member);</span>
<span class="s1">const char *rd_kafka_MemberDescription_host(const rd_kafka_MemberDescription_t *member);</span>
<span class="s1">const rd_kafka_MemberAssignment_t *rd_kafka_MemberDescription_assignment(const rd_kafka_MemberDescription_t *member);</span>
<span class="s1">const rd_kafka_topic_partition_list_t *rd_kafka_MemberAssignment_partitions(const rd_kafka_MemberAssignment_t *assignment);</span>
<span class="s1">typedef struct rd_kafka_DeleteGroup_s rd_kafka_DeleteGroup_t;</span>
<span class="s1">rd_kafka_DeleteGroup_t *rd_kafka_DeleteGroup_new(const char *group);</span>
<span class="s1">void rd_kafka_DeleteGroup_destroy(rd_kafka_DeleteGroup_t *del_group);</span>
<span class="s1">void rd_kafka_DeleteGroup_destroy_array(rd_kafka_DeleteGroup_t **del_groups, size_t del_group_cnt);</span>
<span class="s1">void rd_kafka_DeleteGroups(rd_kafka_t *rk, rd_kafka_DeleteGroup_t **del_groups, size_t del_group_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_group_result_t **rd_kafka_DeleteGroups_result_groups(const rd_kafka_DeleteGroups_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_ListConsumerGroupOffsets_s rd_kafka_ListConsumerGroupOffsets_t;</span>
<span class="s1">rd_kafka_ListConsumerGroupOffsets_t *rd_kafka_ListConsumerGroupOffsets_new(const char *group_id, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">void rd_kafka_ListConsumerGroupOffsets_destroy(rd_kafka_ListConsumerGroupOffsets_t *list_grpoffsets);</span>
<span class="s1">void rd_kafka_ListConsumerGroupOffsets_destroy_array(rd_kafka_ListConsumerGroupOffsets_t **list_grpoffsets, size_t list_grpoffset_cnt);</span>
<span class="s1">void rd_kafka_ListConsumerGroupOffsets(rd_kafka_t *rk, rd_kafka_ListConsumerGroupOffsets_t **list_grpoffsets, size_t list_grpoffsets_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_group_result_t **rd_kafka_ListConsumerGroupOffsets_result_groups(const rd_kafka_ListConsumerGroupOffsets_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_AlterConsumerGroupOffsets_s rd_kafka_AlterConsumerGroupOffsets_t;</span>
<span class="s1">rd_kafka_AlterConsumerGroupOffsets_t *rd_kafka_AlterConsumerGroupOffsets_new(const char *group_id, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">void rd_kafka_AlterConsumerGroupOffsets_destroy(rd_kafka_AlterConsumerGroupOffsets_t *alter_grpoffsets);</span>
<span class="s1">void rd_kafka_AlterConsumerGroupOffsets_destroy_array(rd_kafka_AlterConsumerGroupOffsets_t **alter_grpoffsets, size_t alter_grpoffset_cnt);</span>
<span class="s1">void rd_kafka_AlterConsumerGroupOffsets(rd_kafka_t *rk, rd_kafka_AlterConsumerGroupOffsets_t **alter_grpoffsets, size_t alter_grpoffsets_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_group_result_t **rd_kafka_AlterConsumerGroupOffsets_result_groups(const rd_kafka_AlterConsumerGroupOffsets_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_DeleteConsumerGroupOffsets_s rd_kafka_DeleteConsumerGroupOffsets_t;</span>
<span class="s1">rd_kafka_DeleteConsumerGroupOffsets_t *rd_kafka_DeleteConsumerGroupOffsets_new(const char *group, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">void rd_kafka_DeleteConsumerGroupOffsets_destroy(rd_kafka_DeleteConsumerGroupOffsets_t *del_grpoffsets);</span>
<span class="s1">void rd_kafka_DeleteConsumerGroupOffsets_destroy_array(rd_kafka_DeleteConsumerGroupOffsets_t **del_grpoffsets, size_t del_grpoffset_cnt);</span>
<span class="s1">void rd_kafka_DeleteConsumerGroupOffsets(rd_kafka_t *rk, rd_kafka_DeleteConsumerGroupOffsets_t **del_grpoffsets, size_t del_grpoffsets_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_group_result_t **rd_kafka_DeleteConsumerGroupOffsets_result_groups(const rd_kafka_DeleteConsumerGroupOffsets_result_t *result, size_t *cntp);</span>
<span class="s1">typedef enum rd_kafka_OffsetSpec_t {</span>
<span class="s1">  RD_KAFKA_OFFSET_SPEC_MAX_TIMESTAMP = (- 3),</span>
<span class="s1">  RD_KAFKA_OFFSET_SPEC_EARLIEST = (- 2),</span>
<span class="s1">  RD_KAFKA_OFFSET_SPEC_LATEST = (- 1),</span>
<span class="s1">} rd_kafka_OffsetSpec_t;</span>
<span class="s1">typedef struct rd_kafka_ListOffsetsResultInfo_s rd_kafka_ListOffsetsResultInfo_t;</span>
<span class="s1">const rd_kafka_topic_partition_t *rd_kafka_ListOffsetsResultInfo_topic_partition(const rd_kafka_ListOffsetsResultInfo_t *result_info);</span>
<span class="s1">int64_t rd_kafka_ListOffsetsResultInfo_timestamp(const rd_kafka_ListOffsetsResultInfo_t *result_info);</span>
<span class="s1">const rd_kafka_ListOffsetsResultInfo_t **rd_kafka_ListOffsets_result_infos(const rd_kafka_ListOffsets_result_t *result, size_t *cntp);</span>
<span class="s1">void rd_kafka_ListOffsets(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *topic_partitions, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">typedef enum rd_kafka_ScramMechanism_t {</span>
<span class="s1">  RD_KAFKA_SCRAM_MECHANISM_UNKNOWN = 0,</span>
<span class="s1">  RD_KAFKA_SCRAM_MECHANISM_SHA_256 = 1,</span>
<span class="s1">  RD_KAFKA_SCRAM_MECHANISM_SHA_512 = 2,</span>
<span class="s1">  RD_KAFKA_SCRAM_MECHANISM__CNT,</span>
<span class="s1">} rd_kafka_ScramMechanism_t;</span>
<span class="s1">typedef struct rd_kafka_ScramCredentialInfo_s rd_kafka_ScramCredentialInfo_t;</span>
<span class="s1">rd_kafka_ScramMechanism_t rd_kafka_ScramCredentialInfo_mechanism(const rd_kafka_ScramCredentialInfo_t *scram_credential_info);</span>
<span class="s1">int32_t rd_kafka_ScramCredentialInfo_iterations(const rd_kafka_ScramCredentialInfo_t *scram_credential_info);</span>
<span class="s1">typedef struct rd_kafka_UserScramCredentialsDescription_s rd_kafka_UserScramCredentialsDescription_t;</span>
<span class="s1">const char *rd_kafka_UserScramCredentialsDescription_user(const rd_kafka_UserScramCredentialsDescription_t *description);</span>
<span class="s1">const rd_kafka_error_t *rd_kafka_UserScramCredentialsDescription_error(const rd_kafka_UserScramCredentialsDescription_t *description);</span>
<span class="s1">size_t rd_kafka_UserScramCredentialsDescription_scramcredentialinfo_count(const rd_kafka_UserScramCredentialsDescription_t *description);</span>
<span class="s1">const rd_kafka_ScramCredentialInfo_t *rd_kafka_UserScramCredentialsDescription_scramcredentialinfo(const rd_kafka_UserScramCredentialsDescription_t *description, size_t idx);</span>
<span class="s1">const rd_kafka_UserScramCredentialsDescription_t **rd_kafka_DescribeUserScramCredentials_result_descriptions(const rd_kafka_DescribeUserScramCredentials_result_t *result, size_t *cntp);</span>
<span class="s1">void rd_kafka_DescribeUserScramCredentials(rd_kafka_t *rk, const char **users, size_t user_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">typedef struct rd_kafka_UserScramCredentialAlteration_s rd_kafka_UserScramCredentialAlteration_t;</span>
<span class="s1">rd_kafka_UserScramCredentialAlteration_t *rd_kafka_UserScramCredentialUpsertion_new(const char *username, rd_kafka_ScramMechanism_t mechanism, int32_t iterations, const unsigned char *password, size_t password_size, const unsigned char *salt, size_t salt_size);</span>
<span class="s1">rd_kafka_UserScramCredentialAlteration_t *rd_kafka_UserScramCredentialDeletion_new(const char *username, rd_kafka_ScramMechanism_t mechanism);</span>
<span class="s1">void rd_kafka_UserScramCredentialAlteration_destroy(rd_kafka_UserScramCredentialAlteration_t *alteration);</span>
<span class="s1">void rd_kafka_UserScramCredentialAlteration_destroy_array(rd_kafka_UserScramCredentialAlteration_t **alterations, size_t alteration_cnt);</span>
<span class="s1">typedef struct rd_kafka_AlterUserScramCredentials_result_response_s rd_kafka_AlterUserScramCredentials_result_response_t;</span>
<span class="s1">const char *rd_kafka_AlterUserScramCredentials_result_response_user(const rd_kafka_AlterUserScramCredentials_result_response_t *response);</span>
<span class="s1">const rd_kafka_error_t *rd_kafka_AlterUserScramCredentials_result_response_error(const rd_kafka_AlterUserScramCredentials_result_response_t *response);</span>
<span class="s1">const rd_kafka_AlterUserScramCredentials_result_response_t **rd_kafka_AlterUserScramCredentials_result_responses(const rd_kafka_AlterUserScramCredentials_result_t *result, size_t *cntp);</span>
<span class="s1">void rd_kafka_AlterUserScramCredentials(rd_kafka_t *rk, rd_kafka_UserScramCredentialAlteration_t **alterations, size_t alteration_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">typedef struct rd_kafka_AclBinding_s rd_kafka_AclBinding_t;</span>
<span class="s1">typedef rd_kafka_AclBinding_t rd_kafka_AclBindingFilter_t;</span>
<span class="s1">const rd_kafka_error_t *rd_kafka_acl_result_error(const rd_kafka_acl_result_t *aclres);</span>
<span class="s1">const char *rd_kafka_AclOperation_name(rd_kafka_AclOperation_t acl_operation);</span>
<span class="s1">typedef enum rd_kafka_AclPermissionType_t {</span>
<span class="s1">  RD_KAFKA_ACL_PERMISSION_TYPE_UNKNOWN = 0,</span>
<span class="s1">  RD_KAFKA_ACL_PERMISSION_TYPE_ANY = 1,</span>
<span class="s1">  RD_KAFKA_ACL_PERMISSION_TYPE_DENY = 2,</span>
<span class="s1">  RD_KAFKA_ACL_PERMISSION_TYPE_ALLOW = 3,</span>
<span class="s1">  RD_KAFKA_ACL_PERMISSION_TYPE__CNT,</span>
<span class="s1">} rd_kafka_AclPermissionType_t;</span>
<span class="s1">const char *rd_kafka_AclPermissionType_name(rd_kafka_AclPermissionType_t acl_permission_type);</span>
<span class="s1">rd_kafka_AclBinding_t *rd_kafka_AclBinding_new(rd_kafka_ResourceType_t restype, const char *name, rd_kafka_ResourcePatternType_t resource_pattern_type, const char *principal, const char *host, rd_kafka_AclOperation_t operation, rd_kafka_AclPermissionType_t permission_type, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_AclBindingFilter_t *rd_kafka_AclBindingFilter_new(rd_kafka_ResourceType_t restype, const char *name, rd_kafka_ResourcePatternType_t resource_pattern_type, const char *principal, const char *host, rd_kafka_AclOperation_t operation, rd_kafka_AclPermissionType_t permission_type, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_ResourceType_t rd_kafka_AclBinding_restype(const rd_kafka_AclBinding_t *acl);</span>
<span class="s1">const char *rd_kafka_AclBinding_name(const rd_kafka_AclBinding_t *acl);</span>
<span class="s1">const char *rd_kafka_AclBinding_principal(const rd_kafka_AclBinding_t *acl);</span>
<span class="s1">const char *rd_kafka_AclBinding_host(const rd_kafka_AclBinding_t *acl);</span>
<span class="s1">rd_kafka_AclOperation_t rd_kafka_AclBinding_operation(const rd_kafka_AclBinding_t *acl);</span>
<span class="s1">rd_kafka_AclPermissionType_t rd_kafka_AclBinding_permission_type(const rd_kafka_AclBinding_t *acl);</span>
<span class="s1">rd_kafka_ResourcePatternType_t rd_kafka_AclBinding_resource_pattern_type(const rd_kafka_AclBinding_t *acl);</span>
<span class="s1">const rd_kafka_error_t *rd_kafka_AclBinding_error(const rd_kafka_AclBinding_t *acl);</span>
<span class="s1">void rd_kafka_AclBinding_destroy(rd_kafka_AclBinding_t *acl_binding);</span>
<span class="s1">void rd_kafka_AclBinding_destroy_array(rd_kafka_AclBinding_t **acl_bindings, size_t acl_bindings_cnt);</span>
<span class="s1">const rd_kafka_acl_result_t **rd_kafka_CreateAcls_result_acls(const rd_kafka_CreateAcls_result_t *result, size_t *cntp);</span>
<span class="s1">void rd_kafka_CreateAcls(rd_kafka_t *rk, rd_kafka_AclBinding_t **new_acls, size_t new_acls_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_AclBinding_t **rd_kafka_DescribeAcls_result_acls(const rd_kafka_DescribeAcls_result_t *result, size_t *cntp);</span>
<span class="s1">void rd_kafka_DescribeAcls(rd_kafka_t *rk, rd_kafka_AclBindingFilter_t *acl_filter, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">typedef struct rd_kafka_DeleteAcls_result_response_s rd_kafka_DeleteAcls_result_response_t;</span>
<span class="s1">const rd_kafka_DeleteAcls_result_response_t **rd_kafka_DeleteAcls_result_responses(const rd_kafka_DeleteAcls_result_t *result, size_t *cntp);</span>
<span class="s1">const rd_kafka_error_t *rd_kafka_DeleteAcls_result_response_error(const rd_kafka_DeleteAcls_result_response_t *result_response);</span>
<span class="s1">const rd_kafka_AclBinding_t **rd_kafka_DeleteAcls_result_response_matching_acls(const rd_kafka_DeleteAcls_result_response_t *result_response, size_t *matching_acls_cntp);</span>
<span class="s1">void rd_kafka_DeleteAcls(rd_kafka_t *rk, rd_kafka_AclBindingFilter_t **del_acls, size_t del_acls_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token(rd_kafka_t *rk, const char *token_value, int64_t md_lifetime_ms, const char *md_principal_name, const char **extensions, size_t extension_size, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token_failure(rd_kafka_t *rk, const char *errstr);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_init_transactions(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_begin_transaction(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_send_offsets_to_transaction(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, const rd_kafka_consumer_group_metadata_t *cgmetadata, int timeout_ms);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_commit_transaction(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_abort_transaction(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">typedef struct rd_kafka_mock_cluster_s rd_kafka_mock_cluster_t;</span>
<span class="s1">rd_kafka_mock_cluster_t *rd_kafka_mock_cluster_new(rd_kafka_t *rk, int broker_cnt);</span>
<span class="s1">void rd_kafka_mock_cluster_destroy(rd_kafka_mock_cluster_t *mcluster);</span>
<span class="s1">rd_kafka_t *rd_kafka_mock_cluster_handle(const rd_kafka_mock_cluster_t *mcluster);</span>
<span class="s1">rd_kafka_mock_cluster_t *rd_kafka_handle_mock_cluster(const rd_kafka_t *rk);</span>
<span class="s1">const char *rd_kafka_mock_cluster_bootstraps(const rd_kafka_mock_cluster_t *mcluster);</span>
<span class="s1">void rd_kafka_mock_clear_request_errors(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey);</span>
<span class="s1">void rd_kafka_mock_push_request_errors(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, size_t cnt, ...);</span>
<span class="s1">void rd_kafka_mock_push_request_errors_array(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, size_t cnt, const rd_kafka_resp_err_t *errors);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_push_request_error_rtts(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int16_t ApiKey, size_t cnt, ...);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_error_stack_cnt(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int16_t ApiKey, size_t *cntp);</span>
<span class="s1">void rd_kafka_mock_topic_set_error(rd_kafka_mock_cluster_t *mcluster, const char *topic, rd_kafka_resp_err_t err);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_topic_create(rd_kafka_mock_cluster_t *mcluster, const char *topic, int partition_cnt, int replication_factor);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_partition_set_leader(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_partition_set_follower(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_partition_set_follower_wmarks(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int64_t lo, int64_t hi);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_partition_push_leader_response(rd_kafka_mock_cluster_t *mcluster, const char *topic, int partition, int32_t leader_id, int32_t leader_epoch);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_set_down(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_set_up(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_set_rtt(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int rtt_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_set_rack(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, const char *rack);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_coordinator_set(rd_kafka_mock_cluster_t *mcluster, const char *key_type, const char *key, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_set_apiversion(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, int16_t MinVersion, int16_t MaxVersion);</span>
<span class="s1">void rd_kafka_mock_start_request_tracking(rd_kafka_mock_cluster_t *mcluster);</span>
<span class="s1">void rd_kafka_mock_stop_request_tracking(rd_kafka_mock_cluster_t *mcluster);</span>
<span class="s1">typedef struct rd_kafka_mock_request_s rd_kafka_mock_request_t;</span>
<span class="s1">void rd_kafka_mock_request_destroy(rd_kafka_mock_request_t *mreq);</span>
<span class="s1">void rd_kafka_mock_request_destroy_array(rd_kafka_mock_request_t **mreqs, size_t mreq_cnt);</span>
<span class="s1">int32_t rd_kafka_mock_request_id(rd_kafka_mock_request_t *mreq);</span>
<span class="s1">int16_t rd_kafka_mock_request_api_key(rd_kafka_mock_request_t *mreq);</span>
<span class="s1">int64_t rd_kafka_mock_request_timestamp(rd_kafka_mock_request_t *mreq);</span>
<span class="s1">rd_kafka_mock_request_t **rd_kafka_mock_get_requests(rd_kafka_mock_cluster_t *mcluster, size_t *cntp);</span>
<span class="s1">void rd_kafka_mock_clear_requests(rd_kafka_mock_cluster_t *mcluster);</span>
<span class="s1">&#39;</span>
</code></pre></div>
rdkafka.h, rdkafka_mock.h</p>
<h3 id="rd_kafka_version_31">RD_KAFKA_VERSION<a class="headerlink" href="#rd_kafka_version_31" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_VERSION</span> <span class="o">=</span> <span class="mi">33882367</span>
</code></pre></div>
<p>librdkafka version </p>
<p>Interpreted as hex <code>MM.mm.rr.xx</code>:</p>
<ul>
<li>MM = Major</li>
<li>mm = minor</li>
<li>rr = revision</li>
<li>xx = pre-release id (0xff is the final release)</li>
</ul>
<p>E.g.: <code>0x000801ff</code> = 0.8.1</p>
<dl class="section remark"><dt>Remarks</dt><dd>This value should only be used during compile time, for runtime checks of version use rd_kafka_version() </dd></dl>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_unsupported_compression_type_31">RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE<a class="headerlink" href="#rd_kafka_resp_err_unsupported_compression_type_31" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE</span> <span class="o">=</span> <span class="mi">76</span>
</code></pre></div>
<p>Unsupported compression type </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_end_all_31">RD_KAFKA_RESP_ERR_END_ALL<a class="headerlink" href="#rd_kafka_resp_err_end_all_31" title="Permanent link">&para;</a></h3>
<p><div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_END_ALL</span> <span class="o">=</span> <span class="mi">119</span>
</code></pre></div>
enum rd_kafka_resp_err_t</p>
<h3 id="rd_kafka_admin_op__cnt_31">RD_KAFKA_ADMIN_OP__CNT<a class="headerlink" href="#rd_kafka_admin_op__cnt_31" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_ADMIN_OP__CNT</span> <span class="o">=</span> <span class="mi">22</span>
</code></pre></div>
<p>Number of ops defined </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe </a></li>
</ul>
</div>
<h3 id="rd_kafka_resource__cnt_31">RD_KAFKA_RESOURCE__CNT<a class="headerlink" href="#rd_kafka_resource__cnt_31" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESOURCE__CNT</span> <span class="o">=</span> <span class="mi">5</span>
</code></pre></div>
<p>Number of resource types defined </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#acca83a66d7783ff7683ed2691cc907c9"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#acca83a66d7783ff7683ed2691cc907c9 </a></li>
</ul>
</div>
<h3 id="rd_kafka_cdef_31">RD_KAFKA_CDEF<a class="headerlink" href="#rd_kafka_cdef_31" title="Permanent link">&para;</a></h3>
<p><div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_CDEF</span> <span class="o">=</span> <span class="s1">&#39;typedef long int ssize_t;</span>
<span class="s1">typedef struct _IO_FILE FILE;</span>
<span class="s1">typedef long int mode_t;</span>
<span class="s1">typedef signed int int16_t;</span>
<span class="s1">typedef unsigned int uint16_t;</span>
<span class="s1">typedef signed int int32_t;</span>
<span class="s1">typedef signed long int int64_t;</span>
<span class="s1">int rd_kafka_version(void);</span>
<span class="s1">const char *rd_kafka_version_str(void);</span>
<span class="s1">typedef enum rd_kafka_type_t {</span>
<span class="s1">  RD_KAFKA_PRODUCER,</span>
<span class="s1">  RD_KAFKA_CONSUMER,</span>
<span class="s1">} rd_kafka_type_t;</span>
<span class="s1">typedef enum rd_kafka_timestamp_type_t {</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_NOT_AVAILABLE,</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_CREATE_TIME,</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_LOG_APPEND_TIME,</span>
<span class="s1">} rd_kafka_timestamp_type_t;</span>
<span class="s1">const char *rd_kafka_get_debug_contexts(void);</span>
<span class="s1">typedef struct rd_kafka_s rd_kafka_t;</span>
<span class="s1">typedef struct rd_kafka_topic_s rd_kafka_topic_t;</span>
<span class="s1">typedef struct rd_kafka_conf_s rd_kafka_conf_t;</span>
<span class="s1">typedef struct rd_kafka_topic_conf_s rd_kafka_topic_conf_t;</span>
<span class="s1">typedef struct rd_kafka_queue_s rd_kafka_queue_t;</span>
<span class="s1">typedef struct rd_kafka_op_s rd_kafka_event_t;</span>
<span class="s1">typedef struct rd_kafka_topic_result_s rd_kafka_topic_result_t;</span>
<span class="s1">typedef struct rd_kafka_consumer_group_metadata_s rd_kafka_consumer_group_metadata_t;</span>
<span class="s1">typedef struct rd_kafka_error_s {</span>
<span class="s1">  unsigned int code;</span>
<span class="s1">  char *errstr;</span>
<span class="s1">  unsigned char fatal;</span>
<span class="s1">  unsigned char retriable;</span>
<span class="s1">  unsigned char txn_requires_abort;</span>
<span class="s1">} rd_kafka_error_t;</span>
<span class="s1">typedef struct rd_kafka_headers_s rd_kafka_headers_t;</span>
<span class="s1">typedef struct rd_kafka_group_result_s rd_kafka_group_result_t;</span>
<span class="s1">typedef struct rd_kafka_acl_result_s rd_kafka_acl_result_t;</span>
<span class="s1">typedef struct rd_kafka_Uuid_s rd_kafka_Uuid_t;</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BEGIN = (- 200),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BAD_MSG = (- 199),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BAD_COMPRESSION = (- 198),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__DESTROY = (- 197),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FAIL = (- 196),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TRANSPORT = (- 195),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__CRIT_SYS_RESOURCE = (- 194),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__RESOLVE = (- 193),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__MSG_TIMED_OUT = (- 192),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PARTITION_EOF = (- 191),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION = (- 190),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FS = (- 189),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC = (- 188),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ALL_BROKERS_DOWN = (- 187),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INVALID_ARG = (- 186),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TIMED_OUT = (- 185),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__QUEUE_FULL = (- 184),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ISR_INSUFF = (- 183),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NODE_UPDATE = (- 182),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__SSL = (- 181),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__WAIT_COORD = (- 180),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_GROUP = (- 179),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__IN_PROGRESS = (- 178),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PREV_IN_PROGRESS = (- 177),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__EXISTING_SUBSCRIPTION = (- 176),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS = (- 175),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS = (- 174),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__CONFLICT = (- 173),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__STATE = (- 172),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_PROTOCOL = (- 171),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED = (- 170),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__AUTHENTICATION = (- 169),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NO_OFFSET = (- 168),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__OUTDATED = (- 167),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TIMED_OUT_QUEUE = (- 166),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNSUPPORTED_FEATURE = (- 165),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__WAIT_CACHE = (- 164),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INTR = (- 163),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__KEY_SERIALIZATION = (- 162),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__VALUE_SERIALIZATION = (- 161),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__KEY_DESERIALIZATION = (- 160),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__VALUE_DESERIALIZATION = (- 159),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PARTIAL = (- 158),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__READ_ONLY = (- 157),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOENT = (- 156),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNDERFLOW = (- 155),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INVALID_TYPE = (- 154),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__RETRY = (- 153),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PURGE_QUEUE = (- 152),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PURGE_INFLIGHT = (- 151),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FATAL = (- 150),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INCONSISTENT = (- 149),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__GAPLESS_GUARANTEE = (- 148),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__MAX_POLL_EXCEEDED = (- 147),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_BROKER = (- 146),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOT_CONFIGURED = (- 145),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FENCED = (- 144),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__APPLICATION = (- 143),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ASSIGNMENT_LOST = (- 142),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOOP = (- 141),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__AUTO_OFFSET_RESET = (- 140),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__LOG_TRUNCATION = (- 139),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INVALID_DIFFERENT_RECORD = (- 138),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__END = (- 100),</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN = (- 1),</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NO_ERROR = 0,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_OUT_OF_RANGE = 1,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_MSG = 2,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART = 3,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_MSG_SIZE = 4,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE = 5,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_LEADER_FOR_PARTITION = 6,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REQUEST_TIMED_OUT = 7,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_BROKER_NOT_AVAILABLE = 8,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REPLICA_NOT_AVAILABLE = 9,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE = 10,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_STALE_CTRL_EPOCH = 11,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_METADATA_TOO_LARGE = 12,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NETWORK_EXCEPTION = 13,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_COORDINATOR_LOAD_IN_PROGRESS = 14,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_COORDINATOR_NOT_AVAILABLE = 15,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_COORDINATOR = 16,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_EXCEPTION = 17,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_RECORD_LIST_TOO_LARGE = 18,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS = 19,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS_AFTER_APPEND = 20,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REQUIRED_ACKS = 21,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ILLEGAL_GENERATION = 22,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INCONSISTENT_GROUP_PROTOCOL = 23,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_GROUP_ID = 24,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_MEMBER_ID = 25,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_SESSION_TIMEOUT = 26,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REBALANCE_IN_PROGRESS = 27,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_COMMIT_OFFSET_SIZE = 28,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_AUTHORIZATION_FAILED = 29,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_AUTHORIZATION_FAILED = 30,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_CLUSTER_AUTHORIZATION_FAILED = 31,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TIMESTAMP = 32,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_SASL_MECHANISM = 33,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ILLEGAL_SASL_STATE = 34,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_VERSION = 35,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_ALREADY_EXISTS = 36,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PARTITIONS = 37,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REPLICATION_FACTOR = 38,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REPLICA_ASSIGNMENT = 39,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_CONFIG = 40,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_CONTROLLER = 41,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REQUEST = 42,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_FOR_MESSAGE_FORMAT = 43,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_POLICY_VIOLATION = 44,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OUT_OF_ORDER_SEQUENCE_NUMBER = 45,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DUPLICATE_SEQUENCE_NUMBER = 46,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_EPOCH = 47,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TXN_STATE = 48,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_ID_MAPPING = 49,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TRANSACTION_TIMEOUT = 50,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_CONCURRENT_TRANSACTIONS = 51,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TRANSACTION_COORDINATOR_FENCED = 52,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TRANSACTIONAL_ID_AUTHORIZATION_FAILED = 53,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_SECURITY_DISABLED = 54,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OPERATION_NOT_ATTEMPTED = 55,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_KAFKA_STORAGE_ERROR = 56,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LOG_DIR_NOT_FOUND = 57,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_SASL_AUTHENTICATION_FAILED = 58,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_PRODUCER_ID = 59,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REASSIGNMENT_IN_PROGRESS = 60,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTH_DISABLED = 61,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_NOT_FOUND = 62,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_OWNER_MISMATCH = 63,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_REQUEST_NOT_ALLOWED = 64,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTHORIZATION_FAILED = 65,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_EXPIRED = 66,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRINCIPAL_TYPE = 67,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NON_EMPTY_GROUP = 68,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_ID_NOT_FOUND = 69,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FETCH_SESSION_ID_NOT_FOUND = 70,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_FETCH_SESSION_EPOCH = 71,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LISTENER_NOT_FOUND = 72,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_DELETION_DISABLED = 73,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FENCED_LEADER_EPOCH = 74,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_LEADER_EPOCH = 75,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_STALE_BROKER_EPOCH = 77,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_NOT_AVAILABLE = 78,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_MEMBER_ID_REQUIRED = 79,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_PREFERRED_LEADER_NOT_AVAILABLE = 80,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_MAX_SIZE_REACHED = 81,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FENCED_INSTANCE_ID = 82,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ELIGIBLE_LEADERS_NOT_AVAILABLE = 83,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ELECTION_NOT_NEEDED = 84,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NO_REASSIGNMENT_IN_PROGRESS = 85,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_SUBSCRIBED_TO_TOPIC = 86,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_RECORD = 87,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSTABLE_OFFSET_COMMIT = 88,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_THROTTLING_QUOTA_EXCEEDED = 89,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_PRODUCER_FENCED = 90,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_RESOURCE_NOT_FOUND = 91,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DUPLICATE_RESOURCE = 92,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNACCEPTABLE_CREDENTIAL = 93,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INCONSISTENT_VOTER_SET = 94,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_UPDATE_VERSION = 95,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FEATURE_UPDATE_FAILED = 96,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_PRINCIPAL_DESERIALIZATION_FAILURE = 97,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_ID = 100,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FENCED_MEMBER_EPOCH = 110,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNRELEASED_INSTANCE_ID = 111,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_ASSIGNOR = 112,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_STALE_MEMBER_EPOCH = 113,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_SUBSCRIPTION_ID = 117,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TELEMETRY_TOO_LARGE = 118,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_END_ALL,</span>
<span class="s1">} rd_kafka_resp_err_t;</span>
<span class="s1">struct rd_kafka_err_desc {</span>
<span class="s1">  rd_kafka_resp_err_t code;</span>
<span class="s1">  char *name;</span>
<span class="s1">  char *desc;</span>
<span class="s1">};</span>
<span class="s1">void rd_kafka_get_err_descs(const struct rd_kafka_err_desc **errdescs, size_t *cntp);</span>
<span class="s1">const char *rd_kafka_err2str(rd_kafka_resp_err_t err);</span>
<span class="s1">const char *rd_kafka_err2name(rd_kafka_resp_err_t err);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_last_error(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_errno2err(int errnox);</span>
<span class="s1">int rd_kafka_errno(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_fatal_error(rd_kafka_t *rk, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_test_fatal_error(rd_kafka_t *rk, rd_kafka_resp_err_t err, const char *reason);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_error_code(const rd_kafka_error_t *error);</span>
<span class="s1">const char *rd_kafka_error_name(const rd_kafka_error_t *error);</span>
<span class="s1">const char *rd_kafka_error_string(const rd_kafka_error_t *error);</span>
<span class="s1">int rd_kafka_error_is_fatal(const rd_kafka_error_t *error);</span>
<span class="s1">int rd_kafka_error_is_retriable(const rd_kafka_error_t *error);</span>
<span class="s1">int rd_kafka_error_txn_requires_abort(const rd_kafka_error_t *error);</span>
<span class="s1">void rd_kafka_error_destroy(rd_kafka_error_t *error);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_error_new(rd_kafka_resp_err_t code, const char *fmt, ...);</span>
<span class="s1">typedef struct rd_kafka_topic_partition_s {</span>
<span class="s1">  char *topic;</span>
<span class="s1">  int32_t partition;</span>
<span class="s1">  int64_t offset;</span>
<span class="s1">  void *metadata;</span>
<span class="s1">  size_t metadata_size;</span>
<span class="s1">  void *opaque;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  void *_private;</span>
<span class="s1">} rd_kafka_topic_partition_t;</span>
<span class="s1">void rd_kafka_topic_partition_destroy(rd_kafka_topic_partition_t *rktpar);</span>
<span class="s1">void rd_kafka_topic_partition_set_leader_epoch(rd_kafka_topic_partition_t *rktpar, int32_t leader_epoch);</span>
<span class="s1">int32_t rd_kafka_topic_partition_get_leader_epoch(const rd_kafka_topic_partition_t *rktpar);</span>
<span class="s1">typedef struct rd_kafka_topic_partition_list_s {</span>
<span class="s1">  int cnt;</span>
<span class="s1">  int size;</span>
<span class="s1">  rd_kafka_topic_partition_t *elems;</span>
<span class="s1">} rd_kafka_topic_partition_list_t;</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_new(int size);</span>
<span class="s1">void rd_kafka_topic_partition_list_destroy(rd_kafka_topic_partition_list_t *rkparlist);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_add(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">void rd_kafka_topic_partition_list_add_range(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t start, int32_t stop);</span>
<span class="s1">int rd_kafka_topic_partition_list_del(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">int rd_kafka_topic_partition_list_del_by_idx(rd_kafka_topic_partition_list_t *rktparlist, int idx);</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_copy(const rd_kafka_topic_partition_list_t *src);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_topic_partition_list_set_offset(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition, int64_t offset);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_find(const rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">void rd_kafka_topic_partition_list_sort(rd_kafka_topic_partition_list_t *rktparlist, int (*cmp)(const void *a, const void *b, void *cmp_opaque), void *cmp_opaque);</span>
<span class="s1">typedef enum rd_kafka_vtype_t {</span>
<span class="s1">  RD_KAFKA_VTYPE_END,</span>
<span class="s1">  RD_KAFKA_VTYPE_TOPIC,</span>
<span class="s1">  RD_KAFKA_VTYPE_RKT,</span>
<span class="s1">  RD_KAFKA_VTYPE_PARTITION,</span>
<span class="s1">  RD_KAFKA_VTYPE_VALUE,</span>
<span class="s1">  RD_KAFKA_VTYPE_KEY,</span>
<span class="s1">  RD_KAFKA_VTYPE_OPAQUE,</span>
<span class="s1">  RD_KAFKA_VTYPE_MSGFLAGS,</span>
<span class="s1">  RD_KAFKA_VTYPE_TIMESTAMP,</span>
<span class="s1">  RD_KAFKA_VTYPE_HEADER,</span>
<span class="s1">  RD_KAFKA_VTYPE_HEADERS,</span>
<span class="s1">} rd_kafka_vtype_t;</span>
<span class="s1">typedef struct rd_kafka_vu_s {</span>
<span class="s1">  rd_kafka_vtype_t vtype;</span>
<span class="s1">  union {</span>
<span class="s1">    char *cstr;</span>
<span class="s1">    rd_kafka_topic_t *rkt;</span>
<span class="s1">    int i;</span>
<span class="s1">    int32_t i32;</span>
<span class="s1">    int64_t i64;</span>
<span class="s1">    struct {</span>
<span class="s1">      void *ptr;</span>
<span class="s1">      size_t size;</span>
<span class="s1">    } mem;</span>
<span class="s1">    struct {</span>
<span class="s1">      char *name;</span>
<span class="s1">      void *val;</span>
<span class="s1">      ssize_t size;</span>
<span class="s1">    } header;</span>
<span class="s1">    rd_kafka_headers_t *headers;</span>
<span class="s1">    void *ptr;</span>
<span class="s1">    char _pad[64];</span>
<span class="s1">  } u;</span>
<span class="s1">} rd_kafka_vu_t;</span>
<span class="s1">rd_kafka_headers_t *rd_kafka_headers_new(size_t initial_count);</span>
<span class="s1">void rd_kafka_headers_destroy(rd_kafka_headers_t *hdrs);</span>
<span class="s1">rd_kafka_headers_t *rd_kafka_headers_copy(const rd_kafka_headers_t *src);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_add(rd_kafka_headers_t *hdrs, const char *name, ssize_t name_size, const void *value, ssize_t value_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_remove(rd_kafka_headers_t *hdrs, const char *name);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get_last(const rd_kafka_headers_t *hdrs, const char *name, const void **valuep, size_t *sizep);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get(const rd_kafka_headers_t *hdrs, size_t idx, const char *name, const void **valuep, size_t *sizep);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get_all(const rd_kafka_headers_t *hdrs, size_t idx, const char **namep, const void **valuep, size_t *sizep);</span>
<span class="s1">typedef struct rd_kafka_message_s {</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  rd_kafka_topic_t *rkt;</span>
<span class="s1">  int32_t partition;</span>
<span class="s1">  void *payload;</span>
<span class="s1">  size_t len;</span>
<span class="s1">  void *key;</span>
<span class="s1">  size_t key_len;</span>
<span class="s1">  int64_t offset;</span>
<span class="s1">  void *_private;</span>
<span class="s1">} rd_kafka_message_t;</span>
<span class="s1">void rd_kafka_message_destroy(rd_kafka_message_t *rkmessage);</span>
<span class="s1">const char *rd_kafka_message_errstr(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">const char *rd_kafka_message_produce_errstr(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">int64_t rd_kafka_message_timestamp(const rd_kafka_message_t *rkmessage, rd_kafka_timestamp_type_t *tstype);</span>
<span class="s1">int64_t rd_kafka_message_latency(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">int32_t rd_kafka_message_broker_id(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_message_headers(const rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_message_detach_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);</span>
<span class="s1">void rd_kafka_message_set_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t *hdrs);</span>
<span class="s1">size_t rd_kafka_header_cnt(const rd_kafka_headers_t *hdrs);</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_NOT_PERSISTED = 0,</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_POSSIBLY_PERSISTED = 1,</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_PERSISTED = 2,</span>
<span class="s1">} rd_kafka_msg_status_t;</span>
<span class="s1">rd_kafka_msg_status_t rd_kafka_message_status(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">int32_t rd_kafka_message_leader_epoch(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">const char *rd_kafka_Uuid_base64str(const rd_kafka_Uuid_t *uuid);</span>
<span class="s1">int64_t rd_kafka_Uuid_least_significant_bits(const rd_kafka_Uuid_t *uuid);</span>
<span class="s1">int64_t rd_kafka_Uuid_most_significant_bits(const rd_kafka_Uuid_t *uuid);</span>
<span class="s1">rd_kafka_Uuid_t *rd_kafka_Uuid_new(int64_t most_significant_bits, int64_t least_significant_bits);</span>
<span class="s1">rd_kafka_Uuid_t *rd_kafka_Uuid_copy(const rd_kafka_Uuid_t *uuid);</span>
<span class="s1">void rd_kafka_Uuid_destroy(rd_kafka_Uuid_t *uuid);</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_CONF_UNKNOWN = (- 2),</span>
<span class="s1">  RD_KAFKA_CONF_INVALID = (- 1),</span>
<span class="s1">  RD_KAFKA_CONF_OK = 0,</span>
<span class="s1">} rd_kafka_conf_res_t;</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_new(void);</span>
<span class="s1">void rd_kafka_conf_destroy(rd_kafka_conf_t *conf);</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_dup(const rd_kafka_conf_t *conf);</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_dup_filter(const rd_kafka_conf_t *conf, size_t filter_cnt, const char **filter);</span>
<span class="s1">const rd_kafka_conf_t *rd_kafka_conf(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_set(rd_kafka_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_conf_set_events(rd_kafka_conf_t *conf, int events);</span>
<span class="s1">void rd_kafka_conf_set_background_event_cb(rd_kafka_conf_t *conf, void (*event_cb)(rd_kafka_t *rk, rd_kafka_event_t *rkev, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_dr_cb(rd_kafka_conf_t *conf, void (*dr_cb)(rd_kafka_t *rk, void *payload, size_t len, rd_kafka_resp_err_t err, void *opaque, void *msg_opaque));</span>
<span class="s1">void rd_kafka_conf_set_dr_msg_cb(rd_kafka_conf_t *conf, void (*dr_msg_cb)(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_consume_cb(rd_kafka_conf_t *conf, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_rebalance_cb(rd_kafka_conf_t *conf, void (*rebalance_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *partitions, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_offset_commit_cb(rd_kafka_conf_t *conf, void (*offset_commit_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_error_cb(rd_kafka_conf_t *conf, void (*error_cb)(rd_kafka_t *rk, int err, const char *reason, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_throttle_cb(rd_kafka_conf_t *conf, void (*throttle_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int throttle_time_ms, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_log_cb(rd_kafka_conf_t *conf, void (*log_cb)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));</span>
<span class="s1">void rd_kafka_conf_set_stats_cb(rd_kafka_conf_t *conf, int (*stats_cb)(rd_kafka_t *rk, char *json, size_t json_len, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_oauthbearer_token_refresh_cb(rd_kafka_conf_t *conf, void (*oauthbearer_token_refresh_cb)(rd_kafka_t *rk, const char *oauthbearer_config, void *opaque));</span>
<span class="s1">void rd_kafka_conf_enable_sasl_queue(rd_kafka_conf_t *conf, int enable);</span>
<span class="s1">void rd_kafka_conf_set_socket_cb(rd_kafka_conf_t *conf, int (*socket_cb)(int domain, int type, int protocol, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_connect_cb(rd_kafka_conf_t *conf, int (*connect_cb)(int sockfd, const struct sockaddr *addr, int addrlen, const char *id, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_closesocket_cb(rd_kafka_conf_t *conf, int (*closesocket_cb)(int sockfd, void *opaque));</span>
<span class="s1">struct addrinfo;</span>
<span class="s1">void rd_kafka_conf_set_resolve_cb(rd_kafka_conf_t *conf, int (*resolve_cb)(const char *node, const char *service, const struct addrinfo *hints, struct addrinfo **res, void *opaque));</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert_verify_cb(rd_kafka_conf_t *conf, int (*ssl_cert_verify_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int *x509_error, int depth, const char *buf, size_t size, char *errstr, size_t errstr_size, void *opaque));</span>
<span class="s1">typedef enum rd_kafka_cert_type_t {</span>
<span class="s1">  RD_KAFKA_CERT_PUBLIC_KEY,</span>
<span class="s1">  RD_KAFKA_CERT_PRIVATE_KEY,</span>
<span class="s1">  RD_KAFKA_CERT_CA,</span>
<span class="s1">  RD_KAFKA_CERT__CNT,</span>
<span class="s1">} rd_kafka_cert_type_t;</span>
<span class="s1">typedef enum rd_kafka_cert_enc_t {</span>
<span class="s1">  RD_KAFKA_CERT_ENC_PKCS12,</span>
<span class="s1">  RD_KAFKA_CERT_ENC_DER,</span>
<span class="s1">  RD_KAFKA_CERT_ENC_PEM,</span>
<span class="s1">  RD_KAFKA_CERT_ENC__CNT,</span>
<span class="s1">} rd_kafka_cert_enc_t;</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert(rd_kafka_conf_t *conf, rd_kafka_cert_type_t cert_type, rd_kafka_cert_enc_t cert_enc, const void *buffer, size_t size, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_conf_set_engine_callback_data(rd_kafka_conf_t *conf, void *callback_data);</span>
<span class="s1">void rd_kafka_conf_set_opaque(rd_kafka_conf_t *conf, void *opaque);</span>
<span class="s1">void *rd_kafka_opaque(const rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_conf_set_default_topic_conf(rd_kafka_conf_t *conf, rd_kafka_topic_conf_t *tconf);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_conf_get_default_topic_conf(rd_kafka_conf_t *conf);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_get(const rd_kafka_conf_t *conf, const char *name, char *dest, size_t *dest_size);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_topic_conf_get(const rd_kafka_topic_conf_t *conf, const char *name, char *dest, size_t *dest_size);</span>
<span class="s1">const char **rd_kafka_conf_dump(rd_kafka_conf_t *conf, size_t *cntp);</span>
<span class="s1">const char **rd_kafka_topic_conf_dump(rd_kafka_topic_conf_t *conf, size_t *cntp);</span>
<span class="s1">void rd_kafka_conf_dump_free(const char **arr, size_t cnt);</span>
<span class="s1">void rd_kafka_conf_properties_show(FILE *fp);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_topic_conf_new(void);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_topic_conf_dup(const rd_kafka_topic_conf_t *conf);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_default_topic_conf_dup(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_topic_conf_destroy(rd_kafka_topic_conf_t *topic_conf);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_topic_conf_set(rd_kafka_topic_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_topic_conf_set_opaque(rd_kafka_topic_conf_t *conf, void *rkt_opaque);</span>
<span class="s1">void rd_kafka_topic_conf_set_partitioner_cb(rd_kafka_topic_conf_t *topic_conf, int32_t (*partitioner)(const rd_kafka_topic_t *rkt, const void *keydata, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque));</span>
<span class="s1">void rd_kafka_topic_conf_set_msg_order_cmp(rd_kafka_topic_conf_t *topic_conf, int (*msg_order_cmp)(const rd_kafka_message_t *a, const rd_kafka_message_t *b));</span>
<span class="s1">int rd_kafka_topic_partition_available(const rd_kafka_topic_t *rkt, int32_t partition);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_consistent(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_consistent_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_murmur2(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_murmur2_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_fnv1a(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_fnv1a_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">rd_kafka_t *rd_kafka_new(rd_kafka_type_t type, rd_kafka_conf_t *conf, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_destroy(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_destroy_flags(rd_kafka_t *rk, int flags);</span>
<span class="s1">const char *rd_kafka_name(const rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_type_t rd_kafka_type(const rd_kafka_t *rk);</span>
<span class="s1">char *rd_kafka_memberid(const rd_kafka_t *rk);</span>
<span class="s1">char *rd_kafka_clusterid(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">int32_t rd_kafka_controllerid(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_topic_t *rd_kafka_topic_new(rd_kafka_t *rk, const char *topic, rd_kafka_topic_conf_t *conf);</span>
<span class="s1">void rd_kafka_topic_destroy(rd_kafka_topic_t *rkt);</span>
<span class="s1">const char *rd_kafka_topic_name(const rd_kafka_topic_t *rkt);</span>
<span class="s1">void *rd_kafka_topic_opaque(const rd_kafka_topic_t *rkt);</span>
<span class="s1">int rd_kafka_poll(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">void rd_kafka_yield(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_pause_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_resume_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_query_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_get_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offsets_for_times(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets, int timeout_ms);</span>
<span class="s1">void *rd_kafka_mem_calloc(rd_kafka_t *rk, size_t num, size_t size);</span>
<span class="s1">void *rd_kafka_mem_malloc(rd_kafka_t *rk, size_t size);</span>
<span class="s1">void rd_kafka_mem_free(rd_kafka_t *rk, void *ptr);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_new(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_queue_destroy(rd_kafka_queue_t *rkqu);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_main(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_sasl(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_sasl_background_callbacks_enable(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_sasl_set_credentials(rd_kafka_t *rk, const char *username, const char *password);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_consumer(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_partition(rd_kafka_t *rk, const char *topic, int32_t partition);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_background(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_queue_forward(rd_kafka_queue_t *src, rd_kafka_queue_t *dst);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_set_log_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu);</span>
<span class="s1">size_t rd_kafka_queue_length(rd_kafka_queue_t *rkqu);</span>
<span class="s1">void rd_kafka_queue_io_event_enable(rd_kafka_queue_t *rkqu, int fd, const void *payload, size_t size);</span>
<span class="s1">void rd_kafka_queue_cb_event_enable(rd_kafka_queue_t *rkqu, void (*event_cb)(rd_kafka_t *rk, void *qev_opaque), void *qev_opaque);</span>
<span class="s1">void rd_kafka_queue_yield(rd_kafka_queue_t *rkqu);</span>
<span class="s1">int rd_kafka_consume_start(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);</span>
<span class="s1">int rd_kafka_consume_start_queue(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, rd_kafka_queue_t *rkqu);</span>
<span class="s1">int rd_kafka_consume_stop(rd_kafka_topic_t *rkt, int32_t partition);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_seek(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, int timeout_ms);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_seek_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consume(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms);</span>
<span class="s1">ssize_t rd_kafka_consume_batch(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);</span>
<span class="s1">int rd_kafka_consume_callback(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consume_queue(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">ssize_t rd_kafka_consume_batch_queue(rd_kafka_queue_t *rkqu, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);</span>
<span class="s1">int rd_kafka_consume_callback_queue(rd_kafka_queue_t *rkqu, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offset_store(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offsets_store(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_offset_store_message(rd_kafka_message_t *rkmessage);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_subscribe(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *topics);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_unsubscribe(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_subscription(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **topics);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consumer_poll(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_consumer_close(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_consumer_close_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu);</span>
<span class="s1">int rd_kafka_consumer_closed(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_incremental_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_incremental_unassign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">const char *rd_kafka_rebalance_protocol(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_assignment(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **partitions);</span>
<span class="s1">int rd_kafka_assignment_lost(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, int async);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit_message(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, int async);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit_queue(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_queue_t *rkqu, void (*cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *commit_opaque), void *commit_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_committed(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_position(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata_new(const char *group_id);</span>
<span class="s1">rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata_new_with_genid(const char *group_id, int32_t generation_id, const char *member_id, const char *group_instance_id);</span>
<span class="s1">const char *rd_kafka_consumer_group_metadata_member_id(const rd_kafka_consumer_group_metadata_t *group_metadata);</span>
<span class="s1">void rd_kafka_consumer_group_metadata_destroy(rd_kafka_consumer_group_metadata_t *);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_consumer_group_metadata_write(const rd_kafka_consumer_group_metadata_t *cgmd, void **bufferp, size_t *sizep);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_consumer_group_metadata_read(rd_kafka_consumer_group_metadata_t **cgmdp, const void *buffer, size_t size);</span>
<span class="s1">int rd_kafka_produce(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, void *payload, size_t len, const void *key, size_t keylen, void *msg_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_producev(rd_kafka_t *rk, ...);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_produceva(rd_kafka_t *rk, const rd_kafka_vu_t *vus, size_t cnt);</span>
<span class="s1">int rd_kafka_produce_batch(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, rd_kafka_message_t *rkmessages, int message_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_flush(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_purge(rd_kafka_t *rk, int purge_flags);</span>
<span class="s1">typedef struct rd_kafka_metadata_broker {</span>
<span class="s1">  int32_t id;</span>
<span class="s1">  char *host;</span>
<span class="s1">  int port;</span>
<span class="s1">} rd_kafka_metadata_broker_t;</span>
<span class="s1">typedef struct rd_kafka_metadata_partition {</span>
<span class="s1">  int32_t id;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  int32_t leader;</span>
<span class="s1">  int replica_cnt;</span>
<span class="s1">  int32_t *replicas;</span>
<span class="s1">  int isr_cnt;</span>
<span class="s1">  int32_t *isrs;</span>
<span class="s1">} rd_kafka_metadata_partition_t;</span>
<span class="s1">typedef struct rd_kafka_metadata_topic {</span>
<span class="s1">  char *topic;</span>
<span class="s1">  int partition_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_partition *partitions;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">} rd_kafka_metadata_topic_t;</span>
<span class="s1">typedef struct rd_kafka_metadata {</span>
<span class="s1">  int broker_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_broker *brokers;</span>
<span class="s1">  int topic_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_topic *topics;</span>
<span class="s1">  int32_t orig_broker_id;</span>
<span class="s1">  char *orig_broker_name;</span>
<span class="s1">} rd_kafka_metadata_t;</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_metadata(rd_kafka_t *rk, int all_topics, rd_kafka_topic_t *only_rkt, const struct rd_kafka_metadata **metadatap, int timeout_ms);</span>
<span class="s1">void rd_kafka_metadata_destroy(const struct rd_kafka_metadata *metadata);</span>
<span class="s1">typedef struct rd_kafka_Node_s rd_kafka_Node_t;</span>
<span class="s1">int rd_kafka_Node_id(const rd_kafka_Node_t *node);</span>
<span class="s1">const char *rd_kafka_Node_host(const rd_kafka_Node_t *node);</span>
<span class="s1">uint16_t rd_kafka_Node_port(const rd_kafka_Node_t *node);</span>
<span class="s1">const char *rd_kafka_Node_rack(const rd_kafka_Node_t *node);</span>
<span class="s1">struct rd_kafka_group_member_info {</span>
<span class="s1">  char *member_id;</span>
<span class="s1">  char *client_id;</span>
<span class="s1">  char *client_host;</span>
<span class="s1">  void *member_metadata;</span>
<span class="s1">  int member_metadata_size;</span>
<span class="s1">  void *member_assignment;</span>
<span class="s1">  int member_assignment_size;</span>
<span class="s1">};</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_CONSUMER_GROUP_STATE_UNKNOWN = 0,</span>
<span class="s1">  RD_KAFKA_CONSUMER_GROUP_STATE_PREPARING_REBALANCE = 1,</span>
<span class="s1">  RD_KAFKA_CONSUMER_GROUP_STATE_COMPLETING_REBALANCE = 2,</span>
<span class="s1">  RD_KAFKA_CONSUMER_GROUP_STATE_STABLE = 3,</span>
<span class="s1">  RD_KAFKA_CONSUMER_GROUP_STATE_DEAD = 4,</span>
<span class="s1">  RD_KAFKA_CONSUMER_GROUP_STATE_EMPTY = 5,</span>
<span class="s1">  RD_KAFKA_CONSUMER_GROUP_STATE__CNT,</span>
<span class="s1">} rd_kafka_consumer_group_state_t;</span>
<span class="s1">struct rd_kafka_group_info {</span>
<span class="s1">  struct rd_kafka_metadata_broker broker;</span>
<span class="s1">  char *group;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  char *state;</span>
<span class="s1">  char *protocol_type;</span>
<span class="s1">  char *protocol;</span>
<span class="s1">  struct rd_kafka_group_member_info *members;</span>
<span class="s1">  int member_cnt;</span>
<span class="s1">};</span>
<span class="s1">struct rd_kafka_group_list {</span>
<span class="s1">  struct rd_kafka_group_info *groups;</span>
<span class="s1">  int group_cnt;</span>
<span class="s1">};</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_list_groups(rd_kafka_t *rk, const char *group, const struct rd_kafka_group_list **grplistp, int timeout_ms);</span>
<span class="s1">const char *rd_kafka_consumer_group_state_name(rd_kafka_consumer_group_state_t state);</span>
<span class="s1">rd_kafka_consumer_group_state_t rd_kafka_consumer_group_state_code(const char *name);</span>
<span class="s1">void rd_kafka_group_list_destroy(const struct rd_kafka_group_list *grplist);</span>
<span class="s1">int rd_kafka_brokers_add(rd_kafka_t *rk, const char *brokerlist);</span>
<span class="s1">void rd_kafka_set_logger(rd_kafka_t *rk, void (*func)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));</span>
<span class="s1">void rd_kafka_set_log_level(rd_kafka_t *rk, int level);</span>
<span class="s1">void rd_kafka_log_print(const rd_kafka_t *rk, int level, const char *fac, const char *buf);</span>
<span class="s1">void rd_kafka_log_syslog(const rd_kafka_t *rk, int level, const char *fac, const char *buf);</span>
<span class="s1">int rd_kafka_outq_len(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_dump(FILE *fp, rd_kafka_t *rk);</span>
<span class="s1">int rd_kafka_thread_cnt(void);</span>
<span class="s1">typedef enum rd_kafka_thread_type_t {</span>
<span class="s1">  RD_KAFKA_THREAD_MAIN,</span>
<span class="s1">  RD_KAFKA_THREAD_BACKGROUND,</span>
<span class="s1">  RD_KAFKA_THREAD_BROKER,</span>
<span class="s1">} rd_kafka_thread_type_t;</span>
<span class="s1">int rd_kafka_wait_destroyed(int timeout_ms);</span>
<span class="s1">int rd_kafka_unittest(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_poll_set_consumer(rd_kafka_t *rk);</span>
<span class="s1">typedef int rd_kafka_event_type_t;</span>
<span class="s1">rd_kafka_event_type_t rd_kafka_event_type(const rd_kafka_event_t *rkev);</span>
<span class="s1">const char *rd_kafka_event_name(const rd_kafka_event_t *rkev);</span>
<span class="s1">void rd_kafka_event_destroy(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_message_t *rd_kafka_event_message_next(rd_kafka_event_t *rkev);</span>
<span class="s1">size_t rd_kafka_event_message_array(rd_kafka_event_t *rkev, const rd_kafka_message_t **rkmessages, size_t size);</span>
<span class="s1">size_t rd_kafka_event_message_count(rd_kafka_event_t *rkev);</span>
<span class="s1">const char *rd_kafka_event_config_string(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_event_error(rd_kafka_event_t *rkev);</span>
<span class="s1">const char *rd_kafka_event_error_string(rd_kafka_event_t *rkev);</span>
<span class="s1">int rd_kafka_event_error_is_fatal(rd_kafka_event_t *rkev);</span>
<span class="s1">void *rd_kafka_event_opaque(rd_kafka_event_t *rkev);</span>
<span class="s1">int rd_kafka_event_log(rd_kafka_event_t *rkev, const char **fac, const char **str, int *level);</span>
<span class="s1">int rd_kafka_event_debug_contexts(rd_kafka_event_t *rkev, char *dst, size_t dstsize);</span>
<span class="s1">const char *rd_kafka_event_stats(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_event_topic_partition_list(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_event_topic_partition(rd_kafka_event_t *rkev);</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_CreateTopics_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DeleteTopics_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_CreateAcls_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DescribeAcls_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DeleteAcls_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_CreatePartitions_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_AlterConfigs_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_IncrementalAlterConfigs_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DescribeConfigs_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DeleteRecords_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_ListConsumerGroups_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DescribeConsumerGroups_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DeleteGroups_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DeleteConsumerGroupOffsets_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_AlterConsumerGroupOffsets_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_ListConsumerGroupOffsets_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DescribeTopics_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DescribeCluster_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DescribeUserScramCredentials_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_AlterUserScramCredentials_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_ListOffsets_result_t;</span>
<span class="s1">const rd_kafka_CreateTopics_result_t *rd_kafka_event_CreateTopics_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DeleteTopics_result_t *rd_kafka_event_DeleteTopics_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_CreatePartitions_result_t *rd_kafka_event_CreatePartitions_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_AlterConfigs_result_t *rd_kafka_event_AlterConfigs_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_IncrementalAlterConfigs_result_t *rd_kafka_event_IncrementalAlterConfigs_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DescribeConfigs_result_t *rd_kafka_event_DescribeConfigs_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DeleteRecords_result_t *rd_kafka_event_DeleteRecords_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_ListConsumerGroups_result_t *rd_kafka_event_ListConsumerGroups_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DescribeConsumerGroups_result_t *rd_kafka_event_DescribeConsumerGroups_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DescribeTopics_result_t *rd_kafka_event_DescribeTopics_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DescribeCluster_result_t *rd_kafka_event_DescribeCluster_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DeleteGroups_result_t *rd_kafka_event_DeleteGroups_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DeleteConsumerGroupOffsets_result_t *rd_kafka_event_DeleteConsumerGroupOffsets_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_CreateAcls_result_t *rd_kafka_event_CreateAcls_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DescribeAcls_result_t *rd_kafka_event_DescribeAcls_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DeleteAcls_result_t *rd_kafka_event_DeleteAcls_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_ListConsumerGroupOffsets_result_t *rd_kafka_event_ListConsumerGroupOffsets_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_AlterConsumerGroupOffsets_result_t *rd_kafka_event_AlterConsumerGroupOffsets_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_ListOffsets_result_t *rd_kafka_event_ListOffsets_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DescribeUserScramCredentials_result_t *rd_kafka_event_DescribeUserScramCredentials_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_AlterUserScramCredentials_result_t *rd_kafka_event_AlterUserScramCredentials_result(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_event_t *rd_kafka_queue_poll(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">int rd_kafka_queue_poll_callback(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_plugin_f_conf_init_t)(rd_kafka_conf_t *conf, void **plug_opaquep, char *errstr, size_t errstr_size);</span>
<span class="s1">typedef rd_kafka_conf_res_t (rd_kafka_interceptor_f_on_conf_set_t)(rd_kafka_conf_t *conf, const char *name, const char *val, char *errstr, size_t errstr_size, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_dup_t)(rd_kafka_conf_t *new_conf, const rd_kafka_conf_t *old_conf, size_t filter_cnt, const char **filter, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_destroy_t)(void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_new_t)(rd_kafka_t *rk, const rd_kafka_conf_t *conf, void *ic_opaque, char *errstr, size_t errstr_size);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_destroy_t)(rd_kafka_t *rk, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_send_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_acknowledgement_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_consume_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_commit_t)(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_resp_err_t err, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_request_sent_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_response_received_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, int64_t rtt, rd_kafka_resp_err_t err, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_start_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_exit_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_broker_state_change_t)(rd_kafka_t *rk, int32_t broker_id, const char *secproto, const char *name, int port, const char *state, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_set(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_set_t *on_conf_set, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_dup(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_dup_t *on_conf_dup, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_destroy(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_destroy_t *on_conf_destroy, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_new(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_new_t *on_new, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_destroy(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_destroy_t *on_destroy, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_send(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_send_t *on_send, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_acknowledgement(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_acknowledgement_t *on_acknowledgement, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_consume(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_consume_t *on_consume, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_commit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_commit_t *on_commit, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_request_sent(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_request_sent_t *on_request_sent, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_response_received(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_response_received_t *on_response_received, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_start(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_start_t *on_thread_start, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_exit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_exit_t *on_thread_exit, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_broker_state_change(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_broker_state_change_t *on_broker_state_change, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_topic_result_error(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">const char *rd_kafka_topic_result_error_string(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">const char *rd_kafka_topic_result_name(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">const rd_kafka_error_t *rd_kafka_group_result_error(const rd_kafka_group_result_t *groupres);</span>
<span class="s1">const char *rd_kafka_group_result_name(const rd_kafka_group_result_t *groupres);</span>
<span class="s1">const rd_kafka_topic_partition_list_t *rd_kafka_group_result_partitions(const rd_kafka_group_result_t *groupres);</span>
<span class="s1">typedef enum rd_kafka_admin_op_t {</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_ANY = 0,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_CREATETOPICS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DELETETOPICS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_CREATEPARTITIONS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_ALTERCONFIGS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DESCRIBECONFIGS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DELETERECORDS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DELETEGROUPS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DELETECONSUMERGROUPOFFSETS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_CREATEACLS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DESCRIBEACLS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DELETEACLS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_LISTCONSUMERGROUPS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DESCRIBECONSUMERGROUPS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_LISTCONSUMERGROUPOFFSETS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_ALTERCONSUMERGROUPOFFSETS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_INCREMENTALALTERCONFIGS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DESCRIBEUSERSCRAMCREDENTIALS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_ALTERUSERSCRAMCREDENTIALS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DESCRIBETOPICS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DESCRIBECLUSTER,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_LISTOFFSETS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP__CNT,</span>
<span class="s1">} rd_kafka_admin_op_t;</span>
<span class="s1">typedef struct rd_kafka_AdminOptions_s rd_kafka_AdminOptions_t;</span>
<span class="s1">typedef enum rd_kafka_IsolationLevel_t {</span>
<span class="s1">  RD_KAFKA_ISOLATION_LEVEL_READ_UNCOMMITTED = 0,</span>
<span class="s1">  RD_KAFKA_ISOLATION_LEVEL_READ_COMMITTED = 1,</span>
<span class="s1">} rd_kafka_IsolationLevel_t;</span>
<span class="s1">rd_kafka_AdminOptions_t *rd_kafka_AdminOptions_new(rd_kafka_t *rk, rd_kafka_admin_op_t for_api);</span>
<span class="s1">void rd_kafka_AdminOptions_destroy(rd_kafka_AdminOptions_t *options);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_request_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_operation_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_validate_only(rd_kafka_AdminOptions_t *options, int true_or_false, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_broker(rd_kafka_AdminOptions_t *options, int32_t broker_id, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_AdminOptions_set_require_stable_offsets(rd_kafka_AdminOptions_t *options, int true_or_false);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_AdminOptions_set_include_authorized_operations(rd_kafka_AdminOptions_t *options, int true_or_false);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_AdminOptions_set_match_consumer_group_states(rd_kafka_AdminOptions_t *options, const rd_kafka_consumer_group_state_t *consumer_group_states, size_t consumer_group_states_cnt);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_AdminOptions_set_isolation_level(rd_kafka_AdminOptions_t *options, rd_kafka_IsolationLevel_t value);</span>
<span class="s1">void rd_kafka_AdminOptions_set_opaque(rd_kafka_AdminOptions_t *options, void *ev_opaque);</span>
<span class="s1">typedef enum rd_kafka_AclOperation_t {</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_UNKNOWN = 0,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_ANY = 1,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_ALL = 2,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_READ = 3,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_WRITE = 4,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_CREATE = 5,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_DELETE = 6,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_ALTER = 7,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_DESCRIBE = 8,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_CLUSTER_ACTION = 9,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_DESCRIBE_CONFIGS = 10,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_ALTER_CONFIGS = 11,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_IDEMPOTENT_WRITE = 12,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION__CNT,</span>
<span class="s1">} rd_kafka_AclOperation_t;</span>
<span class="s1">typedef struct rd_kafka_NewTopic_s rd_kafka_NewTopic_t;</span>
<span class="s1">rd_kafka_NewTopic_t *rd_kafka_NewTopic_new(const char *topic, int num_partitions, int replication_factor, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_NewTopic_destroy(rd_kafka_NewTopic_t *new_topic);</span>
<span class="s1">void rd_kafka_NewTopic_destroy_array(rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewTopic_set_replica_assignment(rd_kafka_NewTopic_t *new_topic, int32_t partition, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewTopic_set_config(rd_kafka_NewTopic_t *new_topic, const char *name, const char *value);</span>
<span class="s1">void rd_kafka_CreateTopics(rd_kafka_t *rk, rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_CreateTopics_result_topics(const rd_kafka_CreateTopics_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_DeleteTopic_s rd_kafka_DeleteTopic_t;</span>
<span class="s1">rd_kafka_DeleteTopic_t *rd_kafka_DeleteTopic_new(const char *topic);</span>
<span class="s1">void rd_kafka_DeleteTopic_destroy(rd_kafka_DeleteTopic_t *del_topic);</span>
<span class="s1">void rd_kafka_DeleteTopic_destroy_array(rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt);</span>
<span class="s1">void rd_kafka_DeleteTopics(rd_kafka_t *rk, rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_DeleteTopics_result_topics(const rd_kafka_DeleteTopics_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_NewPartitions_s rd_kafka_NewPartitions_t;</span>
<span class="s1">rd_kafka_NewPartitions_t *rd_kafka_NewPartitions_new(const char *topic, size_t new_total_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_NewPartitions_destroy(rd_kafka_NewPartitions_t *new_parts);</span>
<span class="s1">void rd_kafka_NewPartitions_destroy_array(rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewPartitions_set_replica_assignment(rd_kafka_NewPartitions_t *new_parts, int32_t new_partition_idx, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_CreatePartitions(rd_kafka_t *rk, rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_CreatePartitions_result_topics(const rd_kafka_CreatePartitions_result_t *result, size_t *cntp);</span>
<span class="s1">typedef enum rd_kafka_ConfigSource_t {</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_UNKNOWN_CONFIG = 0,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_TOPIC_CONFIG = 1,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_BROKER_CONFIG = 2,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_DEFAULT_BROKER_CONFIG = 3,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_STATIC_BROKER_CONFIG = 4,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DEFAULT_CONFIG = 5,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE__CNT,</span>
<span class="s1">} rd_kafka_ConfigSource_t;</span>
<span class="s1">const char *rd_kafka_ConfigSource_name(rd_kafka_ConfigSource_t confsource);</span>
<span class="s1">typedef struct rd_kafka_ConfigEntry_s rd_kafka_ConfigEntry_t;</span>
<span class="s1">const char *rd_kafka_ConfigEntry_name(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">const char *rd_kafka_ConfigEntry_value(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">rd_kafka_ConfigSource_t rd_kafka_ConfigEntry_source(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_read_only(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_default(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_sensitive(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_synonym(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">const rd_kafka_ConfigEntry_t **rd_kafka_ConfigEntry_synonyms(const rd_kafka_ConfigEntry_t *entry, size_t *cntp);</span>
<span class="s1">typedef enum rd_kafka_ResourceType_t {</span>
<span class="s1">  RD_KAFKA_RESOURCE_UNKNOWN = 0,</span>
<span class="s1">  RD_KAFKA_RESOURCE_ANY = 1,</span>
<span class="s1">  RD_KAFKA_RESOURCE_TOPIC = 2,</span>
<span class="s1">  RD_KAFKA_RESOURCE_GROUP = 3,</span>
<span class="s1">  RD_KAFKA_RESOURCE_BROKER = 4,</span>
<span class="s1">  RD_KAFKA_RESOURCE__CNT,</span>
<span class="s1">} rd_kafka_ResourceType_t;</span>
<span class="s1">typedef enum rd_kafka_ResourcePatternType_t {</span>
<span class="s1">  RD_KAFKA_RESOURCE_PATTERN_UNKNOWN = 0,</span>
<span class="s1">  RD_KAFKA_RESOURCE_PATTERN_ANY = 1,</span>
<span class="s1">  RD_KAFKA_RESOURCE_PATTERN_MATCH = 2,</span>
<span class="s1">  RD_KAFKA_RESOURCE_PATTERN_LITERAL = 3,</span>
<span class="s1">  RD_KAFKA_RESOURCE_PATTERN_PREFIXED = 4,</span>
<span class="s1">  RD_KAFKA_RESOURCE_PATTERN_TYPE__CNT,</span>
<span class="s1">} rd_kafka_ResourcePatternType_t;</span>
<span class="s1">typedef enum rd_kafka_AlterConfigOpType_t {</span>
<span class="s1">  RD_KAFKA_ALTER_CONFIG_OP_TYPE_SET = 0,</span>
<span class="s1">  RD_KAFKA_ALTER_CONFIG_OP_TYPE_DELETE = 1,</span>
<span class="s1">  RD_KAFKA_ALTER_CONFIG_OP_TYPE_APPEND = 2,</span>
<span class="s1">  RD_KAFKA_ALTER_CONFIG_OP_TYPE_SUBTRACT = 3,</span>
<span class="s1">  RD_KAFKA_ALTER_CONFIG_OP_TYPE__CNT,</span>
<span class="s1">} rd_kafka_AlterConfigOpType_t;</span>
<span class="s1">const char *rd_kafka_ResourcePatternType_name(rd_kafka_ResourcePatternType_t resource_pattern_type);</span>
<span class="s1">const char *rd_kafka_ResourceType_name(rd_kafka_ResourceType_t restype);</span>
<span class="s1">typedef struct rd_kafka_ConfigResource_s rd_kafka_ConfigResource_t;</span>
<span class="s1">rd_kafka_ConfigResource_t *rd_kafka_ConfigResource_new(rd_kafka_ResourceType_t restype, const char *resname);</span>
<span class="s1">void rd_kafka_ConfigResource_destroy(rd_kafka_ConfigResource_t *config);</span>
<span class="s1">void rd_kafka_ConfigResource_destroy_array(rd_kafka_ConfigResource_t **config, size_t config_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_ConfigResource_set_config(rd_kafka_ConfigResource_t *config, const char *name, const char *value);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_ConfigResource_add_incremental_config(rd_kafka_ConfigResource_t *config, const char *name, rd_kafka_AlterConfigOpType_t op_type, const char *value);</span>
<span class="s1">const rd_kafka_ConfigEntry_t **rd_kafka_ConfigResource_configs(const rd_kafka_ConfigResource_t *config, size_t *cntp);</span>
<span class="s1">rd_kafka_ResourceType_t rd_kafka_ConfigResource_type(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">const char *rd_kafka_ConfigResource_name(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_ConfigResource_error(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">const char *rd_kafka_ConfigResource_error_string(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">void rd_kafka_AlterConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_ConfigResource_t **rd_kafka_AlterConfigs_result_resources(const rd_kafka_AlterConfigs_result_t *result, size_t *cntp);</span>
<span class="s1">void rd_kafka_IncrementalAlterConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_ConfigResource_t **rd_kafka_IncrementalAlterConfigs_result_resources(const rd_kafka_IncrementalAlterConfigs_result_t *result, size_t *cntp);</span>
<span class="s1">void rd_kafka_DescribeConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_ConfigResource_t **rd_kafka_DescribeConfigs_result_resources(const rd_kafka_DescribeConfigs_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_DeleteRecords_s rd_kafka_DeleteRecords_t;</span>
<span class="s1">rd_kafka_DeleteRecords_t *rd_kafka_DeleteRecords_new(const rd_kafka_topic_partition_list_t *before_offsets);</span>
<span class="s1">void rd_kafka_DeleteRecords_destroy(rd_kafka_DeleteRecords_t *del_records);</span>
<span class="s1">void rd_kafka_DeleteRecords_destroy_array(rd_kafka_DeleteRecords_t **del_records, size_t del_record_cnt);</span>
<span class="s1">void rd_kafka_DeleteRecords(rd_kafka_t *rk, rd_kafka_DeleteRecords_t **del_records, size_t del_record_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_partition_list_t *rd_kafka_DeleteRecords_result_offsets(const rd_kafka_DeleteRecords_result_t *result);</span>
<span class="s1">typedef struct rd_kafka_TopicCollection_s rd_kafka_TopicCollection_t;</span>
<span class="s1">typedef struct rd_kafka_TopicPartitionInfo_s rd_kafka_TopicPartitionInfo_t;</span>
<span class="s1">typedef struct rd_kafka_TopicDescription_s rd_kafka_TopicDescription_t;</span>
<span class="s1">rd_kafka_TopicCollection_t *rd_kafka_TopicCollection_of_topic_names(const char **topics, size_t topics_cnt);</span>
<span class="s1">void rd_kafka_TopicCollection_destroy(rd_kafka_TopicCollection_t *topics);</span>
<span class="s1">void rd_kafka_DescribeTopics(rd_kafka_t *rk, const rd_kafka_TopicCollection_t *topics, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_TopicDescription_t **rd_kafka_DescribeTopics_result_topics(const rd_kafka_DescribeTopics_result_t *result, size_t *cntp);</span>
<span class="s1">const rd_kafka_TopicPartitionInfo_t **rd_kafka_TopicDescription_partitions(const rd_kafka_TopicDescription_t *topicdesc, size_t *cntp);</span>
<span class="s1">const int rd_kafka_TopicPartitionInfo_partition(const rd_kafka_TopicPartitionInfo_t *partition);</span>
<span class="s1">const rd_kafka_Node_t *rd_kafka_TopicPartitionInfo_leader(const rd_kafka_TopicPartitionInfo_t *partition);</span>
<span class="s1">const rd_kafka_Node_t **rd_kafka_TopicPartitionInfo_isr(const rd_kafka_TopicPartitionInfo_t *partition, size_t *cntp);</span>
<span class="s1">const rd_kafka_Node_t **rd_kafka_TopicPartitionInfo_replicas(const rd_kafka_TopicPartitionInfo_t *partition, size_t *cntp);</span>
<span class="s1">const rd_kafka_AclOperation_t *rd_kafka_TopicDescription_authorized_operations(const rd_kafka_TopicDescription_t *topicdesc, size_t *cntp);</span>
<span class="s1">const char *rd_kafka_TopicDescription_name(const rd_kafka_TopicDescription_t *topicdesc);</span>
<span class="s1">const rd_kafka_Uuid_t *rd_kafka_TopicDescription_topic_id(const rd_kafka_TopicDescription_t *topicdesc);</span>
<span class="s1">int rd_kafka_TopicDescription_is_internal(const rd_kafka_TopicDescription_t *topicdesc);</span>
<span class="s1">const rd_kafka_error_t *rd_kafka_TopicDescription_error(const rd_kafka_TopicDescription_t *topicdesc);</span>
<span class="s1">void rd_kafka_DescribeCluster(rd_kafka_t *rk, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_Node_t **rd_kafka_DescribeCluster_result_nodes(const rd_kafka_DescribeCluster_result_t *result, size_t *cntp);</span>
<span class="s1">const rd_kafka_AclOperation_t *rd_kafka_DescribeCluster_result_authorized_operations(const rd_kafka_DescribeCluster_result_t *result, size_t *cntp);</span>
<span class="s1">const rd_kafka_Node_t *rd_kafka_DescribeCluster_result_controller(const rd_kafka_DescribeCluster_result_t *result);</span>
<span class="s1">const char *rd_kafka_DescribeCluster_result_cluster_id(const rd_kafka_DescribeCluster_result_t *result);</span>
<span class="s1">typedef struct rd_kafka_ConsumerGroupListing_s rd_kafka_ConsumerGroupListing_t;</span>
<span class="s1">typedef struct rd_kafka_ListConsumerGroupsResult_s rd_kafka_ListConsumerGroupsResult_t;</span>
<span class="s1">void rd_kafka_ListConsumerGroups(rd_kafka_t *rk, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const char *rd_kafka_ConsumerGroupListing_group_id(const rd_kafka_ConsumerGroupListing_t *grplist);</span>
<span class="s1">int rd_kafka_ConsumerGroupListing_is_simple_consumer_group(const rd_kafka_ConsumerGroupListing_t *grplist);</span>
<span class="s1">rd_kafka_consumer_group_state_t rd_kafka_ConsumerGroupListing_state(const rd_kafka_ConsumerGroupListing_t *grplist);</span>
<span class="s1">const rd_kafka_ConsumerGroupListing_t **rd_kafka_ListConsumerGroups_result_valid(const rd_kafka_ListConsumerGroups_result_t *result, size_t *cntp);</span>
<span class="s1">const rd_kafka_error_t **rd_kafka_ListConsumerGroups_result_errors(const rd_kafka_ListConsumerGroups_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_ConsumerGroupDescription_s rd_kafka_ConsumerGroupDescription_t;</span>
<span class="s1">typedef struct rd_kafka_MemberDescription_s rd_kafka_MemberDescription_t;</span>
<span class="s1">typedef struct rd_kafka_MemberAssignment_s rd_kafka_MemberAssignment_t;</span>
<span class="s1">void rd_kafka_DescribeConsumerGroups(rd_kafka_t *rk, const char **groups, size_t groups_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_ConsumerGroupDescription_t **rd_kafka_DescribeConsumerGroups_result_groups(const rd_kafka_DescribeConsumerGroups_result_t *result, size_t *cntp);</span>
<span class="s1">const char *rd_kafka_ConsumerGroupDescription_group_id(const rd_kafka_ConsumerGroupDescription_t *grpdesc);</span>
<span class="s1">const rd_kafka_error_t *rd_kafka_ConsumerGroupDescription_error(const rd_kafka_ConsumerGroupDescription_t *grpdesc);</span>
<span class="s1">int rd_kafka_ConsumerGroupDescription_is_simple_consumer_group(const rd_kafka_ConsumerGroupDescription_t *grpdesc);</span>
<span class="s1">const char *rd_kafka_ConsumerGroupDescription_partition_assignor(const rd_kafka_ConsumerGroupDescription_t *grpdesc);</span>
<span class="s1">const rd_kafka_AclOperation_t *rd_kafka_ConsumerGroupDescription_authorized_operations(const rd_kafka_ConsumerGroupDescription_t *grpdesc, size_t *cntp);</span>
<span class="s1">rd_kafka_consumer_group_state_t rd_kafka_ConsumerGroupDescription_state(const rd_kafka_ConsumerGroupDescription_t *grpdesc);</span>
<span class="s1">const rd_kafka_Node_t *rd_kafka_ConsumerGroupDescription_coordinator(const rd_kafka_ConsumerGroupDescription_t *grpdesc);</span>
<span class="s1">size_t rd_kafka_ConsumerGroupDescription_member_count(const rd_kafka_ConsumerGroupDescription_t *grpdesc);</span>
<span class="s1">const rd_kafka_MemberDescription_t *rd_kafka_ConsumerGroupDescription_member(const rd_kafka_ConsumerGroupDescription_t *grpdesc, size_t idx);</span>
<span class="s1">const char *rd_kafka_MemberDescription_client_id(const rd_kafka_MemberDescription_t *member);</span>
<span class="s1">const char *rd_kafka_MemberDescription_group_instance_id(const rd_kafka_MemberDescription_t *member);</span>
<span class="s1">const char *rd_kafka_MemberDescription_consumer_id(const rd_kafka_MemberDescription_t *member);</span>
<span class="s1">const char *rd_kafka_MemberDescription_host(const rd_kafka_MemberDescription_t *member);</span>
<span class="s1">const rd_kafka_MemberAssignment_t *rd_kafka_MemberDescription_assignment(const rd_kafka_MemberDescription_t *member);</span>
<span class="s1">const rd_kafka_topic_partition_list_t *rd_kafka_MemberAssignment_partitions(const rd_kafka_MemberAssignment_t *assignment);</span>
<span class="s1">typedef struct rd_kafka_DeleteGroup_s rd_kafka_DeleteGroup_t;</span>
<span class="s1">rd_kafka_DeleteGroup_t *rd_kafka_DeleteGroup_new(const char *group);</span>
<span class="s1">void rd_kafka_DeleteGroup_destroy(rd_kafka_DeleteGroup_t *del_group);</span>
<span class="s1">void rd_kafka_DeleteGroup_destroy_array(rd_kafka_DeleteGroup_t **del_groups, size_t del_group_cnt);</span>
<span class="s1">void rd_kafka_DeleteGroups(rd_kafka_t *rk, rd_kafka_DeleteGroup_t **del_groups, size_t del_group_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_group_result_t **rd_kafka_DeleteGroups_result_groups(const rd_kafka_DeleteGroups_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_ListConsumerGroupOffsets_s rd_kafka_ListConsumerGroupOffsets_t;</span>
<span class="s1">rd_kafka_ListConsumerGroupOffsets_t *rd_kafka_ListConsumerGroupOffsets_new(const char *group_id, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">void rd_kafka_ListConsumerGroupOffsets_destroy(rd_kafka_ListConsumerGroupOffsets_t *list_grpoffsets);</span>
<span class="s1">void rd_kafka_ListConsumerGroupOffsets_destroy_array(rd_kafka_ListConsumerGroupOffsets_t **list_grpoffsets, size_t list_grpoffset_cnt);</span>
<span class="s1">void rd_kafka_ListConsumerGroupOffsets(rd_kafka_t *rk, rd_kafka_ListConsumerGroupOffsets_t **list_grpoffsets, size_t list_grpoffsets_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_group_result_t **rd_kafka_ListConsumerGroupOffsets_result_groups(const rd_kafka_ListConsumerGroupOffsets_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_AlterConsumerGroupOffsets_s rd_kafka_AlterConsumerGroupOffsets_t;</span>
<span class="s1">rd_kafka_AlterConsumerGroupOffsets_t *rd_kafka_AlterConsumerGroupOffsets_new(const char *group_id, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">void rd_kafka_AlterConsumerGroupOffsets_destroy(rd_kafka_AlterConsumerGroupOffsets_t *alter_grpoffsets);</span>
<span class="s1">void rd_kafka_AlterConsumerGroupOffsets_destroy_array(rd_kafka_AlterConsumerGroupOffsets_t **alter_grpoffsets, size_t alter_grpoffset_cnt);</span>
<span class="s1">void rd_kafka_AlterConsumerGroupOffsets(rd_kafka_t *rk, rd_kafka_AlterConsumerGroupOffsets_t **alter_grpoffsets, size_t alter_grpoffsets_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_group_result_t **rd_kafka_AlterConsumerGroupOffsets_result_groups(const rd_kafka_AlterConsumerGroupOffsets_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_DeleteConsumerGroupOffsets_s rd_kafka_DeleteConsumerGroupOffsets_t;</span>
<span class="s1">rd_kafka_DeleteConsumerGroupOffsets_t *rd_kafka_DeleteConsumerGroupOffsets_new(const char *group, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">void rd_kafka_DeleteConsumerGroupOffsets_destroy(rd_kafka_DeleteConsumerGroupOffsets_t *del_grpoffsets);</span>
<span class="s1">void rd_kafka_DeleteConsumerGroupOffsets_destroy_array(rd_kafka_DeleteConsumerGroupOffsets_t **del_grpoffsets, size_t del_grpoffset_cnt);</span>
<span class="s1">void rd_kafka_DeleteConsumerGroupOffsets(rd_kafka_t *rk, rd_kafka_DeleteConsumerGroupOffsets_t **del_grpoffsets, size_t del_grpoffsets_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_group_result_t **rd_kafka_DeleteConsumerGroupOffsets_result_groups(const rd_kafka_DeleteConsumerGroupOffsets_result_t *result, size_t *cntp);</span>
<span class="s1">typedef enum rd_kafka_OffsetSpec_t {</span>
<span class="s1">  RD_KAFKA_OFFSET_SPEC_MAX_TIMESTAMP = (- 3),</span>
<span class="s1">  RD_KAFKA_OFFSET_SPEC_EARLIEST = (- 2),</span>
<span class="s1">  RD_KAFKA_OFFSET_SPEC_LATEST = (- 1),</span>
<span class="s1">} rd_kafka_OffsetSpec_t;</span>
<span class="s1">typedef struct rd_kafka_ListOffsetsResultInfo_s rd_kafka_ListOffsetsResultInfo_t;</span>
<span class="s1">const rd_kafka_topic_partition_t *rd_kafka_ListOffsetsResultInfo_topic_partition(const rd_kafka_ListOffsetsResultInfo_t *result_info);</span>
<span class="s1">int64_t rd_kafka_ListOffsetsResultInfo_timestamp(const rd_kafka_ListOffsetsResultInfo_t *result_info);</span>
<span class="s1">const rd_kafka_ListOffsetsResultInfo_t **rd_kafka_ListOffsets_result_infos(const rd_kafka_ListOffsets_result_t *result, size_t *cntp);</span>
<span class="s1">void rd_kafka_ListOffsets(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *topic_partitions, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">typedef enum rd_kafka_ScramMechanism_t {</span>
<span class="s1">  RD_KAFKA_SCRAM_MECHANISM_UNKNOWN = 0,</span>
<span class="s1">  RD_KAFKA_SCRAM_MECHANISM_SHA_256 = 1,</span>
<span class="s1">  RD_KAFKA_SCRAM_MECHANISM_SHA_512 = 2,</span>
<span class="s1">  RD_KAFKA_SCRAM_MECHANISM__CNT,</span>
<span class="s1">} rd_kafka_ScramMechanism_t;</span>
<span class="s1">typedef struct rd_kafka_ScramCredentialInfo_s rd_kafka_ScramCredentialInfo_t;</span>
<span class="s1">rd_kafka_ScramMechanism_t rd_kafka_ScramCredentialInfo_mechanism(const rd_kafka_ScramCredentialInfo_t *scram_credential_info);</span>
<span class="s1">int32_t rd_kafka_ScramCredentialInfo_iterations(const rd_kafka_ScramCredentialInfo_t *scram_credential_info);</span>
<span class="s1">typedef struct rd_kafka_UserScramCredentialsDescription_s rd_kafka_UserScramCredentialsDescription_t;</span>
<span class="s1">const char *rd_kafka_UserScramCredentialsDescription_user(const rd_kafka_UserScramCredentialsDescription_t *description);</span>
<span class="s1">const rd_kafka_error_t *rd_kafka_UserScramCredentialsDescription_error(const rd_kafka_UserScramCredentialsDescription_t *description);</span>
<span class="s1">size_t rd_kafka_UserScramCredentialsDescription_scramcredentialinfo_count(const rd_kafka_UserScramCredentialsDescription_t *description);</span>
<span class="s1">const rd_kafka_ScramCredentialInfo_t *rd_kafka_UserScramCredentialsDescription_scramcredentialinfo(const rd_kafka_UserScramCredentialsDescription_t *description, size_t idx);</span>
<span class="s1">const rd_kafka_UserScramCredentialsDescription_t **rd_kafka_DescribeUserScramCredentials_result_descriptions(const rd_kafka_DescribeUserScramCredentials_result_t *result, size_t *cntp);</span>
<span class="s1">void rd_kafka_DescribeUserScramCredentials(rd_kafka_t *rk, const char **users, size_t user_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">typedef struct rd_kafka_UserScramCredentialAlteration_s rd_kafka_UserScramCredentialAlteration_t;</span>
<span class="s1">rd_kafka_UserScramCredentialAlteration_t *rd_kafka_UserScramCredentialUpsertion_new(const char *username, rd_kafka_ScramMechanism_t mechanism, int32_t iterations, const unsigned char *password, size_t password_size, const unsigned char *salt, size_t salt_size);</span>
<span class="s1">rd_kafka_UserScramCredentialAlteration_t *rd_kafka_UserScramCredentialDeletion_new(const char *username, rd_kafka_ScramMechanism_t mechanism);</span>
<span class="s1">void rd_kafka_UserScramCredentialAlteration_destroy(rd_kafka_UserScramCredentialAlteration_t *alteration);</span>
<span class="s1">void rd_kafka_UserScramCredentialAlteration_destroy_array(rd_kafka_UserScramCredentialAlteration_t **alterations, size_t alteration_cnt);</span>
<span class="s1">typedef struct rd_kafka_AlterUserScramCredentials_result_response_s rd_kafka_AlterUserScramCredentials_result_response_t;</span>
<span class="s1">const char *rd_kafka_AlterUserScramCredentials_result_response_user(const rd_kafka_AlterUserScramCredentials_result_response_t *response);</span>
<span class="s1">const rd_kafka_error_t *rd_kafka_AlterUserScramCredentials_result_response_error(const rd_kafka_AlterUserScramCredentials_result_response_t *response);</span>
<span class="s1">const rd_kafka_AlterUserScramCredentials_result_response_t **rd_kafka_AlterUserScramCredentials_result_responses(const rd_kafka_AlterUserScramCredentials_result_t *result, size_t *cntp);</span>
<span class="s1">void rd_kafka_AlterUserScramCredentials(rd_kafka_t *rk, rd_kafka_UserScramCredentialAlteration_t **alterations, size_t alteration_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">typedef struct rd_kafka_AclBinding_s rd_kafka_AclBinding_t;</span>
<span class="s1">typedef rd_kafka_AclBinding_t rd_kafka_AclBindingFilter_t;</span>
<span class="s1">const rd_kafka_error_t *rd_kafka_acl_result_error(const rd_kafka_acl_result_t *aclres);</span>
<span class="s1">const char *rd_kafka_AclOperation_name(rd_kafka_AclOperation_t acl_operation);</span>
<span class="s1">typedef enum rd_kafka_AclPermissionType_t {</span>
<span class="s1">  RD_KAFKA_ACL_PERMISSION_TYPE_UNKNOWN = 0,</span>
<span class="s1">  RD_KAFKA_ACL_PERMISSION_TYPE_ANY = 1,</span>
<span class="s1">  RD_KAFKA_ACL_PERMISSION_TYPE_DENY = 2,</span>
<span class="s1">  RD_KAFKA_ACL_PERMISSION_TYPE_ALLOW = 3,</span>
<span class="s1">  RD_KAFKA_ACL_PERMISSION_TYPE__CNT,</span>
<span class="s1">} rd_kafka_AclPermissionType_t;</span>
<span class="s1">const char *rd_kafka_AclPermissionType_name(rd_kafka_AclPermissionType_t acl_permission_type);</span>
<span class="s1">rd_kafka_AclBinding_t *rd_kafka_AclBinding_new(rd_kafka_ResourceType_t restype, const char *name, rd_kafka_ResourcePatternType_t resource_pattern_type, const char *principal, const char *host, rd_kafka_AclOperation_t operation, rd_kafka_AclPermissionType_t permission_type, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_AclBindingFilter_t *rd_kafka_AclBindingFilter_new(rd_kafka_ResourceType_t restype, const char *name, rd_kafka_ResourcePatternType_t resource_pattern_type, const char *principal, const char *host, rd_kafka_AclOperation_t operation, rd_kafka_AclPermissionType_t permission_type, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_ResourceType_t rd_kafka_AclBinding_restype(const rd_kafka_AclBinding_t *acl);</span>
<span class="s1">const char *rd_kafka_AclBinding_name(const rd_kafka_AclBinding_t *acl);</span>
<span class="s1">const char *rd_kafka_AclBinding_principal(const rd_kafka_AclBinding_t *acl);</span>
<span class="s1">const char *rd_kafka_AclBinding_host(const rd_kafka_AclBinding_t *acl);</span>
<span class="s1">rd_kafka_AclOperation_t rd_kafka_AclBinding_operation(const rd_kafka_AclBinding_t *acl);</span>
<span class="s1">rd_kafka_AclPermissionType_t rd_kafka_AclBinding_permission_type(const rd_kafka_AclBinding_t *acl);</span>
<span class="s1">rd_kafka_ResourcePatternType_t rd_kafka_AclBinding_resource_pattern_type(const rd_kafka_AclBinding_t *acl);</span>
<span class="s1">const rd_kafka_error_t *rd_kafka_AclBinding_error(const rd_kafka_AclBinding_t *acl);</span>
<span class="s1">void rd_kafka_AclBinding_destroy(rd_kafka_AclBinding_t *acl_binding);</span>
<span class="s1">void rd_kafka_AclBinding_destroy_array(rd_kafka_AclBinding_t **acl_bindings, size_t acl_bindings_cnt);</span>
<span class="s1">const rd_kafka_acl_result_t **rd_kafka_CreateAcls_result_acls(const rd_kafka_CreateAcls_result_t *result, size_t *cntp);</span>
<span class="s1">void rd_kafka_CreateAcls(rd_kafka_t *rk, rd_kafka_AclBinding_t **new_acls, size_t new_acls_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_AclBinding_t **rd_kafka_DescribeAcls_result_acls(const rd_kafka_DescribeAcls_result_t *result, size_t *cntp);</span>
<span class="s1">void rd_kafka_DescribeAcls(rd_kafka_t *rk, rd_kafka_AclBindingFilter_t *acl_filter, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">typedef struct rd_kafka_DeleteAcls_result_response_s rd_kafka_DeleteAcls_result_response_t;</span>
<span class="s1">const rd_kafka_DeleteAcls_result_response_t **rd_kafka_DeleteAcls_result_responses(const rd_kafka_DeleteAcls_result_t *result, size_t *cntp);</span>
<span class="s1">const rd_kafka_error_t *rd_kafka_DeleteAcls_result_response_error(const rd_kafka_DeleteAcls_result_response_t *result_response);</span>
<span class="s1">const rd_kafka_AclBinding_t **rd_kafka_DeleteAcls_result_response_matching_acls(const rd_kafka_DeleteAcls_result_response_t *result_response, size_t *matching_acls_cntp);</span>
<span class="s1">void rd_kafka_DeleteAcls(rd_kafka_t *rk, rd_kafka_AclBindingFilter_t **del_acls, size_t del_acls_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token(rd_kafka_t *rk, const char *token_value, int64_t md_lifetime_ms, const char *md_principal_name, const char **extensions, size_t extension_size, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token_failure(rd_kafka_t *rk, const char *errstr);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_init_transactions(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_begin_transaction(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_send_offsets_to_transaction(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, const rd_kafka_consumer_group_metadata_t *cgmetadata, int timeout_ms);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_commit_transaction(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_abort_transaction(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">typedef struct rd_kafka_mock_cluster_s rd_kafka_mock_cluster_t;</span>
<span class="s1">rd_kafka_mock_cluster_t *rd_kafka_mock_cluster_new(rd_kafka_t *rk, int broker_cnt);</span>
<span class="s1">void rd_kafka_mock_cluster_destroy(rd_kafka_mock_cluster_t *mcluster);</span>
<span class="s1">rd_kafka_t *rd_kafka_mock_cluster_handle(const rd_kafka_mock_cluster_t *mcluster);</span>
<span class="s1">rd_kafka_mock_cluster_t *rd_kafka_handle_mock_cluster(const rd_kafka_t *rk);</span>
<span class="s1">const char *rd_kafka_mock_cluster_bootstraps(const rd_kafka_mock_cluster_t *mcluster);</span>
<span class="s1">void rd_kafka_mock_clear_request_errors(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey);</span>
<span class="s1">void rd_kafka_mock_push_request_errors(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, size_t cnt, ...);</span>
<span class="s1">void rd_kafka_mock_push_request_errors_array(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, size_t cnt, const rd_kafka_resp_err_t *errors);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_push_request_error_rtts(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int16_t ApiKey, size_t cnt, ...);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_error_stack_cnt(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int16_t ApiKey, size_t *cntp);</span>
<span class="s1">void rd_kafka_mock_topic_set_error(rd_kafka_mock_cluster_t *mcluster, const char *topic, rd_kafka_resp_err_t err);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_topic_create(rd_kafka_mock_cluster_t *mcluster, const char *topic, int partition_cnt, int replication_factor);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_partition_set_leader(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_partition_set_follower(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_partition_set_follower_wmarks(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int64_t lo, int64_t hi);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_partition_push_leader_response(rd_kafka_mock_cluster_t *mcluster, const char *topic, int partition, int32_t leader_id, int32_t leader_epoch);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_set_down(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_set_up(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_set_rtt(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int rtt_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_set_rack(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, const char *rack);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_coordinator_set(rd_kafka_mock_cluster_t *mcluster, const char *key_type, const char *key, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_set_apiversion(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, int16_t MinVersion, int16_t MaxVersion);</span>
<span class="s1">void rd_kafka_mock_start_request_tracking(rd_kafka_mock_cluster_t *mcluster);</span>
<span class="s1">void rd_kafka_mock_stop_request_tracking(rd_kafka_mock_cluster_t *mcluster);</span>
<span class="s1">typedef struct rd_kafka_mock_request_s rd_kafka_mock_request_t;</span>
<span class="s1">void rd_kafka_mock_request_destroy(rd_kafka_mock_request_t *mreq);</span>
<span class="s1">void rd_kafka_mock_request_destroy_array(rd_kafka_mock_request_t **mreqs, size_t mreq_cnt);</span>
<span class="s1">int32_t rd_kafka_mock_request_id(rd_kafka_mock_request_t *mreq);</span>
<span class="s1">int16_t rd_kafka_mock_request_api_key(rd_kafka_mock_request_t *mreq);</span>
<span class="s1">int64_t rd_kafka_mock_request_timestamp(rd_kafka_mock_request_t *mreq);</span>
<span class="s1">rd_kafka_mock_request_t **rd_kafka_mock_get_requests(rd_kafka_mock_cluster_t *mcluster, size_t *cntp);</span>
<span class="s1">void rd_kafka_mock_clear_requests(rd_kafka_mock_cluster_t *mcluster);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_telemetry_set_requested_metrics(rd_kafka_mock_cluster_t *mcluster, char **metrics, size_t metrics_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_telemetry_set_push_interval(rd_kafka_mock_cluster_t *mcluster, int64_t push_interval_ms);</span>
<span class="s1">&#39;</span>
</code></pre></div>
rdkafka.h, rdkafka_mock.h</p>
<h3 id="rd_kafka_version_32">RD_KAFKA_VERSION<a class="headerlink" href="#rd_kafka_version_32" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_VERSION</span> <span class="o">=</span> <span class="mi">33883135</span>
</code></pre></div>
<p>librdkafka version </p>
<p>Interpreted as hex <code>MM.mm.rr.xx</code>:</p>
<ul>
<li>MM = Major</li>
<li>mm = minor</li>
<li>rr = revision</li>
<li>xx = pre-release id (0xff is the final release)</li>
</ul>
<p>E.g.: <code>0x000801ff</code> = 0.8.1</p>
<dl class="section remark"><dt>Remarks</dt><dd>This value should only be used during compile time, for runtime checks of version use rd_kafka_version() </dd></dl>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_unsupported_compression_type_32">RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE<a class="headerlink" href="#rd_kafka_resp_err_unsupported_compression_type_32" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE</span> <span class="o">=</span> <span class="mi">76</span>
</code></pre></div>
<p>Unsupported compression type </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_end_all_32">RD_KAFKA_RESP_ERR_END_ALL<a class="headerlink" href="#rd_kafka_resp_err_end_all_32" title="Permanent link">&para;</a></h3>
<p><div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_END_ALL</span> <span class="o">=</span> <span class="mi">119</span>
</code></pre></div>
enum rd_kafka_resp_err_t</p>
<h3 id="rd_kafka_admin_op__cnt_32">RD_KAFKA_ADMIN_OP__CNT<a class="headerlink" href="#rd_kafka_admin_op__cnt_32" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_ADMIN_OP__CNT</span> <span class="o">=</span> <span class="mi">22</span>
</code></pre></div>
<p>Number of ops defined </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe </a></li>
</ul>
</div>
<h3 id="rd_kafka_resource__cnt_32">RD_KAFKA_RESOURCE__CNT<a class="headerlink" href="#rd_kafka_resource__cnt_32" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESOURCE__CNT</span> <span class="o">=</span> <span class="mi">5</span>
</code></pre></div>
<p>Number of resource types defined </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#acca83a66d7783ff7683ed2691cc907c9"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#acca83a66d7783ff7683ed2691cc907c9 </a></li>
</ul>
</div>
<h3 id="rd_kafka_cdef_32">RD_KAFKA_CDEF<a class="headerlink" href="#rd_kafka_cdef_32" title="Permanent link">&para;</a></h3>
<p><div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_CDEF</span> <span class="o">=</span> <span class="s1">&#39;typedef long int ssize_t;</span>
<span class="s1">typedef struct _IO_FILE FILE;</span>
<span class="s1">typedef long int mode_t;</span>
<span class="s1">typedef signed int int16_t;</span>
<span class="s1">typedef unsigned int uint16_t;</span>
<span class="s1">typedef signed int int32_t;</span>
<span class="s1">typedef signed long int int64_t;</span>
<span class="s1">int rd_kafka_version(void);</span>
<span class="s1">const char *rd_kafka_version_str(void);</span>
<span class="s1">typedef enum rd_kafka_type_t {</span>
<span class="s1">  RD_KAFKA_PRODUCER,</span>
<span class="s1">  RD_KAFKA_CONSUMER,</span>
<span class="s1">} rd_kafka_type_t;</span>
<span class="s1">typedef enum rd_kafka_timestamp_type_t {</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_NOT_AVAILABLE,</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_CREATE_TIME,</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_LOG_APPEND_TIME,</span>
<span class="s1">} rd_kafka_timestamp_type_t;</span>
<span class="s1">const char *rd_kafka_get_debug_contexts(void);</span>
<span class="s1">typedef struct rd_kafka_s rd_kafka_t;</span>
<span class="s1">typedef struct rd_kafka_topic_s rd_kafka_topic_t;</span>
<span class="s1">typedef struct rd_kafka_conf_s rd_kafka_conf_t;</span>
<span class="s1">typedef struct rd_kafka_topic_conf_s rd_kafka_topic_conf_t;</span>
<span class="s1">typedef struct rd_kafka_queue_s rd_kafka_queue_t;</span>
<span class="s1">typedef struct rd_kafka_op_s rd_kafka_event_t;</span>
<span class="s1">typedef struct rd_kafka_topic_result_s rd_kafka_topic_result_t;</span>
<span class="s1">typedef struct rd_kafka_consumer_group_metadata_s rd_kafka_consumer_group_metadata_t;</span>
<span class="s1">typedef struct rd_kafka_error_s {</span>
<span class="s1">  unsigned int code;</span>
<span class="s1">  char *errstr;</span>
<span class="s1">  unsigned char fatal;</span>
<span class="s1">  unsigned char retriable;</span>
<span class="s1">  unsigned char txn_requires_abort;</span>
<span class="s1">} rd_kafka_error_t;</span>
<span class="s1">typedef struct rd_kafka_headers_s rd_kafka_headers_t;</span>
<span class="s1">typedef struct rd_kafka_group_result_s rd_kafka_group_result_t;</span>
<span class="s1">typedef struct rd_kafka_acl_result_s rd_kafka_acl_result_t;</span>
<span class="s1">typedef struct rd_kafka_Uuid_s rd_kafka_Uuid_t;</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BEGIN = (- 200),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BAD_MSG = (- 199),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BAD_COMPRESSION = (- 198),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__DESTROY = (- 197),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FAIL = (- 196),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TRANSPORT = (- 195),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__CRIT_SYS_RESOURCE = (- 194),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__RESOLVE = (- 193),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__MSG_TIMED_OUT = (- 192),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PARTITION_EOF = (- 191),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION = (- 190),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FS = (- 189),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC = (- 188),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ALL_BROKERS_DOWN = (- 187),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INVALID_ARG = (- 186),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TIMED_OUT = (- 185),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__QUEUE_FULL = (- 184),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ISR_INSUFF = (- 183),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NODE_UPDATE = (- 182),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__SSL = (- 181),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__WAIT_COORD = (- 180),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_GROUP = (- 179),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__IN_PROGRESS = (- 178),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PREV_IN_PROGRESS = (- 177),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__EXISTING_SUBSCRIPTION = (- 176),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS = (- 175),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS = (- 174),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__CONFLICT = (- 173),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__STATE = (- 172),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_PROTOCOL = (- 171),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED = (- 170),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__AUTHENTICATION = (- 169),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NO_OFFSET = (- 168),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__OUTDATED = (- 167),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TIMED_OUT_QUEUE = (- 166),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNSUPPORTED_FEATURE = (- 165),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__WAIT_CACHE = (- 164),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INTR = (- 163),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__KEY_SERIALIZATION = (- 162),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__VALUE_SERIALIZATION = (- 161),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__KEY_DESERIALIZATION = (- 160),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__VALUE_DESERIALIZATION = (- 159),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PARTIAL = (- 158),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__READ_ONLY = (- 157),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOENT = (- 156),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNDERFLOW = (- 155),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INVALID_TYPE = (- 154),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__RETRY = (- 153),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PURGE_QUEUE = (- 152),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PURGE_INFLIGHT = (- 151),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FATAL = (- 150),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INCONSISTENT = (- 149),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__GAPLESS_GUARANTEE = (- 148),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__MAX_POLL_EXCEEDED = (- 147),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_BROKER = (- 146),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOT_CONFIGURED = (- 145),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FENCED = (- 144),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__APPLICATION = (- 143),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ASSIGNMENT_LOST = (- 142),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOOP = (- 141),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__AUTO_OFFSET_RESET = (- 140),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__LOG_TRUNCATION = (- 139),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INVALID_DIFFERENT_RECORD = (- 138),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__END = (- 100),</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN = (- 1),</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NO_ERROR = 0,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_OUT_OF_RANGE = 1,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_MSG = 2,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART = 3,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_MSG_SIZE = 4,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE = 5,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_LEADER_FOR_PARTITION = 6,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REQUEST_TIMED_OUT = 7,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_BROKER_NOT_AVAILABLE = 8,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REPLICA_NOT_AVAILABLE = 9,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE = 10,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_STALE_CTRL_EPOCH = 11,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_METADATA_TOO_LARGE = 12,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NETWORK_EXCEPTION = 13,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_COORDINATOR_LOAD_IN_PROGRESS = 14,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_COORDINATOR_NOT_AVAILABLE = 15,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_COORDINATOR = 16,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_EXCEPTION = 17,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_RECORD_LIST_TOO_LARGE = 18,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS = 19,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS_AFTER_APPEND = 20,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REQUIRED_ACKS = 21,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ILLEGAL_GENERATION = 22,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INCONSISTENT_GROUP_PROTOCOL = 23,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_GROUP_ID = 24,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_MEMBER_ID = 25,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_SESSION_TIMEOUT = 26,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REBALANCE_IN_PROGRESS = 27,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_COMMIT_OFFSET_SIZE = 28,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_AUTHORIZATION_FAILED = 29,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_AUTHORIZATION_FAILED = 30,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_CLUSTER_AUTHORIZATION_FAILED = 31,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TIMESTAMP = 32,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_SASL_MECHANISM = 33,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ILLEGAL_SASL_STATE = 34,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_VERSION = 35,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_ALREADY_EXISTS = 36,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PARTITIONS = 37,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REPLICATION_FACTOR = 38,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REPLICA_ASSIGNMENT = 39,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_CONFIG = 40,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_CONTROLLER = 41,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REQUEST = 42,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_FOR_MESSAGE_FORMAT = 43,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_POLICY_VIOLATION = 44,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OUT_OF_ORDER_SEQUENCE_NUMBER = 45,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DUPLICATE_SEQUENCE_NUMBER = 46,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_EPOCH = 47,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TXN_STATE = 48,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_ID_MAPPING = 49,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TRANSACTION_TIMEOUT = 50,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_CONCURRENT_TRANSACTIONS = 51,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TRANSACTION_COORDINATOR_FENCED = 52,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TRANSACTIONAL_ID_AUTHORIZATION_FAILED = 53,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_SECURITY_DISABLED = 54,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OPERATION_NOT_ATTEMPTED = 55,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_KAFKA_STORAGE_ERROR = 56,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LOG_DIR_NOT_FOUND = 57,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_SASL_AUTHENTICATION_FAILED = 58,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_PRODUCER_ID = 59,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REASSIGNMENT_IN_PROGRESS = 60,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTH_DISABLED = 61,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_NOT_FOUND = 62,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_OWNER_MISMATCH = 63,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_REQUEST_NOT_ALLOWED = 64,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTHORIZATION_FAILED = 65,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_EXPIRED = 66,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRINCIPAL_TYPE = 67,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NON_EMPTY_GROUP = 68,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_ID_NOT_FOUND = 69,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FETCH_SESSION_ID_NOT_FOUND = 70,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_FETCH_SESSION_EPOCH = 71,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LISTENER_NOT_FOUND = 72,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_DELETION_DISABLED = 73,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FENCED_LEADER_EPOCH = 74,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_LEADER_EPOCH = 75,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_STALE_BROKER_EPOCH = 77,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_NOT_AVAILABLE = 78,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_MEMBER_ID_REQUIRED = 79,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_PREFERRED_LEADER_NOT_AVAILABLE = 80,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_MAX_SIZE_REACHED = 81,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FENCED_INSTANCE_ID = 82,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ELIGIBLE_LEADERS_NOT_AVAILABLE = 83,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ELECTION_NOT_NEEDED = 84,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NO_REASSIGNMENT_IN_PROGRESS = 85,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_SUBSCRIBED_TO_TOPIC = 86,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_RECORD = 87,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSTABLE_OFFSET_COMMIT = 88,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_THROTTLING_QUOTA_EXCEEDED = 89,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_PRODUCER_FENCED = 90,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_RESOURCE_NOT_FOUND = 91,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DUPLICATE_RESOURCE = 92,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNACCEPTABLE_CREDENTIAL = 93,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INCONSISTENT_VOTER_SET = 94,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_UPDATE_VERSION = 95,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FEATURE_UPDATE_FAILED = 96,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_PRINCIPAL_DESERIALIZATION_FAILURE = 97,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_ID = 100,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FENCED_MEMBER_EPOCH = 110,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNRELEASED_INSTANCE_ID = 111,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_ASSIGNOR = 112,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_STALE_MEMBER_EPOCH = 113,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_SUBSCRIPTION_ID = 117,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TELEMETRY_TOO_LARGE = 118,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_END_ALL,</span>
<span class="s1">} rd_kafka_resp_err_t;</span>
<span class="s1">struct rd_kafka_err_desc {</span>
<span class="s1">  rd_kafka_resp_err_t code;</span>
<span class="s1">  char *name;</span>
<span class="s1">  char *desc;</span>
<span class="s1">};</span>
<span class="s1">void rd_kafka_get_err_descs(const struct rd_kafka_err_desc **errdescs, size_t *cntp);</span>
<span class="s1">const char *rd_kafka_err2str(rd_kafka_resp_err_t err);</span>
<span class="s1">const char *rd_kafka_err2name(rd_kafka_resp_err_t err);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_last_error(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_errno2err(int errnox);</span>
<span class="s1">int rd_kafka_errno(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_fatal_error(rd_kafka_t *rk, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_test_fatal_error(rd_kafka_t *rk, rd_kafka_resp_err_t err, const char *reason);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_error_code(const rd_kafka_error_t *error);</span>
<span class="s1">const char *rd_kafka_error_name(const rd_kafka_error_t *error);</span>
<span class="s1">const char *rd_kafka_error_string(const rd_kafka_error_t *error);</span>
<span class="s1">int rd_kafka_error_is_fatal(const rd_kafka_error_t *error);</span>
<span class="s1">int rd_kafka_error_is_retriable(const rd_kafka_error_t *error);</span>
<span class="s1">int rd_kafka_error_txn_requires_abort(const rd_kafka_error_t *error);</span>
<span class="s1">void rd_kafka_error_destroy(rd_kafka_error_t *error);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_error_new(rd_kafka_resp_err_t code, const char *fmt, ...);</span>
<span class="s1">typedef struct rd_kafka_topic_partition_s {</span>
<span class="s1">  char *topic;</span>
<span class="s1">  int32_t partition;</span>
<span class="s1">  int64_t offset;</span>
<span class="s1">  void *metadata;</span>
<span class="s1">  size_t metadata_size;</span>
<span class="s1">  void *opaque;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  void *_private;</span>
<span class="s1">} rd_kafka_topic_partition_t;</span>
<span class="s1">void rd_kafka_topic_partition_destroy(rd_kafka_topic_partition_t *rktpar);</span>
<span class="s1">void rd_kafka_topic_partition_set_leader_epoch(rd_kafka_topic_partition_t *rktpar, int32_t leader_epoch);</span>
<span class="s1">int32_t rd_kafka_topic_partition_get_leader_epoch(const rd_kafka_topic_partition_t *rktpar);</span>
<span class="s1">typedef struct rd_kafka_topic_partition_list_s {</span>
<span class="s1">  int cnt;</span>
<span class="s1">  int size;</span>
<span class="s1">  rd_kafka_topic_partition_t *elems;</span>
<span class="s1">} rd_kafka_topic_partition_list_t;</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_new(int size);</span>
<span class="s1">void rd_kafka_topic_partition_list_destroy(rd_kafka_topic_partition_list_t *rkparlist);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_add(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">void rd_kafka_topic_partition_list_add_range(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t start, int32_t stop);</span>
<span class="s1">int rd_kafka_topic_partition_list_del(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">int rd_kafka_topic_partition_list_del_by_idx(rd_kafka_topic_partition_list_t *rktparlist, int idx);</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_copy(const rd_kafka_topic_partition_list_t *src);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_topic_partition_list_set_offset(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition, int64_t offset);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_find(const rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">void rd_kafka_topic_partition_list_sort(rd_kafka_topic_partition_list_t *rktparlist, int (*cmp)(const void *a, const void *b, void *cmp_opaque), void *cmp_opaque);</span>
<span class="s1">typedef enum rd_kafka_vtype_t {</span>
<span class="s1">  RD_KAFKA_VTYPE_END,</span>
<span class="s1">  RD_KAFKA_VTYPE_TOPIC,</span>
<span class="s1">  RD_KAFKA_VTYPE_RKT,</span>
<span class="s1">  RD_KAFKA_VTYPE_PARTITION,</span>
<span class="s1">  RD_KAFKA_VTYPE_VALUE,</span>
<span class="s1">  RD_KAFKA_VTYPE_KEY,</span>
<span class="s1">  RD_KAFKA_VTYPE_OPAQUE,</span>
<span class="s1">  RD_KAFKA_VTYPE_MSGFLAGS,</span>
<span class="s1">  RD_KAFKA_VTYPE_TIMESTAMP,</span>
<span class="s1">  RD_KAFKA_VTYPE_HEADER,</span>
<span class="s1">  RD_KAFKA_VTYPE_HEADERS,</span>
<span class="s1">} rd_kafka_vtype_t;</span>
<span class="s1">typedef struct rd_kafka_vu_s {</span>
<span class="s1">  rd_kafka_vtype_t vtype;</span>
<span class="s1">  union {</span>
<span class="s1">    char *cstr;</span>
<span class="s1">    rd_kafka_topic_t *rkt;</span>
<span class="s1">    int i;</span>
<span class="s1">    int32_t i32;</span>
<span class="s1">    int64_t i64;</span>
<span class="s1">    struct {</span>
<span class="s1">      void *ptr;</span>
<span class="s1">      size_t size;</span>
<span class="s1">    } mem;</span>
<span class="s1">    struct {</span>
<span class="s1">      char *name;</span>
<span class="s1">      void *val;</span>
<span class="s1">      ssize_t size;</span>
<span class="s1">    } header;</span>
<span class="s1">    rd_kafka_headers_t *headers;</span>
<span class="s1">    void *ptr;</span>
<span class="s1">    char _pad[64];</span>
<span class="s1">  } u;</span>
<span class="s1">} rd_kafka_vu_t;</span>
<span class="s1">rd_kafka_headers_t *rd_kafka_headers_new(size_t initial_count);</span>
<span class="s1">void rd_kafka_headers_destroy(rd_kafka_headers_t *hdrs);</span>
<span class="s1">rd_kafka_headers_t *rd_kafka_headers_copy(const rd_kafka_headers_t *src);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_add(rd_kafka_headers_t *hdrs, const char *name, ssize_t name_size, const void *value, ssize_t value_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_remove(rd_kafka_headers_t *hdrs, const char *name);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get_last(const rd_kafka_headers_t *hdrs, const char *name, const void **valuep, size_t *sizep);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get(const rd_kafka_headers_t *hdrs, size_t idx, const char *name, const void **valuep, size_t *sizep);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get_all(const rd_kafka_headers_t *hdrs, size_t idx, const char **namep, const void **valuep, size_t *sizep);</span>
<span class="s1">typedef struct rd_kafka_message_s {</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  rd_kafka_topic_t *rkt;</span>
<span class="s1">  int32_t partition;</span>
<span class="s1">  void *payload;</span>
<span class="s1">  size_t len;</span>
<span class="s1">  void *key;</span>
<span class="s1">  size_t key_len;</span>
<span class="s1">  int64_t offset;</span>
<span class="s1">  void *_private;</span>
<span class="s1">} rd_kafka_message_t;</span>
<span class="s1">void rd_kafka_message_destroy(rd_kafka_message_t *rkmessage);</span>
<span class="s1">const char *rd_kafka_message_errstr(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">const char *rd_kafka_message_produce_errstr(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">int64_t rd_kafka_message_timestamp(const rd_kafka_message_t *rkmessage, rd_kafka_timestamp_type_t *tstype);</span>
<span class="s1">int64_t rd_kafka_message_latency(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">int32_t rd_kafka_message_broker_id(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_message_headers(const rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_message_detach_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);</span>
<span class="s1">void rd_kafka_message_set_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t *hdrs);</span>
<span class="s1">size_t rd_kafka_header_cnt(const rd_kafka_headers_t *hdrs);</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_NOT_PERSISTED = 0,</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_POSSIBLY_PERSISTED = 1,</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_PERSISTED = 2,</span>
<span class="s1">} rd_kafka_msg_status_t;</span>
<span class="s1">rd_kafka_msg_status_t rd_kafka_message_status(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">int32_t rd_kafka_message_leader_epoch(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">const char *rd_kafka_Uuid_base64str(const rd_kafka_Uuid_t *uuid);</span>
<span class="s1">int64_t rd_kafka_Uuid_least_significant_bits(const rd_kafka_Uuid_t *uuid);</span>
<span class="s1">int64_t rd_kafka_Uuid_most_significant_bits(const rd_kafka_Uuid_t *uuid);</span>
<span class="s1">rd_kafka_Uuid_t *rd_kafka_Uuid_new(int64_t most_significant_bits, int64_t least_significant_bits);</span>
<span class="s1">rd_kafka_Uuid_t *rd_kafka_Uuid_copy(const rd_kafka_Uuid_t *uuid);</span>
<span class="s1">void rd_kafka_Uuid_destroy(rd_kafka_Uuid_t *uuid);</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_CONF_UNKNOWN = (- 2),</span>
<span class="s1">  RD_KAFKA_CONF_INVALID = (- 1),</span>
<span class="s1">  RD_KAFKA_CONF_OK = 0,</span>
<span class="s1">} rd_kafka_conf_res_t;</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_new(void);</span>
<span class="s1">void rd_kafka_conf_destroy(rd_kafka_conf_t *conf);</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_dup(const rd_kafka_conf_t *conf);</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_dup_filter(const rd_kafka_conf_t *conf, size_t filter_cnt, const char **filter);</span>
<span class="s1">const rd_kafka_conf_t *rd_kafka_conf(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_set(rd_kafka_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_conf_set_events(rd_kafka_conf_t *conf, int events);</span>
<span class="s1">void rd_kafka_conf_set_background_event_cb(rd_kafka_conf_t *conf, void (*event_cb)(rd_kafka_t *rk, rd_kafka_event_t *rkev, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_dr_cb(rd_kafka_conf_t *conf, void (*dr_cb)(rd_kafka_t *rk, void *payload, size_t len, rd_kafka_resp_err_t err, void *opaque, void *msg_opaque));</span>
<span class="s1">void rd_kafka_conf_set_dr_msg_cb(rd_kafka_conf_t *conf, void (*dr_msg_cb)(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_consume_cb(rd_kafka_conf_t *conf, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_rebalance_cb(rd_kafka_conf_t *conf, void (*rebalance_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *partitions, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_offset_commit_cb(rd_kafka_conf_t *conf, void (*offset_commit_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_error_cb(rd_kafka_conf_t *conf, void (*error_cb)(rd_kafka_t *rk, int err, const char *reason, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_throttle_cb(rd_kafka_conf_t *conf, void (*throttle_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int throttle_time_ms, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_log_cb(rd_kafka_conf_t *conf, void (*log_cb)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));</span>
<span class="s1">void rd_kafka_conf_set_stats_cb(rd_kafka_conf_t *conf, int (*stats_cb)(rd_kafka_t *rk, char *json, size_t json_len, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_oauthbearer_token_refresh_cb(rd_kafka_conf_t *conf, void (*oauthbearer_token_refresh_cb)(rd_kafka_t *rk, const char *oauthbearer_config, void *opaque));</span>
<span class="s1">void rd_kafka_conf_enable_sasl_queue(rd_kafka_conf_t *conf, int enable);</span>
<span class="s1">void rd_kafka_conf_set_socket_cb(rd_kafka_conf_t *conf, int (*socket_cb)(int domain, int type, int protocol, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_connect_cb(rd_kafka_conf_t *conf, int (*connect_cb)(int sockfd, const struct sockaddr *addr, int addrlen, const char *id, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_closesocket_cb(rd_kafka_conf_t *conf, int (*closesocket_cb)(int sockfd, void *opaque));</span>
<span class="s1">struct addrinfo;</span>
<span class="s1">void rd_kafka_conf_set_resolve_cb(rd_kafka_conf_t *conf, int (*resolve_cb)(const char *node, const char *service, const struct addrinfo *hints, struct addrinfo **res, void *opaque));</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert_verify_cb(rd_kafka_conf_t *conf, int (*ssl_cert_verify_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int *x509_error, int depth, const char *buf, size_t size, char *errstr, size_t errstr_size, void *opaque));</span>
<span class="s1">typedef enum rd_kafka_cert_type_t {</span>
<span class="s1">  RD_KAFKA_CERT_PUBLIC_KEY,</span>
<span class="s1">  RD_KAFKA_CERT_PRIVATE_KEY,</span>
<span class="s1">  RD_KAFKA_CERT_CA,</span>
<span class="s1">  RD_KAFKA_CERT__CNT,</span>
<span class="s1">} rd_kafka_cert_type_t;</span>
<span class="s1">typedef enum rd_kafka_cert_enc_t {</span>
<span class="s1">  RD_KAFKA_CERT_ENC_PKCS12,</span>
<span class="s1">  RD_KAFKA_CERT_ENC_DER,</span>
<span class="s1">  RD_KAFKA_CERT_ENC_PEM,</span>
<span class="s1">  RD_KAFKA_CERT_ENC__CNT,</span>
<span class="s1">} rd_kafka_cert_enc_t;</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert(rd_kafka_conf_t *conf, rd_kafka_cert_type_t cert_type, rd_kafka_cert_enc_t cert_enc, const void *buffer, size_t size, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_conf_set_engine_callback_data(rd_kafka_conf_t *conf, void *callback_data);</span>
<span class="s1">void rd_kafka_conf_set_opaque(rd_kafka_conf_t *conf, void *opaque);</span>
<span class="s1">void *rd_kafka_opaque(const rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_conf_set_default_topic_conf(rd_kafka_conf_t *conf, rd_kafka_topic_conf_t *tconf);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_conf_get_default_topic_conf(rd_kafka_conf_t *conf);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_get(const rd_kafka_conf_t *conf, const char *name, char *dest, size_t *dest_size);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_topic_conf_get(const rd_kafka_topic_conf_t *conf, const char *name, char *dest, size_t *dest_size);</span>
<span class="s1">const char **rd_kafka_conf_dump(rd_kafka_conf_t *conf, size_t *cntp);</span>
<span class="s1">const char **rd_kafka_topic_conf_dump(rd_kafka_topic_conf_t *conf, size_t *cntp);</span>
<span class="s1">void rd_kafka_conf_dump_free(const char **arr, size_t cnt);</span>
<span class="s1">void rd_kafka_conf_properties_show(FILE *fp);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_topic_conf_new(void);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_topic_conf_dup(const rd_kafka_topic_conf_t *conf);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_default_topic_conf_dup(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_topic_conf_destroy(rd_kafka_topic_conf_t *topic_conf);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_topic_conf_set(rd_kafka_topic_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_topic_conf_set_opaque(rd_kafka_topic_conf_t *conf, void *rkt_opaque);</span>
<span class="s1">void rd_kafka_topic_conf_set_partitioner_cb(rd_kafka_topic_conf_t *topic_conf, int32_t (*partitioner)(const rd_kafka_topic_t *rkt, const void *keydata, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque));</span>
<span class="s1">void rd_kafka_topic_conf_set_msg_order_cmp(rd_kafka_topic_conf_t *topic_conf, int (*msg_order_cmp)(const rd_kafka_message_t *a, const rd_kafka_message_t *b));</span>
<span class="s1">int rd_kafka_topic_partition_available(const rd_kafka_topic_t *rkt, int32_t partition);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_consistent(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_consistent_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_murmur2(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_murmur2_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_fnv1a(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_fnv1a_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">rd_kafka_t *rd_kafka_new(rd_kafka_type_t type, rd_kafka_conf_t *conf, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_destroy(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_destroy_flags(rd_kafka_t *rk, int flags);</span>
<span class="s1">const char *rd_kafka_name(const rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_type_t rd_kafka_type(const rd_kafka_t *rk);</span>
<span class="s1">char *rd_kafka_memberid(const rd_kafka_t *rk);</span>
<span class="s1">char *rd_kafka_clusterid(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">int32_t rd_kafka_controllerid(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_topic_t *rd_kafka_topic_new(rd_kafka_t *rk, const char *topic, rd_kafka_topic_conf_t *conf);</span>
<span class="s1">void rd_kafka_topic_destroy(rd_kafka_topic_t *rkt);</span>
<span class="s1">const char *rd_kafka_topic_name(const rd_kafka_topic_t *rkt);</span>
<span class="s1">void *rd_kafka_topic_opaque(const rd_kafka_topic_t *rkt);</span>
<span class="s1">int rd_kafka_poll(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">void rd_kafka_yield(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_pause_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_resume_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_query_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_get_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offsets_for_times(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets, int timeout_ms);</span>
<span class="s1">void *rd_kafka_mem_calloc(rd_kafka_t *rk, size_t num, size_t size);</span>
<span class="s1">void *rd_kafka_mem_malloc(rd_kafka_t *rk, size_t size);</span>
<span class="s1">void rd_kafka_mem_free(rd_kafka_t *rk, void *ptr);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_new(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_queue_destroy(rd_kafka_queue_t *rkqu);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_main(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_sasl(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_sasl_background_callbacks_enable(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_sasl_set_credentials(rd_kafka_t *rk, const char *username, const char *password);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_consumer(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_partition(rd_kafka_t *rk, const char *topic, int32_t partition);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_background(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_queue_forward(rd_kafka_queue_t *src, rd_kafka_queue_t *dst);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_set_log_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu);</span>
<span class="s1">size_t rd_kafka_queue_length(rd_kafka_queue_t *rkqu);</span>
<span class="s1">void rd_kafka_queue_io_event_enable(rd_kafka_queue_t *rkqu, int fd, const void *payload, size_t size);</span>
<span class="s1">void rd_kafka_queue_cb_event_enable(rd_kafka_queue_t *rkqu, void (*event_cb)(rd_kafka_t *rk, void *qev_opaque), void *qev_opaque);</span>
<span class="s1">void rd_kafka_queue_yield(rd_kafka_queue_t *rkqu);</span>
<span class="s1">int rd_kafka_consume_start(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);</span>
<span class="s1">int rd_kafka_consume_start_queue(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, rd_kafka_queue_t *rkqu);</span>
<span class="s1">int rd_kafka_consume_stop(rd_kafka_topic_t *rkt, int32_t partition);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_seek(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, int timeout_ms);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_seek_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consume(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms);</span>
<span class="s1">ssize_t rd_kafka_consume_batch(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);</span>
<span class="s1">int rd_kafka_consume_callback(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consume_queue(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">ssize_t rd_kafka_consume_batch_queue(rd_kafka_queue_t *rkqu, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);</span>
<span class="s1">int rd_kafka_consume_callback_queue(rd_kafka_queue_t *rkqu, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offset_store(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offsets_store(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_offset_store_message(rd_kafka_message_t *rkmessage);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_subscribe(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *topics);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_unsubscribe(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_subscription(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **topics);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consumer_poll(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_consumer_close(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_consumer_close_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu);</span>
<span class="s1">int rd_kafka_consumer_closed(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_incremental_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_incremental_unassign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">const char *rd_kafka_rebalance_protocol(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_assignment(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **partitions);</span>
<span class="s1">int rd_kafka_assignment_lost(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, int async);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit_message(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, int async);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit_queue(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_queue_t *rkqu, void (*cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *commit_opaque), void *commit_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_committed(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_position(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata_new(const char *group_id);</span>
<span class="s1">rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata_new_with_genid(const char *group_id, int32_t generation_id, const char *member_id, const char *group_instance_id);</span>
<span class="s1">const char *rd_kafka_consumer_group_metadata_member_id(const rd_kafka_consumer_group_metadata_t *group_metadata);</span>
<span class="s1">void rd_kafka_consumer_group_metadata_destroy(rd_kafka_consumer_group_metadata_t *);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_consumer_group_metadata_write(const rd_kafka_consumer_group_metadata_t *cgmd, void **bufferp, size_t *sizep);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_consumer_group_metadata_read(rd_kafka_consumer_group_metadata_t **cgmdp, const void *buffer, size_t size);</span>
<span class="s1">int rd_kafka_produce(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, void *payload, size_t len, const void *key, size_t keylen, void *msg_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_producev(rd_kafka_t *rk, ...);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_produceva(rd_kafka_t *rk, const rd_kafka_vu_t *vus, size_t cnt);</span>
<span class="s1">int rd_kafka_produce_batch(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, rd_kafka_message_t *rkmessages, int message_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_flush(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_purge(rd_kafka_t *rk, int purge_flags);</span>
<span class="s1">typedef struct rd_kafka_metadata_broker {</span>
<span class="s1">  int32_t id;</span>
<span class="s1">  char *host;</span>
<span class="s1">  int port;</span>
<span class="s1">} rd_kafka_metadata_broker_t;</span>
<span class="s1">typedef struct rd_kafka_metadata_partition {</span>
<span class="s1">  int32_t id;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  int32_t leader;</span>
<span class="s1">  int replica_cnt;</span>
<span class="s1">  int32_t *replicas;</span>
<span class="s1">  int isr_cnt;</span>
<span class="s1">  int32_t *isrs;</span>
<span class="s1">} rd_kafka_metadata_partition_t;</span>
<span class="s1">typedef struct rd_kafka_metadata_topic {</span>
<span class="s1">  char *topic;</span>
<span class="s1">  int partition_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_partition *partitions;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">} rd_kafka_metadata_topic_t;</span>
<span class="s1">typedef struct rd_kafka_metadata {</span>
<span class="s1">  int broker_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_broker *brokers;</span>
<span class="s1">  int topic_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_topic *topics;</span>
<span class="s1">  int32_t orig_broker_id;</span>
<span class="s1">  char *orig_broker_name;</span>
<span class="s1">} rd_kafka_metadata_t;</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_metadata(rd_kafka_t *rk, int all_topics, rd_kafka_topic_t *only_rkt, const struct rd_kafka_metadata **metadatap, int timeout_ms);</span>
<span class="s1">void rd_kafka_metadata_destroy(const struct rd_kafka_metadata *metadata);</span>
<span class="s1">typedef struct rd_kafka_Node_s rd_kafka_Node_t;</span>
<span class="s1">int rd_kafka_Node_id(const rd_kafka_Node_t *node);</span>
<span class="s1">const char *rd_kafka_Node_host(const rd_kafka_Node_t *node);</span>
<span class="s1">uint16_t rd_kafka_Node_port(const rd_kafka_Node_t *node);</span>
<span class="s1">const char *rd_kafka_Node_rack(const rd_kafka_Node_t *node);</span>
<span class="s1">struct rd_kafka_group_member_info {</span>
<span class="s1">  char *member_id;</span>
<span class="s1">  char *client_id;</span>
<span class="s1">  char *client_host;</span>
<span class="s1">  void *member_metadata;</span>
<span class="s1">  int member_metadata_size;</span>
<span class="s1">  void *member_assignment;</span>
<span class="s1">  int member_assignment_size;</span>
<span class="s1">};</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_CONSUMER_GROUP_STATE_UNKNOWN = 0,</span>
<span class="s1">  RD_KAFKA_CONSUMER_GROUP_STATE_PREPARING_REBALANCE = 1,</span>
<span class="s1">  RD_KAFKA_CONSUMER_GROUP_STATE_COMPLETING_REBALANCE = 2,</span>
<span class="s1">  RD_KAFKA_CONSUMER_GROUP_STATE_STABLE = 3,</span>
<span class="s1">  RD_KAFKA_CONSUMER_GROUP_STATE_DEAD = 4,</span>
<span class="s1">  RD_KAFKA_CONSUMER_GROUP_STATE_EMPTY = 5,</span>
<span class="s1">  RD_KAFKA_CONSUMER_GROUP_STATE__CNT,</span>
<span class="s1">} rd_kafka_consumer_group_state_t;</span>
<span class="s1">struct rd_kafka_group_info {</span>
<span class="s1">  struct rd_kafka_metadata_broker broker;</span>
<span class="s1">  char *group;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  char *state;</span>
<span class="s1">  char *protocol_type;</span>
<span class="s1">  char *protocol;</span>
<span class="s1">  struct rd_kafka_group_member_info *members;</span>
<span class="s1">  int member_cnt;</span>
<span class="s1">};</span>
<span class="s1">struct rd_kafka_group_list {</span>
<span class="s1">  struct rd_kafka_group_info *groups;</span>
<span class="s1">  int group_cnt;</span>
<span class="s1">};</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_list_groups(rd_kafka_t *rk, const char *group, const struct rd_kafka_group_list **grplistp, int timeout_ms);</span>
<span class="s1">const char *rd_kafka_consumer_group_state_name(rd_kafka_consumer_group_state_t state);</span>
<span class="s1">rd_kafka_consumer_group_state_t rd_kafka_consumer_group_state_code(const char *name);</span>
<span class="s1">void rd_kafka_group_list_destroy(const struct rd_kafka_group_list *grplist);</span>
<span class="s1">int rd_kafka_brokers_add(rd_kafka_t *rk, const char *brokerlist);</span>
<span class="s1">void rd_kafka_set_logger(rd_kafka_t *rk, void (*func)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));</span>
<span class="s1">void rd_kafka_set_log_level(rd_kafka_t *rk, int level);</span>
<span class="s1">void rd_kafka_log_print(const rd_kafka_t *rk, int level, const char *fac, const char *buf);</span>
<span class="s1">void rd_kafka_log_syslog(const rd_kafka_t *rk, int level, const char *fac, const char *buf);</span>
<span class="s1">int rd_kafka_outq_len(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_dump(FILE *fp, rd_kafka_t *rk);</span>
<span class="s1">int rd_kafka_thread_cnt(void);</span>
<span class="s1">typedef enum rd_kafka_thread_type_t {</span>
<span class="s1">  RD_KAFKA_THREAD_MAIN,</span>
<span class="s1">  RD_KAFKA_THREAD_BACKGROUND,</span>
<span class="s1">  RD_KAFKA_THREAD_BROKER,</span>
<span class="s1">} rd_kafka_thread_type_t;</span>
<span class="s1">int rd_kafka_wait_destroyed(int timeout_ms);</span>
<span class="s1">int rd_kafka_unittest(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_poll_set_consumer(rd_kafka_t *rk);</span>
<span class="s1">typedef int rd_kafka_event_type_t;</span>
<span class="s1">rd_kafka_event_type_t rd_kafka_event_type(const rd_kafka_event_t *rkev);</span>
<span class="s1">const char *rd_kafka_event_name(const rd_kafka_event_t *rkev);</span>
<span class="s1">void rd_kafka_event_destroy(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_message_t *rd_kafka_event_message_next(rd_kafka_event_t *rkev);</span>
<span class="s1">size_t rd_kafka_event_message_array(rd_kafka_event_t *rkev, const rd_kafka_message_t **rkmessages, size_t size);</span>
<span class="s1">size_t rd_kafka_event_message_count(rd_kafka_event_t *rkev);</span>
<span class="s1">const char *rd_kafka_event_config_string(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_event_error(rd_kafka_event_t *rkev);</span>
<span class="s1">const char *rd_kafka_event_error_string(rd_kafka_event_t *rkev);</span>
<span class="s1">int rd_kafka_event_error_is_fatal(rd_kafka_event_t *rkev);</span>
<span class="s1">void *rd_kafka_event_opaque(rd_kafka_event_t *rkev);</span>
<span class="s1">int rd_kafka_event_log(rd_kafka_event_t *rkev, const char **fac, const char **str, int *level);</span>
<span class="s1">int rd_kafka_event_debug_contexts(rd_kafka_event_t *rkev, char *dst, size_t dstsize);</span>
<span class="s1">const char *rd_kafka_event_stats(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_event_topic_partition_list(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_event_topic_partition(rd_kafka_event_t *rkev);</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_CreateTopics_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DeleteTopics_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_CreateAcls_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DescribeAcls_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DeleteAcls_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_CreatePartitions_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_AlterConfigs_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_IncrementalAlterConfigs_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DescribeConfigs_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DeleteRecords_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_ListConsumerGroups_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DescribeConsumerGroups_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DeleteGroups_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DeleteConsumerGroupOffsets_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_AlterConsumerGroupOffsets_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_ListConsumerGroupOffsets_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DescribeTopics_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DescribeCluster_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DescribeUserScramCredentials_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_AlterUserScramCredentials_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_ListOffsets_result_t;</span>
<span class="s1">const rd_kafka_CreateTopics_result_t *rd_kafka_event_CreateTopics_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DeleteTopics_result_t *rd_kafka_event_DeleteTopics_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_CreatePartitions_result_t *rd_kafka_event_CreatePartitions_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_AlterConfigs_result_t *rd_kafka_event_AlterConfigs_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_IncrementalAlterConfigs_result_t *rd_kafka_event_IncrementalAlterConfigs_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DescribeConfigs_result_t *rd_kafka_event_DescribeConfigs_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DeleteRecords_result_t *rd_kafka_event_DeleteRecords_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_ListConsumerGroups_result_t *rd_kafka_event_ListConsumerGroups_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DescribeConsumerGroups_result_t *rd_kafka_event_DescribeConsumerGroups_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DescribeTopics_result_t *rd_kafka_event_DescribeTopics_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DescribeCluster_result_t *rd_kafka_event_DescribeCluster_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DeleteGroups_result_t *rd_kafka_event_DeleteGroups_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DeleteConsumerGroupOffsets_result_t *rd_kafka_event_DeleteConsumerGroupOffsets_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_CreateAcls_result_t *rd_kafka_event_CreateAcls_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DescribeAcls_result_t *rd_kafka_event_DescribeAcls_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DeleteAcls_result_t *rd_kafka_event_DeleteAcls_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_ListConsumerGroupOffsets_result_t *rd_kafka_event_ListConsumerGroupOffsets_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_AlterConsumerGroupOffsets_result_t *rd_kafka_event_AlterConsumerGroupOffsets_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_ListOffsets_result_t *rd_kafka_event_ListOffsets_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DescribeUserScramCredentials_result_t *rd_kafka_event_DescribeUserScramCredentials_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_AlterUserScramCredentials_result_t *rd_kafka_event_AlterUserScramCredentials_result(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_event_t *rd_kafka_queue_poll(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">int rd_kafka_queue_poll_callback(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_plugin_f_conf_init_t)(rd_kafka_conf_t *conf, void **plug_opaquep, char *errstr, size_t errstr_size);</span>
<span class="s1">typedef rd_kafka_conf_res_t (rd_kafka_interceptor_f_on_conf_set_t)(rd_kafka_conf_t *conf, const char *name, const char *val, char *errstr, size_t errstr_size, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_dup_t)(rd_kafka_conf_t *new_conf, const rd_kafka_conf_t *old_conf, size_t filter_cnt, const char **filter, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_destroy_t)(void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_new_t)(rd_kafka_t *rk, const rd_kafka_conf_t *conf, void *ic_opaque, char *errstr, size_t errstr_size);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_destroy_t)(rd_kafka_t *rk, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_send_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_acknowledgement_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_consume_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_commit_t)(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_resp_err_t err, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_request_sent_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_response_received_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, int64_t rtt, rd_kafka_resp_err_t err, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_start_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_exit_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_broker_state_change_t)(rd_kafka_t *rk, int32_t broker_id, const char *secproto, const char *name, int port, const char *state, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_set(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_set_t *on_conf_set, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_dup(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_dup_t *on_conf_dup, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_destroy(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_destroy_t *on_conf_destroy, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_new(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_new_t *on_new, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_destroy(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_destroy_t *on_destroy, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_send(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_send_t *on_send, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_acknowledgement(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_acknowledgement_t *on_acknowledgement, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_consume(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_consume_t *on_consume, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_commit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_commit_t *on_commit, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_request_sent(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_request_sent_t *on_request_sent, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_response_received(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_response_received_t *on_response_received, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_start(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_start_t *on_thread_start, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_exit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_exit_t *on_thread_exit, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_broker_state_change(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_broker_state_change_t *on_broker_state_change, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_topic_result_error(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">const char *rd_kafka_topic_result_error_string(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">const char *rd_kafka_topic_result_name(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">const rd_kafka_error_t *rd_kafka_group_result_error(const rd_kafka_group_result_t *groupres);</span>
<span class="s1">const char *rd_kafka_group_result_name(const rd_kafka_group_result_t *groupres);</span>
<span class="s1">const rd_kafka_topic_partition_list_t *rd_kafka_group_result_partitions(const rd_kafka_group_result_t *groupres);</span>
<span class="s1">typedef enum rd_kafka_admin_op_t {</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_ANY = 0,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_CREATETOPICS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DELETETOPICS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_CREATEPARTITIONS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_ALTERCONFIGS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DESCRIBECONFIGS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DELETERECORDS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DELETEGROUPS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DELETECONSUMERGROUPOFFSETS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_CREATEACLS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DESCRIBEACLS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DELETEACLS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_LISTCONSUMERGROUPS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DESCRIBECONSUMERGROUPS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_LISTCONSUMERGROUPOFFSETS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_ALTERCONSUMERGROUPOFFSETS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_INCREMENTALALTERCONFIGS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DESCRIBEUSERSCRAMCREDENTIALS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_ALTERUSERSCRAMCREDENTIALS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DESCRIBETOPICS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DESCRIBECLUSTER,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_LISTOFFSETS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP__CNT,</span>
<span class="s1">} rd_kafka_admin_op_t;</span>
<span class="s1">typedef struct rd_kafka_AdminOptions_s rd_kafka_AdminOptions_t;</span>
<span class="s1">typedef enum rd_kafka_IsolationLevel_t {</span>
<span class="s1">  RD_KAFKA_ISOLATION_LEVEL_READ_UNCOMMITTED = 0,</span>
<span class="s1">  RD_KAFKA_ISOLATION_LEVEL_READ_COMMITTED = 1,</span>
<span class="s1">} rd_kafka_IsolationLevel_t;</span>
<span class="s1">rd_kafka_AdminOptions_t *rd_kafka_AdminOptions_new(rd_kafka_t *rk, rd_kafka_admin_op_t for_api);</span>
<span class="s1">void rd_kafka_AdminOptions_destroy(rd_kafka_AdminOptions_t *options);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_request_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_operation_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_validate_only(rd_kafka_AdminOptions_t *options, int true_or_false, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_broker(rd_kafka_AdminOptions_t *options, int32_t broker_id, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_AdminOptions_set_require_stable_offsets(rd_kafka_AdminOptions_t *options, int true_or_false);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_AdminOptions_set_include_authorized_operations(rd_kafka_AdminOptions_t *options, int true_or_false);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_AdminOptions_set_match_consumer_group_states(rd_kafka_AdminOptions_t *options, const rd_kafka_consumer_group_state_t *consumer_group_states, size_t consumer_group_states_cnt);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_AdminOptions_set_isolation_level(rd_kafka_AdminOptions_t *options, rd_kafka_IsolationLevel_t value);</span>
<span class="s1">void rd_kafka_AdminOptions_set_opaque(rd_kafka_AdminOptions_t *options, void *ev_opaque);</span>
<span class="s1">typedef enum rd_kafka_AclOperation_t {</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_UNKNOWN = 0,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_ANY = 1,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_ALL = 2,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_READ = 3,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_WRITE = 4,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_CREATE = 5,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_DELETE = 6,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_ALTER = 7,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_DESCRIBE = 8,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_CLUSTER_ACTION = 9,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_DESCRIBE_CONFIGS = 10,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_ALTER_CONFIGS = 11,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_IDEMPOTENT_WRITE = 12,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION__CNT,</span>
<span class="s1">} rd_kafka_AclOperation_t;</span>
<span class="s1">typedef struct rd_kafka_NewTopic_s rd_kafka_NewTopic_t;</span>
<span class="s1">rd_kafka_NewTopic_t *rd_kafka_NewTopic_new(const char *topic, int num_partitions, int replication_factor, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_NewTopic_destroy(rd_kafka_NewTopic_t *new_topic);</span>
<span class="s1">void rd_kafka_NewTopic_destroy_array(rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewTopic_set_replica_assignment(rd_kafka_NewTopic_t *new_topic, int32_t partition, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewTopic_set_config(rd_kafka_NewTopic_t *new_topic, const char *name, const char *value);</span>
<span class="s1">void rd_kafka_CreateTopics(rd_kafka_t *rk, rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_CreateTopics_result_topics(const rd_kafka_CreateTopics_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_DeleteTopic_s rd_kafka_DeleteTopic_t;</span>
<span class="s1">rd_kafka_DeleteTopic_t *rd_kafka_DeleteTopic_new(const char *topic);</span>
<span class="s1">void rd_kafka_DeleteTopic_destroy(rd_kafka_DeleteTopic_t *del_topic);</span>
<span class="s1">void rd_kafka_DeleteTopic_destroy_array(rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt);</span>
<span class="s1">void rd_kafka_DeleteTopics(rd_kafka_t *rk, rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_DeleteTopics_result_topics(const rd_kafka_DeleteTopics_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_NewPartitions_s rd_kafka_NewPartitions_t;</span>
<span class="s1">rd_kafka_NewPartitions_t *rd_kafka_NewPartitions_new(const char *topic, size_t new_total_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_NewPartitions_destroy(rd_kafka_NewPartitions_t *new_parts);</span>
<span class="s1">void rd_kafka_NewPartitions_destroy_array(rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewPartitions_set_replica_assignment(rd_kafka_NewPartitions_t *new_parts, int32_t new_partition_idx, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_CreatePartitions(rd_kafka_t *rk, rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_CreatePartitions_result_topics(const rd_kafka_CreatePartitions_result_t *result, size_t *cntp);</span>
<span class="s1">typedef enum rd_kafka_ConfigSource_t {</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_UNKNOWN_CONFIG = 0,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_TOPIC_CONFIG = 1,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_BROKER_CONFIG = 2,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_DEFAULT_BROKER_CONFIG = 3,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_STATIC_BROKER_CONFIG = 4,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DEFAULT_CONFIG = 5,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE__CNT,</span>
<span class="s1">} rd_kafka_ConfigSource_t;</span>
<span class="s1">const char *rd_kafka_ConfigSource_name(rd_kafka_ConfigSource_t confsource);</span>
<span class="s1">typedef struct rd_kafka_ConfigEntry_s rd_kafka_ConfigEntry_t;</span>
<span class="s1">const char *rd_kafka_ConfigEntry_name(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">const char *rd_kafka_ConfigEntry_value(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">rd_kafka_ConfigSource_t rd_kafka_ConfigEntry_source(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_read_only(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_default(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_sensitive(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_synonym(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">const rd_kafka_ConfigEntry_t **rd_kafka_ConfigEntry_synonyms(const rd_kafka_ConfigEntry_t *entry, size_t *cntp);</span>
<span class="s1">typedef enum rd_kafka_ResourceType_t {</span>
<span class="s1">  RD_KAFKA_RESOURCE_UNKNOWN = 0,</span>
<span class="s1">  RD_KAFKA_RESOURCE_ANY = 1,</span>
<span class="s1">  RD_KAFKA_RESOURCE_TOPIC = 2,</span>
<span class="s1">  RD_KAFKA_RESOURCE_GROUP = 3,</span>
<span class="s1">  RD_KAFKA_RESOURCE_BROKER = 4,</span>
<span class="s1">  RD_KAFKA_RESOURCE__CNT,</span>
<span class="s1">} rd_kafka_ResourceType_t;</span>
<span class="s1">typedef enum rd_kafka_ResourcePatternType_t {</span>
<span class="s1">  RD_KAFKA_RESOURCE_PATTERN_UNKNOWN = 0,</span>
<span class="s1">  RD_KAFKA_RESOURCE_PATTERN_ANY = 1,</span>
<span class="s1">  RD_KAFKA_RESOURCE_PATTERN_MATCH = 2,</span>
<span class="s1">  RD_KAFKA_RESOURCE_PATTERN_LITERAL = 3,</span>
<span class="s1">  RD_KAFKA_RESOURCE_PATTERN_PREFIXED = 4,</span>
<span class="s1">  RD_KAFKA_RESOURCE_PATTERN_TYPE__CNT,</span>
<span class="s1">} rd_kafka_ResourcePatternType_t;</span>
<span class="s1">typedef enum rd_kafka_AlterConfigOpType_t {</span>
<span class="s1">  RD_KAFKA_ALTER_CONFIG_OP_TYPE_SET = 0,</span>
<span class="s1">  RD_KAFKA_ALTER_CONFIG_OP_TYPE_DELETE = 1,</span>
<span class="s1">  RD_KAFKA_ALTER_CONFIG_OP_TYPE_APPEND = 2,</span>
<span class="s1">  RD_KAFKA_ALTER_CONFIG_OP_TYPE_SUBTRACT = 3,</span>
<span class="s1">  RD_KAFKA_ALTER_CONFIG_OP_TYPE__CNT,</span>
<span class="s1">} rd_kafka_AlterConfigOpType_t;</span>
<span class="s1">const char *rd_kafka_ResourcePatternType_name(rd_kafka_ResourcePatternType_t resource_pattern_type);</span>
<span class="s1">const char *rd_kafka_ResourceType_name(rd_kafka_ResourceType_t restype);</span>
<span class="s1">typedef struct rd_kafka_ConfigResource_s rd_kafka_ConfigResource_t;</span>
<span class="s1">rd_kafka_ConfigResource_t *rd_kafka_ConfigResource_new(rd_kafka_ResourceType_t restype, const char *resname);</span>
<span class="s1">void rd_kafka_ConfigResource_destroy(rd_kafka_ConfigResource_t *config);</span>
<span class="s1">void rd_kafka_ConfigResource_destroy_array(rd_kafka_ConfigResource_t **config, size_t config_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_ConfigResource_set_config(rd_kafka_ConfigResource_t *config, const char *name, const char *value);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_ConfigResource_add_incremental_config(rd_kafka_ConfigResource_t *config, const char *name, rd_kafka_AlterConfigOpType_t op_type, const char *value);</span>
<span class="s1">const rd_kafka_ConfigEntry_t **rd_kafka_ConfigResource_configs(const rd_kafka_ConfigResource_t *config, size_t *cntp);</span>
<span class="s1">rd_kafka_ResourceType_t rd_kafka_ConfigResource_type(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">const char *rd_kafka_ConfigResource_name(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_ConfigResource_error(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">const char *rd_kafka_ConfigResource_error_string(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">void rd_kafka_AlterConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_ConfigResource_t **rd_kafka_AlterConfigs_result_resources(const rd_kafka_AlterConfigs_result_t *result, size_t *cntp);</span>
<span class="s1">void rd_kafka_IncrementalAlterConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_ConfigResource_t **rd_kafka_IncrementalAlterConfigs_result_resources(const rd_kafka_IncrementalAlterConfigs_result_t *result, size_t *cntp);</span>
<span class="s1">void rd_kafka_DescribeConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_ConfigResource_t **rd_kafka_DescribeConfigs_result_resources(const rd_kafka_DescribeConfigs_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_DeleteRecords_s rd_kafka_DeleteRecords_t;</span>
<span class="s1">rd_kafka_DeleteRecords_t *rd_kafka_DeleteRecords_new(const rd_kafka_topic_partition_list_t *before_offsets);</span>
<span class="s1">void rd_kafka_DeleteRecords_destroy(rd_kafka_DeleteRecords_t *del_records);</span>
<span class="s1">void rd_kafka_DeleteRecords_destroy_array(rd_kafka_DeleteRecords_t **del_records, size_t del_record_cnt);</span>
<span class="s1">void rd_kafka_DeleteRecords(rd_kafka_t *rk, rd_kafka_DeleteRecords_t **del_records, size_t del_record_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_partition_list_t *rd_kafka_DeleteRecords_result_offsets(const rd_kafka_DeleteRecords_result_t *result);</span>
<span class="s1">typedef struct rd_kafka_TopicCollection_s rd_kafka_TopicCollection_t;</span>
<span class="s1">typedef struct rd_kafka_TopicPartitionInfo_s rd_kafka_TopicPartitionInfo_t;</span>
<span class="s1">typedef struct rd_kafka_TopicDescription_s rd_kafka_TopicDescription_t;</span>
<span class="s1">rd_kafka_TopicCollection_t *rd_kafka_TopicCollection_of_topic_names(const char **topics, size_t topics_cnt);</span>
<span class="s1">void rd_kafka_TopicCollection_destroy(rd_kafka_TopicCollection_t *topics);</span>
<span class="s1">void rd_kafka_DescribeTopics(rd_kafka_t *rk, const rd_kafka_TopicCollection_t *topics, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_TopicDescription_t **rd_kafka_DescribeTopics_result_topics(const rd_kafka_DescribeTopics_result_t *result, size_t *cntp);</span>
<span class="s1">const rd_kafka_TopicPartitionInfo_t **rd_kafka_TopicDescription_partitions(const rd_kafka_TopicDescription_t *topicdesc, size_t *cntp);</span>
<span class="s1">const int rd_kafka_TopicPartitionInfo_partition(const rd_kafka_TopicPartitionInfo_t *partition);</span>
<span class="s1">const rd_kafka_Node_t *rd_kafka_TopicPartitionInfo_leader(const rd_kafka_TopicPartitionInfo_t *partition);</span>
<span class="s1">const rd_kafka_Node_t **rd_kafka_TopicPartitionInfo_isr(const rd_kafka_TopicPartitionInfo_t *partition, size_t *cntp);</span>
<span class="s1">const rd_kafka_Node_t **rd_kafka_TopicPartitionInfo_replicas(const rd_kafka_TopicPartitionInfo_t *partition, size_t *cntp);</span>
<span class="s1">const rd_kafka_AclOperation_t *rd_kafka_TopicDescription_authorized_operations(const rd_kafka_TopicDescription_t *topicdesc, size_t *cntp);</span>
<span class="s1">const char *rd_kafka_TopicDescription_name(const rd_kafka_TopicDescription_t *topicdesc);</span>
<span class="s1">const rd_kafka_Uuid_t *rd_kafka_TopicDescription_topic_id(const rd_kafka_TopicDescription_t *topicdesc);</span>
<span class="s1">int rd_kafka_TopicDescription_is_internal(const rd_kafka_TopicDescription_t *topicdesc);</span>
<span class="s1">const rd_kafka_error_t *rd_kafka_TopicDescription_error(const rd_kafka_TopicDescription_t *topicdesc);</span>
<span class="s1">void rd_kafka_DescribeCluster(rd_kafka_t *rk, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_Node_t **rd_kafka_DescribeCluster_result_nodes(const rd_kafka_DescribeCluster_result_t *result, size_t *cntp);</span>
<span class="s1">const rd_kafka_AclOperation_t *rd_kafka_DescribeCluster_result_authorized_operations(const rd_kafka_DescribeCluster_result_t *result, size_t *cntp);</span>
<span class="s1">const rd_kafka_Node_t *rd_kafka_DescribeCluster_result_controller(const rd_kafka_DescribeCluster_result_t *result);</span>
<span class="s1">const char *rd_kafka_DescribeCluster_result_cluster_id(const rd_kafka_DescribeCluster_result_t *result);</span>
<span class="s1">typedef struct rd_kafka_ConsumerGroupListing_s rd_kafka_ConsumerGroupListing_t;</span>
<span class="s1">typedef struct rd_kafka_ListConsumerGroupsResult_s rd_kafka_ListConsumerGroupsResult_t;</span>
<span class="s1">void rd_kafka_ListConsumerGroups(rd_kafka_t *rk, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const char *rd_kafka_ConsumerGroupListing_group_id(const rd_kafka_ConsumerGroupListing_t *grplist);</span>
<span class="s1">int rd_kafka_ConsumerGroupListing_is_simple_consumer_group(const rd_kafka_ConsumerGroupListing_t *grplist);</span>
<span class="s1">rd_kafka_consumer_group_state_t rd_kafka_ConsumerGroupListing_state(const rd_kafka_ConsumerGroupListing_t *grplist);</span>
<span class="s1">const rd_kafka_ConsumerGroupListing_t **rd_kafka_ListConsumerGroups_result_valid(const rd_kafka_ListConsumerGroups_result_t *result, size_t *cntp);</span>
<span class="s1">const rd_kafka_error_t **rd_kafka_ListConsumerGroups_result_errors(const rd_kafka_ListConsumerGroups_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_ConsumerGroupDescription_s rd_kafka_ConsumerGroupDescription_t;</span>
<span class="s1">typedef struct rd_kafka_MemberDescription_s rd_kafka_MemberDescription_t;</span>
<span class="s1">typedef struct rd_kafka_MemberAssignment_s rd_kafka_MemberAssignment_t;</span>
<span class="s1">void rd_kafka_DescribeConsumerGroups(rd_kafka_t *rk, const char **groups, size_t groups_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_ConsumerGroupDescription_t **rd_kafka_DescribeConsumerGroups_result_groups(const rd_kafka_DescribeConsumerGroups_result_t *result, size_t *cntp);</span>
<span class="s1">const char *rd_kafka_ConsumerGroupDescription_group_id(const rd_kafka_ConsumerGroupDescription_t *grpdesc);</span>
<span class="s1">const rd_kafka_error_t *rd_kafka_ConsumerGroupDescription_error(const rd_kafka_ConsumerGroupDescription_t *grpdesc);</span>
<span class="s1">int rd_kafka_ConsumerGroupDescription_is_simple_consumer_group(const rd_kafka_ConsumerGroupDescription_t *grpdesc);</span>
<span class="s1">const char *rd_kafka_ConsumerGroupDescription_partition_assignor(const rd_kafka_ConsumerGroupDescription_t *grpdesc);</span>
<span class="s1">const rd_kafka_AclOperation_t *rd_kafka_ConsumerGroupDescription_authorized_operations(const rd_kafka_ConsumerGroupDescription_t *grpdesc, size_t *cntp);</span>
<span class="s1">rd_kafka_consumer_group_state_t rd_kafka_ConsumerGroupDescription_state(const rd_kafka_ConsumerGroupDescription_t *grpdesc);</span>
<span class="s1">const rd_kafka_Node_t *rd_kafka_ConsumerGroupDescription_coordinator(const rd_kafka_ConsumerGroupDescription_t *grpdesc);</span>
<span class="s1">size_t rd_kafka_ConsumerGroupDescription_member_count(const rd_kafka_ConsumerGroupDescription_t *grpdesc);</span>
<span class="s1">const rd_kafka_MemberDescription_t *rd_kafka_ConsumerGroupDescription_member(const rd_kafka_ConsumerGroupDescription_t *grpdesc, size_t idx);</span>
<span class="s1">const char *rd_kafka_MemberDescription_client_id(const rd_kafka_MemberDescription_t *member);</span>
<span class="s1">const char *rd_kafka_MemberDescription_group_instance_id(const rd_kafka_MemberDescription_t *member);</span>
<span class="s1">const char *rd_kafka_MemberDescription_consumer_id(const rd_kafka_MemberDescription_t *member);</span>
<span class="s1">const char *rd_kafka_MemberDescription_host(const rd_kafka_MemberDescription_t *member);</span>
<span class="s1">const rd_kafka_MemberAssignment_t *rd_kafka_MemberDescription_assignment(const rd_kafka_MemberDescription_t *member);</span>
<span class="s1">const rd_kafka_topic_partition_list_t *rd_kafka_MemberAssignment_partitions(const rd_kafka_MemberAssignment_t *assignment);</span>
<span class="s1">typedef struct rd_kafka_DeleteGroup_s rd_kafka_DeleteGroup_t;</span>
<span class="s1">rd_kafka_DeleteGroup_t *rd_kafka_DeleteGroup_new(const char *group);</span>
<span class="s1">void rd_kafka_DeleteGroup_destroy(rd_kafka_DeleteGroup_t *del_group);</span>
<span class="s1">void rd_kafka_DeleteGroup_destroy_array(rd_kafka_DeleteGroup_t **del_groups, size_t del_group_cnt);</span>
<span class="s1">void rd_kafka_DeleteGroups(rd_kafka_t *rk, rd_kafka_DeleteGroup_t **del_groups, size_t del_group_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_group_result_t **rd_kafka_DeleteGroups_result_groups(const rd_kafka_DeleteGroups_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_ListConsumerGroupOffsets_s rd_kafka_ListConsumerGroupOffsets_t;</span>
<span class="s1">rd_kafka_ListConsumerGroupOffsets_t *rd_kafka_ListConsumerGroupOffsets_new(const char *group_id, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">void rd_kafka_ListConsumerGroupOffsets_destroy(rd_kafka_ListConsumerGroupOffsets_t *list_grpoffsets);</span>
<span class="s1">void rd_kafka_ListConsumerGroupOffsets_destroy_array(rd_kafka_ListConsumerGroupOffsets_t **list_grpoffsets, size_t list_grpoffset_cnt);</span>
<span class="s1">void rd_kafka_ListConsumerGroupOffsets(rd_kafka_t *rk, rd_kafka_ListConsumerGroupOffsets_t **list_grpoffsets, size_t list_grpoffsets_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_group_result_t **rd_kafka_ListConsumerGroupOffsets_result_groups(const rd_kafka_ListConsumerGroupOffsets_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_AlterConsumerGroupOffsets_s rd_kafka_AlterConsumerGroupOffsets_t;</span>
<span class="s1">rd_kafka_AlterConsumerGroupOffsets_t *rd_kafka_AlterConsumerGroupOffsets_new(const char *group_id, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">void rd_kafka_AlterConsumerGroupOffsets_destroy(rd_kafka_AlterConsumerGroupOffsets_t *alter_grpoffsets);</span>
<span class="s1">void rd_kafka_AlterConsumerGroupOffsets_destroy_array(rd_kafka_AlterConsumerGroupOffsets_t **alter_grpoffsets, size_t alter_grpoffset_cnt);</span>
<span class="s1">void rd_kafka_AlterConsumerGroupOffsets(rd_kafka_t *rk, rd_kafka_AlterConsumerGroupOffsets_t **alter_grpoffsets, size_t alter_grpoffsets_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_group_result_t **rd_kafka_AlterConsumerGroupOffsets_result_groups(const rd_kafka_AlterConsumerGroupOffsets_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_DeleteConsumerGroupOffsets_s rd_kafka_DeleteConsumerGroupOffsets_t;</span>
<span class="s1">rd_kafka_DeleteConsumerGroupOffsets_t *rd_kafka_DeleteConsumerGroupOffsets_new(const char *group, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">void rd_kafka_DeleteConsumerGroupOffsets_destroy(rd_kafka_DeleteConsumerGroupOffsets_t *del_grpoffsets);</span>
<span class="s1">void rd_kafka_DeleteConsumerGroupOffsets_destroy_array(rd_kafka_DeleteConsumerGroupOffsets_t **del_grpoffsets, size_t del_grpoffset_cnt);</span>
<span class="s1">void rd_kafka_DeleteConsumerGroupOffsets(rd_kafka_t *rk, rd_kafka_DeleteConsumerGroupOffsets_t **del_grpoffsets, size_t del_grpoffsets_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_group_result_t **rd_kafka_DeleteConsumerGroupOffsets_result_groups(const rd_kafka_DeleteConsumerGroupOffsets_result_t *result, size_t *cntp);</span>
<span class="s1">typedef enum rd_kafka_OffsetSpec_t {</span>
<span class="s1">  RD_KAFKA_OFFSET_SPEC_MAX_TIMESTAMP = (- 3),</span>
<span class="s1">  RD_KAFKA_OFFSET_SPEC_EARLIEST = (- 2),</span>
<span class="s1">  RD_KAFKA_OFFSET_SPEC_LATEST = (- 1),</span>
<span class="s1">} rd_kafka_OffsetSpec_t;</span>
<span class="s1">typedef struct rd_kafka_ListOffsetsResultInfo_s rd_kafka_ListOffsetsResultInfo_t;</span>
<span class="s1">const rd_kafka_topic_partition_t *rd_kafka_ListOffsetsResultInfo_topic_partition(const rd_kafka_ListOffsetsResultInfo_t *result_info);</span>
<span class="s1">int64_t rd_kafka_ListOffsetsResultInfo_timestamp(const rd_kafka_ListOffsetsResultInfo_t *result_info);</span>
<span class="s1">const rd_kafka_ListOffsetsResultInfo_t **rd_kafka_ListOffsets_result_infos(const rd_kafka_ListOffsets_result_t *result, size_t *cntp);</span>
<span class="s1">void rd_kafka_ListOffsets(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *topic_partitions, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">typedef enum rd_kafka_ScramMechanism_t {</span>
<span class="s1">  RD_KAFKA_SCRAM_MECHANISM_UNKNOWN = 0,</span>
<span class="s1">  RD_KAFKA_SCRAM_MECHANISM_SHA_256 = 1,</span>
<span class="s1">  RD_KAFKA_SCRAM_MECHANISM_SHA_512 = 2,</span>
<span class="s1">  RD_KAFKA_SCRAM_MECHANISM__CNT,</span>
<span class="s1">} rd_kafka_ScramMechanism_t;</span>
<span class="s1">typedef struct rd_kafka_ScramCredentialInfo_s rd_kafka_ScramCredentialInfo_t;</span>
<span class="s1">rd_kafka_ScramMechanism_t rd_kafka_ScramCredentialInfo_mechanism(const rd_kafka_ScramCredentialInfo_t *scram_credential_info);</span>
<span class="s1">int32_t rd_kafka_ScramCredentialInfo_iterations(const rd_kafka_ScramCredentialInfo_t *scram_credential_info);</span>
<span class="s1">typedef struct rd_kafka_UserScramCredentialsDescription_s rd_kafka_UserScramCredentialsDescription_t;</span>
<span class="s1">const char *rd_kafka_UserScramCredentialsDescription_user(const rd_kafka_UserScramCredentialsDescription_t *description);</span>
<span class="s1">const rd_kafka_error_t *rd_kafka_UserScramCredentialsDescription_error(const rd_kafka_UserScramCredentialsDescription_t *description);</span>
<span class="s1">size_t rd_kafka_UserScramCredentialsDescription_scramcredentialinfo_count(const rd_kafka_UserScramCredentialsDescription_t *description);</span>
<span class="s1">const rd_kafka_ScramCredentialInfo_t *rd_kafka_UserScramCredentialsDescription_scramcredentialinfo(const rd_kafka_UserScramCredentialsDescription_t *description, size_t idx);</span>
<span class="s1">const rd_kafka_UserScramCredentialsDescription_t **rd_kafka_DescribeUserScramCredentials_result_descriptions(const rd_kafka_DescribeUserScramCredentials_result_t *result, size_t *cntp);</span>
<span class="s1">void rd_kafka_DescribeUserScramCredentials(rd_kafka_t *rk, const char **users, size_t user_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">typedef struct rd_kafka_UserScramCredentialAlteration_s rd_kafka_UserScramCredentialAlteration_t;</span>
<span class="s1">rd_kafka_UserScramCredentialAlteration_t *rd_kafka_UserScramCredentialUpsertion_new(const char *username, rd_kafka_ScramMechanism_t mechanism, int32_t iterations, const unsigned char *password, size_t password_size, const unsigned char *salt, size_t salt_size);</span>
<span class="s1">rd_kafka_UserScramCredentialAlteration_t *rd_kafka_UserScramCredentialDeletion_new(const char *username, rd_kafka_ScramMechanism_t mechanism);</span>
<span class="s1">void rd_kafka_UserScramCredentialAlteration_destroy(rd_kafka_UserScramCredentialAlteration_t *alteration);</span>
<span class="s1">void rd_kafka_UserScramCredentialAlteration_destroy_array(rd_kafka_UserScramCredentialAlteration_t **alterations, size_t alteration_cnt);</span>
<span class="s1">typedef struct rd_kafka_AlterUserScramCredentials_result_response_s rd_kafka_AlterUserScramCredentials_result_response_t;</span>
<span class="s1">const char *rd_kafka_AlterUserScramCredentials_result_response_user(const rd_kafka_AlterUserScramCredentials_result_response_t *response);</span>
<span class="s1">const rd_kafka_error_t *rd_kafka_AlterUserScramCredentials_result_response_error(const rd_kafka_AlterUserScramCredentials_result_response_t *response);</span>
<span class="s1">const rd_kafka_AlterUserScramCredentials_result_response_t **rd_kafka_AlterUserScramCredentials_result_responses(const rd_kafka_AlterUserScramCredentials_result_t *result, size_t *cntp);</span>
<span class="s1">void rd_kafka_AlterUserScramCredentials(rd_kafka_t *rk, rd_kafka_UserScramCredentialAlteration_t **alterations, size_t alteration_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">typedef struct rd_kafka_AclBinding_s rd_kafka_AclBinding_t;</span>
<span class="s1">typedef rd_kafka_AclBinding_t rd_kafka_AclBindingFilter_t;</span>
<span class="s1">const rd_kafka_error_t *rd_kafka_acl_result_error(const rd_kafka_acl_result_t *aclres);</span>
<span class="s1">const char *rd_kafka_AclOperation_name(rd_kafka_AclOperation_t acl_operation);</span>
<span class="s1">typedef enum rd_kafka_AclPermissionType_t {</span>
<span class="s1">  RD_KAFKA_ACL_PERMISSION_TYPE_UNKNOWN = 0,</span>
<span class="s1">  RD_KAFKA_ACL_PERMISSION_TYPE_ANY = 1,</span>
<span class="s1">  RD_KAFKA_ACL_PERMISSION_TYPE_DENY = 2,</span>
<span class="s1">  RD_KAFKA_ACL_PERMISSION_TYPE_ALLOW = 3,</span>
<span class="s1">  RD_KAFKA_ACL_PERMISSION_TYPE__CNT,</span>
<span class="s1">} rd_kafka_AclPermissionType_t;</span>
<span class="s1">const char *rd_kafka_AclPermissionType_name(rd_kafka_AclPermissionType_t acl_permission_type);</span>
<span class="s1">rd_kafka_AclBinding_t *rd_kafka_AclBinding_new(rd_kafka_ResourceType_t restype, const char *name, rd_kafka_ResourcePatternType_t resource_pattern_type, const char *principal, const char *host, rd_kafka_AclOperation_t operation, rd_kafka_AclPermissionType_t permission_type, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_AclBindingFilter_t *rd_kafka_AclBindingFilter_new(rd_kafka_ResourceType_t restype, const char *name, rd_kafka_ResourcePatternType_t resource_pattern_type, const char *principal, const char *host, rd_kafka_AclOperation_t operation, rd_kafka_AclPermissionType_t permission_type, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_ResourceType_t rd_kafka_AclBinding_restype(const rd_kafka_AclBinding_t *acl);</span>
<span class="s1">const char *rd_kafka_AclBinding_name(const rd_kafka_AclBinding_t *acl);</span>
<span class="s1">const char *rd_kafka_AclBinding_principal(const rd_kafka_AclBinding_t *acl);</span>
<span class="s1">const char *rd_kafka_AclBinding_host(const rd_kafka_AclBinding_t *acl);</span>
<span class="s1">rd_kafka_AclOperation_t rd_kafka_AclBinding_operation(const rd_kafka_AclBinding_t *acl);</span>
<span class="s1">rd_kafka_AclPermissionType_t rd_kafka_AclBinding_permission_type(const rd_kafka_AclBinding_t *acl);</span>
<span class="s1">rd_kafka_ResourcePatternType_t rd_kafka_AclBinding_resource_pattern_type(const rd_kafka_AclBinding_t *acl);</span>
<span class="s1">const rd_kafka_error_t *rd_kafka_AclBinding_error(const rd_kafka_AclBinding_t *acl);</span>
<span class="s1">void rd_kafka_AclBinding_destroy(rd_kafka_AclBinding_t *acl_binding);</span>
<span class="s1">void rd_kafka_AclBinding_destroy_array(rd_kafka_AclBinding_t **acl_bindings, size_t acl_bindings_cnt);</span>
<span class="s1">const rd_kafka_acl_result_t **rd_kafka_CreateAcls_result_acls(const rd_kafka_CreateAcls_result_t *result, size_t *cntp);</span>
<span class="s1">void rd_kafka_CreateAcls(rd_kafka_t *rk, rd_kafka_AclBinding_t **new_acls, size_t new_acls_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_AclBinding_t **rd_kafka_DescribeAcls_result_acls(const rd_kafka_DescribeAcls_result_t *result, size_t *cntp);</span>
<span class="s1">void rd_kafka_DescribeAcls(rd_kafka_t *rk, rd_kafka_AclBindingFilter_t *acl_filter, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">typedef struct rd_kafka_DeleteAcls_result_response_s rd_kafka_DeleteAcls_result_response_t;</span>
<span class="s1">const rd_kafka_DeleteAcls_result_response_t **rd_kafka_DeleteAcls_result_responses(const rd_kafka_DeleteAcls_result_t *result, size_t *cntp);</span>
<span class="s1">const rd_kafka_error_t *rd_kafka_DeleteAcls_result_response_error(const rd_kafka_DeleteAcls_result_response_t *result_response);</span>
<span class="s1">const rd_kafka_AclBinding_t **rd_kafka_DeleteAcls_result_response_matching_acls(const rd_kafka_DeleteAcls_result_response_t *result_response, size_t *matching_acls_cntp);</span>
<span class="s1">void rd_kafka_DeleteAcls(rd_kafka_t *rk, rd_kafka_AclBindingFilter_t **del_acls, size_t del_acls_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token(rd_kafka_t *rk, const char *token_value, int64_t md_lifetime_ms, const char *md_principal_name, const char **extensions, size_t extension_size, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token_failure(rd_kafka_t *rk, const char *errstr);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_init_transactions(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_begin_transaction(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_send_offsets_to_transaction(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, const rd_kafka_consumer_group_metadata_t *cgmetadata, int timeout_ms);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_commit_transaction(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_abort_transaction(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">typedef struct rd_kafka_mock_cluster_s rd_kafka_mock_cluster_t;</span>
<span class="s1">rd_kafka_mock_cluster_t *rd_kafka_mock_cluster_new(rd_kafka_t *rk, int broker_cnt);</span>
<span class="s1">void rd_kafka_mock_cluster_destroy(rd_kafka_mock_cluster_t *mcluster);</span>
<span class="s1">rd_kafka_t *rd_kafka_mock_cluster_handle(const rd_kafka_mock_cluster_t *mcluster);</span>
<span class="s1">rd_kafka_mock_cluster_t *rd_kafka_handle_mock_cluster(const rd_kafka_t *rk);</span>
<span class="s1">const char *rd_kafka_mock_cluster_bootstraps(const rd_kafka_mock_cluster_t *mcluster);</span>
<span class="s1">void rd_kafka_mock_clear_request_errors(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey);</span>
<span class="s1">void rd_kafka_mock_push_request_errors(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, size_t cnt, ...);</span>
<span class="s1">void rd_kafka_mock_push_request_errors_array(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, size_t cnt, const rd_kafka_resp_err_t *errors);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_push_request_error_rtts(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int16_t ApiKey, size_t cnt, ...);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_error_stack_cnt(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int16_t ApiKey, size_t *cntp);</span>
<span class="s1">void rd_kafka_mock_topic_set_error(rd_kafka_mock_cluster_t *mcluster, const char *topic, rd_kafka_resp_err_t err);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_topic_create(rd_kafka_mock_cluster_t *mcluster, const char *topic, int partition_cnt, int replication_factor);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_partition_set_leader(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_partition_set_follower(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_partition_set_follower_wmarks(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int64_t lo, int64_t hi);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_partition_push_leader_response(rd_kafka_mock_cluster_t *mcluster, const char *topic, int partition, int32_t leader_id, int32_t leader_epoch);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_set_down(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_set_up(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_set_rtt(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int rtt_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_set_rack(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, const char *rack);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_coordinator_set(rd_kafka_mock_cluster_t *mcluster, const char *key_type, const char *key, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_set_apiversion(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, int16_t MinVersion, int16_t MaxVersion);</span>
<span class="s1">void rd_kafka_mock_start_request_tracking(rd_kafka_mock_cluster_t *mcluster);</span>
<span class="s1">void rd_kafka_mock_stop_request_tracking(rd_kafka_mock_cluster_t *mcluster);</span>
<span class="s1">typedef struct rd_kafka_mock_request_s rd_kafka_mock_request_t;</span>
<span class="s1">void rd_kafka_mock_request_destroy(rd_kafka_mock_request_t *mreq);</span>
<span class="s1">void rd_kafka_mock_request_destroy_array(rd_kafka_mock_request_t **mreqs, size_t mreq_cnt);</span>
<span class="s1">int32_t rd_kafka_mock_request_id(rd_kafka_mock_request_t *mreq);</span>
<span class="s1">int16_t rd_kafka_mock_request_api_key(rd_kafka_mock_request_t *mreq);</span>
<span class="s1">int64_t rd_kafka_mock_request_timestamp(rd_kafka_mock_request_t *mreq);</span>
<span class="s1">rd_kafka_mock_request_t **rd_kafka_mock_get_requests(rd_kafka_mock_cluster_t *mcluster, size_t *cntp);</span>
<span class="s1">void rd_kafka_mock_clear_requests(rd_kafka_mock_cluster_t *mcluster);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_telemetry_set_requested_metrics(rd_kafka_mock_cluster_t *mcluster, char **metrics, size_t metrics_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_telemetry_set_push_interval(rd_kafka_mock_cluster_t *mcluster, int64_t push_interval_ms);</span>
<span class="s1">&#39;</span>
</code></pre></div>
rdkafka.h, rdkafka_mock.h</p>
<h3 id="rd_kafka_version_33">RD_KAFKA_VERSION<a class="headerlink" href="#rd_kafka_version_33" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_VERSION</span> <span class="o">=</span> <span class="mi">33947903</span>
</code></pre></div>
<p>librdkafka version </p>
<p>Interpreted as hex <code>MM.mm.rr.xx</code>:</p>
<ul>
<li>MM = Major</li>
<li>mm = minor</li>
<li>rr = revision</li>
<li>xx = pre-release id (0xff is the final release)</li>
</ul>
<p>E.g.: <code>0x000801ff</code> = 0.8.1</p>
<dl class="section remark"><dt>Remarks</dt><dd>This value should only be used during compile time, for runtime checks of version use rd_kafka_version() </dd></dl>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_unsupported_compression_type_33">RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE<a class="headerlink" href="#rd_kafka_resp_err_unsupported_compression_type_33" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE</span> <span class="o">=</span> <span class="mi">76</span>
</code></pre></div>
<p>Unsupported compression type </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_end_all_33">RD_KAFKA_RESP_ERR_END_ALL<a class="headerlink" href="#rd_kafka_resp_err_end_all_33" title="Permanent link">&para;</a></h3>
<p><div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_END_ALL</span> <span class="o">=</span> <span class="mi">119</span>
</code></pre></div>
enum rd_kafka_resp_err_t</p>
<h3 id="rd_kafka_admin_op__cnt_33">RD_KAFKA_ADMIN_OP__CNT<a class="headerlink" href="#rd_kafka_admin_op__cnt_33" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_ADMIN_OP__CNT</span> <span class="o">=</span> <span class="mi">23</span>
</code></pre></div>
<p>Number of ops defined </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe </a></li>
</ul>
</div>
<h3 id="rd_kafka_resource__cnt_33">RD_KAFKA_RESOURCE__CNT<a class="headerlink" href="#rd_kafka_resource__cnt_33" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESOURCE__CNT</span> <span class="o">=</span> <span class="mi">6</span>
</code></pre></div>
<p>Number of resource types defined </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#acca83a66d7783ff7683ed2691cc907c9"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#acca83a66d7783ff7683ed2691cc907c9 </a></li>
</ul>
</div>
<h3 id="rd_kafka_cdef_33">RD_KAFKA_CDEF<a class="headerlink" href="#rd_kafka_cdef_33" title="Permanent link">&para;</a></h3>
<p><div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_CDEF</span> <span class="o">=</span> <span class="s1">&#39;typedef long int ssize_t;</span>
<span class="s1">typedef struct _IO_FILE FILE;</span>
<span class="s1">typedef long int mode_t;</span>
<span class="s1">typedef signed int int16_t;</span>
<span class="s1">typedef unsigned int uint16_t;</span>
<span class="s1">typedef signed int int32_t;</span>
<span class="s1">typedef signed long int int64_t;</span>
<span class="s1">int rd_kafka_version(void);</span>
<span class="s1">const char *rd_kafka_version_str(void);</span>
<span class="s1">typedef enum rd_kafka_type_t {</span>
<span class="s1">  RD_KAFKA_PRODUCER,</span>
<span class="s1">  RD_KAFKA_CONSUMER,</span>
<span class="s1">} rd_kafka_type_t;</span>
<span class="s1">typedef enum rd_kafka_timestamp_type_t {</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_NOT_AVAILABLE,</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_CREATE_TIME,</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_LOG_APPEND_TIME,</span>
<span class="s1">} rd_kafka_timestamp_type_t;</span>
<span class="s1">const char *rd_kafka_get_debug_contexts(void);</span>
<span class="s1">typedef struct rd_kafka_s rd_kafka_t;</span>
<span class="s1">typedef struct rd_kafka_topic_s rd_kafka_topic_t;</span>
<span class="s1">typedef struct rd_kafka_conf_s rd_kafka_conf_t;</span>
<span class="s1">typedef struct rd_kafka_topic_conf_s rd_kafka_topic_conf_t;</span>
<span class="s1">typedef struct rd_kafka_queue_s rd_kafka_queue_t;</span>
<span class="s1">typedef struct rd_kafka_op_s rd_kafka_event_t;</span>
<span class="s1">typedef struct rd_kafka_topic_result_s rd_kafka_topic_result_t;</span>
<span class="s1">typedef struct rd_kafka_consumer_group_metadata_s rd_kafka_consumer_group_metadata_t;</span>
<span class="s1">typedef struct rd_kafka_error_s {</span>
<span class="s1">  unsigned int code;</span>
<span class="s1">  char *errstr;</span>
<span class="s1">  unsigned char fatal;</span>
<span class="s1">  unsigned char retriable;</span>
<span class="s1">  unsigned char txn_requires_abort;</span>
<span class="s1">} rd_kafka_error_t;</span>
<span class="s1">typedef struct rd_kafka_headers_s rd_kafka_headers_t;</span>
<span class="s1">typedef struct rd_kafka_group_result_s rd_kafka_group_result_t;</span>
<span class="s1">typedef struct rd_kafka_acl_result_s rd_kafka_acl_result_t;</span>
<span class="s1">typedef struct rd_kafka_Uuid_s rd_kafka_Uuid_t;</span>
<span class="s1">typedef struct rd_kafka_topic_partition_result_s rd_kafka_topic_partition_result_t;</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BEGIN = (- 200),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BAD_MSG = (- 199),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BAD_COMPRESSION = (- 198),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__DESTROY = (- 197),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FAIL = (- 196),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TRANSPORT = (- 195),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__CRIT_SYS_RESOURCE = (- 194),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__RESOLVE = (- 193),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__MSG_TIMED_OUT = (- 192),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PARTITION_EOF = (- 191),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION = (- 190),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FS = (- 189),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC = (- 188),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ALL_BROKERS_DOWN = (- 187),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INVALID_ARG = (- 186),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TIMED_OUT = (- 185),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__QUEUE_FULL = (- 184),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ISR_INSUFF = (- 183),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NODE_UPDATE = (- 182),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__SSL = (- 181),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__WAIT_COORD = (- 180),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_GROUP = (- 179),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__IN_PROGRESS = (- 178),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PREV_IN_PROGRESS = (- 177),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__EXISTING_SUBSCRIPTION = (- 176),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS = (- 175),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS = (- 174),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__CONFLICT = (- 173),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__STATE = (- 172),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_PROTOCOL = (- 171),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED = (- 170),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__AUTHENTICATION = (- 169),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NO_OFFSET = (- 168),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__OUTDATED = (- 167),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TIMED_OUT_QUEUE = (- 166),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNSUPPORTED_FEATURE = (- 165),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__WAIT_CACHE = (- 164),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INTR = (- 163),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__KEY_SERIALIZATION = (- 162),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__VALUE_SERIALIZATION = (- 161),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__KEY_DESERIALIZATION = (- 160),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__VALUE_DESERIALIZATION = (- 159),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PARTIAL = (- 158),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__READ_ONLY = (- 157),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOENT = (- 156),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNDERFLOW = (- 155),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INVALID_TYPE = (- 154),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__RETRY = (- 153),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PURGE_QUEUE = (- 152),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PURGE_INFLIGHT = (- 151),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FATAL = (- 150),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INCONSISTENT = (- 149),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__GAPLESS_GUARANTEE = (- 148),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__MAX_POLL_EXCEEDED = (- 147),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_BROKER = (- 146),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOT_CONFIGURED = (- 145),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FENCED = (- 144),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__APPLICATION = (- 143),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ASSIGNMENT_LOST = (- 142),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOOP = (- 141),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__AUTO_OFFSET_RESET = (- 140),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__LOG_TRUNCATION = (- 139),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INVALID_DIFFERENT_RECORD = (- 138),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__END = (- 100),</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN = (- 1),</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NO_ERROR = 0,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_OUT_OF_RANGE = 1,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_MSG = 2,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART = 3,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_MSG_SIZE = 4,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE = 5,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_LEADER_FOR_PARTITION = 6,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REQUEST_TIMED_OUT = 7,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_BROKER_NOT_AVAILABLE = 8,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REPLICA_NOT_AVAILABLE = 9,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE = 10,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_STALE_CTRL_EPOCH = 11,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_METADATA_TOO_LARGE = 12,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NETWORK_EXCEPTION = 13,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_COORDINATOR_LOAD_IN_PROGRESS = 14,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_COORDINATOR_NOT_AVAILABLE = 15,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_COORDINATOR = 16,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_EXCEPTION = 17,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_RECORD_LIST_TOO_LARGE = 18,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS = 19,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS_AFTER_APPEND = 20,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REQUIRED_ACKS = 21,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ILLEGAL_GENERATION = 22,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INCONSISTENT_GROUP_PROTOCOL = 23,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_GROUP_ID = 24,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_MEMBER_ID = 25,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_SESSION_TIMEOUT = 26,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REBALANCE_IN_PROGRESS = 27,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_COMMIT_OFFSET_SIZE = 28,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_AUTHORIZATION_FAILED = 29,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_AUTHORIZATION_FAILED = 30,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_CLUSTER_AUTHORIZATION_FAILED = 31,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TIMESTAMP = 32,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_SASL_MECHANISM = 33,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ILLEGAL_SASL_STATE = 34,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_VERSION = 35,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_ALREADY_EXISTS = 36,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PARTITIONS = 37,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REPLICATION_FACTOR = 38,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REPLICA_ASSIGNMENT = 39,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_CONFIG = 40,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_CONTROLLER = 41,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REQUEST = 42,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_FOR_MESSAGE_FORMAT = 43,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_POLICY_VIOLATION = 44,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OUT_OF_ORDER_SEQUENCE_NUMBER = 45,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DUPLICATE_SEQUENCE_NUMBER = 46,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_EPOCH = 47,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TXN_STATE = 48,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_ID_MAPPING = 49,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TRANSACTION_TIMEOUT = 50,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_CONCURRENT_TRANSACTIONS = 51,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TRANSACTION_COORDINATOR_FENCED = 52,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TRANSACTIONAL_ID_AUTHORIZATION_FAILED = 53,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_SECURITY_DISABLED = 54,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OPERATION_NOT_ATTEMPTED = 55,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_KAFKA_STORAGE_ERROR = 56,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LOG_DIR_NOT_FOUND = 57,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_SASL_AUTHENTICATION_FAILED = 58,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_PRODUCER_ID = 59,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REASSIGNMENT_IN_PROGRESS = 60,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTH_DISABLED = 61,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_NOT_FOUND = 62,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_OWNER_MISMATCH = 63,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_REQUEST_NOT_ALLOWED = 64,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTHORIZATION_FAILED = 65,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_EXPIRED = 66,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRINCIPAL_TYPE = 67,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NON_EMPTY_GROUP = 68,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_ID_NOT_FOUND = 69,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FETCH_SESSION_ID_NOT_FOUND = 70,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_FETCH_SESSION_EPOCH = 71,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LISTENER_NOT_FOUND = 72,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_DELETION_DISABLED = 73,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FENCED_LEADER_EPOCH = 74,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_LEADER_EPOCH = 75,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_STALE_BROKER_EPOCH = 77,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_NOT_AVAILABLE = 78,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_MEMBER_ID_REQUIRED = 79,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_PREFERRED_LEADER_NOT_AVAILABLE = 80,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_MAX_SIZE_REACHED = 81,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FENCED_INSTANCE_ID = 82,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ELIGIBLE_LEADERS_NOT_AVAILABLE = 83,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ELECTION_NOT_NEEDED = 84,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NO_REASSIGNMENT_IN_PROGRESS = 85,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_SUBSCRIBED_TO_TOPIC = 86,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_RECORD = 87,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSTABLE_OFFSET_COMMIT = 88,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_THROTTLING_QUOTA_EXCEEDED = 89,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_PRODUCER_FENCED = 90,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_RESOURCE_NOT_FOUND = 91,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DUPLICATE_RESOURCE = 92,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNACCEPTABLE_CREDENTIAL = 93,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INCONSISTENT_VOTER_SET = 94,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_UPDATE_VERSION = 95,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FEATURE_UPDATE_FAILED = 96,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_PRINCIPAL_DESERIALIZATION_FAILURE = 97,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_ID = 100,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FENCED_MEMBER_EPOCH = 110,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNRELEASED_INSTANCE_ID = 111,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_ASSIGNOR = 112,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_STALE_MEMBER_EPOCH = 113,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_SUBSCRIPTION_ID = 117,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TELEMETRY_TOO_LARGE = 118,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_END_ALL,</span>
<span class="s1">} rd_kafka_resp_err_t;</span>
<span class="s1">struct rd_kafka_err_desc {</span>
<span class="s1">  rd_kafka_resp_err_t code;</span>
<span class="s1">  char *name;</span>
<span class="s1">  char *desc;</span>
<span class="s1">};</span>
<span class="s1">void rd_kafka_get_err_descs(const struct rd_kafka_err_desc **errdescs, size_t *cntp);</span>
<span class="s1">const char *rd_kafka_err2str(rd_kafka_resp_err_t err);</span>
<span class="s1">const char *rd_kafka_err2name(rd_kafka_resp_err_t err);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_last_error(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_errno2err(int errnox);</span>
<span class="s1">int rd_kafka_errno(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_fatal_error(rd_kafka_t *rk, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_test_fatal_error(rd_kafka_t *rk, rd_kafka_resp_err_t err, const char *reason);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_error_code(const rd_kafka_error_t *error);</span>
<span class="s1">const char *rd_kafka_error_name(const rd_kafka_error_t *error);</span>
<span class="s1">const char *rd_kafka_error_string(const rd_kafka_error_t *error);</span>
<span class="s1">int rd_kafka_error_is_fatal(const rd_kafka_error_t *error);</span>
<span class="s1">int rd_kafka_error_is_retriable(const rd_kafka_error_t *error);</span>
<span class="s1">int rd_kafka_error_txn_requires_abort(const rd_kafka_error_t *error);</span>
<span class="s1">void rd_kafka_error_destroy(rd_kafka_error_t *error);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_error_new(rd_kafka_resp_err_t code, const char *fmt, ...);</span>
<span class="s1">typedef struct rd_kafka_topic_partition_s {</span>
<span class="s1">  char *topic;</span>
<span class="s1">  int32_t partition;</span>
<span class="s1">  int64_t offset;</span>
<span class="s1">  void *metadata;</span>
<span class="s1">  size_t metadata_size;</span>
<span class="s1">  void *opaque;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  void *_private;</span>
<span class="s1">} rd_kafka_topic_partition_t;</span>
<span class="s1">void rd_kafka_topic_partition_destroy(rd_kafka_topic_partition_t *rktpar);</span>
<span class="s1">void rd_kafka_topic_partition_set_leader_epoch(rd_kafka_topic_partition_t *rktpar, int32_t leader_epoch);</span>
<span class="s1">int32_t rd_kafka_topic_partition_get_leader_epoch(const rd_kafka_topic_partition_t *rktpar);</span>
<span class="s1">typedef struct rd_kafka_topic_partition_list_s {</span>
<span class="s1">  int cnt;</span>
<span class="s1">  int size;</span>
<span class="s1">  rd_kafka_topic_partition_t *elems;</span>
<span class="s1">} rd_kafka_topic_partition_list_t;</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_new(int size);</span>
<span class="s1">void rd_kafka_topic_partition_list_destroy(rd_kafka_topic_partition_list_t *rkparlist);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_add(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">void rd_kafka_topic_partition_list_add_range(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t start, int32_t stop);</span>
<span class="s1">int rd_kafka_topic_partition_list_del(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">int rd_kafka_topic_partition_list_del_by_idx(rd_kafka_topic_partition_list_t *rktparlist, int idx);</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_copy(const rd_kafka_topic_partition_list_t *src);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_topic_partition_list_set_offset(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition, int64_t offset);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_find(const rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">void rd_kafka_topic_partition_list_sort(rd_kafka_topic_partition_list_t *rktparlist, int (*cmp)(const void *a, const void *b, void *cmp_opaque), void *cmp_opaque);</span>
<span class="s1">typedef enum rd_kafka_vtype_t {</span>
<span class="s1">  RD_KAFKA_VTYPE_END,</span>
<span class="s1">  RD_KAFKA_VTYPE_TOPIC,</span>
<span class="s1">  RD_KAFKA_VTYPE_RKT,</span>
<span class="s1">  RD_KAFKA_VTYPE_PARTITION,</span>
<span class="s1">  RD_KAFKA_VTYPE_VALUE,</span>
<span class="s1">  RD_KAFKA_VTYPE_KEY,</span>
<span class="s1">  RD_KAFKA_VTYPE_OPAQUE,</span>
<span class="s1">  RD_KAFKA_VTYPE_MSGFLAGS,</span>
<span class="s1">  RD_KAFKA_VTYPE_TIMESTAMP,</span>
<span class="s1">  RD_KAFKA_VTYPE_HEADER,</span>
<span class="s1">  RD_KAFKA_VTYPE_HEADERS,</span>
<span class="s1">} rd_kafka_vtype_t;</span>
<span class="s1">typedef struct rd_kafka_vu_s {</span>
<span class="s1">  rd_kafka_vtype_t vtype;</span>
<span class="s1">  union {</span>
<span class="s1">    char *cstr;</span>
<span class="s1">    rd_kafka_topic_t *rkt;</span>
<span class="s1">    int i;</span>
<span class="s1">    int32_t i32;</span>
<span class="s1">    int64_t i64;</span>
<span class="s1">    struct {</span>
<span class="s1">      void *ptr;</span>
<span class="s1">      size_t size;</span>
<span class="s1">    } mem;</span>
<span class="s1">    struct {</span>
<span class="s1">      char *name;</span>
<span class="s1">      void *val;</span>
<span class="s1">      ssize_t size;</span>
<span class="s1">    } header;</span>
<span class="s1">    rd_kafka_headers_t *headers;</span>
<span class="s1">    void *ptr;</span>
<span class="s1">    char _pad[64];</span>
<span class="s1">  } u;</span>
<span class="s1">} rd_kafka_vu_t;</span>
<span class="s1">rd_kafka_headers_t *rd_kafka_headers_new(size_t initial_count);</span>
<span class="s1">void rd_kafka_headers_destroy(rd_kafka_headers_t *hdrs);</span>
<span class="s1">rd_kafka_headers_t *rd_kafka_headers_copy(const rd_kafka_headers_t *src);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_add(rd_kafka_headers_t *hdrs, const char *name, ssize_t name_size, const void *value, ssize_t value_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_remove(rd_kafka_headers_t *hdrs, const char *name);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get_last(const rd_kafka_headers_t *hdrs, const char *name, const void **valuep, size_t *sizep);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get(const rd_kafka_headers_t *hdrs, size_t idx, const char *name, const void **valuep, size_t *sizep);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get_all(const rd_kafka_headers_t *hdrs, size_t idx, const char **namep, const void **valuep, size_t *sizep);</span>
<span class="s1">typedef struct rd_kafka_message_s {</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  rd_kafka_topic_t *rkt;</span>
<span class="s1">  int32_t partition;</span>
<span class="s1">  void *payload;</span>
<span class="s1">  size_t len;</span>
<span class="s1">  void *key;</span>
<span class="s1">  size_t key_len;</span>
<span class="s1">  int64_t offset;</span>
<span class="s1">  void *_private;</span>
<span class="s1">} rd_kafka_message_t;</span>
<span class="s1">void rd_kafka_message_destroy(rd_kafka_message_t *rkmessage);</span>
<span class="s1">const char *rd_kafka_message_errstr(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">const char *rd_kafka_message_produce_errstr(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">int64_t rd_kafka_message_timestamp(const rd_kafka_message_t *rkmessage, rd_kafka_timestamp_type_t *tstype);</span>
<span class="s1">int64_t rd_kafka_message_latency(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">int32_t rd_kafka_message_broker_id(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_message_headers(const rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_message_detach_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);</span>
<span class="s1">void rd_kafka_message_set_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t *hdrs);</span>
<span class="s1">size_t rd_kafka_header_cnt(const rd_kafka_headers_t *hdrs);</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_NOT_PERSISTED = 0,</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_POSSIBLY_PERSISTED = 1,</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_PERSISTED = 2,</span>
<span class="s1">} rd_kafka_msg_status_t;</span>
<span class="s1">rd_kafka_msg_status_t rd_kafka_message_status(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">int32_t rd_kafka_message_leader_epoch(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">const char *rd_kafka_Uuid_base64str(const rd_kafka_Uuid_t *uuid);</span>
<span class="s1">int64_t rd_kafka_Uuid_least_significant_bits(const rd_kafka_Uuid_t *uuid);</span>
<span class="s1">int64_t rd_kafka_Uuid_most_significant_bits(const rd_kafka_Uuid_t *uuid);</span>
<span class="s1">rd_kafka_Uuid_t *rd_kafka_Uuid_new(int64_t most_significant_bits, int64_t least_significant_bits);</span>
<span class="s1">rd_kafka_Uuid_t *rd_kafka_Uuid_copy(const rd_kafka_Uuid_t *uuid);</span>
<span class="s1">void rd_kafka_Uuid_destroy(rd_kafka_Uuid_t *uuid);</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_CONF_UNKNOWN = (- 2),</span>
<span class="s1">  RD_KAFKA_CONF_INVALID = (- 1),</span>
<span class="s1">  RD_KAFKA_CONF_OK = 0,</span>
<span class="s1">} rd_kafka_conf_res_t;</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_new(void);</span>
<span class="s1">void rd_kafka_conf_destroy(rd_kafka_conf_t *conf);</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_dup(const rd_kafka_conf_t *conf);</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_dup_filter(const rd_kafka_conf_t *conf, size_t filter_cnt, const char **filter);</span>
<span class="s1">const rd_kafka_conf_t *rd_kafka_conf(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_set(rd_kafka_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_conf_set_events(rd_kafka_conf_t *conf, int events);</span>
<span class="s1">void rd_kafka_conf_set_background_event_cb(rd_kafka_conf_t *conf, void (*event_cb)(rd_kafka_t *rk, rd_kafka_event_t *rkev, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_dr_cb(rd_kafka_conf_t *conf, void (*dr_cb)(rd_kafka_t *rk, void *payload, size_t len, rd_kafka_resp_err_t err, void *opaque, void *msg_opaque));</span>
<span class="s1">void rd_kafka_conf_set_dr_msg_cb(rd_kafka_conf_t *conf, void (*dr_msg_cb)(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_consume_cb(rd_kafka_conf_t *conf, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_rebalance_cb(rd_kafka_conf_t *conf, void (*rebalance_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *partitions, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_offset_commit_cb(rd_kafka_conf_t *conf, void (*offset_commit_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_error_cb(rd_kafka_conf_t *conf, void (*error_cb)(rd_kafka_t *rk, int err, const char *reason, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_throttle_cb(rd_kafka_conf_t *conf, void (*throttle_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int throttle_time_ms, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_log_cb(rd_kafka_conf_t *conf, void (*log_cb)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));</span>
<span class="s1">void rd_kafka_conf_set_stats_cb(rd_kafka_conf_t *conf, int (*stats_cb)(rd_kafka_t *rk, char *json, size_t json_len, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_oauthbearer_token_refresh_cb(rd_kafka_conf_t *conf, void (*oauthbearer_token_refresh_cb)(rd_kafka_t *rk, const char *oauthbearer_config, void *opaque));</span>
<span class="s1">void rd_kafka_conf_enable_sasl_queue(rd_kafka_conf_t *conf, int enable);</span>
<span class="s1">void rd_kafka_conf_set_socket_cb(rd_kafka_conf_t *conf, int (*socket_cb)(int domain, int type, int protocol, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_connect_cb(rd_kafka_conf_t *conf, int (*connect_cb)(int sockfd, const struct sockaddr *addr, int addrlen, const char *id, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_closesocket_cb(rd_kafka_conf_t *conf, int (*closesocket_cb)(int sockfd, void *opaque));</span>
<span class="s1">struct addrinfo;</span>
<span class="s1">void rd_kafka_conf_set_resolve_cb(rd_kafka_conf_t *conf, int (*resolve_cb)(const char *node, const char *service, const struct addrinfo *hints, struct addrinfo **res, void *opaque));</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert_verify_cb(rd_kafka_conf_t *conf, int (*ssl_cert_verify_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int *x509_error, int depth, const char *buf, size_t size, char *errstr, size_t errstr_size, void *opaque));</span>
<span class="s1">typedef enum rd_kafka_cert_type_t {</span>
<span class="s1">  RD_KAFKA_CERT_PUBLIC_KEY,</span>
<span class="s1">  RD_KAFKA_CERT_PRIVATE_KEY,</span>
<span class="s1">  RD_KAFKA_CERT_CA,</span>
<span class="s1">  RD_KAFKA_CERT__CNT,</span>
<span class="s1">} rd_kafka_cert_type_t;</span>
<span class="s1">typedef enum rd_kafka_cert_enc_t {</span>
<span class="s1">  RD_KAFKA_CERT_ENC_PKCS12,</span>
<span class="s1">  RD_KAFKA_CERT_ENC_DER,</span>
<span class="s1">  RD_KAFKA_CERT_ENC_PEM,</span>
<span class="s1">  RD_KAFKA_CERT_ENC__CNT,</span>
<span class="s1">} rd_kafka_cert_enc_t;</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert(rd_kafka_conf_t *conf, rd_kafka_cert_type_t cert_type, rd_kafka_cert_enc_t cert_enc, const void *buffer, size_t size, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_conf_set_engine_callback_data(rd_kafka_conf_t *conf, void *callback_data);</span>
<span class="s1">void rd_kafka_conf_set_opaque(rd_kafka_conf_t *conf, void *opaque);</span>
<span class="s1">void *rd_kafka_opaque(const rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_conf_set_default_topic_conf(rd_kafka_conf_t *conf, rd_kafka_topic_conf_t *tconf);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_conf_get_default_topic_conf(rd_kafka_conf_t *conf);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_get(const rd_kafka_conf_t *conf, const char *name, char *dest, size_t *dest_size);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_topic_conf_get(const rd_kafka_topic_conf_t *conf, const char *name, char *dest, size_t *dest_size);</span>
<span class="s1">const char **rd_kafka_conf_dump(rd_kafka_conf_t *conf, size_t *cntp);</span>
<span class="s1">const char **rd_kafka_topic_conf_dump(rd_kafka_topic_conf_t *conf, size_t *cntp);</span>
<span class="s1">void rd_kafka_conf_dump_free(const char **arr, size_t cnt);</span>
<span class="s1">void rd_kafka_conf_properties_show(FILE *fp);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_topic_conf_new(void);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_topic_conf_dup(const rd_kafka_topic_conf_t *conf);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_default_topic_conf_dup(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_topic_conf_destroy(rd_kafka_topic_conf_t *topic_conf);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_topic_conf_set(rd_kafka_topic_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_topic_conf_set_opaque(rd_kafka_topic_conf_t *conf, void *rkt_opaque);</span>
<span class="s1">void rd_kafka_topic_conf_set_partitioner_cb(rd_kafka_topic_conf_t *topic_conf, int32_t (*partitioner)(const rd_kafka_topic_t *rkt, const void *keydata, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque));</span>
<span class="s1">void rd_kafka_topic_conf_set_msg_order_cmp(rd_kafka_topic_conf_t *topic_conf, int (*msg_order_cmp)(const rd_kafka_message_t *a, const rd_kafka_message_t *b));</span>
<span class="s1">int rd_kafka_topic_partition_available(const rd_kafka_topic_t *rkt, int32_t partition);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_consistent(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_consistent_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_murmur2(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_murmur2_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_fnv1a(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_fnv1a_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">rd_kafka_t *rd_kafka_new(rd_kafka_type_t type, rd_kafka_conf_t *conf, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_destroy(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_destroy_flags(rd_kafka_t *rk, int flags);</span>
<span class="s1">const char *rd_kafka_name(const rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_type_t rd_kafka_type(const rd_kafka_t *rk);</span>
<span class="s1">char *rd_kafka_memberid(const rd_kafka_t *rk);</span>
<span class="s1">char *rd_kafka_clusterid(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">int32_t rd_kafka_controllerid(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_topic_t *rd_kafka_topic_new(rd_kafka_t *rk, const char *topic, rd_kafka_topic_conf_t *conf);</span>
<span class="s1">void rd_kafka_topic_destroy(rd_kafka_topic_t *rkt);</span>
<span class="s1">const char *rd_kafka_topic_name(const rd_kafka_topic_t *rkt);</span>
<span class="s1">void *rd_kafka_topic_opaque(const rd_kafka_topic_t *rkt);</span>
<span class="s1">int rd_kafka_poll(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">void rd_kafka_yield(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_pause_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_resume_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_query_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_get_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offsets_for_times(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets, int timeout_ms);</span>
<span class="s1">void *rd_kafka_mem_calloc(rd_kafka_t *rk, size_t num, size_t size);</span>
<span class="s1">void *rd_kafka_mem_malloc(rd_kafka_t *rk, size_t size);</span>
<span class="s1">void rd_kafka_mem_free(rd_kafka_t *rk, void *ptr);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_new(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_queue_destroy(rd_kafka_queue_t *rkqu);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_main(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_sasl(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_sasl_background_callbacks_enable(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_sasl_set_credentials(rd_kafka_t *rk, const char *username, const char *password);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_consumer(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_partition(rd_kafka_t *rk, const char *topic, int32_t partition);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_background(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_queue_forward(rd_kafka_queue_t *src, rd_kafka_queue_t *dst);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_set_log_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu);</span>
<span class="s1">size_t rd_kafka_queue_length(rd_kafka_queue_t *rkqu);</span>
<span class="s1">void rd_kafka_queue_io_event_enable(rd_kafka_queue_t *rkqu, int fd, const void *payload, size_t size);</span>
<span class="s1">void rd_kafka_queue_cb_event_enable(rd_kafka_queue_t *rkqu, void (*event_cb)(rd_kafka_t *rk, void *qev_opaque), void *qev_opaque);</span>
<span class="s1">void rd_kafka_queue_yield(rd_kafka_queue_t *rkqu);</span>
<span class="s1">int rd_kafka_consume_start(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);</span>
<span class="s1">int rd_kafka_consume_start_queue(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, rd_kafka_queue_t *rkqu);</span>
<span class="s1">int rd_kafka_consume_stop(rd_kafka_topic_t *rkt, int32_t partition);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_seek(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, int timeout_ms);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_seek_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consume(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms);</span>
<span class="s1">ssize_t rd_kafka_consume_batch(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);</span>
<span class="s1">int rd_kafka_consume_callback(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consume_queue(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">ssize_t rd_kafka_consume_batch_queue(rd_kafka_queue_t *rkqu, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);</span>
<span class="s1">int rd_kafka_consume_callback_queue(rd_kafka_queue_t *rkqu, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offset_store(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offsets_store(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_offset_store_message(rd_kafka_message_t *rkmessage);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_subscribe(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *topics);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_unsubscribe(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_subscription(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **topics);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consumer_poll(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_consumer_close(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_consumer_close_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu);</span>
<span class="s1">int rd_kafka_consumer_closed(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_incremental_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_incremental_unassign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">const char *rd_kafka_rebalance_protocol(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_assignment(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **partitions);</span>
<span class="s1">int rd_kafka_assignment_lost(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, int async);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit_message(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, int async);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit_queue(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_queue_t *rkqu, void (*cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *commit_opaque), void *commit_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_committed(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_position(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata_new(const char *group_id);</span>
<span class="s1">rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata_new_with_genid(const char *group_id, int32_t generation_id, const char *member_id, const char *group_instance_id);</span>
<span class="s1">const char *rd_kafka_consumer_group_metadata_member_id(const rd_kafka_consumer_group_metadata_t *group_metadata);</span>
<span class="s1">void rd_kafka_consumer_group_metadata_destroy(rd_kafka_consumer_group_metadata_t *);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_consumer_group_metadata_write(const rd_kafka_consumer_group_metadata_t *cgmd, void **bufferp, size_t *sizep);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_consumer_group_metadata_read(rd_kafka_consumer_group_metadata_t **cgmdp, const void *buffer, size_t size);</span>
<span class="s1">int rd_kafka_produce(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, void *payload, size_t len, const void *key, size_t keylen, void *msg_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_producev(rd_kafka_t *rk, ...);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_produceva(rd_kafka_t *rk, const rd_kafka_vu_t *vus, size_t cnt);</span>
<span class="s1">int rd_kafka_produce_batch(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, rd_kafka_message_t *rkmessages, int message_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_flush(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_purge(rd_kafka_t *rk, int purge_flags);</span>
<span class="s1">typedef struct rd_kafka_metadata_broker {</span>
<span class="s1">  int32_t id;</span>
<span class="s1">  char *host;</span>
<span class="s1">  int port;</span>
<span class="s1">} rd_kafka_metadata_broker_t;</span>
<span class="s1">typedef struct rd_kafka_metadata_partition {</span>
<span class="s1">  int32_t id;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  int32_t leader;</span>
<span class="s1">  int replica_cnt;</span>
<span class="s1">  int32_t *replicas;</span>
<span class="s1">  int isr_cnt;</span>
<span class="s1">  int32_t *isrs;</span>
<span class="s1">} rd_kafka_metadata_partition_t;</span>
<span class="s1">typedef struct rd_kafka_metadata_topic {</span>
<span class="s1">  char *topic;</span>
<span class="s1">  int partition_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_partition *partitions;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">} rd_kafka_metadata_topic_t;</span>
<span class="s1">typedef struct rd_kafka_metadata {</span>
<span class="s1">  int broker_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_broker *brokers;</span>
<span class="s1">  int topic_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_topic *topics;</span>
<span class="s1">  int32_t orig_broker_id;</span>
<span class="s1">  char *orig_broker_name;</span>
<span class="s1">} rd_kafka_metadata_t;</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_metadata(rd_kafka_t *rk, int all_topics, rd_kafka_topic_t *only_rkt, const struct rd_kafka_metadata **metadatap, int timeout_ms);</span>
<span class="s1">void rd_kafka_metadata_destroy(const struct rd_kafka_metadata *metadata);</span>
<span class="s1">typedef struct rd_kafka_Node_s rd_kafka_Node_t;</span>
<span class="s1">int rd_kafka_Node_id(const rd_kafka_Node_t *node);</span>
<span class="s1">const char *rd_kafka_Node_host(const rd_kafka_Node_t *node);</span>
<span class="s1">uint16_t rd_kafka_Node_port(const rd_kafka_Node_t *node);</span>
<span class="s1">const char *rd_kafka_Node_rack(const rd_kafka_Node_t *node);</span>
<span class="s1">struct rd_kafka_group_member_info {</span>
<span class="s1">  char *member_id;</span>
<span class="s1">  char *client_id;</span>
<span class="s1">  char *client_host;</span>
<span class="s1">  void *member_metadata;</span>
<span class="s1">  int member_metadata_size;</span>
<span class="s1">  void *member_assignment;</span>
<span class="s1">  int member_assignment_size;</span>
<span class="s1">};</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_CONSUMER_GROUP_STATE_UNKNOWN = 0,</span>
<span class="s1">  RD_KAFKA_CONSUMER_GROUP_STATE_PREPARING_REBALANCE = 1,</span>
<span class="s1">  RD_KAFKA_CONSUMER_GROUP_STATE_COMPLETING_REBALANCE = 2,</span>
<span class="s1">  RD_KAFKA_CONSUMER_GROUP_STATE_STABLE = 3,</span>
<span class="s1">  RD_KAFKA_CONSUMER_GROUP_STATE_DEAD = 4,</span>
<span class="s1">  RD_KAFKA_CONSUMER_GROUP_STATE_EMPTY = 5,</span>
<span class="s1">  RD_KAFKA_CONSUMER_GROUP_STATE__CNT,</span>
<span class="s1">} rd_kafka_consumer_group_state_t;</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_CONSUMER_GROUP_TYPE_UNKNOWN = 0,</span>
<span class="s1">  RD_KAFKA_CONSUMER_GROUP_TYPE_CONSUMER = 1,</span>
<span class="s1">  RD_KAFKA_CONSUMER_GROUP_TYPE_CLASSIC = 2,</span>
<span class="s1">  RD_KAFKA_CONSUMER_GROUP_TYPE__CNT,</span>
<span class="s1">} rd_kafka_consumer_group_type_t;</span>
<span class="s1">struct rd_kafka_group_info {</span>
<span class="s1">  struct rd_kafka_metadata_broker broker;</span>
<span class="s1">  char *group;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  char *state;</span>
<span class="s1">  char *protocol_type;</span>
<span class="s1">  char *protocol;</span>
<span class="s1">  struct rd_kafka_group_member_info *members;</span>
<span class="s1">  int member_cnt;</span>
<span class="s1">};</span>
<span class="s1">struct rd_kafka_group_list {</span>
<span class="s1">  struct rd_kafka_group_info *groups;</span>
<span class="s1">  int group_cnt;</span>
<span class="s1">};</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_list_groups(rd_kafka_t *rk, const char *group, const struct rd_kafka_group_list **grplistp, int timeout_ms);</span>
<span class="s1">const char *rd_kafka_consumer_group_state_name(rd_kafka_consumer_group_state_t state);</span>
<span class="s1">rd_kafka_consumer_group_state_t rd_kafka_consumer_group_state_code(const char *name);</span>
<span class="s1">const char *rd_kafka_consumer_group_type_name(rd_kafka_consumer_group_type_t type);</span>
<span class="s1">rd_kafka_consumer_group_type_t rd_kafka_consumer_group_type_code(const char *name);</span>
<span class="s1">void rd_kafka_group_list_destroy(const struct rd_kafka_group_list *grplist);</span>
<span class="s1">int rd_kafka_brokers_add(rd_kafka_t *rk, const char *brokerlist);</span>
<span class="s1">void rd_kafka_set_logger(rd_kafka_t *rk, void (*func)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));</span>
<span class="s1">void rd_kafka_set_log_level(rd_kafka_t *rk, int level);</span>
<span class="s1">void rd_kafka_log_print(const rd_kafka_t *rk, int level, const char *fac, const char *buf);</span>
<span class="s1">void rd_kafka_log_syslog(const rd_kafka_t *rk, int level, const char *fac, const char *buf);</span>
<span class="s1">int rd_kafka_outq_len(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_dump(FILE *fp, rd_kafka_t *rk);</span>
<span class="s1">int rd_kafka_thread_cnt(void);</span>
<span class="s1">typedef enum rd_kafka_thread_type_t {</span>
<span class="s1">  RD_KAFKA_THREAD_MAIN,</span>
<span class="s1">  RD_KAFKA_THREAD_BACKGROUND,</span>
<span class="s1">  RD_KAFKA_THREAD_BROKER,</span>
<span class="s1">} rd_kafka_thread_type_t;</span>
<span class="s1">int rd_kafka_wait_destroyed(int timeout_ms);</span>
<span class="s1">int rd_kafka_unittest(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_poll_set_consumer(rd_kafka_t *rk);</span>
<span class="s1">typedef int rd_kafka_event_type_t;</span>
<span class="s1">rd_kafka_event_type_t rd_kafka_event_type(const rd_kafka_event_t *rkev);</span>
<span class="s1">const char *rd_kafka_event_name(const rd_kafka_event_t *rkev);</span>
<span class="s1">void rd_kafka_event_destroy(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_message_t *rd_kafka_event_message_next(rd_kafka_event_t *rkev);</span>
<span class="s1">size_t rd_kafka_event_message_array(rd_kafka_event_t *rkev, const rd_kafka_message_t **rkmessages, size_t size);</span>
<span class="s1">size_t rd_kafka_event_message_count(rd_kafka_event_t *rkev);</span>
<span class="s1">const char *rd_kafka_event_config_string(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_event_error(rd_kafka_event_t *rkev);</span>
<span class="s1">const char *rd_kafka_event_error_string(rd_kafka_event_t *rkev);</span>
<span class="s1">int rd_kafka_event_error_is_fatal(rd_kafka_event_t *rkev);</span>
<span class="s1">void *rd_kafka_event_opaque(rd_kafka_event_t *rkev);</span>
<span class="s1">int rd_kafka_event_log(rd_kafka_event_t *rkev, const char **fac, const char **str, int *level);</span>
<span class="s1">int rd_kafka_event_debug_contexts(rd_kafka_event_t *rkev, char *dst, size_t dstsize);</span>
<span class="s1">const char *rd_kafka_event_stats(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_event_topic_partition_list(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_event_topic_partition(rd_kafka_event_t *rkev);</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_CreateTopics_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DeleteTopics_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_CreateAcls_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DescribeAcls_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DeleteAcls_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_CreatePartitions_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_AlterConfigs_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_IncrementalAlterConfigs_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DescribeConfigs_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DeleteRecords_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_ListConsumerGroups_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DescribeConsumerGroups_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DeleteGroups_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DeleteConsumerGroupOffsets_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_AlterConsumerGroupOffsets_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_ListConsumerGroupOffsets_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DescribeTopics_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DescribeCluster_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DescribeUserScramCredentials_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_AlterUserScramCredentials_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_ListOffsets_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_ElectLeaders_result_t;</span>
<span class="s1">const rd_kafka_CreateTopics_result_t *rd_kafka_event_CreateTopics_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DeleteTopics_result_t *rd_kafka_event_DeleteTopics_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_CreatePartitions_result_t *rd_kafka_event_CreatePartitions_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_AlterConfigs_result_t *rd_kafka_event_AlterConfigs_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_IncrementalAlterConfigs_result_t *rd_kafka_event_IncrementalAlterConfigs_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DescribeConfigs_result_t *rd_kafka_event_DescribeConfigs_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DeleteRecords_result_t *rd_kafka_event_DeleteRecords_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_ListConsumerGroups_result_t *rd_kafka_event_ListConsumerGroups_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DescribeConsumerGroups_result_t *rd_kafka_event_DescribeConsumerGroups_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DescribeTopics_result_t *rd_kafka_event_DescribeTopics_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DescribeCluster_result_t *rd_kafka_event_DescribeCluster_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DeleteGroups_result_t *rd_kafka_event_DeleteGroups_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DeleteConsumerGroupOffsets_result_t *rd_kafka_event_DeleteConsumerGroupOffsets_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_CreateAcls_result_t *rd_kafka_event_CreateAcls_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DescribeAcls_result_t *rd_kafka_event_DescribeAcls_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DeleteAcls_result_t *rd_kafka_event_DeleteAcls_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_ListConsumerGroupOffsets_result_t *rd_kafka_event_ListConsumerGroupOffsets_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_AlterConsumerGroupOffsets_result_t *rd_kafka_event_AlterConsumerGroupOffsets_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_ListOffsets_result_t *rd_kafka_event_ListOffsets_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DescribeUserScramCredentials_result_t *rd_kafka_event_DescribeUserScramCredentials_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_AlterUserScramCredentials_result_t *rd_kafka_event_AlterUserScramCredentials_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_ElectLeaders_result_t *rd_kafka_event_ElectLeaders_result(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_event_t *rd_kafka_queue_poll(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">int rd_kafka_queue_poll_callback(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_plugin_f_conf_init_t)(rd_kafka_conf_t *conf, void **plug_opaquep, char *errstr, size_t errstr_size);</span>
<span class="s1">typedef rd_kafka_conf_res_t (rd_kafka_interceptor_f_on_conf_set_t)(rd_kafka_conf_t *conf, const char *name, const char *val, char *errstr, size_t errstr_size, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_dup_t)(rd_kafka_conf_t *new_conf, const rd_kafka_conf_t *old_conf, size_t filter_cnt, const char **filter, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_destroy_t)(void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_new_t)(rd_kafka_t *rk, const rd_kafka_conf_t *conf, void *ic_opaque, char *errstr, size_t errstr_size);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_destroy_t)(rd_kafka_t *rk, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_send_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_acknowledgement_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_consume_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_commit_t)(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_resp_err_t err, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_request_sent_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_response_received_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, int64_t rtt, rd_kafka_resp_err_t err, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_start_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_exit_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_broker_state_change_t)(rd_kafka_t *rk, int32_t broker_id, const char *secproto, const char *name, int port, const char *state, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_set(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_set_t *on_conf_set, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_dup(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_dup_t *on_conf_dup, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_destroy(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_destroy_t *on_conf_destroy, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_new(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_new_t *on_new, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_destroy(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_destroy_t *on_destroy, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_send(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_send_t *on_send, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_acknowledgement(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_acknowledgement_t *on_acknowledgement, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_consume(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_consume_t *on_consume, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_commit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_commit_t *on_commit, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_request_sent(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_request_sent_t *on_request_sent, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_response_received(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_response_received_t *on_response_received, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_start(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_start_t *on_thread_start, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_exit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_exit_t *on_thread_exit, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_broker_state_change(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_broker_state_change_t *on_broker_state_change, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_topic_result_error(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">const char *rd_kafka_topic_result_error_string(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">const char *rd_kafka_topic_result_name(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">const rd_kafka_error_t *rd_kafka_group_result_error(const rd_kafka_group_result_t *groupres);</span>
<span class="s1">const char *rd_kafka_group_result_name(const rd_kafka_group_result_t *groupres);</span>
<span class="s1">const rd_kafka_topic_partition_list_t *rd_kafka_group_result_partitions(const rd_kafka_group_result_t *groupres);</span>
<span class="s1">const rd_kafka_topic_partition_t *rd_kafka_topic_partition_result_partition(const rd_kafka_topic_partition_result_t *partition_result);</span>
<span class="s1">const rd_kafka_error_t *rd_kafka_topic_partition_result_error(const rd_kafka_topic_partition_result_t *partition_result);</span>
<span class="s1">typedef enum rd_kafka_admin_op_t {</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_ANY = 0,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_CREATETOPICS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DELETETOPICS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_CREATEPARTITIONS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_ALTERCONFIGS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DESCRIBECONFIGS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DELETERECORDS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DELETEGROUPS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DELETECONSUMERGROUPOFFSETS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_CREATEACLS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DESCRIBEACLS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DELETEACLS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_LISTCONSUMERGROUPS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DESCRIBECONSUMERGROUPS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_LISTCONSUMERGROUPOFFSETS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_ALTERCONSUMERGROUPOFFSETS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_INCREMENTALALTERCONFIGS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DESCRIBEUSERSCRAMCREDENTIALS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_ALTERUSERSCRAMCREDENTIALS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DESCRIBETOPICS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DESCRIBECLUSTER,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_LISTOFFSETS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_ELECTLEADERS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP__CNT,</span>
<span class="s1">} rd_kafka_admin_op_t;</span>
<span class="s1">typedef struct rd_kafka_AdminOptions_s rd_kafka_AdminOptions_t;</span>
<span class="s1">typedef enum rd_kafka_IsolationLevel_t {</span>
<span class="s1">  RD_KAFKA_ISOLATION_LEVEL_READ_UNCOMMITTED = 0,</span>
<span class="s1">  RD_KAFKA_ISOLATION_LEVEL_READ_COMMITTED = 1,</span>
<span class="s1">} rd_kafka_IsolationLevel_t;</span>
<span class="s1">rd_kafka_AdminOptions_t *rd_kafka_AdminOptions_new(rd_kafka_t *rk, rd_kafka_admin_op_t for_api);</span>
<span class="s1">void rd_kafka_AdminOptions_destroy(rd_kafka_AdminOptions_t *options);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_request_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_operation_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_validate_only(rd_kafka_AdminOptions_t *options, int true_or_false, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_broker(rd_kafka_AdminOptions_t *options, int32_t broker_id, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_AdminOptions_set_require_stable_offsets(rd_kafka_AdminOptions_t *options, int true_or_false);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_AdminOptions_set_include_authorized_operations(rd_kafka_AdminOptions_t *options, int true_or_false);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_AdminOptions_set_match_consumer_group_states(rd_kafka_AdminOptions_t *options, const rd_kafka_consumer_group_state_t *consumer_group_states, size_t consumer_group_states_cnt);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_AdminOptions_set_match_consumer_group_types(rd_kafka_AdminOptions_t *options, const rd_kafka_consumer_group_type_t *consumer_group_types, size_t consumer_group_types_cnt);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_AdminOptions_set_isolation_level(rd_kafka_AdminOptions_t *options, rd_kafka_IsolationLevel_t value);</span>
<span class="s1">void rd_kafka_AdminOptions_set_opaque(rd_kafka_AdminOptions_t *options, void *ev_opaque);</span>
<span class="s1">typedef enum rd_kafka_AclOperation_t {</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_UNKNOWN = 0,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_ANY = 1,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_ALL = 2,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_READ = 3,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_WRITE = 4,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_CREATE = 5,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_DELETE = 6,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_ALTER = 7,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_DESCRIBE = 8,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_CLUSTER_ACTION = 9,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_DESCRIBE_CONFIGS = 10,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_ALTER_CONFIGS = 11,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_IDEMPOTENT_WRITE = 12,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION__CNT,</span>
<span class="s1">} rd_kafka_AclOperation_t;</span>
<span class="s1">typedef struct rd_kafka_NewTopic_s rd_kafka_NewTopic_t;</span>
<span class="s1">rd_kafka_NewTopic_t *rd_kafka_NewTopic_new(const char *topic, int num_partitions, int replication_factor, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_NewTopic_destroy(rd_kafka_NewTopic_t *new_topic);</span>
<span class="s1">void rd_kafka_NewTopic_destroy_array(rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewTopic_set_replica_assignment(rd_kafka_NewTopic_t *new_topic, int32_t partition, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewTopic_set_config(rd_kafka_NewTopic_t *new_topic, const char *name, const char *value);</span>
<span class="s1">void rd_kafka_CreateTopics(rd_kafka_t *rk, rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_CreateTopics_result_topics(const rd_kafka_CreateTopics_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_DeleteTopic_s rd_kafka_DeleteTopic_t;</span>
<span class="s1">rd_kafka_DeleteTopic_t *rd_kafka_DeleteTopic_new(const char *topic);</span>
<span class="s1">void rd_kafka_DeleteTopic_destroy(rd_kafka_DeleteTopic_t *del_topic);</span>
<span class="s1">void rd_kafka_DeleteTopic_destroy_array(rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt);</span>
<span class="s1">void rd_kafka_DeleteTopics(rd_kafka_t *rk, rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_DeleteTopics_result_topics(const rd_kafka_DeleteTopics_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_NewPartitions_s rd_kafka_NewPartitions_t;</span>
<span class="s1">rd_kafka_NewPartitions_t *rd_kafka_NewPartitions_new(const char *topic, size_t new_total_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_NewPartitions_destroy(rd_kafka_NewPartitions_t *new_parts);</span>
<span class="s1">void rd_kafka_NewPartitions_destroy_array(rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewPartitions_set_replica_assignment(rd_kafka_NewPartitions_t *new_parts, int32_t new_partition_idx, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_CreatePartitions(rd_kafka_t *rk, rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_CreatePartitions_result_topics(const rd_kafka_CreatePartitions_result_t *result, size_t *cntp);</span>
<span class="s1">typedef enum rd_kafka_ConfigSource_t {</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_UNKNOWN_CONFIG = 0,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_TOPIC_CONFIG = 1,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_BROKER_CONFIG = 2,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_DEFAULT_BROKER_CONFIG = 3,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_STATIC_BROKER_CONFIG = 4,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DEFAULT_CONFIG = 5,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE__CNT,</span>
<span class="s1">} rd_kafka_ConfigSource_t;</span>
<span class="s1">const char *rd_kafka_ConfigSource_name(rd_kafka_ConfigSource_t confsource);</span>
<span class="s1">typedef struct rd_kafka_ConfigEntry_s rd_kafka_ConfigEntry_t;</span>
<span class="s1">const char *rd_kafka_ConfigEntry_name(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">const char *rd_kafka_ConfigEntry_value(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">rd_kafka_ConfigSource_t rd_kafka_ConfigEntry_source(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_read_only(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_default(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_sensitive(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_synonym(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">const rd_kafka_ConfigEntry_t **rd_kafka_ConfigEntry_synonyms(const rd_kafka_ConfigEntry_t *entry, size_t *cntp);</span>
<span class="s1">typedef enum rd_kafka_ResourceType_t {</span>
<span class="s1">  RD_KAFKA_RESOURCE_UNKNOWN = 0,</span>
<span class="s1">  RD_KAFKA_RESOURCE_ANY = 1,</span>
<span class="s1">  RD_KAFKA_RESOURCE_TOPIC = 2,</span>
<span class="s1">  RD_KAFKA_RESOURCE_GROUP = 3,</span>
<span class="s1">  RD_KAFKA_RESOURCE_BROKER = 4,</span>
<span class="s1">  RD_KAFKA_RESOURCE_TRANSACTIONAL_ID = 5,</span>
<span class="s1">  RD_KAFKA_RESOURCE__CNT,</span>
<span class="s1">} rd_kafka_ResourceType_t;</span>
<span class="s1">typedef enum rd_kafka_ResourcePatternType_t {</span>
<span class="s1">  RD_KAFKA_RESOURCE_PATTERN_UNKNOWN = 0,</span>
<span class="s1">  RD_KAFKA_RESOURCE_PATTERN_ANY = 1,</span>
<span class="s1">  RD_KAFKA_RESOURCE_PATTERN_MATCH = 2,</span>
<span class="s1">  RD_KAFKA_RESOURCE_PATTERN_LITERAL = 3,</span>
<span class="s1">  RD_KAFKA_RESOURCE_PATTERN_PREFIXED = 4,</span>
<span class="s1">  RD_KAFKA_RESOURCE_PATTERN_TYPE__CNT,</span>
<span class="s1">} rd_kafka_ResourcePatternType_t;</span>
<span class="s1">typedef enum rd_kafka_AlterConfigOpType_t {</span>
<span class="s1">  RD_KAFKA_ALTER_CONFIG_OP_TYPE_SET = 0,</span>
<span class="s1">  RD_KAFKA_ALTER_CONFIG_OP_TYPE_DELETE = 1,</span>
<span class="s1">  RD_KAFKA_ALTER_CONFIG_OP_TYPE_APPEND = 2,</span>
<span class="s1">  RD_KAFKA_ALTER_CONFIG_OP_TYPE_SUBTRACT = 3,</span>
<span class="s1">  RD_KAFKA_ALTER_CONFIG_OP_TYPE__CNT,</span>
<span class="s1">} rd_kafka_AlterConfigOpType_t;</span>
<span class="s1">const char *rd_kafka_ResourcePatternType_name(rd_kafka_ResourcePatternType_t resource_pattern_type);</span>
<span class="s1">const char *rd_kafka_ResourceType_name(rd_kafka_ResourceType_t restype);</span>
<span class="s1">typedef struct rd_kafka_ConfigResource_s rd_kafka_ConfigResource_t;</span>
<span class="s1">rd_kafka_ConfigResource_t *rd_kafka_ConfigResource_new(rd_kafka_ResourceType_t restype, const char *resname);</span>
<span class="s1">void rd_kafka_ConfigResource_destroy(rd_kafka_ConfigResource_t *config);</span>
<span class="s1">void rd_kafka_ConfigResource_destroy_array(rd_kafka_ConfigResource_t **config, size_t config_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_ConfigResource_set_config(rd_kafka_ConfigResource_t *config, const char *name, const char *value);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_ConfigResource_add_incremental_config(rd_kafka_ConfigResource_t *config, const char *name, rd_kafka_AlterConfigOpType_t op_type, const char *value);</span>
<span class="s1">const rd_kafka_ConfigEntry_t **rd_kafka_ConfigResource_configs(const rd_kafka_ConfigResource_t *config, size_t *cntp);</span>
<span class="s1">rd_kafka_ResourceType_t rd_kafka_ConfigResource_type(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">const char *rd_kafka_ConfigResource_name(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_ConfigResource_error(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">const char *rd_kafka_ConfigResource_error_string(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">void rd_kafka_AlterConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_ConfigResource_t **rd_kafka_AlterConfigs_result_resources(const rd_kafka_AlterConfigs_result_t *result, size_t *cntp);</span>
<span class="s1">void rd_kafka_IncrementalAlterConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_ConfigResource_t **rd_kafka_IncrementalAlterConfigs_result_resources(const rd_kafka_IncrementalAlterConfigs_result_t *result, size_t *cntp);</span>
<span class="s1">void rd_kafka_DescribeConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_ConfigResource_t **rd_kafka_DescribeConfigs_result_resources(const rd_kafka_DescribeConfigs_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_DeleteRecords_s rd_kafka_DeleteRecords_t;</span>
<span class="s1">rd_kafka_DeleteRecords_t *rd_kafka_DeleteRecords_new(const rd_kafka_topic_partition_list_t *before_offsets);</span>
<span class="s1">void rd_kafka_DeleteRecords_destroy(rd_kafka_DeleteRecords_t *del_records);</span>
<span class="s1">void rd_kafka_DeleteRecords_destroy_array(rd_kafka_DeleteRecords_t **del_records, size_t del_record_cnt);</span>
<span class="s1">void rd_kafka_DeleteRecords(rd_kafka_t *rk, rd_kafka_DeleteRecords_t **del_records, size_t del_record_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_partition_list_t *rd_kafka_DeleteRecords_result_offsets(const rd_kafka_DeleteRecords_result_t *result);</span>
<span class="s1">typedef struct rd_kafka_TopicCollection_s rd_kafka_TopicCollection_t;</span>
<span class="s1">typedef struct rd_kafka_TopicPartitionInfo_s rd_kafka_TopicPartitionInfo_t;</span>
<span class="s1">typedef struct rd_kafka_TopicDescription_s rd_kafka_TopicDescription_t;</span>
<span class="s1">rd_kafka_TopicCollection_t *rd_kafka_TopicCollection_of_topic_names(const char **topics, size_t topics_cnt);</span>
<span class="s1">void rd_kafka_TopicCollection_destroy(rd_kafka_TopicCollection_t *topics);</span>
<span class="s1">void rd_kafka_DescribeTopics(rd_kafka_t *rk, const rd_kafka_TopicCollection_t *topics, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_TopicDescription_t **rd_kafka_DescribeTopics_result_topics(const rd_kafka_DescribeTopics_result_t *result, size_t *cntp);</span>
<span class="s1">const rd_kafka_TopicPartitionInfo_t **rd_kafka_TopicDescription_partitions(const rd_kafka_TopicDescription_t *topicdesc, size_t *cntp);</span>
<span class="s1">const int rd_kafka_TopicPartitionInfo_partition(const rd_kafka_TopicPartitionInfo_t *partition);</span>
<span class="s1">const rd_kafka_Node_t *rd_kafka_TopicPartitionInfo_leader(const rd_kafka_TopicPartitionInfo_t *partition);</span>
<span class="s1">const rd_kafka_Node_t **rd_kafka_TopicPartitionInfo_isr(const rd_kafka_TopicPartitionInfo_t *partition, size_t *cntp);</span>
<span class="s1">const rd_kafka_Node_t **rd_kafka_TopicPartitionInfo_replicas(const rd_kafka_TopicPartitionInfo_t *partition, size_t *cntp);</span>
<span class="s1">const rd_kafka_AclOperation_t *rd_kafka_TopicDescription_authorized_operations(const rd_kafka_TopicDescription_t *topicdesc, size_t *cntp);</span>
<span class="s1">const char *rd_kafka_TopicDescription_name(const rd_kafka_TopicDescription_t *topicdesc);</span>
<span class="s1">const rd_kafka_Uuid_t *rd_kafka_TopicDescription_topic_id(const rd_kafka_TopicDescription_t *topicdesc);</span>
<span class="s1">int rd_kafka_TopicDescription_is_internal(const rd_kafka_TopicDescription_t *topicdesc);</span>
<span class="s1">const rd_kafka_error_t *rd_kafka_TopicDescription_error(const rd_kafka_TopicDescription_t *topicdesc);</span>
<span class="s1">void rd_kafka_DescribeCluster(rd_kafka_t *rk, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_Node_t **rd_kafka_DescribeCluster_result_nodes(const rd_kafka_DescribeCluster_result_t *result, size_t *cntp);</span>
<span class="s1">const rd_kafka_AclOperation_t *rd_kafka_DescribeCluster_result_authorized_operations(const rd_kafka_DescribeCluster_result_t *result, size_t *cntp);</span>
<span class="s1">const rd_kafka_Node_t *rd_kafka_DescribeCluster_result_controller(const rd_kafka_DescribeCluster_result_t *result);</span>
<span class="s1">const char *rd_kafka_DescribeCluster_result_cluster_id(const rd_kafka_DescribeCluster_result_t *result);</span>
<span class="s1">typedef struct rd_kafka_ConsumerGroupListing_s rd_kafka_ConsumerGroupListing_t;</span>
<span class="s1">typedef struct rd_kafka_ListConsumerGroupsResult_s rd_kafka_ListConsumerGroupsResult_t;</span>
<span class="s1">void rd_kafka_ListConsumerGroups(rd_kafka_t *rk, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const char *rd_kafka_ConsumerGroupListing_group_id(const rd_kafka_ConsumerGroupListing_t *grplist);</span>
<span class="s1">int rd_kafka_ConsumerGroupListing_is_simple_consumer_group(const rd_kafka_ConsumerGroupListing_t *grplist);</span>
<span class="s1">rd_kafka_consumer_group_state_t rd_kafka_ConsumerGroupListing_state(const rd_kafka_ConsumerGroupListing_t *grplist);</span>
<span class="s1">rd_kafka_consumer_group_type_t rd_kafka_ConsumerGroupListing_type(const rd_kafka_ConsumerGroupListing_t *grplist);</span>
<span class="s1">const rd_kafka_ConsumerGroupListing_t **rd_kafka_ListConsumerGroups_result_valid(const rd_kafka_ListConsumerGroups_result_t *result, size_t *cntp);</span>
<span class="s1">const rd_kafka_error_t **rd_kafka_ListConsumerGroups_result_errors(const rd_kafka_ListConsumerGroups_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_ConsumerGroupDescription_s rd_kafka_ConsumerGroupDescription_t;</span>
<span class="s1">typedef struct rd_kafka_MemberDescription_s rd_kafka_MemberDescription_t;</span>
<span class="s1">typedef struct rd_kafka_MemberAssignment_s rd_kafka_MemberAssignment_t;</span>
<span class="s1">void rd_kafka_DescribeConsumerGroups(rd_kafka_t *rk, const char **groups, size_t groups_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_ConsumerGroupDescription_t **rd_kafka_DescribeConsumerGroups_result_groups(const rd_kafka_DescribeConsumerGroups_result_t *result, size_t *cntp);</span>
<span class="s1">const char *rd_kafka_ConsumerGroupDescription_group_id(const rd_kafka_ConsumerGroupDescription_t *grpdesc);</span>
<span class="s1">const rd_kafka_error_t *rd_kafka_ConsumerGroupDescription_error(const rd_kafka_ConsumerGroupDescription_t *grpdesc);</span>
<span class="s1">int rd_kafka_ConsumerGroupDescription_is_simple_consumer_group(const rd_kafka_ConsumerGroupDescription_t *grpdesc);</span>
<span class="s1">const char *rd_kafka_ConsumerGroupDescription_partition_assignor(const rd_kafka_ConsumerGroupDescription_t *grpdesc);</span>
<span class="s1">const rd_kafka_AclOperation_t *rd_kafka_ConsumerGroupDescription_authorized_operations(const rd_kafka_ConsumerGroupDescription_t *grpdesc, size_t *cntp);</span>
<span class="s1">rd_kafka_consumer_group_state_t rd_kafka_ConsumerGroupDescription_state(const rd_kafka_ConsumerGroupDescription_t *grpdesc);</span>
<span class="s1">const rd_kafka_Node_t *rd_kafka_ConsumerGroupDescription_coordinator(const rd_kafka_ConsumerGroupDescription_t *grpdesc);</span>
<span class="s1">size_t rd_kafka_ConsumerGroupDescription_member_count(const rd_kafka_ConsumerGroupDescription_t *grpdesc);</span>
<span class="s1">const rd_kafka_MemberDescription_t *rd_kafka_ConsumerGroupDescription_member(const rd_kafka_ConsumerGroupDescription_t *grpdesc, size_t idx);</span>
<span class="s1">const char *rd_kafka_MemberDescription_client_id(const rd_kafka_MemberDescription_t *member);</span>
<span class="s1">const char *rd_kafka_MemberDescription_group_instance_id(const rd_kafka_MemberDescription_t *member);</span>
<span class="s1">const char *rd_kafka_MemberDescription_consumer_id(const rd_kafka_MemberDescription_t *member);</span>
<span class="s1">const char *rd_kafka_MemberDescription_host(const rd_kafka_MemberDescription_t *member);</span>
<span class="s1">const rd_kafka_MemberAssignment_t *rd_kafka_MemberDescription_assignment(const rd_kafka_MemberDescription_t *member);</span>
<span class="s1">const rd_kafka_topic_partition_list_t *rd_kafka_MemberAssignment_partitions(const rd_kafka_MemberAssignment_t *assignment);</span>
<span class="s1">typedef struct rd_kafka_DeleteGroup_s rd_kafka_DeleteGroup_t;</span>
<span class="s1">rd_kafka_DeleteGroup_t *rd_kafka_DeleteGroup_new(const char *group);</span>
<span class="s1">void rd_kafka_DeleteGroup_destroy(rd_kafka_DeleteGroup_t *del_group);</span>
<span class="s1">void rd_kafka_DeleteGroup_destroy_array(rd_kafka_DeleteGroup_t **del_groups, size_t del_group_cnt);</span>
<span class="s1">void rd_kafka_DeleteGroups(rd_kafka_t *rk, rd_kafka_DeleteGroup_t **del_groups, size_t del_group_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_group_result_t **rd_kafka_DeleteGroups_result_groups(const rd_kafka_DeleteGroups_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_ListConsumerGroupOffsets_s rd_kafka_ListConsumerGroupOffsets_t;</span>
<span class="s1">rd_kafka_ListConsumerGroupOffsets_t *rd_kafka_ListConsumerGroupOffsets_new(const char *group_id, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">void rd_kafka_ListConsumerGroupOffsets_destroy(rd_kafka_ListConsumerGroupOffsets_t *list_grpoffsets);</span>
<span class="s1">void rd_kafka_ListConsumerGroupOffsets_destroy_array(rd_kafka_ListConsumerGroupOffsets_t **list_grpoffsets, size_t list_grpoffset_cnt);</span>
<span class="s1">void rd_kafka_ListConsumerGroupOffsets(rd_kafka_t *rk, rd_kafka_ListConsumerGroupOffsets_t **list_grpoffsets, size_t list_grpoffsets_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_group_result_t **rd_kafka_ListConsumerGroupOffsets_result_groups(const rd_kafka_ListConsumerGroupOffsets_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_AlterConsumerGroupOffsets_s rd_kafka_AlterConsumerGroupOffsets_t;</span>
<span class="s1">rd_kafka_AlterConsumerGroupOffsets_t *rd_kafka_AlterConsumerGroupOffsets_new(const char *group_id, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">void rd_kafka_AlterConsumerGroupOffsets_destroy(rd_kafka_AlterConsumerGroupOffsets_t *alter_grpoffsets);</span>
<span class="s1">void rd_kafka_AlterConsumerGroupOffsets_destroy_array(rd_kafka_AlterConsumerGroupOffsets_t **alter_grpoffsets, size_t alter_grpoffset_cnt);</span>
<span class="s1">void rd_kafka_AlterConsumerGroupOffsets(rd_kafka_t *rk, rd_kafka_AlterConsumerGroupOffsets_t **alter_grpoffsets, size_t alter_grpoffsets_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_group_result_t **rd_kafka_AlterConsumerGroupOffsets_result_groups(const rd_kafka_AlterConsumerGroupOffsets_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_DeleteConsumerGroupOffsets_s rd_kafka_DeleteConsumerGroupOffsets_t;</span>
<span class="s1">rd_kafka_DeleteConsumerGroupOffsets_t *rd_kafka_DeleteConsumerGroupOffsets_new(const char *group, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">void rd_kafka_DeleteConsumerGroupOffsets_destroy(rd_kafka_DeleteConsumerGroupOffsets_t *del_grpoffsets);</span>
<span class="s1">void rd_kafka_DeleteConsumerGroupOffsets_destroy_array(rd_kafka_DeleteConsumerGroupOffsets_t **del_grpoffsets, size_t del_grpoffset_cnt);</span>
<span class="s1">void rd_kafka_DeleteConsumerGroupOffsets(rd_kafka_t *rk, rd_kafka_DeleteConsumerGroupOffsets_t **del_grpoffsets, size_t del_grpoffsets_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_group_result_t **rd_kafka_DeleteConsumerGroupOffsets_result_groups(const rd_kafka_DeleteConsumerGroupOffsets_result_t *result, size_t *cntp);</span>
<span class="s1">typedef enum rd_kafka_OffsetSpec_t {</span>
<span class="s1">  RD_KAFKA_OFFSET_SPEC_MAX_TIMESTAMP = (- 3),</span>
<span class="s1">  RD_KAFKA_OFFSET_SPEC_EARLIEST = (- 2),</span>
<span class="s1">  RD_KAFKA_OFFSET_SPEC_LATEST = (- 1),</span>
<span class="s1">} rd_kafka_OffsetSpec_t;</span>
<span class="s1">typedef struct rd_kafka_ListOffsetsResultInfo_s rd_kafka_ListOffsetsResultInfo_t;</span>
<span class="s1">const rd_kafka_topic_partition_t *rd_kafka_ListOffsetsResultInfo_topic_partition(const rd_kafka_ListOffsetsResultInfo_t *result_info);</span>
<span class="s1">int64_t rd_kafka_ListOffsetsResultInfo_timestamp(const rd_kafka_ListOffsetsResultInfo_t *result_info);</span>
<span class="s1">const rd_kafka_ListOffsetsResultInfo_t **rd_kafka_ListOffsets_result_infos(const rd_kafka_ListOffsets_result_t *result, size_t *cntp);</span>
<span class="s1">void rd_kafka_ListOffsets(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *topic_partitions, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">typedef enum rd_kafka_ScramMechanism_t {</span>
<span class="s1">  RD_KAFKA_SCRAM_MECHANISM_UNKNOWN = 0,</span>
<span class="s1">  RD_KAFKA_SCRAM_MECHANISM_SHA_256 = 1,</span>
<span class="s1">  RD_KAFKA_SCRAM_MECHANISM_SHA_512 = 2,</span>
<span class="s1">  RD_KAFKA_SCRAM_MECHANISM__CNT,</span>
<span class="s1">} rd_kafka_ScramMechanism_t;</span>
<span class="s1">typedef struct rd_kafka_ScramCredentialInfo_s rd_kafka_ScramCredentialInfo_t;</span>
<span class="s1">rd_kafka_ScramMechanism_t rd_kafka_ScramCredentialInfo_mechanism(const rd_kafka_ScramCredentialInfo_t *scram_credential_info);</span>
<span class="s1">int32_t rd_kafka_ScramCredentialInfo_iterations(const rd_kafka_ScramCredentialInfo_t *scram_credential_info);</span>
<span class="s1">typedef struct rd_kafka_UserScramCredentialsDescription_s rd_kafka_UserScramCredentialsDescription_t;</span>
<span class="s1">const char *rd_kafka_UserScramCredentialsDescription_user(const rd_kafka_UserScramCredentialsDescription_t *description);</span>
<span class="s1">const rd_kafka_error_t *rd_kafka_UserScramCredentialsDescription_error(const rd_kafka_UserScramCredentialsDescription_t *description);</span>
<span class="s1">size_t rd_kafka_UserScramCredentialsDescription_scramcredentialinfo_count(const rd_kafka_UserScramCredentialsDescription_t *description);</span>
<span class="s1">const rd_kafka_ScramCredentialInfo_t *rd_kafka_UserScramCredentialsDescription_scramcredentialinfo(const rd_kafka_UserScramCredentialsDescription_t *description, size_t idx);</span>
<span class="s1">const rd_kafka_UserScramCredentialsDescription_t **rd_kafka_DescribeUserScramCredentials_result_descriptions(const rd_kafka_DescribeUserScramCredentials_result_t *result, size_t *cntp);</span>
<span class="s1">void rd_kafka_DescribeUserScramCredentials(rd_kafka_t *rk, const char **users, size_t user_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">typedef struct rd_kafka_UserScramCredentialAlteration_s rd_kafka_UserScramCredentialAlteration_t;</span>
<span class="s1">rd_kafka_UserScramCredentialAlteration_t *rd_kafka_UserScramCredentialUpsertion_new(const char *username, rd_kafka_ScramMechanism_t mechanism, int32_t iterations, const unsigned char *password, size_t password_size, const unsigned char *salt, size_t salt_size);</span>
<span class="s1">rd_kafka_UserScramCredentialAlteration_t *rd_kafka_UserScramCredentialDeletion_new(const char *username, rd_kafka_ScramMechanism_t mechanism);</span>
<span class="s1">void rd_kafka_UserScramCredentialAlteration_destroy(rd_kafka_UserScramCredentialAlteration_t *alteration);</span>
<span class="s1">void rd_kafka_UserScramCredentialAlteration_destroy_array(rd_kafka_UserScramCredentialAlteration_t **alterations, size_t alteration_cnt);</span>
<span class="s1">typedef struct rd_kafka_AlterUserScramCredentials_result_response_s rd_kafka_AlterUserScramCredentials_result_response_t;</span>
<span class="s1">const char *rd_kafka_AlterUserScramCredentials_result_response_user(const rd_kafka_AlterUserScramCredentials_result_response_t *response);</span>
<span class="s1">const rd_kafka_error_t *rd_kafka_AlterUserScramCredentials_result_response_error(const rd_kafka_AlterUserScramCredentials_result_response_t *response);</span>
<span class="s1">const rd_kafka_AlterUserScramCredentials_result_response_t **rd_kafka_AlterUserScramCredentials_result_responses(const rd_kafka_AlterUserScramCredentials_result_t *result, size_t *cntp);</span>
<span class="s1">void rd_kafka_AlterUserScramCredentials(rd_kafka_t *rk, rd_kafka_UserScramCredentialAlteration_t **alterations, size_t alteration_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">typedef struct rd_kafka_AclBinding_s rd_kafka_AclBinding_t;</span>
<span class="s1">typedef rd_kafka_AclBinding_t rd_kafka_AclBindingFilter_t;</span>
<span class="s1">const rd_kafka_error_t *rd_kafka_acl_result_error(const rd_kafka_acl_result_t *aclres);</span>
<span class="s1">const char *rd_kafka_AclOperation_name(rd_kafka_AclOperation_t acl_operation);</span>
<span class="s1">typedef enum rd_kafka_AclPermissionType_t {</span>
<span class="s1">  RD_KAFKA_ACL_PERMISSION_TYPE_UNKNOWN = 0,</span>
<span class="s1">  RD_KAFKA_ACL_PERMISSION_TYPE_ANY = 1,</span>
<span class="s1">  RD_KAFKA_ACL_PERMISSION_TYPE_DENY = 2,</span>
<span class="s1">  RD_KAFKA_ACL_PERMISSION_TYPE_ALLOW = 3,</span>
<span class="s1">  RD_KAFKA_ACL_PERMISSION_TYPE__CNT,</span>
<span class="s1">} rd_kafka_AclPermissionType_t;</span>
<span class="s1">const char *rd_kafka_AclPermissionType_name(rd_kafka_AclPermissionType_t acl_permission_type);</span>
<span class="s1">rd_kafka_AclBinding_t *rd_kafka_AclBinding_new(rd_kafka_ResourceType_t restype, const char *name, rd_kafka_ResourcePatternType_t resource_pattern_type, const char *principal, const char *host, rd_kafka_AclOperation_t operation, rd_kafka_AclPermissionType_t permission_type, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_AclBindingFilter_t *rd_kafka_AclBindingFilter_new(rd_kafka_ResourceType_t restype, const char *name, rd_kafka_ResourcePatternType_t resource_pattern_type, const char *principal, const char *host, rd_kafka_AclOperation_t operation, rd_kafka_AclPermissionType_t permission_type, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_ResourceType_t rd_kafka_AclBinding_restype(const rd_kafka_AclBinding_t *acl);</span>
<span class="s1">const char *rd_kafka_AclBinding_name(const rd_kafka_AclBinding_t *acl);</span>
<span class="s1">const char *rd_kafka_AclBinding_principal(const rd_kafka_AclBinding_t *acl);</span>
<span class="s1">const char *rd_kafka_AclBinding_host(const rd_kafka_AclBinding_t *acl);</span>
<span class="s1">rd_kafka_AclOperation_t rd_kafka_AclBinding_operation(const rd_kafka_AclBinding_t *acl);</span>
<span class="s1">rd_kafka_AclPermissionType_t rd_kafka_AclBinding_permission_type(const rd_kafka_AclBinding_t *acl);</span>
<span class="s1">rd_kafka_ResourcePatternType_t rd_kafka_AclBinding_resource_pattern_type(const rd_kafka_AclBinding_t *acl);</span>
<span class="s1">const rd_kafka_error_t *rd_kafka_AclBinding_error(const rd_kafka_AclBinding_t *acl);</span>
<span class="s1">void rd_kafka_AclBinding_destroy(rd_kafka_AclBinding_t *acl_binding);</span>
<span class="s1">void rd_kafka_AclBinding_destroy_array(rd_kafka_AclBinding_t **acl_bindings, size_t acl_bindings_cnt);</span>
<span class="s1">const rd_kafka_acl_result_t **rd_kafka_CreateAcls_result_acls(const rd_kafka_CreateAcls_result_t *result, size_t *cntp);</span>
<span class="s1">void rd_kafka_CreateAcls(rd_kafka_t *rk, rd_kafka_AclBinding_t **new_acls, size_t new_acls_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_AclBinding_t **rd_kafka_DescribeAcls_result_acls(const rd_kafka_DescribeAcls_result_t *result, size_t *cntp);</span>
<span class="s1">void rd_kafka_DescribeAcls(rd_kafka_t *rk, rd_kafka_AclBindingFilter_t *acl_filter, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">typedef struct rd_kafka_DeleteAcls_result_response_s rd_kafka_DeleteAcls_result_response_t;</span>
<span class="s1">const rd_kafka_DeleteAcls_result_response_t **rd_kafka_DeleteAcls_result_responses(const rd_kafka_DeleteAcls_result_t *result, size_t *cntp);</span>
<span class="s1">const rd_kafka_error_t *rd_kafka_DeleteAcls_result_response_error(const rd_kafka_DeleteAcls_result_response_t *result_response);</span>
<span class="s1">const rd_kafka_AclBinding_t **rd_kafka_DeleteAcls_result_response_matching_acls(const rd_kafka_DeleteAcls_result_response_t *result_response, size_t *matching_acls_cntp);</span>
<span class="s1">void rd_kafka_DeleteAcls(rd_kafka_t *rk, rd_kafka_AclBindingFilter_t **del_acls, size_t del_acls_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">typedef struct rd_kafka_ElectLeaders_s rd_kafka_ElectLeaders_t;</span>
<span class="s1">typedef enum rd_kafka_ElectionType_t {</span>
<span class="s1">  RD_KAFKA_ELECTION_TYPE_PREFERRED = 0,</span>
<span class="s1">  RD_KAFKA_ELECTION_TYPE_UNCLEAN = 1,</span>
<span class="s1">} rd_kafka_ElectionType_t;</span>
<span class="s1">rd_kafka_ElectLeaders_t *rd_kafka_ElectLeaders_new(rd_kafka_ElectionType_t election_type, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">void rd_kafka_ElectLeaders_destroy(rd_kafka_ElectLeaders_t *elect_leaders);</span>
<span class="s1">void rd_kafka_ElectLeaders(rd_kafka_t *rk, rd_kafka_ElectLeaders_t *elect_leaders, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_partition_result_t **rd_kafka_ElectLeaders_result_partitions(const rd_kafka_ElectLeaders_result_t *result, size_t *cntp);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token(rd_kafka_t *rk, const char *token_value, int64_t md_lifetime_ms, const char *md_principal_name, const char **extensions, size_t extension_size, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token_failure(rd_kafka_t *rk, const char *errstr);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_init_transactions(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_begin_transaction(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_send_offsets_to_transaction(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, const rd_kafka_consumer_group_metadata_t *cgmetadata, int timeout_ms);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_commit_transaction(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_abort_transaction(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">typedef struct rd_kafka_mock_cluster_s rd_kafka_mock_cluster_t;</span>
<span class="s1">rd_kafka_mock_cluster_t *rd_kafka_mock_cluster_new(rd_kafka_t *rk, int broker_cnt);</span>
<span class="s1">void rd_kafka_mock_cluster_destroy(rd_kafka_mock_cluster_t *mcluster);</span>
<span class="s1">rd_kafka_t *rd_kafka_mock_cluster_handle(const rd_kafka_mock_cluster_t *mcluster);</span>
<span class="s1">rd_kafka_mock_cluster_t *rd_kafka_handle_mock_cluster(const rd_kafka_t *rk);</span>
<span class="s1">const char *rd_kafka_mock_cluster_bootstraps(const rd_kafka_mock_cluster_t *mcluster);</span>
<span class="s1">void rd_kafka_mock_clear_request_errors(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey);</span>
<span class="s1">void rd_kafka_mock_push_request_errors(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, size_t cnt, ...);</span>
<span class="s1">void rd_kafka_mock_push_request_errors_array(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, size_t cnt, const rd_kafka_resp_err_t *errors);</span>
<span class="s1">void rd_kafka_mock_group_initial_rebalance_delay_ms(rd_kafka_mock_cluster_t *mcluster, int32_t delay_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_push_request_error_rtts(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int16_t ApiKey, size_t cnt, ...);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_error_stack_cnt(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int16_t ApiKey, size_t *cntp);</span>
<span class="s1">void rd_kafka_mock_topic_set_error(rd_kafka_mock_cluster_t *mcluster, const char *topic, rd_kafka_resp_err_t err);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_topic_create(rd_kafka_mock_cluster_t *mcluster, const char *topic, int partition_cnt, int replication_factor);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_partition_set_leader(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_partition_set_follower(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_partition_set_follower_wmarks(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int64_t lo, int64_t hi);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_partition_push_leader_response(rd_kafka_mock_cluster_t *mcluster, const char *topic, int partition, int32_t leader_id, int32_t leader_epoch);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_set_down(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_set_up(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_set_rtt(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int rtt_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_set_rack(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, const char *rack);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_coordinator_set(rd_kafka_mock_cluster_t *mcluster, const char *key_type, const char *key, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_set_apiversion(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, int16_t MinVersion, int16_t MaxVersion);</span>
<span class="s1">void rd_kafka_mock_start_request_tracking(rd_kafka_mock_cluster_t *mcluster);</span>
<span class="s1">void rd_kafka_mock_stop_request_tracking(rd_kafka_mock_cluster_t *mcluster);</span>
<span class="s1">typedef struct rd_kafka_mock_request_s rd_kafka_mock_request_t;</span>
<span class="s1">void rd_kafka_mock_request_destroy(rd_kafka_mock_request_t *mreq);</span>
<span class="s1">void rd_kafka_mock_request_destroy_array(rd_kafka_mock_request_t **mreqs, size_t mreq_cnt);</span>
<span class="s1">int32_t rd_kafka_mock_request_id(rd_kafka_mock_request_t *mreq);</span>
<span class="s1">int16_t rd_kafka_mock_request_api_key(rd_kafka_mock_request_t *mreq);</span>
<span class="s1">int64_t rd_kafka_mock_request_timestamp(rd_kafka_mock_request_t *mreq);</span>
<span class="s1">rd_kafka_mock_request_t **rd_kafka_mock_get_requests(rd_kafka_mock_cluster_t *mcluster, size_t *cntp);</span>
<span class="s1">void rd_kafka_mock_clear_requests(rd_kafka_mock_cluster_t *mcluster);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_telemetry_set_requested_metrics(rd_kafka_mock_cluster_t *mcluster, char **metrics, size_t metrics_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_telemetry_set_push_interval(rd_kafka_mock_cluster_t *mcluster, int64_t push_interval_ms);</span>
<span class="s1">&#39;</span>
</code></pre></div>
rdkafka.h, rdkafka_mock.h</p>
<h3 id="rd_kafka_version_34">RD_KAFKA_VERSION<a class="headerlink" href="#rd_kafka_version_34" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_VERSION</span> <span class="o">=</span> <span class="mi">33948159</span>
</code></pre></div>
<p>librdkafka version </p>
<p>Interpreted as hex <code>MM.mm.rr.xx</code>:</p>
<ul>
<li>MM = Major</li>
<li>mm = minor</li>
<li>rr = revision</li>
<li>xx = pre-release id (0xff is the final release)</li>
</ul>
<p>E.g.: <code>0x000801ff</code> = 0.8.1</p>
<dl class="section remark"><dt>Remarks</dt><dd>This value should only be used during compile time, for runtime checks of version use rd_kafka_version() </dd></dl>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_unsupported_compression_type_34">RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE<a class="headerlink" href="#rd_kafka_resp_err_unsupported_compression_type_34" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE</span> <span class="o">=</span> <span class="mi">76</span>
</code></pre></div>
<p>Unsupported compression type </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_end_all_34">RD_KAFKA_RESP_ERR_END_ALL<a class="headerlink" href="#rd_kafka_resp_err_end_all_34" title="Permanent link">&para;</a></h3>
<p><div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_END_ALL</span> <span class="o">=</span> <span class="mi">119</span>
</code></pre></div>
enum rd_kafka_resp_err_t</p>
<h3 id="rd_kafka_admin_op__cnt_34">RD_KAFKA_ADMIN_OP__CNT<a class="headerlink" href="#rd_kafka_admin_op__cnt_34" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_ADMIN_OP__CNT</span> <span class="o">=</span> <span class="mi">23</span>
</code></pre></div>
<p>Number of ops defined </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe </a></li>
</ul>
</div>
<h3 id="rd_kafka_resource__cnt_34">RD_KAFKA_RESOURCE__CNT<a class="headerlink" href="#rd_kafka_resource__cnt_34" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESOURCE__CNT</span> <span class="o">=</span> <span class="mi">6</span>
</code></pre></div>
<p>Number of resource types defined </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#acca83a66d7783ff7683ed2691cc907c9"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#acca83a66d7783ff7683ed2691cc907c9 </a></li>
</ul>
</div>
<h3 id="rd_kafka_cdef_34">RD_KAFKA_CDEF<a class="headerlink" href="#rd_kafka_cdef_34" title="Permanent link">&para;</a></h3>
<p><div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_CDEF</span> <span class="o">=</span> <span class="s1">&#39;typedef long int ssize_t;</span>
<span class="s1">typedef struct _IO_FILE FILE;</span>
<span class="s1">typedef long int mode_t;</span>
<span class="s1">typedef signed int int16_t;</span>
<span class="s1">typedef unsigned int uint16_t;</span>
<span class="s1">typedef signed int int32_t;</span>
<span class="s1">typedef signed long int int64_t;</span>
<span class="s1">int rd_kafka_version(void);</span>
<span class="s1">const char *rd_kafka_version_str(void);</span>
<span class="s1">typedef enum rd_kafka_type_t {</span>
<span class="s1">  RD_KAFKA_PRODUCER,</span>
<span class="s1">  RD_KAFKA_CONSUMER,</span>
<span class="s1">} rd_kafka_type_t;</span>
<span class="s1">typedef enum rd_kafka_timestamp_type_t {</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_NOT_AVAILABLE,</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_CREATE_TIME,</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_LOG_APPEND_TIME,</span>
<span class="s1">} rd_kafka_timestamp_type_t;</span>
<span class="s1">const char *rd_kafka_get_debug_contexts(void);</span>
<span class="s1">typedef struct rd_kafka_s rd_kafka_t;</span>
<span class="s1">typedef struct rd_kafka_topic_s rd_kafka_topic_t;</span>
<span class="s1">typedef struct rd_kafka_conf_s rd_kafka_conf_t;</span>
<span class="s1">typedef struct rd_kafka_topic_conf_s rd_kafka_topic_conf_t;</span>
<span class="s1">typedef struct rd_kafka_queue_s rd_kafka_queue_t;</span>
<span class="s1">typedef struct rd_kafka_op_s rd_kafka_event_t;</span>
<span class="s1">typedef struct rd_kafka_topic_result_s rd_kafka_topic_result_t;</span>
<span class="s1">typedef struct rd_kafka_consumer_group_metadata_s rd_kafka_consumer_group_metadata_t;</span>
<span class="s1">typedef struct rd_kafka_error_s {</span>
<span class="s1">  unsigned int code;</span>
<span class="s1">  char *errstr;</span>
<span class="s1">  unsigned char fatal;</span>
<span class="s1">  unsigned char retriable;</span>
<span class="s1">  unsigned char txn_requires_abort;</span>
<span class="s1">} rd_kafka_error_t;</span>
<span class="s1">typedef struct rd_kafka_headers_s rd_kafka_headers_t;</span>
<span class="s1">typedef struct rd_kafka_group_result_s rd_kafka_group_result_t;</span>
<span class="s1">typedef struct rd_kafka_acl_result_s rd_kafka_acl_result_t;</span>
<span class="s1">typedef struct rd_kafka_Uuid_s rd_kafka_Uuid_t;</span>
<span class="s1">typedef struct rd_kafka_topic_partition_result_s rd_kafka_topic_partition_result_t;</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BEGIN = (- 200),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BAD_MSG = (- 199),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BAD_COMPRESSION = (- 198),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__DESTROY = (- 197),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FAIL = (- 196),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TRANSPORT = (- 195),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__CRIT_SYS_RESOURCE = (- 194),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__RESOLVE = (- 193),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__MSG_TIMED_OUT = (- 192),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PARTITION_EOF = (- 191),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION = (- 190),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FS = (- 189),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC = (- 188),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ALL_BROKERS_DOWN = (- 187),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INVALID_ARG = (- 186),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TIMED_OUT = (- 185),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__QUEUE_FULL = (- 184),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ISR_INSUFF = (- 183),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NODE_UPDATE = (- 182),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__SSL = (- 181),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__WAIT_COORD = (- 180),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_GROUP = (- 179),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__IN_PROGRESS = (- 178),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PREV_IN_PROGRESS = (- 177),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__EXISTING_SUBSCRIPTION = (- 176),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS = (- 175),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS = (- 174),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__CONFLICT = (- 173),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__STATE = (- 172),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_PROTOCOL = (- 171),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED = (- 170),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__AUTHENTICATION = (- 169),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NO_OFFSET = (- 168),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__OUTDATED = (- 167),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TIMED_OUT_QUEUE = (- 166),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNSUPPORTED_FEATURE = (- 165),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__WAIT_CACHE = (- 164),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INTR = (- 163),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__KEY_SERIALIZATION = (- 162),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__VALUE_SERIALIZATION = (- 161),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__KEY_DESERIALIZATION = (- 160),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__VALUE_DESERIALIZATION = (- 159),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PARTIAL = (- 158),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__READ_ONLY = (- 157),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOENT = (- 156),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNDERFLOW = (- 155),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INVALID_TYPE = (- 154),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__RETRY = (- 153),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PURGE_QUEUE = (- 152),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PURGE_INFLIGHT = (- 151),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FATAL = (- 150),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INCONSISTENT = (- 149),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__GAPLESS_GUARANTEE = (- 148),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__MAX_POLL_EXCEEDED = (- 147),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_BROKER = (- 146),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOT_CONFIGURED = (- 145),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FENCED = (- 144),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__APPLICATION = (- 143),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ASSIGNMENT_LOST = (- 142),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOOP = (- 141),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__AUTO_OFFSET_RESET = (- 140),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__LOG_TRUNCATION = (- 139),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INVALID_DIFFERENT_RECORD = (- 138),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__END = (- 100),</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN = (- 1),</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NO_ERROR = 0,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_OUT_OF_RANGE = 1,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_MSG = 2,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART = 3,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_MSG_SIZE = 4,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE = 5,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_LEADER_FOR_PARTITION = 6,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REQUEST_TIMED_OUT = 7,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_BROKER_NOT_AVAILABLE = 8,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REPLICA_NOT_AVAILABLE = 9,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE = 10,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_STALE_CTRL_EPOCH = 11,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_METADATA_TOO_LARGE = 12,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NETWORK_EXCEPTION = 13,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_COORDINATOR_LOAD_IN_PROGRESS = 14,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_COORDINATOR_NOT_AVAILABLE = 15,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_COORDINATOR = 16,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_EXCEPTION = 17,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_RECORD_LIST_TOO_LARGE = 18,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS = 19,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS_AFTER_APPEND = 20,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REQUIRED_ACKS = 21,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ILLEGAL_GENERATION = 22,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INCONSISTENT_GROUP_PROTOCOL = 23,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_GROUP_ID = 24,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_MEMBER_ID = 25,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_SESSION_TIMEOUT = 26,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REBALANCE_IN_PROGRESS = 27,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_COMMIT_OFFSET_SIZE = 28,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_AUTHORIZATION_FAILED = 29,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_AUTHORIZATION_FAILED = 30,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_CLUSTER_AUTHORIZATION_FAILED = 31,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TIMESTAMP = 32,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_SASL_MECHANISM = 33,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ILLEGAL_SASL_STATE = 34,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_VERSION = 35,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_ALREADY_EXISTS = 36,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PARTITIONS = 37,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REPLICATION_FACTOR = 38,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REPLICA_ASSIGNMENT = 39,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_CONFIG = 40,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_CONTROLLER = 41,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REQUEST = 42,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_FOR_MESSAGE_FORMAT = 43,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_POLICY_VIOLATION = 44,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OUT_OF_ORDER_SEQUENCE_NUMBER = 45,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DUPLICATE_SEQUENCE_NUMBER = 46,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_EPOCH = 47,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TXN_STATE = 48,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_ID_MAPPING = 49,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TRANSACTION_TIMEOUT = 50,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_CONCURRENT_TRANSACTIONS = 51,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TRANSACTION_COORDINATOR_FENCED = 52,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TRANSACTIONAL_ID_AUTHORIZATION_FAILED = 53,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_SECURITY_DISABLED = 54,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OPERATION_NOT_ATTEMPTED = 55,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_KAFKA_STORAGE_ERROR = 56,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LOG_DIR_NOT_FOUND = 57,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_SASL_AUTHENTICATION_FAILED = 58,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_PRODUCER_ID = 59,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REASSIGNMENT_IN_PROGRESS = 60,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTH_DISABLED = 61,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_NOT_FOUND = 62,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_OWNER_MISMATCH = 63,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_REQUEST_NOT_ALLOWED = 64,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTHORIZATION_FAILED = 65,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_EXPIRED = 66,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRINCIPAL_TYPE = 67,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NON_EMPTY_GROUP = 68,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_ID_NOT_FOUND = 69,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FETCH_SESSION_ID_NOT_FOUND = 70,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_FETCH_SESSION_EPOCH = 71,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LISTENER_NOT_FOUND = 72,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_DELETION_DISABLED = 73,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FENCED_LEADER_EPOCH = 74,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_LEADER_EPOCH = 75,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_STALE_BROKER_EPOCH = 77,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_NOT_AVAILABLE = 78,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_MEMBER_ID_REQUIRED = 79,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_PREFERRED_LEADER_NOT_AVAILABLE = 80,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_MAX_SIZE_REACHED = 81,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FENCED_INSTANCE_ID = 82,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ELIGIBLE_LEADERS_NOT_AVAILABLE = 83,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ELECTION_NOT_NEEDED = 84,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NO_REASSIGNMENT_IN_PROGRESS = 85,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_SUBSCRIBED_TO_TOPIC = 86,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_RECORD = 87,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSTABLE_OFFSET_COMMIT = 88,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_THROTTLING_QUOTA_EXCEEDED = 89,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_PRODUCER_FENCED = 90,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_RESOURCE_NOT_FOUND = 91,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DUPLICATE_RESOURCE = 92,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNACCEPTABLE_CREDENTIAL = 93,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INCONSISTENT_VOTER_SET = 94,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_UPDATE_VERSION = 95,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FEATURE_UPDATE_FAILED = 96,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_PRINCIPAL_DESERIALIZATION_FAILURE = 97,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_ID = 100,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FENCED_MEMBER_EPOCH = 110,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNRELEASED_INSTANCE_ID = 111,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_ASSIGNOR = 112,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_STALE_MEMBER_EPOCH = 113,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_SUBSCRIPTION_ID = 117,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TELEMETRY_TOO_LARGE = 118,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_END_ALL,</span>
<span class="s1">} rd_kafka_resp_err_t;</span>
<span class="s1">struct rd_kafka_err_desc {</span>
<span class="s1">  rd_kafka_resp_err_t code;</span>
<span class="s1">  char *name;</span>
<span class="s1">  char *desc;</span>
<span class="s1">};</span>
<span class="s1">void rd_kafka_get_err_descs(const struct rd_kafka_err_desc **errdescs, size_t *cntp);</span>
<span class="s1">const char *rd_kafka_err2str(rd_kafka_resp_err_t err);</span>
<span class="s1">const char *rd_kafka_err2name(rd_kafka_resp_err_t err);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_last_error(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_errno2err(int errnox);</span>
<span class="s1">int rd_kafka_errno(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_fatal_error(rd_kafka_t *rk, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_test_fatal_error(rd_kafka_t *rk, rd_kafka_resp_err_t err, const char *reason);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_error_code(const rd_kafka_error_t *error);</span>
<span class="s1">const char *rd_kafka_error_name(const rd_kafka_error_t *error);</span>
<span class="s1">const char *rd_kafka_error_string(const rd_kafka_error_t *error);</span>
<span class="s1">int rd_kafka_error_is_fatal(const rd_kafka_error_t *error);</span>
<span class="s1">int rd_kafka_error_is_retriable(const rd_kafka_error_t *error);</span>
<span class="s1">int rd_kafka_error_txn_requires_abort(const rd_kafka_error_t *error);</span>
<span class="s1">void rd_kafka_error_destroy(rd_kafka_error_t *error);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_error_new(rd_kafka_resp_err_t code, const char *fmt, ...);</span>
<span class="s1">typedef struct rd_kafka_topic_partition_s {</span>
<span class="s1">  char *topic;</span>
<span class="s1">  int32_t partition;</span>
<span class="s1">  int64_t offset;</span>
<span class="s1">  void *metadata;</span>
<span class="s1">  size_t metadata_size;</span>
<span class="s1">  void *opaque;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  void *_private;</span>
<span class="s1">} rd_kafka_topic_partition_t;</span>
<span class="s1">void rd_kafka_topic_partition_destroy(rd_kafka_topic_partition_t *rktpar);</span>
<span class="s1">void rd_kafka_topic_partition_set_leader_epoch(rd_kafka_topic_partition_t *rktpar, int32_t leader_epoch);</span>
<span class="s1">int32_t rd_kafka_topic_partition_get_leader_epoch(const rd_kafka_topic_partition_t *rktpar);</span>
<span class="s1">typedef struct rd_kafka_topic_partition_list_s {</span>
<span class="s1">  int cnt;</span>
<span class="s1">  int size;</span>
<span class="s1">  rd_kafka_topic_partition_t *elems;</span>
<span class="s1">} rd_kafka_topic_partition_list_t;</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_new(int size);</span>
<span class="s1">void rd_kafka_topic_partition_list_destroy(rd_kafka_topic_partition_list_t *rkparlist);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_add(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">void rd_kafka_topic_partition_list_add_range(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t start, int32_t stop);</span>
<span class="s1">int rd_kafka_topic_partition_list_del(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">int rd_kafka_topic_partition_list_del_by_idx(rd_kafka_topic_partition_list_t *rktparlist, int idx);</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_copy(const rd_kafka_topic_partition_list_t *src);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_topic_partition_list_set_offset(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition, int64_t offset);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_find(const rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">void rd_kafka_topic_partition_list_sort(rd_kafka_topic_partition_list_t *rktparlist, int (*cmp)(const void *a, const void *b, void *cmp_opaque), void *cmp_opaque);</span>
<span class="s1">typedef enum rd_kafka_vtype_t {</span>
<span class="s1">  RD_KAFKA_VTYPE_END,</span>
<span class="s1">  RD_KAFKA_VTYPE_TOPIC,</span>
<span class="s1">  RD_KAFKA_VTYPE_RKT,</span>
<span class="s1">  RD_KAFKA_VTYPE_PARTITION,</span>
<span class="s1">  RD_KAFKA_VTYPE_VALUE,</span>
<span class="s1">  RD_KAFKA_VTYPE_KEY,</span>
<span class="s1">  RD_KAFKA_VTYPE_OPAQUE,</span>
<span class="s1">  RD_KAFKA_VTYPE_MSGFLAGS,</span>
<span class="s1">  RD_KAFKA_VTYPE_TIMESTAMP,</span>
<span class="s1">  RD_KAFKA_VTYPE_HEADER,</span>
<span class="s1">  RD_KAFKA_VTYPE_HEADERS,</span>
<span class="s1">} rd_kafka_vtype_t;</span>
<span class="s1">typedef struct rd_kafka_vu_s {</span>
<span class="s1">  rd_kafka_vtype_t vtype;</span>
<span class="s1">  union {</span>
<span class="s1">    char *cstr;</span>
<span class="s1">    rd_kafka_topic_t *rkt;</span>
<span class="s1">    int i;</span>
<span class="s1">    int32_t i32;</span>
<span class="s1">    int64_t i64;</span>
<span class="s1">    struct {</span>
<span class="s1">      void *ptr;</span>
<span class="s1">      size_t size;</span>
<span class="s1">    } mem;</span>
<span class="s1">    struct {</span>
<span class="s1">      char *name;</span>
<span class="s1">      void *val;</span>
<span class="s1">      ssize_t size;</span>
<span class="s1">    } header;</span>
<span class="s1">    rd_kafka_headers_t *headers;</span>
<span class="s1">    void *ptr;</span>
<span class="s1">    char _pad[64];</span>
<span class="s1">  } u;</span>
<span class="s1">} rd_kafka_vu_t;</span>
<span class="s1">rd_kafka_headers_t *rd_kafka_headers_new(size_t initial_count);</span>
<span class="s1">void rd_kafka_headers_destroy(rd_kafka_headers_t *hdrs);</span>
<span class="s1">rd_kafka_headers_t *rd_kafka_headers_copy(const rd_kafka_headers_t *src);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_add(rd_kafka_headers_t *hdrs, const char *name, ssize_t name_size, const void *value, ssize_t value_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_remove(rd_kafka_headers_t *hdrs, const char *name);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get_last(const rd_kafka_headers_t *hdrs, const char *name, const void **valuep, size_t *sizep);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get(const rd_kafka_headers_t *hdrs, size_t idx, const char *name, const void **valuep, size_t *sizep);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get_all(const rd_kafka_headers_t *hdrs, size_t idx, const char **namep, const void **valuep, size_t *sizep);</span>
<span class="s1">typedef struct rd_kafka_message_s {</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  rd_kafka_topic_t *rkt;</span>
<span class="s1">  int32_t partition;</span>
<span class="s1">  void *payload;</span>
<span class="s1">  size_t len;</span>
<span class="s1">  void *key;</span>
<span class="s1">  size_t key_len;</span>
<span class="s1">  int64_t offset;</span>
<span class="s1">  void *_private;</span>
<span class="s1">} rd_kafka_message_t;</span>
<span class="s1">void rd_kafka_message_destroy(rd_kafka_message_t *rkmessage);</span>
<span class="s1">const char *rd_kafka_message_errstr(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">const char *rd_kafka_message_produce_errstr(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">int64_t rd_kafka_message_timestamp(const rd_kafka_message_t *rkmessage, rd_kafka_timestamp_type_t *tstype);</span>
<span class="s1">int64_t rd_kafka_message_latency(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">int32_t rd_kafka_message_broker_id(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_message_headers(const rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_message_detach_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);</span>
<span class="s1">void rd_kafka_message_set_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t *hdrs);</span>
<span class="s1">size_t rd_kafka_header_cnt(const rd_kafka_headers_t *hdrs);</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_NOT_PERSISTED = 0,</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_POSSIBLY_PERSISTED = 1,</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_PERSISTED = 2,</span>
<span class="s1">} rd_kafka_msg_status_t;</span>
<span class="s1">rd_kafka_msg_status_t rd_kafka_message_status(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">int32_t rd_kafka_message_leader_epoch(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">const char *rd_kafka_Uuid_base64str(const rd_kafka_Uuid_t *uuid);</span>
<span class="s1">int64_t rd_kafka_Uuid_least_significant_bits(const rd_kafka_Uuid_t *uuid);</span>
<span class="s1">int64_t rd_kafka_Uuid_most_significant_bits(const rd_kafka_Uuid_t *uuid);</span>
<span class="s1">rd_kafka_Uuid_t *rd_kafka_Uuid_new(int64_t most_significant_bits, int64_t least_significant_bits);</span>
<span class="s1">rd_kafka_Uuid_t *rd_kafka_Uuid_copy(const rd_kafka_Uuid_t *uuid);</span>
<span class="s1">void rd_kafka_Uuid_destroy(rd_kafka_Uuid_t *uuid);</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_CONF_UNKNOWN = (- 2),</span>
<span class="s1">  RD_KAFKA_CONF_INVALID = (- 1),</span>
<span class="s1">  RD_KAFKA_CONF_OK = 0,</span>
<span class="s1">} rd_kafka_conf_res_t;</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_new(void);</span>
<span class="s1">void rd_kafka_conf_destroy(rd_kafka_conf_t *conf);</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_dup(const rd_kafka_conf_t *conf);</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_dup_filter(const rd_kafka_conf_t *conf, size_t filter_cnt, const char **filter);</span>
<span class="s1">const rd_kafka_conf_t *rd_kafka_conf(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_set(rd_kafka_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_conf_set_events(rd_kafka_conf_t *conf, int events);</span>
<span class="s1">void rd_kafka_conf_set_background_event_cb(rd_kafka_conf_t *conf, void (*event_cb)(rd_kafka_t *rk, rd_kafka_event_t *rkev, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_dr_cb(rd_kafka_conf_t *conf, void (*dr_cb)(rd_kafka_t *rk, void *payload, size_t len, rd_kafka_resp_err_t err, void *opaque, void *msg_opaque));</span>
<span class="s1">void rd_kafka_conf_set_dr_msg_cb(rd_kafka_conf_t *conf, void (*dr_msg_cb)(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_consume_cb(rd_kafka_conf_t *conf, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_rebalance_cb(rd_kafka_conf_t *conf, void (*rebalance_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *partitions, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_offset_commit_cb(rd_kafka_conf_t *conf, void (*offset_commit_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_error_cb(rd_kafka_conf_t *conf, void (*error_cb)(rd_kafka_t *rk, int err, const char *reason, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_throttle_cb(rd_kafka_conf_t *conf, void (*throttle_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int throttle_time_ms, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_log_cb(rd_kafka_conf_t *conf, void (*log_cb)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));</span>
<span class="s1">void rd_kafka_conf_set_stats_cb(rd_kafka_conf_t *conf, int (*stats_cb)(rd_kafka_t *rk, char *json, size_t json_len, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_oauthbearer_token_refresh_cb(rd_kafka_conf_t *conf, void (*oauthbearer_token_refresh_cb)(rd_kafka_t *rk, const char *oauthbearer_config, void *opaque));</span>
<span class="s1">void rd_kafka_conf_enable_sasl_queue(rd_kafka_conf_t *conf, int enable);</span>
<span class="s1">void rd_kafka_conf_set_socket_cb(rd_kafka_conf_t *conf, int (*socket_cb)(int domain, int type, int protocol, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_connect_cb(rd_kafka_conf_t *conf, int (*connect_cb)(int sockfd, const struct sockaddr *addr, int addrlen, const char *id, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_closesocket_cb(rd_kafka_conf_t *conf, int (*closesocket_cb)(int sockfd, void *opaque));</span>
<span class="s1">struct addrinfo;</span>
<span class="s1">void rd_kafka_conf_set_resolve_cb(rd_kafka_conf_t *conf, int (*resolve_cb)(const char *node, const char *service, const struct addrinfo *hints, struct addrinfo **res, void *opaque));</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert_verify_cb(rd_kafka_conf_t *conf, int (*ssl_cert_verify_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int *x509_error, int depth, const char *buf, size_t size, char *errstr, size_t errstr_size, void *opaque));</span>
<span class="s1">typedef enum rd_kafka_cert_type_t {</span>
<span class="s1">  RD_KAFKA_CERT_PUBLIC_KEY,</span>
<span class="s1">  RD_KAFKA_CERT_PRIVATE_KEY,</span>
<span class="s1">  RD_KAFKA_CERT_CA,</span>
<span class="s1">  RD_KAFKA_CERT__CNT,</span>
<span class="s1">} rd_kafka_cert_type_t;</span>
<span class="s1">typedef enum rd_kafka_cert_enc_t {</span>
<span class="s1">  RD_KAFKA_CERT_ENC_PKCS12,</span>
<span class="s1">  RD_KAFKA_CERT_ENC_DER,</span>
<span class="s1">  RD_KAFKA_CERT_ENC_PEM,</span>
<span class="s1">  RD_KAFKA_CERT_ENC__CNT,</span>
<span class="s1">} rd_kafka_cert_enc_t;</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert(rd_kafka_conf_t *conf, rd_kafka_cert_type_t cert_type, rd_kafka_cert_enc_t cert_enc, const void *buffer, size_t size, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_conf_set_engine_callback_data(rd_kafka_conf_t *conf, void *callback_data);</span>
<span class="s1">void rd_kafka_conf_set_opaque(rd_kafka_conf_t *conf, void *opaque);</span>
<span class="s1">void *rd_kafka_opaque(const rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_conf_set_default_topic_conf(rd_kafka_conf_t *conf, rd_kafka_topic_conf_t *tconf);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_conf_get_default_topic_conf(rd_kafka_conf_t *conf);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_get(const rd_kafka_conf_t *conf, const char *name, char *dest, size_t *dest_size);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_topic_conf_get(const rd_kafka_topic_conf_t *conf, const char *name, char *dest, size_t *dest_size);</span>
<span class="s1">const char **rd_kafka_conf_dump(rd_kafka_conf_t *conf, size_t *cntp);</span>
<span class="s1">const char **rd_kafka_topic_conf_dump(rd_kafka_topic_conf_t *conf, size_t *cntp);</span>
<span class="s1">void rd_kafka_conf_dump_free(const char **arr, size_t cnt);</span>
<span class="s1">void rd_kafka_conf_properties_show(FILE *fp);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_topic_conf_new(void);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_topic_conf_dup(const rd_kafka_topic_conf_t *conf);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_default_topic_conf_dup(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_topic_conf_destroy(rd_kafka_topic_conf_t *topic_conf);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_topic_conf_set(rd_kafka_topic_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_topic_conf_set_opaque(rd_kafka_topic_conf_t *conf, void *rkt_opaque);</span>
<span class="s1">void rd_kafka_topic_conf_set_partitioner_cb(rd_kafka_topic_conf_t *topic_conf, int32_t (*partitioner)(const rd_kafka_topic_t *rkt, const void *keydata, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque));</span>
<span class="s1">void rd_kafka_topic_conf_set_msg_order_cmp(rd_kafka_topic_conf_t *topic_conf, int (*msg_order_cmp)(const rd_kafka_message_t *a, const rd_kafka_message_t *b));</span>
<span class="s1">int rd_kafka_topic_partition_available(const rd_kafka_topic_t *rkt, int32_t partition);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_consistent(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_consistent_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_murmur2(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_murmur2_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_fnv1a(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_fnv1a_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">rd_kafka_t *rd_kafka_new(rd_kafka_type_t type, rd_kafka_conf_t *conf, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_destroy(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_destroy_flags(rd_kafka_t *rk, int flags);</span>
<span class="s1">const char *rd_kafka_name(const rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_type_t rd_kafka_type(const rd_kafka_t *rk);</span>
<span class="s1">char *rd_kafka_memberid(const rd_kafka_t *rk);</span>
<span class="s1">char *rd_kafka_clusterid(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">int32_t rd_kafka_controllerid(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_topic_t *rd_kafka_topic_new(rd_kafka_t *rk, const char *topic, rd_kafka_topic_conf_t *conf);</span>
<span class="s1">void rd_kafka_topic_destroy(rd_kafka_topic_t *rkt);</span>
<span class="s1">const char *rd_kafka_topic_name(const rd_kafka_topic_t *rkt);</span>
<span class="s1">void *rd_kafka_topic_opaque(const rd_kafka_topic_t *rkt);</span>
<span class="s1">int rd_kafka_poll(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">void rd_kafka_yield(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_pause_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_resume_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_query_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_get_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offsets_for_times(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets, int timeout_ms);</span>
<span class="s1">void *rd_kafka_mem_calloc(rd_kafka_t *rk, size_t num, size_t size);</span>
<span class="s1">void *rd_kafka_mem_malloc(rd_kafka_t *rk, size_t size);</span>
<span class="s1">void rd_kafka_mem_free(rd_kafka_t *rk, void *ptr);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_new(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_queue_destroy(rd_kafka_queue_t *rkqu);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_main(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_sasl(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_sasl_background_callbacks_enable(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_sasl_set_credentials(rd_kafka_t *rk, const char *username, const char *password);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_consumer(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_partition(rd_kafka_t *rk, const char *topic, int32_t partition);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_background(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_queue_forward(rd_kafka_queue_t *src, rd_kafka_queue_t *dst);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_set_log_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu);</span>
<span class="s1">size_t rd_kafka_queue_length(rd_kafka_queue_t *rkqu);</span>
<span class="s1">void rd_kafka_queue_io_event_enable(rd_kafka_queue_t *rkqu, int fd, const void *payload, size_t size);</span>
<span class="s1">void rd_kafka_queue_cb_event_enable(rd_kafka_queue_t *rkqu, void (*event_cb)(rd_kafka_t *rk, void *qev_opaque), void *qev_opaque);</span>
<span class="s1">void rd_kafka_queue_yield(rd_kafka_queue_t *rkqu);</span>
<span class="s1">int rd_kafka_consume_start(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);</span>
<span class="s1">int rd_kafka_consume_start_queue(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, rd_kafka_queue_t *rkqu);</span>
<span class="s1">int rd_kafka_consume_stop(rd_kafka_topic_t *rkt, int32_t partition);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_seek(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, int timeout_ms);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_seek_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consume(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms);</span>
<span class="s1">ssize_t rd_kafka_consume_batch(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);</span>
<span class="s1">int rd_kafka_consume_callback(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consume_queue(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">ssize_t rd_kafka_consume_batch_queue(rd_kafka_queue_t *rkqu, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);</span>
<span class="s1">int rd_kafka_consume_callback_queue(rd_kafka_queue_t *rkqu, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offset_store(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offsets_store(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_offset_store_message(rd_kafka_message_t *rkmessage);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_subscribe(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *topics);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_unsubscribe(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_subscription(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **topics);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consumer_poll(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_consumer_close(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_consumer_close_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu);</span>
<span class="s1">int rd_kafka_consumer_closed(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_incremental_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_incremental_unassign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">const char *rd_kafka_rebalance_protocol(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_assignment(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **partitions);</span>
<span class="s1">int rd_kafka_assignment_lost(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, int async);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit_message(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, int async);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit_queue(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_queue_t *rkqu, void (*cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *commit_opaque), void *commit_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_committed(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_position(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata_new(const char *group_id);</span>
<span class="s1">rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata_new_with_genid(const char *group_id, int32_t generation_id, const char *member_id, const char *group_instance_id);</span>
<span class="s1">const char *rd_kafka_consumer_group_metadata_member_id(const rd_kafka_consumer_group_metadata_t *group_metadata);</span>
<span class="s1">void rd_kafka_consumer_group_metadata_destroy(rd_kafka_consumer_group_metadata_t *);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_consumer_group_metadata_write(const rd_kafka_consumer_group_metadata_t *cgmd, void **bufferp, size_t *sizep);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_consumer_group_metadata_read(rd_kafka_consumer_group_metadata_t **cgmdp, const void *buffer, size_t size);</span>
<span class="s1">int rd_kafka_produce(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, void *payload, size_t len, const void *key, size_t keylen, void *msg_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_producev(rd_kafka_t *rk, ...);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_produceva(rd_kafka_t *rk, const rd_kafka_vu_t *vus, size_t cnt);</span>
<span class="s1">int rd_kafka_produce_batch(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, rd_kafka_message_t *rkmessages, int message_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_flush(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_purge(rd_kafka_t *rk, int purge_flags);</span>
<span class="s1">typedef struct rd_kafka_metadata_broker {</span>
<span class="s1">  int32_t id;</span>
<span class="s1">  char *host;</span>
<span class="s1">  int port;</span>
<span class="s1">} rd_kafka_metadata_broker_t;</span>
<span class="s1">typedef struct rd_kafka_metadata_partition {</span>
<span class="s1">  int32_t id;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  int32_t leader;</span>
<span class="s1">  int replica_cnt;</span>
<span class="s1">  int32_t *replicas;</span>
<span class="s1">  int isr_cnt;</span>
<span class="s1">  int32_t *isrs;</span>
<span class="s1">} rd_kafka_metadata_partition_t;</span>
<span class="s1">typedef struct rd_kafka_metadata_topic {</span>
<span class="s1">  char *topic;</span>
<span class="s1">  int partition_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_partition *partitions;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">} rd_kafka_metadata_topic_t;</span>
<span class="s1">typedef struct rd_kafka_metadata {</span>
<span class="s1">  int broker_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_broker *brokers;</span>
<span class="s1">  int topic_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_topic *topics;</span>
<span class="s1">  int32_t orig_broker_id;</span>
<span class="s1">  char *orig_broker_name;</span>
<span class="s1">} rd_kafka_metadata_t;</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_metadata(rd_kafka_t *rk, int all_topics, rd_kafka_topic_t *only_rkt, const struct rd_kafka_metadata **metadatap, int timeout_ms);</span>
<span class="s1">void rd_kafka_metadata_destroy(const struct rd_kafka_metadata *metadata);</span>
<span class="s1">typedef struct rd_kafka_Node_s rd_kafka_Node_t;</span>
<span class="s1">int rd_kafka_Node_id(const rd_kafka_Node_t *node);</span>
<span class="s1">const char *rd_kafka_Node_host(const rd_kafka_Node_t *node);</span>
<span class="s1">uint16_t rd_kafka_Node_port(const rd_kafka_Node_t *node);</span>
<span class="s1">const char *rd_kafka_Node_rack(const rd_kafka_Node_t *node);</span>
<span class="s1">struct rd_kafka_group_member_info {</span>
<span class="s1">  char *member_id;</span>
<span class="s1">  char *client_id;</span>
<span class="s1">  char *client_host;</span>
<span class="s1">  void *member_metadata;</span>
<span class="s1">  int member_metadata_size;</span>
<span class="s1">  void *member_assignment;</span>
<span class="s1">  int member_assignment_size;</span>
<span class="s1">};</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_CONSUMER_GROUP_STATE_UNKNOWN = 0,</span>
<span class="s1">  RD_KAFKA_CONSUMER_GROUP_STATE_PREPARING_REBALANCE = 1,</span>
<span class="s1">  RD_KAFKA_CONSUMER_GROUP_STATE_COMPLETING_REBALANCE = 2,</span>
<span class="s1">  RD_KAFKA_CONSUMER_GROUP_STATE_STABLE = 3,</span>
<span class="s1">  RD_KAFKA_CONSUMER_GROUP_STATE_DEAD = 4,</span>
<span class="s1">  RD_KAFKA_CONSUMER_GROUP_STATE_EMPTY = 5,</span>
<span class="s1">  RD_KAFKA_CONSUMER_GROUP_STATE__CNT,</span>
<span class="s1">} rd_kafka_consumer_group_state_t;</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_CONSUMER_GROUP_TYPE_UNKNOWN = 0,</span>
<span class="s1">  RD_KAFKA_CONSUMER_GROUP_TYPE_CONSUMER = 1,</span>
<span class="s1">  RD_KAFKA_CONSUMER_GROUP_TYPE_CLASSIC = 2,</span>
<span class="s1">  RD_KAFKA_CONSUMER_GROUP_TYPE__CNT,</span>
<span class="s1">} rd_kafka_consumer_group_type_t;</span>
<span class="s1">struct rd_kafka_group_info {</span>
<span class="s1">  struct rd_kafka_metadata_broker broker;</span>
<span class="s1">  char *group;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  char *state;</span>
<span class="s1">  char *protocol_type;</span>
<span class="s1">  char *protocol;</span>
<span class="s1">  struct rd_kafka_group_member_info *members;</span>
<span class="s1">  int member_cnt;</span>
<span class="s1">};</span>
<span class="s1">struct rd_kafka_group_list {</span>
<span class="s1">  struct rd_kafka_group_info *groups;</span>
<span class="s1">  int group_cnt;</span>
<span class="s1">};</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_list_groups(rd_kafka_t *rk, const char *group, const struct rd_kafka_group_list **grplistp, int timeout_ms);</span>
<span class="s1">const char *rd_kafka_consumer_group_state_name(rd_kafka_consumer_group_state_t state);</span>
<span class="s1">rd_kafka_consumer_group_state_t rd_kafka_consumer_group_state_code(const char *name);</span>
<span class="s1">const char *rd_kafka_consumer_group_type_name(rd_kafka_consumer_group_type_t type);</span>
<span class="s1">rd_kafka_consumer_group_type_t rd_kafka_consumer_group_type_code(const char *name);</span>
<span class="s1">void rd_kafka_group_list_destroy(const struct rd_kafka_group_list *grplist);</span>
<span class="s1">int rd_kafka_brokers_add(rd_kafka_t *rk, const char *brokerlist);</span>
<span class="s1">void rd_kafka_set_logger(rd_kafka_t *rk, void (*func)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));</span>
<span class="s1">void rd_kafka_set_log_level(rd_kafka_t *rk, int level);</span>
<span class="s1">void rd_kafka_log_print(const rd_kafka_t *rk, int level, const char *fac, const char *buf);</span>
<span class="s1">void rd_kafka_log_syslog(const rd_kafka_t *rk, int level, const char *fac, const char *buf);</span>
<span class="s1">int rd_kafka_outq_len(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_dump(FILE *fp, rd_kafka_t *rk);</span>
<span class="s1">int rd_kafka_thread_cnt(void);</span>
<span class="s1">typedef enum rd_kafka_thread_type_t {</span>
<span class="s1">  RD_KAFKA_THREAD_MAIN,</span>
<span class="s1">  RD_KAFKA_THREAD_BACKGROUND,</span>
<span class="s1">  RD_KAFKA_THREAD_BROKER,</span>
<span class="s1">} rd_kafka_thread_type_t;</span>
<span class="s1">int rd_kafka_wait_destroyed(int timeout_ms);</span>
<span class="s1">int rd_kafka_unittest(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_poll_set_consumer(rd_kafka_t *rk);</span>
<span class="s1">typedef int rd_kafka_event_type_t;</span>
<span class="s1">rd_kafka_event_type_t rd_kafka_event_type(const rd_kafka_event_t *rkev);</span>
<span class="s1">const char *rd_kafka_event_name(const rd_kafka_event_t *rkev);</span>
<span class="s1">void rd_kafka_event_destroy(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_message_t *rd_kafka_event_message_next(rd_kafka_event_t *rkev);</span>
<span class="s1">size_t rd_kafka_event_message_array(rd_kafka_event_t *rkev, const rd_kafka_message_t **rkmessages, size_t size);</span>
<span class="s1">size_t rd_kafka_event_message_count(rd_kafka_event_t *rkev);</span>
<span class="s1">const char *rd_kafka_event_config_string(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_event_error(rd_kafka_event_t *rkev);</span>
<span class="s1">const char *rd_kafka_event_error_string(rd_kafka_event_t *rkev);</span>
<span class="s1">int rd_kafka_event_error_is_fatal(rd_kafka_event_t *rkev);</span>
<span class="s1">void *rd_kafka_event_opaque(rd_kafka_event_t *rkev);</span>
<span class="s1">int rd_kafka_event_log(rd_kafka_event_t *rkev, const char **fac, const char **str, int *level);</span>
<span class="s1">int rd_kafka_event_debug_contexts(rd_kafka_event_t *rkev, char *dst, size_t dstsize);</span>
<span class="s1">const char *rd_kafka_event_stats(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_event_topic_partition_list(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_event_topic_partition(rd_kafka_event_t *rkev);</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_CreateTopics_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DeleteTopics_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_CreateAcls_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DescribeAcls_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DeleteAcls_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_CreatePartitions_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_AlterConfigs_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_IncrementalAlterConfigs_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DescribeConfigs_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DeleteRecords_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_ListConsumerGroups_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DescribeConsumerGroups_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DeleteGroups_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DeleteConsumerGroupOffsets_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_AlterConsumerGroupOffsets_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_ListConsumerGroupOffsets_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DescribeTopics_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DescribeCluster_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DescribeUserScramCredentials_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_AlterUserScramCredentials_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_ListOffsets_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_ElectLeaders_result_t;</span>
<span class="s1">const rd_kafka_CreateTopics_result_t *rd_kafka_event_CreateTopics_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DeleteTopics_result_t *rd_kafka_event_DeleteTopics_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_CreatePartitions_result_t *rd_kafka_event_CreatePartitions_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_AlterConfigs_result_t *rd_kafka_event_AlterConfigs_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_IncrementalAlterConfigs_result_t *rd_kafka_event_IncrementalAlterConfigs_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DescribeConfigs_result_t *rd_kafka_event_DescribeConfigs_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DeleteRecords_result_t *rd_kafka_event_DeleteRecords_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_ListConsumerGroups_result_t *rd_kafka_event_ListConsumerGroups_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DescribeConsumerGroups_result_t *rd_kafka_event_DescribeConsumerGroups_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DescribeTopics_result_t *rd_kafka_event_DescribeTopics_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DescribeCluster_result_t *rd_kafka_event_DescribeCluster_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DeleteGroups_result_t *rd_kafka_event_DeleteGroups_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DeleteConsumerGroupOffsets_result_t *rd_kafka_event_DeleteConsumerGroupOffsets_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_CreateAcls_result_t *rd_kafka_event_CreateAcls_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DescribeAcls_result_t *rd_kafka_event_DescribeAcls_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DeleteAcls_result_t *rd_kafka_event_DeleteAcls_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_ListConsumerGroupOffsets_result_t *rd_kafka_event_ListConsumerGroupOffsets_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_AlterConsumerGroupOffsets_result_t *rd_kafka_event_AlterConsumerGroupOffsets_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_ListOffsets_result_t *rd_kafka_event_ListOffsets_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DescribeUserScramCredentials_result_t *rd_kafka_event_DescribeUserScramCredentials_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_AlterUserScramCredentials_result_t *rd_kafka_event_AlterUserScramCredentials_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_ElectLeaders_result_t *rd_kafka_event_ElectLeaders_result(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_event_t *rd_kafka_queue_poll(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">int rd_kafka_queue_poll_callback(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_plugin_f_conf_init_t)(rd_kafka_conf_t *conf, void **plug_opaquep, char *errstr, size_t errstr_size);</span>
<span class="s1">typedef rd_kafka_conf_res_t (rd_kafka_interceptor_f_on_conf_set_t)(rd_kafka_conf_t *conf, const char *name, const char *val, char *errstr, size_t errstr_size, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_dup_t)(rd_kafka_conf_t *new_conf, const rd_kafka_conf_t *old_conf, size_t filter_cnt, const char **filter, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_destroy_t)(void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_new_t)(rd_kafka_t *rk, const rd_kafka_conf_t *conf, void *ic_opaque, char *errstr, size_t errstr_size);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_destroy_t)(rd_kafka_t *rk, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_send_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_acknowledgement_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_consume_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_commit_t)(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_resp_err_t err, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_request_sent_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_response_received_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, int64_t rtt, rd_kafka_resp_err_t err, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_start_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_exit_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_broker_state_change_t)(rd_kafka_t *rk, int32_t broker_id, const char *secproto, const char *name, int port, const char *state, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_set(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_set_t *on_conf_set, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_dup(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_dup_t *on_conf_dup, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_destroy(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_destroy_t *on_conf_destroy, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_new(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_new_t *on_new, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_destroy(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_destroy_t *on_destroy, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_send(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_send_t *on_send, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_acknowledgement(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_acknowledgement_t *on_acknowledgement, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_consume(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_consume_t *on_consume, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_commit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_commit_t *on_commit, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_request_sent(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_request_sent_t *on_request_sent, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_response_received(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_response_received_t *on_response_received, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_start(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_start_t *on_thread_start, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_exit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_exit_t *on_thread_exit, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_broker_state_change(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_broker_state_change_t *on_broker_state_change, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_topic_result_error(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">const char *rd_kafka_topic_result_error_string(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">const char *rd_kafka_topic_result_name(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">const rd_kafka_error_t *rd_kafka_group_result_error(const rd_kafka_group_result_t *groupres);</span>
<span class="s1">const char *rd_kafka_group_result_name(const rd_kafka_group_result_t *groupres);</span>
<span class="s1">const rd_kafka_topic_partition_list_t *rd_kafka_group_result_partitions(const rd_kafka_group_result_t *groupres);</span>
<span class="s1">const rd_kafka_topic_partition_t *rd_kafka_topic_partition_result_partition(const rd_kafka_topic_partition_result_t *partition_result);</span>
<span class="s1">const rd_kafka_error_t *rd_kafka_topic_partition_result_error(const rd_kafka_topic_partition_result_t *partition_result);</span>
<span class="s1">typedef enum rd_kafka_admin_op_t {</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_ANY = 0,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_CREATETOPICS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DELETETOPICS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_CREATEPARTITIONS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_ALTERCONFIGS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DESCRIBECONFIGS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DELETERECORDS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DELETEGROUPS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DELETECONSUMERGROUPOFFSETS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_CREATEACLS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DESCRIBEACLS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DELETEACLS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_LISTCONSUMERGROUPS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DESCRIBECONSUMERGROUPS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_LISTCONSUMERGROUPOFFSETS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_ALTERCONSUMERGROUPOFFSETS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_INCREMENTALALTERCONFIGS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DESCRIBEUSERSCRAMCREDENTIALS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_ALTERUSERSCRAMCREDENTIALS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DESCRIBETOPICS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DESCRIBECLUSTER,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_LISTOFFSETS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_ELECTLEADERS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP__CNT,</span>
<span class="s1">} rd_kafka_admin_op_t;</span>
<span class="s1">typedef struct rd_kafka_AdminOptions_s rd_kafka_AdminOptions_t;</span>
<span class="s1">typedef enum rd_kafka_IsolationLevel_t {</span>
<span class="s1">  RD_KAFKA_ISOLATION_LEVEL_READ_UNCOMMITTED = 0,</span>
<span class="s1">  RD_KAFKA_ISOLATION_LEVEL_READ_COMMITTED = 1,</span>
<span class="s1">} rd_kafka_IsolationLevel_t;</span>
<span class="s1">rd_kafka_AdminOptions_t *rd_kafka_AdminOptions_new(rd_kafka_t *rk, rd_kafka_admin_op_t for_api);</span>
<span class="s1">void rd_kafka_AdminOptions_destroy(rd_kafka_AdminOptions_t *options);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_request_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_operation_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_validate_only(rd_kafka_AdminOptions_t *options, int true_or_false, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_broker(rd_kafka_AdminOptions_t *options, int32_t broker_id, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_AdminOptions_set_require_stable_offsets(rd_kafka_AdminOptions_t *options, int true_or_false);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_AdminOptions_set_include_authorized_operations(rd_kafka_AdminOptions_t *options, int true_or_false);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_AdminOptions_set_match_consumer_group_states(rd_kafka_AdminOptions_t *options, const rd_kafka_consumer_group_state_t *consumer_group_states, size_t consumer_group_states_cnt);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_AdminOptions_set_match_consumer_group_types(rd_kafka_AdminOptions_t *options, const rd_kafka_consumer_group_type_t *consumer_group_types, size_t consumer_group_types_cnt);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_AdminOptions_set_isolation_level(rd_kafka_AdminOptions_t *options, rd_kafka_IsolationLevel_t value);</span>
<span class="s1">void rd_kafka_AdminOptions_set_opaque(rd_kafka_AdminOptions_t *options, void *ev_opaque);</span>
<span class="s1">typedef enum rd_kafka_AclOperation_t {</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_UNKNOWN = 0,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_ANY = 1,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_ALL = 2,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_READ = 3,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_WRITE = 4,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_CREATE = 5,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_DELETE = 6,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_ALTER = 7,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_DESCRIBE = 8,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_CLUSTER_ACTION = 9,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_DESCRIBE_CONFIGS = 10,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_ALTER_CONFIGS = 11,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_IDEMPOTENT_WRITE = 12,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION__CNT,</span>
<span class="s1">} rd_kafka_AclOperation_t;</span>
<span class="s1">typedef struct rd_kafka_NewTopic_s rd_kafka_NewTopic_t;</span>
<span class="s1">rd_kafka_NewTopic_t *rd_kafka_NewTopic_new(const char *topic, int num_partitions, int replication_factor, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_NewTopic_destroy(rd_kafka_NewTopic_t *new_topic);</span>
<span class="s1">void rd_kafka_NewTopic_destroy_array(rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewTopic_set_replica_assignment(rd_kafka_NewTopic_t *new_topic, int32_t partition, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewTopic_set_config(rd_kafka_NewTopic_t *new_topic, const char *name, const char *value);</span>
<span class="s1">void rd_kafka_CreateTopics(rd_kafka_t *rk, rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_CreateTopics_result_topics(const rd_kafka_CreateTopics_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_DeleteTopic_s rd_kafka_DeleteTopic_t;</span>
<span class="s1">rd_kafka_DeleteTopic_t *rd_kafka_DeleteTopic_new(const char *topic);</span>
<span class="s1">void rd_kafka_DeleteTopic_destroy(rd_kafka_DeleteTopic_t *del_topic);</span>
<span class="s1">void rd_kafka_DeleteTopic_destroy_array(rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt);</span>
<span class="s1">void rd_kafka_DeleteTopics(rd_kafka_t *rk, rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_DeleteTopics_result_topics(const rd_kafka_DeleteTopics_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_NewPartitions_s rd_kafka_NewPartitions_t;</span>
<span class="s1">rd_kafka_NewPartitions_t *rd_kafka_NewPartitions_new(const char *topic, size_t new_total_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_NewPartitions_destroy(rd_kafka_NewPartitions_t *new_parts);</span>
<span class="s1">void rd_kafka_NewPartitions_destroy_array(rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewPartitions_set_replica_assignment(rd_kafka_NewPartitions_t *new_parts, int32_t new_partition_idx, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_CreatePartitions(rd_kafka_t *rk, rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_CreatePartitions_result_topics(const rd_kafka_CreatePartitions_result_t *result, size_t *cntp);</span>
<span class="s1">typedef enum rd_kafka_ConfigSource_t {</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_UNKNOWN_CONFIG = 0,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_TOPIC_CONFIG = 1,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_BROKER_CONFIG = 2,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_DEFAULT_BROKER_CONFIG = 3,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_STATIC_BROKER_CONFIG = 4,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DEFAULT_CONFIG = 5,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE__CNT,</span>
<span class="s1">} rd_kafka_ConfigSource_t;</span>
<span class="s1">const char *rd_kafka_ConfigSource_name(rd_kafka_ConfigSource_t confsource);</span>
<span class="s1">typedef struct rd_kafka_ConfigEntry_s rd_kafka_ConfigEntry_t;</span>
<span class="s1">const char *rd_kafka_ConfigEntry_name(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">const char *rd_kafka_ConfigEntry_value(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">rd_kafka_ConfigSource_t rd_kafka_ConfigEntry_source(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_read_only(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_default(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_sensitive(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_synonym(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">const rd_kafka_ConfigEntry_t **rd_kafka_ConfigEntry_synonyms(const rd_kafka_ConfigEntry_t *entry, size_t *cntp);</span>
<span class="s1">typedef enum rd_kafka_ResourceType_t {</span>
<span class="s1">  RD_KAFKA_RESOURCE_UNKNOWN = 0,</span>
<span class="s1">  RD_KAFKA_RESOURCE_ANY = 1,</span>
<span class="s1">  RD_KAFKA_RESOURCE_TOPIC = 2,</span>
<span class="s1">  RD_KAFKA_RESOURCE_GROUP = 3,</span>
<span class="s1">  RD_KAFKA_RESOURCE_BROKER = 4,</span>
<span class="s1">  RD_KAFKA_RESOURCE_TRANSACTIONAL_ID = 5,</span>
<span class="s1">  RD_KAFKA_RESOURCE__CNT,</span>
<span class="s1">} rd_kafka_ResourceType_t;</span>
<span class="s1">typedef enum rd_kafka_ResourcePatternType_t {</span>
<span class="s1">  RD_KAFKA_RESOURCE_PATTERN_UNKNOWN = 0,</span>
<span class="s1">  RD_KAFKA_RESOURCE_PATTERN_ANY = 1,</span>
<span class="s1">  RD_KAFKA_RESOURCE_PATTERN_MATCH = 2,</span>
<span class="s1">  RD_KAFKA_RESOURCE_PATTERN_LITERAL = 3,</span>
<span class="s1">  RD_KAFKA_RESOURCE_PATTERN_PREFIXED = 4,</span>
<span class="s1">  RD_KAFKA_RESOURCE_PATTERN_TYPE__CNT,</span>
<span class="s1">} rd_kafka_ResourcePatternType_t;</span>
<span class="s1">typedef enum rd_kafka_AlterConfigOpType_t {</span>
<span class="s1">  RD_KAFKA_ALTER_CONFIG_OP_TYPE_SET = 0,</span>
<span class="s1">  RD_KAFKA_ALTER_CONFIG_OP_TYPE_DELETE = 1,</span>
<span class="s1">  RD_KAFKA_ALTER_CONFIG_OP_TYPE_APPEND = 2,</span>
<span class="s1">  RD_KAFKA_ALTER_CONFIG_OP_TYPE_SUBTRACT = 3,</span>
<span class="s1">  RD_KAFKA_ALTER_CONFIG_OP_TYPE__CNT,</span>
<span class="s1">} rd_kafka_AlterConfigOpType_t;</span>
<span class="s1">const char *rd_kafka_ResourcePatternType_name(rd_kafka_ResourcePatternType_t resource_pattern_type);</span>
<span class="s1">const char *rd_kafka_ResourceType_name(rd_kafka_ResourceType_t restype);</span>
<span class="s1">typedef struct rd_kafka_ConfigResource_s rd_kafka_ConfigResource_t;</span>
<span class="s1">rd_kafka_ConfigResource_t *rd_kafka_ConfigResource_new(rd_kafka_ResourceType_t restype, const char *resname);</span>
<span class="s1">void rd_kafka_ConfigResource_destroy(rd_kafka_ConfigResource_t *config);</span>
<span class="s1">void rd_kafka_ConfigResource_destroy_array(rd_kafka_ConfigResource_t **config, size_t config_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_ConfigResource_set_config(rd_kafka_ConfigResource_t *config, const char *name, const char *value);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_ConfigResource_add_incremental_config(rd_kafka_ConfigResource_t *config, const char *name, rd_kafka_AlterConfigOpType_t op_type, const char *value);</span>
<span class="s1">const rd_kafka_ConfigEntry_t **rd_kafka_ConfigResource_configs(const rd_kafka_ConfigResource_t *config, size_t *cntp);</span>
<span class="s1">rd_kafka_ResourceType_t rd_kafka_ConfigResource_type(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">const char *rd_kafka_ConfigResource_name(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_ConfigResource_error(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">const char *rd_kafka_ConfigResource_error_string(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">void rd_kafka_AlterConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_ConfigResource_t **rd_kafka_AlterConfigs_result_resources(const rd_kafka_AlterConfigs_result_t *result, size_t *cntp);</span>
<span class="s1">void rd_kafka_IncrementalAlterConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_ConfigResource_t **rd_kafka_IncrementalAlterConfigs_result_resources(const rd_kafka_IncrementalAlterConfigs_result_t *result, size_t *cntp);</span>
<span class="s1">void rd_kafka_DescribeConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_ConfigResource_t **rd_kafka_DescribeConfigs_result_resources(const rd_kafka_DescribeConfigs_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_DeleteRecords_s rd_kafka_DeleteRecords_t;</span>
<span class="s1">rd_kafka_DeleteRecords_t *rd_kafka_DeleteRecords_new(const rd_kafka_topic_partition_list_t *before_offsets);</span>
<span class="s1">void rd_kafka_DeleteRecords_destroy(rd_kafka_DeleteRecords_t *del_records);</span>
<span class="s1">void rd_kafka_DeleteRecords_destroy_array(rd_kafka_DeleteRecords_t **del_records, size_t del_record_cnt);</span>
<span class="s1">void rd_kafka_DeleteRecords(rd_kafka_t *rk, rd_kafka_DeleteRecords_t **del_records, size_t del_record_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_partition_list_t *rd_kafka_DeleteRecords_result_offsets(const rd_kafka_DeleteRecords_result_t *result);</span>
<span class="s1">typedef struct rd_kafka_TopicCollection_s rd_kafka_TopicCollection_t;</span>
<span class="s1">typedef struct rd_kafka_TopicPartitionInfo_s rd_kafka_TopicPartitionInfo_t;</span>
<span class="s1">typedef struct rd_kafka_TopicDescription_s rd_kafka_TopicDescription_t;</span>
<span class="s1">rd_kafka_TopicCollection_t *rd_kafka_TopicCollection_of_topic_names(const char **topics, size_t topics_cnt);</span>
<span class="s1">void rd_kafka_TopicCollection_destroy(rd_kafka_TopicCollection_t *topics);</span>
<span class="s1">void rd_kafka_DescribeTopics(rd_kafka_t *rk, const rd_kafka_TopicCollection_t *topics, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_TopicDescription_t **rd_kafka_DescribeTopics_result_topics(const rd_kafka_DescribeTopics_result_t *result, size_t *cntp);</span>
<span class="s1">const rd_kafka_TopicPartitionInfo_t **rd_kafka_TopicDescription_partitions(const rd_kafka_TopicDescription_t *topicdesc, size_t *cntp);</span>
<span class="s1">const int rd_kafka_TopicPartitionInfo_partition(const rd_kafka_TopicPartitionInfo_t *partition);</span>
<span class="s1">const rd_kafka_Node_t *rd_kafka_TopicPartitionInfo_leader(const rd_kafka_TopicPartitionInfo_t *partition);</span>
<span class="s1">const rd_kafka_Node_t **rd_kafka_TopicPartitionInfo_isr(const rd_kafka_TopicPartitionInfo_t *partition, size_t *cntp);</span>
<span class="s1">const rd_kafka_Node_t **rd_kafka_TopicPartitionInfo_replicas(const rd_kafka_TopicPartitionInfo_t *partition, size_t *cntp);</span>
<span class="s1">const rd_kafka_AclOperation_t *rd_kafka_TopicDescription_authorized_operations(const rd_kafka_TopicDescription_t *topicdesc, size_t *cntp);</span>
<span class="s1">const char *rd_kafka_TopicDescription_name(const rd_kafka_TopicDescription_t *topicdesc);</span>
<span class="s1">const rd_kafka_Uuid_t *rd_kafka_TopicDescription_topic_id(const rd_kafka_TopicDescription_t *topicdesc);</span>
<span class="s1">int rd_kafka_TopicDescription_is_internal(const rd_kafka_TopicDescription_t *topicdesc);</span>
<span class="s1">const rd_kafka_error_t *rd_kafka_TopicDescription_error(const rd_kafka_TopicDescription_t *topicdesc);</span>
<span class="s1">void rd_kafka_DescribeCluster(rd_kafka_t *rk, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_Node_t **rd_kafka_DescribeCluster_result_nodes(const rd_kafka_DescribeCluster_result_t *result, size_t *cntp);</span>
<span class="s1">const rd_kafka_AclOperation_t *rd_kafka_DescribeCluster_result_authorized_operations(const rd_kafka_DescribeCluster_result_t *result, size_t *cntp);</span>
<span class="s1">const rd_kafka_Node_t *rd_kafka_DescribeCluster_result_controller(const rd_kafka_DescribeCluster_result_t *result);</span>
<span class="s1">const char *rd_kafka_DescribeCluster_result_cluster_id(const rd_kafka_DescribeCluster_result_t *result);</span>
<span class="s1">typedef struct rd_kafka_ConsumerGroupListing_s rd_kafka_ConsumerGroupListing_t;</span>
<span class="s1">typedef struct rd_kafka_ListConsumerGroupsResult_s rd_kafka_ListConsumerGroupsResult_t;</span>
<span class="s1">void rd_kafka_ListConsumerGroups(rd_kafka_t *rk, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const char *rd_kafka_ConsumerGroupListing_group_id(const rd_kafka_ConsumerGroupListing_t *grplist);</span>
<span class="s1">int rd_kafka_ConsumerGroupListing_is_simple_consumer_group(const rd_kafka_ConsumerGroupListing_t *grplist);</span>
<span class="s1">rd_kafka_consumer_group_state_t rd_kafka_ConsumerGroupListing_state(const rd_kafka_ConsumerGroupListing_t *grplist);</span>
<span class="s1">rd_kafka_consumer_group_type_t rd_kafka_ConsumerGroupListing_type(const rd_kafka_ConsumerGroupListing_t *grplist);</span>
<span class="s1">const rd_kafka_ConsumerGroupListing_t **rd_kafka_ListConsumerGroups_result_valid(const rd_kafka_ListConsumerGroups_result_t *result, size_t *cntp);</span>
<span class="s1">const rd_kafka_error_t **rd_kafka_ListConsumerGroups_result_errors(const rd_kafka_ListConsumerGroups_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_ConsumerGroupDescription_s rd_kafka_ConsumerGroupDescription_t;</span>
<span class="s1">typedef struct rd_kafka_MemberDescription_s rd_kafka_MemberDescription_t;</span>
<span class="s1">typedef struct rd_kafka_MemberAssignment_s rd_kafka_MemberAssignment_t;</span>
<span class="s1">void rd_kafka_DescribeConsumerGroups(rd_kafka_t *rk, const char **groups, size_t groups_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_ConsumerGroupDescription_t **rd_kafka_DescribeConsumerGroups_result_groups(const rd_kafka_DescribeConsumerGroups_result_t *result, size_t *cntp);</span>
<span class="s1">const char *rd_kafka_ConsumerGroupDescription_group_id(const rd_kafka_ConsumerGroupDescription_t *grpdesc);</span>
<span class="s1">const rd_kafka_error_t *rd_kafka_ConsumerGroupDescription_error(const rd_kafka_ConsumerGroupDescription_t *grpdesc);</span>
<span class="s1">int rd_kafka_ConsumerGroupDescription_is_simple_consumer_group(const rd_kafka_ConsumerGroupDescription_t *grpdesc);</span>
<span class="s1">const char *rd_kafka_ConsumerGroupDescription_partition_assignor(const rd_kafka_ConsumerGroupDescription_t *grpdesc);</span>
<span class="s1">const rd_kafka_AclOperation_t *rd_kafka_ConsumerGroupDescription_authorized_operations(const rd_kafka_ConsumerGroupDescription_t *grpdesc, size_t *cntp);</span>
<span class="s1">rd_kafka_consumer_group_state_t rd_kafka_ConsumerGroupDescription_state(const rd_kafka_ConsumerGroupDescription_t *grpdesc);</span>
<span class="s1">const rd_kafka_Node_t *rd_kafka_ConsumerGroupDescription_coordinator(const rd_kafka_ConsumerGroupDescription_t *grpdesc);</span>
<span class="s1">size_t rd_kafka_ConsumerGroupDescription_member_count(const rd_kafka_ConsumerGroupDescription_t *grpdesc);</span>
<span class="s1">const rd_kafka_MemberDescription_t *rd_kafka_ConsumerGroupDescription_member(const rd_kafka_ConsumerGroupDescription_t *grpdesc, size_t idx);</span>
<span class="s1">const char *rd_kafka_MemberDescription_client_id(const rd_kafka_MemberDescription_t *member);</span>
<span class="s1">const char *rd_kafka_MemberDescription_group_instance_id(const rd_kafka_MemberDescription_t *member);</span>
<span class="s1">const char *rd_kafka_MemberDescription_consumer_id(const rd_kafka_MemberDescription_t *member);</span>
<span class="s1">const char *rd_kafka_MemberDescription_host(const rd_kafka_MemberDescription_t *member);</span>
<span class="s1">const rd_kafka_MemberAssignment_t *rd_kafka_MemberDescription_assignment(const rd_kafka_MemberDescription_t *member);</span>
<span class="s1">const rd_kafka_topic_partition_list_t *rd_kafka_MemberAssignment_partitions(const rd_kafka_MemberAssignment_t *assignment);</span>
<span class="s1">typedef struct rd_kafka_DeleteGroup_s rd_kafka_DeleteGroup_t;</span>
<span class="s1">rd_kafka_DeleteGroup_t *rd_kafka_DeleteGroup_new(const char *group);</span>
<span class="s1">void rd_kafka_DeleteGroup_destroy(rd_kafka_DeleteGroup_t *del_group);</span>
<span class="s1">void rd_kafka_DeleteGroup_destroy_array(rd_kafka_DeleteGroup_t **del_groups, size_t del_group_cnt);</span>
<span class="s1">void rd_kafka_DeleteGroups(rd_kafka_t *rk, rd_kafka_DeleteGroup_t **del_groups, size_t del_group_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_group_result_t **rd_kafka_DeleteGroups_result_groups(const rd_kafka_DeleteGroups_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_ListConsumerGroupOffsets_s rd_kafka_ListConsumerGroupOffsets_t;</span>
<span class="s1">rd_kafka_ListConsumerGroupOffsets_t *rd_kafka_ListConsumerGroupOffsets_new(const char *group_id, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">void rd_kafka_ListConsumerGroupOffsets_destroy(rd_kafka_ListConsumerGroupOffsets_t *list_grpoffsets);</span>
<span class="s1">void rd_kafka_ListConsumerGroupOffsets_destroy_array(rd_kafka_ListConsumerGroupOffsets_t **list_grpoffsets, size_t list_grpoffset_cnt);</span>
<span class="s1">void rd_kafka_ListConsumerGroupOffsets(rd_kafka_t *rk, rd_kafka_ListConsumerGroupOffsets_t **list_grpoffsets, size_t list_grpoffsets_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_group_result_t **rd_kafka_ListConsumerGroupOffsets_result_groups(const rd_kafka_ListConsumerGroupOffsets_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_AlterConsumerGroupOffsets_s rd_kafka_AlterConsumerGroupOffsets_t;</span>
<span class="s1">rd_kafka_AlterConsumerGroupOffsets_t *rd_kafka_AlterConsumerGroupOffsets_new(const char *group_id, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">void rd_kafka_AlterConsumerGroupOffsets_destroy(rd_kafka_AlterConsumerGroupOffsets_t *alter_grpoffsets);</span>
<span class="s1">void rd_kafka_AlterConsumerGroupOffsets_destroy_array(rd_kafka_AlterConsumerGroupOffsets_t **alter_grpoffsets, size_t alter_grpoffset_cnt);</span>
<span class="s1">void rd_kafka_AlterConsumerGroupOffsets(rd_kafka_t *rk, rd_kafka_AlterConsumerGroupOffsets_t **alter_grpoffsets, size_t alter_grpoffsets_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_group_result_t **rd_kafka_AlterConsumerGroupOffsets_result_groups(const rd_kafka_AlterConsumerGroupOffsets_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_DeleteConsumerGroupOffsets_s rd_kafka_DeleteConsumerGroupOffsets_t;</span>
<span class="s1">rd_kafka_DeleteConsumerGroupOffsets_t *rd_kafka_DeleteConsumerGroupOffsets_new(const char *group, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">void rd_kafka_DeleteConsumerGroupOffsets_destroy(rd_kafka_DeleteConsumerGroupOffsets_t *del_grpoffsets);</span>
<span class="s1">void rd_kafka_DeleteConsumerGroupOffsets_destroy_array(rd_kafka_DeleteConsumerGroupOffsets_t **del_grpoffsets, size_t del_grpoffset_cnt);</span>
<span class="s1">void rd_kafka_DeleteConsumerGroupOffsets(rd_kafka_t *rk, rd_kafka_DeleteConsumerGroupOffsets_t **del_grpoffsets, size_t del_grpoffsets_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_group_result_t **rd_kafka_DeleteConsumerGroupOffsets_result_groups(const rd_kafka_DeleteConsumerGroupOffsets_result_t *result, size_t *cntp);</span>
<span class="s1">typedef enum rd_kafka_OffsetSpec_t {</span>
<span class="s1">  RD_KAFKA_OFFSET_SPEC_MAX_TIMESTAMP = (- 3),</span>
<span class="s1">  RD_KAFKA_OFFSET_SPEC_EARLIEST = (- 2),</span>
<span class="s1">  RD_KAFKA_OFFSET_SPEC_LATEST = (- 1),</span>
<span class="s1">} rd_kafka_OffsetSpec_t;</span>
<span class="s1">typedef struct rd_kafka_ListOffsetsResultInfo_s rd_kafka_ListOffsetsResultInfo_t;</span>
<span class="s1">const rd_kafka_topic_partition_t *rd_kafka_ListOffsetsResultInfo_topic_partition(const rd_kafka_ListOffsetsResultInfo_t *result_info);</span>
<span class="s1">int64_t rd_kafka_ListOffsetsResultInfo_timestamp(const rd_kafka_ListOffsetsResultInfo_t *result_info);</span>
<span class="s1">const rd_kafka_ListOffsetsResultInfo_t **rd_kafka_ListOffsets_result_infos(const rd_kafka_ListOffsets_result_t *result, size_t *cntp);</span>
<span class="s1">void rd_kafka_ListOffsets(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *topic_partitions, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">typedef enum rd_kafka_ScramMechanism_t {</span>
<span class="s1">  RD_KAFKA_SCRAM_MECHANISM_UNKNOWN = 0,</span>
<span class="s1">  RD_KAFKA_SCRAM_MECHANISM_SHA_256 = 1,</span>
<span class="s1">  RD_KAFKA_SCRAM_MECHANISM_SHA_512 = 2,</span>
<span class="s1">  RD_KAFKA_SCRAM_MECHANISM__CNT,</span>
<span class="s1">} rd_kafka_ScramMechanism_t;</span>
<span class="s1">typedef struct rd_kafka_ScramCredentialInfo_s rd_kafka_ScramCredentialInfo_t;</span>
<span class="s1">rd_kafka_ScramMechanism_t rd_kafka_ScramCredentialInfo_mechanism(const rd_kafka_ScramCredentialInfo_t *scram_credential_info);</span>
<span class="s1">int32_t rd_kafka_ScramCredentialInfo_iterations(const rd_kafka_ScramCredentialInfo_t *scram_credential_info);</span>
<span class="s1">typedef struct rd_kafka_UserScramCredentialsDescription_s rd_kafka_UserScramCredentialsDescription_t;</span>
<span class="s1">const char *rd_kafka_UserScramCredentialsDescription_user(const rd_kafka_UserScramCredentialsDescription_t *description);</span>
<span class="s1">const rd_kafka_error_t *rd_kafka_UserScramCredentialsDescription_error(const rd_kafka_UserScramCredentialsDescription_t *description);</span>
<span class="s1">size_t rd_kafka_UserScramCredentialsDescription_scramcredentialinfo_count(const rd_kafka_UserScramCredentialsDescription_t *description);</span>
<span class="s1">const rd_kafka_ScramCredentialInfo_t *rd_kafka_UserScramCredentialsDescription_scramcredentialinfo(const rd_kafka_UserScramCredentialsDescription_t *description, size_t idx);</span>
<span class="s1">const rd_kafka_UserScramCredentialsDescription_t **rd_kafka_DescribeUserScramCredentials_result_descriptions(const rd_kafka_DescribeUserScramCredentials_result_t *result, size_t *cntp);</span>
<span class="s1">void rd_kafka_DescribeUserScramCredentials(rd_kafka_t *rk, const char **users, size_t user_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">typedef struct rd_kafka_UserScramCredentialAlteration_s rd_kafka_UserScramCredentialAlteration_t;</span>
<span class="s1">rd_kafka_UserScramCredentialAlteration_t *rd_kafka_UserScramCredentialUpsertion_new(const char *username, rd_kafka_ScramMechanism_t mechanism, int32_t iterations, const unsigned char *password, size_t password_size, const unsigned char *salt, size_t salt_size);</span>
<span class="s1">rd_kafka_UserScramCredentialAlteration_t *rd_kafka_UserScramCredentialDeletion_new(const char *username, rd_kafka_ScramMechanism_t mechanism);</span>
<span class="s1">void rd_kafka_UserScramCredentialAlteration_destroy(rd_kafka_UserScramCredentialAlteration_t *alteration);</span>
<span class="s1">void rd_kafka_UserScramCredentialAlteration_destroy_array(rd_kafka_UserScramCredentialAlteration_t **alterations, size_t alteration_cnt);</span>
<span class="s1">typedef struct rd_kafka_AlterUserScramCredentials_result_response_s rd_kafka_AlterUserScramCredentials_result_response_t;</span>
<span class="s1">const char *rd_kafka_AlterUserScramCredentials_result_response_user(const rd_kafka_AlterUserScramCredentials_result_response_t *response);</span>
<span class="s1">const rd_kafka_error_t *rd_kafka_AlterUserScramCredentials_result_response_error(const rd_kafka_AlterUserScramCredentials_result_response_t *response);</span>
<span class="s1">const rd_kafka_AlterUserScramCredentials_result_response_t **rd_kafka_AlterUserScramCredentials_result_responses(const rd_kafka_AlterUserScramCredentials_result_t *result, size_t *cntp);</span>
<span class="s1">void rd_kafka_AlterUserScramCredentials(rd_kafka_t *rk, rd_kafka_UserScramCredentialAlteration_t **alterations, size_t alteration_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">typedef struct rd_kafka_AclBinding_s rd_kafka_AclBinding_t;</span>
<span class="s1">typedef rd_kafka_AclBinding_t rd_kafka_AclBindingFilter_t;</span>
<span class="s1">const rd_kafka_error_t *rd_kafka_acl_result_error(const rd_kafka_acl_result_t *aclres);</span>
<span class="s1">const char *rd_kafka_AclOperation_name(rd_kafka_AclOperation_t acl_operation);</span>
<span class="s1">typedef enum rd_kafka_AclPermissionType_t {</span>
<span class="s1">  RD_KAFKA_ACL_PERMISSION_TYPE_UNKNOWN = 0,</span>
<span class="s1">  RD_KAFKA_ACL_PERMISSION_TYPE_ANY = 1,</span>
<span class="s1">  RD_KAFKA_ACL_PERMISSION_TYPE_DENY = 2,</span>
<span class="s1">  RD_KAFKA_ACL_PERMISSION_TYPE_ALLOW = 3,</span>
<span class="s1">  RD_KAFKA_ACL_PERMISSION_TYPE__CNT,</span>
<span class="s1">} rd_kafka_AclPermissionType_t;</span>
<span class="s1">const char *rd_kafka_AclPermissionType_name(rd_kafka_AclPermissionType_t acl_permission_type);</span>
<span class="s1">rd_kafka_AclBinding_t *rd_kafka_AclBinding_new(rd_kafka_ResourceType_t restype, const char *name, rd_kafka_ResourcePatternType_t resource_pattern_type, const char *principal, const char *host, rd_kafka_AclOperation_t operation, rd_kafka_AclPermissionType_t permission_type, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_AclBindingFilter_t *rd_kafka_AclBindingFilter_new(rd_kafka_ResourceType_t restype, const char *name, rd_kafka_ResourcePatternType_t resource_pattern_type, const char *principal, const char *host, rd_kafka_AclOperation_t operation, rd_kafka_AclPermissionType_t permission_type, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_ResourceType_t rd_kafka_AclBinding_restype(const rd_kafka_AclBinding_t *acl);</span>
<span class="s1">const char *rd_kafka_AclBinding_name(const rd_kafka_AclBinding_t *acl);</span>
<span class="s1">const char *rd_kafka_AclBinding_principal(const rd_kafka_AclBinding_t *acl);</span>
<span class="s1">const char *rd_kafka_AclBinding_host(const rd_kafka_AclBinding_t *acl);</span>
<span class="s1">rd_kafka_AclOperation_t rd_kafka_AclBinding_operation(const rd_kafka_AclBinding_t *acl);</span>
<span class="s1">rd_kafka_AclPermissionType_t rd_kafka_AclBinding_permission_type(const rd_kafka_AclBinding_t *acl);</span>
<span class="s1">rd_kafka_ResourcePatternType_t rd_kafka_AclBinding_resource_pattern_type(const rd_kafka_AclBinding_t *acl);</span>
<span class="s1">const rd_kafka_error_t *rd_kafka_AclBinding_error(const rd_kafka_AclBinding_t *acl);</span>
<span class="s1">void rd_kafka_AclBinding_destroy(rd_kafka_AclBinding_t *acl_binding);</span>
<span class="s1">void rd_kafka_AclBinding_destroy_array(rd_kafka_AclBinding_t **acl_bindings, size_t acl_bindings_cnt);</span>
<span class="s1">const rd_kafka_acl_result_t **rd_kafka_CreateAcls_result_acls(const rd_kafka_CreateAcls_result_t *result, size_t *cntp);</span>
<span class="s1">void rd_kafka_CreateAcls(rd_kafka_t *rk, rd_kafka_AclBinding_t **new_acls, size_t new_acls_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_AclBinding_t **rd_kafka_DescribeAcls_result_acls(const rd_kafka_DescribeAcls_result_t *result, size_t *cntp);</span>
<span class="s1">void rd_kafka_DescribeAcls(rd_kafka_t *rk, rd_kafka_AclBindingFilter_t *acl_filter, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">typedef struct rd_kafka_DeleteAcls_result_response_s rd_kafka_DeleteAcls_result_response_t;</span>
<span class="s1">const rd_kafka_DeleteAcls_result_response_t **rd_kafka_DeleteAcls_result_responses(const rd_kafka_DeleteAcls_result_t *result, size_t *cntp);</span>
<span class="s1">const rd_kafka_error_t *rd_kafka_DeleteAcls_result_response_error(const rd_kafka_DeleteAcls_result_response_t *result_response);</span>
<span class="s1">const rd_kafka_AclBinding_t **rd_kafka_DeleteAcls_result_response_matching_acls(const rd_kafka_DeleteAcls_result_response_t *result_response, size_t *matching_acls_cntp);</span>
<span class="s1">void rd_kafka_DeleteAcls(rd_kafka_t *rk, rd_kafka_AclBindingFilter_t **del_acls, size_t del_acls_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">typedef struct rd_kafka_ElectLeaders_s rd_kafka_ElectLeaders_t;</span>
<span class="s1">typedef enum rd_kafka_ElectionType_t {</span>
<span class="s1">  RD_KAFKA_ELECTION_TYPE_PREFERRED = 0,</span>
<span class="s1">  RD_KAFKA_ELECTION_TYPE_UNCLEAN = 1,</span>
<span class="s1">} rd_kafka_ElectionType_t;</span>
<span class="s1">rd_kafka_ElectLeaders_t *rd_kafka_ElectLeaders_new(rd_kafka_ElectionType_t election_type, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">void rd_kafka_ElectLeaders_destroy(rd_kafka_ElectLeaders_t *elect_leaders);</span>
<span class="s1">void rd_kafka_ElectLeaders(rd_kafka_t *rk, rd_kafka_ElectLeaders_t *elect_leaders, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_partition_result_t **rd_kafka_ElectLeaders_result_partitions(const rd_kafka_ElectLeaders_result_t *result, size_t *cntp);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token(rd_kafka_t *rk, const char *token_value, int64_t md_lifetime_ms, const char *md_principal_name, const char **extensions, size_t extension_size, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token_failure(rd_kafka_t *rk, const char *errstr);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_init_transactions(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_begin_transaction(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_send_offsets_to_transaction(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, const rd_kafka_consumer_group_metadata_t *cgmetadata, int timeout_ms);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_commit_transaction(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_abort_transaction(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">typedef struct rd_kafka_mock_cluster_s rd_kafka_mock_cluster_t;</span>
<span class="s1">rd_kafka_mock_cluster_t *rd_kafka_mock_cluster_new(rd_kafka_t *rk, int broker_cnt);</span>
<span class="s1">void rd_kafka_mock_cluster_destroy(rd_kafka_mock_cluster_t *mcluster);</span>
<span class="s1">rd_kafka_t *rd_kafka_mock_cluster_handle(const rd_kafka_mock_cluster_t *mcluster);</span>
<span class="s1">rd_kafka_mock_cluster_t *rd_kafka_handle_mock_cluster(const rd_kafka_t *rk);</span>
<span class="s1">const char *rd_kafka_mock_cluster_bootstraps(const rd_kafka_mock_cluster_t *mcluster);</span>
<span class="s1">void rd_kafka_mock_clear_request_errors(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey);</span>
<span class="s1">void rd_kafka_mock_push_request_errors(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, size_t cnt, ...);</span>
<span class="s1">void rd_kafka_mock_push_request_errors_array(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, size_t cnt, const rd_kafka_resp_err_t *errors);</span>
<span class="s1">void rd_kafka_mock_group_initial_rebalance_delay_ms(rd_kafka_mock_cluster_t *mcluster, int32_t delay_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_push_request_error_rtts(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int16_t ApiKey, size_t cnt, ...);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_error_stack_cnt(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int16_t ApiKey, size_t *cntp);</span>
<span class="s1">void rd_kafka_mock_topic_set_error(rd_kafka_mock_cluster_t *mcluster, const char *topic, rd_kafka_resp_err_t err);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_topic_create(rd_kafka_mock_cluster_t *mcluster, const char *topic, int partition_cnt, int replication_factor);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_partition_set_leader(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_partition_set_follower(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_partition_set_follower_wmarks(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int64_t lo, int64_t hi);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_partition_push_leader_response(rd_kafka_mock_cluster_t *mcluster, const char *topic, int partition, int32_t leader_id, int32_t leader_epoch);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_set_down(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_set_up(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_set_rtt(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int rtt_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_set_rack(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, const char *rack);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_coordinator_set(rd_kafka_mock_cluster_t *mcluster, const char *key_type, const char *key, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_set_apiversion(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, int16_t MinVersion, int16_t MaxVersion);</span>
<span class="s1">void rd_kafka_mock_start_request_tracking(rd_kafka_mock_cluster_t *mcluster);</span>
<span class="s1">void rd_kafka_mock_stop_request_tracking(rd_kafka_mock_cluster_t *mcluster);</span>
<span class="s1">typedef struct rd_kafka_mock_request_s rd_kafka_mock_request_t;</span>
<span class="s1">void rd_kafka_mock_request_destroy(rd_kafka_mock_request_t *mreq);</span>
<span class="s1">void rd_kafka_mock_request_destroy_array(rd_kafka_mock_request_t **mreqs, size_t mreq_cnt);</span>
<span class="s1">int32_t rd_kafka_mock_request_id(rd_kafka_mock_request_t *mreq);</span>
<span class="s1">int16_t rd_kafka_mock_request_api_key(rd_kafka_mock_request_t *mreq);</span>
<span class="s1">int64_t rd_kafka_mock_request_timestamp(rd_kafka_mock_request_t *mreq);</span>
<span class="s1">rd_kafka_mock_request_t **rd_kafka_mock_get_requests(rd_kafka_mock_cluster_t *mcluster, size_t *cntp);</span>
<span class="s1">void rd_kafka_mock_clear_requests(rd_kafka_mock_cluster_t *mcluster);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_telemetry_set_requested_metrics(rd_kafka_mock_cluster_t *mcluster, char **metrics, size_t metrics_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_telemetry_set_push_interval(rd_kafka_mock_cluster_t *mcluster, int64_t push_interval_ms);</span>
<span class="s1">&#39;</span>
</code></pre></div>
rdkafka.h, rdkafka_mock.h</p>
<h3 id="rd_kafka_version_35">RD_KAFKA_VERSION<a class="headerlink" href="#rd_kafka_version_35" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_VERSION</span> <span class="o">=</span> <span class="mi">34078975</span>
</code></pre></div>
<p>librdkafka version </p>
<p>Interpreted as hex <code>MM.mm.rr.xx</code>:</p>
<ul>
<li>MM = Major</li>
<li>mm = minor</li>
<li>rr = revision</li>
<li>xx = pre-release id (0xff is the final release)</li>
</ul>
<p>E.g.: <code>0x000801ff</code> = 0.8.1</p>
<dl class="section remark"><dt>Remarks</dt><dd>This value should only be used during compile time, for runtime checks of version use rd_kafka_version() </dd></dl>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_unsupported_compression_type_35">RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE<a class="headerlink" href="#rd_kafka_resp_err_unsupported_compression_type_35" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE</span> <span class="o">=</span> <span class="mi">76</span>
</code></pre></div>
<p>Unsupported compression type </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_end_all_35">RD_KAFKA_RESP_ERR_END_ALL<a class="headerlink" href="#rd_kafka_resp_err_end_all_35" title="Permanent link">&para;</a></h3>
<p><div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_END_ALL</span> <span class="o">=</span> <span class="mi">119</span>
</code></pre></div>
enum rd_kafka_resp_err_t</p>
<h3 id="rd_kafka_admin_op__cnt_35">RD_KAFKA_ADMIN_OP__CNT<a class="headerlink" href="#rd_kafka_admin_op__cnt_35" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_ADMIN_OP__CNT</span> <span class="o">=</span> <span class="mi">23</span>
</code></pre></div>
<p>Number of ops defined </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#a8041b7c45068283d95f54ee14c7362fe </a></li>
</ul>
</div>
<h3 id="rd_kafka_resource__cnt_35">RD_KAFKA_RESOURCE__CNT<a class="headerlink" href="#rd_kafka_resource__cnt_35" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESOURCE__CNT</span> <span class="o">=</span> <span class="mi">6</span>
</code></pre></div>
<p>Number of resource types defined </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#acca83a66d7783ff7683ed2691cc907c9"> https://docs.confluent.io/platform/current/clients/librdkafka/html/rdkafka_8h.html#acca83a66d7783ff7683ed2691cc907c9 </a></li>
</ul>
</div>
<h3 id="rd_kafka_cdef_35">RD_KAFKA_CDEF<a class="headerlink" href="#rd_kafka_cdef_35" title="Permanent link">&para;</a></h3>
<p><div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_CDEF</span> <span class="o">=</span> <span class="s1">&#39;typedef long int ssize_t;</span>
<span class="s1">typedef struct _IO_FILE FILE;</span>
<span class="s1">typedef long int mode_t;</span>
<span class="s1">typedef signed int int16_t;</span>
<span class="s1">typedef unsigned int uint16_t;</span>
<span class="s1">typedef signed int int32_t;</span>
<span class="s1">typedef signed long int int64_t;</span>
<span class="s1">int rd_kafka_version(void);</span>
<span class="s1">const char *rd_kafka_version_str(void);</span>
<span class="s1">typedef enum rd_kafka_type_t {</span>
<span class="s1">  RD_KAFKA_PRODUCER,</span>
<span class="s1">  RD_KAFKA_CONSUMER,</span>
<span class="s1">} rd_kafka_type_t;</span>
<span class="s1">typedef enum rd_kafka_timestamp_type_t {</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_NOT_AVAILABLE,</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_CREATE_TIME,</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_LOG_APPEND_TIME,</span>
<span class="s1">} rd_kafka_timestamp_type_t;</span>
<span class="s1">const char *rd_kafka_get_debug_contexts(void);</span>
<span class="s1">typedef struct rd_kafka_s rd_kafka_t;</span>
<span class="s1">typedef struct rd_kafka_topic_s rd_kafka_topic_t;</span>
<span class="s1">typedef struct rd_kafka_conf_s rd_kafka_conf_t;</span>
<span class="s1">typedef struct rd_kafka_topic_conf_s rd_kafka_topic_conf_t;</span>
<span class="s1">typedef struct rd_kafka_queue_s rd_kafka_queue_t;</span>
<span class="s1">typedef struct rd_kafka_op_s rd_kafka_event_t;</span>
<span class="s1">typedef struct rd_kafka_topic_result_s rd_kafka_topic_result_t;</span>
<span class="s1">typedef struct rd_kafka_consumer_group_metadata_s rd_kafka_consumer_group_metadata_t;</span>
<span class="s1">typedef struct rd_kafka_error_s {</span>
<span class="s1">  unsigned int code;</span>
<span class="s1">  char *errstr;</span>
<span class="s1">  unsigned char fatal;</span>
<span class="s1">  unsigned char retriable;</span>
<span class="s1">  unsigned char txn_requires_abort;</span>
<span class="s1">} rd_kafka_error_t;</span>
<span class="s1">typedef struct rd_kafka_headers_s rd_kafka_headers_t;</span>
<span class="s1">typedef struct rd_kafka_group_result_s rd_kafka_group_result_t;</span>
<span class="s1">typedef struct rd_kafka_acl_result_s rd_kafka_acl_result_t;</span>
<span class="s1">typedef struct rd_kafka_Uuid_s rd_kafka_Uuid_t;</span>
<span class="s1">typedef struct rd_kafka_topic_partition_result_s rd_kafka_topic_partition_result_t;</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BEGIN = (- 200),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BAD_MSG = (- 199),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BAD_COMPRESSION = (- 198),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__DESTROY = (- 197),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FAIL = (- 196),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TRANSPORT = (- 195),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__CRIT_SYS_RESOURCE = (- 194),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__RESOLVE = (- 193),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__MSG_TIMED_OUT = (- 192),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PARTITION_EOF = (- 191),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION = (- 190),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FS = (- 189),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC = (- 188),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ALL_BROKERS_DOWN = (- 187),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INVALID_ARG = (- 186),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TIMED_OUT = (- 185),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__QUEUE_FULL = (- 184),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ISR_INSUFF = (- 183),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NODE_UPDATE = (- 182),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__SSL = (- 181),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__WAIT_COORD = (- 180),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_GROUP = (- 179),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__IN_PROGRESS = (- 178),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PREV_IN_PROGRESS = (- 177),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__EXISTING_SUBSCRIPTION = (- 176),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS = (- 175),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS = (- 174),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__CONFLICT = (- 173),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__STATE = (- 172),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_PROTOCOL = (- 171),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED = (- 170),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__AUTHENTICATION = (- 169),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NO_OFFSET = (- 168),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__OUTDATED = (- 167),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TIMED_OUT_QUEUE = (- 166),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNSUPPORTED_FEATURE = (- 165),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__WAIT_CACHE = (- 164),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INTR = (- 163),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__KEY_SERIALIZATION = (- 162),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__VALUE_SERIALIZATION = (- 161),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__KEY_DESERIALIZATION = (- 160),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__VALUE_DESERIALIZATION = (- 159),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PARTIAL = (- 158),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__READ_ONLY = (- 157),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOENT = (- 156),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNDERFLOW = (- 155),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INVALID_TYPE = (- 154),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__RETRY = (- 153),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PURGE_QUEUE = (- 152),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PURGE_INFLIGHT = (- 151),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FATAL = (- 150),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INCONSISTENT = (- 149),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__GAPLESS_GUARANTEE = (- 148),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__MAX_POLL_EXCEEDED = (- 147),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_BROKER = (- 146),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOT_CONFIGURED = (- 145),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FENCED = (- 144),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__APPLICATION = (- 143),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ASSIGNMENT_LOST = (- 142),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOOP = (- 141),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__AUTO_OFFSET_RESET = (- 140),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__LOG_TRUNCATION = (- 139),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INVALID_DIFFERENT_RECORD = (- 138),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__END = (- 100),</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN = (- 1),</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NO_ERROR = 0,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_OUT_OF_RANGE = 1,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_MSG = 2,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART = 3,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_MSG_SIZE = 4,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE = 5,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_LEADER_FOR_PARTITION = 6,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REQUEST_TIMED_OUT = 7,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_BROKER_NOT_AVAILABLE = 8,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REPLICA_NOT_AVAILABLE = 9,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE = 10,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_STALE_CTRL_EPOCH = 11,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_METADATA_TOO_LARGE = 12,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NETWORK_EXCEPTION = 13,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_COORDINATOR_LOAD_IN_PROGRESS = 14,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_COORDINATOR_NOT_AVAILABLE = 15,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_COORDINATOR = 16,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_EXCEPTION = 17,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_RECORD_LIST_TOO_LARGE = 18,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS = 19,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS_AFTER_APPEND = 20,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REQUIRED_ACKS = 21,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ILLEGAL_GENERATION = 22,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INCONSISTENT_GROUP_PROTOCOL = 23,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_GROUP_ID = 24,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_MEMBER_ID = 25,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_SESSION_TIMEOUT = 26,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REBALANCE_IN_PROGRESS = 27,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_COMMIT_OFFSET_SIZE = 28,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_AUTHORIZATION_FAILED = 29,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_AUTHORIZATION_FAILED = 30,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_CLUSTER_AUTHORIZATION_FAILED = 31,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TIMESTAMP = 32,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_SASL_MECHANISM = 33,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ILLEGAL_SASL_STATE = 34,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_VERSION = 35,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_ALREADY_EXISTS = 36,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PARTITIONS = 37,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REPLICATION_FACTOR = 38,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REPLICA_ASSIGNMENT = 39,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_CONFIG = 40,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_CONTROLLER = 41,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REQUEST = 42,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_FOR_MESSAGE_FORMAT = 43,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_POLICY_VIOLATION = 44,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OUT_OF_ORDER_SEQUENCE_NUMBER = 45,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DUPLICATE_SEQUENCE_NUMBER = 46,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_EPOCH = 47,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TXN_STATE = 48,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_ID_MAPPING = 49,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TRANSACTION_TIMEOUT = 50,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_CONCURRENT_TRANSACTIONS = 51,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TRANSACTION_COORDINATOR_FENCED = 52,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TRANSACTIONAL_ID_AUTHORIZATION_FAILED = 53,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_SECURITY_DISABLED = 54,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OPERATION_NOT_ATTEMPTED = 55,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_KAFKA_STORAGE_ERROR = 56,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LOG_DIR_NOT_FOUND = 57,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_SASL_AUTHENTICATION_FAILED = 58,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_PRODUCER_ID = 59,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REASSIGNMENT_IN_PROGRESS = 60,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTH_DISABLED = 61,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_NOT_FOUND = 62,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_OWNER_MISMATCH = 63,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_REQUEST_NOT_ALLOWED = 64,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTHORIZATION_FAILED = 65,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_EXPIRED = 66,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRINCIPAL_TYPE = 67,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NON_EMPTY_GROUP = 68,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_ID_NOT_FOUND = 69,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FETCH_SESSION_ID_NOT_FOUND = 70,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_FETCH_SESSION_EPOCH = 71,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LISTENER_NOT_FOUND = 72,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_DELETION_DISABLED = 73,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FENCED_LEADER_EPOCH = 74,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_LEADER_EPOCH = 75,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_STALE_BROKER_EPOCH = 77,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_NOT_AVAILABLE = 78,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_MEMBER_ID_REQUIRED = 79,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_PREFERRED_LEADER_NOT_AVAILABLE = 80,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_MAX_SIZE_REACHED = 81,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FENCED_INSTANCE_ID = 82,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ELIGIBLE_LEADERS_NOT_AVAILABLE = 83,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ELECTION_NOT_NEEDED = 84,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NO_REASSIGNMENT_IN_PROGRESS = 85,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_SUBSCRIBED_TO_TOPIC = 86,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_RECORD = 87,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSTABLE_OFFSET_COMMIT = 88,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_THROTTLING_QUOTA_EXCEEDED = 89,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_PRODUCER_FENCED = 90,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_RESOURCE_NOT_FOUND = 91,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DUPLICATE_RESOURCE = 92,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNACCEPTABLE_CREDENTIAL = 93,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INCONSISTENT_VOTER_SET = 94,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_UPDATE_VERSION = 95,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FEATURE_UPDATE_FAILED = 96,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_PRINCIPAL_DESERIALIZATION_FAILURE = 97,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_ID = 100,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FENCED_MEMBER_EPOCH = 110,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNRELEASED_INSTANCE_ID = 111,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_ASSIGNOR = 112,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_STALE_MEMBER_EPOCH = 113,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_SUBSCRIPTION_ID = 117,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TELEMETRY_TOO_LARGE = 118,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_END_ALL,</span>
<span class="s1">} rd_kafka_resp_err_t;</span>
<span class="s1">struct rd_kafka_err_desc {</span>
<span class="s1">  rd_kafka_resp_err_t code;</span>
<span class="s1">  char *name;</span>
<span class="s1">  char *desc;</span>
<span class="s1">};</span>
<span class="s1">void rd_kafka_get_err_descs(const struct rd_kafka_err_desc **errdescs, size_t *cntp);</span>
<span class="s1">const char *rd_kafka_err2str(rd_kafka_resp_err_t err);</span>
<span class="s1">const char *rd_kafka_err2name(rd_kafka_resp_err_t err);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_last_error(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_errno2err(int errnox);</span>
<span class="s1">int rd_kafka_errno(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_fatal_error(rd_kafka_t *rk, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_test_fatal_error(rd_kafka_t *rk, rd_kafka_resp_err_t err, const char *reason);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_error_code(const rd_kafka_error_t *error);</span>
<span class="s1">const char *rd_kafka_error_name(const rd_kafka_error_t *error);</span>
<span class="s1">const char *rd_kafka_error_string(const rd_kafka_error_t *error);</span>
<span class="s1">int rd_kafka_error_is_fatal(const rd_kafka_error_t *error);</span>
<span class="s1">int rd_kafka_error_is_retriable(const rd_kafka_error_t *error);</span>
<span class="s1">int rd_kafka_error_txn_requires_abort(const rd_kafka_error_t *error);</span>
<span class="s1">void rd_kafka_error_destroy(rd_kafka_error_t *error);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_error_new(rd_kafka_resp_err_t code, const char *fmt, ...);</span>
<span class="s1">typedef struct rd_kafka_topic_partition_s {</span>
<span class="s1">  char *topic;</span>
<span class="s1">  int32_t partition;</span>
<span class="s1">  int64_t offset;</span>
<span class="s1">  void *metadata;</span>
<span class="s1">  size_t metadata_size;</span>
<span class="s1">  void *opaque;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  void *_private;</span>
<span class="s1">} rd_kafka_topic_partition_t;</span>
<span class="s1">void rd_kafka_topic_partition_destroy(rd_kafka_topic_partition_t *rktpar);</span>
<span class="s1">void rd_kafka_topic_partition_set_leader_epoch(rd_kafka_topic_partition_t *rktpar, int32_t leader_epoch);</span>
<span class="s1">int32_t rd_kafka_topic_partition_get_leader_epoch(const rd_kafka_topic_partition_t *rktpar);</span>
<span class="s1">typedef struct rd_kafka_topic_partition_list_s {</span>
<span class="s1">  int cnt;</span>
<span class="s1">  int size;</span>
<span class="s1">  rd_kafka_topic_partition_t *elems;</span>
<span class="s1">} rd_kafka_topic_partition_list_t;</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_new(int size);</span>
<span class="s1">void rd_kafka_topic_partition_list_destroy(rd_kafka_topic_partition_list_t *rkparlist);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_add(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">void rd_kafka_topic_partition_list_add_range(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t start, int32_t stop);</span>
<span class="s1">int rd_kafka_topic_partition_list_del(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">int rd_kafka_topic_partition_list_del_by_idx(rd_kafka_topic_partition_list_t *rktparlist, int idx);</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_copy(const rd_kafka_topic_partition_list_t *src);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_topic_partition_list_set_offset(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition, int64_t offset);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_find(const rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">void rd_kafka_topic_partition_list_sort(rd_kafka_topic_partition_list_t *rktparlist, int (*cmp)(const void *a, const void *b, void *cmp_opaque), void *cmp_opaque);</span>
<span class="s1">typedef enum rd_kafka_vtype_t {</span>
<span class="s1">  RD_KAFKA_VTYPE_END,</span>
<span class="s1">  RD_KAFKA_VTYPE_TOPIC,</span>
<span class="s1">  RD_KAFKA_VTYPE_RKT,</span>
<span class="s1">  RD_KAFKA_VTYPE_PARTITION,</span>
<span class="s1">  RD_KAFKA_VTYPE_VALUE,</span>
<span class="s1">  RD_KAFKA_VTYPE_KEY,</span>
<span class="s1">  RD_KAFKA_VTYPE_OPAQUE,</span>
<span class="s1">  RD_KAFKA_VTYPE_MSGFLAGS,</span>
<span class="s1">  RD_KAFKA_VTYPE_TIMESTAMP,</span>
<span class="s1">  RD_KAFKA_VTYPE_HEADER,</span>
<span class="s1">  RD_KAFKA_VTYPE_HEADERS,</span>
<span class="s1">} rd_kafka_vtype_t;</span>
<span class="s1">typedef struct rd_kafka_vu_s {</span>
<span class="s1">  rd_kafka_vtype_t vtype;</span>
<span class="s1">  union {</span>
<span class="s1">    char *cstr;</span>
<span class="s1">    rd_kafka_topic_t *rkt;</span>
<span class="s1">    int i;</span>
<span class="s1">    int32_t i32;</span>
<span class="s1">    int64_t i64;</span>
<span class="s1">    struct {</span>
<span class="s1">      void *ptr;</span>
<span class="s1">      size_t size;</span>
<span class="s1">    } mem;</span>
<span class="s1">    struct {</span>
<span class="s1">      char *name;</span>
<span class="s1">      void *val;</span>
<span class="s1">      ssize_t size;</span>
<span class="s1">    } header;</span>
<span class="s1">    rd_kafka_headers_t *headers;</span>
<span class="s1">    void *ptr;</span>
<span class="s1">    char _pad[64];</span>
<span class="s1">  } u;</span>
<span class="s1">} rd_kafka_vu_t;</span>
<span class="s1">rd_kafka_headers_t *rd_kafka_headers_new(size_t initial_count);</span>
<span class="s1">void rd_kafka_headers_destroy(rd_kafka_headers_t *hdrs);</span>
<span class="s1">rd_kafka_headers_t *rd_kafka_headers_copy(const rd_kafka_headers_t *src);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_add(rd_kafka_headers_t *hdrs, const char *name, ssize_t name_size, const void *value, ssize_t value_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_remove(rd_kafka_headers_t *hdrs, const char *name);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get_last(const rd_kafka_headers_t *hdrs, const char *name, const void **valuep, size_t *sizep);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get(const rd_kafka_headers_t *hdrs, size_t idx, const char *name, const void **valuep, size_t *sizep);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get_all(const rd_kafka_headers_t *hdrs, size_t idx, const char **namep, const void **valuep, size_t *sizep);</span>
<span class="s1">typedef struct rd_kafka_message_s {</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  rd_kafka_topic_t *rkt;</span>
<span class="s1">  int32_t partition;</span>
<span class="s1">  void *payload;</span>
<span class="s1">  size_t len;</span>
<span class="s1">  void *key;</span>
<span class="s1">  size_t key_len;</span>
<span class="s1">  int64_t offset;</span>
<span class="s1">  void *_private;</span>
<span class="s1">} rd_kafka_message_t;</span>
<span class="s1">void rd_kafka_message_destroy(rd_kafka_message_t *rkmessage);</span>
<span class="s1">const char *rd_kafka_message_errstr(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">const char *rd_kafka_message_produce_errstr(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">int64_t rd_kafka_message_timestamp(const rd_kafka_message_t *rkmessage, rd_kafka_timestamp_type_t *tstype);</span>
<span class="s1">int64_t rd_kafka_message_latency(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">int32_t rd_kafka_message_broker_id(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_message_headers(const rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_message_detach_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);</span>
<span class="s1">void rd_kafka_message_set_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t *hdrs);</span>
<span class="s1">size_t rd_kafka_header_cnt(const rd_kafka_headers_t *hdrs);</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_NOT_PERSISTED = 0,</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_POSSIBLY_PERSISTED = 1,</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_PERSISTED = 2,</span>
<span class="s1">} rd_kafka_msg_status_t;</span>
<span class="s1">rd_kafka_msg_status_t rd_kafka_message_status(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">int32_t rd_kafka_message_leader_epoch(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">const char *rd_kafka_Uuid_base64str(const rd_kafka_Uuid_t *uuid);</span>
<span class="s1">int64_t rd_kafka_Uuid_least_significant_bits(const rd_kafka_Uuid_t *uuid);</span>
<span class="s1">int64_t rd_kafka_Uuid_most_significant_bits(const rd_kafka_Uuid_t *uuid);</span>
<span class="s1">rd_kafka_Uuid_t *rd_kafka_Uuid_new(int64_t most_significant_bits, int64_t least_significant_bits);</span>
<span class="s1">rd_kafka_Uuid_t *rd_kafka_Uuid_copy(const rd_kafka_Uuid_t *uuid);</span>
<span class="s1">void rd_kafka_Uuid_destroy(rd_kafka_Uuid_t *uuid);</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_CONF_UNKNOWN = (- 2),</span>
<span class="s1">  RD_KAFKA_CONF_INVALID = (- 1),</span>
<span class="s1">  RD_KAFKA_CONF_OK = 0,</span>
<span class="s1">} rd_kafka_conf_res_t;</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_new(void);</span>
<span class="s1">void rd_kafka_conf_destroy(rd_kafka_conf_t *conf);</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_dup(const rd_kafka_conf_t *conf);</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_dup_filter(const rd_kafka_conf_t *conf, size_t filter_cnt, const char **filter);</span>
<span class="s1">const rd_kafka_conf_t *rd_kafka_conf(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_set(rd_kafka_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_conf_set_events(rd_kafka_conf_t *conf, int events);</span>
<span class="s1">void rd_kafka_conf_set_background_event_cb(rd_kafka_conf_t *conf, void (*event_cb)(rd_kafka_t *rk, rd_kafka_event_t *rkev, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_dr_cb(rd_kafka_conf_t *conf, void (*dr_cb)(rd_kafka_t *rk, void *payload, size_t len, rd_kafka_resp_err_t err, void *opaque, void *msg_opaque));</span>
<span class="s1">void rd_kafka_conf_set_dr_msg_cb(rd_kafka_conf_t *conf, void (*dr_msg_cb)(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_consume_cb(rd_kafka_conf_t *conf, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_rebalance_cb(rd_kafka_conf_t *conf, void (*rebalance_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *partitions, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_offset_commit_cb(rd_kafka_conf_t *conf, void (*offset_commit_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_error_cb(rd_kafka_conf_t *conf, void (*error_cb)(rd_kafka_t *rk, int err, const char *reason, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_throttle_cb(rd_kafka_conf_t *conf, void (*throttle_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int throttle_time_ms, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_log_cb(rd_kafka_conf_t *conf, void (*log_cb)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));</span>
<span class="s1">void rd_kafka_conf_set_stats_cb(rd_kafka_conf_t *conf, int (*stats_cb)(rd_kafka_t *rk, char *json, size_t json_len, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_oauthbearer_token_refresh_cb(rd_kafka_conf_t *conf, void (*oauthbearer_token_refresh_cb)(rd_kafka_t *rk, const char *oauthbearer_config, void *opaque));</span>
<span class="s1">void rd_kafka_conf_enable_sasl_queue(rd_kafka_conf_t *conf, int enable);</span>
<span class="s1">void rd_kafka_conf_set_socket_cb(rd_kafka_conf_t *conf, int (*socket_cb)(int domain, int type, int protocol, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_connect_cb(rd_kafka_conf_t *conf, int (*connect_cb)(int sockfd, const struct sockaddr *addr, int addrlen, const char *id, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_closesocket_cb(rd_kafka_conf_t *conf, int (*closesocket_cb)(int sockfd, void *opaque));</span>
<span class="s1">struct addrinfo;</span>
<span class="s1">void rd_kafka_conf_set_resolve_cb(rd_kafka_conf_t *conf, int (*resolve_cb)(const char *node, const char *service, const struct addrinfo *hints, struct addrinfo **res, void *opaque));</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert_verify_cb(rd_kafka_conf_t *conf, int (*ssl_cert_verify_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int *x509_error, int depth, const char *buf, size_t size, char *errstr, size_t errstr_size, void *opaque));</span>
<span class="s1">typedef enum rd_kafka_cert_type_t {</span>
<span class="s1">  RD_KAFKA_CERT_PUBLIC_KEY,</span>
<span class="s1">  RD_KAFKA_CERT_PRIVATE_KEY,</span>
<span class="s1">  RD_KAFKA_CERT_CA,</span>
<span class="s1">  RD_KAFKA_CERT__CNT,</span>
<span class="s1">} rd_kafka_cert_type_t;</span>
<span class="s1">typedef enum rd_kafka_cert_enc_t {</span>
<span class="s1">  RD_KAFKA_CERT_ENC_PKCS12,</span>
<span class="s1">  RD_KAFKA_CERT_ENC_DER,</span>
<span class="s1">  RD_KAFKA_CERT_ENC_PEM,</span>
<span class="s1">  RD_KAFKA_CERT_ENC__CNT,</span>
<span class="s1">} rd_kafka_cert_enc_t;</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert(rd_kafka_conf_t *conf, rd_kafka_cert_type_t cert_type, rd_kafka_cert_enc_t cert_enc, const void *buffer, size_t size, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_conf_set_engine_callback_data(rd_kafka_conf_t *conf, void *callback_data);</span>
<span class="s1">void rd_kafka_conf_set_opaque(rd_kafka_conf_t *conf, void *opaque);</span>
<span class="s1">void *rd_kafka_opaque(const rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_conf_set_default_topic_conf(rd_kafka_conf_t *conf, rd_kafka_topic_conf_t *tconf);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_conf_get_default_topic_conf(rd_kafka_conf_t *conf);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_get(const rd_kafka_conf_t *conf, const char *name, char *dest, size_t *dest_size);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_topic_conf_get(const rd_kafka_topic_conf_t *conf, const char *name, char *dest, size_t *dest_size);</span>
<span class="s1">const char **rd_kafka_conf_dump(rd_kafka_conf_t *conf, size_t *cntp);</span>
<span class="s1">const char **rd_kafka_topic_conf_dump(rd_kafka_topic_conf_t *conf, size_t *cntp);</span>
<span class="s1">void rd_kafka_conf_dump_free(const char **arr, size_t cnt);</span>
<span class="s1">void rd_kafka_conf_properties_show(FILE *fp);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_topic_conf_new(void);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_topic_conf_dup(const rd_kafka_topic_conf_t *conf);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_default_topic_conf_dup(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_topic_conf_destroy(rd_kafka_topic_conf_t *topic_conf);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_topic_conf_set(rd_kafka_topic_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_topic_conf_set_opaque(rd_kafka_topic_conf_t *conf, void *rkt_opaque);</span>
<span class="s1">void rd_kafka_topic_conf_set_partitioner_cb(rd_kafka_topic_conf_t *topic_conf, int32_t (*partitioner)(const rd_kafka_topic_t *rkt, const void *keydata, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque));</span>
<span class="s1">void rd_kafka_topic_conf_set_msg_order_cmp(rd_kafka_topic_conf_t *topic_conf, int (*msg_order_cmp)(const rd_kafka_message_t *a, const rd_kafka_message_t *b));</span>
<span class="s1">int rd_kafka_topic_partition_available(const rd_kafka_topic_t *rkt, int32_t partition);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_consistent(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_consistent_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_murmur2(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_murmur2_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_fnv1a(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_fnv1a_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">rd_kafka_t *rd_kafka_new(rd_kafka_type_t type, rd_kafka_conf_t *conf, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_destroy(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_destroy_flags(rd_kafka_t *rk, int flags);</span>
<span class="s1">const char *rd_kafka_name(const rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_type_t rd_kafka_type(const rd_kafka_t *rk);</span>
<span class="s1">char *rd_kafka_memberid(const rd_kafka_t *rk);</span>
<span class="s1">char *rd_kafka_clusterid(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">int32_t rd_kafka_controllerid(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_topic_t *rd_kafka_topic_new(rd_kafka_t *rk, const char *topic, rd_kafka_topic_conf_t *conf);</span>
<span class="s1">void rd_kafka_topic_destroy(rd_kafka_topic_t *rkt);</span>
<span class="s1">const char *rd_kafka_topic_name(const rd_kafka_topic_t *rkt);</span>
<span class="s1">void *rd_kafka_topic_opaque(const rd_kafka_topic_t *rkt);</span>
<span class="s1">int rd_kafka_poll(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">void rd_kafka_yield(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_pause_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_resume_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_query_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_get_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offsets_for_times(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets, int timeout_ms);</span>
<span class="s1">void *rd_kafka_mem_calloc(rd_kafka_t *rk, size_t num, size_t size);</span>
<span class="s1">void *rd_kafka_mem_malloc(rd_kafka_t *rk, size_t size);</span>
<span class="s1">void rd_kafka_mem_free(rd_kafka_t *rk, void *ptr);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_new(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_queue_destroy(rd_kafka_queue_t *rkqu);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_main(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_sasl(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_sasl_background_callbacks_enable(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_sasl_set_credentials(rd_kafka_t *rk, const char *username, const char *password);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_consumer(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_partition(rd_kafka_t *rk, const char *topic, int32_t partition);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_background(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_queue_forward(rd_kafka_queue_t *src, rd_kafka_queue_t *dst);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_set_log_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu);</span>
<span class="s1">size_t rd_kafka_queue_length(rd_kafka_queue_t *rkqu);</span>
<span class="s1">void rd_kafka_queue_io_event_enable(rd_kafka_queue_t *rkqu, int fd, const void *payload, size_t size);</span>
<span class="s1">void rd_kafka_queue_cb_event_enable(rd_kafka_queue_t *rkqu, void (*event_cb)(rd_kafka_t *rk, void *qev_opaque), void *qev_opaque);</span>
<span class="s1">void rd_kafka_queue_yield(rd_kafka_queue_t *rkqu);</span>
<span class="s1">int rd_kafka_consume_start(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);</span>
<span class="s1">int rd_kafka_consume_start_queue(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, rd_kafka_queue_t *rkqu);</span>
<span class="s1">int rd_kafka_consume_stop(rd_kafka_topic_t *rkt, int32_t partition);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_seek(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, int timeout_ms);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_seek_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consume(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms);</span>
<span class="s1">ssize_t rd_kafka_consume_batch(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);</span>
<span class="s1">int rd_kafka_consume_callback(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consume_queue(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">ssize_t rd_kafka_consume_batch_queue(rd_kafka_queue_t *rkqu, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);</span>
<span class="s1">int rd_kafka_consume_callback_queue(rd_kafka_queue_t *rkqu, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offset_store(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offsets_store(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_offset_store_message(rd_kafka_message_t *rkmessage);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_subscribe(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *topics);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_unsubscribe(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_subscription(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **topics);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consumer_poll(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_consumer_close(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_consumer_close_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu);</span>
<span class="s1">int rd_kafka_consumer_closed(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_incremental_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_incremental_unassign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">const char *rd_kafka_rebalance_protocol(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_assignment(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **partitions);</span>
<span class="s1">int rd_kafka_assignment_lost(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, int async);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit_message(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, int async);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit_queue(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_queue_t *rkqu, void (*cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *commit_opaque), void *commit_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_committed(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_position(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata_new(const char *group_id);</span>
<span class="s1">rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata_new_with_genid(const char *group_id, int32_t generation_id, const char *member_id, const char *group_instance_id);</span>
<span class="s1">const char *rd_kafka_consumer_group_metadata_group_id(const rd_kafka_consumer_group_metadata_t *group_metadata);</span>
<span class="s1">const char *rd_kafka_consumer_group_metadata_group_instance_id(const rd_kafka_consumer_group_metadata_t *group_metadata);</span>
<span class="s1">const char *rd_kafka_consumer_group_metadata_member_id(const rd_kafka_consumer_group_metadata_t *group_metadata);</span>
<span class="s1">int32_t rd_kafka_consumer_group_metadata_generation_id(const rd_kafka_consumer_group_metadata_t *group_metadata);</span>
<span class="s1">void rd_kafka_consumer_group_metadata_destroy(rd_kafka_consumer_group_metadata_t *);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_consumer_group_metadata_write(const rd_kafka_consumer_group_metadata_t *cgmd, void **bufferp, size_t *sizep);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_consumer_group_metadata_read(rd_kafka_consumer_group_metadata_t **cgmdp, const void *buffer, size_t size);</span>
<span class="s1">int rd_kafka_produce(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, void *payload, size_t len, const void *key, size_t keylen, void *msg_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_producev(rd_kafka_t *rk, ...);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_produceva(rd_kafka_t *rk, const rd_kafka_vu_t *vus, size_t cnt);</span>
<span class="s1">int rd_kafka_produce_batch(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, rd_kafka_message_t *rkmessages, int message_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_flush(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_purge(rd_kafka_t *rk, int purge_flags);</span>
<span class="s1">typedef struct rd_kafka_metadata_broker {</span>
<span class="s1">  int32_t id;</span>
<span class="s1">  char *host;</span>
<span class="s1">  int port;</span>
<span class="s1">} rd_kafka_metadata_broker_t;</span>
<span class="s1">typedef struct rd_kafka_metadata_partition {</span>
<span class="s1">  int32_t id;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  int32_t leader;</span>
<span class="s1">  int replica_cnt;</span>
<span class="s1">  int32_t *replicas;</span>
<span class="s1">  int isr_cnt;</span>
<span class="s1">  int32_t *isrs;</span>
<span class="s1">} rd_kafka_metadata_partition_t;</span>
<span class="s1">typedef struct rd_kafka_metadata_topic {</span>
<span class="s1">  char *topic;</span>
<span class="s1">  int partition_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_partition *partitions;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">} rd_kafka_metadata_topic_t;</span>
<span class="s1">typedef struct rd_kafka_metadata {</span>
<span class="s1">  int broker_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_broker *brokers;</span>
<span class="s1">  int topic_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_topic *topics;</span>
<span class="s1">  int32_t orig_broker_id;</span>
<span class="s1">  char *orig_broker_name;</span>
<span class="s1">} rd_kafka_metadata_t;</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_metadata(rd_kafka_t *rk, int all_topics, rd_kafka_topic_t *only_rkt, const struct rd_kafka_metadata **metadatap, int timeout_ms);</span>
<span class="s1">void rd_kafka_metadata_destroy(const struct rd_kafka_metadata *metadata);</span>
<span class="s1">typedef struct rd_kafka_Node_s rd_kafka_Node_t;</span>
<span class="s1">int rd_kafka_Node_id(const rd_kafka_Node_t *node);</span>
<span class="s1">const char *rd_kafka_Node_host(const rd_kafka_Node_t *node);</span>
<span class="s1">uint16_t rd_kafka_Node_port(const rd_kafka_Node_t *node);</span>
<span class="s1">const char *rd_kafka_Node_rack(const rd_kafka_Node_t *node);</span>
<span class="s1">struct rd_kafka_group_member_info {</span>
<span class="s1">  char *member_id;</span>
<span class="s1">  char *client_id;</span>
<span class="s1">  char *client_host;</span>
<span class="s1">  void *member_metadata;</span>
<span class="s1">  int member_metadata_size;</span>
<span class="s1">  void *member_assignment;</span>
<span class="s1">  int member_assignment_size;</span>
<span class="s1">};</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_CONSUMER_GROUP_STATE_UNKNOWN = 0,</span>
<span class="s1">  RD_KAFKA_CONSUMER_GROUP_STATE_PREPARING_REBALANCE = 1,</span>
<span class="s1">  RD_KAFKA_CONSUMER_GROUP_STATE_COMPLETING_REBALANCE = 2,</span>
<span class="s1">  RD_KAFKA_CONSUMER_GROUP_STATE_STABLE = 3,</span>
<span class="s1">  RD_KAFKA_CONSUMER_GROUP_STATE_DEAD = 4,</span>
<span class="s1">  RD_KAFKA_CONSUMER_GROUP_STATE_EMPTY = 5,</span>
<span class="s1">  RD_KAFKA_CONSUMER_GROUP_STATE__CNT,</span>
<span class="s1">} rd_kafka_consumer_group_state_t;</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_CONSUMER_GROUP_TYPE_UNKNOWN = 0,</span>
<span class="s1">  RD_KAFKA_CONSUMER_GROUP_TYPE_CONSUMER = 1,</span>
<span class="s1">  RD_KAFKA_CONSUMER_GROUP_TYPE_CLASSIC = 2,</span>
<span class="s1">  RD_KAFKA_CONSUMER_GROUP_TYPE__CNT,</span>
<span class="s1">} rd_kafka_consumer_group_type_t;</span>
<span class="s1">struct rd_kafka_group_info {</span>
<span class="s1">  struct rd_kafka_metadata_broker broker;</span>
<span class="s1">  char *group;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  char *state;</span>
<span class="s1">  char *protocol_type;</span>
<span class="s1">  char *protocol;</span>
<span class="s1">  struct rd_kafka_group_member_info *members;</span>
<span class="s1">  int member_cnt;</span>
<span class="s1">};</span>
<span class="s1">struct rd_kafka_group_list {</span>
<span class="s1">  struct rd_kafka_group_info *groups;</span>
<span class="s1">  int group_cnt;</span>
<span class="s1">};</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_list_groups(rd_kafka_t *rk, const char *group, const struct rd_kafka_group_list **grplistp, int timeout_ms);</span>
<span class="s1">const char *rd_kafka_consumer_group_state_name(rd_kafka_consumer_group_state_t state);</span>
<span class="s1">rd_kafka_consumer_group_state_t rd_kafka_consumer_group_state_code(const char *name);</span>
<span class="s1">const char *rd_kafka_consumer_group_type_name(rd_kafka_consumer_group_type_t type);</span>
<span class="s1">rd_kafka_consumer_group_type_t rd_kafka_consumer_group_type_code(const char *name);</span>
<span class="s1">void rd_kafka_group_list_destroy(const struct rd_kafka_group_list *grplist);</span>
<span class="s1">int rd_kafka_brokers_add(rd_kafka_t *rk, const char *brokerlist);</span>
<span class="s1">void rd_kafka_set_logger(rd_kafka_t *rk, void (*func)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));</span>
<span class="s1">void rd_kafka_set_log_level(rd_kafka_t *rk, int level);</span>
<span class="s1">void rd_kafka_log_print(const rd_kafka_t *rk, int level, const char *fac, const char *buf);</span>
<span class="s1">void rd_kafka_log_syslog(const rd_kafka_t *rk, int level, const char *fac, const char *buf);</span>
<span class="s1">int rd_kafka_outq_len(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_dump(FILE *fp, rd_kafka_t *rk);</span>
<span class="s1">int rd_kafka_thread_cnt(void);</span>
<span class="s1">typedef enum rd_kafka_thread_type_t {</span>
<span class="s1">  RD_KAFKA_THREAD_MAIN,</span>
<span class="s1">  RD_KAFKA_THREAD_BACKGROUND,</span>
<span class="s1">  RD_KAFKA_THREAD_BROKER,</span>
<span class="s1">} rd_kafka_thread_type_t;</span>
<span class="s1">int rd_kafka_wait_destroyed(int timeout_ms);</span>
<span class="s1">int rd_kafka_unittest(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_poll_set_consumer(rd_kafka_t *rk);</span>
<span class="s1">typedef int rd_kafka_event_type_t;</span>
<span class="s1">rd_kafka_event_type_t rd_kafka_event_type(const rd_kafka_event_t *rkev);</span>
<span class="s1">const char *rd_kafka_event_name(const rd_kafka_event_t *rkev);</span>
<span class="s1">void rd_kafka_event_destroy(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_message_t *rd_kafka_event_message_next(rd_kafka_event_t *rkev);</span>
<span class="s1">size_t rd_kafka_event_message_array(rd_kafka_event_t *rkev, const rd_kafka_message_t **rkmessages, size_t size);</span>
<span class="s1">size_t rd_kafka_event_message_count(rd_kafka_event_t *rkev);</span>
<span class="s1">const char *rd_kafka_event_config_string(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_event_error(rd_kafka_event_t *rkev);</span>
<span class="s1">const char *rd_kafka_event_error_string(rd_kafka_event_t *rkev);</span>
<span class="s1">int rd_kafka_event_error_is_fatal(rd_kafka_event_t *rkev);</span>
<span class="s1">void *rd_kafka_event_opaque(rd_kafka_event_t *rkev);</span>
<span class="s1">int rd_kafka_event_log(rd_kafka_event_t *rkev, const char **fac, const char **str, int *level);</span>
<span class="s1">int rd_kafka_event_debug_contexts(rd_kafka_event_t *rkev, char *dst, size_t dstsize);</span>
<span class="s1">const char *rd_kafka_event_stats(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_event_topic_partition_list(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_event_topic_partition(rd_kafka_event_t *rkev);</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_CreateTopics_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DeleteTopics_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_CreateAcls_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DescribeAcls_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DeleteAcls_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_CreatePartitions_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_AlterConfigs_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_IncrementalAlterConfigs_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DescribeConfigs_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DeleteRecords_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_ListConsumerGroups_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DescribeConsumerGroups_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DeleteGroups_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DeleteConsumerGroupOffsets_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_AlterConsumerGroupOffsets_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_ListConsumerGroupOffsets_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DescribeTopics_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DescribeCluster_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DescribeUserScramCredentials_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_AlterUserScramCredentials_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_ListOffsets_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_ElectLeaders_result_t;</span>
<span class="s1">const rd_kafka_CreateTopics_result_t *rd_kafka_event_CreateTopics_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DeleteTopics_result_t *rd_kafka_event_DeleteTopics_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_CreatePartitions_result_t *rd_kafka_event_CreatePartitions_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_AlterConfigs_result_t *rd_kafka_event_AlterConfigs_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_IncrementalAlterConfigs_result_t *rd_kafka_event_IncrementalAlterConfigs_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DescribeConfigs_result_t *rd_kafka_event_DescribeConfigs_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DeleteRecords_result_t *rd_kafka_event_DeleteRecords_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_ListConsumerGroups_result_t *rd_kafka_event_ListConsumerGroups_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DescribeConsumerGroups_result_t *rd_kafka_event_DescribeConsumerGroups_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DescribeTopics_result_t *rd_kafka_event_DescribeTopics_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DescribeCluster_result_t *rd_kafka_event_DescribeCluster_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DeleteGroups_result_t *rd_kafka_event_DeleteGroups_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DeleteConsumerGroupOffsets_result_t *rd_kafka_event_DeleteConsumerGroupOffsets_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_CreateAcls_result_t *rd_kafka_event_CreateAcls_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DescribeAcls_result_t *rd_kafka_event_DescribeAcls_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DeleteAcls_result_t *rd_kafka_event_DeleteAcls_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_ListConsumerGroupOffsets_result_t *rd_kafka_event_ListConsumerGroupOffsets_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_AlterConsumerGroupOffsets_result_t *rd_kafka_event_AlterConsumerGroupOffsets_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_ListOffsets_result_t *rd_kafka_event_ListOffsets_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DescribeUserScramCredentials_result_t *rd_kafka_event_DescribeUserScramCredentials_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_AlterUserScramCredentials_result_t *rd_kafka_event_AlterUserScramCredentials_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_ElectLeaders_result_t *rd_kafka_event_ElectLeaders_result(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_event_t *rd_kafka_queue_poll(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">int rd_kafka_queue_poll_callback(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_plugin_f_conf_init_t)(rd_kafka_conf_t *conf, void **plug_opaquep, char *errstr, size_t errstr_size);</span>
<span class="s1">typedef rd_kafka_conf_res_t (rd_kafka_interceptor_f_on_conf_set_t)(rd_kafka_conf_t *conf, const char *name, const char *val, char *errstr, size_t errstr_size, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_dup_t)(rd_kafka_conf_t *new_conf, const rd_kafka_conf_t *old_conf, size_t filter_cnt, const char **filter, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_destroy_t)(void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_new_t)(rd_kafka_t *rk, const rd_kafka_conf_t *conf, void *ic_opaque, char *errstr, size_t errstr_size);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_destroy_t)(rd_kafka_t *rk, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_send_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_acknowledgement_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_consume_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_commit_t)(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_resp_err_t err, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_request_sent_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_response_received_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, int64_t rtt, rd_kafka_resp_err_t err, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_start_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_exit_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_broker_state_change_t)(rd_kafka_t *rk, int32_t broker_id, const char *secproto, const char *name, int port, const char *state, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_set(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_set_t *on_conf_set, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_dup(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_dup_t *on_conf_dup, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_destroy(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_destroy_t *on_conf_destroy, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_new(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_new_t *on_new, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_destroy(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_destroy_t *on_destroy, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_send(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_send_t *on_send, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_acknowledgement(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_acknowledgement_t *on_acknowledgement, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_consume(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_consume_t *on_consume, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_commit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_commit_t *on_commit, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_request_sent(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_request_sent_t *on_request_sent, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_response_received(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_response_received_t *on_response_received, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_start(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_start_t *on_thread_start, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_exit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_exit_t *on_thread_exit, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_broker_state_change(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_broker_state_change_t *on_broker_state_change, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_topic_result_error(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">const char *rd_kafka_topic_result_error_string(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">const char *rd_kafka_topic_result_name(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">const rd_kafka_error_t *rd_kafka_group_result_error(const rd_kafka_group_result_t *groupres);</span>
<span class="s1">const char *rd_kafka_group_result_name(const rd_kafka_group_result_t *groupres);</span>
<span class="s1">const rd_kafka_topic_partition_list_t *rd_kafka_group_result_partitions(const rd_kafka_group_result_t *groupres);</span>
<span class="s1">const rd_kafka_topic_partition_t *rd_kafka_topic_partition_result_partition(const rd_kafka_topic_partition_result_t *partition_result);</span>
<span class="s1">const rd_kafka_error_t *rd_kafka_topic_partition_result_error(const rd_kafka_topic_partition_result_t *partition_result);</span>
<span class="s1">typedef enum rd_kafka_admin_op_t {</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_ANY = 0,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_CREATETOPICS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DELETETOPICS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_CREATEPARTITIONS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_ALTERCONFIGS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DESCRIBECONFIGS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DELETERECORDS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DELETEGROUPS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DELETECONSUMERGROUPOFFSETS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_CREATEACLS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DESCRIBEACLS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DELETEACLS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_LISTCONSUMERGROUPS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DESCRIBECONSUMERGROUPS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_LISTCONSUMERGROUPOFFSETS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_ALTERCONSUMERGROUPOFFSETS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_INCREMENTALALTERCONFIGS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DESCRIBEUSERSCRAMCREDENTIALS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_ALTERUSERSCRAMCREDENTIALS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DESCRIBETOPICS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DESCRIBECLUSTER,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_LISTOFFSETS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_ELECTLEADERS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP__CNT,</span>
<span class="s1">} rd_kafka_admin_op_t;</span>
<span class="s1">typedef struct rd_kafka_AdminOptions_s rd_kafka_AdminOptions_t;</span>
<span class="s1">typedef enum rd_kafka_IsolationLevel_t {</span>
<span class="s1">  RD_KAFKA_ISOLATION_LEVEL_READ_UNCOMMITTED = 0,</span>
<span class="s1">  RD_KAFKA_ISOLATION_LEVEL_READ_COMMITTED = 1,</span>
<span class="s1">} rd_kafka_IsolationLevel_t;</span>
<span class="s1">rd_kafka_AdminOptions_t *rd_kafka_AdminOptions_new(rd_kafka_t *rk, rd_kafka_admin_op_t for_api);</span>
<span class="s1">void rd_kafka_AdminOptions_destroy(rd_kafka_AdminOptions_t *options);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_request_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_operation_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_validate_only(rd_kafka_AdminOptions_t *options, int true_or_false, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_broker(rd_kafka_AdminOptions_t *options, int32_t broker_id, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_AdminOptions_set_require_stable_offsets(rd_kafka_AdminOptions_t *options, int true_or_false);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_AdminOptions_set_include_authorized_operations(rd_kafka_AdminOptions_t *options, int true_or_false);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_AdminOptions_set_match_consumer_group_states(rd_kafka_AdminOptions_t *options, const rd_kafka_consumer_group_state_t *consumer_group_states, size_t consumer_group_states_cnt);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_AdminOptions_set_match_consumer_group_types(rd_kafka_AdminOptions_t *options, const rd_kafka_consumer_group_type_t *consumer_group_types, size_t consumer_group_types_cnt);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_AdminOptions_set_isolation_level(rd_kafka_AdminOptions_t *options, rd_kafka_IsolationLevel_t value);</span>
<span class="s1">void rd_kafka_AdminOptions_set_opaque(rd_kafka_AdminOptions_t *options, void *ev_opaque);</span>
<span class="s1">typedef enum rd_kafka_AclOperation_t {</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_UNKNOWN = 0,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_ANY = 1,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_ALL = 2,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_READ = 3,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_WRITE = 4,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_CREATE = 5,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_DELETE = 6,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_ALTER = 7,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_DESCRIBE = 8,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_CLUSTER_ACTION = 9,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_DESCRIBE_CONFIGS = 10,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_ALTER_CONFIGS = 11,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION_IDEMPOTENT_WRITE = 12,</span>
<span class="s1">  RD_KAFKA_ACL_OPERATION__CNT,</span>
<span class="s1">} rd_kafka_AclOperation_t;</span>
<span class="s1">typedef struct rd_kafka_NewTopic_s rd_kafka_NewTopic_t;</span>
<span class="s1">rd_kafka_NewTopic_t *rd_kafka_NewTopic_new(const char *topic, int num_partitions, int replication_factor, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_NewTopic_destroy(rd_kafka_NewTopic_t *new_topic);</span>
<span class="s1">void rd_kafka_NewTopic_destroy_array(rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewTopic_set_replica_assignment(rd_kafka_NewTopic_t *new_topic, int32_t partition, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewTopic_set_config(rd_kafka_NewTopic_t *new_topic, const char *name, const char *value);</span>
<span class="s1">void rd_kafka_CreateTopics(rd_kafka_t *rk, rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_CreateTopics_result_topics(const rd_kafka_CreateTopics_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_DeleteTopic_s rd_kafka_DeleteTopic_t;</span>
<span class="s1">rd_kafka_DeleteTopic_t *rd_kafka_DeleteTopic_new(const char *topic);</span>
<span class="s1">void rd_kafka_DeleteTopic_destroy(rd_kafka_DeleteTopic_t *del_topic);</span>
<span class="s1">void rd_kafka_DeleteTopic_destroy_array(rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt);</span>
<span class="s1">void rd_kafka_DeleteTopics(rd_kafka_t *rk, rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_DeleteTopics_result_topics(const rd_kafka_DeleteTopics_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_NewPartitions_s rd_kafka_NewPartitions_t;</span>
<span class="s1">rd_kafka_NewPartitions_t *rd_kafka_NewPartitions_new(const char *topic, size_t new_total_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_NewPartitions_destroy(rd_kafka_NewPartitions_t *new_parts);</span>
<span class="s1">void rd_kafka_NewPartitions_destroy_array(rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewPartitions_set_replica_assignment(rd_kafka_NewPartitions_t *new_parts, int32_t new_partition_idx, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_CreatePartitions(rd_kafka_t *rk, rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_CreatePartitions_result_topics(const rd_kafka_CreatePartitions_result_t *result, size_t *cntp);</span>
<span class="s1">typedef enum rd_kafka_ConfigSource_t {</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_UNKNOWN_CONFIG = 0,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_TOPIC_CONFIG = 1,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_BROKER_CONFIG = 2,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_DEFAULT_BROKER_CONFIG = 3,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_STATIC_BROKER_CONFIG = 4,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DEFAULT_CONFIG = 5,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE__CNT,</span>
<span class="s1">} rd_kafka_ConfigSource_t;</span>
<span class="s1">const char *rd_kafka_ConfigSource_name(rd_kafka_ConfigSource_t confsource);</span>
<span class="s1">typedef struct rd_kafka_ConfigEntry_s rd_kafka_ConfigEntry_t;</span>
<span class="s1">const char *rd_kafka_ConfigEntry_name(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">const char *rd_kafka_ConfigEntry_value(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">rd_kafka_ConfigSource_t rd_kafka_ConfigEntry_source(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_read_only(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_default(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_sensitive(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_synonym(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">const rd_kafka_ConfigEntry_t **rd_kafka_ConfigEntry_synonyms(const rd_kafka_ConfigEntry_t *entry, size_t *cntp);</span>
<span class="s1">typedef enum rd_kafka_ResourceType_t {</span>
<span class="s1">  RD_KAFKA_RESOURCE_UNKNOWN = 0,</span>
<span class="s1">  RD_KAFKA_RESOURCE_ANY = 1,</span>
<span class="s1">  RD_KAFKA_RESOURCE_TOPIC = 2,</span>
<span class="s1">  RD_KAFKA_RESOURCE_GROUP = 3,</span>
<span class="s1">  RD_KAFKA_RESOURCE_BROKER = 4,</span>
<span class="s1">  RD_KAFKA_RESOURCE_TRANSACTIONAL_ID = 5,</span>
<span class="s1">  RD_KAFKA_RESOURCE__CNT,</span>
<span class="s1">} rd_kafka_ResourceType_t;</span>
<span class="s1">typedef enum rd_kafka_ResourcePatternType_t {</span>
<span class="s1">  RD_KAFKA_RESOURCE_PATTERN_UNKNOWN = 0,</span>
<span class="s1">  RD_KAFKA_RESOURCE_PATTERN_ANY = 1,</span>
<span class="s1">  RD_KAFKA_RESOURCE_PATTERN_MATCH = 2,</span>
<span class="s1">  RD_KAFKA_RESOURCE_PATTERN_LITERAL = 3,</span>
<span class="s1">  RD_KAFKA_RESOURCE_PATTERN_PREFIXED = 4,</span>
<span class="s1">  RD_KAFKA_RESOURCE_PATTERN_TYPE__CNT,</span>
<span class="s1">} rd_kafka_ResourcePatternType_t;</span>
<span class="s1">typedef enum rd_kafka_AlterConfigOpType_t {</span>
<span class="s1">  RD_KAFKA_ALTER_CONFIG_OP_TYPE_SET = 0,</span>
<span class="s1">  RD_KAFKA_ALTER_CONFIG_OP_TYPE_DELETE = 1,</span>
<span class="s1">  RD_KAFKA_ALTER_CONFIG_OP_TYPE_APPEND = 2,</span>
<span class="s1">  RD_KAFKA_ALTER_CONFIG_OP_TYPE_SUBTRACT = 3,</span>
<span class="s1">  RD_KAFKA_ALTER_CONFIG_OP_TYPE__CNT,</span>
<span class="s1">} rd_kafka_AlterConfigOpType_t;</span>
<span class="s1">const char *rd_kafka_ResourcePatternType_name(rd_kafka_ResourcePatternType_t resource_pattern_type);</span>
<span class="s1">const char *rd_kafka_ResourceType_name(rd_kafka_ResourceType_t restype);</span>
<span class="s1">typedef struct rd_kafka_ConfigResource_s rd_kafka_ConfigResource_t;</span>
<span class="s1">rd_kafka_ConfigResource_t *rd_kafka_ConfigResource_new(rd_kafka_ResourceType_t restype, const char *resname);</span>
<span class="s1">void rd_kafka_ConfigResource_destroy(rd_kafka_ConfigResource_t *config);</span>
<span class="s1">void rd_kafka_ConfigResource_destroy_array(rd_kafka_ConfigResource_t **config, size_t config_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_ConfigResource_set_config(rd_kafka_ConfigResource_t *config, const char *name, const char *value);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_ConfigResource_add_incremental_config(rd_kafka_ConfigResource_t *config, const char *name, rd_kafka_AlterConfigOpType_t op_type, const char *value);</span>
<span class="s1">const rd_kafka_ConfigEntry_t **rd_kafka_ConfigResource_configs(const rd_kafka_ConfigResource_t *config, size_t *cntp);</span>
<span class="s1">rd_kafka_ResourceType_t rd_kafka_ConfigResource_type(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">const char *rd_kafka_ConfigResource_name(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_ConfigResource_error(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">const char *rd_kafka_ConfigResource_error_string(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">void rd_kafka_AlterConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_ConfigResource_t **rd_kafka_AlterConfigs_result_resources(const rd_kafka_AlterConfigs_result_t *result, size_t *cntp);</span>
<span class="s1">void rd_kafka_IncrementalAlterConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_ConfigResource_t **rd_kafka_IncrementalAlterConfigs_result_resources(const rd_kafka_IncrementalAlterConfigs_result_t *result, size_t *cntp);</span>
<span class="s1">void rd_kafka_DescribeConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_ConfigResource_t **rd_kafka_DescribeConfigs_result_resources(const rd_kafka_DescribeConfigs_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_DeleteRecords_s rd_kafka_DeleteRecords_t;</span>
<span class="s1">rd_kafka_DeleteRecords_t *rd_kafka_DeleteRecords_new(const rd_kafka_topic_partition_list_t *before_offsets);</span>
<span class="s1">void rd_kafka_DeleteRecords_destroy(rd_kafka_DeleteRecords_t *del_records);</span>
<span class="s1">void rd_kafka_DeleteRecords_destroy_array(rd_kafka_DeleteRecords_t **del_records, size_t del_record_cnt);</span>
<span class="s1">void rd_kafka_DeleteRecords(rd_kafka_t *rk, rd_kafka_DeleteRecords_t **del_records, size_t del_record_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_partition_list_t *rd_kafka_DeleteRecords_result_offsets(const rd_kafka_DeleteRecords_result_t *result);</span>
<span class="s1">typedef struct rd_kafka_TopicCollection_s rd_kafka_TopicCollection_t;</span>
<span class="s1">typedef struct rd_kafka_TopicPartitionInfo_s rd_kafka_TopicPartitionInfo_t;</span>
<span class="s1">typedef struct rd_kafka_TopicDescription_s rd_kafka_TopicDescription_t;</span>
<span class="s1">rd_kafka_TopicCollection_t *rd_kafka_TopicCollection_of_topic_names(const char **topics, size_t topics_cnt);</span>
<span class="s1">void rd_kafka_TopicCollection_destroy(rd_kafka_TopicCollection_t *topics);</span>
<span class="s1">void rd_kafka_DescribeTopics(rd_kafka_t *rk, const rd_kafka_TopicCollection_t *topics, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_TopicDescription_t **rd_kafka_DescribeTopics_result_topics(const rd_kafka_DescribeTopics_result_t *result, size_t *cntp);</span>
<span class="s1">const rd_kafka_TopicPartitionInfo_t **rd_kafka_TopicDescription_partitions(const rd_kafka_TopicDescription_t *topicdesc, size_t *cntp);</span>
<span class="s1">const int rd_kafka_TopicPartitionInfo_partition(const rd_kafka_TopicPartitionInfo_t *partition);</span>
<span class="s1">const rd_kafka_Node_t *rd_kafka_TopicPartitionInfo_leader(const rd_kafka_TopicPartitionInfo_t *partition);</span>
<span class="s1">const rd_kafka_Node_t **rd_kafka_TopicPartitionInfo_isr(const rd_kafka_TopicPartitionInfo_t *partition, size_t *cntp);</span>
<span class="s1">const rd_kafka_Node_t **rd_kafka_TopicPartitionInfo_replicas(const rd_kafka_TopicPartitionInfo_t *partition, size_t *cntp);</span>
<span class="s1">const rd_kafka_AclOperation_t *rd_kafka_TopicDescription_authorized_operations(const rd_kafka_TopicDescription_t *topicdesc, size_t *cntp);</span>
<span class="s1">const char *rd_kafka_TopicDescription_name(const rd_kafka_TopicDescription_t *topicdesc);</span>
<span class="s1">const rd_kafka_Uuid_t *rd_kafka_TopicDescription_topic_id(const rd_kafka_TopicDescription_t *topicdesc);</span>
<span class="s1">int rd_kafka_TopicDescription_is_internal(const rd_kafka_TopicDescription_t *topicdesc);</span>
<span class="s1">const rd_kafka_error_t *rd_kafka_TopicDescription_error(const rd_kafka_TopicDescription_t *topicdesc);</span>
<span class="s1">void rd_kafka_DescribeCluster(rd_kafka_t *rk, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_Node_t **rd_kafka_DescribeCluster_result_nodes(const rd_kafka_DescribeCluster_result_t *result, size_t *cntp);</span>
<span class="s1">const rd_kafka_AclOperation_t *rd_kafka_DescribeCluster_result_authorized_operations(const rd_kafka_DescribeCluster_result_t *result, size_t *cntp);</span>
<span class="s1">const rd_kafka_Node_t *rd_kafka_DescribeCluster_result_controller(const rd_kafka_DescribeCluster_result_t *result);</span>
<span class="s1">const char *rd_kafka_DescribeCluster_result_cluster_id(const rd_kafka_DescribeCluster_result_t *result);</span>
<span class="s1">typedef struct rd_kafka_ConsumerGroupListing_s rd_kafka_ConsumerGroupListing_t;</span>
<span class="s1">typedef struct rd_kafka_ListConsumerGroupsResult_s rd_kafka_ListConsumerGroupsResult_t;</span>
<span class="s1">void rd_kafka_ListConsumerGroups(rd_kafka_t *rk, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const char *rd_kafka_ConsumerGroupListing_group_id(const rd_kafka_ConsumerGroupListing_t *grplist);</span>
<span class="s1">int rd_kafka_ConsumerGroupListing_is_simple_consumer_group(const rd_kafka_ConsumerGroupListing_t *grplist);</span>
<span class="s1">rd_kafka_consumer_group_state_t rd_kafka_ConsumerGroupListing_state(const rd_kafka_ConsumerGroupListing_t *grplist);</span>
<span class="s1">rd_kafka_consumer_group_type_t rd_kafka_ConsumerGroupListing_type(const rd_kafka_ConsumerGroupListing_t *grplist);</span>
<span class="s1">const rd_kafka_ConsumerGroupListing_t **rd_kafka_ListConsumerGroups_result_valid(const rd_kafka_ListConsumerGroups_result_t *result, size_t *cntp);</span>
<span class="s1">const rd_kafka_error_t **rd_kafka_ListConsumerGroups_result_errors(const rd_kafka_ListConsumerGroups_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_ConsumerGroupDescription_s rd_kafka_ConsumerGroupDescription_t;</span>
<span class="s1">typedef struct rd_kafka_MemberDescription_s rd_kafka_MemberDescription_t;</span>
<span class="s1">typedef struct rd_kafka_MemberAssignment_s rd_kafka_MemberAssignment_t;</span>
<span class="s1">void rd_kafka_DescribeConsumerGroups(rd_kafka_t *rk, const char **groups, size_t groups_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_ConsumerGroupDescription_t **rd_kafka_DescribeConsumerGroups_result_groups(const rd_kafka_DescribeConsumerGroups_result_t *result, size_t *cntp);</span>
<span class="s1">const char *rd_kafka_ConsumerGroupDescription_group_id(const rd_kafka_ConsumerGroupDescription_t *grpdesc);</span>
<span class="s1">const rd_kafka_error_t *rd_kafka_ConsumerGroupDescription_error(const rd_kafka_ConsumerGroupDescription_t *grpdesc);</span>
<span class="s1">int rd_kafka_ConsumerGroupDescription_is_simple_consumer_group(const rd_kafka_ConsumerGroupDescription_t *grpdesc);</span>
<span class="s1">const char *rd_kafka_ConsumerGroupDescription_partition_assignor(const rd_kafka_ConsumerGroupDescription_t *grpdesc);</span>
<span class="s1">const rd_kafka_AclOperation_t *rd_kafka_ConsumerGroupDescription_authorized_operations(const rd_kafka_ConsumerGroupDescription_t *grpdesc, size_t *cntp);</span>
<span class="s1">rd_kafka_consumer_group_state_t rd_kafka_ConsumerGroupDescription_state(const rd_kafka_ConsumerGroupDescription_t *grpdesc);</span>
<span class="s1">const rd_kafka_Node_t *rd_kafka_ConsumerGroupDescription_coordinator(const rd_kafka_ConsumerGroupDescription_t *grpdesc);</span>
<span class="s1">size_t rd_kafka_ConsumerGroupDescription_member_count(const rd_kafka_ConsumerGroupDescription_t *grpdesc);</span>
<span class="s1">const rd_kafka_MemberDescription_t *rd_kafka_ConsumerGroupDescription_member(const rd_kafka_ConsumerGroupDescription_t *grpdesc, size_t idx);</span>
<span class="s1">const char *rd_kafka_MemberDescription_client_id(const rd_kafka_MemberDescription_t *member);</span>
<span class="s1">const char *rd_kafka_MemberDescription_group_instance_id(const rd_kafka_MemberDescription_t *member);</span>
<span class="s1">const char *rd_kafka_MemberDescription_consumer_id(const rd_kafka_MemberDescription_t *member);</span>
<span class="s1">const char *rd_kafka_MemberDescription_host(const rd_kafka_MemberDescription_t *member);</span>
<span class="s1">const rd_kafka_MemberAssignment_t *rd_kafka_MemberDescription_assignment(const rd_kafka_MemberDescription_t *member);</span>
<span class="s1">const rd_kafka_topic_partition_list_t *rd_kafka_MemberAssignment_partitions(const rd_kafka_MemberAssignment_t *assignment);</span>
<span class="s1">typedef struct rd_kafka_DeleteGroup_s rd_kafka_DeleteGroup_t;</span>
<span class="s1">rd_kafka_DeleteGroup_t *rd_kafka_DeleteGroup_new(const char *group);</span>
<span class="s1">void rd_kafka_DeleteGroup_destroy(rd_kafka_DeleteGroup_t *del_group);</span>
<span class="s1">void rd_kafka_DeleteGroup_destroy_array(rd_kafka_DeleteGroup_t **del_groups, size_t del_group_cnt);</span>
<span class="s1">void rd_kafka_DeleteGroups(rd_kafka_t *rk, rd_kafka_DeleteGroup_t **del_groups, size_t del_group_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_group_result_t **rd_kafka_DeleteGroups_result_groups(const rd_kafka_DeleteGroups_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_ListConsumerGroupOffsets_s rd_kafka_ListConsumerGroupOffsets_t;</span>
<span class="s1">rd_kafka_ListConsumerGroupOffsets_t *rd_kafka_ListConsumerGroupOffsets_new(const char *group_id, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">void rd_kafka_ListConsumerGroupOffsets_destroy(rd_kafka_ListConsumerGroupOffsets_t *list_grpoffsets);</span>
<span class="s1">void rd_kafka_ListConsumerGroupOffsets_destroy_array(rd_kafka_ListConsumerGroupOffsets_t **list_grpoffsets, size_t list_grpoffset_cnt);</span>
<span class="s1">void rd_kafka_ListConsumerGroupOffsets(rd_kafka_t *rk, rd_kafka_ListConsumerGroupOffsets_t **list_grpoffsets, size_t list_grpoffsets_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_group_result_t **rd_kafka_ListConsumerGroupOffsets_result_groups(const rd_kafka_ListConsumerGroupOffsets_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_AlterConsumerGroupOffsets_s rd_kafka_AlterConsumerGroupOffsets_t;</span>
<span class="s1">rd_kafka_AlterConsumerGroupOffsets_t *rd_kafka_AlterConsumerGroupOffsets_new(const char *group_id, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">void rd_kafka_AlterConsumerGroupOffsets_destroy(rd_kafka_AlterConsumerGroupOffsets_t *alter_grpoffsets);</span>
<span class="s1">void rd_kafka_AlterConsumerGroupOffsets_destroy_array(rd_kafka_AlterConsumerGroupOffsets_t **alter_grpoffsets, size_t alter_grpoffset_cnt);</span>
<span class="s1">void rd_kafka_AlterConsumerGroupOffsets(rd_kafka_t *rk, rd_kafka_AlterConsumerGroupOffsets_t **alter_grpoffsets, size_t alter_grpoffsets_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_group_result_t **rd_kafka_AlterConsumerGroupOffsets_result_groups(const rd_kafka_AlterConsumerGroupOffsets_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_DeleteConsumerGroupOffsets_s rd_kafka_DeleteConsumerGroupOffsets_t;</span>
<span class="s1">rd_kafka_DeleteConsumerGroupOffsets_t *rd_kafka_DeleteConsumerGroupOffsets_new(const char *group, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">void rd_kafka_DeleteConsumerGroupOffsets_destroy(rd_kafka_DeleteConsumerGroupOffsets_t *del_grpoffsets);</span>
<span class="s1">void rd_kafka_DeleteConsumerGroupOffsets_destroy_array(rd_kafka_DeleteConsumerGroupOffsets_t **del_grpoffsets, size_t del_grpoffset_cnt);</span>
<span class="s1">void rd_kafka_DeleteConsumerGroupOffsets(rd_kafka_t *rk, rd_kafka_DeleteConsumerGroupOffsets_t **del_grpoffsets, size_t del_grpoffsets_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_group_result_t **rd_kafka_DeleteConsumerGroupOffsets_result_groups(const rd_kafka_DeleteConsumerGroupOffsets_result_t *result, size_t *cntp);</span>
<span class="s1">typedef enum rd_kafka_OffsetSpec_t {</span>
<span class="s1">  RD_KAFKA_OFFSET_SPEC_MAX_TIMESTAMP = (- 3),</span>
<span class="s1">  RD_KAFKA_OFFSET_SPEC_EARLIEST = (- 2),</span>
<span class="s1">  RD_KAFKA_OFFSET_SPEC_LATEST = (- 1),</span>
<span class="s1">} rd_kafka_OffsetSpec_t;</span>
<span class="s1">typedef struct rd_kafka_ListOffsetsResultInfo_s rd_kafka_ListOffsetsResultInfo_t;</span>
<span class="s1">const rd_kafka_topic_partition_t *rd_kafka_ListOffsetsResultInfo_topic_partition(const rd_kafka_ListOffsetsResultInfo_t *result_info);</span>
<span class="s1">int64_t rd_kafka_ListOffsetsResultInfo_timestamp(const rd_kafka_ListOffsetsResultInfo_t *result_info);</span>
<span class="s1">const rd_kafka_ListOffsetsResultInfo_t **rd_kafka_ListOffsets_result_infos(const rd_kafka_ListOffsets_result_t *result, size_t *cntp);</span>
<span class="s1">void rd_kafka_ListOffsets(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *topic_partitions, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">typedef enum rd_kafka_ScramMechanism_t {</span>
<span class="s1">  RD_KAFKA_SCRAM_MECHANISM_UNKNOWN = 0,</span>
<span class="s1">  RD_KAFKA_SCRAM_MECHANISM_SHA_256 = 1,</span>
<span class="s1">  RD_KAFKA_SCRAM_MECHANISM_SHA_512 = 2,</span>
<span class="s1">  RD_KAFKA_SCRAM_MECHANISM__CNT,</span>
<span class="s1">} rd_kafka_ScramMechanism_t;</span>
<span class="s1">typedef struct rd_kafka_ScramCredentialInfo_s rd_kafka_ScramCredentialInfo_t;</span>
<span class="s1">rd_kafka_ScramMechanism_t rd_kafka_ScramCredentialInfo_mechanism(const rd_kafka_ScramCredentialInfo_t *scram_credential_info);</span>
<span class="s1">int32_t rd_kafka_ScramCredentialInfo_iterations(const rd_kafka_ScramCredentialInfo_t *scram_credential_info);</span>
<span class="s1">typedef struct rd_kafka_UserScramCredentialsDescription_s rd_kafka_UserScramCredentialsDescription_t;</span>
<span class="s1">const char *rd_kafka_UserScramCredentialsDescription_user(const rd_kafka_UserScramCredentialsDescription_t *description);</span>
<span class="s1">const rd_kafka_error_t *rd_kafka_UserScramCredentialsDescription_error(const rd_kafka_UserScramCredentialsDescription_t *description);</span>
<span class="s1">size_t rd_kafka_UserScramCredentialsDescription_scramcredentialinfo_count(const rd_kafka_UserScramCredentialsDescription_t *description);</span>
<span class="s1">const rd_kafka_ScramCredentialInfo_t *rd_kafka_UserScramCredentialsDescription_scramcredentialinfo(const rd_kafka_UserScramCredentialsDescription_t *description, size_t idx);</span>
<span class="s1">const rd_kafka_UserScramCredentialsDescription_t **rd_kafka_DescribeUserScramCredentials_result_descriptions(const rd_kafka_DescribeUserScramCredentials_result_t *result, size_t *cntp);</span>
<span class="s1">void rd_kafka_DescribeUserScramCredentials(rd_kafka_t *rk, const char **users, size_t user_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">typedef struct rd_kafka_UserScramCredentialAlteration_s rd_kafka_UserScramCredentialAlteration_t;</span>
<span class="s1">rd_kafka_UserScramCredentialAlteration_t *rd_kafka_UserScramCredentialUpsertion_new(const char *username, rd_kafka_ScramMechanism_t mechanism, int32_t iterations, const unsigned char *password, size_t password_size, const unsigned char *salt, size_t salt_size);</span>
<span class="s1">rd_kafka_UserScramCredentialAlteration_t *rd_kafka_UserScramCredentialDeletion_new(const char *username, rd_kafka_ScramMechanism_t mechanism);</span>
<span class="s1">void rd_kafka_UserScramCredentialAlteration_destroy(rd_kafka_UserScramCredentialAlteration_t *alteration);</span>
<span class="s1">void rd_kafka_UserScramCredentialAlteration_destroy_array(rd_kafka_UserScramCredentialAlteration_t **alterations, size_t alteration_cnt);</span>
<span class="s1">typedef struct rd_kafka_AlterUserScramCredentials_result_response_s rd_kafka_AlterUserScramCredentials_result_response_t;</span>
<span class="s1">const char *rd_kafka_AlterUserScramCredentials_result_response_user(const rd_kafka_AlterUserScramCredentials_result_response_t *response);</span>
<span class="s1">const rd_kafka_error_t *rd_kafka_AlterUserScramCredentials_result_response_error(const rd_kafka_AlterUserScramCredentials_result_response_t *response);</span>
<span class="s1">const rd_kafka_AlterUserScramCredentials_result_response_t **rd_kafka_AlterUserScramCredentials_result_responses(const rd_kafka_AlterUserScramCredentials_result_t *result, size_t *cntp);</span>
<span class="s1">void rd_kafka_AlterUserScramCredentials(rd_kafka_t *rk, rd_kafka_UserScramCredentialAlteration_t **alterations, size_t alteration_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">typedef struct rd_kafka_AclBinding_s rd_kafka_AclBinding_t;</span>
<span class="s1">typedef rd_kafka_AclBinding_t rd_kafka_AclBindingFilter_t;</span>
<span class="s1">const rd_kafka_error_t *rd_kafka_acl_result_error(const rd_kafka_acl_result_t *aclres);</span>
<span class="s1">const char *rd_kafka_AclOperation_name(rd_kafka_AclOperation_t acl_operation);</span>
<span class="s1">typedef enum rd_kafka_AclPermissionType_t {</span>
<span class="s1">  RD_KAFKA_ACL_PERMISSION_TYPE_UNKNOWN = 0,</span>
<span class="s1">  RD_KAFKA_ACL_PERMISSION_TYPE_ANY = 1,</span>
<span class="s1">  RD_KAFKA_ACL_PERMISSION_TYPE_DENY = 2,</span>
<span class="s1">  RD_KAFKA_ACL_PERMISSION_TYPE_ALLOW = 3,</span>
<span class="s1">  RD_KAFKA_ACL_PERMISSION_TYPE__CNT,</span>
<span class="s1">} rd_kafka_AclPermissionType_t;</span>
<span class="s1">const char *rd_kafka_AclPermissionType_name(rd_kafka_AclPermissionType_t acl_permission_type);</span>
<span class="s1">rd_kafka_AclBinding_t *rd_kafka_AclBinding_new(rd_kafka_ResourceType_t restype, const char *name, rd_kafka_ResourcePatternType_t resource_pattern_type, const char *principal, const char *host, rd_kafka_AclOperation_t operation, rd_kafka_AclPermissionType_t permission_type, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_AclBindingFilter_t *rd_kafka_AclBindingFilter_new(rd_kafka_ResourceType_t restype, const char *name, rd_kafka_ResourcePatternType_t resource_pattern_type, const char *principal, const char *host, rd_kafka_AclOperation_t operation, rd_kafka_AclPermissionType_t permission_type, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_ResourceType_t rd_kafka_AclBinding_restype(const rd_kafka_AclBinding_t *acl);</span>
<span class="s1">const char *rd_kafka_AclBinding_name(const rd_kafka_AclBinding_t *acl);</span>
<span class="s1">const char *rd_kafka_AclBinding_principal(const rd_kafka_AclBinding_t *acl);</span>
<span class="s1">const char *rd_kafka_AclBinding_host(const rd_kafka_AclBinding_t *acl);</span>
<span class="s1">rd_kafka_AclOperation_t rd_kafka_AclBinding_operation(const rd_kafka_AclBinding_t *acl);</span>
<span class="s1">rd_kafka_AclPermissionType_t rd_kafka_AclBinding_permission_type(const rd_kafka_AclBinding_t *acl);</span>
<span class="s1">rd_kafka_ResourcePatternType_t rd_kafka_AclBinding_resource_pattern_type(const rd_kafka_AclBinding_t *acl);</span>
<span class="s1">const rd_kafka_error_t *rd_kafka_AclBinding_error(const rd_kafka_AclBinding_t *acl);</span>
<span class="s1">void rd_kafka_AclBinding_destroy(rd_kafka_AclBinding_t *acl_binding);</span>
<span class="s1">void rd_kafka_AclBinding_destroy_array(rd_kafka_AclBinding_t **acl_bindings, size_t acl_bindings_cnt);</span>
<span class="s1">const rd_kafka_acl_result_t **rd_kafka_CreateAcls_result_acls(const rd_kafka_CreateAcls_result_t *result, size_t *cntp);</span>
<span class="s1">void rd_kafka_CreateAcls(rd_kafka_t *rk, rd_kafka_AclBinding_t **new_acls, size_t new_acls_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_AclBinding_t **rd_kafka_DescribeAcls_result_acls(const rd_kafka_DescribeAcls_result_t *result, size_t *cntp);</span>
<span class="s1">void rd_kafka_DescribeAcls(rd_kafka_t *rk, rd_kafka_AclBindingFilter_t *acl_filter, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">typedef struct rd_kafka_DeleteAcls_result_response_s rd_kafka_DeleteAcls_result_response_t;</span>
<span class="s1">const rd_kafka_DeleteAcls_result_response_t **rd_kafka_DeleteAcls_result_responses(const rd_kafka_DeleteAcls_result_t *result, size_t *cntp);</span>
<span class="s1">const rd_kafka_error_t *rd_kafka_DeleteAcls_result_response_error(const rd_kafka_DeleteAcls_result_response_t *result_response);</span>
<span class="s1">const rd_kafka_AclBinding_t **rd_kafka_DeleteAcls_result_response_matching_acls(const rd_kafka_DeleteAcls_result_response_t *result_response, size_t *matching_acls_cntp);</span>
<span class="s1">void rd_kafka_DeleteAcls(rd_kafka_t *rk, rd_kafka_AclBindingFilter_t **del_acls, size_t del_acls_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">typedef struct rd_kafka_ElectLeaders_s rd_kafka_ElectLeaders_t;</span>
<span class="s1">typedef enum rd_kafka_ElectionType_t {</span>
<span class="s1">  RD_KAFKA_ELECTION_TYPE_PREFERRED = 0,</span>
<span class="s1">  RD_KAFKA_ELECTION_TYPE_UNCLEAN = 1,</span>
<span class="s1">} rd_kafka_ElectionType_t;</span>
<span class="s1">rd_kafka_ElectLeaders_t *rd_kafka_ElectLeaders_new(rd_kafka_ElectionType_t election_type, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">void rd_kafka_ElectLeaders_destroy(rd_kafka_ElectLeaders_t *elect_leaders);</span>
<span class="s1">void rd_kafka_ElectLeaders(rd_kafka_t *rk, rd_kafka_ElectLeaders_t *elect_leaders, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_partition_result_t **rd_kafka_ElectLeaders_result_partitions(const rd_kafka_ElectLeaders_result_t *result, size_t *cntp);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token(rd_kafka_t *rk, const char *token_value, int64_t md_lifetime_ms, const char *md_principal_name, const char **extensions, size_t extension_size, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token_failure(rd_kafka_t *rk, const char *errstr);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_init_transactions(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_begin_transaction(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_send_offsets_to_transaction(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, const rd_kafka_consumer_group_metadata_t *cgmetadata, int timeout_ms);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_commit_transaction(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_abort_transaction(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">typedef struct rd_kafka_mock_cluster_s rd_kafka_mock_cluster_t;</span>
<span class="s1">rd_kafka_mock_cluster_t *rd_kafka_mock_cluster_new(rd_kafka_t *rk, int broker_cnt);</span>
<span class="s1">void rd_kafka_mock_cluster_destroy(rd_kafka_mock_cluster_t *mcluster);</span>
<span class="s1">rd_kafka_t *rd_kafka_mock_cluster_handle(const rd_kafka_mock_cluster_t *mcluster);</span>
<span class="s1">rd_kafka_mock_cluster_t *rd_kafka_handle_mock_cluster(const rd_kafka_t *rk);</span>
<span class="s1">const char *rd_kafka_mock_cluster_bootstraps(const rd_kafka_mock_cluster_t *mcluster);</span>
<span class="s1">void rd_kafka_mock_clear_request_errors(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey);</span>
<span class="s1">void rd_kafka_mock_push_request_errors(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, size_t cnt, ...);</span>
<span class="s1">void rd_kafka_mock_push_request_errors_array(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, size_t cnt, const rd_kafka_resp_err_t *errors);</span>
<span class="s1">void rd_kafka_mock_group_initial_rebalance_delay_ms(rd_kafka_mock_cluster_t *mcluster, int32_t delay_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_push_request_error_rtts(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int16_t ApiKey, size_t cnt, ...);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_error_stack_cnt(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int16_t ApiKey, size_t *cntp);</span>
<span class="s1">void rd_kafka_mock_topic_set_error(rd_kafka_mock_cluster_t *mcluster, const char *topic, rd_kafka_resp_err_t err);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_topic_create(rd_kafka_mock_cluster_t *mcluster, const char *topic, int partition_cnt, int replication_factor);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_partition_set_leader(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_partition_set_follower(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_partition_set_follower_wmarks(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int64_t lo, int64_t hi);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_partition_push_leader_response(rd_kafka_mock_cluster_t *mcluster, const char *topic, int partition, int32_t leader_id, int32_t leader_epoch);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_set_down(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_set_up(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_set_rtt(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int rtt_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_set_rack(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, const char *rack);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_coordinator_set(rd_kafka_mock_cluster_t *mcluster, const char *key_type, const char *key, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_set_apiversion(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, int16_t MinVersion, int16_t MaxVersion);</span>
<span class="s1">void rd_kafka_mock_start_request_tracking(rd_kafka_mock_cluster_t *mcluster);</span>
<span class="s1">void rd_kafka_mock_stop_request_tracking(rd_kafka_mock_cluster_t *mcluster);</span>
<span class="s1">typedef struct rd_kafka_mock_request_s rd_kafka_mock_request_t;</span>
<span class="s1">void rd_kafka_mock_request_destroy(rd_kafka_mock_request_t *mreq);</span>
<span class="s1">void rd_kafka_mock_request_destroy_array(rd_kafka_mock_request_t **mreqs, size_t mreq_cnt);</span>
<span class="s1">int32_t rd_kafka_mock_request_id(rd_kafka_mock_request_t *mreq);</span>
<span class="s1">int16_t rd_kafka_mock_request_api_key(rd_kafka_mock_request_t *mreq);</span>
<span class="s1">int64_t rd_kafka_mock_request_timestamp(rd_kafka_mock_request_t *mreq);</span>
<span class="s1">rd_kafka_mock_request_t **rd_kafka_mock_get_requests(rd_kafka_mock_cluster_t *mcluster, size_t *cntp);</span>
<span class="s1">void rd_kafka_mock_clear_requests(rd_kafka_mock_cluster_t *mcluster);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_telemetry_set_requested_metrics(rd_kafka_mock_cluster_t *mcluster, char **metrics, size_t metrics_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_telemetry_set_push_interval(rd_kafka_mock_cluster_t *mcluster, int64_t push_interval_ms);</span>
<span class="s1">typedef struct rd_kafka_mock_cgrp_consumer_target_assignment_s rd_kafka_mock_cgrp_consumer_target_assignment_t;</span>
<span class="s1">rd_kafka_mock_cgrp_consumer_target_assignment_t *rd_kafka_mock_cgrp_consumer_target_assignment_new(char **member_ids, int member_cnt, rd_kafka_topic_partition_list_t **assignment);</span>
<span class="s1">void rd_kafka_mock_cgrp_consumer_target_assignment_destroy(rd_kafka_mock_cgrp_consumer_target_assignment_t *target_assignment);</span>
<span class="s1">void rd_kafka_mock_cgrp_consumer_target_assignment(rd_kafka_mock_cluster_t *mcluster, const char *group_id, rd_kafka_mock_cgrp_consumer_target_assignment_t *target_assignment);</span>
<span class="s1">void rd_kafka_mock_set_group_consumer_session_timeout_ms(rd_kafka_mock_cluster_t *mcluster, int group_consumer_session_timeout_ms);</span>
<span class="s1">void rd_kafka_mock_set_group_consumer_heartbeat_interval_ms(rd_kafka_mock_cluster_t *mcluster, int group_consumer_heartbeat_interval_ms);</span>
<span class="s1">&#39;</span>
</code></pre></div>
rdkafka.h, rdkafka_mock.h</p>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
    <div class="md-copyright__highlight">
      Copyright &copy; idealo internet GmbH.
    </div>
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "../..", "features": ["navigation.tabs", "navigation.indexes"], "search": "../../assets/javascripts/workers/search.f8cc74c7.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../../assets/javascripts/bundle.60a45f97.min.js"></script>
      
    
  </body>
</html>